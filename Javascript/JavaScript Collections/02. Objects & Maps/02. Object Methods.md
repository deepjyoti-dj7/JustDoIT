# Object Methods

## Object.keys()

### Get Property Names
```javascript
const person = {name: 'John', age: 30, city: 'NYC'};

const keys = Object.keys(person);
console.log(keys);  // ['name', 'age', 'city']

// Iterate over keys
Object.keys(person).forEach(key => {
  console.log(`${key}: ${person[key]}`);
});
```

### Own Properties Only
```javascript
const proto = {inherited: true};
const obj = Object.create(proto);
obj.own = 'value';

console.log(Object.keys(obj));  // ['own'] (not 'inherited')
console.log('inherited' in obj);  // true
```

## Object.values()

### Get Property Values
```javascript
const person = {name: 'John', age: 30, city: 'NYC'};

const values = Object.values(person);
console.log(values);  // ['John', 30, 'NYC']

// Sum numeric values
const scores = {math: 90, english: 85, science: 92};
const total = Object.values(scores).reduce((sum, score) => sum + score, 0);
console.log(total);  // 267
```

## Object.entries()

### Get Key-Value Pairs
```javascript
const person = {name: 'John', age: 30, city: 'NYC'};

const entries = Object.entries(person);
console.log(entries);
// [['name', 'John'], ['age', 30], ['city', 'NYC']]

// Iterate with destructuring
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`);
}
```

### Transform to Map
```javascript
const obj = {a: 1, b: 2, c: 3};
const map = new Map(Object.entries(obj));

console.log(map.get('a'));  // 1
```

### Filter Object
```javascript
const person = {name: 'John', age: 30, city: 'NYC', country: 'USA'};

// Keep only specific properties
const filtered = Object.fromEntries(
  Object.entries(person).filter(([key]) => key !== 'country')
);
console.log(filtered);  // {name: 'John', age: 30, city: 'NYC'}
```

## Object.assign()

### Copy Properties
```javascript
const target = {a: 1, b: 2};
const source = {b: 3, c: 4};

Object.assign(target, source);
console.log(target);  // {a: 1, b: 3, c: 4} (b was overwritten)
```

### Clone Object (Shallow)
```javascript
const original = {name: 'John', age: 30};
const clone = Object.assign({}, original);

clone.age = 25;
console.log(original.age);  // 30
console.log(clone.age);     // 25
```

### Merge Multiple Objects
```javascript
const defaults = {theme: 'light', lang: 'en'};
const userPrefs = {theme: 'dark'};
const sessionPrefs = {fontSize: 14};

const config = Object.assign({}, defaults, userPrefs, sessionPrefs);
console.log(config);
// {theme: 'dark', lang: 'en', fontSize: 14}
```

### Shallow Copy Limitation
```javascript
const original = {
  name: 'John',
  address: {city: 'NYC'}
};

const clone = Object.assign({}, original);
clone.address.city = 'LA';

console.log(original.address.city);  // 'LA' (nested object shared!)
```

## Object.freeze() & seal()

### Object.freeze() - Immutable
```javascript
const obj = {name: 'John', age: 30};
Object.freeze(obj);

obj.age = 25;           // Silently fails
obj.city = 'NYC';       // Cannot add
delete obj.name;        // Cannot delete

console.log(obj);       // {name: 'John', age: 30}

// Check if frozen
console.log(Object.isFrozen(obj));  // true
```

### Shallow Freeze
```javascript
const obj = {
  name: 'John',
  address: {city: 'NYC'}
};

Object.freeze(obj);

obj.name = 'Jane';           // Fails
obj.address.city = 'LA';     // Works! (nested not frozen)
console.log(obj.address.city);  // 'LA'
```

### Deep Freeze
```javascript
function deepFreeze(obj) {
  Object.freeze(obj);
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  return obj;
}

const obj = {name: 'John', address: {city: 'NYC'}};
deepFreeze(obj);

obj.address.city = 'LA';  // Fails
```

### Object.seal() - Prevent Add/Delete
```javascript
const obj = {name: 'John', age: 30};
Object.seal(obj);

obj.age = 25;           // Works (can modify)
obj.city = 'NYC';       // Fails (cannot add)
delete obj.name;        // Fails (cannot delete)

console.log(obj);       // {name: 'John', age: 25}
console.log(Object.isSealed(obj));  // true
```

### Freeze vs Seal Comparison
```javascript
const frozen = Object.freeze({a: 1});
const sealed = Object.seal({b: 2});

frozen.a = 10;    // Fails
sealed.b = 20;    // Works

frozen.c = 3;     // Fails
sealed.c = 3;     // Fails

delete frozen.a;  // Fails
delete sealed.b;  // Fails
```

## Object.fromEntries()

### Array of Entries to Object
```javascript
const entries = [['name', 'John'], ['age', 30]];
const obj = Object.fromEntries(entries);
console.log(obj);  // {name: 'John', age: 30}
```

### Map to Object
```javascript
const map = new Map([
  ['name', 'John'],
  ['age', 30]
]);

const obj = Object.fromEntries(map);
console.log(obj);  // {name: 'John', age: 30}
```

### Transform Object Values
```javascript
const prices = {apple: 1.5, banana: 0.8, orange: 1.2};

const doubled = Object.fromEntries(
  Object.entries(prices).map(([fruit, price]) => [fruit, price * 2])
);

console.log(doubled);
// {apple: 3, banana: 1.6, orange: 2.4}
```

### Query String to Object
```javascript
const queryString = 'name=John&age=30&city=NYC';

const params = Object.fromEntries(
  new URLSearchParams(queryString)
);

console.log(params);
// {name: 'John', age: '30', city: 'NYC'}
```

## Object.hasOwn() (ES2022)

### Safer hasOwnProperty()
```javascript
const obj = {name: 'John'};

// Old way (can fail if hasOwnProperty is overridden)
console.log(obj.hasOwnProperty('name'));  // true

// New way (safer)
console.log(Object.hasOwn(obj, 'name'));  // true

// Works with null prototype
const nullProto = Object.create(null);
nullProto.name = 'John';

// obj.hasOwnProperty('name');  // Error!
console.log(Object.hasOwn(nullProto, 'name'));  // true
```

### Check Before Access
```javascript
const config = {theme: 'dark', lang: 'en'};

function getSetting(key) {
  return Object.hasOwn(config, key) ? config[key] : 'default';
}

console.log(getSetting('theme'));     // 'dark'
console.log(getSetting('fontSize'));  // 'default'
```

## Additional Utility Methods

### Object.getOwnPropertyNames()
```javascript
const obj = {a: 1, b: 2};
Object.defineProperty(obj, 'hidden', {
  value: 3,
  enumerable: false
});

console.log(Object.keys(obj));  // ['a', 'b']
console.log(Object.getOwnPropertyNames(obj));  // ['a', 'b', 'hidden']
```

### Object.getOwnPropertySymbols()
```javascript
const sym = Symbol('id');
const obj = {
  name: 'John',
  [sym]: 12345
};

console.log(Object.keys(obj));  // ['name']
console.log(Object.getOwnPropertySymbols(obj));  // [Symbol(id)]
```

### Object.is()
```javascript
// Similar to === but handles special cases
console.log(Object.is(NaN, NaN));      // true (=== gives false)
console.log(Object.is(+0, -0));        // false (=== gives true)
console.log(Object.is(5, 5));          // true
console.log(Object.is({}, {}));        // false (different references)
```

## Key Takeaways

- **Object.keys()** returns array of property names
- **Object.values()** returns array of property values
- **Object.entries()** returns array of [key, value] pairs
- **Object.assign()** copies properties (shallow), merges objects
- **Object.freeze()** makes object immutable (shallow)
- **Object.seal()** prevents add/delete but allows modification
- **Object.fromEntries()** converts entries to object (inverse of entries())
- **Object.hasOwn()** safer alternative to `hasOwnProperty()` (ES2022)
- All methods work only with **own enumerable properties**
- For deep operations, implement custom recursive functions
