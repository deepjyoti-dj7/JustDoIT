# Maps

## Creating Maps

### Basic Creation
```javascript
// Empty Map
const map = new Map();

// From array of entries
const map2 = new Map([
  ['name', 'John'],
  ['age', 30],
  ['city', 'NYC']
]);

console.log(map2.get('name'));  // 'John'
```

### From Object
```javascript
const obj = {a: 1, b: 2, c: 3};
const map = new Map(Object.entries(obj));

console.log(map.get('a'));  // 1
```

### Clone Map
```javascript
const original = new Map([['a', 1], ['b', 2]]);
const clone = new Map(original);

clone.set('c', 3);
console.log(original.size);  // 2
console.log(clone.size);     // 3
```

## Map vs Object

### Key Differences
```javascript
// Map: Keys can be any type
const map = new Map();
map.set(1, 'number key');
map.set({}, 'object key');
map.set(() => {}, 'function key');

// Object: Keys are strings/symbols only
const obj = {};
obj[1] = 'converted to "1"';
obj[{}] = 'converted to "[object Object]"';

console.log(Object.keys(obj));  // ['1', '[object Object]']
```

### Comparison Table
| Feature | Map | Object |
|---------|-----|--------|
| **Key Types** | Any type | String/Symbol |
| **Key Order** | Insertion order | Not guaranteed (mostly insertion in modern JS) |
| **Size** | `map.size` | `Object.keys(obj).length` |
| **Iteration** | Built-in iterators | Requires `Object.keys()` etc |
| **Performance** | Better for frequent add/remove | Better for simple lookups |
| **Serialization** | Not JSON-serializable | JSON-serializable |
| **Prototype** | No inherited keys | Has prototype chain |

### When to Use Map
```javascript
// ✅ Use Map for:
// - Non-string keys
const userMap = new Map();
const user1 = {id: 1};
userMap.set(user1, 'John');

// - Frequent additions/deletions
const cache = new Map();
cache.set('key1', 'value1');
cache.delete('key1');

// - Need to know size
console.log(cache.size);  // O(1)

// - Iteration order matters
const ordered = new Map();
ordered.set('z', 1);
ordered.set('a', 2);
for (const [key] of ordered) {
  console.log(key);  // 'z', 'a' (insertion order)
}
```

### When to Use Object
```javascript
// ✅ Use Object for:
// - Simple key-value storage
const config = {theme: 'dark', lang: 'en'};

// - JSON serialization
const data = {name: 'John', age: 30};
const json = JSON.stringify(data);

// - Property access syntax
const user = {name: 'John'};
console.log(user.name);  // Cleaner than map.get('name')
```

## Map Methods

### set() - Add/Update
```javascript
const map = new Map();

map.set('name', 'John');
map.set('age', 30);

// Chaining
map.set('city', 'NYC').set('country', 'USA');

// Update existing
map.set('age', 31);
console.log(map.get('age'));  // 31
```

### get() - Retrieve
```javascript
const map = new Map([['name', 'John']]);

console.log(map.get('name'));     // 'John'
console.log(map.get('missing'));  // undefined

// With default value
const value = map.get('missing') ?? 'default';
console.log(value);  // 'default'
```

### has() - Check Existence
```javascript
const map = new Map([['name', 'John']]);

console.log(map.has('name'));     // true
console.log(map.has('age'));      // false

// Safe get
if (map.has('name')) {
  console.log(map.get('name'));
}
```

### delete() - Remove
```javascript
const map = new Map([
  ['a', 1],
  ['b', 2],
  ['c', 3]
]);

const deleted = map.delete('b');
console.log(deleted);     // true
console.log(map.size);    // 2

const notDeleted = map.delete('z');
console.log(notDeleted);  // false
```

### clear() - Remove All
```javascript
const map = new Map([['a', 1], ['b', 2]]);

map.clear();
console.log(map.size);  // 0
```

## Iterating Maps

### for...of with entries()
```javascript
const map = new Map([
  ['name', 'John'],
  ['age', 30],
  ['city', 'NYC']
]);

// Default iteration (entries)
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}

// Explicit entries()
for (const [key, value] of map.entries()) {
  console.log(`${key}: ${value}`);
}
```

### keys() and values()
```javascript
const map = new Map([['a', 1], ['b', 2], ['c', 3]]);

// Iterate keys
for (const key of map.keys()) {
  console.log(key);  // 'a', 'b', 'c'
}

// Iterate values
for (const value of map.values()) {
  console.log(value);  // 1, 2, 3
}
```

### forEach()
```javascript
const map = new Map([['a', 1], ['b', 2]]);

map.forEach((value, key, mapRef) => {
  console.log(`${key}: ${value}`);
});
```

### Convert to Array
```javascript
const map = new Map([['a', 1], ['b', 2], ['c', 3]]);

// Array of entries
const entries = [...map];
console.log(entries);  // [['a', 1], ['b', 2], ['c', 3]]

// Array of keys
const keys = [...map.keys()];
console.log(keys);     // ['a', 'b', 'c']

// Array of values
const values = [...map.values()];
console.log(values);   // [1, 2, 3]
```

## Map Size

### Get Size
```javascript
const map = new Map([['a', 1], ['b', 2]]);

console.log(map.size);  // 2

map.set('c', 3);
console.log(map.size);  // 3

map.delete('a');
console.log(map.size);  // 2
```

### Check Empty
```javascript
const map = new Map();

const isEmpty = map.size === 0;
console.log(isEmpty);  // true

map.set('key', 'value');
console.log(map.size === 0);  // false
```

## WeakMap

### Basic Usage
```javascript
const weakMap = new WeakMap();

const obj1 = {id: 1};
const obj2 = {id: 2};

weakMap.set(obj1, 'data for obj1');
weakMap.set(obj2, 'data for obj2');

console.log(weakMap.get(obj1));  // 'data for obj1'
```

### Keys Must Be Objects
```javascript
const weakMap = new WeakMap();

// ✅ Objects allowed
weakMap.set({}, 'value');
weakMap.set([], 'value');

// ❌ Primitives not allowed
// weakMap.set('string', 'value');  // TypeError
// weakMap.set(123, 'value');       // TypeError
```

### Garbage Collection
```javascript
let obj = {name: 'John'};
const weakMap = new WeakMap();
weakMap.set(obj, 'metadata');

// obj can be garbage collected when no other references
obj = null;  // WeakMap entry automatically removed
```

### WeakMap vs Map
| Feature | WeakMap | Map |
|---------|---------|-----|
| **Keys** | Objects only | Any type |
| **GC** | Keys can be GC'd | Keys prevent GC |
| **Iteration** | Not iterable | Iterable |
| **Size** | No `.size` | Has `.size` |
| **Methods** | get, set, has, delete | All methods |
| **Use Case** | Private data, caching | General purpose |

### Private Data Pattern
```javascript
const privateData = new WeakMap();

class Person {
  constructor(name, ssn) {
    this.name = name;  // Public
    privateData.set(this, {ssn});  // Private
  }
  
  getSSN() {
    return privateData.get(this).ssn;
  }
}

const person = new Person('John', '123-45-6789');
console.log(person.name);      // 'John'
console.log(person.getSSN());  // '123-45-6789'
console.log(person.ssn);       // undefined (private)
```

## Use Cases

### Caching/Memoization
```javascript
const cache = new Map();

function expensiveOperation(n) {
  if (cache.has(n)) {
    return cache.get(n);
  }
  
  const result = n * n;  // Expensive calculation
  cache.set(n, result);
  return result;
}

console.log(expensiveOperation(5));  // Calculates
console.log(expensiveOperation(5));  // From cache
```

### Counting Occurrences
```javascript
const words = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];

const count = new Map();
for (const word of words) {
  count.set(word, (count.get(word) || 0) + 1);
}

console.log(count);
// Map { 'apple' => 3, 'banana' => 2, 'orange' => 1 }
```

### Object Metadata
```javascript
const metadata = new Map();

const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'}
];

users.forEach(user => {
  metadata.set(user, {
    lastAccessed: new Date(),
    loginCount: 0
  });
});

const user1Meta = metadata.get(users[0]);
user1Meta.loginCount++;
```

### Unique Object Tracking
```javascript
const seen = new Map();

function processItem(item) {
  if (seen.has(item)) {
    console.log('Already processed');
    return;
  }
  
  seen.set(item, true);
  // Process item...
}

const obj = {id: 1};
processItem(obj);  // Processes
processItem(obj);  // Already processed
```

## Key Takeaways

- **Map** allows any type as key, maintains insertion order
- Better performance than Object for frequent add/delete operations
- **get(), set(), has(), delete()** are main methods
- **size** property for count (O(1))
- Iterable by default with **for...of**
- **WeakMap** has object-only keys, allows garbage collection
- Use **WeakMap** for private data or when keys might be deleted
- **Map** not JSON-serializable (convert to/from Object if needed)
- Choose Map for dynamic collections, Object for static config
