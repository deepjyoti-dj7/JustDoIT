# Immutability Concepts

## Why Immutability

### Benefits
```javascript
// Predictability
const original = [1, 2, 3];
const modified = [...original, 4];  // Original unchanged
console.log(original);  // [1, 2, 3]
console.log(modified);  // [1, 2, 3, 4]

// Easier debugging
const state = {count: 0};
const newState = {...state, count: 1};  // Can track both states

// Safe sharing
const shared = Object.freeze({value: 10});
shared.value = 20;  // Fails in strict mode, ignored otherwise
```

### Use Cases
- React/Redux state management
- Functional programming
- Concurrent operations
- Time-travel debugging
- Undo/redo functionality

## Shallow vs Deep Copy

### Shallow Copy
```javascript
const original = {a: 1, b: {c: 2}};

// Spread operator
const copy1 = {...original};

// Object.assign
const copy2 = Object.assign({}, original);

// Array spread
const arr = [1, 2, {x: 3}];
const arrCopy = [...arr];

// Issue: Nested objects are shared
copy1.b.c = 10;
console.log(original.b.c);  // 10 (modified!)
```

### Deep Copy
```javascript
const original = {a: 1, b: {c: 2, d: {e: 3}}};

// JSON method (simple but limited)
const copy1 = JSON.parse(JSON.stringify(original));
// Limitations: No functions, dates, undefined, symbols

// structuredClone (modern)
const copy2 = structuredClone(original);
// Better: Handles dates, maps, sets, typed arrays

// Recursive function
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj);
  if (Array.isArray(obj)) return obj.map(deepClone);
  
  return Object.fromEntries(
    Object.entries(obj).map(([k, v]) => [k, deepClone(v)])
  );
}

const copy3 = deepClone(original);
```

### Performance Comparison
```javascript
// Shallow copy - Fast
const shallow = {...obj};  // O(n) where n = number of properties

// Deep copy - Slower
const deep = structuredClone(obj);  // O(n) where n = all nested elements

// Only use deep copy when needed
```

## Object.freeze()

### Basic Freeze
```javascript
const obj = {a: 1, b: 2};
Object.freeze(obj);

obj.a = 10;      // Fails silently (strict mode throws)
obj.c = 3;       // Can't add
delete obj.a;    // Can't delete

console.log(obj);  // {a: 1, b: 2}
```

### Shallow Freeze
```javascript
const obj = {a: 1, b: {c: 2}};
Object.freeze(obj);

obj.a = 10;      // Blocked
obj.b.c = 20;    // Allowed! (nested not frozen)
console.log(obj.b.c);  // 20
```

### Deep Freeze
```javascript
function deepFreeze(obj) {
  Object.freeze(obj);
  
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  
  return obj;
}

const obj = {a: 1, b: {c: 2}};
deepFreeze(obj);
obj.b.c = 20;  // Blocked
```

### freeze() vs seal() vs preventExtensions()
```javascript
const obj = {a: 1};

// preventExtensions: Can't add
Object.preventExtensions(obj);
obj.a = 2;       // ✅ Allowed
obj.b = 3;       // ❌ Blocked
delete obj.a;    // ✅ Allowed

// seal: Can't add or delete
Object.seal(obj);
obj.a = 2;       // ✅ Allowed
obj.b = 3;       // ❌ Blocked
delete obj.a;    // ❌ Blocked

// freeze: Can't modify at all
Object.freeze(obj);
obj.a = 2;       // ❌ Blocked
obj.b = 3;       // ❌ Blocked
delete obj.a;    // ❌ Blocked
```

## Immutable Updates

### Arrays
```javascript
const arr = [1, 2, 3];

// Add
const add = [...arr, 4];              // [1, 2, 3, 4]
const prepend = [0, ...arr];          // [0, 1, 2, 3]
const insert = [...arr.slice(0, 2), 2.5, ...arr.slice(2)];  // [1, 2, 2.5, 3]

// Remove
const remove = arr.filter((_, i) => i !== 1);  // [1, 3]
const removeLast = arr.slice(0, -1);           // [1, 2]

// Update
const update = arr.map((x, i) => i === 1 ? 20 : x);  // [1, 20, 3]
const updateWith = arr.with(1, 20);                   // [1, 20, 3] (ES2023)

// Sort/Reverse
const sorted = [...arr].sort();                       // [1, 2, 3]
const toSorted = arr.toSorted();                      // [1, 2, 3] (ES2023)
const reversed = arr.toReversed();                    // [3, 2, 1] (ES2023)
```

### Objects
```javascript
const obj = {a: 1, b: 2};

// Add/Update
const updated = {...obj, c: 3};           // {a: 1, b: 2, c: 3}
const override = {...obj, a: 10};         // {a: 10, b: 2}

// Remove
const {b, ...rest} = obj;
console.log(rest);                        // {a: 1}

// Nested update
const nested = {a: 1, b: {c: 2, d: 3}};
const updated2 = {
  ...nested,
  b: {...nested.b, c: 20}
};  // {a: 1, b: {c: 20, d: 3}}
```

## Immer Library

### Basic Usage
```javascript
import {produce} from 'immer';

const state = {count: 0, todos: [{text: 'Learn', done: false}]};

// Mutable-style updates, immutable result
const nextState = produce(state, draft => {
  draft.count++;
  draft.todos[0].done = true;
  draft.todos.push({text: 'Code', done: false});
});

console.log(state.count);       // 0 (unchanged)
console.log(nextState.count);   // 1 (new state)
```

### Benefits
```javascript
// Without Immer - Complex
const updated = {
  ...state,
  todos: state.todos.map((todo, i) => 
    i === 0 ? {...todo, done: true} : todo
  ).concat([{text: 'Code', done: false}])
};

// With Immer - Simple
const updated = produce(state, draft => {
  draft.todos[0].done = true;
  draft.todos.push({text: 'Code', done: false});
});
```

## Key Takeaways

- **Immutability** prevents unexpected changes
- **Shallow copy** with spread/Object.assign
- **Deep copy** with structuredClone or JSON
- **Object.freeze()** prevents modifications (shallow)
- Use **spread**, **map**, **filter** for immutable updates
- **ES2023** adds toSorted, toReversed, with
- **Immer** simplifies complex immutable updates
- Trade-off: Safety vs performance
