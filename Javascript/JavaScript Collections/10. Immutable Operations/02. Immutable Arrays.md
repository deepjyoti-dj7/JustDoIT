# Immutable Arrays

## ES2023 Methods

### toSorted()
```javascript
const arr = [3, 1, 4, 1, 5];

// Old way - mutates
const sorted1 = [...arr].sort();

// New way - immutable
const sorted2 = arr.toSorted();

console.log(arr);      // [3, 1, 4, 1, 5] (unchanged)
console.log(sorted2);  // [1, 1, 3, 4, 5]

// With comparator
const numbers = [10, 5, 40, 25];
const sorted3 = numbers.toSorted((a, b) => a - b);
```

### toReversed()
```javascript
const arr = [1, 2, 3, 4, 5];

// Old way
const reversed1 = [...arr].reverse();

// New way
const reversed2 = arr.toReversed();

console.log(arr);        // [1, 2, 3, 4, 5] (unchanged)
console.log(reversed2);  // [5, 4, 3, 2, 1]
```

### toSpliced()
```javascript
const arr = [1, 2, 3, 4, 5];

// Old way
const spliced1 = [...arr.slice(0, 2), ...arr.slice(3)];

// New way - remove elements
const spliced2 = arr.toSpliced(2, 1);  // Remove 1 at index 2
console.log(spliced2);  // [1, 2, 4, 5]

// Insert elements
const inserted = arr.toSpliced(2, 0, 2.5);  // Insert at index 2
console.log(inserted);  // [1, 2, 2.5, 3, 4, 5]

// Replace elements
const replaced = arr.toSpliced(1, 2, 20, 30);  // Replace 2 items
console.log(replaced);  // [1, 20, 30, 4, 5]
```

### with()
```javascript
const arr = [1, 2, 3, 4, 5];

// Old way
const updated1 = arr.map((x, i) => i === 2 ? 30 : x);

// New way
const updated2 = arr.with(2, 30);

console.log(arr);       // [1, 2, 3, 4, 5] (unchanged)
console.log(updated2);  // [1, 2, 30, 4, 5]

// Negative indices
const updated3 = arr.with(-1, 50);  // Update last
console.log(updated3);  // [1, 2, 3, 4, 50]
```

## Spread Operator Patterns

### Copying
```javascript
const original = [1, 2, 3];
const copy = [...original];

copy.push(4);
console.log(original);  // [1, 2, 3]
console.log(copy);      // [1, 2, 3, 4]
```

### Concatenating
```javascript
const arr1 = [1, 2];
const arr2 = [3, 4];
const arr3 = [5, 6];

const combined = [...arr1, ...arr2, ...arr3];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Inserting in middle
const inserted = [...arr1, 99, ...arr2];
console.log(inserted);  // [1, 2, 99, 3, 4]
```

### Adding Elements
```javascript
const arr = [2, 3, 4];

const prepend = [1, ...arr];           // [1, 2, 3, 4]
const append = [...arr, 5];            // [2, 3, 4, 5]
const both = [1, ...arr, 5];           // [1, 2, 3, 4, 5]
const middle = [...arr.slice(0, 1), 2.5, ...arr.slice(1)];
```

## Functional Patterns

### map() for Updates
```javascript
const arr = [1, 2, 3, 4, 5];

// Update all
const doubled = arr.map(x => x * 2);

// Update specific
const updated = arr.map((x, i) => i === 2 ? 30 : x);

// Update by condition
const incremented = arr.map(x => x > 2 ? x + 1 : x);
```

### filter() for Removal
```javascript
const arr = [1, 2, 3, 4, 5];

// Remove by index
const removed = arr.filter((_, i) => i !== 2);

// Remove by value
const filtered = arr.filter(x => x !== 3);

// Remove by condition
const evens = arr.filter(x => x % 2 === 0);

// Remove first occurrence
let found = false;
const removeFirst = arr.filter(x => {
  if (x === 3 && !found) {
    found = true;
    return false;
  }
  return true;
});
```

### concat() for Adding
```javascript
const arr = [1, 2, 3];

const added = arr.concat(4);        // [1, 2, 3, 4]
const multiple = arr.concat(4, 5);  // [1, 2, 3, 4, 5]
const arrays = arr.concat([4, 5]);  // [1, 2, 3, 4, 5]
```

### slice() for Extraction
```javascript
const arr = [1, 2, 3, 4, 5];

const sub = arr.slice(1, 3);     // [2, 3]
const copy = arr.slice();        // [1, 2, 3, 4, 5]
const removeLast = arr.slice(0, -1);  // [1, 2, 3, 4]
```

## Complex Updates

### Nested Arrays
```javascript
const matrix = [
  [1, 2],
  [3, 4],
  [5, 6]
];

// Update nested value
const updated = matrix.map((row, i) => 
  i === 1 ? row.map((val, j) => j === 0 ? 30 : val) : row
);
console.log(updated);  // [[1, 2], [30, 4], [5, 6]]

// Using with() and toSpliced()
const updated2 = matrix.with(1, matrix[1].with(0, 30));
```

### Array of Objects
```javascript
const users = [
  {id: 1, name: 'John', active: true},
  {id: 2, name: 'Jane', active: false},
  {id: 3, name: 'Bob', active: true}
];

// Update by id
const updated = users.map(user => 
  user.id === 2 ? {...user, active: true} : user
);

// Remove by id
const removed = users.filter(user => user.id !== 2);

// Add new
const added = [...users, {id: 4, name: 'Alice', active: true}];

// Sort by property
const sorted = [...users].sort((a, b) => 
  a.name.localeCompare(b.name)
);
```

## Performance Tips

### Prefer Appropriate Methods
```javascript
// ✅ Good: Direct immutable method
const sorted = arr.toSorted();

// ❌ Less efficient: Copy then mutate
const sorted = [...arr].sort();

// ✅ Good: Use with() for single update
const updated = arr.with(2, 30);

// ❌ Less efficient: map for single update
const updated = arr.map((x, i) => i === 2 ? 30 : x);
```

### Avoid Unnecessary Copies
```javascript
// ❌ Bad: Multiple copies
let arr = [1, 2, 3];
arr = [...arr, 4];
arr = [...arr, 5];
arr = [...arr, 6];

// ✅ Good: Single operation
const arr = [1, 2, 3, 4, 5, 6];
// Or if building dynamically:
const arr = [1, 2, 3].concat([4, 5, 6]);
```

### When to Mutate
```javascript
// ✅ OK: Local scope, no sharing
function process(data) {
  const result = [...data];  // Copy once
  result.sort();             // Mutate local copy
  result.reverse();
  return result;
}

// ✅ OK: Building array
function buildArray() {
  const arr = [];
  for (let i = 0; i < 1000; i++) {
    arr.push(i);  // Mutate during construction
  }
  return Object.freeze(arr);  // Freeze before returning
}
```

## Key Takeaways

- **ES2023 methods**: toSorted, toReversed, toSpliced, with
- Use **spread** for copying and concatenating
- **map()** for transformations
- **filter()** for removals
- **concat()/slice()** for adding/extracting
- Combine methods for complex updates
- New methods are clearer and safer
- Consider performance for large arrays
- Mutation is OK in local scope
