# Lodash Basics

# Lodash Basics

## Installation

### npm
```bash
npm install lodash
```

### Import
```javascript
// Full library
import _ from 'lodash';

// Specific functions (tree-shaking)
import {chunk, uniq, groupBy} from 'lodash';

// Individual imports (smallest bundle)
import chunk from 'lodash/chunk';
import uniq from 'lodash/uniq';
```

## Common Methods

### chunk()
```javascript
import {chunk} from 'lodash';

const arr = [1, 2, 3, 4, 5, 6, 7];
const chunks = chunk(arr, 3);
console.log(chunks);  // [[1, 2, 3], [4, 5, 6], [7]]

// Use case: Pagination
const items = Array.from({length: 100}, (_, i) => i);
const pages = chunk(items, 10);  // 10 pages of 10 items
```

### uniq()
```javascript
import {uniq, uniqBy} from 'lodash';

const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = uniq(arr);
console.log(unique);  // [1, 2, 3, 4, 5]

// By property
const users = [{id: 1, name: 'A'}, {id: 1, name: 'B'}, {id: 2, name: 'C'}];
const uniqueUsers = uniqBy(users, 'id');
console.log(uniqueUsers);  // [{id: 1, name: 'A'}, {id: 2, name: 'C'}]

// By function
const uniqueBy = uniqBy([2.1, 1.2, 2.3], Math.floor);
// [2.1, 1.2]
```

### groupBy()
```javascript
import {groupBy} from 'lodash';

const data = [
  {category: 'fruit', name: 'apple'},
  {category: 'fruit', name: 'banana'},
  {category: 'veggie', name: 'carrot'}
];

const grouped = groupBy(data, 'category');
console.log(grouped);
// {
//   fruit: [{category: 'fruit', name: 'apple'}, ...],
//   veggie: [{category: 'veggie', name: 'carrot'}]
// }

// With function
const byLength = groupBy(['one', 'two', 'three'], str => str.length);
// {3: ['one', 'two'], 5: ['three']}
```

### flatten() and flatMap()
```javascript
import {flatten, flattenDeep, flatMap} from 'lodash';

const arr = [1, [2, [3, [4]]]];

const flat1 = flatten(arr);      // [1, 2, [3, [4]]]
const flatAll = flattenDeep(arr); // [1, 2, 3, 4]

// flatMap
const result = flatMap([1, 2], n => [n, n * 2]);
console.log(result);  // [1, 2, 2, 4]
```

### pick() and omit()
```javascript
import {pick, omit} from 'lodash';

const user = {id: 1, name: 'John', password: 'secret', email: 'j@e.com'};

const safe = pick(user, ['id', 'name', 'email']);
// {id: 1, name: 'John', email: 'j@e.com'}

const noPassword = omit(user, ['password']);
// {id: 1, name: 'John', email: 'j@e.com'}
```

## Native vs Lodash

### When to Use Native
```javascript
// ✅ Native is sufficient
const arr = [1, 2, 3, 4, 5];

// Map
const doubled = arr.map(x => x * 2);

// Filter
const evens = arr.filter(x => x % 2 === 0);

// Find
const found = arr.find(x => x > 3);

// Includes
const has = arr.includes(3);

// Unique (Set)
const unique = [...new Set(arr)];
```

### When Lodash Helps
```javascript
import {chunk, groupBy, debounce, throttle, cloneDeep} from 'lodash';

// ✅ Lodash provides:

// Chunk - no native equivalent
const chunks = chunk([1,2,3,4,5], 2);

// GroupBy - ES2024 has Object.groupBy now
const grouped = groupBy(items, 'category');

// Deep clone - native structuredClone available now
const clone = cloneDeep(nestedObj);

// Debounce/Throttle - no native
const debouncedSave = debounce(save, 1000);

// Deep get/set with paths
const value = _.get(obj, 'a.b.c.d', 'default');
```

### Performance Comparison
```javascript
// Native is often faster for simple operations

// Native filter
const result1 = arr.filter(x => x > 5);  // Fast

// Lodash filter (adds overhead)
const result2 = _.filter(arr, x => x > 5);  // Slightly slower

// But Lodash optimizes complex operations
const result3 = _.chain(arr)
  .filter(x => x > 5)
  .map(x => x * 2)
  .uniq()
  .value();  // Single iteration (lazy evaluation)
```

## Useful Utilities

### debounce() and throttle()
```javascript
import {debounce, throttle} from 'lodash';

// Debounce - wait until user stops typing
const search = debounce((query) => {
  console.log('Searching for:', query);
}, 300);

search('h');      // Wait...
search('he');     // Wait...
search('hello');  // Executes after 300ms of no calls

// Throttle - execute at most once per interval
const onScroll = throttle(() => {
  console.log('Scrolling');
}, 100);  // Max once per 100ms

window.addEventListener('scroll', onScroll);
```

### get() and set()
```javascript
import {get, set} from 'lodash';

const obj = {a: {b: {c: 42}}};

// Safe access
const value = get(obj, 'a.b.c');        // 42
const missing = get(obj, 'a.x.y', 'default');  // 'default'

// Set nested value
set(obj, 'a.b.d', 100);
console.log(obj.a.b.d);  // 100

// Create path if missing
const empty = {};
set(empty, 'x.y.z', 5);
console.log(empty);  // {x: {y: {z: 5}}}
```

### isEqual()
```javascript
import {isEqual} from 'lodash';

const obj1 = {a: 1, b: {c: 2}};
const obj2 = {a: 1, b: {c: 2}};

console.log(obj1 === obj2);         // false (different references)
console.log(isEqual(obj1, obj2));  // true (deep equality)

const arr1 = [1, 2, [3, 4]];
const arr2 = [1, 2, [3, 4]];
console.log(isEqual(arr1, arr2));  // true
```

### merge() and cloneDeep()
```javascript
import {merge, cloneDeep} from 'lodash';

// Deep merge
const defaults = {a: 1, b: {c: 2, d: 3}};
const custom = {b: {c: 20, e: 4}};
const result = merge({}, defaults, custom);
// {a: 1, b: {c: 20, d: 3, e: 4}}

// Deep clone
const original = {a: 1, b: {c: 2}};
const clone = cloneDeep(original);
clone.b.c = 20;
console.log(original.b.c);  // 2 (unchanged)
```

## Chaining

### Explicit Chaining
```javascript
import {chain} from 'lodash';

const result = chain([1, 2, 3, 4, 5, 6])
  .filter(n => n % 2 === 0)
  .map(n => n * 2)
  .take(2)
  .value();  // Must call .value()

console.log(result);  // [4, 8]
```

### Lazy Evaluation
```javascript
// Lazy - only processes what's needed
const result = chain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  .filter(n => {
    console.log('Filter', n);
    return n % 2 === 0;
  })
  .take(2)  // Only needs 2 results
  .value();
// Only filters until 2 even numbers found
```

## Key Takeaways

- **Lodash** provides utilities missing from native JS
- Use **specific imports** for smaller bundles
- **Native is often sufficient** for simple operations
- **groupBy**, **chunk**, **debounce**, **throttle** are very useful
- **Deep operations** (clone, merge, get/set) are helpful
- **Chaining** with lazy evaluation for complex pipelines
- Consider **modern native alternatives** (structuredClone, Object.groupBy)
- Install only if you need its features
