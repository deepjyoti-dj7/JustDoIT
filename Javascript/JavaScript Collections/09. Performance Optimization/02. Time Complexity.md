# Time Complexity

## Big O Notation

### Common Complexities
```javascript
// O(1) - Constant
const first = arr[0];
const size = map.size;

// O(log n) - Logarithmic
binarySearch(sortedArr, target);

// O(n) - Linear
arr.forEach(item => console.log(item));

// O(n log n) - Linearithmic
arr.sort((a, b) => a - b);

// O(n²) - Quadratic
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    // nested loop
  }
}
```

### Visualization
```
O(1)      < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n)
Best                                              Worst
```

## Array Method Complexity

### Access and Modification
```javascript
// O(1) - Direct access
arr[0];           // Get
arr[0] = 5;       // Set
arr.length;       // Length
arr.push(1);      // Add to end
arr.pop();        // Remove from end
```

### Linear Operations
```javascript
// O(n) - Check all elements
arr.indexOf(5);        // Find index
arr.includes(5);       // Check existence
arr.find(x => x > 5);  // Find element
arr.filter(x => x > 5); // Filter
arr.map(x => x * 2);   // Transform
arr.reduce((a, b) => a + b); // Aggregate

// O(n) - Shift elements
arr.shift();           // Remove from start
arr.unshift(1);        // Add to start
arr.splice(2, 1);      // Remove from middle
```

### Sorting and Reversing
```javascript
// O(n log n)
arr.sort((a, b) => a - b);

// O(n)
arr.reverse();
```

## Map vs Object

### Time Complexity
```javascript
// Map - O(1) average
const map = new Map();
map.set('key', 'value');  // O(1)
map.get('key');           // O(1)
map.has('key');           // O(1)
map.delete('key');        // O(1)

// Object - varies
const obj = {};
obj.key = 'value';        // O(1)
obj.key;                  // O(1)
'key' in obj;             // O(1)
delete obj.key;           // O(1)

// Iteration
map.forEach(...);         // O(n)
Object.keys(obj);         // O(n)
```

### Performance Comparison
```javascript
// Map is faster for:
// - Frequent additions/deletions
// - Large number of entries
// - Non-string keys

// Object is faster for:
// - Small fixed structure
// - JSON serialization
// - Simple key-value pairs
```

## Set vs Array

### Time Complexity
```javascript
// Set - O(1) average
const set = new Set();
set.add(1);       // O(1)
set.has(1);       // O(1)
set.delete(1);    // O(1)

// Array - O(n)
const arr = [];
arr.push(1);      // O(1)
arr.includes(1);  // O(n)
arr.splice(arr.indexOf(1), 1);  // O(n)
```

### Use Cases
```javascript
// Use Set when:
const uniqueValues = new Set([1, 2, 2, 3]);  // O(n) creation
if (uniqueValues.has(2)) { /* O(1) */ }

// Use Array when:
const ordered = [1, 2, 3];
const first = ordered[0];  // O(1) access by index
```

## Optimization Tips

### Avoid Nested Loops
```javascript
// ❌ O(n²) - Nested loops
function findDuplicates(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) return true;
    }
  }
  return false;
}

// ✅ O(n) - Use Set
function findDuplicates(arr) {
  const seen = new Set();
  for (const item of arr) {
    if (seen.has(item)) return true;
    seen.add(item);
  }
  return false;
}
```

### Cache Results
```javascript
// ❌ Bad: Recalculate every time
for (let i = 0; i < arr.length; i++) {  // Calls .length each iteration
  console.log(arr[i]);
}

// ✅ Good: Cache length
const len = arr.length;
for (let i = 0; i < len; i++) {
  console.log(arr[i]);
}

// Note: Modern JS engines optimize this anyway
```

### Use Appropriate Methods
```javascript
// ❌ Slow: filter().length for existence
const exists = arr.filter(x => x === target).length > 0;  // O(n) always

// ✅ Fast: some() short-circuits
const exists = arr.some(x => x === target);  // O(1) to O(n)

// ✅ Fastest: Set for repeated checks
const set = new Set(arr);  // O(n) once
const exists = set.has(target);  // O(1)
```

### Break Early
```javascript
// ❌ Bad: Check all elements
let found = false;
arr.forEach(item => {
  if (item === target) found = true;  // Continues even after found
});

// ✅ Good: Break early
let found = false;
for (const item of arr) {
  if (item === target) {
    found = true;
    break;  // Stop immediately
  }
}

// Or use find()
const found = arr.find(x => x === target) !== undefined;
```

## Complexity Table

| Operation | Array | Set | Map | Object |
|-----------|-------|-----|-----|--------|
| Access by key | - | - | O(1) | O(1) |
| Access by index | O(1) | - | - | - |
| Search | O(n) | O(1) | O(1) | - |
| Insert (end) | O(1) | O(1) | O(1) | O(1) |
| Insert (start) | O(n) | O(1) | O(1) | O(1) |
| Delete | O(n) | O(1) | O(1) | O(1) |
| Iteration | O(n) | O(n) | O(n) | O(n) |

## Key Takeaways

- **Big O** describes growth rate as input increases
- **Array access** by index is O(1)
- **Array search** is O(n) without sorting
- **Map/Set operations** are O(1) average
- **Sorting** is O(n log n) minimum
- Avoid nested loops when possible
- Use Set/Map for frequent lookups
- Short-circuit operations when possible
- Choose data structure based on operations needed
