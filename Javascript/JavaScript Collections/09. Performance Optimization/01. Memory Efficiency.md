# Memory Efficiency

## Avoiding Memory Leaks

### Common Leak Patterns
```javascript
// ❌ Leak: Global variables
function createLeak() {
  leak = [1, 2, 3];  // Implicit global
}

// ✅ Fixed: Use const/let
function noLeak() {
  const data = [1, 2, 3];
}
```

### Event Listeners
```javascript
// ❌ Leak: Not removing listeners
const button = document.getElementById('btn');
button.addEventListener('click', handler);

// ✅ Fixed: Remove when done
button.removeEventListener('click', handler);

// Or use AbortController (modern)
const controller = new AbortController();
button.addEventListener('click', handler, {signal: controller.signal});
controller.abort();  // Removes listener
```

### Timers and Intervals
```javascript
// ❌ Leak: Not clearing timers
const id = setInterval(() => {
  console.log('Running');
}, 1000);

// ✅ Fixed: Clear when done
clearInterval(id);
```

## WeakMap and WeakSet

### WeakMap for Metadata
```javascript
// ✅ Good: WeakMap doesn't prevent GC
const metadata = new WeakMap();

let user = {name: 'John'};
metadata.set(user, {lastLogin: Date.now()});

// When user is no longer referenced, metadata is GC'd
user = null;  // Metadata automatically cleaned up
```

### Regular Map Comparison
```javascript
// ❌ Bad: Regular Map prevents GC
const cache = new Map();
let obj = {data: 'value'};
cache.set(obj, 'cached');

obj = null;  // Object still in memory due to Map reference!
```

### WeakSet for Tracking
```javascript
const visitedNodes = new WeakSet();

function traverse(node) {
  if (visitedNodes.has(node)) return;
  visitedNodes.add(node);
  // Process node
}

// Nodes are GC'd when no longer referenced
```

## Object Pooling

### Basic Pool
```javascript
class ObjectPool {
  constructor(createFn, resetFn, size = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
    
    for (let i = 0; i < size; i++) {
      this.pool.push(createFn());
    }
  }

  acquire() {
    return this.pool.pop() || this.createFn();
  }

  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Usage
const vectorPool = new ObjectPool(
  () => ({x: 0, y: 0}),
  (v) => { v.x = 0; v.y = 0; }
);

const v = vectorPool.acquire();
v.x = 10; v.y = 20;
vectorPool.release(v);  // Reuse instead of GC
```

### When to Use
```javascript
// Good for:
// - Frequent object creation/destruction
// - Games, animations
// - High-performance loops

// Not needed for:
// - Infrequent operations
// - Small objects (literals are fast)
```

## Typed Arrays

### Efficient Numeric Storage
```javascript
// Regular array
const arr = [1, 2, 3, 4, 5];  // 8 bytes per element

// Typed array
const typedArr = new Int32Array([1, 2, 3, 4, 5]);  // 4 bytes per element

console.log(arr.length * 8);        // ~40 bytes (approximate)
console.log(typedArr.byteLength);   // 20 bytes (exact)
```

### Types
```javascript
const int8 = new Int8Array(10);      // -128 to 127
const uint8 = new Uint8Array(10);    // 0 to 255
const int16 = new Int16Array(10);    // -32768 to 32767
const int32 = new Int32Array(10);    // -2^31 to 2^31-1
const float32 = new Float32Array(10); // 32-bit float
const float64 = new Float64Array(10); // 64-bit float
```

### Performance Benefits
```javascript
// Faster for numeric operations
const data = new Float32Array(1000000);
for (let i = 0; i < data.length; i++) {
  data[i] = Math.random();  // Faster than regular array
}

// Predictable memory usage
console.log(data.byteLength);  // Exactly 4MB
```

## Memory Best Practices

### Avoid Large Closures
```javascript
// ❌ Bad: Closure captures large array
function createHandler() {
  const largeData = new Array(1000000).fill(0);
  return function() {
    console.log(largeData[0]);  // Keeps entire array in memory
  };
}

// ✅ Good: Only keep what you need
function createHandler() {
  const largeData = new Array(1000000).fill(0);
  const firstValue = largeData[0];
  return function() {
    console.log(firstValue);  // Only keeps one value
  };
}
```

### Clear References
```javascript
// ✅ Nullify when done
let largeArray = new Array(1000000);
// Use it...
largeArray = null;  // Allow GC
```

### Use Appropriate Data Structures
```javascript
// ❌ Bad: Array for frequent lookups
const users = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];
const user = users.find(u => u.id === 2);  // O(n)

// ✅ Good: Map for frequent lookups
const userMap = new Map([[1, {name: 'A'}], [2, {name: 'B'}]]);
const user = userMap.get(2);  // O(1)
```

### Limit Array Size
```javascript
// ❌ Bad: Unbounded growth
const logs = [];
function log(msg) {
  logs.push(msg);  // Grows forever
}

// ✅ Good: Limit size
const MAX_LOGS = 1000;
const logs = [];
function log(msg) {
  logs.push(msg);
  if (logs.length > MAX_LOGS) {
    logs.shift();  // Remove oldest
  }
}
```

## Key Takeaways

- **WeakMap/WeakSet** allow garbage collection
- **Object pooling** for frequent creation/destruction
- **Typed arrays** for numeric data (smaller, faster)
- Clear references when done (set to null)
- Remove event listeners and timers
- Avoid large closures
- Use appropriate data structures (Map vs Array)
- Limit unbounded growth
