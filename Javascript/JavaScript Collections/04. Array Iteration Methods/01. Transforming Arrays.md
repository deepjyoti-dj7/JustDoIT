# Transforming Arrays

## map()

### Basic Transformation
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

const squared = numbers.map(n => n ** 2);
console.log(squared);  // [1, 4, 9, 16, 25]
```

### Object Transformation
```javascript
const users = [
  {firstName: 'John', lastName: 'Doe'},
  {firstName: 'Jane', lastName: 'Smith'}
];

const fullNames = users.map(u => `${u.firstName} ${u.lastName}`);
console.log(fullNames);  // ['John Doe', 'Jane Smith']

const withIds = users.map((u, index) => ({
  id: index + 1,
  ...u
}));
```

### Extracting Properties
```javascript
const products = [
  {id: 1, name: 'Laptop', price: 1000},
  {id: 2, name: 'Mouse', price: 25},
  {id: 3, name: 'Keyboard', price: 75}
];

const prices = products.map(p => p.price);
console.log(prices);  // [1000, 25, 75]

const names = products.map(p => p.name);
console.log(names);  // ['Laptop', 'Mouse', 'Keyboard']
```

### Converting Types
```javascript
const strings = ['1', '2', '3', '4'];
const numbers = strings.map(Number);
console.log(numbers);  // [1, 2, 3, 4]

const values = [1, 0, '', 'hello', null];
const booleans = values.map(Boolean);
console.log(booleans);  // [true, false, false, true, false]
```

## flatMap()

### Map + Flatten
```javascript
const arr = [1, 2, 3];

// map returns nested arrays
const mapped = arr.map(x => [x, x * 2]);
console.log(mapped);  // [[1, 2], [2, 4], [3, 6]]

// flatMap flattens one level
const flatMapped = arr.flatMap(x => [x, x * 2]);
console.log(flatMapped);  // [1, 2, 2, 4, 3, 6]
```

### Expanding Elements
```javascript
const users = [
  {name: 'John', hobbies: ['reading', 'gaming']},
  {name: 'Jane', hobbies: ['cooking', 'hiking']}
];

const allHobbies = users.flatMap(u => u.hobbies);
console.log(allHobbies);
// ['reading', 'gaming', 'cooking', 'hiking']
```

### Conditional Flattening
```javascript
const numbers = [1, 2, 3, 4, 5];

// Include only even numbers
const evens = numbers.flatMap(n => n % 2 === 0 ? [n] : []);
console.log(evens);  // [2, 4]

// Duplicate odds, keep evens
const result = numbers.flatMap(n => 
  n % 2 === 0 ? [n] : [n, n]
);
console.log(result);  // [1, 1, 2, 3, 3, 4, 5, 5]
```

### String Splitting
```javascript
const sentences = ['Hello World', 'How are you'];
const words = sentences.flatMap(s => s.split(' '));
console.log(words);
// ['Hello', 'World', 'How', 'are', 'you']
```

## reduce()

### Accumulating Values
```javascript
const numbers = [1, 2, 3, 4, 5];

// Sum
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

// Product
const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120
```

### Building Objects
```javascript
const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];

const count = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
console.log(count);
// {apple: 3, banana: 2, orange: 1}
```

### Grouping
```javascript
const people = [
  {name: 'John', age: 25},
  {name: 'Jane', age: 30},
  {name: 'Bob', age: 25},
  {name: 'Alice', age: 30}
];

const byAge = people.reduce((acc, person) => {
  const age = person.age;
  if (!acc[age]) acc[age] = [];
  acc[age].push(person);
  return acc;
}, {});

console.log(byAge);
// {25: [{name: 'John', ...}, {name: 'Bob', ...}],
//  30: [{name: 'Jane', ...}, {name: 'Alice', ...}]}
```

### Flattening
```javascript
const nested = [[1, 2], [3, 4], [5, 6]];

const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
console.log(flat);  // [1, 2, 3, 4, 5, 6]

// Deep flatten
const deepNested = [1, [2, [3, [4, 5]]]];

const deepFlat = (arr) => arr.reduce((acc, val) => 
  Array.isArray(val) 
    ? acc.concat(deepFlat(val))
    : acc.concat(val),
  []
);
console.log(deepFlat(deepNested));  // [1, 2, 3, 4, 5]
```

### Array to Map
```javascript
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'}
];

const userMap = users.reduce((acc, user) => {
  acc.set(user.id, user);
  return acc;
}, new Map());

console.log(userMap.get(1));  // {id: 1, name: 'John'}
```

### Pipe/Compose Functions
```javascript
const pipe = (...fns) => (value) => 
  fns.reduce((acc, fn) => fn(acc), value);

const add5 = x => x + 5;
const multiply3 = x => x * 3;
const subtract2 = x => x - 2;

const compute = pipe(add5, multiply3, subtract2);
console.log(compute(10));  // (10 + 5) * 3 - 2 = 43
```

## reduceRight()

### Right-to-Left Processing
```javascript
const arr = [1, 2, 3, 4, 5];

// reduce: left to right
const leftToRight = arr.reduce((acc, n) => acc.concat(n), []);
console.log(leftToRight);  // [1, 2, 3, 4, 5]

// reduceRight: right to left
const rightToLeft = arr.reduceRight((acc, n) => acc.concat(n), []);
console.log(rightToLeft);  // [5, 4, 3, 2, 1]
```

### Reverse String
```javascript
const str = 'hello';
const reversed = str.split('').reduceRight((acc, char) => acc + char, '');
console.log(reversed);  // 'olleh'
```

### Compose (vs Pipe)
```javascript
const compose = (...fns) => (value) => 
  fns.reduceRight((acc, fn) => fn(acc), value);

const add5 = x => x + 5;
const multiply3 = x => x * 3;

const compute = compose(add5, multiply3);
console.log(compute(10));  // add5(multiply3(10)) = 35
```

## Chaining Methods

### Multiple Transformations
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const result = numbers
  .filter(n => n % 2 === 0)     // [2, 4, 6, 8, 10]
  .map(n => n * 2)              // [4, 8, 12, 16, 20]
  .reduce((sum, n) => sum + n, 0);  // 60

console.log(result);  // 60
```

### Complex Data Processing
```javascript
const users = [
  {name: 'John', age: 25, active: true},
  {name: 'Jane', age: 30, active: true},
  {name: 'Bob', age: 35, active: false},
  {name: 'Alice', age: 28, active: true}
];

const result = users
  .filter(u => u.active)           // Active users only
  .filter(u => u.age < 30)         // Under 30
  .map(u => u.name.toUpperCase())  // Uppercase names
  .sort();                          // Alphabetical

console.log(result);  // ['ALICE', 'JOHN']
```

### Readable Pipeline
```javascript
const products = [
  {name: 'Laptop', price: 1000, category: 'electronics'},
  {name: 'Shirt', price: 30, category: 'clothing'},
  {name: 'Phone', price: 800, category: 'electronics'},
  {name: 'Shoes', price: 100, category: 'clothing'}
];

const expensiveElectronics = products
  .filter(p => p.category === 'electronics')
  .filter(p => p.price > 500)
  .map(p => p.name);

console.log(expensiveElectronics);  // ['Laptop', 'Phone']
```

## Performance Tips

### Avoid Multiple Iterations
```javascript
const numbers = Array.from({length: 100000}, (_, i) => i);

// ❌ Slow: Multiple iterations
const result1 = numbers
  .filter(n => n % 2 === 0)
  .map(n => n * 2)
  .filter(n => n > 1000);

// ✅ Fast: Single reduce
const result2 = numbers.reduce((acc, n) => {
  if (n % 2 === 0) {
    const doubled = n * 2;
    if (doubled > 1000) {
      acc.push(doubled);
    }
  }
  return acc;
}, []);
```

### Early Termination
```javascript
// ❌ Processes all elements
const hasLarge = numbers
  .map(n => n * 2)
  .some(n => n > 1000);

// ✅ Stops at first match
const hasLarge2 = numbers.some(n => (n * 2) > 1000);
```

### Reuse Intermediate Results
```javascript
// ❌ Recalculates filtered array
const evens = numbers.filter(n => n % 2 === 0);
const doubled = numbers.filter(n => n % 2 === 0).map(n => n * 2);

// ✅ Reuse filtered array
const evens2 = numbers.filter(n => n % 2 === 0);
const doubled2 = evens2.map(n => n * 2);
```

### Use Appropriate Method
```javascript
// ❌ Overkill for finding one item
const first = numbers.filter(n => n > 50)[0];

// ✅ Stops at first match
const first2 = numbers.find(n => n > 50);

// ❌ Unnecessary array creation
const hasEven = numbers.filter(n => n % 2 === 0).length > 0;

// ✅ Short-circuits
const hasEven2 = numbers.some(n => n % 2 === 0);
```

## Key Takeaways

- **map()** transforms each element, returns new array of same length
- **flatMap()** combines map + flat, useful for expanding/filtering
- **reduce()** accumulates values, most versatile (can replicate map/filter)
- **reduceRight()** processes from right to left
- **Chaining** creates readable pipelines but may impact performance
- Avoid unnecessary iterations with large arrays
- Use specific methods (find, some) over filter when appropriate
- Consider single reduce over multiple chains for performance
- Always provide initial value to reduce() for safety
