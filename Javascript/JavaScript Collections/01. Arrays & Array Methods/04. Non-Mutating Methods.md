# Non-Mutating Array Methods

## concat()

### Merging Arrays
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const merged = arr1.concat(arr2);
console.log(merged);           // [1, 2, 3, 4, 5, 6]
console.log(arr1);             // [1, 2, 3] (unchanged)

// Multiple arrays
const arr3 = [7, 8];
const all = arr1.concat(arr2, arr3);
console.log(all);              // [1, 2, 3, 4, 5, 6, 7, 8]

// With individual values
const extended = arr1.concat(4, 5, arr2);
console.log(extended);         // [1, 2, 3, 4, 5, 4, 5, 6]
```

### vs Spread
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// concat()
const merged1 = arr1.concat(arr2);

// Spread (more common)
const merged2 = [...arr1, ...arr2];

console.log(merged1);          // [1, 2, 3, 4, 5, 6]
console.log(merged2);          // [1, 2, 3, 4, 5, 6]
```

## slice()

### Extract Portion
```javascript
const arr = [1, 2, 3, 4, 5];

// From index 1 to 3 (excluding 3)
const sliced = arr.slice(1, 3);
console.log(sliced);           // [2, 3]
console.log(arr);              // [1, 2, 3, 4, 5] (unchanged)

// From index 2 to end
const fromTwo = arr.slice(2);
console.log(fromTwo);          // [3, 4, 5]

// Negative indices
const lastTwo = arr.slice(-2);
console.log(lastTwo);          // [4, 5]

// Copy array
const copy = arr.slice();
```

### Common Patterns
```javascript
const arr = [1, 2, 3, 4, 5];

// Remove first element
const withoutFirst = arr.slice(1);  // [2, 3, 4, 5]

// Remove last element
const withoutLast = arr.slice(0, -1);  // [1, 2, 3, 4]

// Remove first and last
const middle = arr.slice(1, -1);  // [2, 3, 4]

// Get last n elements
const lastThree = arr.slice(-3);  // [3, 4, 5]
```

## join()

### Array to String
```javascript
const arr = ['Hello', 'World', '!'];

// Default separator (comma)
const str1 = arr.join();
console.log(str1);             // 'Hello,World,!'

// Custom separator
const str2 = arr.join(' ');
console.log(str2);             // 'Hello World !'

const str3 = arr.join('-');
console.log(str3);             // 'Hello-World-!'

// Empty separator
const str4 = arr.join('');
console.log(str4);             // 'HelloWorld!'
```

### Common Use Cases
```javascript
// Path construction
const pathParts = ['home', 'user', 'documents'];
const path = pathParts.join('/');
console.log(path);             // 'home/user/documents'

// CSV format
const row = ['John', 'Doe', '30'];
const csv = row.join(',');
console.log(csv);              // 'John,Doe,30'

// URL query string
const params = ['name=John', 'age=30', 'city=NYC'];
const query = '?' + params.join('&');
console.log(query);            // '?name=John&age=30&city=NYC'
```

## includes()

### Check Existence
```javascript
const arr = [1, 2, 3, 4, 5];

console.log(arr.includes(3));     // true
console.log(arr.includes(6));     // false
console.log(arr.includes('3'));   // false (type-sensitive)

// Start search from index
console.log(arr.includes(3, 3));  // false (searches from index 3)
console.log(arr.includes(3, 2));  // true
```

### NaN Handling
```javascript
const arr = [1, NaN, 3];

console.log(arr.includes(NaN));   // true âœ“
console.log(arr.indexOf(NaN));    // -1 (indexOf can't find NaN)
```

### Array vs Set
```javascript
const arr = [1, 2, 3, 4, 5];
const set = new Set(arr);

// Array: O(n)
console.log(arr.includes(3));     // true

// Set: O(1)
console.log(set.has(3));          // true (faster for large collections)
```

## indexOf() & lastIndexOf()

### indexOf() - First Occurrence
```javascript
const arr = [1, 2, 3, 2, 1];

console.log(arr.indexOf(2));      // 1
console.log(arr.indexOf(5));      // -1 (not found)

// Start from index
console.log(arr.indexOf(2, 2));   // 3 (starts search from index 2)
```

### lastIndexOf() - Last Occurrence
```javascript
const arr = [1, 2, 3, 2, 1];

console.log(arr.lastIndexOf(2));  // 3
console.log(arr.lastIndexOf(1));  // 4

// Search backwards from index
console.log(arr.lastIndexOf(2, 2));  // 1
```

### Find All Indices
```javascript
const arr = [1, 2, 3, 2, 1, 2];

function findAllIndices(arr, value) {
  const indices = [];
  let idx = arr.indexOf(value);
  while (idx !== -1) {
    indices.push(idx);
    idx = arr.indexOf(value, idx + 1);
  }
  return indices;
}

console.log(findAllIndices(arr, 2));  // [1, 3, 5]
```

## flat() & flatMap()

### flat() - Flatten Nested Arrays
```javascript
const nested = [1, [2, 3], [4, [5, 6]]];

// Flatten one level
const flat1 = nested.flat();
console.log(flat1);            // [1, 2, 3, 4, [5, 6]]

// Flatten two levels
const flat2 = nested.flat(2);
console.log(flat2);            // [1, 2, 3, 4, 5, 6]

// Flatten all levels
const flatAll = nested.flat(Infinity);
console.log(flatAll);          // [1, 2, 3, 4, 5, 6]
```

### Remove Empty Slots
```javascript
const sparse = [1, 2, , 4, 5];
const dense = sparse.flat();
console.log(dense);            // [1, 2, 4, 5]
```

### flatMap() - Map + Flatten
```javascript
const arr = [1, 2, 3];

// Regular map
const mapped = arr.map(x => [x, x * 2]);
console.log(mapped);           // [[1, 2], [2, 4], [3, 6]]

// flatMap (map + flat)
const flatMapped = arr.flatMap(x => [x, x * 2]);
console.log(flatMapped);       // [1, 2, 2, 4, 3, 6]

// Conditional flattening
const result = arr.flatMap(x => x % 2 === 0 ? [x] : []);
console.log(result);           // [2]
```

### Split and Flatten
```javascript
const sentences = ['Hello World', 'How are you'];
const words = sentences.flatMap(s => s.split(' '));
console.log(words);            // ['Hello', 'World', 'How', 'are', 'you']
```

## toSorted(), toReversed(), with() (ES2023)

### toSorted() - Immutable Sort
```javascript
const arr = [3, 1, 4, 1, 5];

const sorted = arr.toSorted();
console.log(arr);              // [3, 1, 4, 1, 5] (unchanged)
console.log(sorted);           // [1, 1, 3, 4, 5]

// With comparator
const descending = arr.toSorted((a, b) => b - a);
console.log(descending);       // [5, 4, 3, 1, 1]
```

### toReversed() - Immutable Reverse
```javascript
const arr = [1, 2, 3, 4, 5];

const reversed = arr.toReversed();
console.log(arr);              // [1, 2, 3, 4, 5] (unchanged)
console.log(reversed);         // [5, 4, 3, 2, 1]
```

### with() - Immutable Update
```javascript
const arr = ['a', 'b', 'c', 'd'];

// Update index 2
const updated = arr.with(2, 'X');
console.log(arr);              // ['a', 'b', 'c', 'd'] (unchanged)
console.log(updated);          // ['a', 'b', 'X', 'd']

// Negative index
const lastUpdated = arr.with(-1, 'Z');
console.log(lastUpdated);      // ['a', 'b', 'c', 'Z']
```

### Chaining Immutable Methods
```javascript
const arr = [3, 1, 4, 1, 5];

const result = arr
  .toSorted((a, b) => a - b)   // [1, 1, 3, 4, 5]
  .with(0, 0)                   // [0, 1, 3, 4, 5]
  .toReversed();                // [5, 4, 3, 1, 0]

console.log(arr);              // [3, 1, 4, 1, 5] (unchanged)
console.log(result);           // [5, 4, 3, 1, 0]
```

## Key Takeaways

- **Non-mutating methods** return new arrays, leave original unchanged
- **concat()** merges arrays, but spread `...` is more common
- **slice()** extracts portions, useful for copying arrays
- **join()** converts array to string with separator
- **includes()** checks existence, handles NaN correctly
- **indexOf()/lastIndexOf()** find first/last index, return -1 if not found
- **flat()** flattens nested arrays, depth configurable
- **flatMap()** combines map + flat in one operation
- **ES2023** immutable methods: `toSorted()`, `toReversed()`, `with()`
- Use immutable methods for functional programming patterns
