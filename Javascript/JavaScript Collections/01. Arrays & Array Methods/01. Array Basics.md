# Array Basics

## Creating Arrays

### Array Literal
```javascript
const fruits = ['apple', 'banana', 'orange'];
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, 'hello', true, null, {name: 'John'}];
const empty = [];
```

### Array Constructor
```javascript
const arr1 = new Array();           // []
const arr2 = new Array(5);          // [ <5 empty items> ]
const arr3 = new Array(1, 2, 3);    // [1, 2, 3]

// Better: Use Array.of() for consistent behavior
const arr4 = Array.of(5);           // [5]
const arr5 = Array.of(1, 2, 3);     // [1, 2, 3]
```

### Array.from()
```javascript
// From string
const chars = Array.from('hello');  // ['h', 'e', 'l', 'l', 'o']

// From Set
const set = new Set([1, 2, 3]);
const arr = Array.from(set);        // [1, 2, 3]

// With mapping function
const doubled = Array.from([1, 2, 3], x => x * 2);  // [2, 4, 6]

// Create range
const range = Array.from({length: 5}, (_, i) => i);  // [0, 1, 2, 3, 4]
```

### Array Fill
```javascript
const zeros = new Array(5).fill(0);          // [0, 0, 0, 0, 0]
const ones = Array(3).fill(1);               // [1, 1, 1]
const matrix = Array(3).fill(null).map(() => Array(3).fill(0));
```

## Accessing Elements

### Index Access
```javascript
const fruits = ['apple', 'banana', 'orange'];

console.log(fruits[0]);      // 'apple'
console.log(fruits[2]);      // 'orange'
console.log(fruits[5]);      // undefined (out of bounds)
console.log(fruits[-1]);     // undefined (negative index)
```

### at() Method (ES2022)
```javascript
const arr = ['a', 'b', 'c', 'd'];

// Positive index
console.log(arr.at(0));      // 'a'
console.log(arr.at(2));      // 'c'

// Negative index (from end)
console.log(arr.at(-1));     // 'd' (last element)
console.log(arr.at(-2));     // 'c' (second to last)

// vs traditional approach
console.log(arr[arr.length - 1]);  // 'd'
```

### First and Last Elements
```javascript
const numbers = [10, 20, 30, 40, 50];

// First element
const first = numbers[0];              // 10
const firstAlt = numbers.at(0);        // 10

// Last element
const last = numbers[numbers.length - 1];  // 50
const lastAlt = numbers.at(-1);            // 50
```

## Array Length

### Getting Length
```javascript
const arr = [1, 2, 3, 4, 5];
console.log(arr.length);     // 5

const empty = [];
console.log(empty.length);   // 0
```

### Setting Length
```javascript
const arr = [1, 2, 3, 4, 5];

// Truncate array
arr.length = 3;
console.log(arr);            // [1, 2, 3]

// Extend array (creates empty slots)
arr.length = 5;
console.log(arr);            // [1, 2, 3, <2 empty items>]

// Clear array
arr.length = 0;
console.log(arr);            // []
```

### Sparse Arrays
```javascript
const sparse = [1, , , 4];   // Has empty slots
console.log(sparse.length);  // 4
console.log(sparse[1]);      // undefined
console.log(1 in sparse);    // false (slot doesn't exist)

// Check for sparse arrays
const isDense = arr => arr.length === Object.keys(arr).length;
console.log(isDense([1, 2, 3]));     // true
console.log(isDense([1, , 3]));      // false
```

## Array Destructuring

### Basic Destructuring
```javascript
const [a, b, c] = [1, 2, 3];
console.log(a, b, c);        // 1 2 3

// Swap variables
let x = 1, y = 2;
[x, y] = [y, x];
console.log(x, y);           // 2 1
```

### Skipping Elements
```javascript
const [first, , third] = [10, 20, 30, 40];
console.log(first, third);   // 10 30

const [, , , fourth] = [1, 2, 3, 4, 5];
console.log(fourth);         // 4
```

### Default Values
```javascript
const [a = 1, b = 2] = [10];
console.log(a, b);           // 10 2

const [x = 'default'] = [];
console.log(x);              // 'default'
```

### Rest Pattern
```javascript
const [first, ...rest] = [1, 2, 3, 4, 5];
console.log(first);          // 1
console.log(rest);           // [2, 3, 4, 5]

const [head, ...tail] = ['a'];
console.log(head, tail);     // 'a' []
```

### Nested Destructuring
```javascript
const matrix = [[1, 2], [3, 4], [5, 6]];
const [[a, b], , [c, d]] = matrix;
console.log(a, b, c, d);     // 1 2 5 6

const data = [1, [2, 3, [4, 5]]];
const [x, [y, z, [w]]] = data;
console.log(x, y, z, w);     // 1 2 3 4
```

## Spread Operator

### Copying Arrays
```javascript
const original = [1, 2, 3];
const copy = [...original];
copy.push(4);
console.log(original);       // [1, 2, 3]
console.log(copy);           // [1, 2, 3, 4]
```

### Merging Arrays
```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const merged = [...arr1, ...arr2];
console.log(merged);         // [1, 2, 3, 4, 5, 6]

// With additional elements
const combined = [0, ...arr1, 3.5, ...arr2, 7];
console.log(combined);       // [0, 1, 2, 3, 3.5, 4, 5, 6, 7]
```

### Converting Iterables
```javascript
// String to array
const chars = [...'hello'];
console.log(chars);          // ['h', 'e', 'l', 'l', 'o']

// Set to array
const uniqueArr = [...new Set([1, 2, 2, 3, 3])];
console.log(uniqueArr);      // [1, 2, 3]

// Map to array
const map = new Map([['a', 1], ['b', 2]]);
const entries = [...map];
console.log(entries);        // [['a', 1], ['b', 2]]
```

### Function Arguments
```javascript
const numbers = [1, 5, 3, 9, 2];
console.log(Math.max(...numbers));     // 9
console.log(Math.min(...numbers));     // 1

function sum(a, b, c) {
  return a + b + c;
}
console.log(sum(...[10, 20, 30]));     // 60
```

## Common Patterns

### Creating Range
```javascript
// 0 to n-1
const range1 = [...Array(5).keys()];               // [0, 1, 2, 3, 4]

// 1 to n
const range2 = Array.from({length: 5}, (_, i) => i + 1);  // [1, 2, 3, 4, 5]

// Custom range
const range = (start, end) => 
  Array.from({length: end - start + 1}, (_, i) => start + i);
console.log(range(5, 10));             // [5, 6, 7, 8, 9, 10]
```

### Removing Duplicates
```javascript
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = [...new Set(arr)];
console.log(unique);                   // [1, 2, 3, 4, 5]

// With objects (by property)
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'},
  {id: 1, name: 'John'}
];
const uniqueById = [...new Map(users.map(u => [u.id, u])).values()];
```

### Flatten Array
```javascript
const nested = [1, [2, 3], [4, [5, 6]]];

// One level
const flat1 = nested.flat();           // [1, 2, 3, 4, [5, 6]]

// Deep flatten
const flatDeep = nested.flat(Infinity);  // [1, 2, 3, 4, 5, 6]

// Manual flatten (one level)
const manualFlat = [].concat(...nested);
```

### Chunking Array
```javascript
const chunk = (arr, size) => {
  return Array.from(
    {length: Math.ceil(arr.length / size)},
    (_, i) => arr.slice(i * size, i * size + size)
  );
};

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(chunk(numbers, 3));        // [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Shuffling Array
```javascript
const shuffle = (arr) => {
  const result = [...arr];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

const deck = [1, 2, 3, 4, 5];
console.log(shuffle(deck));
```

### Array Equality
```javascript
// Shallow equality
const arraysEqual = (a, b) => 
  a.length === b.length && a.every((val, i) => val === b[i]);

console.log(arraysEqual([1, 2, 3], [1, 2, 3]));  // true
console.log(arraysEqual([1, 2, 3], [1, 2, 4]));  // false

// Deep equality (for nested arrays)
const deepEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
```

### Rotating Array
```javascript
// Rotate right
const rotateRight = (arr, n) => {
  const len = arr.length;
  n = n % len;
  return [...arr.slice(-n), ...arr.slice(0, -n)];
};

// Rotate left
const rotateLeft = (arr, n) => {
  const len = arr.length;
  n = n % len;
  return [...arr.slice(n), ...arr.slice(0, n)];
};

const arr = [1, 2, 3, 4, 5];
console.log(rotateRight(arr, 2));      // [4, 5, 1, 2, 3]
console.log(rotateLeft(arr, 2));       // [3, 4, 5, 1, 2]
```

### Array Intersection and Union
```javascript
// Intersection
const intersection = (arr1, arr2) => 
  arr1.filter(item => arr2.includes(item));

// Union
const union = (arr1, arr2) => 
  [...new Set([...arr1, ...arr2])];

// Difference
const difference = (arr1, arr2) => 
  arr1.filter(item => !arr2.includes(item));

const a = [1, 2, 3, 4];
const b = [3, 4, 5, 6];
console.log(intersection(a, b));       // [3, 4]
console.log(union(a, b));              // [1, 2, 3, 4, 5, 6]
console.log(difference(a, b));         // [1, 2]
```

### Partitioning Array
```javascript
const partition = (arr, predicate) => {
  return arr.reduce((acc, item) => {
    acc[predicate(item) ? 0 : 1].push(item);
    return acc;
  }, [[], []]);
};

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
const [evens, odds] = partition(numbers, n => n % 2 === 0);
console.log(evens);                    // [2, 4, 6, 8]
console.log(odds);                     // [1, 3, 5, 7]
```

### Last N Elements
```javascript
const lastN = (arr, n) => arr.slice(-n);

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(lastN(numbers, 3));        // [6, 7, 8]

// Or using at()
const last = numbers.at(-1);           // 8
```

## Key Takeaways

- Use **array literals** `[]` for most array creation
- Use **Array.from()** to convert iterables or create sequences
- Use **at()** for convenient access to elements, especially from the end
- **Destructuring** simplifies extracting values from arrays
- **Spread operator** `...` is essential for copying, merging, and converting
- Arrays are **zero-indexed** and have dynamic length
- Setting `length` can truncate or extend arrays
- Use **spread** over `slice()` for shallow copying
- **Rest pattern** `...rest` captures remaining elements
- Many common patterns can be achieved with combinations of built-in methods
