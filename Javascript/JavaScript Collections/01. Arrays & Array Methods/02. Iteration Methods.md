# Array Iteration Methods

## forEach()

### Basic Usage
```javascript
const numbers = [1, 2, 3, 4, 5];

numbers.forEach(num => console.log(num));
// 1 2 3 4 5

// With index and array
numbers.forEach((num, index, arr) => {
  console.log(`${index}: ${num} of ${arr.length}`);
});
```

### Limitations
```javascript
const arr = [1, 2, 3, 4, 5];

// Cannot break or continue
arr.forEach(num => {
  if (num === 3) return;  // Only skips current iteration
  console.log(num);        // 1 2 4 5
});

// Cannot return value
const result = arr.forEach(num => num * 2);  // undefined

// Use for-of for breaking
for (const num of arr) {
  if (num === 3) break;
  console.log(num);        // 1 2
}
```

## map()

### Transform Elements
```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
console.log(doubled);      // [2, 4, 6, 8, 10]

const words = ['hello', 'world'];
const capitalized = words.map(w => w.toUpperCase());
console.log(capitalized);  // ['HELLO', 'WORLD']
```

### With Index
```javascript
const arr = ['a', 'b', 'c'];
const indexed = arr.map((item, index) => `${index}-${item}`);
console.log(indexed);      // ['0-a', '1-b', '2-c']
```

### Object Transformation
```javascript
const users = [
  {id: 1, name: 'John', age: 30},
  {id: 2, name: 'Jane', age: 25}
];

const names = users.map(u => u.name);
console.log(names);        // ['John', 'Jane']

const updated = users.map(u => ({
  ...u,
  age: u.age + 1
}));
```

### Chaining
```javascript
const numbers = [1, 2, 3, 4, 5];
const result = numbers
  .map(n => n * 2)
  .map(n => n + 1)
  .map(n => `Number: ${n}`);
console.log(result);
// ['Number: 3', 'Number: 5', 'Number: 7', 'Number: 9', 'Number: 11']
```

## filter()

### Basic Filtering
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);        // [2, 4, 6, 8]

const odds = numbers.filter(n => n % 2 !== 0);
console.log(odds);         // [1, 3, 5, 7]
```

### Complex Conditions
```javascript
const users = [
  {name: 'John', age: 30, active: true},
  {name: 'Jane', age: 25, active: false},
  {name: 'Bob', age: 35, active: true}
];

const activeAdults = users.filter(u => u.active && u.age >= 30);
console.log(activeAdults); // [{name: 'John', ...}, {name: 'Bob', ...}]
```

### Removing Falsy Values
```javascript
const arr = [0, 1, false, 2, '', 3, null, undefined, NaN];
const truthy = arr.filter(Boolean);
console.log(truthy);       // [1, 2, 3]
```

### Unique Values
```javascript
const numbers = [1, 2, 2, 3, 4, 4, 5];
const unique = numbers.filter((num, index, arr) => 
  arr.indexOf(num) === index
);
console.log(unique);       // [1, 2, 3, 4, 5]
```

## reduce()

### Sum and Product
```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum);          // 15

const product = numbers.reduce((acc, num) => acc * num, 1);
console.log(product);      // 120
```

### Max and Min
```javascript
const numbers = [5, 2, 8, 1, 9, 3];

const max = numbers.reduce((max, num) => num > max ? num : max);
console.log(max);          // 9

const min = numbers.reduce((min, num) => num < min ? num : min);
console.log(min);          // 1
```

### Object from Array
```javascript
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'}
];

const userMap = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});
console.log(userMap);
// {1: {id: 1, name: 'John'}, 2: {id: 2, name: 'Jane'}}
```

### Counting Occurrences
```javascript
const fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple'];

const count = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
console.log(count);
// {apple: 3, banana: 2, orange: 1}
```

### Flatten Array
```javascript
const nested = [[1, 2], [3, 4], [5, 6]];
const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
console.log(flat);         // [1, 2, 3, 4, 5, 6]
```

### Grouping
```javascript
const people = [
  {name: 'John', age: 30},
  {name: 'Jane', age: 25},
  {name: 'Bob', age: 30}
];

const grouped = people.reduce((acc, person) => {
  const key = person.age;
  if (!acc[key]) acc[key] = [];
  acc[key].push(person);
  return acc;
}, {});
console.log(grouped);
// {25: [{name: 'Jane', age: 25}], 30: [{name: 'John', ...}, {name: 'Bob', ...}]}
```

## find() & findIndex()

### find()
```javascript
const numbers = [1, 2, 3, 4, 5];
const firstEven = numbers.find(n => n % 2 === 0);
console.log(firstEven);    // 2

const notFound = numbers.find(n => n > 10);
console.log(notFound);     // undefined
```

### findIndex()
```javascript
const numbers = [1, 2, 3, 4, 5];
const index = numbers.findIndex(n => n % 2 === 0);
console.log(index);        // 1

const notFoundIndex = numbers.findIndex(n => n > 10);
console.log(notFoundIndex);  // -1
```

### With Objects
```javascript
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'},
  {id: 3, name: 'Bob'}
];

const user = users.find(u => u.id === 2);
console.log(user);         // {id: 2, name: 'Jane'}

const index = users.findIndex(u => u.name === 'Bob');
console.log(index);        // 2
```

### findLast() & findLastIndex() (ES2023)
```javascript
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

const lastEven = numbers.findLast(n => n % 2 === 0);
console.log(lastEven);     // 2

const lastIndex = numbers.findLastIndex(n => n % 2 === 0);
console.log(lastIndex);    // 7
```

## some() & every()

### some() - At Least One
```javascript
const numbers = [1, 2, 3, 4, 5];

const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven);      // true

const hasNegative = numbers.some(n => n < 0);
console.log(hasNegative);  // false
```

### every() - All Elements
```javascript
const numbers = [2, 4, 6, 8];

const allEven = numbers.every(n => n % 2 === 0);
console.log(allEven);      // true

const allPositive = numbers.every(n => n > 0);
console.log(allPositive);  // true
```

### Validation
```javascript
const users = [
  {name: 'John', age: 30, verified: true},
  {name: 'Jane', age: 25, verified: true},
  {name: 'Bob', age: 35, verified: false}
];

const allVerified = users.every(u => u.verified);
console.log(allVerified);  // false

const someVerified = users.some(u => u.verified);
console.log(someVerified); // true

const allAdults = users.every(u => u.age >= 18);
console.log(allAdults);    // true
```

## Performance Considerations

### Method Comparison
```javascript
const arr = Array.from({length: 1000000}, (_, i) => i);

// forEach - fastest for side effects
console.time('forEach');
let sum1 = 0;
arr.forEach(n => sum1 += n);
console.timeEnd('forEach');

// reduce - slower but functional
console.time('reduce');
const sum2 = arr.reduce((acc, n) => acc + n, 0);
console.timeEnd('reduce');

// for loop - fastest overall
console.time('for');
let sum3 = 0;
for (let i = 0; i < arr.length; i++) {
  sum3 += arr[i];
}
console.timeEnd('for');
```

### Early Exit
```javascript
const numbers = Array.from({length: 1000}, (_, i) => i);

// find() - stops at first match
const found = numbers.find(n => n === 500);  // Checks ~500 elements

// filter() - checks all elements
const filtered = numbers.filter(n => n === 500)[0];  // Checks 1000 elements
```

### Chaining vs Single Loop
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Multiple iterations (less efficient)
const result1 = numbers
  .filter(n => n % 2 === 0)
  .map(n => n * 2)
  .reduce((sum, n) => sum + n, 0);

// Single iteration (more efficient)
const result2 = numbers.reduce((sum, n) => {
  if (n % 2 === 0) return sum + (n * 2);
  return sum;
}, 0);

console.log(result1 === result2);  // true
```

### Avoiding Array Creation
```javascript
// Creates intermediate arrays
const result1 = arr
  .map(n => n * 2)
  .filter(n => n > 10)
  .map(n => n / 2);

// Single reduce (no intermediate arrays)
const result2 = arr.reduce((acc, n) => {
  const doubled = n * 2;
  if (doubled > 10) acc.push(doubled / 2);
  return acc;
}, []);
```

### Short-Circuit Evaluation
```javascript
const numbers = [1, 2, 3, 4, 5];

// some() stops at first true
const hasEven = numbers.some(n => {
  console.log('Checking:', n);
  return n % 2 === 0;
});  // Logs: 1, 2 (stops)

// every() stops at first false
const allEven = numbers.every(n => {
  console.log('Checking:', n);
  return n % 2 === 0;
});  // Logs: 1 (stops)
```

## Best Practices

### Use Appropriate Method
```javascript
// ✅ Use find() for single item
const user = users.find(u => u.id === 1);

// ❌ Avoid filter()[0]
const user = users.filter(u => u.id === 1)[0];

// ✅ Use some() for existence check
const hasAdmin = users.some(u => u.role === 'admin');

// ❌ Avoid filter().length > 0
const hasAdmin = users.filter(u => u.role === 'admin').length > 0;
```

### Return Values
```javascript
// ✅ Implicit return for simple operations
const doubled = numbers.map(n => n * 2);

// ✅ Explicit return for multiple statements
const processed = numbers.map(n => {
  const doubled = n * 2;
  return doubled + 1;
});

// ✅ Return object with parentheses
const objects = numbers.map(n => ({value: n}));
```

### Provide Initial Value for reduce()
```javascript
// ✅ Always provide initial value
const sum = numbers.reduce((acc, n) => acc + n, 0);

// ❌ Empty array throws error without initial value
const emptySum = [].reduce((acc, n) => acc + n);  // Error
```

## Key Takeaways

- **forEach()**: Side effects only, cannot break or return value
- **map()**: Transform each element, returns new array of same length
- **filter()**: Returns new array with elements matching condition
- **reduce()**: Accumulates values into single result
- **find()/findIndex()**: Returns first matching element/index, stops early
- **some()/every()**: Boolean checks with short-circuit evaluation
- Choose the right method for performance and readability
- **for...of** or traditional loops when you need to break early
- Chaining is readable but may impact performance with large arrays
- **reduce()** is powerful but can be less readable than alternatives
