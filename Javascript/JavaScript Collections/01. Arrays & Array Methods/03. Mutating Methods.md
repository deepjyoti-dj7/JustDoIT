# Mutating Array Methods

## push() & pop()

### push() - Add to End
```javascript
const arr = [1, 2, 3];

// Add single element
const newLength = arr.push(4);
console.log(arr);          // [1, 2, 3, 4]
console.log(newLength);    // 4

// Add multiple elements
arr.push(5, 6, 7);
console.log(arr);          // [1, 2, 3, 4, 5, 6, 7]

// Spread syntax
const more = [8, 9];
arr.push(...more);
console.log(arr);          // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### pop() - Remove from End
```javascript
const arr = [1, 2, 3, 4, 5];

const last = arr.pop();
console.log(last);         // 5
console.log(arr);          // [1, 2, 3, 4]

// Empty array
const empty = [];
console.log(empty.pop());  // undefined
```

### Stack Implementation
```javascript
class Stack {
  constructor() {
    this.items = [];
  }
  
  push(item) {
    this.items.push(item);
  }
  
  pop() {
    return this.items.pop();
  }
  
  peek() {
    return this.items[this.items.length - 1];
  }
  
  isEmpty() {
    return this.items.length === 0;
  }
}

const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack.pop());  // 3
```

## shift() & unshift()

### shift() - Remove from Start
```javascript
const arr = [1, 2, 3, 4, 5];

const first = arr.shift();
console.log(first);        // 1
console.log(arr);          // [2, 3, 4, 5]

// Empty array
const empty = [];
console.log(empty.shift());  // undefined
```

### unshift() - Add to Start
```javascript
const arr = [3, 4, 5];

// Add single element
const newLength = arr.unshift(2);
console.log(arr);          // [2, 3, 4, 5]
console.log(newLength);    // 4

// Add multiple elements
arr.unshift(0, 1);
console.log(arr);          // [0, 1, 2, 3, 4, 5]
```

### Performance Note
```javascript
// shift() and unshift() are O(n) - slow for large arrays
const arr = Array.from({length: 1000000}, (_, i) => i);

console.time('shift');
arr.shift();
console.timeEnd('shift');  // Slower (re-indexes all elements)

console.time('pop');
arr.pop();
console.timeEnd('pop');    // Faster (only removes last)
```

## splice()

### Remove Elements
```javascript
const arr = [1, 2, 3, 4, 5];

// Remove 2 elements starting at index 1
const removed = arr.splice(1, 2);
console.log(removed);      // [2, 3]
console.log(arr);          // [1, 4, 5]
```

### Insert Elements
```javascript
const arr = [1, 2, 5];

// Insert at index 2 (remove 0)
arr.splice(2, 0, 3, 4);
console.log(arr);          // [1, 2, 3, 4, 5]
```

### Replace Elements
```javascript
const arr = [1, 2, 3, 4, 5];

// Replace 2 elements at index 1
arr.splice(1, 2, 'a', 'b', 'c');
console.log(arr);          // [1, 'a', 'b', 'c', 4, 5]
```

### Common Patterns
```javascript
const arr = [1, 2, 3, 4, 5];

// Remove from middle
arr.splice(2, 1);          // Remove 3

// Remove last n elements
arr.splice(-2);            // Remove last 2

// Clear array
arr.splice(0);
console.log(arr);          // []
```

## sort()

### Default Sort (Lexicographic)
```javascript
const fruits = ['banana', 'apple', 'orange'];
fruits.sort();
console.log(fruits);       // ['apple', 'banana', 'orange']

// Numbers sorted as strings!
const numbers = [10, 5, 40, 25, 1000, 1];
numbers.sort();
console.log(numbers);      // [1, 10, 1000, 25, 40, 5] ❌
```

### Numeric Sort
```javascript
const numbers = [10, 5, 40, 25, 1000, 1];

// Ascending
numbers.sort((a, b) => a - b);
console.log(numbers);      // [1, 5, 10, 25, 40, 1000]

// Descending
numbers.sort((a, b) => b - a);
console.log(numbers);      // [1000, 40, 25, 10, 5, 1]
```

### Object Sorting
```javascript
const users = [
  {name: 'John', age: 30},
  {name: 'Jane', age: 25},
  {name: 'Bob', age: 35}
];

// Sort by age
users.sort((a, b) => a.age - b.age);

// Sort by name
users.sort((a, b) => a.name.localeCompare(b.name));
```

### Stable Sort
```javascript
const items = [
  {name: 'A', priority: 2},
  {name: 'B', priority: 1},
  {name: 'C', priority: 2},
  {name: 'D', priority: 1}
];

// Sort maintains relative order for equal elements
items.sort((a, b) => a.priority - b.priority);
// [{name: 'B', priority: 1}, {name: 'D', priority: 1},
//  {name: 'A', priority: 2}, {name: 'C', priority: 2}]
```

## reverse()

### Basic Usage
```javascript
const arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr);          // [5, 4, 3, 2, 1]

const words = ['hello', 'world'];
words.reverse();
console.log(words);        // ['world', 'hello']
```

### Reverse String
```javascript
const str = 'hello';
const reversed = str.split('').reverse().join('');
console.log(reversed);     // 'olleh'
```

## fill()

### Fill All Elements
```javascript
const arr = [1, 2, 3, 4, 5];
arr.fill(0);
console.log(arr);          // [0, 0, 0, 0, 0]
```

### Fill Range
```javascript
const arr = [1, 2, 3, 4, 5];

// Fill from index 1 to 4
arr.fill(0, 1, 4);
console.log(arr);          // [1, 0, 0, 0, 5]

// Fill from index 2 to end
arr.fill(9, 2);
console.log(arr);          // [1, 0, 9, 9, 9]
```

### Initialize Array
```javascript
// Create array of zeros
const zeros = new Array(5).fill(0);
console.log(zeros);        // [0, 0, 0, 0, 0]

// Create 2D array (⚠️ shallow copy issue)
const matrix1 = new Array(3).fill([]);
matrix1[0].push(1);  // Modifies all rows!

// Correct way
const matrix2 = Array.from({length: 3}, () => []);
matrix2[0].push(1);  // Only modifies first row
```

## Immutable Alternatives

### Non-Mutating Equivalents
```javascript
const arr = [1, 2, 3, 4, 5];

// Instead of push()
const withPush = [...arr, 6];  // [1, 2, 3, 4, 5, 6]

// Instead of unshift()
const withUnshift = [0, ...arr];  // [0, 1, 2, 3, 4, 5]

// Instead of pop()
const withoutLast = arr.slice(0, -1);  // [1, 2, 3, 4]

// Instead of shift()
const withoutFirst = arr.slice(1);  // [2, 3, 4, 5]

// Instead of splice()
const withoutMiddle = [...arr.slice(0, 2), ...arr.slice(3)];

// Instead of reverse()
const reversed = [...arr].reverse();  // or arr.toReversed() in ES2023

// Instead of sort()
const sorted = [...arr].sort((a, b) => a - b);  // or arr.toSorted()
```

### ES2023 Immutable Methods
```javascript
const arr = [3, 1, 4, 1, 5];

// toSorted() - immutable sort
const sorted = arr.toSorted((a, b) => a - b);
console.log(arr);          // [3, 1, 4, 1, 5] (unchanged)
console.log(sorted);       // [1, 1, 3, 4, 5]

// toReversed() - immutable reverse
const reversed = arr.toReversed();
console.log(arr);          // [3, 1, 4, 1, 5] (unchanged)
console.log(reversed);     // [5, 1, 4, 1, 3]

// toSpliced() - immutable splice
const spliced = arr.toSpliced(1, 2, 'a', 'b');
console.log(arr);          // [3, 1, 4, 1, 5] (unchanged)
console.log(spliced);      // [3, 'a', 'b', 1, 5]

// with() - immutable element replacement
const updated = arr.with(2, 99);
console.log(arr);          // [3, 1, 4, 1, 5] (unchanged)
console.log(updated);      // [3, 1, 99, 1, 5]
```

## Key Takeaways

- **Mutating methods** modify the original array in place
- **push()/pop()** are O(1), **shift()/unshift()** are O(n)
- **splice()** is the Swiss Army knife - can add, remove, replace
- **sort()** sorts in place, default is lexicographic (string) order
- Always provide comparison function for numeric sorting
- **reverse()** reverses array in place
- **fill()** is useful for initialization but watch for shallow copies
- Use immutable alternatives for functional programming
- **ES2023** provides built-in immutable versions: `toSorted()`, `toReversed()`, `toSpliced()`, `with()`
