# Grouping Data

## Object.groupBy() (ES2024)

### Basic Grouping
```javascript
const people = [
  {name: 'John', age: 25},
  {name: 'Jane', age: 30},
  {name: 'Bob', age: 25},
  {name: 'Alice', age: 30}
];

const byAge = Object.groupBy(people, person => person.age);
console.log(byAge);
// {
//   25: [{name: 'John', age: 25}, {name: 'Bob', age: 25}],
//   30: [{name: 'Jane', age: 30}, {name: 'Alice', age: 30}]
// }
```

### Group by Property
```javascript
const products = [
  {name: 'Laptop', category: 'electronics'},
  {name: 'Shirt', category: 'clothing'},
  {name: 'Phone', category: 'electronics'}
];

const byCategory = Object.groupBy(products, p => p.category);
```

## Map.groupBy() (ES2024)

### Group to Map
```javascript
const items = [{id: 1, type: 'A'}, {id: 2, type: 'B'}, {id: 3, type: 'A'}];

const grouped = Map.groupBy(items, item => item.type);
console.log(grouped.get('A'));  // [{id: 1, ...}, {id: 3, ...}]
```

### Advantages of Map.groupBy
```javascript
// Works with non-string keys
const byObject = Map.groupBy(items, item => item.obj);

// Maintains key order
// No prototype pollution issues
```

## reduce() for Grouping

### Manual Grouping
```javascript
const people = [
  {name: 'John', age: 25},
  {name: 'Jane', age: 30},
  {name: 'Bob', age: 25}
];

const byAge = people.reduce((acc, person) => {
  const key = person.age;
  if (!acc[key]) acc[key] = [];
  acc[key].push(person);
  return acc;
}, {});
```

### Group by Multiple Properties
```javascript
const data = [
  {name: 'A', cat: 'X', val: 1},
  {name: 'B', cat: 'Y', val: 2},
  {name: 'C', cat: 'X', val: 3}
];

const grouped = data.reduce((acc, item) => {
  const key = `${item.cat}-${item.val > 1 ? 'high' : 'low'}`;
  acc[key] = acc[key] || [];
  acc[key].push(item);
  return acc;
}, {});
```

## Custom Grouping Functions

### Flexible Grouping
```javascript
function groupBy(array, keyFn) {
  return array.reduce((acc, item) => {
    const key = keyFn(item);
    (acc[key] = acc[key] || []).push(item);
    return acc;
  }, {});
}

const students = [{name: 'A', grade: 85}, {name: 'B', grade: 92}];
const byGrade = groupBy(students, s => s.grade >= 90 ? 'A' : 'B');
```

### Group with Transform
```javascript
function groupAndMap(array, keyFn, valueFn) {
  return array.reduce((acc, item) => {
    const key = keyFn(item);
    const value = valueFn(item);
    (acc[key] = acc[key] || []).push(value);
    return acc;
  }, {});
}

const data = [{id: 1, name: 'A', cat: 'X'}, {id: 2, name: 'B', cat: 'X'}];
const result = groupAndMap(data, d => d.cat, d => d.name);
// {X: ['A', 'B']}
```

## Use Cases

### Counting
```javascript
const votes = ['A', 'B', 'A', 'C', 'B', 'A'];
const counts = votes.reduce((acc, vote) => {
  acc[vote] = (acc[vote] || 0) + 1;
  return acc;
}, {});
console.log(counts);  // {A: 3, B: 2, C: 1}
```

### Partitioning
```javascript
const numbers = [1, 2, 3, 4, 5, 6];
const {even, odd} = numbers.reduce((acc, n) => {
  acc[n % 2 === 0 ? 'even' : 'odd'].push(n);
  return acc;
}, {even: [], odd: []});
```

### Index by ID
```javascript
const users = [{id: 1, name: 'John'}, {id: 2, name: 'Jane'}];
const byId = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});

console.log(byId[1]);  // {id: 1, name: 'John'}
```

## Key Takeaways

- **Object.groupBy()** and **Map.groupBy()** are new ES2024 features
- **reduce()** is the traditional way to group data
- Returns object/map with arrays as values
- Use Map for non-string keys
- Custom functions provide flexibility
- Common for categorization and counting
