# Sorting Algorithms

## sort() Method

### Default String Sort
```javascript
const arr = [10, 5, 40, 25, 1000];
arr.sort();
console.log(arr);  // [10, 1000, 25, 40, 5] - lexicographic!
```

### Numeric Sort
```javascript
const numbers = [10, 5, 40, 25, 1000];
numbers.sort((a, b) => a - b);  // Ascending
console.log(numbers);  // [5, 10, 25, 40, 1000]

numbers.sort((a, b) => b - a);  // Descending
console.log(numbers);  // [1000, 40, 25, 10, 5]
```

## Comparison Functions

### Sorting Objects
```javascript
const users = [
  {name: 'John', age: 30},
  {name: 'Jane', age: 25},
  {name: 'Bob', age: 35}
];

// Sort by age
users.sort((a, b) => a.age - b.age);

// Sort by name
users.sort((a, b) => a.name.localeCompare(b.name));
```

### Multiple Criteria
```javascript
const data = [
  {name: 'A', score: 90},
  {name: 'B', score: 90},
  {name: 'C', score: 85}
];

data.sort((a, b) => {
  if (a.score !== b.score) {
    return b.score - a.score;  // Score descending
  }
  return a.name.localeCompare(b.name);  // Name ascending
});
```

## Bubble Sort

### Implementation
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let swapped = false;
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }
    if (!swapped) break;  // Already sorted
  }
  return arr;
}

const arr = [64, 34, 25, 12, 22];
bubbleSort(arr);
console.log(arr);  // [12, 22, 25, 34, 64]
```

### Time Complexity
- Best: O(n) - already sorted
- Average: O(n²)
- Worst: O(n²)
- Space: O(1)

## Quick Sort

### Implementation
```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);

  return [...quickSort(left), ...middle, ...quickSort(right)];
}

const arr = [64, 34, 25, 12, 22];
console.log(quickSort(arr));  // [12, 22, 25, 34, 64]
```

### Time Complexity
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n²)
- Space: O(log n)

## Merge Sort

### Implementation
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0, j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i++]);
    } else {
      result.push(right[j++]);
    }
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}

const arr = [64, 34, 25, 12, 22];
console.log(mergeSort(arr));  // [12, 22, 25, 34, 64]
```

### Time Complexity
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n log n)
- Space: O(n)

## Time Complexity

| Algorithm | Best | Average | Worst | Space | Stable |
|-----------|------|---------|-------|-------|--------|
| Bubble    | O(n) | O(n²)   | O(n²) | O(1)  | Yes    |
| Quick     | O(n log n) | O(n log n) | O(n²) | O(log n) | No |
| Merge     | O(n log n) | O(n log n) | O(n log n) | O(n) | Yes |
| Built-in  | O(n log n) | O(n log n) | O(n log n) | - | Yes |

## Key Takeaways

- **Built-in sort()** is optimized (Timsort-like)
- Default sort is **lexicographic** (string-based)
- Use **comparison function** for numeric/object sorting
- **Stable sort** since ES2019
- Quick sort: fast average, unstable
- Merge sort: consistent O(n log n), stable
- Bubble sort: simple but slow (O(n²))
