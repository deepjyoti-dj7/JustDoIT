# Searching Algorithms

## Linear Search

### Basic Implementation
```javascript
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) return i;
  }
  return -1;
}

const arr = [5, 2, 8, 1, 9];
console.log(linearSearch(arr, 8));  // 2
console.log(linearSearch(arr, 7));  // -1
```

### Time Complexity
- Best: O(1) - found at first position
- Average: O(n)
- Worst: O(n) - element not found or at end

## Binary Search

### Iterative Implementation
```javascript
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) return mid;
    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// Requires sorted array
const arr = [1, 3, 5, 7, 9, 11];
console.log(binarySearch(arr, 7));   // 3
console.log(binarySearch(arr, 6));   // -1
```

### Recursive Implementation
```javascript
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;

  const mid = Math.floor((left + right) / 2);

  if (arr[mid] === target) return mid;
  if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right);
  }
  return binarySearchRecursive(arr, target, left, mid - 1);
}
```

### Time Complexity
- Best: O(1) - found at middle
- Average: O(log n)
- Worst: O(log n)
- **Requires sorted array**

## find() vs filter()

### find() - Returns First Match
```javascript
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'},
  {id: 3, name: 'Bob'}
];

const user = users.find(u => u.id === 2);
console.log(user);  // {id: 2, name: 'Jane'}

// Returns undefined if not found
const missing = users.find(u => u.id === 5);  // undefined
```

### filter() - Returns All Matches
```javascript
const numbers = [1, 2, 3, 4, 5, 6];

const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4, 6]

// Returns empty array if none found
const large = numbers.filter(n => n > 10);  // []
```

### Performance Comparison
```javascript
const large = Array.from({length: 1000000}, (_, i) => i);

// find() stops at first match - O(1) to O(n)
const found = large.find(n => n === 500);  // Fast

// filter() always checks all - O(n)
const filtered = large.filter(n => n === 500);  // Slower
```

## indexOf() vs includes()

### indexOf() - Returns Index
```javascript
const arr = [1, 2, 3, 4, 5];

console.log(arr.indexOf(3));    // 2
console.log(arr.indexOf(10));   // -1

// Limitation with NaN
const arr2 = [NaN, 1, 2];
console.log(arr2.indexOf(NaN)); // -1 (can't find NaN!)
```

### includes() - Returns Boolean
```javascript
const arr = [1, 2, 3, 4, 5];

console.log(arr.includes(3));   // true
console.log(arr.includes(10));  // false

// Handles NaN correctly
const arr2 = [NaN, 1, 2];
console.log(arr2.includes(NaN));  // true
```

### When to Use
```javascript
// Use includes() for existence check
if (arr.includes(value)) { /* ... */ }

// Use indexOf() when you need the position
const index = arr.indexOf(value);
if (index !== -1) {
  arr.splice(index, 1);  // Remove it
}
```

## Performance Best Practices

### Choose the Right Method
```javascript
// ❌ Slow - filter() checks all
const exists = arr.filter(x => x === target).length > 0;

// ✅ Fast - includes() can short-circuit
const exists = arr.includes(target);

// ❌ Slow - find() for existence
const exists = arr.find(x => x === target) !== undefined;

// ✅ Fast - some() short-circuits
const exists = arr.some(x => x === target);
```

### Binary Search for Large Sorted Arrays
```javascript
const large = Array.from({length: 1000000}, (_, i) => i);

// Linear search - O(n)
const index1 = large.indexOf(999999);  // Slow

// Binary search - O(log n)
const index2 = binarySearch(large, 999999);  // Fast
```

## Key Takeaways

- **Linear search**: O(n), works on unsorted arrays
- **Binary search**: O(log n), requires sorted array
- **find()**: Returns first match, stops early
- **filter()**: Returns all matches, always O(n)
- **includes()**: Existence check, handles NaN
- **indexOf()**: Returns position, doesn't handle NaN
- Use binary search for large sorted datasets
- Prefer some()/includes() over filter() for existence checks
