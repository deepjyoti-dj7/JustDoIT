# Queues

## FIFO Concept

**First In, First Out** - The first element added is the first one removed.

```javascript
// Visual representation
// Front ← [1, 2, 3] ← Rear
// dequeue() removes 1
// enqueue(4) adds to rear → [2, 3, 4]
```

### Queue Operations
- **Enqueue**: Add to rear
- **Dequeue**: Remove from front
- **Peek**: View front without removing
- **isEmpty**: Check if empty

## shift() and push() Implementation

### Basic Queue
```javascript
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element);  // Add to rear
  }

  dequeue() {
    if (this.isEmpty()) return undefined;
    return this.items.shift();  // Remove from front
  }

  peek() {
    if (this.isEmpty()) return undefined;
    return this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}
```

### Usage
```javascript
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);

console.log(queue.peek());     // 1
console.log(queue.dequeue());  // 1
console.log(queue.size());     // 2
```

### Performance Issue
```javascript
// shift() is O(n) because it reindexes the array
// For large queues, use circular queue or linked list
```

## Circular Queue

### Efficient Implementation
```javascript
class CircularQueue {
  constructor(capacity) {
    this.items = new Array(capacity);
    this.capacity = capacity;
    this.front = 0;
    this.rear = -1;
    this.size = 0;
  }

  enqueue(element) {
    if (this.isFull()) return false;
    this.rear = (this.rear + 1) % this.capacity;
    this.items[this.rear] = element;
    this.size++;
    return true;
  }

  dequeue() {
    if (this.isEmpty()) return undefined;
    const item = this.items[this.front];
    this.front = (this.front + 1) % this.capacity;
    this.size--;
    return item;
  }

  peek() {
    return this.isEmpty() ? undefined : this.items[this.front];
  }

  isEmpty() {
    return this.size === 0;
  }

  isFull() {
    return this.size === this.capacity;
  }
}
```

### Circular Queue Benefits
```javascript
// O(1) enqueue and dequeue
// Fixed memory usage
// No array shifting

const cq = new CircularQueue(3);
cq.enqueue(1);  // [1, _, _]
cq.enqueue(2);  // [1, 2, _]
cq.enqueue(3);  // [1, 2, 3]
cq.dequeue();   // [_, 2, 3] front moves
cq.enqueue(4);  // [4, 2, 3] wraps around
```

## Priority Queue

### Simple Priority Queue
```javascript
class PriorityQueue {
  constructor() {
    this.items = [];
  }

  enqueue(element, priority) {
    const queueElement = {element, priority};
    let added = false;

    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    if (!added) this.items.push(queueElement);
  }

  dequeue() {
    return this.isEmpty() ? undefined : this.items.shift().element;
  }

  isEmpty() {
    return this.items.length === 0;
  }
}
```

### Usage
```javascript
const pq = new PriorityQueue();
pq.enqueue('low', 3);
pq.enqueue('high', 1);
pq.enqueue('medium', 2);

console.log(pq.dequeue());  // 'high' (priority 1)
console.log(pq.dequeue());  // 'medium' (priority 2)
```

## Use Cases

### Task Queue
```javascript
class TaskQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  async addTask(task) {
    this.queue.push(task);
    if (!this.processing) {
      this.processQueue();
    }
  }

  async processQueue() {
    this.processing = true;
    while (this.queue.length > 0) {
      const task = this.queue.shift();
      await task();
    }
    this.processing = false;
  }
}
```

### BFS (Breadth-First Search)
```javascript
function bfs(graph, start) {
  const visited = new Set();
  const queue = [start];
  const result = [];

  while (queue.length > 0) {
    const node = queue.shift();
    if (visited.has(node)) continue;

    visited.add(node);
    result.push(node);

    for (const neighbor of graph[node] || []) {
      if (!visited.has(neighbor)) {
        queue.push(neighbor);
      }
    }
  }
  return result;
}

const graph = {A: ['B', 'C'], B: ['D'], C: ['E'], D: [], E: []};
console.log(bfs(graph, 'A'));  // ['A', 'B', 'C', 'D', 'E']
```

### Print Queue
```javascript
class PrintQueue {
  constructor() {
    this.queue = [];
  }

  addJob(job) {
    this.queue.push({...job, timestamp: Date.now()});
    console.log(`Job added: ${job.name}`);
  }

  processNext() {
    if (this.queue.length === 0) {
      console.log('No jobs in queue');
      return;
    }
    const job = this.queue.shift();
    console.log(`Processing: ${job.name}`);
    return job;
  }

  getWaitingTime() {
    return this.queue.length;
  }
}
```

## Key Takeaways

- **FIFO** structure (First In, First Out)
- Use **shift()/push()** for simple queue (O(n) dequeue)
- **Circular queue** for O(1) operations
- **Priority queue** for ordered processing
- Common uses: BFS, task scheduling, buffering
- Consider performance for large queues
