# Stacks

## LIFO Concept

**Last In, First Out** - The last element added is the first one removed.

```javascript
// Visual representation
// push(3)  →  [1, 2, 3]  ←  Stack Top
//              [1, 2]
//              [1]       ←  Stack Bottom
// pop()    →  returns 3
```

### Stack Operations
- **Push**: Add to top
- **Pop**: Remove from top
- **Peek**: View top without removing
- **isEmpty**: Check if empty

## Array Implementation

### Basic Stack
```javascript
class Stack {
  constructor() {
    this.items = [];
  }

  push(element) {
    this.items.push(element);
  }

  pop() {
    if (this.isEmpty()) return undefined;
    return this.items.pop();
  }

  peek() {
    if (this.isEmpty()) return undefined;
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}
```

### Usage
```javascript
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);

console.log(stack.peek());  // 3
console.log(stack.pop());   // 3
console.log(stack.size());  // 2
```

## push() and pop()

### Array Methods
```javascript
const stack = [];

// Push - O(1)
stack.push(1);  // [1]
stack.push(2);  // [1, 2]
stack.push(3);  // [1, 2, 3]

// Pop - O(1)
const top = stack.pop();  // 3, stack is [1, 2]
```

### Multiple Operations
```javascript
const stack = [];
stack.push(1, 2, 3);  // Can push multiple
console.log(stack);   // [1, 2, 3]

const last = stack.pop();   // 3
const second = stack.pop(); // 2
```

## Use Cases

### Undo/Redo
```javascript
class UndoManager {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
  }

  execute(action) {
    action.execute();
    this.undoStack.push(action);
    this.redoStack = [];  // Clear redo on new action
  }

  undo() {
    if (this.undoStack.length === 0) return;
    const action = this.undoStack.pop();
    action.undo();
    this.redoStack.push(action);
  }

  redo() {
    if (this.redoStack.length === 0) return;
    const action = this.redoStack.pop();
    action.execute();
    this.undoStack.push(action);
  }
}
```

### Browser History
```javascript
class BrowserHistory {
  constructor() {
    this.backStack = [];
    this.forwardStack = [];
    this.current = null;
  }

  visit(url) {
    if (this.current) this.backStack.push(this.current);
    this.current = url;
    this.forwardStack = [];
  }

  back() {
    if (this.backStack.length === 0) return null;
    this.forwardStack.push(this.current);
    this.current = this.backStack.pop();
    return this.current;
  }

  forward() {
    if (this.forwardStack.length === 0) return null;
    this.backStack.push(this.current);
    this.current = this.forwardStack.pop();
    return this.current;
  }
}
```

### Expression Evaluation
```javascript
function evaluatePostfix(expr) {
  const stack = [];
  const tokens = expr.split(' ');

  for (const token of tokens) {
    if (!isNaN(token)) {
      stack.push(Number(token));
    } else {
      const b = stack.pop();
      const a = stack.pop();
      switch (token) {
        case '+': stack.push(a + b); break;
        case '-': stack.push(a - b); break;
        case '*': stack.push(a * b); break;
        case '/': stack.push(a / b); break;
      }
    }
  }
  return stack.pop();
}

console.log(evaluatePostfix('3 4 + 2 *'));  // 14
```

### Balanced Parentheses
```javascript
function isBalanced(str) {
  const stack = [];
  const pairs = {'(': ')', '[': ']', '{': '}'};

  for (const char of str) {
    if (char in pairs) {
      stack.push(char);
    } else if (Object.values(pairs).includes(char)) {
      const last = stack.pop();
      if (pairs[last] !== char) return false;
    }
  }
  return stack.length === 0;
}

console.log(isBalanced('()[]{}'));      // true
console.log(isBalanced('([{}])'));      // true
console.log(isBalanced('([)]'));        // false
```

### Function Call Stack
```javascript
function factorial(n) {
  console.log(`Push: factorial(${n})`);
  if (n <= 1) {
    console.log('Pop: return 1');
    return 1;
  }
  const result = n * factorial(n - 1);
  console.log(`Pop: return ${result}`);
  return result;
}

factorial(3);
// Push: factorial(3)
// Push: factorial(2)
// Push: factorial(1)
// Pop: return 1
// Pop: return 2
// Pop: return 6
```

## Performance

### Time Complexity
```javascript
// Array-based Stack
push()   // O(1) amortized
pop()    // O(1)
peek()   // O(1)
isEmpty()// O(1)
size()   // O(1)
```

### Space Complexity
```javascript
// O(n) where n is the number of elements
```

## Key Takeaways

- **LIFO** structure (Last In, First Out)
- Use **array methods** push()/pop() for simple stack
- **O(1)** push and pop operations
- Common uses: undo/redo, parsing, DFS, recursion
- JavaScript call stack is a stack
- Useful for reversing or tracking state
