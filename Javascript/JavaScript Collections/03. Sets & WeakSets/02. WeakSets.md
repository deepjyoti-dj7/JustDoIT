# WeakSets

## Creating WeakSets

### Basic Creation
```javascript
const weakSet = new WeakSet();

const obj1 = {id: 1};
const obj2 = {id: 2};

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1));  // true
```

### From Iterable
```javascript
const obj1 = {a: 1};
const obj2 = {b: 2};

const weakSet = new WeakSet([obj1, obj2]);

console.log(weakSet.has(obj1));  // true
```

### Only Objects Allowed
```javascript
const weakSet = new WeakSet();

// ✅ Objects allowed
weakSet.add({});
weakSet.add([]);
weakSet.add(new Date());

// ❌ Primitives not allowed
// weakSet.add(1);         // TypeError
// weakSet.add('string');  // TypeError
// weakSet.add(true);      // TypeError
// weakSet.add(null);      // TypeError
```

## WeakSet vs Set

### Comparison Table
| Feature | WeakSet | Set |
|---------|---------|-----|
| **Values** | Objects only | Any type |
| **Garbage Collection** | Values can be GC'd | Values prevent GC |
| **Iteration** | Not iterable | Iterable |
| **Size** | No `.size` property | Has `.size` |
| **Methods** | add, has, delete | add, has, delete, clear |
| **Use Cases** | Marking objects, private data | General collections |

### Memory Behavior
```javascript
// Regular Set prevents garbage collection
const set = new Set();
let obj1 = {data: 'large object'};
set.add(obj1);
obj1 = null;  // Object NOT garbage collected (Set still references it)

// WeakSet allows garbage collection
const weakSet = new WeakSet();
let obj2 = {data: 'large object'};
weakSet.add(obj2);
obj2 = null;  // Object CAN be garbage collected
```

### Why No Iteration
```javascript
// WeakSet cannot be iterated because:
// 1. Objects can be GC'd at any time
// 2. No guarantee which objects still exist
// 3. Size is non-deterministic

const weakSet = new WeakSet();

// ❌ These don't exist:
// weakSet.size
// weakSet.forEach()
// for (const item of weakSet) {}
// weakSet.clear()
```

## Garbage Collection

### Automatic Cleanup
```javascript
const weakSet = new WeakSet();

function createAndAdd() {
  const temp = {data: 'temporary'};
  weakSet.add(temp);
  // temp goes out of scope
}

createAndAdd();
// Object {data: 'temporary'} can now be garbage collected
// WeakSet automatically removes the reference
```

### Weak References Explained
```javascript
// Strong reference (prevents GC)
const set = new Set();
const obj = {id: 1};
set.add(obj);
// Even if 'obj' variable is deleted, Set keeps the object alive

// Weak reference (allows GC)
const weakSet = new WeakSet();
const obj2 = {id: 2};
weakSet.add(obj2);
// If 'obj2' is the only reference, object can be GC'd
// WeakSet doesn't prevent garbage collection
```

### Memory Leak Prevention
```javascript
// ❌ Potential memory leak with Set
const cache = new Set();

function processItems(items) {
  items.forEach(item => {
    cache.add(item);  // Items stay in memory forever
  });
}

// ✅ No leak with WeakSet
const processed = new WeakSet();

function processItems2(items) {
  items.forEach(item => {
    processed.add(item);  // Items can be GC'd when no longer needed
  });
}
```

## Use Cases

### Marking Objects as Processed
```javascript
const processed = new WeakSet();

function processItem(item) {
  if (processed.has(item)) {
    console.log('Already processed');
    return;
  }
  
  // Process item...
  console.log('Processing:', item);
  processed.add(item);
}

const obj = {id: 1};
processItem(obj);  // Processing
processItem(obj);  // Already processed
```

### Tracking DOM Elements
```javascript
const clickedElements = new WeakSet();

function setupClickTracking(element) {
  element.addEventListener('click', () => {
    if (clickedElements.has(element)) {
      console.log('Element clicked again');
    } else {
      console.log('First click');
      clickedElements.add(element);
    }
  });
}

// When element is removed from DOM and no other references exist,
// it can be garbage collected along with WeakSet entry
```

### Private Object Flags
```javascript
const privateFlags = new WeakSet();

class User {
  constructor(name) {
    this.name = name;
  }
  
  markAsAdmin() {
    privateFlags.add(this);
  }
  
  isAdmin() {
    return privateFlags.has(this);
  }
}

const user = new User('John');
console.log(user.isAdmin());  // false
user.markAsAdmin();
console.log(user.isAdmin());  // true
```

### Object Validation
```javascript
const validObjects = new WeakSet();

function validate(obj) {
  // Validation logic...
  if (obj.requiredField && obj.id > 0) {
    validObjects.add(obj);
    return true;
  }
  return false;
}

function isValid(obj) {
  return validObjects.has(obj);
}

const data = {id: 1, requiredField: 'value'};
validate(data);
console.log(isValid(data));  // true
```

### Preventing Circular Processing
```javascript
function deepProcess(obj, processed = new WeakSet()) {
  // Avoid infinite loops with circular references
  if (processed.has(obj)) {
    return;
  }
  
  processed.add(obj);
  
  // Process object
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepProcess(value, processed);
    }
  });
}

const circular = {a: 1};
circular.self = circular;
deepProcess(circular);  // Won't infinite loop
```

## Limitations

### Cannot Iterate
```javascript
const weakSet = new WeakSet([{a: 1}, {b: 2}]);

// ❌ Not possible:
// for (const item of weakSet) { }
// weakSet.forEach(() => {});
// [...weakSet]
```

### Cannot Get Size
```javascript
const weakSet = new WeakSet();
weakSet.add({});
weakSet.add({});

// ❌ No size property
// console.log(weakSet.size);  // undefined
```

### Cannot Clear All
```javascript
const weakSet = new WeakSet();
weakSet.add({a: 1});

// ❌ No clear method
// weakSet.clear();  // TypeError

// Only way to clear: create new WeakSet
let ws = new WeakSet([{a: 1}]);
ws = new WeakSet();  // Old one will be GC'd
```

### Cannot Store Primitives
```javascript
const weakSet = new WeakSet();

// ❌ All of these fail:
// weakSet.add(42);
// weakSet.add('string');
// weakSet.add(true);
// weakSet.add(Symbol('sym'));

// ✅ Only objects:
weakSet.add({});
weakSet.add([]);
weakSet.add(function() {});
```

## Best Practices

### When to Use WeakSet
```javascript
// ✅ Use WeakSet when:
// 1. Marking/tagging objects temporarily
const marked = new WeakSet();

// 2. Tracking object states without preventing GC
const active = new WeakSet();

// 3. Preventing circular reference issues
const visited = new WeakSet();

// 4. Private object metadata
const metadata = new WeakSet();
```

### When NOT to Use WeakSet
```javascript
// ❌ Don't use WeakSet when:
// 1. Need to iterate over values
const needIteration = new Set();  // Use Set

// 2. Need to know count
const needSize = new Set();  // Use Set

// 3. Storing primitives
const numbers = new Set();  // Use Set

// 4. Need to clear all at once
const needClear = new Set();  // Use Set
```

### Memory-Conscious Code
```javascript
// Good: WeakSet for temporary tracking
const processing = new WeakSet();

async function handleBatch(items) {
  for (const item of items) {
    if (!processing.has(item)) {
      processing.add(item);
      await processItem(item);
      // Don't need to delete - GC handles it
    }
  }
}
```

## Key Takeaways

- **WeakSet** stores only objects, allows garbage collection
- No iteration, no size, no clear() method
- **add(), has(), delete()** are the only methods
- Perfect for **marking objects** without preventing GC
- Use for **temporary tracking** or **object flags**
- Prevents **memory leaks** when tracking large/temporary objects
- Cannot store primitives (numbers, strings, booleans)
- Choose WeakSet when object lifecycle is uncertain
- Choose Set when you need iteration, size, or primitives
