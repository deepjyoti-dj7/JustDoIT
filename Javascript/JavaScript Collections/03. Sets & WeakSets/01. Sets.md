# Sets

## Creating Sets

### Basic Creation
```javascript
// Empty Set
const set = new Set();

// From array
const set2 = new Set([1, 2, 3, 4, 5]);
console.log(set2);  // Set {1, 2, 3, 4, 5}

// From string (each character)
const charSet = new Set('hello');
console.log(charSet);  // Set {'h', 'e', 'l', 'o'}
```

### Automatic Deduplication
```javascript
const set = new Set([1, 2, 2, 3, 3, 3, 4]);
console.log(set);  // Set {1, 2, 3, 4}
console.log(set.size);  // 4
```

### Clone Set
```javascript
const original = new Set([1, 2, 3]);
const clone = new Set(original);

clone.add(4);
console.log(original.size);  // 3
console.log(clone.size);     // 4
```

## Set Methods

### add() - Add Element
```javascript
const set = new Set();

set.add(1);
set.add(2);
set.add(3);

// Chaining
set.add(4).add(5).add(6);

// Duplicates ignored
set.add(1);  // Already exists
console.log(set.size);  // 6
```

### has() - Check Existence
```javascript
const set = new Set([1, 2, 3]);

console.log(set.has(2));  // true
console.log(set.has(5));  // false

// Use for validation
const validIds = new Set([1, 2, 3, 4]);
const isValid = validIds.has(userId);
```

### delete() - Remove Element
```javascript
const set = new Set([1, 2, 3, 4]);

const deleted = set.delete(2);
console.log(deleted);   // true
console.log(set.size);  // 3

const notDeleted = set.delete(10);
console.log(notDeleted);  // false
```

### clear() - Remove All
```javascript
const set = new Set([1, 2, 3]);

set.clear();
console.log(set.size);  // 0
```

## Set vs Array

### Comparison Table
| Feature | Set | Array |
|---------|-----|-------|
| **Duplicates** | No | Yes |
| **Order** | Insertion order | Index order |
| **Access** | Only via iteration | By index |
| **Search** | O(1) with `has()` | O(n) with `includes()` |
| **Add** | O(1) | O(1) push, O(n) unshift |
| **Delete** | O(1) | O(n) |
| **Size** | `.size` | `.length` |

### Performance Comparison
```javascript
const arr = Array.from({length: 100000}, (_, i) => i);
const set = new Set(arr);

// Check existence
console.time('Array includes');
arr.includes(99999);  // O(n)
console.timeEnd('Array includes');

console.time('Set has');
set.has(99999);  // O(1) - much faster
console.timeEnd('Set has');
```

### When to Use Set
```javascript
// ✅ Use Set for:
// - Unique values
const uniqueIds = new Set([1, 1, 2, 2, 3]);

// - Fast membership testing
const allowedOrigins = new Set(['https://app.com', 'https://api.com']);
if (allowedOrigins.has(origin)) { /* ... */ }

// - Removing duplicates
const arr = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(arr)];
```

### When to Use Array
```javascript
// ✅ Use Array for:
// - Ordered collection with duplicates
const scores = [85, 90, 85, 78, 90];

// - Index access needed
const items = ['a', 'b', 'c'];
console.log(items[1]);  // 'b'

// - Array methods (map, filter, reduce)
const doubled = items.map(x => x + x);
```

## Iterating Sets

### for...of
```javascript
const set = new Set(['a', 'b', 'c']);

for (const value of set) {
  console.log(value);  // 'a', 'b', 'c'
}
```

### forEach()
```javascript
const set = new Set([1, 2, 3]);

set.forEach((value, valueAgain, setRef) => {
  console.log(value);  // Note: value === valueAgain
});
```

### Convert to Array
```javascript
const set = new Set([1, 2, 3]);

// Spread
const arr1 = [...set];

// Array.from()
const arr2 = Array.from(set);

console.log(arr1);  // [1, 2, 3]
```

### values() and keys()
```javascript
const set = new Set(['a', 'b', 'c']);

// values() and keys() are identical for Sets
for (const value of set.values()) {
  console.log(value);
}

for (const key of set.keys()) {
  console.log(key);  // Same as values()
}
```

## Set Operations

### Union (A ∪ B)
```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([3, 4, 5]);

const union = new Set([...setA, ...setB]);
console.log(union);  // Set {1, 2, 3, 4, 5}

// ES2025: Native union
// const union = setA.union(setB);
```

### Intersection (A ∩ B)
```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([2, 3, 4]);

const intersection = new Set(
  [...setA].filter(x => setB.has(x))
);
console.log(intersection);  // Set {2, 3}

// ES2025: Native intersection
// const intersection = setA.intersection(setB);
```

### Difference (A - B)
```javascript
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([3, 4, 5]);

const difference = new Set(
  [...setA].filter(x => !setB.has(x))
);
console.log(difference);  // Set {1, 2}

// ES2025: Native difference
// const difference = setA.difference(setB);
```

### Symmetric Difference (A △ B)
```javascript
const setA = new Set([1, 2, 3]);
const setB = new Set([3, 4, 5]);

const symmetricDiff = new Set([
  ...[...setA].filter(x => !setB.has(x)),
  ...[...setB].filter(x => !setA.has(x))
]);
console.log(symmetricDiff);  // Set {1, 2, 4, 5}

// ES2025: Native symmetricDifference
// const symmetricDiff = setA.symmetricDifference(setB);
```

### Subset Check (A ⊆ B)
```javascript
const setA = new Set([1, 2]);
const setB = new Set([1, 2, 3, 4]);

const isSubset = [...setA].every(x => setB.has(x));
console.log(isSubset);  // true

// ES2025: Native isSubsetOf
// const isSubset = setA.isSubsetOf(setB);
```

### Superset Check (A ⊇ B)
```javascript
const setA = new Set([1, 2, 3, 4]);
const setB = new Set([1, 2]);

const isSuperset = [...setB].every(x => setA.has(x));
console.log(isSuperset);  // true

// ES2025: Native isSupersetOf
// const isSuperset = setA.isSupersetOf(setB);
```

## Removing Duplicates

### Array Deduplication
```javascript
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = [...new Set(arr)];
console.log(unique);  // [1, 2, 3, 4, 5]
```

### Object Array Deduplication
```javascript
const users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Jane'},
  {id: 1, name: 'John'}
];

// By property
const uniqueById = [...new Map(users.map(u => [u.id, u])).values()];
console.log(uniqueById);  // [{id: 1, ...}, {id: 2, ...}]
```

### String Deduplication
```javascript
const str = 'hello';
const uniqueChars = [...new Set(str)].join('');
console.log(uniqueChars);  // 'helo'
```

### Case-Insensitive Deduplication
```javascript
const words = ['Hello', 'WORLD', 'hello', 'World'];
const seen = new Set();
const unique = words.filter(word => {
  const lower = word.toLowerCase();
  if (seen.has(lower)) return false;
  seen.add(lower);
  return true;
});
console.log(unique);  // ['Hello', 'WORLD']
```

## Practical Examples

### Tag Management
```javascript
class TagManager {
  constructor() {
    this.tags = new Set();
  }
  
  addTag(tag) {
    this.tags.add(tag.toLowerCase());
  }
  
  removeTag(tag) {
    this.tags.delete(tag.toLowerCase());
  }
  
  hasTag(tag) {
    return this.tags.has(tag.toLowerCase());
  }
  
  getTags() {
    return [...this.tags];
  }
}

const manager = new TagManager();
manager.addTag('JavaScript');
manager.addTag('javascript');  // Ignored (duplicate)
console.log(manager.getTags());  // ['javascript']
```

### Visited Pages Tracker
```javascript
const visitedPages = new Set();

function visitPage(url) {
  if (visitedPages.has(url)) {
    console.log('Returning to:', url);
  } else {
    console.log('First visit:', url);
    visitedPages.add(url);
  }
}

visitPage('/home');     // First visit
visitPage('/about');    // First visit
visitPage('/home');     // Returning to
```

## Key Takeaways

- **Set** stores unique values in insertion order
- **O(1)** for add, delete, has operations (very fast)
- Automatically removes duplicates
- **add(), has(), delete(), clear()** are main methods
- Not indexable (no `set[0]`), use iteration or convert to array
- Perfect for **membership testing** and **deduplication**
- Set operations: union, intersection, difference (custom or ES2025 native)
- Convert Set ↔ Array with spread `[...set]` or `Array.from(set)`
- Use Set over Array when **uniqueness** and **fast lookups** matter
