# Task Parallelism

## Table of Contents
- [What is Task Parallelism?](#what-is-task-parallelism)
- [Web Workers for Tasks](#web-workers-for-tasks)
- [Worker Pools](#worker-pools)
- [Task Distribution](#task-distribution)
- [Load Balancing](#load-balancing)
- [Error Handling](#error-handling)
- [Performance Optimization](#performance-optimization)
- [Real-World Examples](#real-world-examples)

---

## What is Task Parallelism?

**Task parallelism** executes different tasks simultaneously across multiple threads/workers.

**Characteristics:**
- Different operations run in parallel
- Each task may be different
- Focus on doing multiple things at once
- Good for independent tasks

```javascript
// Sequential (slow)
const user = await fetchUser()
const posts = await fetchPosts()
const comments = await fetchComments()

// Parallel (fast)
const [user, posts, comments] = await Promise.all([
  fetchUser(),
  fetchPosts(),
  fetchComments()
])
```

---

## Web Workers for Tasks

### Basic Task Worker:

```javascript
// task-worker.js
self.onmessage = (e) => {
  const { taskId, type, data } = e.data
  
  let result
  switch (type) {
    case 'compute':
      result = computeTask(data)
      break
    case 'process':
      result = processTask(data)
      break
    case 'analyze':
      result = analyzeTask(data)
      break
  }
  
  self.postMessage({ taskId, result })
}
```

### Task Manager:

```javascript
class TaskManager {
  constructor(workerScript, numWorkers = 4) {
    this.workers = []
    this.taskQueue = []
    this.pendingTasks = new Map()
    this.nextTaskId = 0
    
    for (let i = 0; i < numWorkers; i++) {
      const worker = new Worker(workerScript)
      worker.onmessage = (e) => this.handleResult(e.data)
      this.workers.push({ worker, busy: false })
    }
  }
  
  async executeTask(type, data) {
    return new Promise((resolve, reject) => {
      const taskId = this.nextTaskId++
      this.pendingTasks.set(taskId, { resolve, reject })
      
      const availableWorker = this.workers.find(w => !w.busy)
      
      if (availableWorker) {
        this.assignTask(availableWorker, { taskId, type, data })
      } else {
        this.taskQueue.push({ taskId, type, data })
      }
    })
  }
  
  assignTask(workerInfo, task) {
    workerInfo.busy = true
    workerInfo.worker.postMessage(task)
  }
  
  handleResult({ taskId, result, error }) {
    const task = this.pendingTasks.get(taskId)
    this.pendingTasks.delete(taskId)
    
    // Find worker that completed this task
    const workerInfo = this.workers.find(w => w.busy)
    if (workerInfo) {
      workerInfo.busy = false
      
      // Assign next task if available
      if (this.taskQueue.length > 0) {
        const nextTask = this.taskQueue.shift()
        this.assignTask(workerInfo, nextTask)
      }
    }
    
    if (error) {
      task.reject(new Error(error))
    } else {
      task.resolve(result)
    }
  }
}

// Usage
const taskManager = new TaskManager('task-worker.js', 4)

const results = await Promise.all([
  taskManager.executeTask('compute', { value: 10 }),
  taskManager.executeTask('process', { data: [1, 2, 3] }),
  taskManager.executeTask('analyze', { text: 'hello' })
])
```

---

## Worker Pools

### Simple Worker Pool:

```javascript
class WorkerPool {
  constructor(workerScript, size = navigator.hardwareConcurrency || 4) {
    this.workers = []
    this.queue = []
    
    for (let i = 0; i < size; i++) {
      this.workers.push({
        worker: new Worker(workerScript),
        busy: false,
        resolve: null
      })
      
      this.workers[i].worker.onmessage = (e) => {
        this.workers[i].resolve(e.data)
        this.workers[i].busy = false
        this.processQueue()
      }
    }
  }
  
  async execute(data) {
    return new Promise((resolve) => {
      const availableWorker = this.workers.find(w => !w.busy)
      
      if (availableWorker) {
        availableWorker.busy = true
        availableWorker.resolve = resolve
        availableWorker.worker.postMessage(data)
      } else {
        this.queue.push({ data, resolve })
      }
    })
  }
  
  processQueue() {
    if (this.queue.length === 0) return
    
    const availableWorker = this.workers.find(w => !w.busy)
    if (availableWorker) {
      const { data, resolve } = this.queue.shift()
      availableWorker.busy = true
      availableWorker.resolve = resolve
      availableWorker.worker.postMessage(data)
    }
  }
  
  terminate() {
    this.workers.forEach(w => w.worker.terminate())
  }
}

// Usage
const pool = new WorkerPool('compute-worker.js', 4)

const tasks = Array.from({ length: 100 }, (_, i) => i)
const results = await Promise.all(
  tasks.map(task => pool.execute({ value: task }))
)
```

---

## Task Distribution

### Round-Robin:

```javascript
class RoundRobinPool {
  constructor(workerScript, size) {
    this.workers = Array.from({ length: size }, () => new Worker(workerScript))
    this.currentIndex = 0
  }
  
  execute(data) {
    return new Promise((resolve) => {
      const worker = this.workers[this.currentIndex]
      
      worker.onmessage = (e) => {
        resolve(e.data)
      }
      
      worker.postMessage(data)
      this.currentIndex = (this.currentIndex + 1) % this.workers.length
    })
  }
}
```

### Least-Loaded:

```javascript
class LeastLoadedPool {
  constructor(workerScript, size) {
    this.workers = Array.from({ length: size }, () => ({
      worker: new Worker(workerScript),
      load: 0
    }))
  }
  
  execute(data) {
    return new Promise((resolve) => {
      // Find worker with lowest load
      const workerInfo = this.workers.reduce((min, w) =>
        w.load < min.load ? w : min
      )
      
      workerInfo.load++
      
      workerInfo.worker.onmessage = (e) => {
        workerInfo.load--
        resolve(e.data)
      }
      
      workerInfo.worker.postMessage(data)
    })
  }
}
```

---

## Load Balancing

### Dynamic Worker Creation:

```javascript
class DynamicWorkerPool {
  constructor(workerScript, minWorkers = 2, maxWorkers = 8) {
    this.workerScript = workerScript
    this.minWorkers = minWorkers
    this.maxWorkers = maxWorkers
    this.workers = []
    this.queue = []
    
    // Start with minimum workers
    for (let i = 0; i < minWorkers; i++) {
      this.addWorker()
    }
    
    // Monitor queue and adjust
    setInterval(() => this.adjustWorkers(), 1000)
  }
  
  addWorker() {
    if (this.workers.length >= this.maxWorkers) return
    
    const worker = new Worker(this.workerScript)
    const workerInfo = { worker, busy: false }
    
    worker.onmessage = (e) => {
      workerInfo.resolve(e.data)
      workerInfo.busy = false
      this.processQueue()
    }
    
    this.workers.push(workerInfo)
  }
  
  removeWorker() {
    if (this.workers.length <= this.minWorkers) return
    
    const idleWorker = this.workers.find(w => !w.busy)
    if (idleWorker) {
      idleWorker.worker.terminate()
      this.workers = this.workers.filter(w => w !== idleWorker)
    }
  }
  
  adjustWorkers() {
    const busyCount = this.workers.filter(w => w.busy).length
    const utilization = busyCount / this.workers.length
    
    if (utilization > 0.8 && this.queue.length > 0) {
      this.addWorker()
    } else if (utilization < 0.2 && this.workers.length > this.minWorkers) {
      this.removeWorker()
    }
  }
  
  execute(data) {
    return new Promise((resolve) => {
      const availableWorker = this.workers.find(w => !w.busy)
      
      if (availableWorker) {
        availableWorker.busy = true
        availableWorker.resolve = resolve
        availableWorker.worker.postMessage(data)
      } else {
        this.queue.push({ data, resolve })
      }
    })
  }
  
  processQueue() {
    if (this.queue.length === 0) return
    
    const availableWorker = this.workers.find(w => !w.busy)
    if (availableWorker) {
      const { data, resolve } = this.queue.shift()
      availableWorker.busy = true
      availableWorker.resolve = resolve
      availableWorker.worker.postMessage(data)
    }
  }
}
```

---

## Error Handling

### Retry on Failure:

```javascript
class RobustWorkerPool {
  constructor(workerScript, size, maxRetries = 3) {
    this.workerScript = workerScript
    this.size = size
    this.maxRetries = maxRetries
    this.workers = []
    
    for (let i = 0; i < size; i++) {
      this.createWorker(i)
    }
  }
  
  createWorker(index) {
    const worker = new Worker(this.workerScript)
    
    worker.onerror = (error) => {
      console.error(`Worker ${index} error:`, error)
      worker.terminate()
      this.createWorker(index)  // Recreate worker
    }
    
    this.workers[index] = { worker, busy: false }
  }
  
  async execute(data, retries = 0) {
    try {
      return await this.executeOnce(data)
    } catch (error) {
      if (retries < this.maxRetries) {
        console.log(`Retrying task (attempt ${retries + 1})`)
        return this.execute(data, retries + 1)
      }
      throw error
    }
  }
  
  executeOnce(data) {
    return new Promise((resolve, reject) => {
      const availableWorker = this.workers.find(w => !w.busy)
      
      if (!availableWorker) {
        reject(new Error('No workers available'))
        return
      }
      
      availableWorker.busy = true
      
      const timeout = setTimeout(() => {
        reject(new Error('Task timeout'))
        availableWorker.busy = false
      }, 30000)
      
      availableWorker.worker.onmessage = (e) => {
        clearTimeout(timeout)
        availableWorker.busy = false
        
        if (e.data.error) {
          reject(new Error(e.data.error))
        } else {
          resolve(e.data)
        }
      }
      
      availableWorker.worker.postMessage(data)
    })
  }
}
```

---

## Performance Optimization

### Batch Processing:

```javascript
class BatchWorkerPool {
  constructor(workerScript, size, batchSize = 10) {
    this.pool = new WorkerPool(workerScript, size)
    this.batchSize = batchSize
  }
  
  async executeBatch(tasks) {
    const batches = []
    
    for (let i = 0; i < tasks.length; i += this.batchSize) {
      const batch = tasks.slice(i, i + this.batchSize)
      batches.push(
        this.pool.execute({ batch })
      )
    }
    
    const results = await Promise.all(batches)
    return results.flat()
  }
}
```

### Prioritized Tasks:

```javascript
class PriorityWorkerPool {
  constructor(workerScript, size) {
    this.pool = new WorkerPool(workerScript, size)
    this.highPriorityQueue = []
    this.normalPriorityQueue = []
  }
  
  execute(data, priority = 'normal') {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject }
      
      if (priority === 'high') {
        this.highPriorityQueue.push(task)
      } else {
        this.normalPriorityQueue.push(task)
      }
      
      this.processQueue()
    })
  }
  
  async processQueue() {
    const task = this.highPriorityQueue.shift() || this.normalPriorityQueue.shift()
    
    if (task) {
      try {
        const result = await this.pool.execute(task.data)
        task.resolve(result)
      } catch (error) {
        task.reject(error)
      }
      
      if (this.highPriorityQueue.length > 0 || this.normalPriorityQueue.length > 0) {
        this.processQueue()
      }
    }
  }
}
```

---

## Real-World Examples

### 1. Parallel API Requests:

```javascript
const pool = new WorkerPool('api-worker.js', 5)

const userIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

const users = await Promise.all(
  userIds.map(id => pool.execute({ endpoint: `/users/${id}` }))
)
```

### 2. Image Processing Pipeline:

```javascript
const taskManager = new TaskManager('image-worker.js', 4)

async function processImages(images) {
  const results = await Promise.all(images.map(async (image) => {
    const resized = await taskManager.executeTask('resize', image)
    const filtered = await taskManager.executeTask('filter', resized)
    const compressed = await taskManager.executeTask('compress', filtered)
    return compressed
  }))
  
  return results
}
```

### 3. Data Analysis:

```javascript
const pool = new WorkerPool('analysis-worker.js', 8)

async function analyzeDataset(data) {
  // Parallel analysis tasks
  const [stats, trends, anomalies, correlations] = await Promise.all([
    pool.execute({ task: 'statistics', data }),
    pool.execute({ task: 'trends', data }),
    pool.execute({ task: 'anomalies', data }),
    pool.execute({ task: 'correlations', data })
  ])
  
  return { stats, trends, anomalies, correlations }
}
```

---

## Summary

### Key Concepts:
- Different tasks run in parallel
- Worker pools manage task distribution
- Load balancing optimizes performance
- Error handling ensures reliability

### When to Use:
- ✅ Independent tasks
- ✅ Different operations
- ✅ API requests
- ✅ Pipeline processing
- ❌ Dependent sequential tasks
- ❌ Shared state requirements

### Best Practices:
- Use worker pools
- Implement error handling
- Monitor worker utilization
- Adjust pool size dynamically
- Handle task priorities

### Related Topics:
- Data parallelism
- Web Workers
- Load balancing
- Async patterns
