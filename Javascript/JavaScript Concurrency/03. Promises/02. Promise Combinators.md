# Promise Combinators

## Table of Contents
- [Overview](#overview)
- [Promise.all()](#promiseall)
- [Promise.race()](#promiserace)
- [Promise.allSettled()](#promiseallsettled)
- [Promise.any()](#promiseany)
- [Comparison Table](#comparison-table)
- [Real-World Examples](#real-world-examples)
- [Best Practices](#best-practices)

---

## Overview

**Combinators** allow you to work with multiple promises simultaneously.

| Method | Resolves When | Rejects When | Use Case |
|--------|--------------|--------------|----------|
| `all()` | All resolve | Any rejects | All required |
| `race()` | First settles | First rejects | Fastest wins |
| `allSettled()` | All settle | Never | Need all results |
| `any()` | First resolves | All reject | First success |

---

## Promise.all()

Waits for **all** promises to resolve, or **any** to reject.

### Syntax:

```javascript
Promise.all([promise1, promise2, promise3])
  .then(([result1, result2, result3]) => {
    // All succeeded
  })
  .catch(err => {
    // Any failed
  })
```

### Basic Example:

```javascript
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2)
const p3 = Promise.resolve(3)

Promise.all([p1, p2, p3])
  .then(results => console.log(results))  // [1, 2, 3]
```

### With Async Operations:

```javascript
const fetchUser = id => 
  new Promise(resolve => setTimeout(() => resolve({ id, name: 'User' + id }), 100))

Promise.all([
  fetchUser(1),
  fetchUser(2),
  fetchUser(3)
])
  .then(users => {
    console.log('All users:', users)
    // [{ id: 1, name: 'User1' }, ...]
  })
  .catch(err => console.error('Failed:', err))
```

### Fails Fast:

```javascript
const p1 = new Promise(resolve => setTimeout(() => resolve('Success'), 2000))
const p2 = new Promise((_, reject) => setTimeout(() => reject('Error'), 1000))
const p3 = new Promise(resolve => setTimeout(() => resolve('Success'), 3000))

Promise.all([p1, p2, p3])
  .then(results => console.log(results))  // Never reaches here
  .catch(err => console.error(err))       // 'Error' after 1 second

// p3 continues running but result is ignored
```

### Use Cases:

```javascript
// 1. Fetch multiple resources
Promise.all([
  fetch('/api/user'),
  fetch('/api/posts'),
  fetch('/api/comments')
])
  .then(async ([userRes, postsRes, commentsRes]) => {
    const user = await userRes.json()
    const posts = await postsRes.json()
    const comments = await commentsRes.json()
    return { user, posts, comments }
  })

// 2. Parallel processing
const items = [1, 2, 3, 4, 5]
Promise.all(items.map(item => processItem(item)))
  .then(results => console.log('All processed:', results))

// 3. Wait for multiple operations
Promise.all([
  saveToDatabase(data),
  sendEmail(user),
  updateCache(key)
])
  .then(() => console.log('All operations complete'))
```

---

## Promise.race()

Resolves or rejects as soon as **any** promise settles.

### Syntax:

```javascript
Promise.race([promise1, promise2, promise3])
  .then(result => {
    // First to resolve
  })
  .catch(err => {
    // First to reject
  })
```

### Basic Example:

```javascript
const p1 = new Promise(resolve => setTimeout(() => resolve('First'), 100))
const p2 = new Promise(resolve => setTimeout(() => resolve('Second'), 200))
const p3 = new Promise(resolve => setTimeout(() => resolve('Third'), 300))

Promise.race([p1, p2, p3])
  .then(result => console.log(result))  // 'First' (after 100ms)
```

### Timeout Pattern:

```javascript
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), ms)
  )
  return Promise.race([promise, timeout])
}

withTimeout(fetchData(), 5000)
  .then(data => console.log('Data:', data))
  .catch(err => console.error(err))  // 'Timeout' if > 5s
```

### Use Cases:

```javascript
// 1. Timeout implementation
const dataPromise = fetch('/api/slow-endpoint')
const timeoutPromise = new Promise((_, reject) => 
  setTimeout(() => reject(new Error('Request timeout')), 3000)
)

Promise.race([dataPromise, timeoutPromise])
  .then(data => console.log(data))
  .catch(err => console.error(err))

// 2. Fastest server wins
Promise.race([
  fetch('https://server1.com/api/data'),
  fetch('https://server2.com/api/data'),
  fetch('https://server3.com/api/data')
])
  .then(response => response.json())
  .then(data => console.log('Fastest server data:', data))

// 3. User cancellation
Promise.race([
  longRunningTask(),
  userCancellation  // Promise that rejects when user clicks cancel
])
```

---

## Promise.allSettled()

Waits for **all** promises to settle (resolve or reject).

### Syntax:

```javascript
Promise.allSettled([promise1, promise2, promise3])
  .then(results => {
    // All settled, check each result
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('Success:', result.value)
      } else {
        console.log('Failed:', result.reason)
      }
    })
  })
```

### Basic Example:

```javascript
const p1 = Promise.resolve('Success')
const p2 = Promise.reject('Error')
const p3 = Promise.resolve('Another success')

Promise.allSettled([p1, p2, p3])
  .then(results => console.log(results))

// Output:
// [
//   { status: 'fulfilled', value: 'Success' },
//   { status: 'rejected', reason: 'Error' },
//   { status: 'fulfilled', value: 'Another success' }
// ]
```

### Processing Results:

```javascript
Promise.allSettled([
  fetchUser(1),
  fetchUser(2),
  fetchUser(3)
])
  .then(results => {
    const successful = results
      .filter(r => r.status === 'fulfilled')
      .map(r => r.value)
    
    const failed = results
      .filter(r => r.status === 'rejected')
      .map(r => r.reason)
    
    console.log('Successful:', successful)
    console.log('Failed:', failed)
  })
```

### Use Cases:

```javascript
// 1. Multiple API calls where failures are acceptable
const userIds = [1, 2, 3, 4, 5]

Promise.allSettled(
  userIds.map(id => fetchUser(id))
)
  .then(results => {
    const users = results
      .filter(r => r.status === 'fulfilled')
      .map(r => r.value)
    
    console.log(`Loaded ${users.length}/${userIds.length} users`)
  })

// 2. Batch operations with error tolerance
Promise.allSettled([
  saveToDatabase(data1),
  saveToDatabase(data2),
  saveToDatabase(data3)
])
  .then(results => {
    const saved = results.filter(r => r.status === 'fulfilled').length
    const failed = results.filter(r => r.status === 'rejected').length
    console.log(`Saved: ${saved}, Failed: ${failed}`)
  })
```

---

## Promise.any()

Resolves when **any** promise resolves, rejects only if **all** reject.

### Syntax:

```javascript
Promise.any([promise1, promise2, promise3])
  .then(result => {
    // First to resolve
  })
  .catch(err => {
    // All rejected (AggregateError)
  })
```

### Basic Example:

```javascript
const p1 = Promise.reject('Error 1')
const p2 = new Promise(resolve => setTimeout(() => resolve('Success'), 100))
const p3 = Promise.reject('Error 3')

Promise.any([p1, p2, p3])
  .then(result => console.log(result))  // 'Success'
  .catch(err => console.error(err))
```

### All Rejected:

```javascript
const p1 = Promise.reject('Error 1')
const p2 = Promise.reject('Error 2')
const p3 = Promise.reject('Error 3')

Promise.any([p1, p2, p3])
  .catch(err => {
    console.log(err instanceof AggregateError)  // true
    console.log(err.errors)  // ['Error 1', 'Error 2', 'Error 3']
  })
```

### Use Cases:

```javascript
// 1. Fallback servers (first successful response)
Promise.any([
  fetch('https://primary-server.com/api'),
  fetch('https://backup-server-1.com/api'),
  fetch('https://backup-server-2.com/api')
])
  .then(response => response.json())
  .then(data => console.log('Data from fastest working server:', data))
  .catch(() => console.error('All servers failed'))

// 2. Resource loading with fallbacks
Promise.any([
  loadFromCDN('https://cdn1.example.com/lib.js'),
  loadFromCDN('https://cdn2.example.com/lib.js'),
  loadFromLocal('/local/lib.js')
])
  .then(() => console.log('Library loaded'))
  .catch(() => console.error('Failed to load library'))
```

---

## Comparison Table

```javascript
const p1 = Promise.resolve('A')
const p2 = Promise.reject('B')
const p3 = new Promise(r => setTimeout(() => r('C'), 1000))

// Promise.all() - Fails if any fails
Promise.all([p1, p2, p3])
  .then(results => console.log(results))
  .catch(err => console.error('all:', err))  // 'all: B'

// Promise.race() - First to settle
Promise.race([p1, p2, p3])
  .then(result => console.log('race:', result))  // 'race: A'

// Promise.allSettled() - Wait for all
Promise.allSettled([p1, p2, p3])
  .then(results => console.log('allSettled:', results))
  // allSettled: [
  //   { status: 'fulfilled', value: 'A' },
  //   { status: 'rejected', reason: 'B' },
  //   { status: 'fulfilled', value: 'C' }
  // ]

// Promise.any() - First success
Promise.any([p1, p2, p3])
  .then(result => console.log('any:', result))  // 'any: A'
```

---

## Real-World Examples

### Example 1: Parallel Data Fetching

```javascript
async function loadDashboard(userId) {
  try {
    const [user, stats, notifications, activity] = await Promise.all([
      fetch(`/api/users/${userId}`).then(r => r.json()),
      fetch(`/api/stats/${userId}`).then(r => r.json()),
      fetch(`/api/notifications/${userId}`).then(r => r.json()),
      fetch(`/api/activity/${userId}`).then(r => r.json())
    ])
    
    return { user, stats, notifications, activity }
  } catch (err) {
    console.error('Dashboard load failed:', err)
    throw err
  }
}
```

### Example 2: Resilient API Calls

```javascript
function fetchWithFallback(urls) {
  return Promise.any(
    urls.map(url => 
      fetch(url)
        .then(r => {
          if (!r.ok) throw new Error(`HTTP ${r.status}`)
          return r.json()
        })
    )
  )
}

fetchWithFallback([
  'https://api1.example.com/data',
  'https://api2.example.com/data',
  'https://api3.example.com/data'
])
  .then(data => console.log('Data:', data))
  .catch(err => console.error('All APIs failed:', err.errors))
```

### Example 3: Batch Processing with Reports

```javascript
async function processBatch(items) {
  const results = await Promise.allSettled(
    items.map(item => processItem(item))
  )
  
  const report = {
    total: results.length,
    successful: results.filter(r => r.status === 'fulfilled').length,
    failed: results.filter(r => r.status === 'rejected').length,
    errors: results
      .filter(r => r.status === 'rejected')
      .map(r => r.reason.message)
  }
  
  console.log('Batch processing report:', report)
  return report
}
```

---

## Best Practices

### 1. Choose the Right Combinator

```javascript
// Use Promise.all when all must succeed
Promise.all([required1(), required2(), required3()])

// Use Promise.allSettled when you need all results
Promise.allSettled([optional1(), optional2(), optional3()])

// Use Promise.race for timeout or fastest wins
Promise.race([fetchData(), timeout(5000)])

// Use Promise.any for fallbacks
Promise.any([primary(), backup1(), backup2()])
```

### 2. Handle Empty Arrays

```javascript
Promise.all([])  // Resolves immediately with []
Promise.race([]) // Never settles (pending forever)
Promise.allSettled([])  // Resolves immediately with []
Promise.any([])  // Rejects with AggregateError
```

### 3. Error Handling

```javascript
// Always handle errors
Promise.all(promises)
  .then(results => processResults(results))
  .catch(err => {
    console.error('Operation failed:', err)
    // Fallback or retry logic
  })
```

---

## Summary

### Quick Reference:
- **Promise.all()**: All must succeed, fail-fast
- **Promise.race()**: First to settle wins
- **Promise.allSettled()**: Get all results, never fails
- **Promise.any()**: First success wins, fail if all fail

### When to Use:
- **All required**: `Promise.all()`
- **Need all results**: `Promise.allSettled()`
- **Timeout/fastest**: `Promise.race()`
- **Fallback servers**: `Promise.any()`
## Error Handling
