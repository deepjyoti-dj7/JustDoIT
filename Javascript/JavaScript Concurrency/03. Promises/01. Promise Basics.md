# Promise Basics

## Table of Contents
- [What are Promises?](#what-are-promises)
- [Creating Promises](#creating-promises)
- [Promise States](#promise-states)
- [then(), catch(), finally()](#then-catch-finally)
- [Promise Chaining](#promise-chaining)
- [Error Propagation](#error-propagation)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)

---

## What are Promises?

A **Promise** is an object representing the eventual completion or failure of an asynchronous operation.

```javascript
// Callback approach
getData(url, (err, data) => {
  if (err) handleError(err)
  else processData(data)
})

// Promise approach
getData(url)
  .then(data => processData(data))
  .catch(err => handleError(err))
```

### Benefits:
- Better error handling
- Cleaner syntax
- Easier composition
- Built-in error propagation

---

## Creating Promises

### Basic Syntax:

```javascript
const promise = new Promise((resolve, reject) => {
  // Async operation
  if (success) {
    resolve(value)  // Success
  } else {
    reject(error)   // Failure
  }
})
```

### Examples:

```javascript
// Simple resolved promise
const resolvedPromise = new Promise((resolve) => {
  resolve('Success!')
})

// Simple rejected promise
const rejectedPromise = new Promise((resolve, reject) => {
  reject(new Error('Failed!'))
})

// Async operation
function fetchUser(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id > 0) {
        resolve({ id, name: 'John' })
      } else {
        reject(new Error('Invalid ID'))
      }
    }, 1000)
  })
}

fetchUser(1)
  .then(user => console.log(user))
  .catch(err => console.error(err))
```

### Shorthand Methods:

```javascript
// Already resolved
const resolved = Promise.resolve('Immediate value')

// Already rejected
const rejected = Promise.reject(new Error('Immediate error'))

// Useful for converting values to promises
Promise.resolve(42).then(n => console.log(n))  // 42
```

---

## Promise States

A promise can be in one of three states:

```
┌─────────┐
│ Pending │ ← Initial state
└────┬────┘
     │
     ├──────────┐
     │          │
     ▼          ▼
┌──────────┐  ┌──────────┐
│Fulfilled │  │ Rejected │ ← Final states
└──────────┘  └──────────┘
```

### 1. Pending

Initial state, neither fulfilled nor rejected.

```javascript
const promise = new Promise((resolve) => {
  // Still pending
  setTimeout(() => resolve('Done'), 1000)
})

console.log(promise)  // Promise { <pending> }
```

### 2. Fulfilled

Operation completed successfully.

```javascript
const promise = Promise.resolve('Success')
console.log(promise)  // Promise { 'Success' }
```

### 3. Rejected

Operation failed.

```javascript
const promise = Promise.reject(new Error('Failed'))
console.log(promise)  // Promise { <rejected> Error: Failed }
```

### State is Immutable:

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('First')
  resolve('Second')  // Ignored
  reject('Error')    // Ignored
})

promise.then(val => console.log(val))  // 'First'
// Once settled (fulfilled/rejected), state cannot change
```

---

## then(), catch(), finally()

### then()

Handles fulfilled promises.

```javascript
promise.then(
  value => console.log(value),      // Success handler
  error => console.error(error)      // Error handler (optional)
)

// Usually written as:
promise
  .then(value => console.log(value))
  .catch(error => console.error(error))
```

### catch()

Handles rejected promises.

```javascript
fetchData()
  .then(data => processData(data))
  .catch(err => console.error('Error:', err))

// Equivalent to:
fetchData()
  .then(data => processData(data))
  .then(undefined, err => console.error('Error:', err))
```

### finally()

Runs regardless of outcome.

```javascript
fetchData()
  .then(data => processData(data))
  .catch(err => handleError(err))
  .finally(() => {
    console.log('Cleanup')
    hideLoader()
  })

// finally doesn't receive any arguments
// and doesn't change the promise value
```

### Complete Example:

```javascript
function loadData() {
  showLoader()
  
  return fetchData()
    .then(data => {
      console.log('Data loaded:', data)
      return processData(data)
    })
    .catch(err => {
      console.error('Failed to load:', err)
      return defaultData  // Fallback
    })
    .finally(() => {
      hideLoader()
      console.log('Request completed')
    })
}
```

---

## Promise Chaining

Promises can be chained by returning values or promises from `.then()`.

### Basic Chaining:

```javascript
Promise.resolve(5)
  .then(n => n * 2)       // 10
  .then(n => n + 1)       // 11
  .then(n => n * 3)       // 33
  .then(result => console.log(result))  // 33
```

### Returning Promises:

```javascript
fetchUser(1)
  .then(user => {
    console.log('User:', user)
    return fetchOrders(user.id)  // Returns promise
  })
  .then(orders => {
    console.log('Orders:', orders)
    return fetchDetails(orders[0].id)
  })
  .then(details => {
    console.log('Details:', details)
  })
  .catch(err => console.error(err))
```

### Real-World Example:

```javascript
function processUserOrder(userId, orderId) {
  return fetchUser(userId)
    .then(user => {
      if (!user.active) {
        throw new Error('User inactive')
      }
      return fetchOrder(orderId)
    })
    .then(order => {
      if (order.userId !== userId) {
        throw new Error('Order mismatch')
      }
      return processPayment(order)
    })
    .then(payment => {
      return sendConfirmation(payment)
    })
    .then(confirmation => {
      console.log('Success:', confirmation)
      return confirmation
    })
    .catch(err => {
      console.error('Order processing failed:', err)
      throw err
    })
}
```

---

## Error Propagation

Errors automatically propagate down the chain.

### Basic Propagation:

```javascript
Promise.resolve()
  .then(() => {
    throw new Error('Error in step 1')
  })
  .then(() => {
    console.log('Step 2')  // Skipped
  })
  .then(() => {
    console.log('Step 3')  // Skipped
  })
  .catch(err => {
    console.error('Caught:', err.message)
  })
```

### Multiple catch Handlers:

```javascript
fetchData()
  .then(data => processData(data))
  .catch(err => {
    console.error('Processing failed:', err)
    return fallbackData  // Recover from error
  })
  .then(data => {
    console.log('Using:', data)  // Uses fallback if error
  })
  .catch(err => {
    console.error('Final error:', err)
  })
```

### Error Recovery:

```javascript
function fetchWithRetry(url, retries = 3) {
  return fetch(url)
    .catch(err => {
      if (retries > 0) {
        console.log(`Retrying... (${retries} left)`)
        return fetchWithRetry(url, retries - 1)
      }
      throw err
    })
}
```

---

## Common Patterns

### Pattern 1: Promisifying Callbacks

```javascript
// Callback version
function readFileCallback(path, callback) {
  fs.readFile(path, 'utf8', callback)
}

// Promise version
function readFilePromise(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, 'utf8', (err, data) => {
      if (err) reject(err)
      else resolve(data)
    })
  })
}

// Node.js util.promisify
const { promisify } = require('util')
const readFile = promisify(fs.readFile)
```

### Pattern 2: Conditional Chains

```javascript
function processOrder(order) {
  return validateOrder(order)
    .then(valid => {
      if (valid.requiresApproval) {
        return requestApproval(order)
          .then(() => processPayment(order))
      }
      return processPayment(order)
    })
}
```

### Pattern 3: Timeout

```javascript
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), ms)
  })
  
  return Promise.race([promise, timeout])
}

withTimeout(fetchData(), 5000)
  .then(data => console.log(data))
  .catch(err => console.error(err))  // 'Timeout' if > 5s
```

---

## Best Practices

### 1. Always Return in then()

```javascript
// ❌ Bad - doesn't return
promise.then(data => {
  processData(data)  // If this returns a promise, it's lost
})

// ✅ Good
promise.then(data => {
  return processData(data)
})
```

### 2. Always Handle Errors

```javascript
// ❌ Unhandled rejection
fetchData().then(data => console.log(data))

// ✅ With error handling
fetchData()
  .then(data => console.log(data))
  .catch(err => console.error(err))
```

### 3. Don't Nest Promises

```javascript
// ❌ Promise hell (like callback hell)
fetchUser()
  .then(user => {
    fetchOrders(user.id)
      .then(orders => {
        console.log(orders)  // Nested!
      })
  })

// ✅ Chain properly
fetchUser()
  .then(user => fetchOrders(user.id))
  .then(orders => console.log(orders))
```

### 4. Use Promise.resolve() for Consistency

```javascript
function getData(useCache) {
  if (useCache) {
    return Promise.resolve(cachedData)  // Consistent return type
  }
  return fetchData()  // Already returns promise
}
```

---

## Summary

### Key Concepts:
- Promises represent future values
- Three states: pending, fulfilled, rejected
- Chain with .then(), handle errors with .catch()
- Errors propagate automatically
- Always return from .then()

### Comparison:
```javascript
// Callbacks
operation1((err, result1) => {
  if (err) return handleError(err)
  operation2(result1, (err, result2) => {
    if (err) return handleError(err)
    // ...
  })
})

// Promises
operation1()
  .then(result1 => operation2(result1))
  .then(result2 => console.log(result2))
  .catch(handleError)
```

### Related Topics:
- Promise combinators (Promise.all, Promise.race)
- Async/await
- Error handling strategies
