# Promise Patterns

## Table of Contents
- [Sequential Execution](#sequential-execution)
- [Parallel Execution](#parallel-execution)
- [Retry Pattern](#retry-pattern)
- [Timeout Pattern](#timeout-pattern)
- [Caching Pattern](#caching-pattern)
- [Queue Pattern](#queue-pattern)
- [Circuit Breaker](#circuit-breaker)
- [Best Practices](#best-practices)

---

## Sequential Execution

Execute promises one after another.

### Using then() Chaining:

```javascript
fetchUser(1)
  .then(user => fetchOrders(user.id))
  .then(orders => fetchDetails(orders[0].id))
  .then(details => console.log(details))
  .catch(handleError)
```

### Using async/await:

```javascript
async function processSequentially() {
  try {
    const user = await fetchUser(1)
    const orders = await fetchOrders(user.id)
    const details = await fetchDetails(orders[0].id)
    console.log(details)
  } catch (err) {
    handleError(err)
  }
}
```

### Sequential Array Processing:

```javascript
// Process array items one by one
async function processSequential(items) {
  const results = []
  
  for (const item of items) {
    const result = await processItem(item)
    results.push(result)
  }
  
  return results
}

// Using reduce
function processWithReduce(items) {
  return items.reduce((promise, item) => {
    return promise.then(results => 
      processItem(item).then(result => [...results, result])
    )
  }, Promise.resolve([]))
}
```

---

## Parallel Execution

Execute multiple promises simultaneously.

### Promise.all():

```javascript
async function processParallel(items) {
  return Promise.all(items.map(item => processItem(item)))
}

// Usage
const results = await processParallel([1, 2, 3, 4, 5])
```

### Controlled Concurrency:

```javascript
async function processBatch(items, batchSize = 3) {
  const results = []
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    const batchResults = await Promise.all(
      batch.map(item => processItem(item))
    )
    results.push(...batchResults)
  }
  
  return results
}
```

### Pool Pattern:

```javascript
class PromisePool {
  constructor(concurrency) {
    this.concurrency = concurrency
    this.running = 0
    this.queue = []
  }
  
  async add(promiseFn) {
    while (this.running >= this.concurrency) {
      await Promise.race(this.queue)
    }
    
    this.running++
    
    const promise = promiseFn()
      .finally(() => {
        this.running--
        const index = this.queue.indexOf(promise)
        this.queue.splice(index, 1)
      })
    
    this.queue.push(promise)
    return promise
  }
}

// Usage
const pool = new PromisePool(3)
const results = await Promise.all(
  items.map(item => pool.add(() => processItem(item)))
)
```

---

## Retry Pattern

Retry failed operations.

### Simple Retry:

```javascript
async function retry(fn, maxAttempts = 3) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (err) {
      if (attempt === maxAttempts) throw err
      console.log(`Attempt ${attempt} failed, retrying...`)
    }
  }
}

// Usage
const data = await retry(() => fetchData(url), 5)
```

### Retry with Delay:

```javascript
function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

async function retryWithDelay(fn, maxAttempts = 3, delay = 1000) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (err) {
      if (attempt === maxAttempts) throw err
      console.log(`Attempt ${attempt} failed, waiting ${delay}ms...`)
      await wait(delay)
    }
  }
}
```

### Exponential Backoff:

```javascript
async function retryWithBackoff(fn, maxAttempts = 5) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (err) {
      if (attempt === maxAttempts) throw err
      
      const delay = Math.pow(2, attempt) * 1000  // 2s, 4s, 8s, 16s...
      console.log(`Retry ${attempt}, waiting ${delay}ms`)
      await wait(delay)
    }
  }
}
```

---

## Timeout Pattern

Add timeouts to promises.

### Basic Timeout:

```javascript
function timeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), ms)
    )
  ])
}

// Usage
try {
  const data = await timeout(fetchData(), 5000)
} catch (err) {
  console.error('Request timed out')
}
```

### With Cleanup:

```javascript
function timeoutWithCleanup(promise, ms, cleanup) {
  let timeoutId
  
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      cleanup?.()
      reject(new Error('Timeout'))
    }, ms)
  })
  
  return Promise.race([
    promise.finally(() => clearTimeout(timeoutId)),
    timeoutPromise
  ])
}
```

---

## Caching Pattern

Cache promise results.

### Simple Cache:

```javascript
class PromiseCache {
  constructor() {
    this.cache = new Map()
  }
  
  async get(key, promiseFn) {
    if (this.cache.has(key)) {
      return this.cache.get(key)
    }
    
    const promise = promiseFn()
    this.cache.set(key, promise)
    
    try {
      const result = await promise
      return result
    } catch (err) {
      // Remove failed promises from cache
      this.cache.delete(key)
      throw err
    }
  }
  
  clear() {
    this.cache.clear()
  }
}

// Usage
const cache = new PromiseCache()
const user = await cache.get('user:1', () => fetchUser(1))
```

### TTL Cache:

```javascript
class TTLCache {
  constructor(ttl = 60000) {
    this.cache = new Map()
    this.ttl = ttl
  }
  
  async get(key, promiseFn) {
    const cached = this.cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.value
    }
    
    const value = await promiseFn()
    this.cache.set(key, { value, timestamp: Date.now() })
    return value
  }
}
```

---

## Queue Pattern

Process promises in sequence.

### Simple Queue:

```javascript
class PromiseQueue {
  constructor() {
    this.queue = []
    this.processing = false
  }
  
  add(promiseFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ promiseFn, resolve, reject })
      this.process()
    })
  }
  
  async process() {
    if (this.processing || this.queue.length === 0) return
    
    this.processing = true
    
    while (this.queue.length > 0) {
      const { promiseFn, resolve, reject } = this.queue.shift()
      
      try {
        const result = await promiseFn()
        resolve(result)
      } catch (err) {
        reject(err)
      }
    }
    
    this.processing = false
  }
}

// Usage
const queue = new PromiseQueue()
queue.add(() => fetchData(1))
queue.add(() => fetchData(2))
```

---

## Circuit Breaker

Prevent cascading failures.

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0
    this.threshold = threshold
    this.timeout = timeout
    this.state = 'CLOSED'  // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now()
  }
  
  async execute(promiseFn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN')
      }
      this.state = 'HALF_OPEN'
    }
    
    try {
      const result = await promiseFn()
      this.onSuccess()
      return result
    } catch (err) {
      this.onFailure()
      throw err
    }
  }
  
  onSuccess() {
    this.failureCount = 0
    this.state = 'CLOSED'
  }
  
  onFailure() {
    this.failureCount++
    
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN'
      this.nextAttempt = Date.now() + this.timeout
    }
  }
}

// Usage
const breaker = new CircuitBreaker(3, 30000)
const data = await breaker.execute(() => fetchData())
```

---

## Best Practices

### 1. Handle Errors Properly:

```javascript
// ❌ Unhandled rejection
async function bad() {
  const data = await fetchData()
  return processData(data)
}

// ✅ With error handling
async function good() {
  try {
    const data = await fetchData()
    return processData(data)
  } catch (err) {
    console.error('Error:', err)
    return defaultData
  }
}
```

### 2. Use Appropriate Patterns:

```javascript
// Sequential when order matters
for (const item of items) {
  await processItem(item)
}

// Parallel when independent
await Promise.all(items.map(processItem))
```

### 3. Add Timeouts:

```javascript
// Always timeout long operations
const result = await timeout(longOperation(), 10000)
```

### 4. Cache Expensive Operations:

```javascript
const cache = new PromiseCache()
const data = await cache.get('key', () => expensiveOperation())
```

---

## Summary

### Pattern Selection Guide:

| Need | Pattern |
|------|---------|
| One after another | Sequential |
| All at once | Parallel (Promise.all) |
| Limited concurrency | Pool |
| Retry failures | Retry with backoff |
| Prevent hangs | Timeout |
| Avoid duplicate calls | Cache |
| Rate limiting | Queue |
| Fault tolerance | Circuit breaker |

### Key Takeaways:
- Choose the right pattern for your use case
- Always handle errors
- Add timeouts to prevent hangs
- Use caching for expensive operations
- Control concurrency to avoid overload
