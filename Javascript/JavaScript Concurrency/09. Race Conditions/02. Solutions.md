# Race Condition Solutions

## Table of Contents
- [Atomic Operations](#atomic-operations)
- [Locks and Mutexes](#locks-and-mutexes)
- [Lock-Free Algorithms](#lock-free-algorithms)
- [Immutability](#immutability)
- [Message Passing](#message-passing)
- [Thread-Safe Patterns](#thread-safe-patterns)
- [Best Practices](#best-practices)

---

## Atomic Operations

Use `Atomics` for simple operations on SharedArrayBuffer.

### Counter:

```javascript
// ❌ Race condition
counter[0]++

// ✅ Atomic
Atomics.add(counter, 0, 1)
```

### Conditional Update:

```javascript
// ✅ Compare-and-swap
function atomicMax(array, index, value) {
  while (true) {
    const current = Atomics.load(array, index)
    if (value <= current) return current
    
    const old = Atomics.compareExchange(array, index, current, value)
    if (old === current) return value
  }
}
```

### Flag Setting:

```javascript
// ✅ Atomic store/load
Atomics.store(flags, 0, 1)  // Set flag
const isSet = Atomics.load(flags, 0) === 1  // Check flag
```

---

## Locks and Mutexes

Protect critical sections with mutual exclusion.

### Simple Mutex:

```javascript
class Mutex {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.lock = new Int32Array(this.buffer)
  }
  
  acquire() {
    while (Atomics.compareExchange(this.lock, 0, 0, 1) !== 0) {
      Atomics.wait(this.lock, 0, 1, 100)
    }
  }
  
  release() {
    Atomics.store(this.lock, 0, 0)
    Atomics.notify(this.lock, 0, 1)
  }
}

// ✅ Protected critical section
const mutex = new Mutex()

mutex.acquire()
try {
  sharedData[0]++  // Safe
} finally {
  mutex.release()
}
```

### Bank Account Example:

```javascript
const mutex = new Mutex()

function transfer(from, to, amount) {
  mutex.acquire()
  try {
    if (accounts[from] >= amount) {
      accounts[from] -= amount
      accounts[to] += amount
      return true
    }
    return false
  } finally {
    mutex.release()
  }
}
```

### Read-Write Lock:

```javascript
class RWLock {
  // ... (implementation from Synchronization)
}

// ✅ Multiple readers, one writer
const rwLock = new RWLock()

// Read (many simultaneous)
rwLock.readLock()
const data = sharedData[0]
rwLock.readUnlock()

// Write (exclusive)
rwLock.writeLock()
sharedData[0] = newValue
rwLock.writeUnlock()
```

---

## Lock-Free Algorithms

Algorithms that don't use locks but avoid races.

### Lock-Free Stack:

```javascript
class LockFreeStack {
  constructor() {
    this.buffer = new SharedArrayBuffer(404)
    this.view = new Int32Array(this.buffer)
    this.view[0] = -1  // Top index
    // view[1..100] = stack data
  }
  
  push(value) {
    while (true) {
      const top = Atomics.load(this.view, 0)
      const newTop = top + 1
      
      if (newTop >= 100) throw new Error('Stack full')
      
      this.view[1 + newTop] = value
      
      if (Atomics.compareExchange(this.view, 0, top, newTop) === top) {
        return
      }
    }
  }
  
  pop() {
    while (true) {
      const top = Atomics.load(this.view, 0)
      
      if (top < 0) throw new Error('Stack empty')
      
      const value = this.view[1 + top]
      
      if (Atomics.compareExchange(this.view, 0, top, top - 1) === top) {
        return value
      }
    }
  }
}
```

### Lock-Free Queue:

```javascript
class LockFreeQueue {
  constructor(size) {
    this.buffer = new SharedArrayBuffer((size + 2) * 4)
    this.view = new Int32Array(this.buffer)
    this.size = size
    this.view[0] = 0  // head
    this.view[1] = 0  // tail
  }
  
  enqueue(value) {
    while (true) {
      const tail = Atomics.load(this.view, 1)
      const head = Atomics.load(this.view, 0)
      const next = (tail + 1) % this.size
      
      if (next === head) throw new Error('Queue full')
      
      this.view[2 + tail] = value
      
      if (Atomics.compareExchange(this.view, 1, tail, next) === tail) {
        return
      }
    }
  }
  
  dequeue() {
    while (true) {
      const head = Atomics.load(this.view, 0)
      const tail = Atomics.load(this.view, 1)
      
      if (head === tail) throw new Error('Queue empty')
      
      const value = this.view[2 + head]
      const next = (head + 1) % this.size
      
      if (Atomics.compareExchange(this.view, 0, head, next) === head) {
        return value
      }
    }
  }
}
```

---

## Immutability

Use immutable data structures to avoid races.

### Immutable State:

```javascript
// ✅ Immutable updates
function updateState(oldState, changes) {
  return Object.freeze({
    ...oldState,
    ...changes,
    timestamp: Date.now()
  })
}

// Workers can't modify, only replace
let currentState = { counter: 0 }

// Worker 1
const newState1 = updateState(currentState, { counter: 1 })

// Worker 2
const newState2 = updateState(currentState, { counter: 1 })

// No race, both create new objects
```

### Copy-On-Write:

```javascript
class COWArray {
  constructor(data = []) {
    this.data = Object.freeze([...data])
  }
  
  push(item) {
    return new COWArray([...this.data, item])
  }
  
  get(index) {
    return this.data[index]
  }
  
  get length() {
    return this.data.length
  }
}

// ✅ No races
const array1 = new COWArray([1, 2, 3])
const array2 = array1.push(4)
// array1 unchanged, array2 is new
```

---

## Message Passing

Avoid shared state by passing messages.

### Actor Model:

```javascript
// ✅ No shared state
class Actor {
  constructor(workerScript) {
    this.worker = new Worker(workerScript)
    this.callbacks = new Map()
    this.nextId = 0
    
    this.worker.onmessage = (e) => {
      const { id, result } = e.data
      const callback = this.callbacks.get(id)
      if (callback) {
        callback(result)
        this.callbacks.delete(id)
      }
    }
  }
  
  send(message) {
    return new Promise((resolve) => {
      const id = this.nextId++
      this.callbacks.set(id, resolve)
      this.worker.postMessage({ id, message })
    })
  }
}

// Usage
const actor = new Actor('actor-worker.js')
const result = await actor.send({ action: 'compute', data: 42 })
```

### Channel Pattern:

```javascript
class Channel {
  constructor() {
    this.queue = []
    this.waiting = []
  }
  
  async send(message) {
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift()
      resolve(message)
    } else {
      this.queue.push(message)
    }
  }
  
  async receive() {
    if (this.queue.length > 0) {
      return this.queue.shift()
    } else {
      return new Promise(resolve => {
        this.waiting.push(resolve)
      })
    }
  }
}

// ✅ Coordinated communication
const channel = new Channel()

// Producer
await channel.send({ data: 42 })

// Consumer
const message = await channel.receive()
```

---

## Thread-Safe Patterns

### Double-Checked Locking:

```javascript
let instance = null
const mutex = new Mutex()

function getInstance() {
  if (instance === null) {  // First check (no lock)
    mutex.acquire()
    try {
      if (instance === null) {  // Second check (with lock)
        instance = new Resource()
      }
    } finally {
      mutex.release()
    }
  }
  return instance
}
```

### Thread-Local Storage:

```javascript
// Each worker has own storage
const threadLocal = new Map()

function getThreadLocalValue(key) {
  const threadId = self.name
  if (!threadLocal.has(threadId)) {
    threadLocal.set(threadId, new Map())
  }
  return threadLocal.get(threadId).get(key)
}

function setThreadLocalValue(key, value) {
  const threadId = self.name
  if (!threadLocal.has(threadId)) {
    threadLocal.set(threadId, new Map())
  }
  threadLocal.get(threadId).set(key, value)
}
```

### Producer-Consumer with Queue:

```javascript
class SafeQueue {
  constructor() {
    this.mutex = new Mutex()
    this.notEmpty = new ConditionVariable(this.mutex)
    this.items = []
  }
  
  enqueue(item) {
    this.mutex.acquire()
    try {
      this.items.push(item)
      this.notEmpty.notify()
    } finally {
      this.mutex.release()
    }
  }
  
  dequeue() {
    this.mutex.acquire()
    try {
      while (this.items.length === 0) {
        this.notEmpty.wait()
      }
      return this.items.shift()
    } finally {
      this.mutex.release()
    }
  }
}
```

---

## Best Practices

### 1. Minimize Shared State:

```javascript
// ✅ Each worker has own data
function processChunk(data, startIndex, endIndex) {
  const localResults = []
  for (let i = startIndex; i < endIndex; i++) {
    localResults.push(process(data[i]))
  }
  return localResults
}
```

### 2. Use Appropriate Synchronization:

```javascript
// Simple counter? → Atomics
Atomics.add(counter, 0, 1)

// Complex structure? → Mutex
mutex.acquire()
updateComplexStructure()
mutex.release()

// Read-heavy? → RWLock
rwLock.readLock()
```

### 3. Keep Critical Sections Small:

```javascript
// ❌ Too much in critical section
mutex.acquire()
doExpensiveWork()
sharedData[0]++
mutex.release()

// ✅ Minimal critical section
const result = doExpensiveWork()
mutex.acquire()
sharedData[0] += result
mutex.release()
```

### 4. Always Release Locks:

```javascript
// ✅ Use try/finally
mutex.acquire()
try {
  // Critical section
} finally {
  mutex.release()  // Always executed
}
```

### 5. Test Concurrently:

```javascript
async function testConcurrency() {
  const workers = Array.from({ length: 10 }, () => new Worker('test.js'))
  
  await Promise.all(workers.map(w => 
    new Promise(resolve => {
      w.onmessage = () => resolve()
      w.postMessage({ iterations: 10000 })
    })
  ))
  
  // Verify results
}
```

---

## Summary

### Solution Strategies:

| Strategy | Pros | Cons | Use When |
|----------|------|------|----------|
| Atomics | Fast, simple | Limited operations | Simple counters/flags |
| Locks | General purpose | Can deadlock | Complex updates |
| Lock-Free | No blocking | Complex | High contention |
| Immutability | Safe | Memory overhead | Functional style |
| Message Passing | No shared state | Communication cost | Actor model |

### Key Principles:
- Minimize shared mutable state
- Use atomic operations when possible
- Protect critical sections
- Keep locks held briefly
- Test with multiple threads

### Related Topics:
- Atomic operations
- Synchronization
- Lock-free algorithms
- Functional programming
