# Understanding Race Conditions

## Table of Contents
- [What are Race Conditions?](#what-are-race-conditions)
- [How Race Conditions Occur](#how-race-conditions-occur)
- [Types of Race Conditions](#types-of-race-conditions)
- [Detecting Race Conditions](#detecting-race-conditions)
- [Common Scenarios](#common-scenarios)
- [Impact](#impact)
- [Prevention Overview](#prevention-overview)

---

## What are Race Conditions?

A **race condition** occurs when two or more threads access shared data concurrently, and at least one modifies it, leading to unpredictable results.

**Example:**
```javascript
// Shared counter
let counter = 0

// Worker 1
counter++  // Read: 0, Increment, Write: 1

// Worker 2 (simultaneously)
counter++  // Read: 0, Increment, Write: 1

// Expected: 2, Actual: 1 (RACE CONDITION!)
```

**Key Characteristics:**
- Non-deterministic behavior
- Timing-dependent
- Hard to reproduce
- Can cause data corruption
- Difficult to debug

---

## How Race Conditions Occur

### Read-Modify-Write Pattern:

```javascript
// ❌ Race condition
function increment() {
  const temp = sharedArray[0]  // 1. Read
  const newValue = temp + 1     // 2. Modify
  sharedArray[0] = newValue     // 3. Write
}

// Timeline:
// T1: Worker 1 reads 0
// T2: Worker 2 reads 0
// T3: Worker 1 writes 1
// T4: Worker 2 writes 1 (overwrites!)
// Result: 1 (should be 2)
```

### Check-Then-Act Pattern:

```javascript
// ❌ Race condition
function withdraw(amount) {
  if (balance >= amount) {      // 1. Check
    balance -= amount           // 2. Act
  }
}

// Timeline:
// T1: Worker 1 checks: balance (100) >= 80 ✓
// T2: Worker 2 checks: balance (100) >= 80 ✓
// T3: Worker 1 withdraws: balance = 20
// T4: Worker 2 withdraws: balance = -60 (OVERDRAFT!)
```

### Compound Operations:

```javascript
// ❌ Multiple race conditions
function transfer(from, to, amount) {
  accounts[from] -= amount   // Race 1
  accounts[to] += amount     // Race 2
}

// Partially completed transfers can corrupt data
```

---

## Types of Race Conditions

### 1. Data Race:

```javascript
// ❌ Data race: non-atomic access
let sharedData = 0

// Worker 1
sharedData = 10

// Worker 2
console.log(sharedData)  // Could see 0 or 10
```

### 2. Critical Section Race:

```javascript
// ❌ Unprotected critical section
function processQueue() {
  if (queue.length > 0) {     // Check
    const item = queue.pop()  // Act
    process(item)
  }
}

// Both workers might pop the same item!
```

### 3. Lost Update:

```javascript
// ❌ Lost update
// Worker 1
let temp1 = sharedArray[0]  // Read: 100
temp1 += 50                  // Modify: 150

// Worker 2 (meanwhile)
let temp2 = sharedArray[0]  // Read: 100
temp2 += 30                  // Modify: 130
sharedArray[0] = temp2       // Write: 130

// Worker 1 continues
sharedArray[0] = temp1       // Write: 150 (lost Worker 2's update!)
```

### 4. Dirty Read:

```javascript
// ❌ Reading partially updated data
// Worker 1
sharedArray[0] = 100
sharedArray[1] = 200  // Not atomic with above

// Worker 2 (reads between updates)
const a = sharedArray[0]  // 100
const b = sharedArray[1]  // 0 (old value) - INCONSISTENT!
```

---

## Detecting Race Conditions

### 1. Manual Code Review:

```javascript
// Look for patterns:
// - Unprotected shared variable access
// - Check-then-act without synchronization
// - Compound operations
// - Missing locks

// ❌ Suspicious code
if (cache.has(key)) {          // Check
  return cache.get(key)        // Act
}
const value = computeValue()
cache.set(key, value)          // Race: another thread might have set it
```

### 2. Testing:

```javascript
// Stress test with multiple workers
async function stressTest() {
  const workers = []
  const iterations = 10000
  
  for (let i = 0; i < 10; i++) {
    const worker = new Worker('worker.js')
    worker.postMessage({ iterations })
    workers.push(worker)
  }
  
  // Check if final count is correct
  await Promise.all(workers.map(w => new Promise(resolve => {
    w.onmessage = () => resolve()
  })))
  
  const expected = 10 * iterations
  const actual = sharedCounter[0]
  
  if (actual !== expected) {
    console.error(`Race condition! Expected ${expected}, got ${actual}`)
  }
}
```

### 3. Logging and Timing:

```javascript
// Add logging to detect races
function updateSharedData(value) {
  const threadId = self.name
  const timestamp = Date.now()
  
  console.log(`[${threadId}] ${timestamp}: Reading...`)
  const current = sharedArray[0]
  
  console.log(`[${threadId}] ${timestamp}: Read ${current}`)
  const newValue = current + value
  
  console.log(`[${threadId}] ${timestamp}: Writing ${newValue}`)
  sharedArray[0] = newValue
  
  console.log(`[${threadId}] ${timestamp}: Done`)
}

// Look for interleaved operations in logs
```

---

## Common Scenarios

### 1. Counter Without Synchronization:

```javascript
// ❌ Race condition
const sharedBuffer = new SharedArrayBuffer(4)
const counter = new Int32Array(sharedBuffer)

// Multiple workers
for (let i = 0; i < 1000; i++) {
  counter[0]++  // Not atomic!
}

// Result: less than expected
```

### 2. Lazy Initialization:

```javascript
// ❌ Double initialization
let instance = null

function getInstance() {
  if (instance === null) {      // Check
    instance = new Resource()   // Act
  }
  return instance
}

// Both threads might create instances!
```

### 3. HashMap Corruption:

```javascript
// ❌ Concurrent modification
const map = new Map()

// Worker 1
map.set('key1', 'value1')

// Worker 2 (simultaneously)
map.set('key2', 'value2')

// Internal structure can corrupt!
```

### 4. Event Ordering:

```javascript
// ❌ Wrong order assumptions
// Worker 1
sharedArray[0] = 42
sharedArray[1] = 1  // Ready flag

// Worker 2
while (sharedArray[1] !== 1) {
  // Wait
}
const value = sharedArray[0]  // Might not see 42! (without memory barrier)
```

### 5. Producer-Consumer:

```javascript
// ❌ Race in queue
const queue = []

// Producer
function produce(item) {
  queue.push(item)  // Not thread-safe
}

// Consumer
function consume() {
  if (queue.length > 0) {
    return queue.shift()  // Another thread might have shifted already
  }
}
```

---

## Impact

### Data Corruption:

```javascript
// Transfer with race condition
function transfer(from, to, amount) {
  accounts[from] -= amount  // Race
  accounts[to] += amount    // Race
}

// Money can be lost or created!
```

### Security Vulnerabilities:

```javascript
// ❌ TOCTOU (Time-of-check to time-of-use)
if (user.hasPermission()) {  // Check
  // Another thread might revoke permission here
  performPrivilegedAction()  // Use
}
```

### Application Crashes:

```javascript
// ❌ Corrupted state
if (resource !== null) {
  // Another thread might set to null here
  resource.doSomething()  // CRASH!
}
```

### Non-Deterministic Bugs:

```javascript
// Bug appears randomly
// Hard to reproduce
// Depends on timing
// Different results each run
```

---

## Prevention Overview

### 1. Atomic Operations:

```javascript
// ✅ Use Atomics
Atomics.add(counter, 0, 1)  // Atomic increment
```

### 2. Locks:

```javascript
// ✅ Use mutex
mutex.acquire()
try {
  // Critical section
  sharedData[0]++
} finally {
  mutex.release()
}
```

### 3. Immutability:

```javascript
// ✅ Immutable data
const newState = Object.freeze({
  ...oldState,
  counter: oldState.counter + 1
})
```

### 4. Message Passing:

```javascript
// ✅ No shared state
worker.postMessage({ command: 'increment' })
```

### 5. Thread-Safe Data Structures:

```javascript
// ✅ Use atomic queue
const queue = new AtomicQueue()
queue.enqueue(item)
```

---

## Summary

### Characteristics:
- **Timing-dependent**: Results vary with execution timing
- **Non-deterministic**: Hard to reproduce
- **Dangerous**: Can corrupt data
- **Subtle**: Often hard to detect

### Common Causes:
- Shared mutable state
- Missing synchronization
- Compound operations
- Check-then-act patterns
- Non-atomic operations

### Detection Methods:
- Code review
- Stress testing
- Logging and analysis
- Static analysis tools
- Runtime detection tools

### Next Steps:
- Learn synchronization techniques
- Use atomic operations
- Minimize shared state
- Test thoroughly

### Related Topics:
- Atomic operations
- Synchronization
- Solutions (next section)
- Thread safety
