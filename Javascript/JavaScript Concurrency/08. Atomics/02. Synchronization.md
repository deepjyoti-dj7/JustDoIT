# Synchronization

## Table of Contents
- [What is Synchronization?](#what-is-synchronization)
- [Mutex (Mutual Exclusion)](#mutex-mutual-exclusion)
- [Semaphores](#semaphores)
- [Barriers](#barriers)
- [Condition Variables](#condition-variables)
- [Read-Write Locks](#read-write-locks)
- [Deadlock Prevention](#deadlock-prevention)
- [Best Practices](#best-practices)

---

## What is Synchronization?

**Synchronization** coordinates multiple threads accessing shared resources to prevent race conditions and ensure correctness.

**Why Needed:**
- Prevent simultaneous access to shared data
- Coordinate thread execution
- Ensure data consistency
- Avoid race conditions

```javascript
// ❌ Without synchronization
worker1: sharedArray[0]++  // Read: 0, Write: 1
worker2: sharedArray[0]++  // Read: 0, Write: 1
// Result: 1 (should be 2!)

// ✅ With synchronization
worker1: lock.acquire(); sharedArray[0]++; lock.release()
worker2: lock.acquire(); sharedArray[0]++; lock.release()
// Result: 2 (correct!)
```

---

## Mutex (Mutual Exclusion)

A **mutex** ensures only one thread can access a critical section at a time.

### Simple Mutex:

```javascript
class Mutex {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.lock = new Int32Array(this.buffer)
    this.lock[0] = 0  // 0 = unlocked, 1 = locked
  }
  
  acquire() {
    while (Atomics.compareExchange(this.lock, 0, 0, 1) !== 0) {
      // Spin until lock is acquired
    }
  }
  
  release() {
    Atomics.store(this.lock, 0, 0)
  }
  
  getBuffer() {
    return this.buffer
  }
}

// Usage
const mutex = new Mutex()

// In any worker
mutex.acquire()
try {
  // Critical section
  sharedArray[0]++
} finally {
  mutex.release()
}
```

### Mutex with Wait/Notify:

```javascript
class WaitMutex {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.lock = new Int32Array(this.buffer)
  }
  
  acquire() {
    while (true) {
      if (Atomics.compareExchange(this.lock, 0, 0, 1) === 0) {
        return  // Acquired
      }
      // Wait instead of spinning
      Atomics.wait(this.lock, 0, 1)
    }
  }
  
  release() {
    Atomics.store(this.lock, 0, 0)
    Atomics.notify(this.lock, 0, 1)
  }
}
```

### Example: Bank Account:

```javascript
// Shared state
const accountBuffer = new SharedArrayBuffer(12)
const account = new Int32Array(accountBuffer)
account[0] = 1000  // Balance
account[1] = 0     // Lock

const mutex = new Mutex()

// Worker 1: Deposit
function deposit(amount) {
  mutex.acquire()
  try {
    const balance = account[0]
    account[0] = balance + amount
    console.log(`Deposited ${amount}, balance: ${account[0]}`)
  } finally {
    mutex.release()
  }
}

// Worker 2: Withdraw
function withdraw(amount) {
  mutex.acquire()
  try {
    const balance = account[0]
    if (balance >= amount) {
      account[0] = balance - amount
      console.log(`Withdrew ${amount}, balance: ${account[0]}`)
    }
  } finally {
    mutex.release()
  }
}
```

---

## Semaphores

A **semaphore** controls access to a limited number of resources.

### Counting Semaphore:

```javascript
class Semaphore {
  constructor(count) {
    this.buffer = new SharedArrayBuffer(4)
    this.count = new Int32Array(this.buffer)
    this.count[0] = count
  }
  
  acquire() {
    while (true) {
      const current = Atomics.load(this.count, 0)
      if (current > 0) {
        if (Atomics.compareExchange(this.count, 0, current, current - 1) === current) {
          return
        }
      } else {
        Atomics.wait(this.count, 0, 0)
      }
    }
  }
  
  release() {
    Atomics.add(this.count, 0, 1)
    Atomics.notify(this.count, 0, 1)
  }
  
  getBuffer() {
    return this.buffer
  }
}

// Usage: Limit concurrent workers
const semaphore = new Semaphore(3)  // Max 3 workers

function doWork() {
  semaphore.acquire()
  try {
    console.log('Working...')
    // Do work
  } finally {
    semaphore.release()
  }
}
```

### Connection Pool:

```javascript
class ConnectionPool {
  constructor(maxConnections) {
    this.semaphore = new Semaphore(maxConnections)
    this.connectionBuffer = new SharedArrayBuffer(4)
    this.connections = new Int32Array(this.connectionBuffer)
    this.connections[0] = maxConnections
  }
  
  async getConnection() {
    this.semaphore.acquire()
    const id = Atomics.sub(this.connections, 0, 1)
    return { id }
  }
  
  releaseConnection(conn) {
    Atomics.add(this.connections, 0, 1)
    this.semaphore.release()
  }
}

// Usage
const pool = new ConnectionPool(5)

const conn = await pool.getConnection()
try {
  // Use connection
  await query(conn)
} finally {
  pool.releaseConnection(conn)
}
```

---

## Barriers

A **barrier** synchronizes multiple threads at a specific point.

### Barrier Implementation:

```javascript
class Barrier {
  constructor(count) {
    this.buffer = new SharedArrayBuffer(12)
    this.view = new Int32Array(this.buffer)
    this.view[0] = count   // Total threads
    this.view[1] = 0       // Arrived count
    this.view[2] = 0       // Generation
  }
  
  wait() {
    const total = this.view[0]
    const generation = Atomics.load(this.view, 2)
    
    const arrived = Atomics.add(this.view, 1, 1) + 1
    
    if (arrived === total) {
      // Last thread arrives
      Atomics.store(this.view, 1, 0)
      Atomics.add(this.view, 2, 1)
      Atomics.notify(this.view, 2, Infinity)
    } else {
      // Wait for all threads
      while (Atomics.load(this.view, 2) === generation) {
        Atomics.wait(this.view, 2, generation)
      }
    }
  }
  
  getBuffer() {
    return this.buffer
  }
}

// Usage: Parallel algorithm with phases
const barrier = new Barrier(4)

function parallelSort(data, workerId) {
  // Phase 1: Local sort
  sortLocalData(data, workerId)
  barrier.wait()  // Wait for all workers
  
  // Phase 2: Merge
  mergePhase(data, workerId)
  barrier.wait()  // Wait for all workers
  
  // Phase 3: Final assembly
  finalPhase(data, workerId)
}
```

---

## Condition Variables

**Condition variables** allow threads to wait for specific conditions.

### Condition Variable:

```javascript
class ConditionVariable {
  constructor(mutex) {
    this.mutex = mutex
    this.buffer = new SharedArrayBuffer(4)
    this.waiters = new Int32Array(this.buffer)
  }
  
  wait() {
    Atomics.add(this.waiters, 0, 1)
    this.mutex.release()
    
    Atomics.wait(this.waiters, 0, 0)
    
    this.mutex.acquire()
  }
  
  notify() {
    if (Atomics.load(this.waiters, 0) > 0) {
      Atomics.sub(this.waiters, 0, 1)
      Atomics.notify(this.waiters, 0, 1)
    }
  }
  
  notifyAll() {
    const count = Atomics.exchange(this.waiters, 0, 0)
    if (count > 0) {
      Atomics.notify(this.waiters, 0, Infinity)
    }
  }
}

// Usage: Producer-Consumer with condition
const mutex = new Mutex()
const notEmpty = new ConditionVariable(mutex)
const notFull = new ConditionVariable(mutex)

function producer(item) {
  mutex.acquire()
  
  while (queue.isFull()) {
    notFull.wait()  // Wait for space
  }
  
  queue.enqueue(item)
  notEmpty.notify()  // Signal consumer
  
  mutex.release()
}

function consumer() {
  mutex.acquire()
  
  while (queue.isEmpty()) {
    notEmpty.wait()  // Wait for item
  }
  
  const item = queue.dequeue()
  notFull.notify()  // Signal producer
  
  mutex.release()
  return item
}
```

---

## Read-Write Locks

**Read-write locks** allow multiple readers or one writer.

### RWLock Implementation:

```javascript
class RWLock {
  constructor() {
    this.buffer = new SharedArrayBuffer(12)
    this.state = new Int32Array(this.buffer)
    this.state[0] = 0  // Readers count
    this.state[1] = 0  // Writer flag (0 or 1)
    this.state[2] = 0  // Waiting writers
  }
  
  readLock() {
    while (true) {
      // Wait if writer is active
      while (Atomics.load(this.state, 1) === 1) {
        Atomics.wait(this.state, 1, 1)
      }
      
      // Increment readers
      Atomics.add(this.state, 0, 1)
      
      // Check no writer sneaked in
      if (Atomics.load(this.state, 1) === 0) {
        return
      }
      
      // Writer active, undo and retry
      Atomics.sub(this.state, 0, 1)
    }
  }
  
  readUnlock() {
    const readers = Atomics.sub(this.state, 0, 1) - 1
    if (readers === 0 && Atomics.load(this.state, 2) > 0) {
      Atomics.notify(this.state, 1, 1)
    }
  }
  
  writeLock() {
    Atomics.add(this.state, 2, 1)
    
    while (true) {
      if (Atomics.compareExchange(this.state, 1, 0, 1) === 0) {
        // Wait for readers to finish
        while (Atomics.load(this.state, 0) > 0) {
          // Spin
        }
        Atomics.sub(this.state, 2, 1)
        return
      }
      Atomics.wait(this.state, 1, 1)
    }
  }
  
  writeUnlock() {
    Atomics.store(this.state, 1, 0)
    Atomics.notify(this.state, 1, Infinity)
  }
}

// Usage
const rwLock = new RWLock()

// Multiple readers can read simultaneously
function read() {
  rwLock.readLock()
  try {
    const data = sharedData[0]
    console.log('Read:', data)
  } finally {
    rwLock.readUnlock()
  }
}

// Only one writer at a time
function write(value) {
  rwLock.writeLock()
  try {
    sharedData[0] = value
    console.log('Wrote:', value)
  } finally {
    rwLock.writeUnlock()
  }
}
```

---

## Deadlock Prevention

**Deadlock** occurs when threads wait for each other indefinitely.

### Deadlock Example:

```javascript
// ❌ Deadlock scenario
// Worker 1
lock1.acquire()
lock2.acquire()  // Waits for Worker 2 to release lock2

// Worker 2
lock2.acquire()
lock1.acquire()  // Waits for Worker 1 to release lock1
// Both wait forever!
```

### Prevention: Lock Ordering:

```javascript
// ✅ Always acquire locks in same order
function transfer(from, to, amount) {
  const first = from < to ? from : to
  const second = from < to ? to : from
  
  locks[first].acquire()
  locks[second].acquire()
  try {
    accounts[from] -= amount
    accounts[to] += amount
  } finally {
    locks[second].release()
    locks[first].release()
  }
}
```

### Prevention: Timeout:

```javascript
class TimedMutex {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.lock = new Int32Array(this.buffer)
  }
  
  tryAcquire(timeoutMs) {
    const start = Date.now()
    
    while (Date.now() - start < timeoutMs) {
      if (Atomics.compareExchange(this.lock, 0, 0, 1) === 0) {
        return true  // Acquired
      }
      Atomics.wait(this.lock, 0, 1, 100)
    }
    
    return false  // Timeout
  }
  
  release() {
    Atomics.store(this.lock, 0, 0)
    Atomics.notify(this.lock, 0, 1)
  }
}

// Usage
if (mutex.tryAcquire(5000)) {
  try {
    // Critical section
  } finally {
    mutex.release()
  }
} else {
  console.log('Could not acquire lock')
}
```

---

## Best Practices

### 1. Always Release Locks:

```javascript
// ✅ Use try/finally
mutex.acquire()
try {
  // Critical section
} finally {
  mutex.release()  // Always executed
}
```

### 2. Keep Critical Sections Small:

```javascript
// ❌ Lock held too long
mutex.acquire()
doExpensiveWork()  // Don't do this
sharedData[0]++
mutex.release()

// ✅ Minimal critical section
doExpensiveWork()  // Do outside lock
mutex.acquire()
sharedData[0]++
mutex.release()
```

### 3. Avoid Nested Locks:

```javascript
// ❌ Prone to deadlock
lock1.acquire()
lock2.acquire()

// ✅ Single lock if possible
combinedLock.acquire()
```

### 4. Use Appropriate Primitive:

```javascript
// Simple counter → Atomics
Atomics.add(counter, 0, 1)

// Complex update → Mutex
mutex.acquire()
update ComplexStructure()
mutex.release()

// Limited resources → Semaphore
semaphore.acquire()
useResource()
semaphore.release()
```

### 5. Document Lock Invariants:

```javascript
/*
 * Lock protects:
 * - sharedData[0]: User count
 * - sharedData[1]: Total score
 * 
 * Invariant: totalScore >= userCount * minScore
 */
mutex.acquire()
try {
  sharedData[0]++
  sharedData[1] += score
} finally {
  mutex.release()
}
```

---

## Summary

### Synchronization Primitives:

| Primitive | Purpose | Example |
|-----------|---------|---------|
| Mutex | Exclusive access | Bank account |
| Semaphore | Limited resources | Connection pool |
| Barrier | Phase synchronization | Parallel sort |
| Condition Variable | Event waiting | Producer-consumer |
| RWLock | Multiple readers | Cache |

### Key Principles:
- Always release locks (use try/finally)
- Keep critical sections small
- Use lock ordering to prevent deadlock
- Choose appropriate synchronization primitive
- Document lock invariants

### Related Topics:
- Atomic operations
- Race conditions
- Deadlock detection
- Lock-free algorithms
