# Atomic Operations

## Table of Contents
- [What are Atomic Operations?](#what-are-atomic-operations)
- [Atomics Object](#atomics-object)
- [Load and Store](#load-and-store)
- [Arithmetic Operations](#arithmetic-operations)
- [Bitwise Operations](#bitwise-operations)
- [Compare and Exchange](#compare-and-exchange)
- [Wait and Notify](#wait-and-notify)
- [Use Cases](#use-cases)
- [Best Practices](#best-practices)

---

## What are Atomic Operations?

**Atomic operations** are indivisible operations that complete without interruption, ensuring thread safety when working with SharedArrayBuffer.

**Why Atomic?**
- Prevents race conditions
- Ensures operation completes fully
- No partial reads/writes
- Thread-safe without locks

**Example Problem:**
```javascript
// ❌ NOT atomic - race condition
sharedArray[0]++
// This actually does:
// 1. Read sharedArray[0]
// 2. Add 1
// 3. Write back
// Another thread can interfere between steps!

// ✅ Atomic - safe
Atomics.add(sharedArray, 0, 1)
// Happens as one indivisible operation
```

---

## Atomics Object

The `Atomics` object provides static methods for atomic operations on SharedArrayBuffer.

**Supported TypedArrays:**
- Int8Array
- Uint8Array
- Int16Array
- Uint16Array
- Int32Array
- Uint32Array
- BigInt64Array
- BigUint64Array

**NOT supported:**
- Float32Array
- Float64Array

```javascript
const sharedBuffer = new SharedArrayBuffer(16)
const sharedArray = new Int32Array(sharedBuffer)

// All Atomics operations work on sharedArray
Atomics.add(sharedArray, 0, 5)
Atomics.load(sharedArray, 0)
```

---

## Load and Store

### Atomics.load()

Atomically read a value from shared memory.

```javascript
const sharedBuffer = new SharedArrayBuffer(4)
const sharedArray = new Int32Array(sharedBuffer)

sharedArray[0] = 42

// Atomic read
const value = Atomics.load(sharedArray, 0)
console.log(value)  // 42
```

### Atomics.store()

Atomically write a value to shared memory.

```javascript
// Atomic write
Atomics.store(sharedArray, 0, 100)
console.log(sharedArray[0])  // 100

// Returns the value written
const result = Atomics.store(sharedArray, 1, 200)
console.log(result)  // 200
```

### Example: Safe Communication

```javascript
// Main thread
const sharedBuffer = new SharedArrayBuffer(8)
const sharedArray = new Int32Array(sharedBuffer)

const worker = new Worker('worker.js')
worker.postMessage({ buffer: sharedBuffer })

// Write data atomically
Atomics.store(sharedArray, 0, 42)
Atomics.store(sharedArray, 1, 1)  // Signal ready

// Worker
self.onmessage = (e) => {
  const sharedArray = new Int32Array(e.data.buffer)
  
  // Wait for signal
  while (Atomics.load(sharedArray, 1) !== 1) {
    // Spin wait
  }
  
  // Read data atomically
  const data = Atomics.load(sharedArray, 0)
  console.log('Received:', data)  // 42
}
```

---

## Arithmetic Operations

### Atomics.add()

Atomically add a value and return the old value.

```javascript
const sharedArray = new Int32Array(new SharedArrayBuffer(4))
sharedArray[0] = 10

const oldValue = Atomics.add(sharedArray, 0, 5)
console.log(oldValue)        // 10
console.log(sharedArray[0])  // 15
```

### Atomics.sub()

Atomically subtract a value and return the old value.

```javascript
sharedArray[0] = 20
const oldValue = Atomics.sub(sharedArray, 0, 7)
console.log(oldValue)        // 20
console.log(sharedArray[0])  // 13
```

### Thread-Safe Counter:

```javascript
// Main thread
const sharedBuffer = new SharedArrayBuffer(4)
const counter = new Int32Array(sharedBuffer)
counter[0] = 0

const workers = []
for (let i = 0; i < 4; i++) {
  const worker = new Worker('counter-worker.js')
  worker.postMessage({ buffer: sharedBuffer })
  workers.push(worker)
}

setTimeout(() => {
  console.log('Final count:', Atomics.load(counter, 0))
}, 1000)

// counter-worker.js
self.onmessage = (e) => {
  const counter = new Int32Array(e.data.buffer)
  
  // Each worker increments 1000 times
  for (let i = 0; i < 1000; i++) {
    Atomics.add(counter, 0, 1)
  }
  
  self.postMessage('done')
}
// Final count will be exactly 4000 (no race conditions)
```

---

## Bitwise Operations

### Atomics.and()

Atomically AND with a value.

```javascript
sharedArray[0] = 0b1111  // 15
Atomics.and(sharedArray, 0, 0b1100)  // 12
console.log(sharedArray[0])  // 0b1100 (12)
```

### Atomics.or()

Atomically OR with a value.

```javascript
sharedArray[0] = 0b1100  // 12
Atomics.or(sharedArray, 0, 0b0011)  // 3
console.log(sharedArray[0])  // 0b1111 (15)
```

### Atomics.xor()

Atomically XOR with a value.

```javascript
sharedArray[0] = 0b1100  // 12
Atomics.xor(sharedArray, 0, 0b1010)  // 10
console.log(sharedArray[0])  // 0b0110 (6)
```

### Flag Management:

```javascript
// Bit flags for worker states
const FLAGS = {
  IDLE: 0b0001,
  WORKING: 0b0010,
  PAUSED: 0b0100,
  ERROR: 0b1000
}

const sharedBuffer = new SharedArrayBuffer(4)
const flags = new Int32Array(sharedBuffer)

// Set WORKING flag
Atomics.or(flags, 0, FLAGS.WORKING)

// Clear WORKING flag
Atomics.and(flags, 0, ~FLAGS.WORKING)

// Toggle PAUSED flag
Atomics.xor(flags, 0, FLAGS.PAUSED)

// Check if flag is set
const isWorking = (Atomics.load(flags, 0) & FLAGS.WORKING) !== 0
```

---

## Compare and Exchange

### Atomics.compareExchange()

Atomically compare and exchange if match.

```javascript
const sharedArray = new Int32Array(new SharedArrayBuffer(4))
sharedArray[0] = 10

// If value at index 0 is 10, replace with 20
const oldValue = Atomics.compareExchange(sharedArray, 0, 10, 20)
console.log(oldValue)        // 10 (old value)
console.log(sharedArray[0])  // 20 (new value)

// Try again with wrong expected value
const result = Atomics.compareExchange(sharedArray, 0, 10, 30)
console.log(result)          // 20 (current value, not changed)
console.log(sharedArray[0])  // 20 (unchanged)
```

### Lock-Free Spin Lock:

```javascript
class SpinLock {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.lock = new Int32Array(this.buffer)
    this.lock[0] = 0  // 0 = unlocked, 1 = locked
  }
  
  acquire() {
    while (true) {
      // Try to change 0 to 1
      const oldValue = Atomics.compareExchange(this.lock, 0, 0, 1)
      if (oldValue === 0) {
        // Successfully acquired lock
        return
      }
      // Lock was already held, spin and retry
    }
  }
  
  release() {
    Atomics.store(this.lock, 0, 0)
  }
  
  getBuffer() {
    return this.buffer
  }
}

// Usage
const lock = new SpinLock()

lock.acquire()
try {
  // Critical section - only one thread at a time
  sharedData[0]++
} finally {
  lock.release()
}
```

### Atomics.exchange()

Atomically exchange value and return old value.

```javascript
sharedArray[0] = 42
const oldValue = Atomics.exchange(sharedArray, 0, 100)
console.log(oldValue)        // 42
console.log(sharedArray[0])  // 100
```

---

## Wait and Notify

### Atomics.wait()

Block until notified or timeout (only in Workers, not main thread).

```javascript
// Worker only
const sharedArray = new Int32Array(sharedBuffer)

// Wait for value at index 0 to change from 0
const result = Atomics.wait(sharedArray, 0, 0, 1000)
// Returns: 'ok', 'not-equal', or 'timed-out'

console.log(result)
```

### Atomics.notify()

Wake up threads waiting on a location.

```javascript
// Wake up one waiting thread
Atomics.notify(sharedArray, 0, 1)

// Wake up all waiting threads
Atomics.notify(sharedArray, 0, Infinity)
```

### Producer-Consumer Pattern:

```javascript
// Main thread (Producer)
const sharedBuffer = new SharedArrayBuffer(8)
const sharedArray = new Int32Array(sharedBuffer)
sharedArray[0] = 0  // Data
sharedArray[1] = 0  // Ready flag

const worker = new Worker('consumer.js')
worker.postMessage({ buffer: sharedBuffer })

setTimeout(() => {
  // Produce data
  Atomics.store(sharedArray, 0, 42)
  Atomics.store(sharedArray, 1, 1)
  
  // Notify consumer
  Atomics.notify(sharedArray, 1, 1)
}, 1000)

// consumer.js (Worker)
self.onmessage = (e) => {
  const sharedArray = new Int32Array(e.data.buffer)
  
  console.log('Waiting for data...')
  
  // Wait for ready flag to become 1
  const result = Atomics.wait(sharedArray, 1, 0, 5000)
  
  if (result === 'ok') {
    const data = Atomics.load(sharedArray, 0)
    console.log('Received data:', data)  // 42
  } else {
    console.log('Wait result:', result)
  }
}
```

### Blocking Queue:

```javascript
class BlockingQueue {
  constructor(size) {
    // [readIndex, writeIndex, count, ...data]
    this.buffer = new SharedArrayBuffer((size + 3) * 4)
    this.view = new Int32Array(this.buffer)
    this.size = size
    this.view[0] = 0  // readIndex
    this.view[1] = 0  // writeIndex
    this.view[2] = 0  // count
  }
  
  enqueue(value) {
    // Wait while queue is full
    while (Atomics.load(this.view, 2) === this.size) {
      Atomics.wait(this.view, 2, this.size)
    }
    
    const writeIndex = Atomics.load(this.view, 1)
    this.view[3 + writeIndex] = value
    Atomics.store(this.view, 1, (writeIndex + 1) % this.size)
    Atomics.add(this.view, 2, 1)
    
    // Notify waiting dequeuers
    Atomics.notify(this.view, 2, 1)
  }
  
  dequeue() {
    // Wait while queue is empty
    while (Atomics.load(this.view, 2) === 0) {
      Atomics.wait(this.view, 2, 0)
    }
    
    const readIndex = Atomics.load(this.view, 0)
    const value = this.view[3 + readIndex]
    Atomics.store(this.view, 0, (readIndex + 1) % this.size)
    Atomics.sub(this.view, 2, 1)
    
    // Notify waiting enqueuers
    Atomics.notify(this.view, 2, 1)
    
    return value
  }
  
  getBuffer() {
    return this.buffer
  }
}
```

---

## Use Cases

### 1. Thread-Safe Counter:

```javascript
// Shared counter across workers
const counter = new Int32Array(new SharedArrayBuffer(4))

// Worker 1
Atomics.add(counter, 0, 1)

// Worker 2
Atomics.add(counter, 0, 1)

// Main thread
console.log(Atomics.load(counter, 0))  // 2
```

### 2. Mutex Lock:

```javascript
class Mutex {
  constructor() {
    this.buffer = new SharedArrayBuffer(4)
    this.state = new Int32Array(this.buffer)
  }
  
  lock() {
    while (Atomics.compareExchange(this.state, 0, 0, 1) !== 0) {
      Atomics.wait(this.state, 0, 1)
    }
  }
  
  unlock() {
    Atomics.store(this.state, 0, 0)
    Atomics.notify(this.state, 0, 1)
  }
}
```

### 3. Barrier Synchronization:

```javascript
class Barrier {
  constructor(count) {
    this.buffer = new SharedArrayBuffer(8)
    this.view = new Int32Array(this.buffer)
    this.view[0] = count  // Total threads
    this.view[1] = 0      // Arrived count
  }
  
  wait() {
    const total = this.view[0]
    const arrived = Atomics.add(this.view, 1, 1) + 1
    
    if (arrived === total) {
      // Last thread, reset and notify all
      Atomics.store(this.view, 1, 0)
      Atomics.notify(this.view, 1, Infinity)
    } else {
      // Wait for all threads
      while (Atomics.load(this.view, 1) !== 0) {
        Atomics.wait(this.view, 1, arrived)
      }
    }
  }
}
```

---

## Best Practices

### 1. Always Use Atomics with SharedArrayBuffer:

```javascript
// ❌ Race condition
sharedArray[0]++

// ✅ Thread-safe
Atomics.add(sharedArray, 0, 1)
```

### 2. Use Appropriate TypedArray:

```javascript
// ✅ Int32Array for counters
const counter = new Int32Array(sharedBuffer)
Atomics.add(counter, 0, 1)

// ❌ Cannot use Float32Array
const floats = new Float32Array(sharedBuffer)
// Atomics.add(floats, 0, 1)  // Error!
```

### 3. Don't Call wait() on Main Thread:

```javascript
// ❌ Blocks main thread - forbidden
Atomics.wait(sharedArray, 0, 0)

// ✅ Only in Workers
// worker.js
Atomics.wait(sharedArray, 0, 0)
```

### 4. Handle Wait Timeouts:

```javascript
const result = Atomics.wait(sharedArray, 0, 0, 5000)

if (result === 'timed-out') {
  console.log('Operation timed out')
} else if (result === 'ok') {
  console.log('Notified successfully')
}
```

### 5. Use compareExchange for Complex Updates:

```javascript
function atomicMax(array, index, value) {
  while (true) {
    const current = Atomics.load(array, index)
    if (value <= current) return current
    
    const old = Atomics.compareExchange(array, index, current, value)
    if (old === current) return value
  }
}
```

---

## Summary

### Key Operations:

| Operation | Purpose |
|-----------|---------|
| `load` | Atomic read |
| `store` | Atomic write |
| `add` | Atomic addition |
| `sub` | Atomic subtraction |
| `and/or/xor` | Atomic bitwise |
| `compareExchange` | Conditional swap |
| `exchange` | Swap value |
| `wait` | Block until notified |
| `notify` | Wake waiting threads |

### When to Use:
- ✅ SharedArrayBuffer operations
- ✅ Multi-threaded counters
- ✅ Lock implementations
- ✅ Synchronization primitives
- ❌ Regular arrays
- ❌ Single-threaded code

### Related Topics:
- SharedArrayBuffer
- Web Workers
- Race conditions
- Synchronization
