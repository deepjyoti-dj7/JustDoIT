# Microtasks vs Macrotasks

## Table of Contents
- [Overview](#overview)
- [Microtasks](#microtasks)
- [Macrotasks](#macrotasks)
- [Priority and Execution Order](#priority-and-execution-order)
- [Practical Comparisons](#practical-comparisons)
- [Performance Implications](#performance-implications)
- [Common Patterns](#common-patterns)
- [Pitfalls](#pitfalls)
- [Best Practices](#best-practices)

---

## Overview

The event loop processes two types of tasks with different priorities:

| Feature | Microtasks | Macrotasks |
|---------|-----------|------------|
| **Priority** | High | Low |
| **Execution** | All in queue | One per loop |
| **Sources** | Promises, queueMicrotask | setTimeout, I/O |
| **Timing** | After call stack | After microtasks |
| **Can starve** | Macrotasks | No |

```javascript
// Quick demonstration
console.log('1: Sync')

setTimeout(() => console.log('2: Macrotask'), 0)

Promise.resolve().then(() => console.log('3: Microtask'))

console.log('4: Sync')

// Output:
// 1: Sync
// 4: Sync
// 3: Microtask  ← Executes before macrotask
// 2: Macrotask
```

---

## Microtasks

**Microtasks** are high-priority tasks that execute after the current script but before any macrotasks.

### Sources of Microtasks:

1. **Promise callbacks**
   ```javascript
   Promise.resolve().then(() => {})
   Promise.reject().catch(() => {})
   promise.finally(() => {})
   ```

2. **queueMicrotask()**
   ```javascript
   queueMicrotask(() => {
     console.log('Microtask')
   })
   ```

3. **MutationObserver** (Browser)
   ```javascript
   const observer = new MutationObserver(() => {
     console.log('DOM changed')
   })
   ```

4. **process.nextTick()** (Node.js - highest priority)
   ```javascript
   process.nextTick(() => {
     console.log('Next tick')
   })
   ```

### Characteristics:

```javascript
// All microtasks execute before next macrotask
Promise.resolve().then(() => {
  console.log('Micro 1')
  
  // Queuing more microtasks
  Promise.resolve().then(() => {
    console.log('Micro 2')
  })
})

Promise.resolve().then(() => {
  console.log('Micro 3')
})

setTimeout(() => {
  console.log('Macro 1')
}, 0)

// Output:
// Micro 1
// Micro 3
// Micro 2  ← Added during microtask execution
// Macro 1  ← Executes after ALL microtasks
```

---

## Macrotasks

**Macrotasks** (or tasks) are lower-priority operations executed one per event loop iteration.

### Sources of Macrotasks:

1. **Timers**
   ```javascript
   setTimeout(() => {}, 0)
   setInterval(() => {}, 1000)
   ```

2. **I/O Operations**
   ```javascript
   fs.readFile('file.txt', callback)
   ```

3. **UI Rendering** (Browser)
   ```javascript
   requestAnimationFrame(() => {})
   ```

4. **setImmediate()** (Node.js)
   ```javascript
   setImmediate(() => {
     console.log('Immediate')
   })
   ```

5. **User Interactions**
   ```javascript
   button.addEventListener('click', () => {})
   ```

### Characteristics:

```javascript
// Only ONE macrotask per event loop iteration
setTimeout(() => {
  console.log('Macro 1')
  
  // This goes to END of macrotask queue
  setTimeout(() => {
    console.log('Macro 2')
  }, 0)
}, 0)

setTimeout(() => {
  console.log('Macro 3')
}, 0)

// Event loop iterations:
// Iteration 1: Macro 1
// Iteration 2: Macro 3
// Iteration 3: Macro 2
```

---

## Priority and Execution Order

### Event Loop Algorithm:

```
while (eventLoop.waitForTask()) {
  // 1. Execute synchronous code (call stack)
  const task = eventLoop.processNextMacrotask()
  task.execute()
  
  // 2. Execute ALL microtasks
  while (microtaskQueue.hasTasks()) {
    const microtask = microtaskQueue.nextTask()
    microtask.execute()
  }
  
  // 3. Render (browser only)
  if (browser.needsRendering()) {
    browser.render()
  }
}
```

### Detailed Example:

```javascript
console.log('Start')

setTimeout(() => {
  console.log('Macro 1')
  
  Promise.resolve().then(() => {
    console.log('Micro in Macro 1')
  })
  
  setTimeout(() => {
    console.log('Macro 2')
  }, 0)
}, 0)

Promise.resolve()
  .then(() => {
    console.log('Micro 1')
    
    setTimeout(() => {
      console.log('Macro in Micro 1')
    }, 0)
  })
  .then(() => {
    console.log('Micro 2')
  })

console.log('End')

// Output:
// Start
// End
// Micro 1
// Micro 2
// Macro 1
// Micro in Macro 1
// Macro in Micro 1
// Macro 2
```

### Why This Order?

```
1. Sync: Start, End
2. Microtasks (all): Micro 1, Micro 2
3. Macrotask (one): Macro 1
4. Microtasks (all): Micro in Macro 1
5. Macrotask (one): Macro in Micro 1
6. Macrotask (one): Macro 2
```

---

## Practical Comparisons

### Example 1: Nested Tasks

```javascript
// Microtasks complete before macrotasks
Promise.resolve().then(() => {
  console.log('1')
  
  Promise.resolve().then(() => {
    console.log('2')
    
    Promise.resolve().then(() => {
      console.log('3')
    })
  })
})

setTimeout(() => {
  console.log('4')
}, 0)

// Output: 1, 2, 3, 4
// All promises before setTimeout
```

### Example 2: Alternating Tasks

```javascript
function test() {
  console.log('Test start')
  
  setTimeout(() => console.log('Timeout 1'), 0)
  
  Promise.resolve()
    .then(() => console.log('Promise 1'))
    .then(() => console.log('Promise 2'))
  
  setTimeout(() => console.log('Timeout 2'), 0)
  
  Promise.resolve().then(() => console.log('Promise 3'))
  
  console.log('Test end')
}

test()

// Output:
// Test start
// Test end
// Promise 1
// Promise 3
// Promise 2
// Timeout 1
// Timeout 2
```

### Example 3: Mixed with Synchronous Code

```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(`Timeout ${i}`), 0)
  
  Promise.resolve().then(() => console.log(`Promise ${i}`))
}

console.log('Loop done')

// Output:
// Loop done
// Promise 0
// Promise 1
// Promise 2
// Timeout 0
// Timeout 1
// Timeout 2
```

---

## Performance Implications

### Microtask Starvation

```javascript
// ❌ Infinite microtasks starve macrotasks
let count = 0

function recursiveMicrotask() {
  if (count++ < 1000) {
    Promise.resolve().then(recursiveMicrotask)
  }
}

// This setTimeout never executes while microtasks run
setTimeout(() => {
  console.log('Finally!')
}, 0)

recursiveMicrotask()
```

### Breaking Long Microtasks

```javascript
// ✅ Use macrotasks to allow breaks
async function processWithBreaks(items) {
  for (let i = 0; i < items.length; i++) {
    await processItem(items[i])
    
    // Every 100 items, yield to event loop
    if (i % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0))
    }
  }
}
```

### Rendering Performance

```javascript
// ❌ Blocks rendering
for (let i = 0; i < 1000; i++) {
  await Promise.resolve()  // Microtasks
  updateDOM()  // DOM won't render until all done
}

// ✅ Allows rendering between updates
for (let i = 0; i < 1000; i++) {
  await new Promise(r => setTimeout(r, 0))  // Macrotask
  updateDOM()  // Renders after each update
}
```

---

## Common Patterns

### Pattern 1: Immediate Execution

```javascript
// Execute after current stack (microtask)
Promise.resolve().then(() => {
  console.log('Next microtask')
})

// Or explicitly
queueMicrotask(() => {
  console.log('Queued microtask')
})

// Execute in next event loop iteration (macrotask)
setTimeout(() => {
  console.log('Next macrotask')
}, 0)
```

### Pattern 2: Batching Updates

```javascript
class StateManager {
  constructor() {
    this.pendingUpdates = []
    this.updateScheduled = false
  }
  
  update(value) {
    this.pendingUpdates.push(value)
    
    if (!this.updateScheduled) {
      this.updateScheduled = true
      
      // Batch with microtask
      queueMicrotask(() => {
        this.flush()
      })
    }
  }
  
  flush() {
    const updates = this.pendingUpdates
    this.pendingUpdates = []
    this.updateScheduled = false
    
    // Process all batched updates
    updates.forEach(update => {
      // Apply update
    })
  }
}
```

### Pattern 3: Priority Queue

```javascript
class PriorityScheduler {
  scheduleHigh(task) {
    // High priority - microtask
    queueMicrotask(task)
  }
  
  scheduleLow(task) {
    // Low priority - macrotask
    setTimeout(task, 0)
  }
  
  scheduleIdle(task) {
    // Idle time - requestIdleCallback
    if (typeof requestIdleCallback !== 'undefined') {
      requestIdleCallback(task)
    } else {
      setTimeout(task, 0)
    }
  }
}
```

---

## Pitfalls

### Pitfall 1: Assuming setTimeout(0) is Immediate

```javascript
console.log('1')

setTimeout(() => {
  console.log('2')
}, 0)

Promise.resolve().then(() => {
  console.log('3')
})

// Output: 1, 3, 2
// setTimeout(0) is NOT immediate!
```

### Pitfall 2: Infinite Microtask Loop

```javascript
// ❌ Never completes
function bad() {
  Promise.resolve().then(bad)
}

bad()  // Hangs browser

// ✅ Use macrotask for recursive scheduling
function good() {
  setTimeout(good, 0)
}
```

### Pitfall 3: Order Confusion

```javascript
async function test() {
  console.log('1')
  
  await Promise.resolve()
  console.log('2')  // When does this run?
  
  setTimeout(() => console.log('3'), 0)
}

test()
console.log('4')

// Output: 1, 4, 2, 3
// await creates microtask, setTimeout creates macrotask
```

---

## Best Practices

### 1. Choose the Right Queue

```javascript
// High priority, must run soon
Promise.resolve().then(() => {
  // Critical update
})

// Lower priority, can wait
setTimeout(() => {
  // Non-critical work
}, 0)

// Very low priority, when idle
requestIdleCallback(() => {
  // Analytics, cleanup
})
```

### 2. Avoid Starving Macrotasks

```javascript
// ❌ Can block UI
async function processAll(items) {
  for (const item of items) {
    await Promise.resolve()
    process(item)
  }
}

// ✅ Periodically yield
async function processAllSafely(items) {
  for (let i = 0; i < items.length; i++) {
    process(items[i])
    
    if (i % 50 === 0) {
      await new Promise(r => setTimeout(r, 0))
    }
  }
}
```

### 3. Understand Timing Guarantees

```javascript
// Microtasks: Before next render
queueMicrotask(() => {
  // Runs before browser paints
})

// Macrotasks: May allow render between
setTimeout(() => {
  // May render before this
}, 0)

// Animation frame: Before next paint
requestAnimationFrame(() => {
  // Runs just before paint
})
```

### 4. Be Careful with Promises in Loops

```javascript
// ❌ All microtasks before any macrotasks
for (let i = 0; i < 10; i++) {
  Promise.resolve().then(() => console.log(i))
  setTimeout(() => console.log(i), 0)
}
// Prints all promises (0-9), then all timeouts (0-9)

// Different from:
for (let i = 0; i < 10; i++) {
  (function(i) {
    Promise.resolve().then(() => console.log(`P${i}`))
    setTimeout(() => console.log(`T${i}`), 0)
  })(i)
}
```

---

## Summary

### Key Differences:

| Aspect | Microtasks | Macrotasks |
|--------|-----------|------------|
| **When** | After current task | Next event loop |
| **How many** | All in queue | One per loop |
| **Priority** | Higher | Lower |
| **Examples** | Promises | setTimeout |
| **Can starve** | Macrotasks | Nothing |

### Decision Guide:

**Use Microtasks when:**
- Need to run before next paint
- Critical updates required ASAP
- Batching synchronous updates

**Use Macrotasks when:**
- Can wait for next event loop
- Want to allow rendering/UI updates
- Scheduling periodic work
- Processing large datasets

### Related Topics:
- Event Loop
- Promises
- Async/Await
- Performance optimization
