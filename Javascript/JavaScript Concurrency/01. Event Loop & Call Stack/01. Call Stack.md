# Call Stack

## Table of Contents
- [What is the Call Stack?](#what-is-the-call-stack)
- [How the Call Stack Works](#how-the-call-stack-works)
- [Stack Frames](#stack-frames)
- [Execution Context](#execution-context)
- [Stack Overflow](#stack-overflow)
- [Call Stack Visualization](#call-stack-visualization)
- [Practical Examples](#practical-examples)
- [Debugging with Call Stack](#debugging-with-call-stack)
- [Best Practices](#best-practices)

---

## What is the Call Stack?

The **call stack** is a data structure that JavaScript uses to keep track of function calls. It follows the **LIFO (Last In, First Out)** principle.

### Key Characteristics:
- **Single-threaded**: JavaScript has only one call stack
- **Synchronous execution**: Functions execute one at a time
- **LIFO order**: Last function called is the first to complete
- **Limited size**: Stack overflow occurs when limit is exceeded

```javascript
// Simple call stack example
function first() {
  console.log('First function')
  second()
  console.log('First function end')
}

function second() {
  console.log('Second function')
  third()
  console.log('Second function end')
}

function third() {
  console.log('Third function')
}

first()

// Call stack progression:
// 1. [first]
// 2. [first, second]
// 3. [first, second, third]
// 4. [first, second]        <- third completes
// 5. [first]                <- second completes
// 6. []                     <- first completes
```

---

## How the Call Stack Works

### Step-by-Step Execution

```javascript
function multiply(a, b) {
  return a * b
}

function square(n) {
  return multiply(n, n)
}

function printSquare(n) {
  const result = square(n)
  console.log(result)
}

printSquare(5)
```

**Call Stack Progression:**

```
1. Global Execution Context
   └─ [global]

2. printSquare(5) is called
   └─ [global, printSquare]

3. square(5) is called inside printSquare
   └─ [global, printSquare, square]

4. multiply(5, 5) is called inside square
   └─ [global, printSquare, square, multiply]

5. multiply returns 25
   └─ [global, printSquare, square]

6. square returns 25
   └─ [global, printSquare]

7. console.log(25) executes
   └─ [global, printSquare, console.log]

8. printSquare completes
   └─ [global]

9. Script completes
   └─ []
```

---

## Stack Frames

Each function call creates a **stack frame** (activation record) containing:

1. **Function arguments**: Values passed to the function
2. **Local variables**: Variables declared in the function
3. **Return address**: Where to return after execution
4. **this binding**: Value of `this` in the function

```javascript
function calculate(x, y) {
  // Stack frame contains:
  // - Arguments: x=10, y=5
  // - Local variables: result, message
  // - Return address
  // - this binding
  
  const result = x + y
  const message = `Result is ${result}`
  
  return result
}

calculate(10, 5)
```

### Visualizing Stack Frames

```javascript
function outer(a) {
  const outerVar = 'outer'
  
  function inner(b) {
    const innerVar = 'inner'
    console.log(a, b, outerVar, innerVar)
  }
  
  inner(2)
}

outer(1)

// Stack Frame for outer(1):
// ┌─────────────────────┐
// │ a: 1                │
// │ outerVar: 'outer'   │
// │ inner: <function>   │
// └─────────────────────┘

// Stack Frame for inner(2):
// ┌─────────────────────┐
// │ b: 2                │
// │ innerVar: 'inner'   │
// │ [[Scope]]: outer    │ <- Closure
// └─────────────────────┘
```

---

## Execution Context

Every function call creates an **execution context** with two phases:

### 1. Creation Phase
- Create scope chain
- Create variable object (arguments, variables, functions)
- Determine `this` value

### 2. Execution Phase
- Assign values to variables
- Execute code line by line

```javascript
var globalVar = 'global'

function outer() {
  var outerVar = 'outer'
  
  function inner() {
    var innerVar = 'inner'
    console.log(globalVar, outerVar, innerVar)
  }
  
  inner()
}

outer()

// Execution contexts:
// ┌─────────────────────────┐
// │ Global Context          │
// │ - globalVar: 'global'   │
// │ - outer: <function>     │
// └─────────────────────────┘
//           ↑
// ┌─────────────────────────┐
// │ outer() Context         │
// │ - outerVar: 'outer'     │
// │ - inner: <function>     │
// │ [[Scope]]: Global       │
// └─────────────────────────┘
//           ↑
// ┌─────────────────────────┐
// │ inner() Context         │
// │ - innerVar: 'inner'     │
// │ [[Scope]]: outer, Global│
// └─────────────────────────┘
```

---

## Stack Overflow

Stack overflow occurs when the call stack exceeds its limit from:
- Infinite recursion
- Too deep recursion
- Excessively large stack frames

### Common Causes

```javascript
// 1. Infinite recursion - ❌
function infiniteRecursion() {
  infiniteRecursion()  // No base case!
}

// infiniteRecursion()  // RangeError: Maximum call stack size exceeded

// 2. Missing base case - ❌
function factorial(n) {
  return n * factorial(n - 1)  // Forgot base case!
}

// factorial(5)  // Stack overflow

// 3. Correct recursion - ✅
function factorialCorrect(n) {
  if (n <= 1) return 1  // Base case
  return n * factorialCorrect(n - 1)
}

console.log(factorialCorrect(5))  // 120
```

### Stack Size Limits

Different JavaScript environments have different limits:
- **Chrome/V8**: ~15,000-20,000 frames
- **Firefox/SpiderMonkey**: ~50,000-100,000 frames
- **Node.js**: ~10,000-15,000 frames

```javascript
let depth = 0

function measureStackDepth() {
  try {
    depth++
    measureStackDepth()
  } catch (e) {
    console.log(`Maximum stack depth: ${depth}`)
  }
}

// measureStackDepth()
```

---

## Call Stack Visualization

### Example 1: Simple Function Chain

```javascript
function a() {
  console.log('a start')
  b()
  console.log('a end')
}

function b() {
  console.log('b start')
  c()
  console.log('b end')
}

function c() {
  console.log('c')
}

a()

// Output:
// a start
// b start
// c
// b end
// a end

// Call stack timeline:
// [global]
// [global, a]
// [global, a, b]
// [global, a, b, c]    <- c logs 'c'
// [global, a, b]       <- c returns
// [global, a]          <- b returns
// [global]             <- a returns
```

### Example 2: Recursion

```javascript
function countdown(n) {
  console.log(n)
  
  if (n > 0) {
    countdown(n - 1)
  }
}

countdown(3)

// Output: 3, 2, 1, 0

// Call stack during recursion:
// [global, countdown(3)]
// [global, countdown(3), countdown(2)]
// [global, countdown(3), countdown(2), countdown(1)]
// [global, countdown(3), countdown(2), countdown(1), countdown(0)]
// [global, countdown(3), countdown(2), countdown(1)]
// [global, countdown(3), countdown(2)]
// [global, countdown(3)]
// [global]
```

---

## Practical Examples

### Example 1: Fibonacci (Recursive vs Iterative)

```javascript
// Recursive - uses call stack
function fibRecursive(n) {
  if (n <= 1) return n
  return fibRecursive(n - 1) + fibRecursive(n - 2)
}

console.log(fibRecursive(10))  // 55
// Stack depth: O(n)
// Time: O(2^n) - very slow

// Iterative - doesn't use call stack
function fibIterative(n) {
  if (n <= 1) return n
  
  let prev = 0, curr = 1
  for (let i = 2; i <= n; i++) {
    [prev, curr] = [curr, prev + curr]
  }
  return curr
}

console.log(fibIterative(10))  // 55
// Stack depth: O(1)
// Time: O(n) - much faster
```

### Example 2: Tail Call Optimization

```javascript
// Not tail-recursive - ❌
function factorialNotTail(n) {
  if (n <= 1) return 1
  return n * factorialNotTail(n - 1)  // Multiplication after return
}

// Tail-recursive - ✅
function factorialTail(n, accumulator = 1) {
  if (n <= 1) return accumulator
  return factorialTail(n - 1, n * accumulator)  // Last operation is call
}

console.log(factorialTail(5))  // 120

// Note: TCO is part of ES6 but not widely implemented
// Only Safari/JavaScriptCore supports it properly
```

---

## Debugging with Call Stack

### Using Browser DevTools

```javascript
function buggyFunction() {
  const data = getData()
  processData(data)
}

function getData() {
  return {value: null}
}

function processData(data) {
  console.log(data.value.toUpperCase())  // Error here!
}

buggyFunction()

// Error stack trace shows:
// TypeError: Cannot read property 'toUpperCase' of null
//     at processData (script.js:10)
//     at buggyFunction (script.js:3)
//     at <anonymous> (script.js:13)
```

### console.trace()

```javascript
function deepFunction() {
  console.trace('Trace point')
}

function middleFunction() {
  deepFunction()
}

function topFunction() {
  middleFunction()
}

topFunction()

// Output shows full call stack:
// Trace point
//     at deepFunction (...)
//     at middleFunction (...)
//     at topFunction (...)
//     at <anonymous> (...)
```

### Stack Trace in Errors

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message)
    this.name = 'CustomError'
    
    // Capture stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError)
    }
  }
}

function throwError() {
  throw new CustomError('Something went wrong!')
}

function caller() {
  throwError()
}

try {
  caller()
} catch (error) {
  console.log(error.stack)
  // CustomError: Something went wrong!
  //     at throwError (...)
  //     at caller (...)
}
```

---

## Best Practices

### 1. Avoid Deep Recursion

```javascript
// ❌ Deep recursion for large inputs
function sumRecursive(arr, index = 0) {
  if (index >= arr.length) return 0
  return arr[index] + sumRecursive(arr, index + 1)
}

// ✅ Use iteration instead
function sumIterative(arr) {
  return arr.reduce((sum, num) => sum + num, 0)
}

const large = Array(10000).fill(1)
console.log(sumIterative(large))  // 10000
```

### 2. Handle Stack Overflow Gracefully

```javascript
function safeRecursion(n) {
  try {
    return riskyRecursiveFunction(n)
  } catch (error) {
    if (error instanceof RangeError) {
      console.error('Stack overflow, using iterative approach')
      return iterativeAlternative(n)
    }
    throw error
  }
}
```

### 3. Use Iterative for Large Datasets

```javascript
// Recursive tree traversal - ❌ (deep trees)
function traverseRecursive(node, callback) {
  if (!node) return
  callback(node)
  node.children?.forEach(child => traverseRecursive(child, callback))
}

// Iterative tree traversal - ✅
function traverseIterative(root, callback) {
  const stack = [root]
  
  while (stack.length > 0) {
    const node = stack.pop()
    if (!node) continue
    
    callback(node)
    
    if (node.children) {
      stack.push(...node.children.reverse())
    }
  }
}
```

### 4. Monitor Recursion Depth

```javascript
function recursiveWithLimit(n, limit = 1000, depth = 0) {
  if (depth > limit) {
    throw new Error(`Recursion limit exceeded: ${limit}`)
  }
  
  if (n <= 0) return 0
  return n + recursiveWithLimit(n - 1, limit, depth + 1)
}
```

---

## Summary

### Key Points:
- Call stack tracks function execution in LIFO order
- Each function creates a stack frame with local context
- Stack overflow occurs with excessive recursion
- Execution context manages scope and variable access
- JavaScript is single-threaded with one call stack

### When to Avoid Recursion:
- Large input sizes (> 1000 items)
- Deep nesting levels
- Performance-critical code
- Limited stack environments

### Related Topics:
- Event Loop (asynchronous execution)
- Closures (scope chain)
- Memory management
- Tail call optimization
