# Event Loop

## Table of Contents
- [What is the Event Loop?](#what-is-the-event-loop)
- [Event Loop Architecture](#event-loop-architecture)
- [How Event Loop Works](#how-the-event-loop-works)
- [Task Queue (Macrotask Queue)](#task-queue-macrotask-queue)
- [Microtask Queue](#microtask-queue)
- [Execution Order](#execution-order)
- [Browser vs Node.js](#browser-vs-nodejs)
- [Practical Examples](#practical-examples)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)

---

## What is the Event Loop?

The **event loop** is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded. It coordinates execution between the **call stack**, **task queues**, and **Web APIs**.

### Key Concepts:
- **Single-threaded**: One call stack, one thing at a time
- **Non-blocking**: Async operations don't block execution
- **Event-driven**: Responds to events/callbacks
- **Continuous loop**: Constantly checks for work to do

```javascript
console.log('Start')

setTimeout(() => {
  console.log('Timeout')
}, 0)

Promise.resolve().then(() => {
  console.log('Promise')
})

console.log('End')

// Output:
// Start
// End
// Promise
// Timeout

// Why? Event loop priority: microtasks > macrotasks
```

---

## Event Loop Architecture

```
┌─────────────────────────┐
│     Call Stack          │
│  (Synchronous code)     │
└───────────┬─────────────┘
            │
            ↓
┌───────────────────────────────────────┐
│          Web APIs                     │
│  - setTimeout/setInterval             │
│  - fetch/XMLHttpRequest               │
│  - DOM events                         │
│  - Promise executors                  │
└───────────┬──────────────────────────┘
            │
    ┌───────┴────────┐
    ↓                ↓
┌─────────┐    ┌──────────────┐
│Microtask│    │   Macrotask  │
│  Queue  │    │    Queue     │
│         │    │              │
│-Promise │    │-setTimeout   │
│-queueMic│    │-setInterval  │
│-MutObser│    │-setImmediate │
│         │    │-I/O          │
└────┬────┘    └──────┬───────┘
     │                │
     └────────┬───────┘
              ↓
     ┌────────────────┐
     │   Event Loop   │
     │                │
     │  While(true) { │
     │   checkQueue() │
     │   execute()    │
     │  }             │
     └────────────────┘
```

---

## How the Event Loop Works

### The Loop Algorithm:

```
1. Execute all synchronous code (call stack)
2. Check if call stack is empty
3. If empty:
   a. Execute ALL microtasks (Promise.then, queueMicrotask)
   b. Render (if browser - repaint/reflow)
   c. Execute ONE macrotask (setTimeout, setInterval)
4. Repeat from step 2
```

### Simple Example:

```javascript
console.log('1: Start')

setTimeout(() => {
  console.log('2: Timeout 1')
}, 0)

Promise.resolve()
  .then(() => console.log('3: Promise 1'))
  .then(() => console.log('4: Promise 2'))

setTimeout(() => {
  console.log('5: Timeout 2')
}, 0)

console.log('6: End')

// Output order:
// 1: Start          (sync)
// 6: End            (sync)
// 3: Promise 1      (microtask)
// 4: Promise 2      (microtask)
// 2: Timeout 1      (macrotask)
// 5: Timeout 2      (macrotask)
```

### Detailed Execution Flow:

```javascript
function demo() {
  console.log('A')
  
  setTimeout(() => console.log('B'), 0)
  
  Promise.resolve().then(() => {
    console.log('C')
    setTimeout(() => console.log('D'), 0)
  })
  
  setTimeout(() => console.log('E'), 0)
  
  console.log('F')
}

demo()

// Step-by-step:
// 1. Call Stack: [demo]
//    Output: A

// 2. setTimeout B registered → Macrotask Queue: [B]

// 3. Promise registered → Microtask Queue: [C]

// 4. setTimeout E registered → Macrotask Queue: [B, E]

// 5. Call Stack: [demo]
//    Output: F

// 6. Call stack empty → Process microtasks
//    Output: C
//    setTimeout D registered → Macrotask Queue: [B, E, D]

// 7. Process ONE macrotask
//    Output: B

// 8. Check microtasks (empty)

// 9. Process next macrotask
//    Output: E

// 10. Process next macrotask
//     Output: D

// Final Output: A F C B E D
```

---

## Task Queue (Macrotask Queue)

**Macrotasks** are scheduled by Web APIs and executed one at a time per event loop iteration.

### Sources of Macrotasks:
- `setTimeout()`
- `setInterval()`
- `setImmediate()` (Node.js)
- I/O operations
- UI rendering
- `requestAnimationFrame()` (browser)

```javascript
setTimeout(() => {
  console.log('Macrotask 1')
}, 0)

setTimeout(() => {
  console.log('Macrotask 2')
}, 0)

setTimeout(() => {
  console.log('Macrotask 3')
}, 0)

// Event loop executes ONE macrotask per iteration:
// Iteration 1: Macrotask 1
// Iteration 2: Macrotask 2
// Iteration 3: Macrotask 3
```

---

## Microtask Queue

**Microtasks** have higher priority and are executed until the queue is empty.

### Sources of Microtasks:
- `Promise.then()`, `Promise.catch()`, `Promise.finally()`
- `queueMicrotask()`
- `MutationObserver` (browser)
- `process.nextTick()` (Node.js - highest priority)

```javascript
Promise.resolve().then(() => {
  console.log('Microtask 1')
})

Promise.resolve().then(() => {
  console.log('Microtask 2')
  
  Promise.resolve().then(() => {
    console.log('Microtask 3')
  })
})

Promise.resolve().then(() => {
  console.log('Microtask 4')
})

// ALL microtasks execute in same event loop iteration:
// Microtask 1
// Microtask 2
// Microtask 4
// Microtask 3 (queued during Microtask 2)
```

---

## Execution Order

### Priority Levels:
1. **Synchronous code** (call stack)
2. **Microtasks** (all in queue)
3. **Rendering** (browser only)
4. **Macrotasks** (one per iteration)

### Complex Example:

```javascript
console.log('Script start')

setTimeout(() => {
  console.log('setTimeout 1')
  Promise.resolve().then(() => {
    console.log('Promise in setTimeout 1')
  })
}, 0)

Promise.resolve()
  .then(() => {
    console.log('Promise 1')
    setTimeout(() => {
      console.log('setTimeout in Promise 1')
    }, 0)
  })
  .then(() => {
    console.log('Promise 2')
  })

setTimeout(() => {
  console.log('setTimeout 2')
}, 0)

console.log('Script end')

// Output:
// Script start
// Script end
// Promise 1
// Promise 2
// setTimeout 1
// Promise in setTimeout 1
// setTimeout 2
// setTimeout in Promise 1
```

### Why This Order?

```
1. Sync: "Script start"
2. Sync: "Script end"
3. Microtasks (all):
   - "Promise 1"
   - "Promise 2"
4. Macrotask (one): "setTimeout 1"
5. Microtasks (all): "Promise in setTimeout 1"
6. Macrotask (one): "setTimeout 2"
7. Macrotask (one): "setTimeout in Promise 1"
```

---

## Browser vs Node.js

### Browser Event Loop

```javascript
// Browser has rendering steps
console.log('Start')

setTimeout(() => console.log('Timeout'), 0)

requestAnimationFrame(() => {
  console.log('Animation frame')
})

Promise.resolve().then(() => console.log('Promise'))

console.log('End')

// Browser output:
// Start
// End
// Promise
// Animation frame (before next macrotask)
// Timeout
```

### Node.js Event Loop

Node.js has **multiple phases**:

```
   ┌───────────────────────┐
┌─>│        timers         │  setTimeout, setInterval
│  └───────────┬───────────┘
│  ┌───────────┴───────────┐
│  │   pending callbacks   │  I/O callbacks
│  └───────────┬───────────┘
│  ┌───────────┴───────────┐
│  │    idle, prepare      │  Internal use
│  └───────────┬───────────┘
│  ┌───────────┴───────────┐
│  │        poll           │  Retrieve new I/O events
│  └───────────┬───────────┘
│  ┌───────────┴───────────┐
│  │        check          │  setImmediate
│  └───────────┬───────────┘
│  ┌───────────┴───────────┐
│  │   close callbacks     │  socket.on('close', ...)
│  └───────────────────────┘
└───────────────────────────┘
```

```javascript
// Node.js specific
setImmediate(() => console.log('setImmediate'))
setTimeout(() => console.log('setTimeout'), 0)
process.nextTick(() => console.log('nextTick'))
Promise.resolve().then(() => console.log('Promise'))

// Output:
// nextTick (highest priority)
// Promise
// setTimeout
// setImmediate
```

---

## Practical Examples

### Example 1: Event Loop Visualization

```javascript
function blockFor(ms) {
  const now = Date.now()
  while (Date.now() < now + ms) {}
}

console.log('Start')

setTimeout(() => {
  console.log('Timeout 1')
}, 100)

setTimeout(() => {
  console.log('Timeout 2')
  blockFor(200)  // Blocks for 200ms
  console.log('Timeout 2 end')
}, 100)

setTimeout(() => {
  console.log('Timeout 3')
}, 100)

// All setTimeout callbacks go to queue at ~100ms
// But they execute sequentially, not in parallel
// Timeout 2 blocks event loop for 200ms
// Total time: ~300ms, not 100ms
```

### Example 2: Microtask Starving Macrotasks

```javascript
let count = 0

function recursiveMicrotask() {
  count++
  console.log(`Microtask ${count}`)
  
  if (count < 5) {
    Promise.resolve().then(recursiveMicrotask)
  }
}

setTimeout(() => {
  console.log('This will execute after all microtasks')
}, 0)

Promise.resolve().then(recursiveMicrotask)

// Output:
// Microtask 1
// Microtask 2
// Microtask 3
// Microtask 4
// Microtask 5
// This will execute after all microtasks

// Event loop waits for ALL microtasks before macrotask
```

---

## Common Patterns

### Pattern 1: Defer to Next Tick

```javascript
// Execute after current synchronous code
Promise.resolve().then(() => {
  console.log('Deferred execution')
})

// Or explicitly
queueMicrotask(() => {
  console.log('Deferred via queueMicrotask')
})

console.log('Synchronous')

// Output:
// Synchronous
// Deferred execution
// Deferred via queueMicrotask
```

### Pattern 2: Break Long Tasks

```javascript
function processLargeArray(arr) {
  const chunkSize = 100
  let index = 0
  
  function processChunk() {
    const chunk = arr.slice(index, index + chunkSize)
    
    // Process chunk
    chunk.forEach(item => {
      // Do work
    })
    
    index += chunkSize
    
    if (index < arr.length) {
      // Schedule next chunk (avoid blocking)
      setTimeout(processChunk, 0)
    }
  }
  
  processChunk()
}

// Allows UI to remain responsive
```

### Pattern 3: Debounce with Event Loop

```javascript
function debounce(fn, delay) {
  let timeoutId
  
  return function(...args) {
    clearTimeout(timeoutId)
    
    timeoutId = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

const debouncedSearch = debounce((query) => {
  console.log('Searching for:', query)
}, 300)

// Only last call within 300ms executes
debouncedSearch('a')
debouncedSearch('ab')
debouncedSearch('abc')
// Output (after 300ms): Searching for: abc
```

---

## Best Practices

### 1. Don't Block the Event Loop

```javascript
// ❌ Blocks event loop
function processHuge(arr) {
  return arr.map(item => expensiveOperation(item))
}

// ✅ Process in chunks
async function processHugeAsync(arr) {
  const results = []
  const chunkSize = 1000
  
  for (let i = 0; i < arr.length; i += chunkSize) {
    const chunk = arr.slice(i, i + chunkSize)
    results.push(...chunk.map(item => expensiveOperation(item)))
    
    // Yield to event loop
    await new Promise(resolve => setTimeout(resolve, 0))
  }
  
  return results
}
```

### 2. Understand Timing Guarantees

```javascript
// ❌ setTimeout(fn, 0) doesn't mean "immediate"
setTimeout(() => {
  console.log('Not immediate')
}, 0)

// It means "after current macrotask and all microtasks"
```

### 3. Use Microtasks for High Priority

```javascript
// High priority work
Promise.resolve().then(() => {
  // Executes before any setTimeout
})

// Lower priority work
setTimeout(() => {
  // Executes after microtasks
}, 0)
```

### 4. Avoid Microtask Loops

```javascript
// ❌ Can starve macrotasks
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks)
}

// ✅ Use setTimeout for long-running tasks
function processWithBreaks() {
  // Do work
  setTimeout(processWithBreaks, 0)  // Allows other tasks
}
```

---

## Summary

### Key Takeaways:
- Event loop coordinates sync code, microtasks, and macrotasks
- Microtasks have priority over macrotasks
- Browser and Node.js have different event loop implementations
- One macrotask per iteration, all microtasks per iteration
- Don't block the event loop with long synchronous operations

### Execution Order:
1. Synchronous code (call stack)
2. All microtasks
3. Rendering (browser)
4. One macrotask

### Related Topics:
- Promises
- Async/Await
- Web Workers (separate event loop)
- Performance optimization
