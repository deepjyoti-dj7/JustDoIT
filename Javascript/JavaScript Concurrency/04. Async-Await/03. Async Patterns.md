# Async Patterns

## Table of Contents
- [Sequential Execution](#sequential-execution)
- [Parallel Execution](#parallel-execution)
- [Error Handling Patterns](#error-handling-patterns)
- [Retry Pattern](#retry-pattern)
- [Timeout Pattern](#timeout-pattern)
- [Caching Pattern](#caching-pattern)
- [Real-World Examples](#real-world-examples)

---

## Sequential Execution

Execute operations one after another.

```javascript
// Basic Sequential
async function processInOrder() {
  const result1 = await operation1()
  const result2 = await operation2(result1)
  const result3 = await operation3(result2)
  return result3
}

// With Dependencies
async function loadUserData(userId) {
  const user = await fetchUser(userId)
  const posts = await fetchPosts(user.id)
  const comments = await fetchComments(posts.map(p => p.id))
  
  return { user, posts, comments }
}

// Sequential Loop
async function processItems(items) {
  const results = []
  for (const item of items) {
    results.push(await processItem(item))
  }
  return results
}
```

---

## Parallel Execution

Execute multiple operations simultaneously.

```javascript
// Promise.all
async function fetchAllData() {
  const [users, posts, comments] = await Promise.all([
    fetchUsers(),
    fetchPosts(),
    fetchComments()
  ])
  
  return { users, posts, comments }
}

// Parallel Array Processing
async function processAllItems(items) {
  return await Promise.all(items.map(item => processItem(item)))
}

// Mixed Sequential and Parallel
async function loadDashboard(userId) {
  const user = await fetchUser(userId)  // Sequential
  
  // Parallel
  const [posts, friends, notifications] = await Promise.all([
    fetchPosts(user.id),
    fetchFriends(user.id),
    fetchNotifications(user.id)
  ])
  
  return { user, posts, friends, notifications }
}

// Batched Parallel Execution
async function processBatches(items, batchSize) {
  const results = []
  
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    const batchResults = await Promise.all(
      batch.map(item => processItem(item))
    )
    results.push(...batchResults)
  }
  
  return results
}

// Usage: Process 10 items at a time
await processBatches(items, 10)
```

---

## Error Handling Patterns

### Try/Catch per Operation:

```javascript
async function fetchWithErrorHandling() {
  let user, posts
  
  try {
    user = await fetchUser()
  } catch (err) {
    console.error('User fetch failed:', err)
    user = getGuestUser()
  }
  
  try {
    posts = await fetchPosts(user.id)
  } catch (err) {
    console.error('Posts fetch failed:', err)
    posts = []
  }
  
  return { user, posts }
}
```

### Promise.allSettled:

```javascript
async function fetchAllWithErrors() {
  const results = await Promise.allSettled([
    fetchUsers(),
    fetchPosts(),
    fetchComments()
  ])
  
  const [users, posts, comments] = results.map(r => 
    r.status === 'fulfilled' ? r.value : []
  )
  
  return { users, posts, comments }
}
```

### Fallback Chain:

```javascript
async function fetchWithFallbacks() {
  try {
    return await fetchFromPrimary()
  } catch {
    try {
      return await fetchFromSecondary()
    } catch {
      try {
        return await fetchFromCache()
      } catch {
        return getDefaultData()
      }
    }
  }
}
```

---

## Retry Pattern

Automatically retry failed operations.

### Simple Retry:

```javascript
async function retry(fn, maxAttempts = 3) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (err) {
      if (attempt === maxAttempts) throw err
      console.log(`Attempt ${attempt} failed, retrying...`)
    }
  }
}

// Usage
const data = await retry(() => fetchData(), 5)
```

### Retry with Exponential Backoff:

```javascript
async function retryWithBackoff(fn, maxAttempts = 3, baseDelay = 1000) {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn()
    } catch (err) {
      if (attempt === maxAttempts) throw err
      
      const delay = baseDelay * Math.pow(2, attempt - 1)
      console.log(`Attempt ${attempt} failed. Retrying in ${delay}ms...`)
      await new Promise(resolve => setTimeout(resolve, delay))
    }
  }
}

// Usage
const data = await retryWithBackoff(() => fetchData(), 5, 1000)
```

---

## Timeout Pattern

Add timeouts to async operations.

### Basic Timeout:

```javascript
function timeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), ms)
    )
  ])
}

// Usage
try {
  const data = await timeout(fetchData(), 5000)
} catch (err) {
  console.error('Operation timed out or failed')
}
```

### Timeout with Abort:

```javascript
async function fetchWithTimeout(url, ms) {
  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), ms)
  
  try {
    const response = await fetch(url, { signal: controller.signal })
    return await response.json()
  } finally {
    clearTimeout(timeoutId)
  }
}
```

---

## Caching Pattern

Cache async results to avoid redundant operations.

### Simple Cache:

```javascript
const cache = new Map()

async function fetchWithCache(key, fetcher) {
  if (cache.has(key)) return cache.get(key)
  
  const data = await fetcher()
  cache.set(key, data)
  return data
}

// Usage
const user = await fetchWithCache('user:1', () => fetchUser(1))
```

### Cache with Expiration:

```javascript
class CacheWithExpiry {
  constructor(ttl = 60000) {
    this.cache = new Map()
    this.ttl = ttl
  }
  
  async get(key, fetcher) {
    const cached = this.cache.get(key)
    
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data
    }
    
    const data = await fetcher()
    this.cache.set(key, { data, timestamp: Date.now() })
    return data
  }
}

// Usage
const cache = new CacheWithExpiry(60000)  // 1 minute TTL
const data = await cache.get('api:data', () => fetchData())
```

---

## Real-World Examples

### Request Queue (Concurrency Control):

```javascript
class RequestQueue {
  constructor(concurrency = 3) {
    this.concurrency = concurrency
    this.running = 0
    this.queue = []
  }
  
  async add(fn) {
    while (this.running >= this.concurrency) {
      await new Promise(resolve => this.queue.push(resolve))
    }
    
    this.running++
    
    try {
      return await fn()
    } finally {
      this.running--
      const resolve = this.queue.shift()
      if (resolve) resolve()
    }
  }
}

// Usage: Max 3 concurrent requests
const queue = new RequestQueue(3)
const results = await Promise.all(
  urls.map(url => queue.add(() => fetch(url)))
)
```

### Polling Pattern:

```javascript
async function poll(fn, condition, interval = 1000, timeout = 30000) {
  const endTime = Date.now() + timeout
  
  while (Date.now() < endTime) {
    const result = await fn()
    if (condition(result)) return result
    
    await new Promise(resolve => setTimeout(resolve, interval))
  }
  
  throw new Error('Polling timeout')
}

// Usage: Poll until job completes
const job = await poll(
  () => checkJobStatus(jobId),
  status => status === 'complete',
  2000,   // Check every 2 seconds
  60000   // Timeout after 1 minute
)
```

### Circuit Breaker:

```javascript
class CircuitBreaker {
  constructor(threshold = 5, resetTime = 60000) {
    this.failures = 0
    this.threshold = threshold
    this.resetTime = resetTime
    this.state = 'CLOSED'
    this.nextAttempt = Date.now()
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN')
      }
      this.state = 'HALF_OPEN'
    }
    
    try {
      const result = await fn()
      this.onSuccess()
      return result
    } catch (err) {
      this.onFailure()
      throw err
    }
  }
  
  onSuccess() {
    this.failures = 0
    this.state = 'CLOSED'
  }
  
  onFailure() {
    this.failures++
    if (this.failures >= this.threshold) {
      this.state = 'OPEN'
      this.nextAttempt = Date.now() + this.resetTime
    }
  }
}

// Usage: Protect API from cascading failures
const breaker = new CircuitBreaker(5, 60000)
const data = await breaker.execute(() => fetchData())
```

### Debounce:

```javascript
function debounce(fn, delay) {
  let timeoutId
  
  return function(...args) {
    clearTimeout(timeoutId)
    
    return new Promise((resolve, reject) => {
      timeoutId = setTimeout(async () => {
        try {
          resolve(await fn.apply(this, args))
        } catch (err) {
          reject(err)
        }
      }, delay)
    })
  }
}

// Usage: Search API with 300ms debounce
const debouncedSearch = debounce(async (query) => {
  return await searchAPI(query)
}, 300)

await debouncedSearch('javascript')
```

---

## Summary

### Pattern Selection Guide:

| Pattern | Use When |
|---------|----------|
| Sequential | Operations depend on each other |
| Parallel | Independent operations |
| Retry | Network requests, flaky APIs |
| Timeout | Need operation guarantees |
| Cache | Expensive, reusable data |
| Queue | Control concurrency |
| Poll | Wait for async state change |
| Circuit Breaker | Protect against failures |
| Debounce | User input, search |

### Best Practices:
- Use parallel execution when possible
- Always handle errors appropriately
- Add timeouts to external requests
- Cache expensive operations
- Limit concurrent operations
- Monitor and log failures

### Related Topics:
- Async functions
- Promise combinators
- Error handling
- Performance optimization
