# Async Functions

## Table of Contents
- [What are Async Functions?](#what-are-async-functions)
- [Basic Syntax](#basic-syntax)
- [Return Values](#return-values)
- [Error Handling](#error-handling)
- [Async Methods](#async-methods)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)

---

## What are Async Functions?

**Async functions** are syntactic sugar for working with Promises, making asynchronous code look and behave like synchronous code.

```javascript
// Promise version
function fetchUser() {
  return fetch('/api/user')
    .then(response => response.json())
    .then(data => processData(data))
    .catch(err => handleError(err))
}

// Async/await version
async function fetchUser() {
  try {
    const response = await fetch('/api/user')
    const data = await response.json()
    return processData(data)
  } catch (err) {
    handleError(err)
  }
}
```

**Benefits:** Cleaner syntax, easier error handling, better debugging, read like synchronous code.

---

## Basic Syntax

```javascript
// Function Declaration
async function myFunction() { }

// Function Expression
const myFunction = async function() { }

// Arrow Function
const myFunction = async () => { }

// Class Method
class MyClass {
  async myMethod() { }
}

// IIFE
(async () => {
  const data = await fetchData()
})()

// Top-level await (ES2022 modules)
const data = await fetchData()
```

---

## Return Values

Async functions **always** return a Promise.

```javascript
async function getValue() {
  return 42  // Wrapped in Promise.resolve(42)
}

getValue().then(value => console.log(value))  // 42

// Returning Promises
async function fetchData() {
  return fetch('/api/data')  // Already a Promise
}

const response = await fetchData()
const data = await response.json()
```

---

## Error Handling

### Basic Try/Catch:

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`)
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`)
    }
    
    return await response.json()
  } catch (err) {
    console.error('Failed to fetch user:', err)
    return null  // Fallback
  }
}
```

### Specific Error Handling:

```javascript
async function processData() {
  try {
    const data = await fetchData()
    return processRawData(data)
  } catch (err) {
    if (err instanceof NetworkError) return retry()
    if (err instanceof ValidationError) return useDefaultData()
    throw err  // Unknown error
  }
}
```

### Finally Block:

```javascript
async function fetchWithLoader() {
  showLoader()
  
  try {
    const data = await fetchData()
    return processData(data)
  } catch (err) {
    handleError(err)
  } finally {
    hideLoader()  // Always executes
  }
}
```

---

## Async Methods

### Object Methods:

```javascript
const api = {
  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`)
    return response.json()
  },
  
  async saveUser(user) {
    const response = await fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(user)
    })
    return response.json()
  }
}

const user = await api.fetchUser(1)
```

### Class Methods:

```javascript
class UserService {
  constructor(baseUrl) {
    this.baseUrl = baseUrl
  }
  
  async getUser(id) {
    const response = await fetch(`${this.baseUrl}/users/${id}`)
    return response.json()
  }
  
  async updateUser(id, data) {
    const response = await fetch(`${this.baseUrl}/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data)
    })
    return response.json()
  }
}

const service = new UserService('/api')
const user = await service.getUser(1)
```

---

## Common Patterns

### Sequential Execution:

```javascript
async function processInOrder() {
  const result1 = await step1()
  const result2 = await step2(result1)
  const result3 = await step3(result2)
  return result3
}
```

### Parallel Execution:

```javascript
async function processInParallel() {
  const [result1, result2, result3] = await Promise.all([
    step1(),
    step2(),
    step3()
  ])
  
  return { result1, result2, result3 }
}
```

### Conditional Logic:

```javascript
async function conditionalFetch(useCache) {
  if (useCache) {
    const cached = await getFromCache()
    if (cached) return cached
  }
  
  const data = await fetchFromAPI()
  await saveToCache(data)
  return data
}
```

### Looping:

```javascript
// Sequential
async function processItems(items) {
  const results = []
  for (const item of items) {
    results.push(await processItem(item))
  }
  return results
}

// Parallel
async function processItemsParallel(items) {
  return Promise.all(items.map(item => processItem(item)))
}
```

### Error Recovery:

```javascript
async function fetchWithFallback(url) {
  try {
    return await fetch(url)
  } catch (err) {
    console.log('Primary failed, trying fallback')
    return await fetch(fallbackUrl)
  }
}
```

---

## Best Practices

### 1. Use try/catch:

```javascript
// ❌ Bad
async function bad() {
  const data = await fetchData()
  return processData(data)
}

// ✅ Good
async function good() {
  try {
    const data = await fetchData()
    return processData(data)
  } catch (err) {
    console.error('Error:', err)
    throw err
  }
}
```

### 2. Avoid Unnecessary Await:

```javascript
// ❌ Bad
async function bad() {
  return await fetchData()
}

// ✅ Good
async function good() {
  return fetchData()
}

// ✅ When needed for try/catch
async function alsoGood() {
  try {
    return await fetchData()
  } catch (err) {
    handleError(err)
  }
}
```

### 3. Parallel When Possible:

```javascript
// ❌ Sequential (slower)
async function sequential() {
  const user = await fetchUser()
  const posts = await fetchPosts()
  const comments = await fetchComments()
  return { user, posts, comments }
}

// ✅ Parallel (faster)
async function parallel() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ])
  return { user, posts, comments }
}
```

### 4. Handle Rejections:

```javascript
async function main() {
  const data = await fetchData()
  processData(data)
}

main().catch(err => {
  console.error('Unhandled error:', err)
  process.exit(1)
})
```

### 5. Use Finally for Cleanup:

```javascript
async function fetchWithCleanup() {
  const resource = await acquireResource()
  
  try {
    return await processResource(resource)
  } finally {
    await releaseResource(resource)  // Always runs
  }
}
```

---

## Summary

### Key Points:
- Async functions always return Promises
- Use `try/catch` for error handling
- Avoid unnecessary `await`
- Use `Promise.all()` for parallel operations
- Always handle rejections

### Comparison:

```javascript
// Promises
function fetchData() {
  return fetch('/api')
    .then(r => r.json())
    .then(data => processData(data))
    .catch(handleError)
}

// Async/Await
async function fetchData() {
  try {
    const response = await fetch('/api')
    const data = await response.json()
    return processData(data)
  } catch (err) {
    handleError(err)
  }
}
```

### When to Use:
- ✅ Modern codebases
- ✅ Complex async flows
- ✅ Need readable code
- ✅ Error handling important

### Related Topics:
- Await keyword
- Promise.all/race/allSettled
- Error handling strategies
- Async patterns
