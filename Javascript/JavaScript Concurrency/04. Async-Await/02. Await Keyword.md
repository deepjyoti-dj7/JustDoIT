# Await Keyword

## Table of Contents
- [What is Await?](#what-is-await)
- [Basic Usage](#basic-usage)
- [Await with Promises](#await-with-promises)
- [Error Handling](#error-handling)
- [Top-Level Await](#top-level-await)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)

---

## What is Await?

The `await` keyword pauses async function execution until a Promise is settled (resolved or rejected).

```javascript
async function fetchData() {
  const response = await fetch('/api/data')  // Pauses here
  const data = await response.json()         // Pauses here
  return data
}
```

**Key Points:**
- Only works inside `async` functions
- Pauses execution without blocking main thread
- Returns resolved value or throws if rejected
- Makes async code look synchronous

---

## Basic Usage

### Awaiting Promises:

```javascript
async function example() {
  // Without await
  const promise = fetch('/api/data')  // Returns Promise
  console.log(promise)  // Promise { <pending> }
  
  // With await
  const response = await fetch('/api/data')  // Returns Response
  console.log(response)  // Response { ... }
}
```

### Awaiting Values:

```javascript
async function example() {
  const value = await 42  // Non-promise wrapped in Promise.resolve()
  console.log(value)  // 42
  
  const str = await 'Hello'
  console.log(str)  // 'Hello'
}
```

---

## Await with Promises

### Promise Resolution:

```javascript
async function fetchUser() {
  const user = await Promise.resolve({ name: 'Alice', id: 1 })
  console.log(user)  // { name: 'Alice', id: 1 }
}
```

### Promise Rejection:

```javascript
async function handleError() {
  try {
    const result = await Promise.reject(new Error('Failed'))
  } catch (err) {
    console.error(err.message)  // 'Failed'
  }
}
```

### Multiple Awaits:

```javascript
async function fetchAll() {
  const user = await fetchUser()
  const posts = await fetchPosts(user.id)
  const comments = await fetchComments(user.id)
  
  return { user, posts, comments }
}
```

---

## Error Handling

### Try/Catch:

```javascript
async function fetchData() {
  try {
    const response = await fetch('/api/data')
    return await response.json()
  } catch (err) {
    console.error('Fetch failed:', err)
    return null
  }
}
```

### Multiple Try/Catch:

```javascript
async function fetchWithFallbacks() {
  let data
  
  try {
    data = await fetchFromPrimary()
  } catch (err) {
    try {
      data = await fetchFromSecondary()
    } catch (err2) {
      data = getDefaultData()
    }
  }
  
  return data
}
```

### Selective Error Handling:

```javascript
async function processData() {
  const data = await fetchData().catch(err => {
    console.error('Fetch error:', err)
    return getDefaultData()
  })
  
  return processRawData(data)
}
```

---

## Top-Level Await

### ES2022 Modules:

```javascript
// In module scope (not in function)
const data = await fetch('/api/data').then(r => r.json())
console.log(data)

// Dynamic imports
const module = await import('./module.js')
module.doSomething()

// Conditional imports
const language = navigator.language
const messages = await import(`./i18n/${language}.js`)
```

### Use Cases:

```javascript
// Loading config
const config = await fetch('/config.json').then(r => r.json())

// Database connection
await db.connect()

// Feature detection
const hasFeature = await checkFeature()
if (hasFeature) {
  const module = await import('./feature.js')
}
```

---

## Common Patterns

### Sequential Execution:

```javascript
async function sequential() {
  const step1 = await doStep1()
  const step2 = await doStep2(step1)
  const step3 = await doStep3(step2)
  return step3
}
```

### Parallel Execution:

```javascript
async function parallel() {
  // Start all at once
  const [result1, result2, result3] = await Promise.all([
    doStep1(),
    doStep2(),
    doStep3()
  ])
  
  return { result1, result2, result3 }
}
```

### Parallel then Sequential:

```javascript
async function mixed() {
  // Parallel
  const [user, settings] = await Promise.all([
    fetchUser(),
    fetchSettings()
  ])
  
  // Sequential (depends on user)
  const posts = await fetchPosts(user.id)
  const comments = await fetchComments(user.id)
  
  return { user, settings, posts, comments }
}
```

### Conditional Await:

```javascript
async function conditionalFetch(useCache) {
  let data
  
  if (useCache) {
    data = await getFromCache()
  }
  
  if (!data) {
    data = await fetchFromAPI()
    if (useCache) await saveToCache(data)
  }
  
  return data
}
```

### Loop with Await:

```javascript
// Sequential processing
async function processSequentially(items) {
  for (const item of items) {
    await processItem(item)
  }
}

// Parallel processing
async function processParallel(items) {
  await Promise.all(items.map(item => processItem(item)))
}

// Batched processing
async function processBatched(items, batchSize) {
  for (let i = 0; i < items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize)
    await Promise.all(batch.map(item => processItem(item)))
  }
}
```

---

## Best Practices

### 1. Don't Await in Sequence When You Can Parallelize:

```javascript
// ❌ Slow (sequential)
async function slow() {
  const user = await fetchUser()
  const posts = await fetchPosts()
  const comments = await fetchComments()
  return { user, posts, comments }
}

// ✅ Fast (parallel)
async function fast() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ])
  return { user, posts, comments }
}
```

### 2. Always Handle Errors:

```javascript
// ❌ Unhandled rejection
async function bad() {
  const data = await fetchData()
  return processData(data)
}

// ✅ Proper error handling
async function good() {
  try {
    const data = await fetchData()
    return processData(data)
  } catch (err) {
    console.error('Error:', err)
    throw err
  }
}
```

### 3. Avoid Mixing Await and .then():

```javascript
// ❌ Confusing
async function mixed() {
  const data = await fetchData().then(d => process(d))
  return data
}

// ✅ Consistent
async function consistent() {
  const rawData = await fetchData()
  const data = process(rawData)
  return data
}
```

### 4. Use await Only When Needed:

```javascript
// ❌ Unnecessary await
async function unnecessary() {
  return await fetchData()
}

// ✅ Direct return
async function direct() {
  return fetchData()
}

// ✅ Await when needed for error handling
async function needed() {
  try {
    return await fetchData()
  } catch (err) {
    return getDefaultData()
  }
}
```

### 5. Be Careful with Array Methods:

```javascript
// ❌ Won't work as expected
async function wrong(items) {
  items.forEach(async item => {
    await processItem(item)  // Doesn't wait
  })
}

// ✅ Correct sequential
async function sequential(items) {
  for (const item of items) {
    await processItem(item)
  }
}

// ✅ Correct parallel
async function parallel(items) {
  await Promise.all(items.map(item => processItem(item)))
}
```

---

## Summary

### Key Points:
- `await` pauses async function execution
- Only works in `async` functions (or module top-level)
- Returns resolved value or throws error
- Use `Promise.all()` for parallel operations
- Always handle errors with try/catch

### Await vs Then:

```javascript
// Using .then()
function fetchData() {
  return fetch('/api/data')
    .then(r => r.json())
    .then(data => processData(data))
}

// Using await
async function fetchData() {
  const response = await fetch('/api/data')
  const data = await response.json()
  return processData(data)
}
```

Both are equivalent, but `await` is more readable.

### Related Topics:
- Async functions
- Promise.all/race/allSettled
- Error handling
- Top-level await
