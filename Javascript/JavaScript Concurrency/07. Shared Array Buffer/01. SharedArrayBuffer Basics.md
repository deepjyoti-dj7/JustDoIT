# SharedArrayBuffer Basics

## Table of Contents
- [What is SharedArrayBuffer?](#what-is-sharedarraybuffer)
- [Creating SharedArrayBuffer](#creating-sharedarraybuffer)
- [Sharing Between Workers](#sharing-between-workers)
- [TypedArrays with SharedArrayBuffer](#typedarrays-with-sharedarraybuffer)
- [Security Considerations](#security-considerations)
- [Use Cases](#use-cases)
- [Limitations](#limitations)
- [Best Practices](#best-practices)

---

## What is SharedArrayBuffer?

**SharedArrayBuffer** is a low-level object that represents a fixed-length raw binary data buffer that can be shared between the main thread and Web Workers.

**Key Features:**
- Shared memory between threads
- Zero-copy data sharing
- Enables true multi-threading
- Requires Atomics for safe operations

**Difference from ArrayBuffer:**
```javascript
// Regular ArrayBuffer (copied on postMessage)
const buffer = new ArrayBuffer(16)
worker.postMessage(buffer)  // Buffer is cloned

// SharedArrayBuffer (shared reference)
const sharedBuffer = new SharedArrayBuffer(16)
worker.postMessage(sharedBuffer)  // Buffer is shared, not cloned
```

---

## Creating SharedArrayBuffer

### Basic Creation:

```javascript
// Create a 1024-byte shared buffer
const buffer = new SharedArrayBuffer(1024)

console.log(buffer.byteLength)  // 1024
console.log(buffer instanceof SharedArrayBuffer)  // true
```

### With TypedArray:

```javascript
const sharedBuffer = new SharedArrayBuffer(16)
const int32View = new Int32Array(sharedBuffer)

int32View[0] = 42
console.log(int32View[0])  // 42
```

### Multiple Views:

```javascript
const sharedBuffer = new SharedArrayBuffer(16)

const int32View = new Int32Array(sharedBuffer)
const uint8View = new Uint8Array(sharedBuffer)

int32View[0] = 0x12345678
console.log(uint8View[0])  // 0x78 (little-endian)
```

---

## Sharing Between Workers

### Main Thread:

```javascript
// main.js
const sharedBuffer = new SharedArrayBuffer(4)
const sharedArray = new Int32Array(sharedBuffer)

// Initialize data
sharedArray[0] = 0

// Create workers
const worker1 = new Worker('worker1.js')
const worker2 = new Worker('worker2.js')

// Share buffer with workers
worker1.postMessage({ buffer: sharedBuffer })
worker2.postMessage({ buffer: sharedBuffer })

// Monitor changes
setInterval(() => {
  console.log('Main thread sees:', sharedArray[0])
}, 1000)
```

### Worker 1 (Incrementer):

```javascript
// worker1.js
let sharedArray

self.onmessage = (e) => {
  sharedArray = new Int32Array(e.data.buffer)
  
  setInterval(() => {
    sharedArray[0]++
    console.log('Worker 1 incremented to:', sharedArray[0])
  }, 500)
}
```

### Worker 2 (Reader):

```javascript
// worker2.js
let sharedArray

self.onmessage = (e) => {
  sharedArray = new Int32Array(e.data.buffer)
  
  setInterval(() => {
    console.log('Worker 2 reads:', sharedArray[0])
  }, 1000)
}
```

---

## TypedArrays with SharedArrayBuffer

### Supported TypedArrays:

```javascript
const sharedBuffer = new SharedArrayBuffer(32)

const int8 = new Int8Array(sharedBuffer)        // 8-bit signed
const uint8 = new Uint8Array(sharedBuffer)      // 8-bit unsigned
const int16 = new Int16Array(sharedBuffer)      // 16-bit signed
const uint16 = new Uint16Array(sharedBuffer)    // 16-bit unsigned
const int32 = new Int32Array(sharedBuffer)      // 32-bit signed
const uint32 = new Uint32Array(sharedBuffer)    // 32-bit unsigned
const float32 = new Float32Array(sharedBuffer)  // 32-bit float
const float64 = new Float64Array(sharedBuffer)  // 64-bit float
```

### Byte Offset and Length:

```javascript
const sharedBuffer = new SharedArrayBuffer(16)

// Create view starting at byte 4, length 2
const view = new Int32Array(sharedBuffer, 4, 2)

view[0] = 100
view[1] = 200

console.log(view.byteOffset)  // 4
console.log(view.length)      // 2
```

### Data Sharing Example:

```javascript
// Main thread
const sharedBuffer = new SharedArrayBuffer(1024)
const data = new Float32Array(sharedBuffer)

// Fill with data
for (let i = 0; i < data.length; i++) {
  data[i] = Math.random()
}

worker.postMessage({ buffer: sharedBuffer })

// Worker
self.onmessage = (e) => {
  const data = new Float32Array(e.data.buffer)
  
  // Process data in-place
  for (let i = 0; i < data.length; i++) {
    data[i] *= 2  // Double all values
  }
  
  self.postMessage('done')
}
```

---

## Security Considerations

### Cross-Origin Isolation Required:

SharedArrayBuffer requires cross-origin isolation to prevent timing attacks like Spectre.

```http
<!-- Required headers -->
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

### HTML Headers:

```html
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
</head>
<body>
  <script>
    if (typeof SharedArrayBuffer !== 'undefined') {
      console.log('SharedArrayBuffer available')
    } else {
      console.log('SharedArrayBuffer not available')
    }
  </script>
</body>
</html>
```

### Feature Detection:

```javascript
function isSharedArrayBufferSupported() {
  try {
    const buffer = new SharedArrayBuffer(1)
    return true
  } catch (e) {
    return false
  }
}

if (isSharedArrayBufferSupported()) {
  // Use SharedArrayBuffer
} else {
  // Fallback to regular ArrayBuffer
}
```

---

## Use Cases

### 1. Parallel Image Processing:

```javascript
// Main thread
const imageData = ctx.getImageData(0, 0, width, height)
const sharedBuffer = new SharedArrayBuffer(imageData.data.length)
const sharedArray = new Uint8ClampedArray(sharedBuffer)

// Copy image data to shared buffer
sharedArray.set(imageData.data)

const workers = []
const workerCount = 4

for (let i = 0; i < workerCount; i++) {
  const worker = new Worker('image-worker.js')
  workers.push(worker)
  
  worker.postMessage({
    buffer: sharedBuffer,
    startRow: i * (height / workerCount),
    endRow: (i + 1) * (height / workerCount),
    width
  })
}

// Worker
self.onmessage = (e) => {
  const { buffer, startRow, endRow, width } = e.data
  const pixels = new Uint8ClampedArray(buffer)
  
  for (let y = startRow; y < endRow; y++) {
    for (let x = 0; x < width; x++) {
      const i = (y * width + x) * 4
      
      // Grayscale filter
      const avg = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3
      pixels[i] = pixels[i+1] = pixels[i+2] = avg
    }
  }
  
  self.postMessage('done')
}
```

### 2. Shared State Between Workers:

```javascript
// Main
const stateBuffer = new SharedArrayBuffer(100)
const state = new Int32Array(stateBuffer)

// Initialize state
state[0] = 0  // Counter
state[1] = 0  // Flag

const workers = [
  new Worker('worker.js'),
  new Worker('worker.js'),
  new Worker('worker.js')
]

workers.forEach(w => w.postMessage({ state: stateBuffer }))

// Worker
self.onmessage = (e) => {
  const state = new Int32Array(e.data.state)
  
  setInterval(() => {
    Atomics.add(state, 0, 1)  // Safe increment
    console.log('Counter:', state[0])
  }, 100)
}
```

### 3. Lock-Free Data Structures:

```javascript
class SharedQueue {
  constructor(size) {
    // [head, tail, ...data]
    this.buffer = new SharedArrayBuffer((size + 2) * 4)
    this.view = new Int32Array(this.buffer)
    this.size = size
    this.view[0] = 0  // head
    this.view[1] = 0  // tail
  }
  
  enqueue(value) {
    const tail = Atomics.load(this.view, 1)
    const head = Atomics.load(this.view, 0)
    const next = (tail + 1) % this.size
    
    if (next === head) {
      throw new Error('Queue full')
    }
    
    this.view[2 + tail] = value
    Atomics.store(this.view, 1, next)
  }
  
  dequeue() {
    const head = Atomics.load(this.view, 0)
    const tail = Atomics.load(this.view, 1)
    
    if (head === tail) {
      throw new Error('Queue empty')
    }
    
    const value = this.view[2 + head]
    Atomics.store(this.view, 0, (head + 1) % this.size)
    return value
  }
  
  getBuffer() {
    return this.buffer
  }
}

// Usage
const queue = new SharedQueue(100)
worker.postMessage({ queueBuffer: queue.getBuffer() })
```

---

## Limitations

### Cannot Be Transferred:

```javascript
// ❌ Cannot transfer SharedArrayBuffer
worker.postMessage(sharedBuffer, [sharedBuffer])  // Error

// ✅ Send as regular message
worker.postMessage({ buffer: sharedBuffer })
```

### Fixed Size:

```javascript
const buffer = new SharedArrayBuffer(1024)

// Cannot resize
// buffer.resize(2048)  // No such method
```

### Requires Atomics for Safety:

```javascript
// ❌ Race condition
sharedArray[0]++

// ✅ Thread-safe
Atomics.add(sharedArray, 0, 1)
```

### Browser Support:

```javascript
// Check support
if ('SharedArrayBuffer' in window) {
  console.log('Supported')
} else {
  console.log('Not supported')
}
```

---

## Best Practices

### 1. Always Use Atomics:

```javascript
// ❌ Unsafe
function increment() {
  sharedArray[0]++
}

// ✅ Safe
function increment() {
  Atomics.add(sharedArray, 0, 1)
}
```

### 2. Check Cross-Origin Isolation:

```javascript
if (crossOriginIsolated) {
  const buffer = new SharedArrayBuffer(1024)
} else {
  console.error('SharedArrayBuffer requires cross-origin isolation')
}
```

### 3. Use Proper TypedArrays:

```javascript
// ✅ Match data type to use case
const ints = new Int32Array(sharedBuffer)      // For integers
const floats = new Float32Array(sharedBuffer)  // For decimals
const bytes = new Uint8Array(sharedBuffer)     // For binary data
```

### 4. Handle Errors Gracefully:

```javascript
function createSharedBuffer(size) {
  try {
    return new SharedArrayBuffer(size)
  } catch (e) {
    console.warn('SharedArrayBuffer not available, using ArrayBuffer')
    return new ArrayBuffer(size)
  }
}
```

### 5. Document Shared Memory Layout:

```javascript
/*
 * Shared Buffer Layout:
 * [0-3]   Counter (Int32)
 * [4-7]   Flag (Int32)
 * [8-11]  Status (Int32)
 * [12+]   Data array
 */
const buffer = new SharedArrayBuffer(1024)
const view = new Int32Array(buffer)

const COUNTER_INDEX = 0
const FLAG_INDEX = 1
const STATUS_INDEX = 2
const DATA_START = 3
```

---

## Summary

### Key Points:
- Shared memory between threads
- Zero-copy data transfer
- Requires Atomics for safety
- Needs cross-origin isolation
- Fixed size after creation

### When to Use:
- ✅ Parallel data processing
- ✅ High-performance computing
- ✅ Shared state across workers
- ✅ Large data sets
- ❌ Simple message passing
- ❌ Without cross-origin isolation

### Related Topics:
- Atomics
- Web Workers
- Race conditions
- Parallel processing
