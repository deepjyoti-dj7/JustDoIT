# Callback Hell

## Table of Contents
- [What is Callback Hell?](#what-is-callback-hell)
- [The Pyramid of Doom](#the-pyramid-of-doom)
- [Problems](#problems)
- [Real-World Examples](#real-world-examples)
- [Solutions](#solutions)
- [Best Practices](#best-practices)

---

## What is Callback Hell?

**Callback hell** occurs when multiple nested callbacks make code unreadable.

```javascript
// Callback hell
getData(function(a) {
  getMoreData(a, function(b) {
    getEvenMoreData(b, function(c) {
      console.log(c)
    })
  })
})
```

---

## The Pyramid of Doom

```javascript
const fs = require('fs')

fs.readFile('file1.txt', 'utf8', (err1, data1) => {
  if (err1) return console.error(err1)
  
  fs.readFile('file2.txt', 'utf8', (err2, data2) => {
    if (err2) return console.error(err2)
    
    fs.readFile('file3.txt', 'utf8', (err3, data3) => {
      if (err3) return console.error(err3)
      
      console.log(data1 + data2 + data3)
    })
  })
})
```

---

## Problems

### 1. Readability
Hard to follow the logic flow.

### 2. Error Handling
Repeated at every level.

### 3. Difficult to Debug
Confusing stack traces.

### 4. Hard to Modify
Restructuring required for changes.

---

## Real-World Examples

### Authentication Flow:

```javascript
function authenticateUser(username, password) {
  validateInput(username, password, (err, valid) => {
    if (err) return handleError(err)
    
    findUser(username, (err, user) => {
      if (err) return handleError(err)
      
      comparePasswords(password, user.password, (err, match) => {
        if (err) return handleError(err)
        \n        generateToken(user, (err, token) => {
          if (err) return handleError(err)
          \n          saveSession(user.id, token, (err, session) => {
            if (err) return handleError(err)
            \n            return res.json({ token, user })
          })
        })
      })
    })
  })
}
```

---

## Solutions

### 1. Named Functions

```javascript
function processUser(err, user) {
  if (err) return handleError(err)
  getOrders(user.id, processOrders)
}

function processOrders(err, orders) {
  if (err) return handleError(err)
  console.log(orders)
}

getUser(userId, processUser)
```

### 2. Promises

```javascript
getUserPromise(userId)
  .then(user => getOrders(user.id))
  .then(orders => getDetails(orders[0].id))
  .then(details => updateInventory(details))
  .catch(handleError)
```

### 3. Async/Await

```javascript
async function processUserData(userId) {
  try {
    const user = await getUser(userId)
    const orders = await getOrders(user.id)
    const details = await getDetails(orders[0].id)
    await updateInventory(details)
  } catch (err) {
    handleError(err)
  }
}
```

---

## Best Practices

1. **Limit nesting depth** (max 2-3 levels)
2. **Use Promises or async/await** for new code
3. **Extract callbacks** into named functions
4. **Handle errors** consistently
5. **Document complex flows**

---

## Summary

**Avoid callback hell by:**
- Using named functions
- Converting to Promises
- Using async/await (recommended)
- Modularizing code

**Recommendation:** Use async/await for all new asynchronous code.
