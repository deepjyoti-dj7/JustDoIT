# Callbacks

## Table of Contents
- [What are Callbacks?](#what-are-callbacks)
- [Callback Pattern](#callback-pattern)
- [Error-First Callbacks](#error-first-callbacks)
- [Higher-Order Functions](#higher-order-functions)
- [Async Callbacks](#async-callbacks)
- [Callback Queue](#callback-queue)
- [Common Patterns](#common-patterns)
- [Pitfalls](#pitfalls)
- [Best Practices](#best-practices)

---

## What are Callbacks?

A **callback** is a function passed as an argument to another function, to be executed later.

### Basic Example:

```javascript
// Simple callback
function greet(name, callback) {
  console.log(`Hello, ${name}!`)
  callback()
}

function done() {
  console.log('Done greeting')
}

greet('Alice', done)
// Output:
// Hello, Alice!
// Done greeting
```

### Why Use Callbacks?

1. **Asynchronous operations**: Handle operations that take time
2. **Event handling**: Respond to user actions
3. **Higher-order functions**: Array methods like map, filter
4. **Inversion of control**: Let other code decide when to execute

---

## Callback Pattern

### Synchronous Callbacks

Execute immediately:

```javascript
const numbers = [1, 2, 3, 4, 5]

// Array methods use synchronous callbacks
const doubled = numbers.map(n => n * 2)
console.log(doubled)  // [2, 4, 6, 8, 10]

const evens = numbers.filter(n => n % 2 === 0)
console.log(evens)  // [2, 4]

const sum = numbers.reduce((acc, n) => acc + n, 0)
console.log(sum)  // 15
```

### Asynchronous Callbacks

Execute later (after some event or time):

```javascript
// setTimeout - executes after delay
setTimeout(() => {
  console.log('Executed after 1 second')
}, 1000)

// Event listeners - executes on event
document.getElementById('btn').addEventListener('click', () => {
  console.log('Button clicked!')
})

// File I/O - executes when operation completes
const fs = require('fs')
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err
  console.log(data)
})
```

---

## Error-First Callbacks

Node.js convention: first parameter is error, second is result.

### Pattern:

```javascript
function readFileAsync(path, callback) {
  // Simulate async operation
  setTimeout(() => {
    const error = Math.random() > 0.5 ? new Error('File not found') : null
    const data = error ? null : 'File contents'
    
    callback(error, data)
  }, 1000)
}

// Usage
readFileAsync('file.txt', (err, data) => {
  if (err) {
    console.error('Error:', err.message)
    return
  }
  
  console.log('Data:', data)
})
```

### Why Error-First?

1. **Consistency**: All async APIs follow same pattern
2. **Error handling**: Forces you to handle errors
3. **Null check**: Error is falsy when successful

```javascript
const fs = require('fs')

// Error-first callback
fs.readFile('data.json', 'utf8', (err, data) => {
  // Always check error first
  if (err) {
    console.error('Failed to read file:', err)
    return
  }
  
  // Safe to use data here
  const json = JSON.parse(data)
  console.log(json)
})
```

---

## Higher-Order Functions

Functions that accept or return functions.

### Accepting Callbacks:

```javascript
// Custom higher-order function
function repeat(n, callback) {
  for (let i = 0; i < n; i++) {
    callback(i)
  }
}

repeat(3, (i) => {
  console.log(`Iteration ${i}`)
})
// Output:
// Iteration 0
// Iteration 1
// Iteration 2
```

### Returning Functions:

```javascript
// Function that returns a function
function multiplier(factor) {
  return function(number) {
    return number * factor
  }
}

const double = multiplier(2)
const triple = multiplier(3)

console.log(double(5))  // 10
console.log(triple(5))  // 15
```

### Practical Example - Custom forEach:

```javascript
function forEach(array, callback) {
  for (let i = 0; i < array.length; i++) {
    callback(array[i], i, array)
  }
}

const fruits = ['apple', 'banana', 'orange']

forEach(fruits, (fruit, index) => {
  console.log(`${index}: ${fruit}`)
})
// Output:
// 0: apple
// 1: banana
// 2: orange
```

---

## Async Callbacks

### setTimeout and setInterval:

```javascript
// setTimeout - execute once after delay
const timeoutId = setTimeout(() => {
  console.log('Delayed execution')
}, 2000)

// Can cancel
clearTimeout(timeoutId)

// setInterval - execute repeatedly
let count = 0
const intervalId = setInterval(() => {
  console.log(`Count: ${++count}`)
  
  if (count === 5) {
    clearInterval(intervalId)
  }
}, 1000)
```

### Event Listeners:

```javascript
const button = document.getElementById('myButton')

// Add event listener
button.addEventListener('click', function(event) {
  console.log('Button clicked!', event.target)
})

// Multiple listeners
button.addEventListener('click', () => {
  console.log('Second listener')
})

// Remove listener
function handler() {
  console.log('Handler')
}
button.addEventListener('click', handler)
button.removeEventListener('click', handler)
```

### AJAX Callbacks:

```javascript
function fetchData(url, callback) {
  const xhr = new XMLHttpRequest()
  
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        callback(null, JSON.parse(xhr.responseText))
      } else {
        callback(new Error(`HTTP ${xhr.status}`))
      }
    }
  }
  
  xhr.open('GET', url)
  xhr.send()
}

// Usage
fetchData('/api/users', (err, users) => {
  if (err) {
    console.error('Failed:', err)
    return
  }
  console.log('Users:', users)
})
```

---

## Callback Queue

Asynchronous callbacks are queued in the event loop.

```javascript
console.log('1')

setTimeout(() => {
  console.log('2')
}, 0)

setTimeout(() => {
  console.log('3')
}, 0)

console.log('4')

// Output:
// 1
// 4
// 2
// 3

// Callbacks queued, executed after sync code
```

### Execution Order:

```javascript
function first(callback) {
  setTimeout(() => {
    console.log('First')
    callback()
  }, 100)
}

function second(callback) {
  setTimeout(() => {
    console.log('Second')
    callback()
  }, 50)
}

first(() => {
  console.log('First callback')
})

second(() => {
  console.log('Second callback')
})

// Output:
// Second (50ms)
// Second callback
// First (100ms)
// First callback
```

---

## Common Patterns

### Pattern 1: Callback Wrapper

```javascript
function safeCallback(callback) {
  return function(...args) {
    if (typeof callback === 'function') {
      try {
        return callback.apply(this, args)
      } catch (err) {
        console.error('Callback error:', err)
      }
    }
  }
}

// Usage
function doSomething(callback) {
  const safe = safeCallback(callback)
  safe(result)
}
```

### Pattern 2: Once Callback

```javascript
function once(callback) {
  let called = false
  
  return function(...args) {
    if (!called) {
      called = true
      return callback.apply(this, args)
    }
  }
}

const onceCallback = once(() => {
  console.log('Called only once')
})

onceCallback()  // "Called only once"
onceCallback()  // Nothing
onceCallback()  // Nothing
```

### Pattern 3: Throttle

```javascript
function throttle(callback, delay) {
  let lastCall = 0
  
  return function(...args) {
    const now = Date.now()
    
    if (now - lastCall >= delay) {
      lastCall = now
      return callback.apply(this, args)
    }
  }
}

const throttled = throttle(() => {
  console.log('Throttled function')
}, 1000)

// Calls limited to once per second
window.addEventListener('scroll', throttled)
```

---

## Pitfalls

### Pitfall 1: Losing `this` Context

```javascript
const obj = {
  name: 'Object',
  
  // ❌ Loses context
  method: function() {
    setTimeout(function() {
      console.log(this.name)  // undefined
    }, 1000)
  },
  
  // ✅ Arrow function preserves context
  methodFixed: function() {
    setTimeout(() => {
      console.log(this.name)  // "Object"
    }, 1000)
  },
  
  // ✅ Bind context
  methodBind: function() {
    setTimeout(function() {
      console.log(this.name)  // "Object"
    }.bind(this), 1000)
  }
}
```

### Pitfall 2: Multiple Callback Invocations

```javascript
// ❌ Callback called multiple times
function badAsync(callback) {
  setTimeout(() => {
    callback('first')
  }, 100)
  
  setTimeout(() => {
    callback('second')  // Oops!
  }, 200)
}

// ✅ Ensure single callback
function goodAsync(callback) {
  let called = false
  
  function callOnce(data) {
    if (!called) {
      called = true
      callback(data)
    }
  }
  
  setTimeout(() => callOnce('data'), 100)
}
```

### Pitfall 3: Callback Not Being Called

```javascript
// ❌ Missing callback in error case
function getData(callback) {
  if (someCondition) {
    return  // Forgot to call callback!
  }
  
  callback(null, data)
}

// ✅ Always call callback
function getDataFixed(callback) {
  if (someCondition) {
    return callback(new Error('Invalid condition'))
  }
  
  callback(null, data)
}
```

---

## Best Practices

### 1. Always Handle Errors

```javascript
// ✅ Good
fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error('Error:', err)
    return
  }
  console.log(data)
})

// ❌ Bad - ignores errors
fs.readFile('file.txt', (err, data) => {
  console.log(data)  // What if err?
})
```

### 2. Keep Callbacks Small

```javascript
// ❌ Large inline callback
fetchUser(userId, (err, user) => {
  if (err) handleError(err)
  validateUser(user, (err, valid) => {
    if (err) handleError(err)
    // ... lots of logic
  })
})

// ✅ Separate functions
function handleUser(err, user) {
  if (err) return handleError(err)
  validateUser(user, handleValidation)
}

fetchUser(userId, handleUser)
```

### 3. Name Your Callbacks

```javascript
// ❌ Anonymous callback
button.addEventListener('click', function() {
  // ...
})

// ✅ Named callback (easier debugging)
button.addEventListener('click', function handleClick() {
  // Stack traces show "handleClick"
})
```

### 4. Use Promises for Complex Async

```javascript
// Callbacks get messy with multiple async operations
// Consider using Promises or async/await instead

const util = require('util')
const fs = require('fs')

// Convert callback to Promise
const readFilePromise = util.promisify(fs.readFile)

// Much cleaner
readFilePromise('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err))
```

---

## Summary

### Key Points:
- Callbacks enable asynchronous programming
- Error-first pattern is Node.js convention
- Higher-order functions accept/return functions
- Callbacks are queued by event loop
- Beware of context (this) and error handling

### When to Use Callbacks:
- Simple async operations
- Event handlers
- Array methods (map, filter, reduce)
- Single async operation

### When to Avoid:
- Multiple nested async operations (callback hell)
- Complex error handling
- Need for Promise.all-like behavior

### Evolution:
Callbacks → Promises → Async/Await
