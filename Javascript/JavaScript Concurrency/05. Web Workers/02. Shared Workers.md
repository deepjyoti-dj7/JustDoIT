# Shared Workers

## Table of Contents
- [What are Shared Workers?](#what-are-shared-workers)
- [Creating Shared Workers](#creating-shared-workers)
- [Communication](#communication)
- [Multi-Tab Coordination](#multi-tab-coordination)
- [Use Cases](#use-cases)
- [Comparison with Dedicated Workers](#comparison-with-dedicated-workers)
- [Best Practices](#best-practices)

---

## What are Shared Workers?

**Shared Workers** can be accessed by multiple scripts (tabs, iframes, windows) from the same origin.

**Differences from Dedicated Workers:**
- Shared across multiple browsing contexts
- Use `MessagePort` for communication
- Persists across page reloads
- More complex lifecycle

---

## Creating Shared Workers

### Basic Setup:

**main.js (in any tab):**
```javascript
const worker = new SharedWorker('shared-worker.js')

// Access the port
const port = worker.port

// Start communication
port.start()

// Send message
port.postMessage({ type: 'hello', from: 'Tab 1' })

// Receive messages
port.onmessage = (event) => {
  console.log('Received:', event.data)
}
```

**shared-worker.js:**
```javascript
const connections = []

self.onconnect = (event) => {
  const port = event.ports[0]
  connections.push(port)
  
  port.onmessage = (e) => {
    console.log('Message from client:', e.data)
    
    // Respond to sender
    port.postMessage({ response: 'Got it!' })
    
    // Broadcast to all connections
    connections.forEach(p => {
      if (p !== port) {
        p.postMessage({ broadcast: e.data })
      }
    })
  }
  
  port.start()
}
```

---

## Communication

### Message Ports:

```javascript
// Tab 1
const worker = new SharedWorker('worker.js')
worker.port.onmessage = (e) => {
  console.log('Tab 1 received:', e.data)
}
worker.port.postMessage('Hello from Tab 1')

// Tab 2
const worker = new SharedWorker('worker.js')
worker.port.onmessage = (e) => {
  console.log('Tab 2 received:', e.data)
}
worker.port.postMessage('Hello from Tab 2')

// Shared Worker
self.onconnect = (e) => {
  const port = e.ports[0]
  
  port.onmessage = (event) => {
    console.log('Worker received:', event.data)
    port.postMessage(`Echo: ${event.data}`)
  }
  
  port.start()
}
```

### Connection Management:

```javascript
// shared-worker.js
const ports = new Set()

self.onconnect = (event) => {
  const port = event.ports[0]
  ports.add(port)
  
  // Notify connection count
  broadcast({ type: 'connectionCount', count: ports.size })
  
  port.onmessage = (e) => {
    handleMessage(port, e.data)
  }
  
  // Handle disconnect
  port.onclose = () => {
    ports.delete(port)
    broadcast({ type: 'connectionCount', count: ports.size })
  }
  
  port.start()
}

function broadcast(message) {
  ports.forEach(port => port.postMessage(message))
}
```

---

## Multi-Tab Coordination

### Shared State:

```javascript
// shared-worker.js
let sharedState = {
  users: [],
  messages: []
}

self.onconnect = (event) => {
  const port = event.ports[0]
  
  port.onmessage = (e) => {
    const { type, data } = e.data
    
    switch (type) {
      case 'GET_STATE':
        port.postMessage({ type: 'STATE', data: sharedState })
        break
        
      case 'UPDATE_USER':
        sharedState.users.push(data)
        broadcast({ type: 'USER_ADDED', data })
        break
        
      case 'ADD_MESSAGE':
        sharedState.messages.push(data)
        broadcast({ type: 'NEW_MESSAGE', data })
        break
    }
  }
  
  port.start()
  
  // Send current state to new connection
  port.postMessage({ type: 'STATE', data: sharedState })
}

function broadcast(message) {
  // Send to all tabs
  self.clients.matchAll().then(clients => {
    clients.forEach(client => client.postMessage(message))
  })
}
```

### Chat Application:

```javascript
// main.js
const worker = new SharedWorker('chat-worker.js')
const port = worker.port

port.onmessage = (e) => {
  const { type, data } = e.data
  
  if (type === 'MESSAGE') {
    displayMessage(data)
  } else if (type === 'USER_JOIN') {
    console.log(`${data.name} joined`)
  }
}

function sendMessage(text) {
  port.postMessage({ type: 'SEND_MESSAGE', text, user: currentUser })
}

port.start()

// chat-worker.js
const connections = new Set()
const messages = []

self.onconnect = (event) => {
  const port = event.ports[0]
  connections.add(port)
  
  // Send chat history to new connection
  port.postMessage({ type: 'HISTORY', messages })
  
  port.onmessage = (e) => {
    if (e.data.type === 'SEND_MESSAGE') {
      const message = {
        text: e.data.text,
        user: e.data.user,
        timestamp: Date.now()
      }
      
      messages.push(message)
      
      // Broadcast to all tabs
      connections.forEach(p => {
        p.postMessage({ type: 'MESSAGE', data: message })
      })
    }
  }
  
  port.start()
}
```

---

## Use Cases

### 1. Cross-Tab Notifications:

```javascript
// notification-worker.js
const subscribers = new Set()

self.onconnect = (event) => {
  const port = event.ports[0]
  subscribers.add(port)
  
  port.onmessage = (e) => {
    if (e.data.type === 'NOTIFY') {
      // Send to all other tabs
      subscribers.forEach(p => {
        if (p !== port) {
          p.postMessage({ type: 'NOTIFICATION', data: e.data.data })
        }
      })
    }
  }
  
  port.start()
}
```

### 2. Shared WebSocket Connection:

```javascript
// socket-worker.js
let socket

self.onconnect = (event) => {
  const port = event.ports[0]
  
  // Create socket on first connection
  if (!socket) {
    socket = new WebSocket('wss://example.com/socket')
    
    socket.onmessage = (e) => {
      // Broadcast to all tabs
      broadcastToAll({ type: 'SOCKET_MESSAGE', data: e.data })
    }
  }
  
  port.onmessage = (e) => {
    if (e.data.type === 'SEND') {
      socket.send(e.data.data)
    }
  }
  
  port.start()
}
```

### 3. Shared Cache:

```javascript
// cache-worker.js
const cache = new Map()

self.onconnect = (event) => {
  const port = event.ports[0]
  
  port.onmessage = async (e) => {
    const { type, key, value } = e.data
    
    switch (type) {
      case 'GET':
        const cached = cache.get(key)
        if (cached) {
          port.postMessage({ type: 'CACHE_HIT', key, value: cached })
        } else {
          port.postMessage({ type: 'CACHE_MISS', key })
        }
        break
        
      case 'SET':
        cache.set(key, value)
        // Notify all tabs of cache update
        broadcastToAll({ type: 'CACHE_UPDATED', key, value })
        break
        
      case 'DELETE':
        cache.delete(key)
        broadcastToAll({ type: 'CACHE_DELETED', key })
        break
    }
  }
  
  port.start()
}
```

---

## Comparison with Dedicated Workers

| Feature | Dedicated Worker | Shared Worker |
|---------|------------------|---------------|
| Scope | Single tab | Multiple tabs |
| Communication | `postMessage()` | `port.postMessage()` |
| Creation | `new Worker()` | `new SharedWorker()` |
| Lifecycle | Dies with page | Persists |
| Complexity | Simple | More complex |
| Use Case | Single-page tasks | Cross-tab coordination |

---

## Best Practices

### 1. Handle Multiple Connections:

```javascript
const connections = new Map()
let connectionId = 0

self.onconnect = (event) => {
  const port = event.ports[0]
  const id = connectionId++
  
  connections.set(id, port)
  
  port.onclose = () => {
    connections.delete(id)
  }
  
  port.start()
}
```

### 2. Broadcast Selectively:

```javascript
function broadcast(message, exclude = null) {
  connections.forEach((port, id) => {
    if (id !== exclude) {
      port.postMessage(message)
    }
  })
}
```

### 3. Clean Up Resources:

```javascript
self.onconnect = (event) => {
  const port = event.ports[0]
  
  port.addEventListener('close', () => {
    // Clean up resources for this connection
    cleanupConnection(port)
  })
  
  port.start()
}
```

### 4. Handle Errors:

```javascript
self.onconnect = (event) => {
  const port = event.ports[0]
  
  port.onmessageerror = (error) => {
    console.error('Message error:', error)
    port.postMessage({ error: 'Message deserialization failed' })
  }
  
  port.start()
}

self.onerror = (error) => {
  console.error('Worker error:', error)
}
```

---

## Summary

### Key Points:
- Shared across multiple tabs/windows
- Use `MessagePort` for communication
- Persist across page reloads
- More complex than dedicated workers

### When to Use:
- ✅ Cross-tab communication
- ✅ Shared WebSocket connections
- ✅ Synchronized state
- ✅ Resource pooling
- ❌ Simple single-page tasks

### Related Topics:
- Dedicated Workers
- BroadcastChannel API
- Service Workers
- MessageChannel
