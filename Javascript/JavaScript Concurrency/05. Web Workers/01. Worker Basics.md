# Worker Basics

## Table of Contents
- [What are Web Workers?](#what-are-web-workers)
- [Creating Workers](#creating-workers)
- [Communication](#communication)
- [Worker Lifecycle](#worker-lifecycle)
- [Worker Scope](#worker-scope)
- [Use Cases](#use-cases)
- [Limitations](#limitations)
- [Best Practices](#best-practices)

---

## What are Web Workers?

**Web Workers** allow JavaScript to run in background threads, separate from the main execution thread.

**Benefits:**
- Non-blocking operations
- CPU-intensive tasks won't freeze UI
- True parallelism
- Improved performance

**Types:**
- **Dedicated Workers**: Single page/script
- **Shared Workers**: Multiple pages/scripts
- **Service Workers**: Network proxy, offline support

---

## Creating Workers

### Basic Worker Creation:

**main.js:**
```javascript
const worker = new Worker('worker.js')

// Send message to worker
worker.postMessage({ type: 'start', data: [1, 2, 3] })

// Receive message from worker
worker.onmessage = (event) => {
  console.log('Result from worker:', event.data)
}

// Handle errors
worker.onerror = (error) => {
  console.error('Worker error:', error.message)
}

// Terminate worker
worker.terminate()
```

**worker.js:**
```javascript
// Listen for messages
self.onmessage = (event) => {
  const { type, data } = event.data
  
  if (type === 'start') {
    const result = processData(data)
    self.postMessage(result)
  }
}

function processData(data) {
  // CPU-intensive operation
  return data.map(x => x * 2)
}
```

### Inline Worker (Blob):

```javascript
const workerCode = `
  self.onmessage = (e) => {
    const result = e.data * 2
    self.postMessage(result)
  }
`

const blob = new Blob([workerCode], { type: 'application/javascript' })
const workerUrl = URL.createObjectURL(blob)
const worker = new Worker(workerUrl)

worker.postMessage(5)
worker.onmessage = (e) => console.log(e.data)  // 10
```

---

## Communication

### Structured Clone:

```javascript
// Main thread
worker.postMessage({
  user: { name: 'Alice', age: 30 },
  items: [1, 2, 3],
  date: new Date()
})

// Worker
self.onmessage = (e) => {
  console.log(e.data.user.name)  // 'Alice'
  console.log(e.data.items)      // [1, 2, 3]
}
```

### Transferable Objects:

```javascript
// Transfer ArrayBuffer (zero-copy)
const buffer = new ArrayBuffer(1024)
worker.postMessage({ buffer }, [buffer])
// buffer is now unusable in main thread

// Worker receives ownership
self.onmessage = (e) => {
  const buffer = e.data.buffer
  // Use buffer...
}
```

### Bi-directional Communication:

```javascript
// Main thread
const worker = new Worker('worker.js')

worker.postMessage({ action: 'process', data: [1, 2, 3] })

worker.onmessage = (e) => {
  if (e.data.type === 'progress') {
    console.log(`Progress: ${e.data.percent}%`)
  } else if (e.data.type === 'complete') {
    console.log('Result:', e.data.result)
  }
}

// Worker
self.onmessage = (e) => {
  const { action, data } = e.data
  
  if (action === 'process') {
    for (let i = 0; i < data.length; i++) {
      // Send progress updates
      self.postMessage({
        type: 'progress',
        percent: (i / data.length) * 100
      })
      
      // Process...
    }
    
    self.postMessage({ type: 'complete', result: processedData })
  }
}
```

---

## Worker Lifecycle

### Creating and Terminating:

```javascript
// Create worker
const worker = new Worker('worker.js')

// Terminate from main thread
worker.terminate()

// Close from worker thread
self.close()
```

### Error Handling:

```javascript
worker.onerror = (error) => {
  console.error('Worker error:', error.message)
  console.error('File:', error.filename)
  console.error('Line:', error.lineno)
}

worker.onmessageerror = (error) => {
  console.error('Message deserialization error:', error)
}
```

---

## Worker Scope

### Available APIs:

```javascript
// Worker scope (not window)
self.console.log('Worker started')

// Available in workers:
// - setTimeout/setInterval
// - fetch
// - IndexedDB
// - WebSockets
// - XMLHttpRequest
// - importScripts()

// NOT available:
// - DOM manipulation
// - window object
// - document object
// - parent object
```

### Import Scripts:

```javascript
// worker.js
importScripts('utils.js', 'helpers.js')

// Now use functions from imported scripts
const result = utilFunction()
```

### Fetch in Worker:

```javascript
self.onmessage = async (e) => {
  const url = e.data.url
  
  try {
    const response = await fetch(url)
    const data = await response.json()
    self.postMessage({ success: true, data })
  } catch (err) {
    self.postMessage({ success: false, error: err.message })
  }
}
```

---

## Use Cases

### 1. Heavy Computation:

```javascript
// Main
const worker = new Worker('compute.js')

worker.postMessage({ type: 'fibonacci', n: 40 })

worker.onmessage = (e) => {
  console.log('Result:', e.data)
  worker.terminate()
}

// compute.js
self.onmessage = (e) => {
  if (e.data.type === 'fibonacci') {
    const result = fibonacci(e.data.n)
    self.postMessage(result)
  }
}

function fibonacci(n) {
  if (n <= 1) return n
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```

### 2. Image Processing:

```javascript
// Main
const worker = new Worker('image-worker.js')

canvas.toBlob((blob) => {
  worker.postMessage({ image: blob })
})

worker.onmessage = (e) => {
  const processedBlob = e.data
  const img = document.createElement('img')
  img.src = URL.createObjectURL(processedBlob)
}

// image-worker.js
self.onmessage = async (e) => {
  const blob = e.data.image
  const bitmap = await createImageBitmap(blob)
  
  const canvas = new OffscreenCanvas(bitmap.width, bitmap.height)
  const ctx = canvas.getContext('2d')
  
  ctx.drawImage(bitmap, 0, 0)
  const imageData = ctx.getImageData(0, 0, bitmap.width, bitmap.height)
  
  // Apply grayscale filter
  for (let i = 0; i < imageData.data.length; i += 4) {
    const avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3
    imageData.data[i] = avg
    imageData.data[i + 1] = avg
    imageData.data[i + 2] = avg
  }
  
  ctx.putImageData(imageData, 0, 0)
  const processedBlob = await canvas.convertToBlob()
  
  self.postMessage(processedBlob)
}
```

### 3. Background Data Sync:

```javascript
// Main
const syncWorker = new Worker('sync-worker.js')

syncWorker.postMessage({ action: 'startSync', interval: 60000 })

syncWorker.onmessage = (e) => {
  console.log('Sync update:', e.data)
}

// sync-worker.js
let syncInterval

self.onmessage = async (e) => {
  if (e.data.action === 'startSync') {
    syncInterval = setInterval(async () => {
      try {
        const response = await fetch('/api/sync')
        const data = await response.json()
        self.postMessage({ success: true, data })
      } catch (err) {
        self.postMessage({ success: false, error: err.message })
      }
    }, e.data.interval)
  } else if (e.data.action === 'stopSync') {
    clearInterval(syncInterval)
  }
}
```

---

## Limitations

### Cannot Access:
- DOM (document, window)
- Parent page variables directly
- Synchronous operations in main thread

### Can Access:
- `self` (worker global scope)
- `fetch`, `XMLHttpRequest`
- `setTimeout`, `setInterval`
- `IndexedDB`, `WebSockets`
- `importScripts()`

### Performance Considerations:
- Message passing has overhead
- Not suitable for small, quick tasks
- Memory overhead per worker

---

## Best Practices

### 1. Use for CPU-Intensive Tasks:

```javascript
// ✅ Good use case
worker.postMessage({ task: 'parseCSV', data: largeCSVString })

// ❌ Bad use case (overhead > benefit)
worker.postMessage({ task: 'add', a: 5, b: 3 })
```

### 2. Transfer Large Data:

```javascript
// ✅ Transfer ArrayBuffer (zero-copy)
const buffer = new ArrayBuffer(1024 * 1024)
worker.postMessage({ buffer }, [buffer])

// ❌ Clone large data (slow)
worker.postMessage({ array: new Array(1000000) })
```

### 3. Handle Errors:

```javascript
worker.onerror = (error) => {
  console.error('Worker error:', error)
  // Restart worker or show error to user
}

// In worker
self.addEventListener('error', (error) => {
  self.postMessage({ error: error.message })
})
```

### 4. Clean Up:

```javascript
// Terminate when done
worker.onmessage = (e) => {
  processResult(e.data)
  worker.terminate()  // Free resources
}
```

### 5. Use Worker Pools:

```javascript
class WorkerPool {
  constructor(workerScript, poolSize = 4) {
    this.workers = []
    this.queue = []
    
    for (let i = 0; i < poolSize; i++) {
      const worker = new Worker(workerScript)
      worker.onmessage = (e) => this.handleResult(i, e.data)
      this.workers.push({ worker, busy: false })
    }
  }
  
  execute(data) {
    return new Promise((resolve) => {
      const availableWorker = this.workers.find(w => !w.busy)
      
      if (availableWorker) {
        availableWorker.busy = true
        availableWorker.resolve = resolve
        availableWorker.worker.postMessage(data)
      } else {
        this.queue.push({ data, resolve })
      }
    })
  }
  
  handleResult(index, result) {
    const workerInfo = this.workers[index]
    workerInfo.resolve(result)
    workerInfo.busy = false
    
    // Process queue
    if (this.queue.length > 0) {
      const { data, resolve } = this.queue.shift()
      workerInfo.busy = true
      workerInfo.resolve = resolve
      workerInfo.worker.postMessage(data)
    }
  }
}

// Usage
const pool = new WorkerPool('worker.js', 4)
const results = await Promise.all(
  tasks.map(task => pool.execute(task))
)
```

---

## Summary

### Key Points:
- Workers run in separate threads
- Use for CPU-intensive tasks
- Communication via message passing
- Cannot access DOM
- Terminate when done

### When to Use:
- ✅ Heavy computations
- ✅ Image/video processing
- ✅ Large data parsing
- ✅ Background sync
- ❌ Simple calculations
- ❌ DOM manipulation

### Related Topics:
- Shared Workers
- Service Workers
- OffscreenCanvas
- Transferable objects
