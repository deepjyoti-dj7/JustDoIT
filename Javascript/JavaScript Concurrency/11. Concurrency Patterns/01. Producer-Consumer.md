# Producer-Consumer Pattern

## Table of Contents
- [What is Producer-Consumer?](#what-is-producer-consumer)
- [Basic Implementation](#basic-implementation)
- [Blocking Queue](#blocking-queue)
- [Multiple Producers/Consumers](#multiple-producersconsumers)
- [Backpressure Handling](#backpressure-handling)
- [Priority Queues](#priority-queues)
- [Real-World Examples](#real-world-examples)

---

## What is Producer-Consumer?

The **Producer-Consumer** pattern decouples data producers from data consumers using a queue.

**Components:**
- **Producer**: Creates data and adds to queue
- **Queue**: Buffer between producers and consumers
- **Consumer**: Takes data from queue and processes it

**Benefits:**
- Decoupling of components
- Load balancing
- Buffering for varying rates
- Scalability

```
Producer → [Queue] → Consumer
Producer → [Queue] → Consumer
Producer → [Queue] → Consumer
```

---

## Basic Implementation

### Simple Queue:

```javascript
class SimpleQueue {
  constructor() {
    this.items = []
    this.waiting = []
  }
  
  async enqueue(item) {
    this.items.push(item)
    
    // Notify waiting consumers
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift()
      resolve(this.items.shift())
    }
  }
  
  async dequeue() {
    if (this.items.length > 0) {
      return this.items.shift()
    }
    
    // Wait for item
    return new Promise((resolve) => {
      this.waiting.push(resolve)
    })
  }
  
  get size() {
    return this.items.length
  }
}

// Usage
const queue = new SimpleQueue()

// Producer
async function producer() {
  for (let i = 0; i < 10; i++) {
    await queue.enqueue({ id: i, data: `Item ${i}` })
    console.log(`Produced: ${i}`)
    await sleep(100)
  }
}

// Consumer
async function consumer() {
  while (true) {
    const item = await queue.dequeue()
    console.log(`Consumed: ${item.id}`)
    await processItem(item)
  }
}

producer()
consumer()
```

---

## Blocking Queue

### Bounded Queue with Blocking:

```javascript
class BlockingQueue {
  constructor(capacity = Infinity) {
    this.capacity = capacity
    this.items = []
    this.waitingPut = []
    this.waitingGet = []
  }
  
  async put(item) {
    // Wait if queue is full
    while (this.items.length >= this.capacity) {
      await new Promise(resolve => this.waitingPut.push(resolve))
    }
    
    this.items.push(item)
    
    // Notify waiting consumers
    if (this.waitingGet.length > 0) {
      const resolve = this.waitingGet.shift()
      resolve()
    }
  }
  
  async get() {
    // Wait if queue is empty
    while (this.items.length === 0) {
      await new Promise(resolve => this.waitingGet.push(resolve))
    }
    
    const item = this.items.shift()
    
    // Notify waiting producers
    if (this.waitingPut.length > 0) {
      const resolve = this.waitingPut.shift()
      resolve()
    }
    
    return item
  }
  
  async tryPut(item, timeout = 0) {
    const timer = timeout > 0 ? setTimeout(() => {
      const index = this.waitingPut.indexOf(resolve)
      if (index > -1) this.waitingPut.splice(index, 1)
    }, timeout) : null
    
    try {
      await this.put(item)
      if (timer) clearTimeout(timer)
      return true
    } catch {
      return false
    }
  }
  
  async tryGet(timeout = 0) {
    const timer = timeout > 0 ? setTimeout(() => {
      const index = this.waitingGet.indexOf(resolve)
      if (index > -1) this.waitingGet.splice(index, 1)
    }, timeout) : null
    
    try {
      const item = await this.get()
      if (timer) clearTimeout(timer)
      return item
    } catch {
      return null
    }
  }
  
  get size() {
    return this.items.length
  }
  
  get isFull() {
    return this.items.length >= this.capacity
  }
  
  get isEmpty() {
    return this.items.length === 0
  }
}

// Usage
const queue = new BlockingQueue(5)  // Max 5 items

async function fastProducer() {
  for (let i = 0; i < 100; i++) {
    await queue.put({ id: i })
    console.log(`Produced ${i}, queue size: ${queue.size}`)
  }
}

async function slowConsumer() {
  for (let i = 0; i < 100; i++) {
    const item = await queue.get()
    console.log(`Consumed ${item.id}`)
    await sleep(50)  // Slow processing
  }
}
```

---

## Multiple Producers/Consumers

### Worker Pool Pattern:

```javascript
class WorkerPool {
  constructor(numConsumers = 4) {
    this.queue = new BlockingQueue(100)
    this.consumers = []
    this.running = false
    
    for (let i = 0; i < numConsumers; i++) {
      this.consumers.push(this.createConsumer(i))
    }
  }
  
  createConsumer(id) {
    return async () => {
      console.log(`Consumer ${id} started`)
      
      while (this.running) {
        try {
          const item = await this.queue.get()
          await this.processItem(item, id)
        } catch (error) {
          console.error(`Consumer ${id} error:`, error)
        }
      }
      
      console.log(`Consumer ${id} stopped`)
    }
  }
  
  async processItem(item, consumerId) {
    console.log(`Consumer ${consumerId} processing:`, item.id)
    // Simulate work
    await sleep(Math.random() * 1000)
  }
  
  start() {
    this.running = true
    this.consumers.forEach(consumer => consumer())
  }
  
  stop() {
    this.running = false
  }
  
  async produce(item) {
    await this.queue.put(item)
  }
}

// Usage
const pool = new WorkerPool(4)
pool.start()

// Multiple producers
async function producer1() {
  for (let i = 0; i < 50; i++) {
    await pool.produce({ id: `P1-${i}`, data: i })
  }
}

async function producer2() {
  for (let i = 0; i < 50; i++) {
    await pool.produce({ id: `P2-${i}`, data: i })
  }
}

Promise.all([producer1(), producer2()])
```

---

## Backpressure Handling

### Backpressure Strategy:

```javascript
class BackpressureQueue {
  constructor(capacity, onBackpressure) {
    this.capacity = capacity
    this.queue = []
    this.onBackpressure = onBackpressure || (() => {})
    this.producerPaused = false
  }
  
  async produce(item) {
    // Check capacity
    if (this.queue.length >= this.capacity) {
      this.producerPaused = true
      this.onBackpressure('slow_down')
      
      // Wait for space
      while (this.queue.length >= this.capacity * 0.7) {
        await sleep(10)
      }
      
      this.producerPaused = false
      this.onBackpressure('resume')
    }
    
    this.queue.push(item)
  }
  
  async consume() {
    while (this.queue.length === 0) {
      await sleep(10)
    }
    return this.queue.shift()
  }
}

// Usage
const queue = new BackpressureQueue(100, (signal) => {
  if (signal === 'slow_down') {
    console.log('⚠️ Queue full, slowing production')
  } else {
    console.log('✅ Queue drained, resuming production')
  }
})
```

### Adaptive Rate Control:

```javascript
class AdaptiveProducer {
  constructor(queue, initialRate = 100) {
    this.queue = queue
    this.rate = initialRate  // Items per second
    this.minRate = 10
    this.maxRate = 1000
  }
  
  async produce(data) {
    for (const item of data) {
      await this.queue.put(item)
      
      // Adjust rate based on queue size
      const utilization = this.queue.size / this.queue.capacity
      
      if (utilization > 0.8) {
        this.rate = Math.max(this.minRate, this.rate * 0.9)
      } else if (utilization < 0.2) {
        this.rate = Math.min(this.maxRate, this.rate * 1.1)
      }
      
      await sleep(1000 / this.rate)
    }
  }
}
```

---

## Priority Queues

### Priority-Based Processing:

```javascript
class PriorityQueue {
  constructor() {
    this.queues = {
      high: [],
      medium: [],
      low: []
    }
    this.waiting = []
  }
  
  async enqueue(item, priority = 'medium') {
    if (!this.queues[priority]) {
      throw new Error(`Invalid priority: ${priority}`)
    }
    
    this.queues[priority].push(item)
    
    // Notify waiting consumers
    if (this.waiting.length > 0) {
      const resolve = this.waiting.shift()
      resolve()
    }
  }
  
  async dequeue() {
    // Try high priority first
    for (const priority of ['high', 'medium', 'low']) {
      if (this.queues[priority].length > 0) {
        return this.queues[priority].shift()
      }
    }
    
    // Wait for item
    await new Promise(resolve => this.waiting.push(resolve))
    return this.dequeue()
  }
  
  get size() {
    return Object.values(this.queues).reduce((sum, q) => sum + q.length, 0)
  }
}

// Usage
const priorityQueue = new PriorityQueue()

// Producer with priorities
async function producer() {
  await priorityQueue.enqueue({ task: 'urgent' }, 'high')
  await priorityQueue.enqueue({ task: 'normal' }, 'medium')
  await priorityQueue.enqueue({ task: 'background' }, 'low')
}

// Consumer (always gets highest priority items first)
async function consumer() {
  while (true) {
    const item = await priorityQueue.dequeue()
    console.log('Processing:', item)
  }
}
```

---

## Real-World Examples

### 1. Log Processing System:

```javascript
class LogProcessor {
  constructor() {
    this.queue = new BlockingQueue(1000)
    this.running = false
  }
  
  start() {
    this.running = true
    this.processLogs()
  }
  
  async log(level, message) {
    await this.queue.put({
      timestamp: Date.now(),
      level,
      message
    })
  }
  
  async processLogs() {
    while (this.running) {
      const log = await this.queue.get()
      
      // Write to file, send to server, etc.
      await this.writeLog(log)
    }
  }
  
  async writeLog(log) {
    console.log(`[${log.level}] ${log.message}`)
    // Actually write to file/database
  }
}

const logger = new LogProcessor()
logger.start()

// Multiple components logging
logger.log('INFO', 'Application started')
logger.log('ERROR', 'Connection failed')
```

### 2. Image Processing Pipeline:

```javascript
class ImagePipeline {
  constructor() {
    this.uploadQueue = new BlockingQueue(10)
    this.processQueue = new BlockingQueue(10)
    this.outputQueue = new BlockingQueue(10)
    
    this.startWorkers()
  }
  
  startWorkers() {
    // Processing workers
    for (let i = 0; i < 4; i++) {
      this.processingWorker()
    }
    
    // Upload workers
    for (let i = 0; i < 2; i++) {
      this.uploadWorker()
    }
  }
  
  async processingWorker() {
    while (true) {
      const image = await this.uploadQueue.get()
      const processed = await this.processImage(image)
      await this.processQueue.put(processed)
    }
  }
  
  async uploadWorker() {
    while (true) {
      const image = await this.processQueue.get()
      await this.uploadImage(image)
      await this.outputQueue.put(image)
    }
  }
  
  async addImage(image) {
    await this.uploadQueue.put(image)
  }
  
  async processImage(image) {
    // Resize, filter, etc.
    return image
  }
  
  async uploadImage(image) {
    // Upload to S3, CDN, etc.
  }
}
```

### 3. API Request Queue:

```javascript
class RequestQueue {
  constructor(rateLimit = 10) {
    this.queue = new BlockingQueue(100)
    this.rateLimit = rateLimit
    this.processing = false
  }
  
  async request(url, options) {
    return new Promise((resolve, reject) => {
      this.queue.put({ url, options, resolve, reject })
    })
  }
  
  start() {
    if (this.processing) return
    this.processing = true
    this.processRequests()
  }
  
  async processRequests() {
    while (this.processing) {
      const requests = []
      
      // Get batch of requests
      for (let i = 0; i < this.rateLimit && this.queue.size > 0; i++) {
        requests.push(await this.queue.get())
      }
      
      // Process batch
      await Promise.all(requests.map(async (req) => {
        try {
          const response = await fetch(req.url, req.options)
          req.resolve(response)
        } catch (error) {
          req.reject(error)
        }
      }))
      
      // Wait before next batch
      await sleep(1000)
    }
  }
}

const apiQueue = new RequestQueue(10)
apiQueue.start()

// Use it
const response = await apiQueue.request('/api/data')
```

---

## Summary

### Key Concepts:
- Producers create data
- Consumers process data
- Queue decouples them
- Backpressure prevents overload

### When to Use:
- ✅ Different production/consumption rates
- ✅ Need buffering
- ✅ Decoupling components
- ✅ Load balancing
- ❌ Real-time, no delays tolerated
- ❌ Strict ordering required

### Best Practices:
- Set appropriate queue capacity
- Handle backpressure
- Monitor queue size
- Use priorities when needed
- Graceful shutdown

### Related Topics:
- Task queues
- Message queues
- Async patterns
- Backpressure handling
