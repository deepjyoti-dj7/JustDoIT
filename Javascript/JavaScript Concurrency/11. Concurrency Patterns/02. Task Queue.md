# Task Queue Pattern

## Table of Contents
- [What is a Task Queue?](#what-is-a-task-queue)
- [Basic Implementation](#basic-implementation)
- [Priority Task Queue](#priority-task-queue)
- [Delayed Tasks](#delayed-tasks)
- [Recurring Tasks](#recurring-tasks)
- [Worker Management](#worker-management)
- [Real-World Examples](#real-world-examples)

---

## What is a Task Queue?

A **Task Queue** manages execution of asynchronous tasks with controlled concurrency.

**Features:**
- Sequential or concurrent execution
- Priority handling
- Delayed execution
- Retry logic
- Concurrency limiting

```javascript
const queue = new TaskQueue({ concurrency: 3 })

queue.add(() => fetchData())
queue.add(() => processImage())
queue.add(() => sendEmail())
```

---

## Basic Implementation

### Simple Task Queue:

```javascript
class TaskQueue {
  constructor(options = {}) {
    this.concurrency = options.concurrency || 1
    this.tasks = []
    this.running = 0
    this.paused = false
  }
  
  async add(fn, options = {}) {
    return new Promise((resolve, reject) => {
      const task = {
        fn,
        resolve,
        reject,
        priority: options.priority || 0,
        retries: options.retries || 0,
        maxRetries: options.maxRetries || 0
      }
      
      this.tasks.push(task)
      this.tasks.sort((a, b) => b.priority - a.priority)
      
      this.process()
    })
  }
  
  async process() {
    if (this.paused || this.running >= this.concurrency || this.tasks.length === 0) {
      return
    }
    
    this.running++
    const task = this.tasks.shift()
    
    try {
      const result = await task.fn()
      task.resolve(result)
    } catch (error) {
      if (task.retries < task.maxRetries) {
        task.retries++
        this.tasks.unshift(task)
      } else {
        task.reject(error)
      }
    } finally {
      this.running--
      this.process()
    }
  }
  
  pause() {
    this.paused = true
  }
  
  resume() {
    this.paused = false
    this.process()
  }
  
  clear() {
    this.tasks = []
  }
  
  get size() {
    return this.tasks.length
  }
  
  get pending() {
    return this.running
  }
}

// Usage
const queue = new TaskQueue({ concurrency: 3 })

const result = await queue.add(async () => {
  const data = await fetch('/api/data')
  return data.json()
}, { priority: 1, maxRetries: 3 })
```

---

## Priority Task Queue

### Priority Levels:

```javascript
class PriorityTaskQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency
    this.queues = {
      high: [],
      normal: [],
      low: []
    }
    this.running = 0
  }
  
  add(fn, priority = 'normal') {
    return new Promise((resolve, reject) => {
      const task = { fn, resolve, reject }
      this.queues[priority].push(task)
      this.process()
    })
  }
  
  async process() {
    if (this.running >= this.concurrency) return
    
    // Try priorities in order
    const task = this.queues.high.shift() ||
                 this.queues.normal.shift() ||
                 this.queues.low.shift()
    
    if (!task) return
    
    this.running++
    
    try {
      const result = await task.fn()
      task.resolve(result)
    } catch (error) {
      task.reject(error)
    } finally {
      this.running--
      this.process()
    }
  }
  
  get size() {
    return Object.values(this.queues).reduce((sum, q) => sum + q.length, 0)
  }
}

// Usage
const queue = new PriorityTaskQueue(2)

queue.add(() => urgentTask(), 'high')
queue.add(() => normalTask(), 'normal')
queue.add(() => backgroundTask(), 'low')
```

---

## Delayed Tasks

### Scheduled Execution:

```javascript
class DelayedTaskQueue {
  constructor() {
    this.tasks = []
    this.timers = new Map()
  }
  
  schedule(fn, delay) {
    return new Promise((resolve, reject) => {
      const executeAt = Date.now() + delay
      const task = { fn, resolve, reject, executeAt }
      
      this.tasks.push(task)
      this.tasks.sort((a, b) => a.executeAt - b.executeAt)
      
      this.scheduleNext()
    })
  }
  
  scheduleNext() {
    // Clear existing timer
    if (this.nextTimer) {
      clearTimeout(this.nextTimer)
    }
    
    if (this.tasks.length === 0) return
    
    const nextTask = this.tasks[0]
    const delay = Math.max(0, nextTask.executeAt - Date.now())
    
    this.nextTimer = setTimeout(async () => {
      this.tasks.shift()
      
      try {
        const result = await nextTask.fn()
        nextTask.resolve(result)
      } catch (error) {
        nextTask.reject(error)
      }
      
      this.scheduleNext()
    }, delay)
  }
  
  cancel(task) {
    const index = this.tasks.indexOf(task)
    if (index > -1) {
      this.tasks.splice(index, 1)
      task.reject(new Error('Task cancelled'))
      
      if (index === 0) {
        this.scheduleNext()
      }
    }
  }
}

// Usage
const scheduler = new DelayedTaskQueue()

scheduler.schedule(() => console.log('Execute in 5s'), 5000)
scheduler.schedule(() => console.log('Execute in 10s'), 10000)
```

---

## Recurring Tasks

### Interval Tasks:

```javascript
class RecurringTaskQueue {
  constructor() {
    this.tasks = new Map()
    this.nextId = 0
  }
  
  addRecurring(fn, interval, options = {}) {
    const id = this.nextId++
    const immediate = options.immediate !== false
    
    const task = {
      id,
      fn,
      interval,
      running: false,
      stopped: false
    }
    
    this.tasks.set(id, task)
    
    if (immediate) {
      this.execute(task)
    } else {
      this.schedule(task)
    }
    
    return id
  }
  
  async execute(task) {
    if (task.stopped || task.running) return
    
    task.running = true
    
    try {
      await task.fn()
    } catch (error) {
      console.error('Recurring task error:', error)
    } finally {
      task.running = false
      
      if (!task.stopped) {
        this.schedule(task)
      }
    }
  }
  
  schedule(task) {
    task.timer = setTimeout(() => {
      this.execute(task)
    }, task.interval)
  }
  
  remove(id) {
    const task = this.tasks.get(id)
    if (task) {
      task.stopped = true
      if (task.timer) {
        clearTimeout(task.timer)
      }
      this.tasks.delete(id)
    }
  }
  
  clear() {
    for (const task of this.tasks.values()) {
      this.remove(task.id)
    }
  }
}

// Usage
const recurring = new RecurringTaskQueue()

const id = recurring.addRecurring(async () => {
  await checkForUpdates()
}, 60000, { immediate: true })

// Later: stop
recurring.remove(id)
```

---

## Worker Management

### Worker Pool with Queue:

```javascript
class WorkerTaskQueue {
  constructor(workerScript, numWorkers = 4) {
    this.workers = []
    this.tasks = []
    
    for (let i = 0; i < numWorkers; i++) {
      const worker = new Worker(workerScript)
      const workerInfo = { worker, busy: false, currentTask: null }
      
      worker.onmessage = (e) => {
        if (workerInfo.currentTask) {
          if (e.data.error) {
            workerInfo.currentTask.reject(new Error(e.data.error))
          } else {
            workerInfo.currentTask.resolve(e.data.result)
          }
          workerInfo.currentTask = null
        }
        
        workerInfo.busy = false
        this.processNext()
      }
      
      worker.onerror = (error) => {
        if (workerInfo.currentTask) {
          workerInfo.currentTask.reject(error)
          workerInfo.currentTask = null
        }
        workerInfo.busy = false
        this.processNext()
      }
      
      this.workers.push(workerInfo)
    }
  }
  
  add(data, priority = 0) {
    return new Promise((resolve, reject) => {
      const task = { data, priority, resolve, reject }
      this.tasks.push(task)
      this.tasks.sort((a, b) => b.priority - a.priority)
      this.processNext()
    })
  }
  
  processNext() {
    if (this.tasks.length === 0) return
    
    const availableWorker = this.workers.find(w => !w.busy)
    if (!availableWorker) return
    
    const task = this.tasks.shift()
    availableWorker.busy = true
    availableWorker.currentTask = task
    availableWorker.worker.postMessage(task.data)
  }
  
  terminate() {
    this.workers.forEach(w => w.worker.terminate())
  }
  
  get pending() {
    return this.tasks.length
  }
  
  get active() {
    return this.workers.filter(w => w.busy).length
  }
}

// Usage
const workerQueue = new WorkerTaskQueue('compute-worker.js', 4)

const result = await workerQueue.add({ 
  operation: 'fibonacci', 
  value: 40 
}, 1)
```

---

## Real-World Examples

### 1. Email Queue:

```javascript
class EmailQueue {
  constructor() {
    this.queue = new TaskQueue({ concurrency: 5 })
  }
  
  async sendEmail(to, subject, body) {
    return this.queue.add(async () => {
      console.log(`Sending email to ${to}`)
      
      const response = await fetch('/api/send-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ to, subject, body })
      })
      
      if (!response.ok) {
        throw new Error('Email send failed')
      }
      
      return response.json()
    }, { maxRetries: 3 })
  }
  
  async sendBulk(recipients, subject, body) {
    return Promise.all(
      recipients.map(to => this.sendEmail(to, subject, body))
    )
  }
}

const emailQueue = new EmailQueue()
await emailQueue.sendBulk(['user1@example.com', 'user2@example.com'], 
                          'Newsletter', 'Hello!')
```

### 2. API Rate Limiter:

```javascript
class RateLimitedQueue {
  constructor(requestsPerSecond = 10) {
    this.queue = []
    this.requestsPerSecond = requestsPerSecond
    this.lastReset = Date.now()
    this.requestsThisSecond = 0
    
    this.process()
  }
  
  async request(fn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, resolve, reject })
    })
  }
  
  async process() {
    setInterval(async () => {
      const now = Date.now()
      
      if (now - this.lastReset >= 1000) {
        this.lastReset = now
        this.requestsThisSecond = 0
      }
      
      while (this.requestsThisSecond < this.requestsPerSecond && this.queue.length > 0) {
        const task = this.queue.shift()
        this.requestsThisSecond++
        
        try {
          const result = await task.fn()
          task.resolve(result)
        } catch (error) {
          task.reject(error)
        }
      }
    }, 100)
  }
}

const apiQueue = new RateLimitedQueue(10)

const data = await apiQueue.request(() => fetch('/api/data'))
```

### 3. Background Jobs:

```javascript
class BackgroundJobQueue {
  constructor() {
    this.immediate = new PriorityTaskQueue(2)
    this.scheduled = new DelayedTaskQueue()
    this.recurring = new RecurringTaskQueue()
  }
  
  async runNow(job, priority = 'normal') {
    return this.immediate.add(job, priority)
  }
  
  async runLater(job, delay) {
    return this.scheduled.schedule(job, delay)
  }
  
  runPeriodically(job, interval) {
    return this.recurring.addRecurring(job, interval)
  }
}

const jobs = new BackgroundJobQueue()

// Immediate
await jobs.runNow(() => cleanupOldFiles(), 'low')

// Delayed
await jobs.runLater(() => sendReminder(), 3600000)  // 1 hour

// Recurring
jobs.runPeriodically(() => syncData(), 300000)  // 5 minutes
```

---

## Summary

### Key Concepts:
- Controlled task execution
- Priority handling
- Delayed and recurring tasks
- Worker pool integration

### When to Use:
- ✅ Limit concurrency
- ✅ Prioritize tasks
- ✅ Schedule tasks
- ✅ Retry on failure
- ❌ Simple sequential operations

### Best Practices:
- Set appropriate concurrency
- Handle errors and retries
- Use priorities wisely
- Monitor queue size
- Clean up resources

### Related Topics:
- Producer-consumer
- Worker pools
- Rate limiting
- Job scheduling
