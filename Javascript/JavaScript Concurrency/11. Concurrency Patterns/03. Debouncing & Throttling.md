# Debouncing & Throttling

## Table of Contents
- [What are Debouncing and Throttling?](#what-are-debouncing-and-throttling)
- [Debouncing](#debouncing)
- [Throttling](#throttling)
- [Comparison](#comparison)
- [Advanced Patterns](#advanced-patterns)
- [React Integration](#react-integration)
- [Real-World Examples](#real-world-examples)

---

## What are Debouncing and Throttling?

**Rate limiting** techniques to control how often a function executes.

**Debouncing**: Delays execution until after a quiet period  
**Throttling**: Limits execution to once per time interval

```javascript
// Without rate limiting - fires constantly
input.addEventListener('input', handleSearch)  // 100+ calls/second

// With debouncing - fires once after typing stops
input.addEventListener('input', debounce(handleSearch, 300))  // 1 call

// With throttling - fires at most once per interval
window.addEventListener('scroll', throttle(handleScroll, 100))  // 10 calls/second
```

---

## Debouncing

### Basic Debounce:

```javascript
function debounce(func, delay) {
  let timeoutId
  
  return function (...args) {
    clearTimeout(timeoutId)
    
    timeoutId = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
}

// Usage
const debouncedSearch = debounce((query) => {
  console.log('Searching for:', query)
}, 300)

debouncedSearch('h')      // Cancelled
debouncedSearch('he')     // Cancelled
debouncedSearch('hel')    // Cancelled
debouncedSearch('hell')   // Cancelled
debouncedSearch('hello')  // Executes after 300ms
```

### Debounce with Leading Edge:

```javascript
function debounce(func, delay, immediate = false) {
  let timeoutId
  
  return function (...args) {
    const callNow = immediate && !timeoutId
    
    clearTimeout(timeoutId)
    
    timeoutId = setTimeout(() => {
      timeoutId = null
      if (!immediate) {
        func.apply(this, args)
      }
    }, delay)
    
    if (callNow) {
      func.apply(this, args)
    }
  }
}

// Usage: Execute immediately, then wait
const debouncedClick = debounce(handleClick, 1000, true)
button.addEventListener('click', debouncedClick)
// First click: executes immediately
// Subsequent clicks within 1s: ignored
// After 1s: ready for next immediate execution
```

### Async Debounce:

```javascript
function asyncDebounce(func, delay) {
  let timeoutId
  let lastPromise
  
  return function (...args) {
    return new Promise((resolve, reject) => {
      clearTimeout(timeoutId)
      
      timeoutId = setTimeout(async () => {
        try {
          const result = await func.apply(this, args)
          resolve(result)
        } catch (error) {
          reject(error)
        }
      }, delay)
    })
  }
}

// Usage
const debouncedFetch = asyncDebounce(async (query) => {
  const response = await fetch(`/api/search?q=${query}`)
  return response.json()
}, 300)

try {
  const results = await debouncedFetch('hello')
  console.log(results)
} catch (error) {
  console.error(error)
}
```

---

## Throttling

### Basic Throttle:

```javascript
function throttle(func, limit) {
  let inThrottle
  
  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args)
      inThrottle = true
      
      setTimeout(() => {
        inThrottle = false
      }, limit)
    }
  }
}

// Usage
const throttledScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY)
}, 100)

window.addEventListener('scroll', throttledScroll)
// Executes at most once every 100ms
```

### Throttle with Leading and Trailing:

```javascript
function throttle(func, limit, options = {}) {
  let timeout
  let previous = 0
  const { leading = true, trailing = true } = options
  
  return function (...args) {
    const now = Date.now()
    
    if (!previous && !leading) {
      previous = now
    }
    
    const remaining = limit - (now - previous)
    
    if (remaining <= 0 || remaining > limit) {
      if (timeout) {
        clearTimeout(timeout)
        timeout = null
      }
      
      previous = now
      func.apply(this, args)
    } else if (!timeout && trailing) {
      timeout = setTimeout(() => {
        previous = leading ? Date.now() : 0
        timeout = null
        func.apply(this, args)
      }, remaining)
    }
  }
}

// Usage
const throttled = throttle(handleEvent, 1000, {
  leading: true,   // Execute on first call
  trailing: true   // Execute after throttle period
})
```

### Async Throttle:

```javascript
function asyncThrottle(func, limit) {
  let inThrottle = false
  let lastResult
  
  return async function (...args) {
    if (!inThrottle) {
      inThrottle = true
      
      try {
        lastResult = await func.apply(this, args)
      } finally {
        setTimeout(() => {
          inThrottle = false
        }, limit)
      }
    }
    
    return lastResult
  }
}

// Usage
const throttledAPI = asyncThrottle(async (id) => {
  const response = await fetch(`/api/data/${id}`)
  return response.json()
}, 1000)

const data = await throttledAPI(123)
```

---

## Comparison

### Visual Difference:

```
Events:     | | | | | | | | | | | | | |
                  Time →

Throttle:   |       |       |       |
            (every 100ms)

Debounce:                           |
            (300ms after last event)
```

### When to Use Each:

```javascript
// ✅ Debounce: Wait for completion
// - Search input
// - Form validation
// - Auto-save
// - Window resize
const search = debounce(handleSearch, 300)
const validate = debounce(validateForm, 500)
const save = debounce(autoSave, 1000)

// ✅ Throttle: Regular intervals
// - Scroll events
// - Mouse move
// - Animation frame updates
// - Progress tracking
const scroll = throttle(handleScroll, 100)
const mouseMove = throttle(handleMouseMove, 16)  // ~60fps
const progress = throttle(updateProgress, 200)
```

---

## Advanced Patterns

### Debounce with Max Wait:

```javascript
function debounceWithMaxWait(func, delay, maxWait) {
  let timeoutId
  let lastInvokeTime = Date.now()
  
  return function (...args) {
    const now = Date.now()
    const timeSinceLastInvoke = now - lastInvokeTime
    
    clearTimeout(timeoutId)
    
    if (timeSinceLastInvoke >= maxWait) {
      lastInvokeTime = now
      func.apply(this, args)
    } else {
      timeoutId = setTimeout(() => {
        lastInvokeTime = Date.now()
        func.apply(this, args)
      }, delay)
    }
  }
}

// Usage: Debounce normally, but force execution after 3 seconds
const debouncedSave = debounceWithMaxWait(saveData, 500, 3000)
```

### Cancellable Debounce:

```javascript
function debounce(func, delay) {
  let timeoutId
  
  const debounced = function (...args) {
    clearTimeout(timeoutId)
    
    timeoutId = setTimeout(() => {
      func.apply(this, args)
    }, delay)
  }
  
  debounced.cancel = () => {
    clearTimeout(timeoutId)
  }
  
  debounced.flush = function (...args) {
    clearTimeout(timeoutId)
    func.apply(this, args)
  }
  
  return debounced
}

// Usage
const debouncedSearch = debounce(search, 300)

debouncedSearch('hello')
debouncedSearch.cancel()   // Cancel pending execution
debouncedSearch.flush()    // Execute immediately
```

---

## React Integration

### useDebounce Hook:

```javascript
import { useEffect, useState } from 'react'

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value)
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])
  
  return debouncedValue
}

// Usage
function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('')
  const debouncedSearchTerm = useDebounce(searchTerm, 300)
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      // API call
      fetch(`/api/search?q=${debouncedSearchTerm}`)
        .then(res => res.json())
        .then(setResults)
    }
  }, [debouncedSearchTerm])
  
  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  )
}
```

### useThrottle Hook:

```javascript
import { useRef, useEffect } from 'react'

function useThrottle(callback, delay) {
  const inThrottle = useRef(false)
  
  return (...args) => {
    if (!inThrottle.current) {
      callback(...args)
      inThrottle.current = true
      
      setTimeout(() => {
        inThrottle.current = false
      }, delay)
    }
  }
}

// Usage
function ScrollComponent() {
  const handleScroll = useThrottle(() => {
    console.log('Scroll Y:', window.scrollY)
  }, 100)
  
  useEffect(() => {
    window.addEventListener('scroll', handleScroll)
    return () => window.removeEventListener('scroll', handleScroll)
  }, [])
  
  return <div>Scroll me!</div>
}
```

---

## Real-World Examples

### 1. Search with Autocomplete:

```javascript
const searchInput = document.getElementById('search')
const resultsDiv = document.getElementById('results')

const performSearch = async (query) => {
  if (query.length < 2) {
    resultsDiv.innerHTML = ''
    return
  }
  
  const response = await fetch(`/api/autocomplete?q=${query}`)
  const results = await response.json()
  
  resultsDiv.innerHTML = results.map(r =>
    `<div class="result">${r.name}</div>`
  ).join('')
}

const debouncedSearch = debounce(performSearch, 300)

searchInput.addEventListener('input', (e) => {
  debouncedSearch(e.target.value)
})
```

### 2. Infinite Scroll:

```javascript
const loadMore = async () => {
  const response = await fetch(`/api/posts?page=${currentPage}`)
  const posts = await response.json()
  appendPosts(posts)
  currentPage++
}

const throttledLoadMore = throttle(loadMore, 1000)

window.addEventListener('scroll', () => {
  const { scrollTop, scrollHeight, clientHeight } = document.documentElement
  
  if (scrollTop + clientHeight >= scrollHeight - 100) {
    throttledLoadMore()
  }
})
```

### 3. Form Auto-Save:

```javascript
const form = document.getElementById('editor-form')

const saveForm = async (formData) => {
  await fetch('/api/save-draft', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(formData)
  })
  
  showNotification('Draft saved')
}

const debouncedSave = debounce(saveForm, 2000)

form.addEventListener('input', () => {
  const formData = new FormData(form)
  debouncedSave(Object.fromEntries(formData))
})
```

---

## Summary

### Key Differences:

| Feature | Debouncing | Throttling |
|---------|-----------|-----------|
| **Execution** | After quiet period | Regular intervals |
| **Use Case** | Wait for completion | Limit frequency |
| **Example** | Search input | Scroll handler |

### Best Practices:
- Choose appropriate delays (100-500ms)
- Cancel on unmount (React)
- Use leading/trailing options wisely
- Test with real user interactions
- Monitor performance impact

### Common Delays:
- Input: 200-500ms
- Resize: 150-300ms
- Scroll: 50-100ms
- Autocomplete: 300-500ms
- Auto-save: 1000-3000ms

### Related Topics:
- Rate limiting
- Event handling
- Performance optimization
- User experience
