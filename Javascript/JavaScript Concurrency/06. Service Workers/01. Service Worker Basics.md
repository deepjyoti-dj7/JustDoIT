# Service Worker Basics

## Table of Contents
- [What are Service Workers?](#what-are-service-workers)
- [Registration](#registration)
- [Lifecycle](#lifecycle)
- [Events](#events)
- [Scope](#scope)
- [Caching Basics](#caching-basics)
- [Offline Support](#offline-support)
- [Best Practices](#best-practices)

---

## What are Service Workers?

**Service Workers** are scripts that run in the background, separate from web pages, enabling features like offline support, push notifications, and background sync.

**Key Features:**
- Network proxy (intercept requests)
- Background processing
- Offline-first capabilities
- Push notifications
- Background sync

**Requirements:**
- HTTPS (or localhost for development)
- Separate JavaScript file
- Browser support (not IE)

---

## Registration

### Basic Registration:

```javascript
// main.js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(registration => {
      console.log('SW registered:', registration.scope)
    })
    .catch(error => {
      console.error('SW registration failed:', error)
    })
}
```

### With Options:

```javascript
navigator.serviceWorker.register('/sw.js', {
  scope: '/app/'  // Only control /app/ paths
})
```

### Check Status:

```javascript
navigator.serviceWorker.ready.then(registration => {
  console.log('SW is ready:', registration)
})

// Check if SW is controlling the page
if (navigator.serviceWorker.controller) {
  console.log('Page is controlled by SW')
}
```

### Update Service Worker:

```javascript
registration.update()  // Force check for updates

// Auto-update on page load
navigator.serviceWorker.register('/sw.js').then(reg => {
  setInterval(() => reg.update(), 60 * 60 * 1000)  // Every hour
})
```

---

## Lifecycle

### Lifecycle Stages:

1. **Install**: Download and cache resources
2. **Activate**: Clean up old caches
3. **Fetch**: Intercept network requests

```javascript
// sw.js

// INSTALL
self.addEventListener('install', (event) => {
  console.log('SW installing...')
  
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/styles.css',
        '/script.js',
        '/offline.html'
      ])
    })
  )
  
  // Skip waiting to activate immediately
  self.skipWaiting()
})

// ACTIVATE
self.addEventListener('activate', (event) => {
  console.log('SW activating...')
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(name => name !== 'v1')
          .map(name => caches.delete(name))
      )
    })
  )
  
  // Take control of all pages immediately
  self.clients.claim()
})

// FETCH
self.addEventListener('fetch', (event) => {
  console.log('Fetching:', event.request.url)
  
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request)
    })
  )
})
```

### Lifecycle Methods:

```javascript
// Skip waiting phase
self.skipWaiting()

// Claim clients immediately
self.clients.claim()

// Wait until promises resolve
event.waitUntil(promise)
```

---

## Events

### Install Event:

```javascript
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('app-v1').then(cache => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js'
      ])
    })
  )
})
```

### Activate Event:

```javascript
self.addEventListener('activate', (event) => {
  const currentCaches = ['app-v1']
  
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!currentCaches.includes(cacheName)) {
            return caches.delete(cacheName)
          }
        })
      )
    })
  )
})
```

### Fetch Event:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      if (cachedResponse) {
        return cachedResponse
      }
      
      return fetch(event.request).then(response => {
        // Cache new responses
        return caches.open('runtime').then(cache => {
          cache.put(event.request, response.clone())
          return response
        })
      })
    })
  )
})
```

### Message Event:

```javascript
// In Service Worker
self.addEventListener('message', (event) => {
  if (event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

// From page
navigator.serviceWorker.controller.postMessage({
  type: 'SKIP_WAITING'
})
```

---

## Scope

### Default Scope:

```javascript
// Registers at /sw.js, controls everything under /
navigator.serviceWorker.register('/sw.js')

// Controls /app/ and subdirectories
navigator.serviceWorker.register('/app/sw.js')
```

### Custom Scope:

```javascript
navigator.serviceWorker.register('/sw.js', {
  scope: '/app/'
})

// In Service Worker
self.addEventListener('install', () => {
  console.log('Scope:', self.registration.scope)
})
```

### Multiple Service Workers:

```javascript
// Different scopes, different SWs
navigator.serviceWorker.register('/sw-app.js', { scope: '/app/' })
navigator.serviceWorker.register('/sw-admin.js', { scope: '/admin/' })
```

---

## Caching Basics

### Cache API:

```javascript
// Open cache
const cache = await caches.open('my-cache')

// Add to cache
await cache.add('/index.html')
await cache.addAll(['/styles.css', '/app.js'])

// Put in cache
const response = await fetch('/data.json')
await cache.put('/data.json', response)

// Match from cache
const cached = await cache.match('/index.html')

// Delete from cache
await cache.delete('/index.html')

// Get all cache names
const cacheNames = await caches.keys()

// Delete cache
await caches.delete('old-cache')
```

### Pre-caching (Install):

```javascript
const CACHE_NAME = 'app-v1'
const urlsToCache = [
  '/',
  '/styles.css',
  '/app.js',
  '/logo.png'
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      return cache.addAll(urlsToCache)
    })
  )
})
```

### Runtime Caching (Fetch):

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      if (cachedResponse) return cachedResponse
      
      return fetch(event.request).then(response => {
        // Don't cache non-success responses
        if (!response || response.status !== 200 || response.type !== 'basic') {
          return response
        }
        
        const responseToCache = response.clone()
        
        caches.open('runtime').then(cache => {
          cache.put(event.request, responseToCache)
        })
        
        return response
      })
    })
  )
})
```

---

## Offline Support

### Offline Page:

```javascript
const CACHE_NAME = 'offline-v1'

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => {
      return cache.addAll([
        '/offline.html',
        '/offline.css'
      ])
    })
  )
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request).catch(() => {
      return caches.match(event.request).then(response => {
        return response || caches.match('/offline.html')
      })
    })
  )
})
```

### Offline Detection:

```javascript
// In page
window.addEventListener('online', () => {
  console.log('Back online!')
  // Sync data
})

window.addEventListener('offline', () => {
  console.log('You are offline')
  // Show offline UI
})

// Check status
if (navigator.onLine) {
  console.log('Online')
} else {
  console.log('Offline')
}
```

---

## Best Practices

### 1. Version Your Caches:

```javascript
const VERSION = 'v1.0.0'
const CACHE_NAME = `app-${VERSION}`

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      )
    })
  )
})
```

### 2. Don't Cache Everything:

```javascript
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)
  
  // Skip caching for API requests
  if (url.pathname.startsWith('/api/')) {
    return fetch(event.request)
  }
  
  // Skip caching for external domains
  if (url.origin !== location.origin) {
    return fetch(event.request)
  }
  
  // Cache other requests
  event.respondWith(/* ... */)
})
```

### 3. Handle Updates:

```javascript
// In page
navigator.serviceWorker.register('/sw.js').then(reg => {
  reg.addEventListener('updatefound', () => {
    const newWorker = reg.installing
    
    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
        // New SW available!
        if (confirm('New version available! Reload?')) {
          window.location.reload()
        }
      }
    })
  })
})

// In Service Worker
self.addEventListener('message', (event) => {
  if (event.data === 'skipWaiting') {
    self.skipWaiting()
  }
})
```

### 4. Use HTTPS:

```javascript
// Service Workers only work on HTTPS (except localhost)
if (location.protocol === 'https:' || location.hostname === 'localhost') {
  navigator.serviceWorker.register('/sw.js')
}
```

### 5. Clean Up Old Caches:

```javascript
const CACHE_WHITELIST = ['app-v2', 'runtime-v2']

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!CACHE_WHITELIST.includes(cacheName)) {
            return caches.delete(cacheName)
          }
        })
      )
    })
  )
})
```

---

## Summary

### Key Points:
- Runs in background, separate from page
- Intercepts network requests
- Enables offline functionality
- Requires HTTPS
- Separate file and scope

### Lifecycle:
1. Register
2. Install (cache resources)
3. Activate (cleanup)
4. Fetch (intercept requests)
5. Update (when file changes)

### Common Use Cases:
- Offline support
- Performance optimization
- Push notifications
- Background sync

### Related Topics:
- Caching strategies
- Push notifications
- Background sync
- Workbox library
