# Caching Strategies

## Table of Contents
- [Cache-First Strategy](#cache-first-strategy)
- [Network-First Strategy](#network-first-strategy)
- [Stale-While-Revalidate](#stale-while-revalidate)
- [Network-Only Strategy](#network-only-strategy)
- [Cache-Only Strategy](#cache-only-strategy)
- [Strategy Selection](#strategy-selection)
- [Advanced Patterns](#advanced-patterns)
- [Best Practices](#best-practices)

---

## Cache-First Strategy

**Strategy**: Check cache first, fallback to network.

**Use Case**: Static assets (CSS, JS, images) that rarely change.

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      return cachedResponse || fetch(event.request)
    })
  )
})
```

### With Caching New Responses:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      if (cachedResponse) {
        return cachedResponse
      }
      
      return fetch(event.request).then(response => {
        return caches.open('runtime-v1').then(cache => {
          cache.put(event.request, response.clone())
          return response
        })
      })
    })
  )
})
```

### Pros & Cons:

**Pros:**
- Fastest response time
- Works offline
- Reduces bandwidth

**Cons:**
- May serve stale content
- No updates until cache is cleared

---

## Network-First Strategy

**Strategy**: Try network first, fallback to cache.

**Use Case**: API responses, dynamic content.

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Cache successful response
        const responseToCache = response.clone()
        caches.open('api-v1').then(cache => {
          cache.put(event.request, responseToCache)
        })
        return response
      })
      .catch(() => {
        // Fallback to cache
        return caches.match(event.request)
      })
  )
})
```

### With Timeout:

```javascript
function fetchWithTimeout(request, timeout = 3000) {
  return Promise.race([
    fetch(request),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), timeout)
    )
  ])
}

self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetchWithTimeout(event.request, 3000)
      .then(response => {
        caches.open('api-v1').then(cache => {
          cache.put(event.request, response.clone())
        })
        return response
      })
      .catch(() => caches.match(event.request))
  )
})
```

### Pros & Cons:

**Pros:**
- Always fresh content
- Offline fallback

**Cons:**
- Slower (network first)
- Uses more bandwidth

---

## Stale-While-Revalidate

**Strategy**: Serve cached version immediately, update cache in background.

**Use Case**: Content that can be slightly stale (news, social feeds).

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cachedResponse => {
      const fetchPromise = fetch(event.request).then(response => {
        // Update cache in background
        caches.open('dynamic-v1').then(cache => {
          cache.put(event.request, response.clone())
        })
        return response
      })
      
      // Return cached version immediately, or wait for network
      return cachedResponse || fetchPromise
    })
  )
})
```

### With Expiration:

```javascript
const MAX_AGE = 60 * 60 * 1000  // 1 hour

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open('stale-v1').then(cache => {
      return cache.match(event.request).then(cachedResponse => {
        const fetchPromise = fetch(event.request).then(response => {
          const headers = new Headers(response.headers)
          headers.append('sw-cached-at', Date.now())
          
          const modifiedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers
          })
          
          cache.put(event.request, modifiedResponse.clone())
          return modifiedResponse
        })
        
        if (cachedResponse) {
          const cachedAt = cachedResponse.headers.get('sw-cached-at')
          const age = Date.now() - parseInt(cachedAt || 0)
          
          if (age < MAX_AGE) {
            return cachedResponse
          }
        }
        
        return fetchPromise
      })
    })
  )
})
```

### Pros & Cons:

**Pros:**
- Fast initial response
- Automatically updates
- Good balance

**Cons:**
- May show stale content briefly
- Background updates use bandwidth

---

## Network-Only Strategy

**Strategy**: Always use network, no caching.

**Use Case**: Real-time data, sensitive information.

```javascript
self.addEventListener('fetch', (event) => {
  // Only for API endpoints
  if (event.request.url.includes('/api/realtime')) {
    event.respondWith(fetch(event.request))
  }
})
```

### Pros & Cons:

**Pros:**
- Always fresh
- No stale data

**Cons:**
- Doesn't work offline
- Slower

---

## Cache-Only Strategy

**Strategy**: Only serve from cache, never network.

**Use Case**: Fully offline apps, pre-cached content.

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(caches.match(event.request))
})
```

### Pros & Cons:

**Pros:**
- Extremely fast
- Works offline
- No bandwidth usage

**Cons:**
- Content never updates
- Must pre-cache everything

---

## Strategy Selection

### By Resource Type:

```javascript
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)
  
  // Static assets: Cache-First
  if (url.pathname.match(/\.(css|js|png|jpg|svg)$/)) {
    event.respondWith(cacheFirst(event.request))
  }
  
  // API: Network-First
  else if (url.pathname.startsWith('/api/')) {
    event.respondWith(networkFirst(event.request))
  }
  
  // HTML: Stale-While-Revalidate
  else if (event.request.headers.get('Accept').includes('text/html')) {
    event.respondWith(staleWhileRevalidate(event.request))
  }
})

function cacheFirst(request) {
  return caches.match(request).then(cached => cached || fetch(request))
}

function networkFirst(request) {
  return fetch(request).catch(() => caches.match(request))
}

function staleWhileRevalidate(request) {
  return caches.match(request).then(cached => {
    const fetchPromise = fetch(request).then(response => {
      caches.open('html-v1').then(cache => cache.put(request, response.clone()))
      return response
    })
    return cached || fetchPromise
  })
}
```

### Decision Tree:

```
Is content static and rarely changes?
  YES → Cache-First
  NO ↓

Is fresh data critical?
  YES → Network-First (with cache fallback)
  NO ↓

Is some staleness acceptable?
  YES → Stale-While-Revalidate
  NO → Network-First

Is app fully offline?
  YES → Cache-Only
  NO → Network-Only (for specific endpoints)
```

---

## Advanced Patterns

### Cache Then Network:

```javascript
// In Service Worker
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then(cached => cached || fetch(event.request))
  )
})

// In Page
function getData(url) {
  let networkDataReceived = false
  
  // Try cache first
  caches.match(url).then(response => {
    if (response && !networkDataReceived) {
      response.json().then(displayData)
    }
  })
  
  // Then network
  fetch(url).then(response => {
    networkDataReceived = true
    response.json().then(displayData)
  })
}
```

### Conditional Caching:

```javascript
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)
  
  // Only cache GET requests
  if (event.request.method !== 'GET') {
    return fetch(event.request)
  }
  
  // Don't cache authenticated requests
  if (event.request.headers.get('Authorization')) {
    return fetch(event.request)
  }
  
  // Don't cache external resources
  if (url.origin !== location.origin) {
    return fetch(event.request)
  }
  
  // Apply caching strategy
  event.respondWith(cacheFirst(event.request))
})
```

### Cache with Expiration:

```javascript
class CacheExpiration {
  constructor(cacheName, maxEntries = 50, maxAge = 24 * 60 * 60 * 1000) {
    this.cacheName = cacheName
    this.maxEntries = maxEntries
    this.maxAge = maxAge
  }
  
  async expireEntries() {
    const cache = await caches.open(this.cacheName)
    const requests = await cache.keys()
    
    // Remove old entries
    const now = Date.now()
    
    for (const request of requests) {
      const response = await cache.match(request)
      const dateHeader = response.headers.get('date')
      const age = now - new Date(dateHeader).getTime()
      
      if (age > this.maxAge) {
        await cache.delete(request)
      }
    }
    
    // Limit max entries
    const updatedRequests = await cache.keys()
    if (updatedRequests.length > this.maxEntries) {
      const toDelete = updatedRequests.slice(0, updatedRequests.length - this.maxEntries)
      await Promise.all(toDelete.map(req => cache.delete(req)))
    }
  }
}

// Usage
const expiration = new CacheExpiration('runtime-v1', 50, 24 * 60 * 60 * 1000)

self.addEventListener('activate', (event) => {
  event.waitUntil(expiration.expireEntries())
})
```

---

## Best Practices

### 1. Use Different Strategies for Different Resources:

```javascript
const strategies = {
  '/api/': 'network-first',
  '/static/': 'cache-first',
  '/feed/': 'stale-while-revalidate'
}

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)
  
  for (const [path, strategy] of Object.entries(strategies)) {
    if (url.pathname.startsWith(path)) {
      event.respondWith(applyStrategy(strategy, event.request))
      return
    }
  }
})
```

### 2. Set Cache Expiration:

```javascript
const CACHE_MAX_AGE = {
  'static-v1': 7 * 24 * 60 * 60 * 1000,   // 7 days
  'api-v1': 60 * 60 * 1000,               // 1 hour
  'images-v1': 30 * 24 * 60 * 60 * 1000   // 30 days
}
```

### 3. Version Your Caches:

```javascript
const CACHE_VERSION = 'v1.0.0'
const CACHE_NAMES = {
  static: `static-${CACHE_VERSION}`,
  api: `api-${CACHE_VERSION}`,
  runtime: `runtime-${CACHE_VERSION}`
}
```

### 4. Handle Opaque Responses:

```javascript
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'no-cors') {
    // Opaque response - can't read status
    event.respondWith(
      fetch(event.request).then(response => {
        caches.open('cors-v1').then(cache => {
          cache.put(event.request, response.clone())
        })
        return response
      })
    )
  }
})
```

### 5. Monitor Cache Size:

```javascript
async function getCacheSize(cacheName) {
  const cache = await caches.open(cacheName)
  const keys = await cache.keys()
  
  let size = 0
  for (const request of keys) {
    const response = await cache.match(request)
    const blob = await response.blob()
    size += blob.size
  }
  
  return size
}

// Usage
const size = await getCacheSize('static-v1')
console.log(`Cache size: ${(size / 1024 / 1024).toFixed(2)} MB`)
```

---

## Summary

### Strategy Comparison:

| Strategy | Speed | Freshness | Offline | Best For |
|----------|-------|-----------|---------|----------|
| Cache-First | ⚡⚡⚡ | ⚠️ | ✅ | Static assets |
| Network-First | ⚡ | ✅ | ✅ | API data |
| Stale-While-Revalidate | ⚡⚡ | ✅ | ✅ | Dynamic content |
| Network-Only | ⚡ | ✅ | ❌ | Real-time data |
| Cache-Only | ⚡⚡⚡ | ❌ | ✅ | Offline apps |

### General Guidelines:
- Static assets → Cache-First
- API data → Network-First
- News/feeds → Stale-While-Revalidate
- Real-time → Network-Only
- Offline apps → Cache-Only

### Related Topics:
- Service Worker basics
- Cache API
- Offline support
- Workbox library
