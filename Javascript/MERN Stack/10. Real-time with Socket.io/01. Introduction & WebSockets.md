# 01. Introduction & WebSockets

## Introduction

Real-time communication enables instant, bidirectional data exchange between clients and servers. WebSockets provide a persistent connection for real-time features like chat, notifications, live updates, and collaborative editing.

---

## What is Real-time Communication?

### Traditional HTTP (Request-Response)

```
Client                    Server
  |───── Request ──────▶|  
  |◀───── Response ─────|
  |                         |
  |───── Request ──────▶|  
  |◀───── Response ─────|
```

- **Client-initiated**: Server cannot push data
- **Stateless**: Each request is independent
- **Overhead**: HTTP headers on every request

### Real-time (WebSocket)

```
Client                    Server
  |─── Handshake (HTTP) ──▶|
  |◀───── Upgrade ──────|
  |═════════════════════════| Persistent Connection
  |◀────── Data ───────▶| Bidirectional
  |◀────── Data ───────▶|
```

- **Bidirectional**: Both can send data anytime
- **Persistent**: Connection stays open
- **Low overhead**: No HTTP headers after handshake

---

## Real-time Use Cases

### 1. **Chat Applications**
- Instant messaging (WhatsApp, Slack)
- Group conversations
- Typing indicators
- Message delivery status

### 2. **Notifications**
- Push notifications
- Real-time alerts
- Activity feeds
- System updates

### 3. **Live Updates**
- Stock prices
- Sports scores
- News feeds
- Social media likes/comments

### 4. **Collaborative Tools**
- Google Docs (simultaneous editing)
- Figma (design collaboration)
- Code editors (Live Share)
- Whiteboards

### 5. **Gaming**
- Multiplayer games
- Real-time game state
- Player positions
- Chat

### 6. **IoT & Monitoring**
- Sensor data
- Dashboard updates
- System metrics
- Live charts

---

## Traditional Approaches vs WebSockets

### 1. **Polling**

```javascript
// Client repeatedly requests data
setInterval(() => {
  fetch('/api/messages')
    .then(res => res.json())
    .then(data => updateUI(data));
}, 1000); // Every second
```

**Pros**: Simple, works everywhere
**Cons**: 
- High server load
- Unnecessary requests
- Delayed updates
- Wasted bandwidth

### 2. **Long Polling**

```javascript
// Server holds connection until new data
const longPoll = async () => {
  const response = await fetch('/api/messages/wait');
  const data = await response.json();
  updateUI(data);
  longPoll(); // Repeat
};
longPoll();
```

**Pros**: Instant updates, less overhead than polling
**Cons**: 
- Still uses HTTP
- Server resources held
- Complex implementation

### 3. **Server-Sent Events (SSE)**

```javascript
const eventSource = new EventSource('/api/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  updateUI(data);
};
```

**Pros**: Simple, built-in reconnection
**Cons**: 
- **Unidirectional** (server → client only)
- Limited browser connections
- No binary data support

### 4. **WebSockets** ✅

```javascript
const socket = new WebSocket('ws://localhost:3000');

socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  updateUI(data);
};

socket.send(JSON.stringify({ message: 'Hello' }));
```

**Pros**: 
- **Bidirectional** communication
- Low latency
- Full-duplex
- Binary data support
- Low overhead

**Cons**: 
- More complex than HTTP
- Proxy/firewall issues
- No automatic reconnection

---

## WebSocket Protocol

### Connection Flow

```
1. Client initiates HTTP request
   GET /chat HTTP/1.1
   Host: server.example.com
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
   Sec-WebSocket-Version: 13

2. Server responds with upgrade
   HTTP/1.1 101 Switching Protocols
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=

3. Connection upgraded to WebSocket
   │
   │ <──── Bidirectional messages ────>
   │
```

### Basic WebSocket API

```javascript
// Create WebSocket connection
const socket = new WebSocket('ws://localhost:3000');

// Connection opened
socket.addEventListener('open', (event) => {
  console.log('Connected to server');
  socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', (event) => {
  console.log('Message from server:', event.data);
});

// Connection closed
socket.addEventListener('close', (event) => {
  console.log('Disconnected from server');
});

// Error occurred
socket.addEventListener('error', (event) => {
  console.error('WebSocket error:', event);
});

// Send message
socket.send('Hello!');

// Close connection
socket.close();
```

---

## WebSocket States

```javascript
socket.readyState === WebSocket.CONNECTING // 0 - Connecting
socket.readyState === WebSocket.OPEN       // 1 - Connected
socket.readyState === WebSocket.CLOSING    // 2 - Closing
socket.readyState === WebSocket.CLOSED     // 3 - Closed

// Check before sending
if (socket.readyState === WebSocket.OPEN) {
  socket.send('message');
}
```

---

## Why Socket.io Over Raw WebSockets?

### Raw WebSocket Limitations

1. **No automatic reconnection**
2. **No fallback** for older browsers
3. **No rooms/namespaces**
4. **No event-based messaging**
5. **No acknowledgments**
6. **Manual heartbeat** required

### Socket.io Advantages

```javascript
// Socket.io abstracts complexity
const socket = io('http://localhost:3000');

// Event-based messaging
socket.on('message', (data) => {
  console.log(data);
});

socket.emit('message', { text: 'Hello' });

// Built-in features:
// ✅ Auto-reconnection
// ✅ Fallback to polling
// ✅ Rooms & namespaces
// ✅ Acknowledgments
// ✅ Heartbeat/ping-pong
// ✅ Binary support
// ✅ Middleware
```

---

## Comparison Table

| Feature | Polling | Long Polling | SSE | WebSocket | Socket.io |
|---------|---------|--------------|-----|-----------|----------|
| **Bidirectional** | ❌ | ❌ | ❌ | ✅ | ✅ |
| **Real-time** | ❌ | ⚠️ | ✅ | ✅ | ✅ |
| **Low Latency** | ❌ | ⚠️ | ✅ | ✅ | ✅ |
| **Overhead** | High | Medium | Low | Very Low | Very Low |
| **Auto Reconnect** | N/A | ❌ | ✅ | ❌ | ✅ |
| **Fallback** | N/A | N/A | ❌ | ❌ | ✅ |
| **Event-based** | ❌ | ❌ | ⚠️ | ❌ | ✅ |
| **Rooms** | ❌ | ❌ | ❌ | ❌ | ✅ |
| **Complexity** | Low | Medium | Low | Medium | Low |

---

## Interview Questions

**Q1: What is the difference between HTTP and WebSocket?**
- **HTTP**: Unidirectional, stateless, request-response, high overhead
- **WebSocket**: Bidirectional, persistent connection, low overhead, full-duplex

**Q2: How does WebSocket handshake work?**
1. Client sends HTTP request with `Upgrade: websocket` header
2. Server responds with `101 Switching Protocols`
3. Connection upgraded to WebSocket protocol
4. Bidirectional communication begins

**Q3: What are WebSocket readyState values?**
- `0 CONNECTING`: Connection not yet established
- `1 OPEN`: Connection open and ready
- `2 CLOSING`: Connection closing
- `3 CLOSED`: Connection closed

**Q4: What are alternatives to WebSocket?**
- Polling (repeated requests)
- Long polling (server holds connection)
- Server-Sent Events (unidirectional)
- HTTP/2 Server Push

**Q5: Why use Socket.io instead of raw WebSocket?**
- Auto-reconnection
- Fallback to polling
- Event-based API
- Rooms and namespaces
- Acknowledgments
- Middleware support

---

## Best Practices

1. **Use WebSocket for real-time** features only
2. **Validate and sanitize** all messages
3. **Implement authentication** for secure connections
4. **Handle disconnections** gracefully
5. **Limit message size** to prevent abuse
6. **Use compression** for large payloads
7. **Implement heartbeat** to detect dead connections
8. **Rate limit** to prevent spam
9. **Use namespaces** to organize features
10. **Monitor connection count** for scaling

---

## Summary

- **Real-time communication**: Instant bidirectional data exchange
- **HTTP**: Stateless, unidirectional, high overhead
- **WebSocket**: Persistent, bidirectional, low overhead
- **Handshake**: HTTP upgrade to WebSocket protocol
- **States**: CONNECTING, OPEN, CLOSING, CLOSED
- **Alternatives**: Polling, long polling, SSE
- **Socket.io**: WebSocket wrapper with auto-reconnect, fallback, events, rooms
- **Use cases**: Chat, notifications, live updates, collaboration, gaming
