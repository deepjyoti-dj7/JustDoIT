# 08. Online Status & Notifications

## Introduction

Tracking online status and sending real-time notifications are essential features for modern applications. This guide covers presence detection, status updates, and push notification systems using Socket.io.

---

## Online Status Tracking

### Basic Online/Offline Status

```javascript
// Server
const onlineUsers = new Map(); // { userId: { socketId, status, lastSeen } }

io.on('connection', (socket) => {
  // User comes online
  socket.on('setOnline', (userId) => {
    socket.userId = userId;
    
    onlineUsers.set(userId, {
      socketId: socket.id,
      status: 'online',
      lastSeen: new Date()
    });
    
    // Notify all users
    io.emit('userStatusChanged', {
      userId,
      status: 'online',
      timestamp: new Date()
    });
  });
  
  // Disconnection
  socket.on('disconnect', () => {
    if (socket.userId) {
      onlineUsers.delete(socket.userId);
      
      // Notify all users
      io.emit('userStatusChanged', {
        userId: socket.userId,
        status: 'offline',
        lastSeen: new Date()
      });
    }
  });
});
```

### Extended Status (Online, Away, Busy)

```javascript
// Server
const userStatuses = new Map(); // { userId: 'online' | 'away' | 'busy' | 'offline' }

io.on('connection', (socket) => {
  socket.on('login', (userId) => {
    socket.userId = userId;
    userStatuses.set(userId, 'online');
    
    // Send current status of all users
    const allStatuses = Object.fromEntries(userStatuses);
    socket.emit('allStatuses', allStatuses);
    
    // Notify others
    socket.broadcast.emit('statusUpdate', {
      userId,
      status: 'online'
    });
  });
  
  // Change status
  socket.on('changeStatus', (status) => {
    if (['online', 'away', 'busy'].includes(status)) {
      userStatuses.set(socket.userId, status);
      
      io.emit('statusUpdate', {
        userId: socket.userId,
        status
      });
    }
  });
  
  // Auto-away after inactivity
  let inactivityTimeout;
  
  socket.on('activity', () => {
    // Reset status to online
    if (userStatuses.get(socket.userId) === 'away') {
      userStatuses.set(socket.userId, 'online');
      io.emit('statusUpdate', {
        userId: socket.userId,
        status: 'online'
      });
    }
    
    // Reset inactivity timer
    clearTimeout(inactivityTimeout);
    inactivityTimeout = setTimeout(() => {
      userStatuses.set(socket.userId, 'away');
      io.emit('statusUpdate', {
        userId: socket.userId,
        status: 'away'
      });
    }, 300000); // 5 minutes
  });
  
  socket.on('disconnect', () => {
    if (socket.userId) {
      userStatuses.set(socket.userId, 'offline');
      socket.broadcast.emit('statusUpdate', {
        userId: socket.userId,
        status: 'offline',
        lastSeen: new Date()
      });
    }
    clearTimeout(inactivityTimeout);
  });
});
```

### Client Implementation

```javascript
const socket = io('http://localhost:5000');
const userStatuses = new Map();

// Login
function login(userId) {
  socket.emit('login', userId);
}

// Receive all statuses
socket.on('allStatuses', (statuses) => {
  Object.entries(statuses).forEach(([userId, status]) => {
    userStatuses.set(userId, status);
    updateUserStatusUI(userId, status);
  });
});

// Status updates
socket.on('statusUpdate', ({ userId, status }) => {
  userStatuses.set(userId, status);
  updateUserStatusUI(userId, status);
});

// Change own status
function changeStatus(status) {
  socket.emit('changeStatus', status);
}

// Track activity for auto-away
let activityTimer;
function trackActivity() {
  socket.emit('activity');
  
  clearTimeout(activityTimer);
  activityTimer = setTimeout(trackActivity, 60000); // Every minute
}

// Activity events
document.addEventListener('mousemove', () => socket.emit('activity'));
document.addEventListener('keypress', () => socket.emit('activity'));

// Update UI
function updateUserStatusUI(userId, status) {
  const statusElement = document.getElementById(`status-${userId}`);
  if (statusElement) {
    statusElement.className = `status-indicator ${status}`;
    statusElement.textContent = status;
  }
}
```

---

## Last Seen & Active Now

### Server Implementation

```javascript
const userActivity = new Map(); // { userId: { lastSeen, isOnline } }

io.on('connection', (socket) => {
  socket.on('login', (userId) => {
    socket.userId = userId;
    
    userActivity.set(userId, {
      lastSeen: new Date(),
      isOnline: true,
      socketId: socket.id
    });
    
    io.emit('userActivity', {
      userId,
      isOnline: true,
      lastSeen: new Date()
    });
  });
  
  // Update last seen on activity
  socket.on('heartbeat', () => {
    if (socket.userId) {
      const activity = userActivity.get(socket.userId);
      if (activity) {
        activity.lastSeen = new Date();
      }
    }
  });
  
  // Get user status
  socket.on('getUserStatus', (userId, callback) => {
    const activity = userActivity.get(userId);
    callback(activity || { isOnline: false, lastSeen: null });
  });
  
  socket.on('disconnect', () => {
    if (socket.userId) {
      const activity = userActivity.get(socket.userId);
      if (activity) {
        activity.isOnline = false;
        activity.lastSeen = new Date();
      }
      
      io.emit('userActivity', {
        userId: socket.userId,
        isOnline: false,
        lastSeen: new Date()
      });
    }
  });
});
```

### Client Display

```javascript
// Format last seen
function formatLastSeen(lastSeen) {
  const now = new Date();
  const diff = now - new Date(lastSeen);
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (minutes < 1) return 'Active now';
  if (minutes < 60) return `Active ${minutes}m ago`;
  if (hours < 24) return `Active ${hours}h ago`;
  return `Active ${days}d ago`;
}

// Update user activity
socket.on('userActivity', ({ userId, isOnline, lastSeen }) => {
  const statusEl = document.getElementById(`user-${userId}-status`);
  
  if (isOnline) {
    statusEl.textContent = 'Active now';
    statusEl.className = 'status online';
  } else {
    statusEl.textContent = formatLastSeen(lastSeen);
    statusEl.className = 'status offline';
  }
});

// Send heartbeat every 30 seconds
setInterval(() => {
  socket.emit('heartbeat');
}, 30000);
```

---

## Real-time Notifications

### Server Implementation

```javascript
const userSockets = new Map(); // { userId: socketId }

io.on('connection', (socket) => {
  socket.on('login', (userId) => {
    socket.userId = userId;
    userSockets.set(userId, socket.id);
  });
  
  // Send notification to user
  function sendNotification(userId, notification) {
    const socketId = userSockets.get(userId);
    
    if (socketId) {
      io.to(socketId).emit('notification', {
        id: generateId(),
        type: notification.type,
        title: notification.title,
        message: notification.message,
        data: notification.data,
        timestamp: new Date(),
        read: false
      });
    }
  }
  
  // Different notification types
  socket.on('likePost', ({ postId, postAuthorId }) => {
    sendNotification(postAuthorId, {
      type: 'like',
      title: 'New Like',
      message: `${socket.username} liked your post`,
      data: { postId, userId: socket.userId }
    });
  });
  
  socket.on('comment', ({ postId, postAuthorId, comment }) => {
    sendNotification(postAuthorId, {
      type: 'comment',
      title: 'New Comment',
      message: `${socket.username} commented on your post`,
      data: { postId, comment, userId: socket.userId }
    });
  });
  
  socket.on('follow', ({ targetUserId }) => {
    sendNotification(targetUserId, {
      type: 'follow',
      title: 'New Follower',
      message: `${socket.username} started following you`,
      data: { userId: socket.userId }
    });
  });
  
  socket.on('mention', ({ mentionedUserId, postId }) => {
    sendNotification(mentionedUserId, {
      type: 'mention',
      title: 'You were mentioned',
      message: `${socket.username} mentioned you in a post`,
      data: { postId, userId: socket.userId }
    });
  });
  
  // Mark notification as read
  socket.on('markNotificationRead', (notificationId) => {
    // Update in database
    console.log(`Notification ${notificationId} marked as read`);
  });
  
  socket.on('disconnect', () => {
    if (socket.userId) {
      userSockets.delete(socket.userId);
    }
  });
});

function generateId() {
  return `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
```

### Client Implementation

```javascript
const notifications = [];

// Receive notification
socket.on('notification', (notification) => {
  console.log('New notification:', notification);
  
  notifications.unshift(notification);
  updateNotificationBadge();
  displayNotification(notification);
  
  // Show browser notification if permitted
  if (Notification.permission === 'granted') {
    new Notification(notification.title, {
      body: notification.message,
      icon: '/icon.png'
    });
  }
});

// Display notification in UI
function displayNotification(notification) {
  const notifEl = document.createElement('div');
  notifEl.className = `notification ${notification.type}`;
  notifEl.innerHTML = `
    <h4>${notification.title}</h4>
    <p>${notification.message}</p>
    <small>${formatTime(notification.timestamp)}</small>
  `;
  
  notifEl.addEventListener('click', () => {
    handleNotificationClick(notification);
    markAsRead(notification.id);
  });
  
  document.getElementById('notifications').prepend(notifEl);
  
  // Auto-dismiss after 5 seconds
  setTimeout(() => {
    notifEl.classList.add('fade-out');
    setTimeout(() => notifEl.remove(), 500);
  }, 5000);
}

// Update notification badge
function updateNotificationBadge() {
  const unreadCount = notifications.filter(n => !n.read).length;
  const badge = document.getElementById('notification-badge');
  
  if (unreadCount > 0) {
    badge.textContent = unreadCount > 99 ? '99+' : unreadCount;
    badge.style.display = 'block';
  } else {
    badge.style.display = 'none';
  }
}

// Mark as read
function markAsRead(notificationId) {
  const notification = notifications.find(n => n.id === notificationId);
  if (notification) {
    notification.read = true;
    socket.emit('markNotificationRead', notificationId);
    updateNotificationBadge();
  }
}

// Handle notification click
function handleNotificationClick(notification) {
  switch (notification.type) {
    case 'like':
    case 'comment':
      window.location.href = `/post/${notification.data.postId}`;
      break;
    case 'follow':
      window.location.href = `/user/${notification.data.userId}`;
      break;
    case 'mention':
      window.location.href = `/post/${notification.data.postId}`;
      break;
  }
}

// Request browser notification permission
if ('Notification' in window && Notification.permission === 'default') {
  Notification.requestPermission();
}
```

---

## Complete Example: Status & Notifications

### Server (statusNotificationServer.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

// Data stores
const onlineUsers = new Map(); // { userId: { socketId, status, lastSeen } }
const userNotifications = new Map(); // { userId: [notifications] }

io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  // ========== USER LOGIN ==========
  socket.on('login', ({ userId, username }) => {
    socket.userId = userId;
    socket.username = username;
    
    // Set online status
    onlineUsers.set(userId, {
      socketId: socket.id,
      status: 'online',
      lastSeen: new Date()
    });
    
    // Send all online users
    const onlineUsersList = Array.from(onlineUsers.entries()).map(([id, data]) => ({
      userId: id,
      status: data.status,
      lastSeen: data.lastSeen
    }));
    socket.emit('onlineUsers', onlineUsersList);
    
    // Notify others
    socket.broadcast.emit('userOnline', {
      userId,
      username,
      status: 'online'
    });
    
    // Send pending notifications
    const pendingNotifications = userNotifications.get(userId) || [];
    socket.emit('pendingNotifications', pendingNotifications);
  });
  
  // ========== STATUS CHANGE ==========
  socket.on('changeStatus', (status) => {
    if (['online', 'away', 'busy'].includes(status)) {
      const userData = onlineUsers.get(socket.userId);
      if (userData) {
        userData.status = status;
        userData.lastSeen = new Date();
        
        io.emit('statusChanged', {
          userId: socket.userId,
          username: socket.username,
          status
        });
      }
    }
  });
  
  // ========== SEND NOTIFICATION ==========
  socket.on('sendNotification', ({ recipientId, type, message, data }) => {
    const notification = {
      id: `notif-${Date.now()}`,
      from: socket.userId,
      fromUsername: socket.username,
      type,
      message,
      data,
      timestamp: new Date(),
      read: false
    };
    
    // Store notification
    if (!userNotifications.has(recipientId)) {
      userNotifications.set(recipientId, []);
    }
    userNotifications.get(recipientId).push(notification);
    
    // Send if user is online
    const recipient = onlineUsers.get(recipientId);
    if (recipient) {
      io.to(recipient.socketId).emit('notification', notification);
    }
  });
  
  // ========== MARK AS READ ==========
  socket.on('markRead', (notificationId) => {
    const notifications = userNotifications.get(socket.userId) || [];
    const notification = notifications.find(n => n.id === notificationId);
    if (notification) {
      notification.read = true;
    }
  });
  
  // ========== HEARTBEAT ==========
  socket.on('heartbeat', () => {
    const userData = onlineUsers.get(socket.userId);
    if (userData) {
      userData.lastSeen = new Date();
    }
  });
  
  // ========== DISCONNECTION ==========
  socket.on('disconnect', () => {
    if (socket.userId) {
      const userData = onlineUsers.get(socket.userId);
      if (userData) {
        userData.status = 'offline';
        userData.lastSeen = new Date();
      }
      
      socket.broadcast.emit('userOffline', {
        userId: socket.userId,
        username: socket.username,
        lastSeen: new Date()
      });
      
      // Remove after 1 minute (give time for reconnection)
      setTimeout(() => {
        onlineUsers.delete(socket.userId);
      }, 60000);
    }
    console.log('Client disconnected:', socket.id);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

---

## Interview Questions

**Q1: How to track online/offline status?**
- Store users in Map with `{ userId: socketId, status, lastSeen }`
- Update on `connection` (online) and `disconnect` (offline)
- Broadcast status changes to all clients

**Q2: How to implement last seen?**
- Update `lastSeen` timestamp on activity (heartbeat)
- Send periodic heartbeat from client (e.g., every 30s)
- Display relative time (e.g., "Active 5m ago")

**Q3: How to send real-time notifications?**
- Store user socket IDs
- Use `io.to(socketId).emit('notification', data)`
- Store notifications for offline users in database
- Send pending notifications on login

**Q4: What notification types are common?**
- Likes, comments, mentions, follows
- Messages, friend requests, system alerts
- Each type has different data and handling

**Q5: How to handle multiple devices?**
- Store multiple socket IDs per user (Set or Array)
- Send notification to all user's sockets
- Sync read status across devices

---

## Best Practices

1. **Store notifications** in database for offline users
2. **Implement heartbeat** for accurate last seen
3. **Auto-away** after inactivity period
4. **Batch notifications** to reduce noise
5. **Use notification types** for filtering
6. **Mark as read** to track viewed notifications
7. **Limit notification history** for performance
8. **Use browser notifications** for better UX
9. **Handle multiple devices** per user
10. **Monitor notification frequency** to prevent spam

---

## Summary

- **Online Status**: Track with Map of userId â†’ socket data
- **Statuses**: online, away, busy, offline
- **Last Seen**: Update on heartbeat, display on offline
- **Notifications**: Send via `io.to(socketId).emit()`
- **Types**: likes, comments, follows, mentions, etc.
- **Offline Users**: Store notifications in database
- **Read Status**: Track and sync across devices
- **Heartbeat**: Periodic ping for accurate presence
- **Browser Notifications**: Enhance with Notification API
- **Best Practice**: Persist data, handle multiple devices
