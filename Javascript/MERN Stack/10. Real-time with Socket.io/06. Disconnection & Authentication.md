# 06. Disconnection & Authentication

## Introduction

Handling disconnections and implementing authentication are crucial for building robust real-time applications. This guide covers disconnection handling, reconnection strategies, and various authentication methods.

---

## Disconnection

### Server-side Disconnection Handling

```javascript
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // Disconnection event
  socket.on('disconnect', (reason) => {
    console.log('User disconnected:', socket.id);
    console.log('Reason:', reason);
    
    // Perform cleanup
    // - Remove from online users
    // - Update database
    // - Notify other users
  });
});
```

### Disconnection Reasons

```javascript
socket.on('disconnect', (reason) => {
  switch (reason) {
    case 'transport close':
      // Network connection lost
      console.log('Network issue');
      break;
      
    case 'client namespace disconnect':
      // Client called socket.disconnect()
      console.log('Client disconnected intentionally');
      break;
      
    case 'server namespace disconnect':
      // Server called socket.disconnect()
      console.log('Server disconnected client');
      break;
      
    case 'ping timeout':
      // Client didn't respond to ping
      console.log('Ping timeout');
      break;
      
    case 'transport error':
      // Transport error
      console.log('Transport error');
      break;
      
    default:
      console.log('Unknown reason:', reason);
  }
});
```

### Forced Disconnection (Server)

```javascript
io.on('connection', (socket) => {
  // Disconnect after 1 hour of inactivity
  const timeout = setTimeout(() => {
    socket.disconnect(true); // true = close underlying connection
  }, 3600000);
  
  // Reset timeout on activity
  socket.on('activity', () => {
    clearTimeout(timeout);
    // Set new timeout...
  });
  
  // Kick user
  socket.on('kickUser', (targetSocketId) => {
    io.sockets.sockets.get(targetSocketId)?.disconnect(true);
  });
});
```

### Client-side Disconnection Handling

```javascript
const socket = io('http://localhost:5000');

// Disconnection
socket.on('disconnect', (reason) => {
  console.log('Disconnected:', reason);
  
  if (reason === 'io server disconnect') {
    // Server disconnected, reconnect manually
    socket.connect();
  }
  // Otherwise, socket will auto-reconnect
  
  // Update UI
  updateConnectionStatus('disconnected');
});

// Manual disconnect
function logout() {
  socket.disconnect();
}
```

---

## Reconnection

### Client Reconnection Configuration

```javascript
const socket = io('http://localhost:5000', {
  reconnection: true,              // Enable reconnection
  reconnectionAttempts: 5,         // Max attempts
  reconnectionDelay: 1000,         // Initial delay (ms)
  reconnectionDelayMax: 5000,      // Max delay (ms)
  randomizationFactor: 0.5,        // Randomize delay Â±50%
  timeout: 20000                   // Connection timeout
});
```

### Reconnection Events

```javascript
let reconnectAttempts = 0;

// Reconnecting
socket.on('reconnect_attempt', (attemptNumber) => {
  console.log('Reconnection attempt:', attemptNumber);
  reconnectAttempts = attemptNumber;
  updateUI(`Reconnecting... (${attemptNumber}/5)`);
});

// Reconnection error
socket.on('reconnect_error', (error) => {
  console.error('Reconnection error:', error);
});

// Reconnection failed
socket.on('reconnect_failed', () => {
  console.error('Reconnection failed after max attempts');
  updateUI('Connection lost. Please refresh.');
});

// Reconnected successfully
socket.on('reconnect', (attemptNumber) => {
  console.log('Reconnected after', attemptNumber, 'attempts');
  reconnectAttempts = 0;
  updateUI('Connected');
  
  // Re-join rooms, restore state, etc.
  restoreState();
});

function restoreState() {
  // Re-authenticate
  socket.emit('authenticate', { token: getToken() });
  
  // Re-join rooms
  socket.emit('joinRoom', currentRoom);
  
  // Request missed messages
  socket.emit('getRecentMessages', lastMessageId);
}
```

---

## Authentication

### 1. Token-based Authentication (JWT)

#### Server Setup

```javascript
const jwt = require('jsonwebtoken');
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Middleware for authentication
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication error: No token provided'));
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.userId = decoded.userId;
    socket.username = decoded.username;
    socket.email = decoded.email;
    next();
  } catch (err) {
    next(new Error('Authentication error: Invalid token'));
  }
});

io.on('connection', (socket) => {
  console.log(`Authenticated user: ${socket.username} (${socket.userId})`);
  
  // User is authenticated, allow access
  socket.emit('authenticated', {
    userId: socket.userId,
    username: socket.username
  });
});
```

#### Client Setup

```javascript
const token = localStorage.getItem('authToken');

const socket = io('http://localhost:5000', {
  auth: {
    token: token
  }
});

// Authentication success
socket.on('authenticated', (user) => {
  console.log('Authenticated as:', user.username);
});

// Authentication error
socket.on('connect_error', (err) => {
  console.error('Connection error:', err.message);
  if (err.message.includes('Authentication')) {
    // Redirect to login
    window.location.href = '/login';
  }
});
```

### 2. Query Parameter Authentication

```javascript
// Client
const socket = io('http://localhost:5000', {
  query: {
    token: 'your-jwt-token'
  }
});

// Server
io.use((socket, next) => {
  const token = socket.handshake.query.token;
  
  if (!token) {
    return next(new Error('No token'));
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.user = decoded;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});
```

### 3. Cookie-based Authentication

```javascript
// Server
const cookieParser = require('cookie-parser');

// Parse cookies from handshake
io.use((socket, next) => {
  const cookies = socket.handshake.headers.cookie;
  
  if (!cookies) {
    return next(new Error('No cookies'));
  }
  
  // Parse cookies manually or use cookie-parser
  const token = parseCookie(cookies).token;
  
  if (!token) {
    return next(new Error('No auth token'));
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.user = decoded;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});

function parseCookie(cookieString) {
  const cookies = {};
  cookieString.split(';').forEach(cookie => {
    const [name, value] = cookie.trim().split('=');
    cookies[name] = value;
  });
  return cookies;
}

// Client (cookies sent automatically)
const socket = io('http://localhost:5000', {
  withCredentials: true  // Send cookies
});
```

### 4. Session-based Authentication

```javascript
// Server with Express session
const session = require('express-session');
const sharedsession = require('express-socket.io-session');

// Express session middleware
const sessionMiddleware = session({
  secret: 'session-secret',
  resave: false,
  saveUninitialized: false,
  cookie: { secure: false }
});

app.use(sessionMiddleware);

// Share session with Socket.io
io.use(sharedsession(sessionMiddleware, {
  autoSave: true
}));

io.on('connection', (socket) => {
  // Access session
  const session = socket.handshake.session;
  
  if (!session.user) {
    socket.disconnect(true);
    return;
  }
  
  console.log('User from session:', session.user);
  socket.userId = session.user.id;
});
```

---

## Complete Authentication Example

### Server (authServer.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

const JWT_SECRET = 'your-secret-key';
const users = new Map(); // In-memory user storage (use DB in production)
const onlineUsers = new Map();

app.use(express.json());

// Register endpoint
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  
  if (users.has(username)) {
    return res.status(400).json({ error: 'User already exists' });
  }
  
  const hashedPassword = await bcrypt.hash(password, 10);
  users.set(username, {
    username,
    password: hashedPassword,
    createdAt: new Date()
  });
  
  res.json({ message: 'User registered successfully' });
});

// Login endpoint
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  const user = users.get(username);
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate JWT
  const token = jwt.sign(
    { username: user.username },
    JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  res.json({ token, username: user.username });
});

// Socket.io authentication middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication required'));
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.username = decoded.username;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});

// Socket.io connection
io.on('connection', (socket) => {
  console.log(`${socket.username} connected (${socket.id})`);
  
  // Add to online users
  onlineUsers.set(socket.username, socket.id);
  
  // Notify all about online users
  io.emit('onlineUsers', Array.from(onlineUsers.keys()));
  
  // Authenticated event
  socket.emit('authenticated', {
    username: socket.username,
    onlineUsers: Array.from(onlineUsers.keys())
  });
  
  // Chat message
  socket.on('message', (message) => {
    io.emit('message', {
      from: socket.username,
      message,
      timestamp: new Date()
    });
  });
  
  // Disconnection
  socket.on('disconnect', () => {
    onlineUsers.delete(socket.username);
    io.emit('onlineUsers', Array.from(onlineUsers.keys()));
    console.log(`${socket.username} disconnected`);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

### Client (authClient.html)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Socket.io Authentication</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    .hidden { display: none; }
    input, button { padding: 10px; margin: 5px; }
    #messages { border: 1px solid #ddd; height: 300px; overflow-y: auto; padding: 10px; }
  </style>
</head>
<body>
  <!-- Login Form -->
  <div id="loginForm">
    <h2>Login</h2>
    <input type="text" id="username" placeholder="Username" />
    <input type="password" id="password" placeholder="Password" />
    <button onclick="login()">Login</button>
    <button onclick="register()">Register</button>
    <p id="loginError" style="color: red;"></p>
  </div>
  
  <!-- Chat Interface -->
  <div id="chatInterface" class="hidden">
    <h2>Chat - Welcome <span id="currentUser"></span></h2>
    <p>Online Users: <span id="onlineUsers"></span></p>
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
    <button onclick="logout()">Logout</button>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    let socket;
    let token = localStorage.getItem('authToken');
    
    // Auto-login if token exists
    if (token) {
      connectSocket(token);
    }
    
    // Register
    async function register() {
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      
      const response = await fetch('http://localhost:5000/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        alert('Registration successful! Please login.');
      } else {
        document.getElementById('loginError').textContent = data.error;
      }
    }
    
    // Login
    async function login() {
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      
      const response = await fetch('http://localhost:5000/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        localStorage.setItem('authToken', data.token);
        connectSocket(data.token);
      } else {
        document.getElementById('loginError').textContent = data.error;
      }
    }
    
    // Connect to Socket.io
    function connectSocket(authToken) {
      socket = io('http://localhost:5000', {
        auth: { token: authToken }
      });
      
      // Authenticated
      socket.on('authenticated', (data) => {
        document.getElementById('loginForm').classList.add('hidden');
        document.getElementById('chatInterface').classList.remove('hidden');
        document.getElementById('currentUser').textContent = data.username;
        updateOnlineUsers(data.onlineUsers);
      });
      
      // Online users
      socket.on('onlineUsers', (users) => {
        updateOnlineUsers(users);
      });
      
      // Messages
      socket.on('message', (data) => {
        const messagesDiv = document.getElementById('messages');
        messagesDiv.innerHTML += `<p><strong>${data.from}:</strong> ${data.message}</p>`;
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      });
      
      // Connection error
      socket.on('connect_error', (err) => {
        document.getElementById('loginError').textContent = 
          'Authentication failed: ' + err.message;
        localStorage.removeItem('authToken');
        document.getElementById('loginForm').classList.remove('hidden');
        document.getElementById('chatInterface').classList.add('hidden');
      });
    }
    
    // Send message
    function sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (message) {
        socket.emit('message', message);
        input.value = '';
      }
    }
    
    // Update online users
    function updateOnlineUsers(users) {
      document.getElementById('onlineUsers').textContent = users.join(', ');
    }
    
    // Logout
    function logout() {
      localStorage.removeItem('authToken');
      socket.disconnect();
      location.reload();
    }
    
    // Send on Enter
    document.getElementById('messageInput')?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
  </script>
</body>
</html>
```

---

## Interview Questions

**Q1: How to handle disconnection in Socket.io?**
```javascript
socket.on('disconnect', (reason) => {
  console.log('Disconnected:', reason);
  // Cleanup: remove from online users, update DB, etc.
});
```

**Q2: What are common disconnection reasons?**
- `transport close`: Network issue
- `client namespace disconnect`: Client disconnected
- `server namespace disconnect`: Server disconnected client
- `ping timeout`: Client didn't respond to ping

**Q3: How to implement JWT authentication?**
```javascript
// Client
const socket = io(url, { auth: { token: jwtToken } });

// Server middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  const decoded = jwt.verify(token, SECRET);
  socket.user = decoded;
  next();
});
```

**Q4: How to handle reconnection?**
- Configure client: `reconnection: true`, `reconnectionAttempts`, `reconnectionDelay`
- Listen to events: `reconnect`, `reconnect_attempt`, `reconnect_failed`
- Restore state: re-authenticate, re-join rooms, fetch missed data

**Q5: How to force disconnect a client?**
```javascript
socket.disconnect(true); // true = close underlying connection
```

---

## Best Practices

1. **Always authenticate** connections
2. **Use JWT** for stateless authentication
3. **Validate tokens** in middleware
4. **Handle reconnection** gracefully
5. **Restore state** after reconnection
6. **Clean up** on disconnection
7. **Set reconnection limits** to prevent infinite loops
8. **Log disconnection reasons** for debugging
9. **Use HTTPS/WSS** in production
10. **Implement timeout** for inactive connections

---

## Summary

- **disconnect event**: Fired when client disconnects
- **Reasons**: transport close, ping timeout, manual disconnect
- **Reconnection**: Automatic with configurable delays
- **Events**: `reconnect`, `reconnect_attempt`, `reconnect_failed`
- **Authentication**: JWT, cookies, sessions, query params
- **Middleware**: `io.use()` for authentication
- **Token**: Send via `auth`, `query`, or cookies
- **Force disconnect**: `socket.disconnect(true)`
- **Restore state**: Re-authenticate, re-join rooms after reconnect
- **Best practice**: Always authenticate and handle disconnections
