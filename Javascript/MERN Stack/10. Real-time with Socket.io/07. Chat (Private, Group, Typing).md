# 07. Chat (Private, Group, Typing)

## Introduction

Building a real-time chat application involves implementing private messaging, group chats, and user experience features like typing indicators. This guide covers complete chat implementation with Socket.io.

---

## Private Chat (One-to-One)

### Server Implementation

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

// Store online users: { userId: socketId }
const onlineUsers = new Map();

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // User login
  socket.on('login', (userId) => {
    socket.userId = userId;
    onlineUsers.set(userId, socket.id);
    
    // Notify user they're online
    socket.emit('loginSuccess', {
      userId,
      onlineUsers: Array.from(onlineUsers.keys())
    });
    
    // Notify others
    socket.broadcast.emit('userOnline', userId);
  });
  
  // Private message
  socket.on('privateMessage', ({ recipientId, message }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    
    // Send to recipient if online
    if (recipientSocketId) {
      io.to(recipientSocketId).emit('privateMessage', {
        from: socket.userId,
        message,
        timestamp: new Date()
      });
      
      // Send confirmation to sender
      socket.emit('messageSent', {
        to: recipientId,
        message,
        status: 'delivered',
        timestamp: new Date()
      });
    } else {
      // User offline, save to database or queue
      socket.emit('messageSent', {
        to: recipientId,
        message,
        status: 'pending',
        timestamp: new Date()
      });
    }
  });
  
  // Disconnection
  socket.on('disconnect', () => {
    if (socket.userId) {
      onlineUsers.delete(socket.userId);
      socket.broadcast.emit('userOffline', socket.userId);
    }
    console.log('User disconnected:', socket.id);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

### Client Implementation

```javascript
const socket = io('http://localhost:5000');
let currentUserId = '';

// Login
function login(userId) {
  currentUserId = userId;
  socket.emit('login', userId);
}

// Login success
socket.on('loginSuccess', ({ userId, onlineUsers }) => {
  console.log('Logged in as:', userId);
  displayOnlineUsers(onlineUsers);
});

// Send private message
function sendPrivateMessage(recipientId, message) {
  socket.emit('privateMessage', {
    recipientId,
    message
  });
  
  // Display in UI immediately
  displayMessage({
    from: currentUserId,
    to: recipientId,
    message,
    timestamp: new Date()
  });
}

// Receive private message
socket.on('privateMessage', (data) => {
  console.log('Message from', data.from, ':', data.message);
  displayMessage(data);
  
  // Send read receipt
  socket.emit('messageRead', {
    senderId: data.from,
    timestamp: new Date()
  });
});

// Message sent confirmation
socket.on('messageSent', (data) => {
  console.log('Message status:', data.status);
  updateMessageStatus(data);
});

// User online/offline
socket.on('userOnline', (userId) => {
  console.log('User online:', userId);
  updateUserStatus(userId, 'online');
});

socket.on('userOffline', (userId) => {
  console.log('User offline:', userId);
  updateUserStatus(userId, 'offline');
});
```

---

## Group Chat

### Server Implementation

```javascript
const groupChats = new Map(); // { groupId: Set<userId> }
const userGroups = new Map();  // { userId: Set<groupId> }

io.on('connection', (socket) => {
  // Create group
  socket.on('createGroup', ({ groupId, groupName, members }) => {
    // Create group
    groupChats.set(groupId, new Set(members));
    
    // Add to user groups
    members.forEach(userId => {
      if (!userGroups.has(userId)) {
        userGroups.set(userId, new Set());
      }
      userGroups.get(userId).add(groupId);
    });
    
    // Create Socket.io room for the group
    socket.join(groupId);
    
    // Notify all members
    members.forEach(userId => {
      const socketId = onlineUsers.get(userId);
      if (socketId) {
        io.to(socketId).emit('groupCreated', {
          groupId,
          groupName,
          members
        });
      }
    });
  });
  
  // Join group
  socket.on('joinGroup', (groupId) => {
    socket.join(groupId);
    
    // Add user to group
    if (!groupChats.has(groupId)) {
      groupChats.set(groupId, new Set());
    }
    groupChats.get(groupId).add(socket.userId);
    
    // Notify group
    socket.to(groupId).emit('userJoinedGroup', {
      groupId,
      userId: socket.userId
    });
    
    socket.emit('joinedGroup', groupId);
  });
  
  // Group message
  socket.on('groupMessage', ({ groupId, message }) => {
    // Broadcast to all in group (including sender for UI)
    io.to(groupId).emit('groupMessage', {
      groupId,
      from: socket.userId,
      message,
      timestamp: new Date()
    });
  });
  
  // Leave group
  socket.on('leaveGroup', (groupId) => {
    socket.leave(groupId);
    
    // Remove from group
    groupChats.get(groupId)?.delete(socket.userId);
    
    // Notify group
    socket.to(groupId).emit('userLeftGroup', {
      groupId,
      userId: socket.userId
    });
  });
  
  // Delete group
  socket.on('deleteGroup', (groupId) => {
    // Notify all members
    io.to(groupId).emit('groupDeleted', groupId);
    
    // Clean up
    groupChats.delete(groupId);
    
    // Remove from all sockets
    io.in(groupId).socketsLeave(groupId);
  });
});
```

### Client Implementation

```javascript
// Create group
function createGroup(groupName, members) {
  const groupId = generateId();
  
  socket.emit('createGroup', {
    groupId,
    groupName,
    members: [...members, currentUserId]
  });
}

// Join group
function joinGroup(groupId) {
  socket.emit('joinGroup', groupId);
}

// Send group message
function sendGroupMessage(groupId, message) {
  socket.emit('groupMessage', { groupId, message });
}

// Receive group message
socket.on('groupMessage', (data) => {
  console.log(`[${data.groupId}] ${data.from}: ${data.message}`);
  displayGroupMessage(data);
});

// Group events
socket.on('groupCreated', ({ groupId, groupName, members }) => {
  console.log('Group created:', groupName);
  addGroupToUI({ groupId, groupName, members });
});

socket.on('userJoinedGroup', ({ groupId, userId }) => {
  console.log(`${userId} joined group ${groupId}`);
  updateGroupMembers(groupId, userId, 'joined');
});

socket.on('userLeftGroup', ({ groupId, userId }) => {
  console.log(`${userId} left group ${groupId}`);
  updateGroupMembers(groupId, userId, 'left');
});

socket.on('groupDeleted', (groupId) => {
  console.log('Group deleted:', groupId);
  removeGroupFromUI(groupId);
});
```

---

## Typing Indicators

### Server Implementation

```javascript
io.on('connection', (socket) => {
  // Private chat typing
  socket.on('typing', ({ recipientId }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    
    if (recipientSocketId) {
      io.to(recipientSocketId).emit('userTyping', {
        userId: socket.userId,
        isTyping: true
      });
    }
  });
  
  socket.on('stopTyping', ({ recipientId }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    
    if (recipientSocketId) {
      io.to(recipientSocketId).emit('userTyping', {
        userId: socket.userId,
        isTyping: false
      });
    }
  });
  
  // Group chat typing
  socket.on('groupTyping', ({ groupId }) => {
    socket.to(groupId).emit('userTypingInGroup', {
      groupId,
      userId: socket.userId,
      isTyping: true
    });
  });
  
  socket.on('groupStopTyping', ({ groupId }) => {
    socket.to(groupId).emit('userTypingInGroup', {
      groupId,
      userId: socket.userId,
      isTyping: false
    });
  });
});
```

### Client Implementation

```javascript
let typingTimeout;

// Handle input for typing indicator
function handleMessageInput(recipientId) {
  // Emit typing event
  socket.emit('typing', { recipientId });
  
  // Clear previous timeout
  clearTimeout(typingTimeout);
  
  // Stop typing after 2 seconds of inactivity
  typingTimeout = setTimeout(() => {
    socket.emit('stopTyping', { recipientId });
  }, 2000);
}

// Message sent - stop typing
function onMessageSent(recipientId) {
  clearTimeout(typingTimeout);
  socket.emit('stopTyping', { recipientId });
}

// Display typing indicator
socket.on('userTyping', ({ userId, isTyping }) => {
  const indicator = document.getElementById(`typing-${userId}`);
  
  if (isTyping) {
    indicator.textContent = `${userId} is typing...`;
    indicator.style.display = 'block';
  } else {
    indicator.style.display = 'none';
  }
});

// Group typing
function handleGroupInput(groupId) {
  socket.emit('groupTyping', { groupId });
  
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    socket.emit('groupStopTyping', { groupId });
  }, 2000);
}

socket.on('userTypingInGroup', ({ groupId, userId, isTyping }) => {
  const indicator = document.getElementById(`group-typing-${groupId}`);
  
  if (isTyping) {
    indicator.textContent = `${userId} is typing...`;
    indicator.style.display = 'block';
  } else {
    indicator.style.display = 'none';
  }
});
```

---

## Complete Chat Application

### Server (chatApp.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const jwt = require('jsonwebtoken');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

const JWT_SECRET = 'secret';
const onlineUsers = new Map();
const groupChats = new Map();

// Authentication middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication required'));
  }
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.userId = decoded.userId;
    socket.username = decoded.username;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});

io.on('connection', (socket) => {
  console.log(`${socket.username} connected`);
  
  // Add to online users
  onlineUsers.set(socket.userId, socket.id);
  
  // Notify others
  socket.broadcast.emit('userOnline', {
    userId: socket.userId,
    username: socket.username
  });
  
  // Send online users to new user
  socket.emit('onlineUsers', Array.from(onlineUsers.keys()));
  
  // ========== PRIVATE MESSAGES ==========
  socket.on('privateMessage', ({ recipientId, message }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    
    const messageData = {
      from: socket.userId,
      fromUsername: socket.username,
      message,
      timestamp: new Date()
    };
    
    if (recipientSocketId) {
      // Send to recipient
      io.to(recipientSocketId).emit('privateMessage', messageData);
      
      // Confirm to sender
      socket.emit('messageSent', {
        ...messageData,
        to: recipientId,
        status: 'delivered'
      });
    } else {
      socket.emit('messageSent', {
        ...messageData,
        to: recipientId,
        status: 'pending'
      });
    }
  });
  
  // ========== GROUP CHAT ==========
  socket.on('createGroup', ({ groupName, members }) => {
    const groupId = `group-${Date.now()}`;
    groupChats.set(groupId, {
      name: groupName,
      members: new Set([...members, socket.userId]),
      createdBy: socket.userId
    });
    
    // Join room
    socket.join(groupId);
    
    // Notify members
    members.forEach(memberId => {
      const socketId = onlineUsers.get(memberId);
      if (socketId) {
        io.sockets.sockets.get(socketId)?.join(groupId);
      }
    });
    
    io.to(groupId).emit('groupCreated', {
      groupId,
      groupName,
      members: [...members, socket.userId],
      createdBy: socket.userId
    });
  });
  
  socket.on('groupMessage', ({ groupId, message }) => {
    io.to(groupId).emit('groupMessage', {
      groupId,
      from: socket.userId,
      fromUsername: socket.username,
      message,
      timestamp: new Date()
    });
  });
  
  // ========== TYPING INDICATORS ==========
  socket.on('typing', ({ recipientId }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    if (recipientSocketId) {
      io.to(recipientSocketId).emit('userTyping', {
        userId: socket.userId,
        username: socket.username
      });
    }
  });
  
  socket.on('stopTyping', ({ recipientId }) => {
    const recipientSocketId = onlineUsers.get(recipientId);
    if (recipientSocketId) {
      io.to(recipientSocketId).emit('userStopTyping', {
        userId: socket.userId
      });
    }
  });
  
  socket.on('groupTyping', ({ groupId }) => {
    socket.to(groupId).emit('userTypingInGroup', {
      groupId,
      userId: socket.userId,
      username: socket.username
    });
  });
  
  socket.on('groupStopTyping', ({ groupId }) => {
    socket.to(groupId).emit('userStopTypingInGroup', {
      groupId,
      userId: socket.userId
    });
  });
  
  // ========== READ RECEIPTS ==========
  socket.on('messageRead', ({ senderId, messageId }) => {
    const senderSocketId = onlineUsers.get(senderId);
    if (senderSocketId) {
      io.to(senderSocketId).emit('messageRead', {
        readBy: socket.userId,
        messageId,
        timestamp: new Date()
      });
    }
  });
  
  // ========== DISCONNECTION ==========
  socket.on('disconnect', () => {
    onlineUsers.delete(socket.userId);
    socket.broadcast.emit('userOffline', {
      userId: socket.userId,
      username: socket.username
    });
    console.log(`${socket.username} disconnected`);
  });
});

server.listen(5000, () => {
  console.log('Chat server running on port 5000');
});
```

---

## Interview Questions

**Q1: How to implement private messaging?**
- Store online users in a Map: `{ userId: socketId }`
- Look up recipient's socket ID
- Use `io.to(socketId).emit()` to send message

**Q2: How to implement group chat?**
- Use Socket.io rooms
- `socket.join(groupId)` to join group
- `io.to(groupId).emit()` to broadcast to group

**Q3: How do typing indicators work?**
- Client emits `typing` event on input
- Server forwards to recipient(s)
- Auto-stop typing after timeout (e.g., 2 seconds)
- Clear on message send or stop typing

**Q4: How to handle offline users?**
- Check if user is in online users Map
- If offline, save message to database
- Send pending messages when user comes online

**Q5: What's the difference between private and group chat?**
- **Private**: Direct socket-to-socket using `io.to(socketId)`
- **Group**: Using rooms with `io.to(roomId)` for multiple users

---

## Best Practices

1. **Store messages** in database for persistence
2. **Implement read receipts** for better UX
3. **Add message status** (sent, delivered, read)
4. **Validate input** to prevent XSS attacks
5. **Rate limit** to prevent spam
6. **Use acknowledgments** for critical messages
7. **Handle offline users** gracefully
8. **Implement pagination** for message history
9. **Add file sharing** for rich chat experience
10. **Monitor performance** for scaling needs

---

## Summary

- **Private Chat**: Direct messaging using socket IDs
- **Group Chat**: Multi-user chat using rooms
- **Typing Indicators**: Real-time feedback for better UX
- **Online Users**: Track with Map of userId â†’ socketId
- **Message Status**: Sent, delivered, read, pending
- **Read Receipts**: Acknowledge message viewing
- **Rooms**: `socket.join(groupId)` for groups
- **Broadcasting**: `io.to(room).emit()` for group messages
- **Offline Handling**: Save messages to database
- **Best Practice**: Authenticate, validate, persist messages
