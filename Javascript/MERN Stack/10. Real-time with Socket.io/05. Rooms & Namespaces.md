# 05. Rooms & Namespaces

## Introduction

**Rooms** and **Namespaces** are powerful Socket.io features for organizing and segregating connections. They enable targeted broadcasting, feature separation, and efficient communication management.

---

## Rooms

### What are Rooms?

Rooms are server-side channels that sockets can join and leave. They enable broadcasting to specific groups of clients.

```
Server
  ├─ Room: "room1"
  │   ├─ Socket A
  │   └─ Socket B
  ├─ Room: "room2"
  │   ├─ Socket C
  │   └─ Socket D
  └─ Room: "room3"
      └─ Socket E
```

### Joining Rooms

```javascript
// Server
io.on('connection', (socket) => {
  // Join a room
  socket.join('room1');
  console.log(`${socket.id} joined room1`);
  
  // Join multiple rooms
  socket.join(['room1', 'room2', 'room3']);
  
  // Join with callback (Socket.io v3+)
  socket.join('room1', () => {
    console.log('Joined successfully');
  });
  
  // Dynamic room joining
  socket.on('joinRoom', (roomName) => {
    socket.join(roomName);
    socket.emit('joinedRoom', roomName);
  });
});
```

### Leaving Rooms

```javascript
// Leave a room
socket.leave('room1');

// Leave with callback
socket.leave('room1', () => {
  console.log('Left room1');
});

// On disconnect, socket automatically leaves all rooms
socket.on('disconnect', () => {
  console.log('Socket left all rooms');
});
```

### Broadcasting to Rooms

```javascript
io.on('connection', (socket) => {
  socket.join('gameRoom');
  
  // Send to all in room (including sender)
  io.to('gameRoom').emit('message', 'Hello room!');
  
  // Send to all in room (except sender)
  socket.to('gameRoom').emit('message', 'Hello others!');
  
  // Send to multiple rooms
  socket.to('room1').to('room2').emit('multiRoomMessage', 'Hello!');
  
  // Alternative syntax (same as io.to())
  io.in('gameRoom').emit('message', 'Hello!');
});
```

### Getting Room Information

```javascript
// Get all rooms
const rooms = io.sockets.adapter.rooms;
console.log('All rooms:', rooms);

// Get sockets in a room
const socketsInRoom = io.sockets.adapter.rooms.get('room1');
if (socketsInRoom) {
  console.log('Sockets in room1:', socketsInRoom.size);
  socketsInRoom.forEach(socketId => {
    console.log('Socket:', socketId);
  });
}

// Get rooms a socket is in
const socketRooms = socket.rooms;
console.log('Socket is in rooms:', socketRooms);
// Note: Every socket is automatically in a room with its own socket.id

// Count clients in room
const clientCount = io.sockets.adapter.rooms.get('room1')?.size || 0;
console.log('Clients in room1:', clientCount);
```

---

## Chat Room Example

### Server (chatServer.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

// Store active rooms and users
const chatRooms = new Map();

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // Join room
  socket.on('joinRoom', ({ username, room }) => {
    socket.join(room);
    socket.username = username;
    socket.currentRoom = room;
    
    // Store user in room
    if (!chatRooms.has(room)) {
      chatRooms.set(room, new Set());
    }
    chatRooms.get(room).add({ id: socket.id, username });
    
    // Notify room
    socket.to(room).emit('userJoined', {
      username,
      timestamp: new Date()
    });
    
    // Send room info to user
    const roomUsers = Array.from(chatRooms.get(room));
    socket.emit('roomInfo', {
      room,
      users: roomUsers
    });
    
    console.log(`${username} joined room: ${room}`);
  });
  
  // Room message
  socket.on('roomMessage', (message) => {
    const room = socket.currentRoom;
    
    io.to(room).emit('message', {
      username: socket.username,
      message,
      timestamp: new Date()
    });
  });
  
  // Leave room
  socket.on('leaveRoom', () => {
    const room = socket.currentRoom;
    
    if (room) {
      socket.leave(room);
      
      // Remove from room map
      const roomSet = chatRooms.get(room);
      if (roomSet) {
        roomSet.delete({ id: socket.id, username: socket.username });
        if (roomSet.size === 0) {
          chatRooms.delete(room);
        }
      }
      
      // Notify room
      socket.to(room).emit('userLeft', {
        username: socket.username,
        timestamp: new Date()
      });
      
      socket.currentRoom = null;
      console.log(`${socket.username} left room: ${room}`);
    }
  });
  
  // Disconnect
  socket.on('disconnect', () => {
    const room = socket.currentRoom;
    
    if (room) {
      socket.to(room).emit('userLeft', {
        username: socket.username,
        timestamp: new Date()
      });
    }
    
    console.log('User disconnected:', socket.id);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

---

## Namespaces

### What are Namespaces?

Namespaces provide **separate communication channels** on the same server. Each namespace has its own events, rooms, and middleware.

```
Server (http://localhost:5000)
  ├─ Namespace: "/" (default)
  │   ├─ Socket A
  │   └─ Socket B
  ├─ Namespace: "/admin"
  │   └─ Socket C
  └─ Namespace: "/chat"
      ├─ Socket D
      └─ Socket E
```

### Creating Namespaces (Server)

```javascript
const io = require('socket.io')(server);

// Default namespace "/"
io.on('connection', (socket) => {
  console.log('Connected to default namespace');
});

// Create custom namespace "/admin"
const adminNamespace = io.of('/admin');
adminNamespace.on('connection', (socket) => {
  console.log('Connected to admin namespace:', socket.id);
  
  socket.on('adminAction', (data) => {
    console.log('Admin action:', data);
  });
});

// Create namespace "/chat"
const chatNamespace = io.of('/chat');
chatNamespace.on('connection', (socket) => {
  console.log('Connected to chat namespace:', socket.id);
  
  socket.on('chatMessage', (message) => {
    chatNamespace.emit('newMessage', message);
  });
});
```

### Connecting to Namespaces (Client)

```javascript
// Connect to default namespace
const defaultSocket = io('http://localhost:5000');

// Connect to admin namespace
const adminSocket = io('http://localhost:5000/admin');

adminSocket.on('connect', () => {
  console.log('Connected to admin namespace');
});

// Connect to chat namespace
const chatSocket = io('http://localhost:5000/chat');

chatSocket.on('connect', () => {
  console.log('Connected to chat namespace');
});

chatSocket.emit('chatMessage', 'Hello chat!');
```

### Namespace Middleware

```javascript
// Middleware for specific namespace
const adminNamespace = io.of('/admin');

adminNamespace.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (isAdmin(token)) {
    next();
  } else {
    next(new Error('Admin access required'));
  }
});

adminNamespace.on('connection', (socket) => {
  console.log('Admin connected:', socket.id);
});
```

### Dynamic Namespaces

```javascript
// Create namespaces dynamically based on pattern
io.of(/^\/team-\w+$/).on('connection', (socket) => {
  const namespace = socket.nsp.name; // e.g., "/team-alpha"
  console.log(`Connected to ${namespace}`);
  
  socket.on('teamMessage', (message) => {
    socket.nsp.emit('message', message); // Broadcast to this namespace
  });
});

// Client connects to dynamic namespace
const teamSocket = io('http://localhost:5000/team-alpha');
```

---

## Rooms vs Namespaces

| Feature | Rooms | Namespaces |
|---------|-------|------------|
| **Purpose** | Group sockets within namespace | Separate communication channels |
| **Scope** | Server-side only | Client & Server |
| **Connection** | Join/leave dynamically | Separate client connection |
| **Events** | Shared with namespace | Separate event handlers |
| **Middleware** | Shared with namespace | Separate middleware |
| **URL** | N/A | Different URL paths |
| **Use case** | Chat rooms, game lobbies | Admin panel, different features |

---

## Complete Multi-Namespace Example

### Server (multiNamespace.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

// ========== DEFAULT NAMESPACE (/) ==========
io.on('connection', (socket) => {
  console.log('Main connection:', socket.id);
  
  socket.on('mainMessage', (data) => {
    io.emit('mainBroadcast', data);
  });
});

// ========== CHAT NAMESPACE (/chat) ==========
const chatNamespace = io.of('/chat');

chatNamespace.on('connection', (socket) => {
  console.log('Chat connection:', socket.id);
  
  // Join room
  socket.on('joinRoom', (room) => {
    socket.join(room);
    socket.currentRoom = room;
    chatNamespace.to(room).emit('userJoined', socket.id);
  });
  
  // Room message
  socket.on('roomMessage', ({ room, message }) => {
    chatNamespace.to(room).emit('message', {
      from: socket.id,
      message
    });
  });
  
  socket.on('disconnect', () => {
    if (socket.currentRoom) {
      chatNamespace.to(socket.currentRoom).emit('userLeft', socket.id);
    }
  });
});

// ========== ADMIN NAMESPACE (/admin) ==========
const adminNamespace = io.of('/admin');

// Admin authentication middleware
adminNamespace.use((socket, next) => {
  const token = socket.handshake.auth.token;
  if (token === 'admin-secret') {
    next();
  } else {
    next(new Error('Admin authentication failed'));
  }
});

adminNamespace.on('connection', (socket) => {
  console.log('Admin connection:', socket.id);
  
  // Send stats
  socket.emit('stats', {
    mainConnections: io.sockets.sockets.size,
    chatConnections: chatNamespace.sockets.size,
    adminConnections: adminNamespace.sockets.size
  });
  
  // Broadcast to all namespaces
  socket.on('globalAnnouncement', (message) => {
    io.emit('announcement', message);
    chatNamespace.emit('announcement', message);
    adminNamespace.emit('announcement', message);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

### Client

```html
<!DOCTYPE html>
<html>
<head>
  <title>Multi-Namespace Client</title>
</head>
<body>
  <h1>Multi-Namespace Socket.io</h1>
  
  <div>
    <h2>Main Namespace</h2>
    <input id="mainInput" placeholder="Main message" />
    <button onclick="sendMain()">Send</button>
    <div id="mainMessages"></div>
  </div>
  
  <div>
    <h2>Chat Namespace</h2>
    <input id="roomInput" placeholder="Room name" />
    <button onclick="joinRoom()">Join Room</button>
    <input id="chatInput" placeholder="Chat message" />
    <button onclick="sendChat()">Send</button>
    <div id="chatMessages"></div>
  </div>
  
  <div>
    <h2>Admin Namespace</h2>
    <button onclick="connectAdmin()">Connect Admin</button>
    <div id="adminStats"></div>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Main namespace
    const mainSocket = io('http://localhost:5000');
    
    mainSocket.on('mainBroadcast', (data) => {
      document.getElementById('mainMessages').innerHTML += `<p>${data}</p>`;
    });
    
    function sendMain() {
      const message = document.getElementById('mainInput').value;
      mainSocket.emit('mainMessage', message);
    }
    
    // Chat namespace
    const chatSocket = io('http://localhost:5000/chat');
    let currentRoom = '';
    
    chatSocket.on('message', (data) => {
      document.getElementById('chatMessages').innerHTML += 
        `<p><strong>${data.from}:</strong> ${data.message}</p>`;
    });
    
    chatSocket.on('userJoined', (userId) => {
      document.getElementById('chatMessages').innerHTML += 
        `<p><em>${userId} joined</em></p>`;
    });
    
    function joinRoom() {
      currentRoom = document.getElementById('roomInput').value;
      chatSocket.emit('joinRoom', currentRoom);
    }
    
    function sendChat() {
      const message = document.getElementById('chatInput').value;
      chatSocket.emit('roomMessage', { room: currentRoom, message });
    }
    
    // Admin namespace
    let adminSocket;
    
    function connectAdmin() {
      adminSocket = io('http://localhost:5000/admin', {
        auth: { token: 'admin-secret' }
      });
      
      adminSocket.on('stats', (stats) => {
        document.getElementById('adminStats').innerHTML = 
          `<p>Main: ${stats.mainConnections}</p>
           <p>Chat: ${stats.chatConnections}</p>
           <p>Admin: ${stats.adminConnections}</p>`;
      });
      
      adminSocket.on('connect_error', (err) => {
        alert('Admin auth failed: ' + err.message);
      });
    }
  </script>
</body>
</html>
```

---

## Interview Questions

**Q1: What are rooms in Socket.io?**
- Server-side channels for grouping sockets
- Enable targeted broadcasting to specific groups
- Sockets can join/leave dynamically

**Q2: How to broadcast to a room?**
```javascript
io.to('roomName').emit('event', data);        // To all in room
socket.to('roomName').emit('event', data);    // To all except sender
```

**Q3: What are namespaces?**
- Separate communication channels on same server
- Different URL paths (e.g., `/admin`, `/chat`)
- Separate events, rooms, and middleware

**Q4: Rooms vs Namespaces?**
- **Rooms**: Grouping within namespace, server-side only
- **Namespaces**: Separate channels, client connects explicitly

**Q5: How to get sockets in a room?**
```javascript
const sockets = io.sockets.adapter.rooms.get('roomName');
const count = sockets?.size || 0;
```

---

## Best Practices

1. **Use rooms** for dynamic grouping (chat rooms, game lobbies)
2. **Use namespaces** for feature separation (admin, public, chat)
3. **Clean up** rooms when empty
4. **Validate** room names to prevent injection
5. **Limit** number of rooms per socket
6. **Use middleware** for namespace authentication
7. **Monitor** room sizes for scaling
8. **Document** room/namespace structure
9. **Avoid** creating too many namespaces
10. **Test** room isolation and broadcasting

---

## Summary

- **Rooms**: Server-side channels for grouping sockets
- **join(room)**: Add socket to room
- **leave(room)**: Remove socket from room
- **to(room).emit()**: Broadcast to room
- **Namespaces**: Separate communication channels
- **io.of('/name')**: Create namespace
- **Client**: `io('url/namespace')` to connect
- **Middleware**: Separate for each namespace
- **Use rooms**: For dynamic groups
- **Use namespaces**: For feature separation
