# 09. Live Updates & Collaboration

## Introduction

Live updates and real-time collaboration enable multiple users to work together simultaneously with instant synchronization. This guide covers live data updates, collaborative editing, cursor tracking, and multi-user interactions.

---

## Live Data Updates

### Real-time Dashboard

```javascript
// Server (dashboardServer.js)
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

// Simulate real-time data
let dashboardData = {
  users: 1250,
  revenue: 45320,
  orders: 342,
  traffic: 8540
};

io.on('connection', (socket) => {
  console.log('Dashboard client connected');
  
  // Send initial data
  socket.emit('dashboardData', dashboardData);
  
  // Subscribe to updates
  socket.on('subscribe', (metrics) => {
    console.log('Subscribed to:', metrics);
    socket.metrics = metrics;
  });
  
  socket.on('disconnect', () => {
    console.log('Dashboard client disconnected');
  });
});

// Simulate data updates
setInterval(() => {
  // Update random metric
  const metrics = ['users', 'revenue', 'orders', 'traffic'];
  const randomMetric = metrics[Math.floor(Math.random() * metrics.length)];
  
  dashboardData[randomMetric] += Math.floor(Math.random() * 100) - 50;
  
  // Broadcast update
  io.emit('dataUpdate', {
    metric: randomMetric,
    value: dashboardData[randomMetric],
    timestamp: new Date()
  });
}, 3000); // Update every 3 seconds

server.listen(5000, () => {
  console.log('Dashboard server running on port 5000');
});
```

```javascript
// Client
const socket = io('http://localhost:5000');
const metrics = {};

// Receive initial data
socket.on('dashboardData', (data) => {
  Object.assign(metrics, data);
  updateDashboard(data);
});

// Subscribe to specific metrics
socket.emit('subscribe', ['users', 'revenue', 'orders']);

// Receive updates
socket.on('dataUpdate', ({ metric, value, timestamp }) => {
  metrics[metric] = value;
  animateUpdate(metric, value);
});

function updateDashboard(data) {
  document.getElementById('users').textContent = data.users;
  document.getElementById('revenue').textContent = `$${data.revenue}`;
  document.getElementById('orders').textContent = data.orders;
  document.getElementById('traffic').textContent = data.traffic;
}

function animateUpdate(metric, value) {
  const element = document.getElementById(metric);
  element.classList.add('updated');
  element.textContent = metric === 'revenue' ? `$${value}` : value;
  
  setTimeout(() => {
    element.classList.remove('updated');
  }, 1000);
}
```

---

## Live Feed (Social Media, News)

### Server Implementation

```javascript
const posts = [];
let postIdCounter = 1;

io.on('connection', (socket) => {
  // Send recent posts
  socket.emit('recentPosts', posts.slice(-20));
  
  // Create post
  socket.on('createPost', ({ content, author }) => {
    const post = {
      id: postIdCounter++,
      content,
      author,
      likes: 0,
      comments: [],
      timestamp: new Date()
    };
    
    posts.push(post);
    
    // Broadcast to all clients
    io.emit('newPost', post);
  });
  
  // Like post
  socket.on('likePost', (postId) => {
    const post = posts.find(p => p.id === postId);
    if (post) {
      post.likes++;
      io.emit('postLiked', { postId, likes: post.likes });
    }
  });
  
  // Comment on post
  socket.on('commentPost', ({ postId, comment, author }) => {
    const post = posts.find(p => p.id === postId);
    if (post) {
      const newComment = { id: Date.now(), author, comment, timestamp: new Date() };
      post.comments.push(newComment);
      
      io.emit('newComment', { postId, comment: newComment });
    }
  });
  
  // Delete post
  socket.on('deletePost', (postId) => {
    const index = posts.findIndex(p => p.id === postId);
    if (index !== -1) {
      posts.splice(index, 1);
      io.emit('postDeleted', postId);
    }
  });
});
```

### Client Implementation

```javascript
const socket = io('http://localhost:5000');
const feed = [];

// Receive recent posts
socket.on('recentPosts', (posts) => {
  feed.push(...posts);
  renderFeed();
});

// New post
socket.on('newPost', (post) => {
  feed.unshift(post); // Add to top
  addPostToUI(post);
  showNotification('New post added');
});

// Post liked
socket.on('postLiked', ({ postId, likes }) => {
  const post = feed.find(p => p.id === postId);
  if (post) {
    post.likes = likes;
    updateLikesUI(postId, likes);
  }
});

// New comment
socket.on('newComment', ({ postId, comment }) => {
  const post = feed.find(p => p.id === postId);
  if (post) {
    post.comments.push(comment);
    addCommentToUI(postId, comment);
  }
});

// Post deleted
socket.on('postDeleted', (postId) => {
  const index = feed.findIndex(p => p.id === postId);
  if (index !== -1) {
    feed.splice(index, 1);
    removePostFromUI(postId);
  }
});

// Create post
function createPost(content, author) {
  socket.emit('createPost', { content, author });
}

// Like post
function likePost(postId) {
  socket.emit('likePost', postId);
}

// Comment
function commentPost(postId, comment, author) {
  socket.emit('commentPost', { postId, comment, author });
}
```

---

## Collaborative Editing (Google Docs Style)

### Server Implementation

```javascript
const documents = new Map(); // { docId: { content, users } }

io.on('connection', (socket) => {
  // Join document
  socket.on('joinDocument', ({ docId, userId, username }) => {
    socket.join(docId);
    socket.docId = docId;
    socket.userId = userId;
    socket.username = username;
    
    // Initialize document if not exists
    if (!documents.has(docId)) {
      documents.set(docId, {
        content: '',
        users: new Map()
      });
    }
    
    const doc = documents.get(docId);
    doc.users.set(userId, { username, socketId: socket.id });
    
    // Send current content
    socket.emit('documentContent', doc.content);
    
    // Notify others
    socket.to(docId).emit('userJoined', {
      userId,
      username,
      users: Array.from(doc.users.values())
    });
    
    // Send active users
    socket.emit('activeUsers', Array.from(doc.users.values()));
  });
  
  // Text change
  socket.on('textChange', ({ content, cursorPosition }) => {
    const doc = documents.get(socket.docId);
    if (doc) {
      doc.content = content;
      
      // Broadcast to others (not sender)
      socket.to(socket.docId).emit('textChanged', {
        userId: socket.userId,
        username: socket.username,
        content,
        cursorPosition
      });
    }
  });
  
  // Cursor movement
  socket.on('cursorMove', ({ position, selection }) => {
    socket.to(socket.docId).emit('cursorMoved', {
      userId: socket.userId,
      username: socket.username,
      position,
      selection
    });
  });
  
  // Leave document
  socket.on('leaveDocument', () => {
    if (socket.docId) {
      const doc = documents.get(socket.docId);
      if (doc) {
        doc.users.delete(socket.userId);
        
        socket.to(socket.docId).emit('userLeft', {
          userId: socket.userId,
          username: socket.username
        });
      }
      
      socket.leave(socket.docId);
    }
  });
  
  // Disconnect
  socket.on('disconnect', () => {
    if (socket.docId) {
      const doc = documents.get(socket.docId);
      if (doc) {
        doc.users.delete(socket.userId);
        
        socket.to(socket.docId).emit('userLeft', {
          userId: socket.userId,
          username: socket.username
        });
      }
    }
  });
});
```

### Client Implementation

```javascript
const socket = io('http://localhost:5000');
const editor = document.getElementById('editor');
const cursors = new Map();
let currentDocId = 'doc-123';
let currentUserId = 'user-' + Math.random().toString(36).substr(2, 9);

// Join document
socket.emit('joinDocument', {
  docId: currentDocId,
  userId: currentUserId,
  username: 'User ' + currentUserId.substr(-4)
});

// Receive document content
socket.on('documentContent', (content) => {
  editor.value = content;
});

// Active users
socket.on('activeUsers', (users) => {
  displayActiveUsers(users);
});

// User joined
socket.on('userJoined', ({ userId, username }) => {
  console.log(`${username} joined the document`);
  showNotification(`${username} joined`);
});

// Text changed by another user
socket.on('textChanged', ({ userId, username, content, cursorPosition }) => {
  // Save current cursor position
  const currentPosition = editor.selectionStart;
  
  // Update content
  editor.value = content;
  
  // Restore cursor position (with adjustment)
  editor.selectionStart = currentPosition;
  editor.selectionEnd = currentPosition;
  
  // Show who made the change
  showChangeIndicator(username);
});

// Cursor moved by another user
socket.on('cursorMoved', ({ userId, username, position, selection }) => {
  updateRemoteCursor(userId, username, position, selection);
});

// User left
socket.on('userLeft', ({ userId, username }) => {
  console.log(`${username} left the document`);
  removeRemoteCursor(userId);
});

// Send text changes
let changeTimeout;
editor.addEventListener('input', () => {
  clearTimeout(changeTimeout);
  
  changeTimeout = setTimeout(() => {
    socket.emit('textChange', {
      content: editor.value,
      cursorPosition: editor.selectionStart
    });
  }, 300); // Debounce 300ms
});

// Send cursor movement
editor.addEventListener('selectionchange', () => {
  socket.emit('cursorMove', {
    position: editor.selectionStart,
    selection: {
      start: editor.selectionStart,
      end: editor.selectionEnd
    }
  });
});

// Helper functions
function updateRemoteCursor(userId, username, position, selection) {
  let cursor = cursors.get(userId);
  
  if (!cursor) {
    cursor = createCursor(userId, username);
    cursors.set(userId, cursor);
  }
  
  // Update cursor position (visual representation)
  // This is simplified - real implementation would calculate pixel position
  cursor.style.top = `${Math.floor(position / 80) * 20}px`;
  cursor.querySelector('.cursor-label').textContent = username;
}

function createCursor(userId, username) {
  const cursor = document.createElement('div');
  cursor.className = 'remote-cursor';
  cursor.innerHTML = `
    <div class="cursor-line"></div>
    <div class="cursor-label">${username}</div>
  `;
  document.getElementById('cursors-container').appendChild(cursor);
  return cursor;
}

function removeRemoteCursor(userId) {
  const cursor = cursors.get(userId);
  if (cursor) {
    cursor.remove();
    cursors.delete(userId);
  }
}
```

---

## Live Whiteboard / Canvas

### Server Implementation

```javascript
const canvases = new Map(); // { canvasId: { strokes: [] } }

io.on('connection', (socket) => {
  // Join canvas
  socket.on('joinCanvas', (canvasId) => {
    socket.join(canvasId);
    socket.canvasId = canvasId;
    
    if (!canvases.has(canvasId)) {
      canvases.set(canvasId, { strokes: [] });
    }
    
    // Send existing strokes
    socket.emit('canvasState', canvases.get(canvasId).strokes);
  });
  
  // Draw stroke
  socket.on('draw', (strokeData) => {
    const canvas = canvases.get(socket.canvasId);
    if (canvas) {
      canvas.strokes.push(strokeData);
      
      // Broadcast to others
      socket.to(socket.canvasId).emit('draw', strokeData);
    }
  });
  
  // Clear canvas
  socket.on('clearCanvas', () => {
    const canvas = canvases.get(socket.canvasId);
    if (canvas) {
      canvas.strokes = [];
      io.to(socket.canvasId).emit('canvasCleared');
    }
  });
  
  // Undo
  socket.on('undo', () => {
    const canvas = canvases.get(socket.canvasId);
    if (canvas && canvas.strokes.length > 0) {
      canvas.strokes.pop();
      io.to(socket.canvasId).emit('canvasState', canvas.strokes);
    }
  });
});
```

### Client Implementation

```javascript
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const socket = io('http://localhost:5000');

let isDrawing = false;
let currentStroke = [];

// Join canvas
socket.emit('joinCanvas', 'canvas-123');

// Receive canvas state
socket.on('canvasState', (strokes) => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  strokes.forEach(stroke => drawStroke(stroke));
});

// Receive draw from others
socket.on('draw', (strokeData) => {
  drawStroke(strokeData);
});

// Canvas cleared
socket.on('canvasCleared', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
});

// Drawing events
canvas.addEventListener('mousedown', (e) => {
  isDrawing = true;
  currentStroke = [{ x: e.offsetX, y: e.offsetY }];
});

canvas.addEventListener('mousemove', (e) => {
  if (!isDrawing) return;
  
  const point = { x: e.offsetX, y: e.offsetY };
  currentStroke.push(point);
  
  // Draw locally
  ctx.lineTo(point.x, point.y);
  ctx.stroke();
});

canvas.addEventListener('mouseup', () => {
  if (isDrawing) {
    isDrawing = false;
    
    // Send stroke to server
    const strokeData = {
      points: currentStroke,
      color: '#000',
      width: 2
    };
    
    socket.emit('draw', strokeData);
    currentStroke = [];
    
    ctx.beginPath();
  }
});

function drawStroke(strokeData) {
  ctx.strokeStyle = strokeData.color;
  ctx.lineWidth = strokeData.width;
  ctx.beginPath();
  
  strokeData.points.forEach((point, index) => {
    if (index === 0) {
      ctx.moveTo(point.x, point.y);
    } else {
      ctx.lineTo(point.x, point.y);
    }
  });
  
  ctx.stroke();
}

// Clear canvas
function clearCanvas() {
  socket.emit('clearCanvas');
}

// Undo
function undo() {
  socket.emit('undo');
}
```

---

## Interview Questions

**Q1: How to implement live updates?**
- Broadcast changes to all connected clients using `io.emit()`
- Store state on server
- Send initial state on connection
- Broadcast incremental updates

**Q2: How to handle collaborative editing conflicts?**
- **Operational Transformation (OT)**: Transform operations based on concurrent changes
- **CRDT (Conflict-free Replicated Data Types)**: Automatically merge changes
- **Last-write-wins**: Simple but may lose data
- **Locking**: Lock sections being edited

**Q3: How to optimize real-time collaboration?**
- **Debounce** frequent events (e.g., text input)
- **Throttle** high-frequency events (e.g., cursor movement)
- Send **deltas** instead of full state
- Use **compression** for large payloads
- Implement **lazy loading** for history

**Q4: How to show user cursors in collaborative editor?**
- Track cursor position for each user
- Broadcast cursor movements
- Render cursors as overlays
- Use different colors for each user

**Q5: How to sync state across multiple clients?**
- Server as source of truth
- Broadcast all changes to connected clients
- Send full state on new connection
- Handle disconnection and reconnection

---

## Best Practices

1. **Debounce/throttle** frequent events
2. **Send deltas** instead of full state when possible
3. **Implement conflict resolution** for concurrent edits
4. **Show user presence** (cursors, selections)
5. **Handle offline mode** with queuing
6. **Optimize payload size** with compression
7. **Use acknowledgments** for critical updates
8. **Implement undo/redo** with history
9. **Version control** for documents
10. **Monitor performance** and scale accordingly

---

## Summary

- **Live Updates**: Broadcast data changes to all clients
- **Dashboard**: Real-time metrics with `io.emit()`
- **Live Feed**: Social media-style updates
- **Collaborative Editing**: Multi-user document editing
- **Cursor Tracking**: Show remote user positions
- **Whiteboard**: Real-time drawing canvas
- **Debouncing**: Reduce event frequency
- **State Sync**: Server as source of truth
- **Conflict Resolution**: OT, CRDT, or last-write-wins
- **Best Practice**: Optimize, debounce, handle conflicts
