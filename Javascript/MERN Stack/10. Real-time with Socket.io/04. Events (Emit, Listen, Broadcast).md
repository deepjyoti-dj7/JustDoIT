# 04. Events (Emit, Listen, Broadcast)

## Introduction

Socket.io uses an event-driven architecture. Events allow clients and servers to communicate by sending and receiving custom messages. This guide covers emitting, listening, broadcasting, and acknowledgments.

---

## Event Basics

### Emit (Send Event)

```javascript
// Send event to the other side
socket.emit('eventName', data);
```

### Listen (Receive Event)

```javascript
// Listen for events
socket.on('eventName', (data) => {
  console.log('Received:', data);
});
```

---

## Server-side Events

### 1. Emit to Sender

```javascript
io.on('connection', (socket) => {
  // Send to the connected client only
  socket.emit('welcome', 'Welcome to the server!');
  
  socket.on('message', (data) => {
    console.log('Received:', data);
    // Reply to sender
    socket.emit('messageReceived', 'Got your message!');
  });
});
```

### 2. Broadcast to All (Except Sender)

```javascript
io.on('connection', (socket) => {
  // Broadcast to everyone except sender
  socket.broadcast.emit('userJoined', {
    userId: socket.id,
    timestamp: new Date()
  });
  
  socket.on('message', (data) => {
    // Send to everyone except sender
    socket.broadcast.emit('newMessage', data);
  });
});
```

### 3. Emit to All Clients

```javascript
io.on('connection', (socket) => {
  socket.on('announcement', (data) => {
    // Send to ALL clients (including sender)
    io.emit('announcement', data);
  });
});
```

### 4. Emit to Specific Socket

```javascript
io.on('connection', (socket) => {
  socket.on('privateMessage', ({ recipientId, message }) => {
    // Send to specific socket by ID
    io.to(recipientId).emit('privateMessage', {
      from: socket.id,
      message: message
    });
  });
});
```

---

## Client-side Events

### Emit to Server

```javascript
const socket = io('http://localhost:5000');

// Send event to server
socket.emit('message', 'Hello Server!');

socket.emit('userAction', {
  type: 'click',
  elementId: 'button1',
  timestamp: Date.now()
});
```

### Listen for Events

```javascript
// Listen for server events
socket.on('welcome', (message) => {
  console.log(message);
});

socket.on('newMessage', (data) => {
  console.log('New message:', data);
});

socket.on('userJoined', (data) => {
  console.log('User joined:', data.userId);
});
```

---

## Event Patterns

### Pattern 1: Request-Response

```javascript
// Client
socket.emit('getUsers');

socket.on('usersList', (users) => {
  console.log('Users:', users);
});

// Server
socket.on('getUsers', () => {
  const users = getUsersFromDatabase();
  socket.emit('usersList', users);
});
```

### Pattern 2: Acknowledgments (Callbacks)

```javascript
// Client sends with callback
socket.emit('message', 'Hello', (response) => {
  console.log('Server acknowledged:', response);
});

// Server acknowledges
socket.on('message', (data, callback) => {
  console.log('Received:', data);
  callback('Message received!'); // Call the callback
});
```

### Pattern 3: Bi-directional Communication

```javascript
// Server
io.on('connection', (socket) => {
  // Server can send
  socket.emit('serverUpdate', 'Update from server');
  
  // And receive
  socket.on('clientUpdate', (data) => {
    console.log('Client update:', data);
  });
});

// Client
socket.on('serverUpdate', (data) => {
  console.log('Server update:', data);
});

socket.emit('clientUpdate', 'Update from client');
```

---

## Broadcasting

### Broadcasting Methods

```javascript
io.on('connection', (socket) => {
  // 1. To sender only
  socket.emit('event', data);
  
  // 2. To all except sender
  socket.broadcast.emit('event', data);
  
  // 3. To all (including sender)
  io.emit('event', data);
  
  // 4. To all in a room except sender
  socket.to('room1').emit('event', data);
  
  // 5. To all in a room (including sender)
  io.to('room1').emit('event', data);
  
  // 6. To multiple rooms
  socket.to('room1').to('room2').emit('event', data);
  
  // 7. To specific socket
  io.to(socketId).emit('event', data);
});
```

### Broadcasting Example: Chat

```javascript
// Server
io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // Notify others about new user
  socket.broadcast.emit('userConnected', {
    userId: socket.id,
    timestamp: new Date()
  });
  
  // Handle chat messages
  socket.on('chatMessage', (message) => {
    // Broadcast to everyone (including sender for UI feedback)
    io.emit('chatMessage', {
      userId: socket.id,
      message: message,
      timestamp: new Date()
    });
  });
  
  // Handle disconnection
  socket.on('disconnect', () => {
    socket.broadcast.emit('userDisconnected', {
      userId: socket.id,
      timestamp: new Date()
    });
  });
});

// Client
socket.on('userConnected', (data) => {
  console.log('User joined:', data.userId);
});

socket.on('chatMessage', (data) => {
  displayMessage(data);
});

socket.on('userDisconnected', (data) => {
  console.log('User left:', data.userId);
});

function sendMessage(text) {
  socket.emit('chatMessage', text);
}
```

---

## Acknowledgments

### Server Acknowledging Client

```javascript
// Client sends message with callback
socket.emit('saveData', { name: 'John', age: 30 }, (response) => {
  if (response.success) {
    console.log('Data saved:', response.id);
  } else {
    console.error('Error:', response.error);
  }
});

// Server processes and acknowledges
socket.on('saveData', (data, callback) => {
  try {
    const result = saveToDatabase(data);
    callback({ success: true, id: result.id });
  } catch (error) {
    callback({ success: false, error: error.message });
  }
});
```

### Client Acknowledging Server

```javascript
// Server sends message with callback
socket.emit('notification', {
  title: 'New Message',
  body: 'You have a new message'
}, (acknowledged) => {
  if (acknowledged) {
    console.log('Client received notification');
  }
});

// Client acknowledges
socket.on('notification', (data, callback) => {
  displayNotification(data);
  callback(true); // Acknowledge receipt
});
```

### Timeout for Acknowledgments

```javascript
// Client with timeout
socket.timeout(5000).emit('getData', (err, response) => {
  if (err) {
    console.error('Request timed out');
  } else {
    console.log('Response:', response);
  }
});

// Server must respond within 5 seconds
socket.on('getData', (callback) => {
  const data = fetchData();
  callback(data);
});
```

---

## Event Management

### Remove Event Listener

```javascript
// Add listener
function messageHandler(data) {
  console.log('Message:', data);
}

socket.on('message', messageHandler);

// Remove specific listener
socket.off('message', messageHandler);

// Remove all listeners for event
socket.off('message');

// Remove all listeners
socket.removeAllListeners();
```

### Once (Listen Once)

```javascript
// Listen for event only once
socket.once('welcome', (message) => {
  console.log('Welcome message:', message);
  // This listener is automatically removed after first trigger
});
```

### Check Listeners

```javascript
// Get all event names
const events = socket.eventNames();
console.log('Registered events:', events);

// Get listener count for event
const count = socket.listenerCount('message');
console.log('Message listeners:', count);
```

---

## Complete Chat Example

### Server (server.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*' }
});

const users = new Map(); // Store connected users

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  // User joins with username
  socket.on('join', (username, callback) => {
    users.set(socket.id, username);
    
    // Notify others
    socket.broadcast.emit('userJoined', {
      userId: socket.id,
      username: username
    });
    
    // Send current users to new user
    const userList = Array.from(users.entries()).map(([id, name]) => ({
      id, username: name
    }));
    
    callback({ success: true, users: userList });
  });
  
  // Chat message
  socket.on('chatMessage', (message) => {
    const username = users.get(socket.id);
    
    // Broadcast to all (including sender)
    io.emit('chatMessage', {
      userId: socket.id,
      username: username,
      message: message,
      timestamp: new Date()
    });
  });
  
  // Private message
  socket.on('privateMessage', ({ recipientId, message }) => {
    const senderName = users.get(socket.id);
    
    // Send to recipient
    io.to(recipientId).emit('privateMessage', {
      from: socket.id,
      fromUsername: senderName,
      message: message,
      timestamp: new Date()
    });
    
    // Send confirmation to sender
    socket.emit('privateMessageSent', {
      to: recipientId,
      message: message
    });
  });
  
  // Typing indicator
  socket.on('typing', () => {
    const username = users.get(socket.id);
    socket.broadcast.emit('userTyping', { userId: socket.id, username });
  });
  
  socket.on('stopTyping', () => {
    socket.broadcast.emit('userStopTyping', { userId: socket.id });
  });
  
  // Disconnection
  socket.on('disconnect', () => {
    const username = users.get(socket.id);
    users.delete(socket.id);
    
    socket.broadcast.emit('userLeft', {
      userId: socket.id,
      username: username
    });
    
    console.log('User disconnected:', socket.id);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

### Client (index.html)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Socket.io Chat</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    #messages { border: 1px solid #ddd; height: 400px; overflow-y: auto; padding: 10px; margin: 10px 0; }
    #messages p { margin: 5px 0; }
    .user-joined { color: green; font-style: italic; }
    .user-left { color: red; font-style: italic; }
    .typing { color: gray; font-style: italic; }
    input[type="text"] { width: 70%; padding: 10px; }
    button { padding: 10px 20px; }
  </style>
</head>
<body>
  <h1>Socket.io Chat</h1>
  
  <div id="login" style="display: block;">
    <input type="text" id="username" placeholder="Enter username" />
    <button onclick="joinChat()">Join Chat</button>
  </div>
  
  <div id="chat" style="display: none;">
    <div id="users"></div>
    <div id="messages"></div>
    <div id="typingIndicator" class="typing"></div>
    <input type="text" id="messageInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io('http://localhost:5000');
    let currentUsername = '';
    let typingTimeout;
    
    // Join chat
    function joinChat() {
      const username = document.getElementById('username').value.trim();
      if (!username) return;
      
      currentUsername = username;
      socket.emit('join', username, (response) => {
        if (response.success) {
          document.getElementById('login').style.display = 'none';
          document.getElementById('chat').style.display = 'block';
          displayUsers(response.users);
        }
      });
    }
    
    // Send message
    function sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      
      if (message) {
        socket.emit('chatMessage', message);
        input.value = '';
        socket.emit('stopTyping');
      }
    }
    
    // Display users
    function displayUsers(users) {
      const usersDiv = document.getElementById('users');
      usersDiv.innerHTML = '<strong>Users:</strong> ' + 
        users.map(u => u.username).join(', ');
    }
    
    // Add message to UI
    function addMessage(text, className = '') {
      const messagesDiv = document.getElementById('messages');
      const p = document.createElement('p');
      p.textContent = text;
      if (className) p.className = className;
      messagesDiv.appendChild(p);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }
    
    // Event listeners
    socket.on('userJoined', (data) => {
      addMessage(`${data.username} joined the chat`, 'user-joined');
    });
    
    socket.on('chatMessage', (data) => {
      const prefix = data.username === currentUsername ? 'You' : data.username;
      addMessage(`${prefix}: ${data.message}`);
    });
    
    socket.on('userTyping', (data) => {
      const indicator = document.getElementById('typingIndicator');
      indicator.textContent = `${data.username} is typing...`;
    });
    
    socket.on('userStopTyping', () => {
      document.getElementById('typingIndicator').textContent = '';
    });
    
    socket.on('userLeft', (data) => {
      addMessage(`${data.username} left the chat`, 'user-left');
    });
    
    // Typing indicator
    document.getElementById('messageInput').addEventListener('input', () => {
      socket.emit('typing');
      
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        socket.emit('stopTyping');
      }, 2000);
    });
    
    // Send on Enter
    document.getElementById('messageInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
  </script>
</body>
</html>
```

---

## Interview Questions

**Q1: What are the main event methods in Socket.io?**
- `emit()`: Send event
- `on()`: Listen for event
- `broadcast.emit()`: Send to all except sender
- `io.emit()`: Send to all clients
- `to(room).emit()`: Send to specific room

**Q2: How do acknowledgments work?**
```javascript
// Sender
socket.emit('event', data, (response) => { /* callback */ });

// Receiver
socket.on('event', (data, callback) => {
  callback(response); // Call the callback
});
```

**Q3: Difference between `socket.emit()` and `io.emit()`?**
- `socket.emit()`: Send to **one** client (the socket)
- `io.emit()`: Send to **all** connected clients

**Q4: How to send to all except sender?**
```javascript
socket.broadcast.emit('event', data);
```

**Q5: How to remove event listeners?**
```javascript
socket.off('eventName', handler); // Remove specific
socket.off('eventName');          // Remove all for event
socket.removeAllListeners();      // Remove all
```

---

## Best Practices

1. **Use meaningful event names** (camelCase)
2. **Validate data** before processing
3. **Use acknowledgments** for critical operations
4. **Clean up listeners** to prevent memory leaks
5. **Handle errors** in event handlers
6. **Limit payload size** to prevent network issues
7. **Use namespaces** to organize events
8. **Document events** for team collaboration
9. **Avoid emitting** in loops (batch instead)
10. **Test event flows** thoroughly

---

## Summary

- **emit()**: Send events to the other side
- **on()**: Listen for events
- **socket.emit()**: Send to sender only
- **socket.broadcast.emit()**: Send to all except sender
- **io.emit()**: Send to all clients
- **io.to(room).emit()**: Send to specific room
- **Acknowledgments**: Callback-based responses
- **once()**: Listen only once
- **off()**: Remove listeners
- **Use cases**: Chat, notifications, real-time updates
