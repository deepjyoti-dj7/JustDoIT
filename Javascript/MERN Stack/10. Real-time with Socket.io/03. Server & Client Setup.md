# 03. Server & Client Setup

## Introduction

Setting up Socket.io involves configuring both server and client sides. This guide covers various setup scenarios including standalone servers, Express integration, and client configurations.

---

## Server Setup

### 1. Standalone Socket.io Server

```javascript
// server.js
const { Server } = require('socket.io');

const io = new Server(3000, {
  cors: {
    origin: '*', // Allow all origins (development only)
    methods: ['GET', 'POST']
  }
});

io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

console.log('Socket.io server running on port 3000');
```

### 2. With Express.js

```javascript
// server.js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app); // Create HTTP server
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000',
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// Express routes
app.get('/', (req, res) => {
  res.send('Server is running');
});

app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok',
    connections: io.engine.clientsCount 
  });
});

// Socket.io connection
io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  socket.on('disconnect', () => {
    console.log('Client disconnected:', socket.id);
  });
});

const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 3. With HTTPS

```javascript
const fs = require('fs');
const https = require('https');
const express = require('express');
const { Server } = require('socket.io');

const app = express();

// SSL certificates
const server = https.createServer({
  key: fs.readFileSync('/path/to/private.key'),
  cert: fs.readFileSync('/path/to/certificate.crt')
}, app);

const io = new Server(server, {
  cors: {
    origin: 'https://yourdomain.com',
    methods: ['GET', 'POST']
  }
});

io.on('connection', (socket) => {
  console.log('Secure connection:', socket.id);
});

server.listen(443);
```

---

## Advanced Server Configuration

### Complete Options

```javascript
const io = new Server(server, {
  // CORS settings
  cors: {
    origin: ['http://localhost:3000', 'https://myapp.com'],
    methods: ['GET', 'POST'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true
  },
  
  // Connection settings
  connectTimeout: 45000,      // Connection timeout (ms)
  pingTimeout: 60000,         // Ping timeout (ms)
  pingInterval: 25000,        // Ping interval (ms)
  
  // Buffer settings
  maxHttpBufferSize: 1e6,     // 1MB max message size
  
  // Transport settings
  transports: ['websocket', 'polling'],
  allowUpgrades: true,        // Allow upgrade from polling to websocket
  
  // Path
  path: '/socket.io/',        // Server path
  
  // Serve client file
  serveClient: true,          // Serve client file at /socket.io/socket.io.js
  
  // Adapter (for scaling)
  // adapter: redisAdapter({ host: 'localhost', port: 6379 })
});
```

### Environment-based Configuration

```javascript
// config/socket.config.js
module.exports = {
  development: {
    cors: {
      origin: '*',
      methods: ['GET', 'POST']
    },
    pingInterval: 25000,
    pingTimeout: 60000
  },
  production: {
    cors: {
      origin: process.env.CLIENT_URL,
      methods: ['GET', 'POST'],
      credentials: true
    },
    pingInterval: 10000,
    pingTimeout: 30000,
    transports: ['websocket'] // Disable polling in production
  }
};

// server.js
const socketConfig = require('./config/socket.config');
const env = process.env.NODE_ENV || 'development';

const io = new Server(server, socketConfig[env]);
```

---

## Client Setup

### 1. Browser (CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Socket.io Client</title>
</head>
<body>
  <!-- Socket.io client library (served by server) -->
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Connect to server
    const socket = io('http://localhost:5000');
    
    socket.on('connect', () => {
      console.log('Connected:', socket.id);
    });
    
    socket.on('disconnect', () => {
      console.log('Disconnected');
    });
  </script>
</body>
</html>
```

### 2. Node.js Client

```javascript
// client.js
const io = require('socket.io-client');

const socket = io('http://localhost:5000', {
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000
});

socket.on('connect', () => {
  console.log('Connected to server');
});

socket.on('disconnect', () => {
  console.log('Disconnected from server');
});
```

### 3. React Client

```javascript
// utils/socket.js
import io from 'socket.io-client';

const SOCKET_URL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5000';

export const socket = io(SOCKET_URL, {
  autoConnect: false, // Don't auto-connect, connect manually
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 20000
});

export const connectSocket = () => {
  if (!socket.connected) {
    socket.connect();
  }
};

export const disconnectSocket = () => {
  if (socket.connected) {
    socket.disconnect();
  }
};
```

```javascript
// App.js
import { useEffect, useState } from 'react';
import { socket, connectSocket, disconnectSocket } from './utils/socket';

function App() {
  const [isConnected, setIsConnected] = useState(false);
  const [socketId, setSocketId] = useState('');
  
  useEffect(() => {
    // Connect to socket
    connectSocket();
    
    // Event listeners
    function onConnect() {
      setIsConnected(true);
      setSocketId(socket.id);
      console.log('Connected:', socket.id);
    }
    
    function onDisconnect() {
      setIsConnected(false);
      setSocketId('');
      console.log('Disconnected');
    }
    
    socket.on('connect', onConnect);
    socket.on('disconnect', onDisconnect);
    
    // Cleanup
    return () => {
      socket.off('connect', onConnect);
      socket.off('disconnect', onDisconnect);
      disconnectSocket();
    };
  }, []);
  
  return (
    <div>
      <h1>Socket.io React App</h1>
      <p>Status: {isConnected ? 'Connected' : 'Disconnected'}</p>
      <p>Socket ID: {socketId || 'N/A'}</p>
    </div>
  );
}

export default App;
```

---

## Client Configuration Options

```javascript
const socket = io('http://localhost:5000', {
  // Connection
  autoConnect: true,            // Auto-connect on creation
  forceNew: false,              // Force new connection
  
  // Reconnection
  reconnection: true,           // Enable reconnection
  reconnectionAttempts: Infinity, // Number of attempts
  reconnectionDelay: 1000,      // Initial delay (ms)
  reconnectionDelayMax: 5000,   // Max delay (ms)
  randomizationFactor: 0.5,     // Randomize delay
  
  // Timeout
  timeout: 20000,               // Connection timeout (ms)
  
  // Transport
  transports: ['websocket', 'polling'],
  upgrade: true,                // Upgrade to websocket
  rememberUpgrade: false,       // Remember transport upgrade
  
  // Path
  path: '/socket.io/',          // Server path
  
  // Query parameters (sent with handshake)
  query: {
    token: 'abc123',
    userId: '12345'
  },
  
  // Extra headers (polling only)
  extraHeaders: {
    'Authorization': 'Bearer token123'
  },
  
  // Cookies
  withCredentials: true,        // Send cookies
  
  // Only websocket (no polling fallback)
  // transports: ['websocket']
});
```

---

## Connection Management

### Manual Connection Control

```javascript
// Create socket without auto-connect
const socket = io('http://localhost:5000', {
  autoConnect: false
});

// Connect manually
socket.connect();
// or
socket.open();

// Disconnect
socket.disconnect();
// or
socket.close();

// Check connection state
if (socket.connected) {
  console.log('Socket is connected');
}

if (socket.disconnected) {
  console.log('Socket is disconnected');
}
```

### Reconnection Logic

```javascript
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;

socket.on('connect', () => {
  console.log('Connected');
  reconnectAttempts = 0; // Reset counter
});

socket.on('disconnect', (reason) => {
  console.log('Disconnected:', reason);
  
  if (reason === 'io server disconnect') {
    // Server forcefully disconnected, reconnect manually
    socket.connect();
  }
  // Otherwise, socket will auto-reconnect
});

socket.on('reconnect_attempt', (attemptNumber) => {
  console.log('Reconnect attempt:', attemptNumber);
  reconnectAttempts = attemptNumber;
});

socket.on('reconnect', (attemptNumber) => {
  console.log('Reconnected after', attemptNumber, 'attempts');
});

socket.on('reconnect_failed', () => {
  console.error('Reconnection failed after', MAX_RECONNECT_ATTEMPTS, 'attempts');
  // Show UI message to user
});
```

---

## Middleware (Server-side)

### Authentication Middleware

```javascript
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication error: No token provided'));
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = decoded.userId; // Attach user info to socket
    next();
  } catch (err) {
    next(new Error('Authentication error: Invalid token'));
  }
});

// Client sends token
const socket = io('http://localhost:5000', {
  auth: {
    token: 'your-jwt-token'
  }
});
```

### Logging Middleware

```javascript
io.use((socket, next) => {
  console.log('Connection attempt from:', socket.handshake.address);
  console.log('User Agent:', socket.handshake.headers['user-agent']);
  console.log('Query params:', socket.handshake.query);
  next();
});
```

### Rate Limiting Middleware

```javascript
const connections = new Map();
const MAX_CONNECTIONS_PER_IP = 5;

io.use((socket, next) => {
  const ip = socket.handshake.address;
  const count = connections.get(ip) || 0;
  
  if (count >= MAX_CONNECTIONS_PER_IP) {
    return next(new Error('Too many connections from this IP'));
  }
  
  connections.set(ip, count + 1);
  
  socket.on('disconnect', () => {
    connections.set(ip, connections.get(ip) - 1);
  });
  
  next();
});
```

---

## Complete Production-Ready Setup

### Server (server.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Create HTTP server
const server = http.createServer(app);

// Socket.io configuration
const io = new Server(server, {
  cors: {
    origin: process.env.CLIENT_URL || 'http://localhost:3000',
    methods: ['GET', 'POST'],
    credentials: true
  },
  pingTimeout: 60000,
  pingInterval: 25000,
  maxHttpBufferSize: 1e6
});

// Authentication middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  
  if (!token) {
    return next(new Error('Authentication required'));
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = decoded.userId;
    socket.username = decoded.username;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});

// Connection handler
io.on('connection', (socket) => {
  console.log(`User connected: ${socket.username} (${socket.id})`);
  
  // Join user-specific room
  socket.join(`user:${socket.userId}`);
  
  // Handle disconnection
  socket.on('disconnect', (reason) => {
    console.log(`User disconnected: ${socket.username} (${reason})`);
  });
  
  // Handle errors
  socket.on('error', (error) => {
    console.error('Socket error:', error);
  });
});

// REST endpoints
app.get('/', (req, res) => {
  res.json({ message: 'Socket.io server is running' });
});

app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    connections: io.engine.clientsCount,
    timestamp: new Date().toISOString()
  });
});

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, closing server...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});
```

---

## Interview Questions

**Q1: How to integrate Socket.io with Express?**
```javascript
const server = http.createServer(app);
const io = new Server(server);
server.listen(PORT); // Not app.listen()
```

**Q2: What is middleware in Socket.io?**
- Functions executed before connection is established
- Used for authentication, logging, validation
- Can reject connections by calling `next(new Error('...'))`

**Q3: How to handle authentication in Socket.io?**
```javascript
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  const user = verifyToken(token);
  if (user) {
    socket.user = user;
    next();
  } else {
    next(new Error('Auth failed'));
  }
});
```

**Q4: What are Socket.io transports?**
- `websocket`: Full-duplex WebSocket
- `polling`: HTTP long-polling fallback
- Auto-upgrades from polling to WebSocket when available

**Q5: How to prevent auto-connection in client?**
```javascript
const socket = io(url, { autoConnect: false });
socket.connect(); // Connect manually
```

---

## Best Practices

1. **Use HTTPS** in production for secure WebSocket (wss://)
2. **Implement authentication** middleware
3. **Set appropriate timeouts** (ping, reconnection)
4. **Handle disconnections** gracefully
5. **Use environment variables** for configuration
6. **Limit message size** to prevent abuse
7. **Clean up listeners** on unmount (React)
8. **Use namespaces** to separate features
9. **Monitor connections** for scaling needs
10. **Test reconnection** scenarios

---

## Summary

- **Server Setup**: Standalone or with Express using `http.createServer()`
- **CORS**: Required for cross-origin connections
- **Middleware**: Authentication, logging, rate limiting
- **Client Setup**: Browser CDN, Node.js, or React
- **Configuration**: CORS, timeouts, transports, reconnection
- **Connection Control**: Manual connect/disconnect
- **Reconnection**: Automatic with configurable delays
- **Production**: HTTPS, authentication, environment variables
