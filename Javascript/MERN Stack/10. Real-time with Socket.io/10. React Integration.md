# 10. React Integration

## Introduction

Integrating Socket.io with React enables building real-time features in modern web applications. This guide covers setup, custom hooks, context API, state management, and best practices for React + Socket.io.

---

## Basic Setup

### Installation

```bash
npm install socket.io-client
```

### Simple Connection

```javascript
// App.js
import { useEffect, useState } from 'react';
import io from 'socket.io-client';

const SOCKET_URL = 'http://localhost:5000';

function App() {
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Create socket connection
    const newSocket = io(SOCKET_URL);
    setSocket(newSocket);
    
    // Connection events
    newSocket.on('connect', () => {
      console.log('Connected:', newSocket.id);
      setIsConnected(true);
    });
    
    newSocket.on('disconnect', () => {
      console.log('Disconnected');
      setIsConnected(false);
    });
    
    // Cleanup on unmount
    return () => {
      newSocket.close();
    };
  }, []);
  
  return (
    <div>
      <h1>Socket.io + React</h1>
      <p>Status: {isConnected ? 'Connected' : 'Disconnected'}</p>
    </div>
  );
}

export default App;
```

---

## Socket Utility (Singleton Pattern)

### utils/socket.js

```javascript
import io from 'socket.io-client';

const SOCKET_URL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:5000';

class SocketService {
  constructor() {
    this.socket = null;
  }
  
  connect(token) {
    if (this.socket?.connected) {
      return this.socket;
    }
    
    this.socket = io(SOCKET_URL, {
      auth: { token },
      autoConnect: false,
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });
    
    this.socket.connect();
    
    return this.socket;
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
    }
  }
  
  emit(event, data) {
    if (this.socket) {
      this.socket.emit(event, data);
    }
  }
  
  on(event, callback) {
    if (this.socket) {
      this.socket.on(event, callback);
    }
  }
  
  off(event, callback) {
    if (this.socket) {
      this.socket.off(event, callback);
    }
  }
  
  getSocket() {
    return this.socket;
  }
}

const socketService = new SocketService();
export default socketService;
```

### Usage

```javascript
import { useEffect } from 'react';
import socketService from './utils/socket';

function App() {
  useEffect(() => {
    const token = localStorage.getItem('authToken');
    const socket = socketService.connect(token);
    
    socket.on('connect', () => {
      console.log('Connected');
    });
    
    return () => {
      socketService.disconnect();
    };
  }, []);
  
  return <div>App</div>;
}
```

---

## Custom Hooks

### useSocket Hook

```javascript
// hooks/useSocket.js
import { useEffect, useState } from 'react';
import io from 'socket.io-client';

const SOCKET_URL = 'http://localhost:5000';

export const useSocket = (url = SOCKET_URL, options = {}) => {
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    const socketInstance = io(url, options);
    setSocket(socketInstance);
    
    socketInstance.on('connect', () => {
      setIsConnected(true);
    });
    
    socketInstance.on('disconnect', () => {
      setIsConnected(false);
    });
    
    return () => {
      socketInstance.close();
    };
  }, [url]);
  
  return { socket, isConnected };
};
```

### useSocketEvent Hook

```javascript
// hooks/useSocketEvent.js
import { useEffect } from 'react';

export const useSocketEvent = (socket, eventName, callback) => {
  useEffect(() => {
    if (!socket) return;
    
    socket.on(eventName, callback);
    
    return () => {
      socket.off(eventName, callback);
    };
  }, [socket, eventName, callback]);
};
```

### Usage Example

```javascript
import { useState } from 'react';
import { useSocket, useSocketEvent } from './hooks';

function Chat() {
  const { socket, isConnected } = useSocket();
  const [messages, setMessages] = useState([]);
  
  // Listen for new messages
  useSocketEvent(socket, 'message', (message) => {
    setMessages(prev => [...prev, message]);
  });
  
  const sendMessage = (text) => {
    if (socket) {
      socket.emit('message', text);
    }
  };
  
  return (
    <div>
      <p>Status: {isConnected ? 'Connected' : 'Disconnected'}</p>
      {messages.map((msg, i) => (
        <div key={i}>{msg}</div>
      ))}
    </div>
  );
}
```

---

## Context API for Socket

### SocketContext.js

```javascript
import { createContext, useContext, useEffect, useState } from 'react';
import io from 'socket.io-client';

const SocketContext = createContext(null);

export const useSocketContext = () => {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocketContext must be used within SocketProvider');
  }
  return context;
};

export const SocketProvider = ({ children, url = 'http://localhost:5000' }) => {
  const [socket, setSocket] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const token = localStorage.getItem('authToken');
    
    const socketInstance = io(url, {
      auth: { token },
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });
    
    socketInstance.on('connect', () => {
      console.log('Socket connected:', socketInstance.id);
      setIsConnected(true);
      setError(null);
    });
    
    socketInstance.on('disconnect', (reason) => {
      console.log('Socket disconnected:', reason);
      setIsConnected(false);
    });
    
    socketInstance.on('connect_error', (err) => {
      console.error('Connection error:', err);
      setError(err.message);
    });
    
    setSocket(socketInstance);
    
    return () => {
      socketInstance.close();
    };
  }, [url]);
  
  const emit = (event, data, callback) => {
    if (socket) {
      socket.emit(event, data, callback);
    }
  };
  
  const value = {
    socket,
    isConnected,
    error,
    emit
  };
  
  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  );
};
```

### App.js

```javascript
import { SocketProvider } from './context/SocketContext';
import Chat from './components/Chat';

function App() {
  return (
    <SocketProvider url="http://localhost:5000">
      <Chat />
    </SocketProvider>
  );
}

export default App;
```

### Component Using Context

```javascript
import { useEffect, useState } from 'react';
import { useSocketContext } from '../context/SocketContext';

function Chat() {
  const { socket, isConnected, emit } = useSocketContext();
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  
  useEffect(() => {
    if (!socket) return;
    
    // Listen for messages
    const handleMessage = (message) => {
      setMessages(prev => [...prev, message]);
    };
    
    socket.on('message', handleMessage);
    
    return () => {
      socket.off('message', handleMessage);
    };
  }, [socket]);
  
  const sendMessage = () => {
    if (input.trim()) {
      emit('message', input);
      setInput('');
    }
  };
  
  return (
    <div>
      <p>Status: {isConnected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}</p>
      
      <div className="messages">
        {messages.map((msg, i) => (
          <div key={i}>{msg}</div>
        ))}
      </div>
      
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
      />
      <button onClick={sendMessage}>Send</button>
    </div>
  );
}

export default Chat;
```

---

## Complete Chat Application

### Server (server.js)

```javascript
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000',
    methods: ['GET', 'POST']
  }
});

const users = new Map();

io.on('connection', (socket) => {
  console.log('User connected:', socket.id);
  
  socket.on('join', (username) => {
    users.set(socket.id, username);
    socket.username = username;
    
    socket.broadcast.emit('userJoined', username);
    socket.emit('usersList', Array.from(users.values()));
  });
  
  socket.on('message', (message) => {
    io.emit('message', {
      username: socket.username,
      text: message,
      timestamp: new Date()
    });
  });
  
  socket.on('typing', () => {
    socket.broadcast.emit('userTyping', socket.username);
  });
  
  socket.on('stopTyping', () => {
    socket.broadcast.emit('userStopTyping', socket.username);
  });
  
  socket.on('disconnect', () => {
    const username = users.get(socket.id);
    users.delete(socket.id);
    socket.broadcast.emit('userLeft', username);
    console.log('User disconnected:', socket.id);
  });
});

server.listen(5000, () => {
  console.log('Server running on port 5000');
});
```

### React Client

```javascript
// App.js
import { useState, useEffect } from 'react';
import io from 'socket.io-client';
import './App.css';

const socket = io('http://localhost:5000');

function App() {
  const [username, setUsername] = useState('');
  const [isJoined, setIsJoined] = useState(false);
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [users, setUsers] = useState([]);
  const [typingUsers, setTypingUsers] = useState(new Set());
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    // Connection events
    socket.on('connect', () => {
      setIsConnected(true);
    });
    
    socket.on('disconnect', () => {
      setIsConnected(false);
    });
    
    // Chat events
    socket.on('usersList', (usersList) => {
      setUsers(usersList);
    });
    
    socket.on('userJoined', (username) => {
      setMessages(prev => [...prev, {
        type: 'system',
        text: `${username} joined the chat`,
        timestamp: new Date()
      }]);
    });
    
    socket.on('message', (message) => {
      setMessages(prev => [...prev, message]);
    });
    
    socket.on('userTyping', (username) => {
      setTypingUsers(prev => new Set(prev).add(username));
    });
    
    socket.on('userStopTyping', (username) => {
      setTypingUsers(prev => {
        const newSet = new Set(prev);
        newSet.delete(username);
        return newSet;
      });
    });
    
    socket.on('userLeft', (username) => {
      setMessages(prev => [...prev, {
        type: 'system',
        text: `${username} left the chat`,
        timestamp: new Date()
      }]);
    });
    
    return () => {
      socket.off('connect');
      socket.off('disconnect');
      socket.off('usersList');
      socket.off('userJoined');
      socket.off('message');
      socket.off('userTyping');
      socket.off('userStopTyping');
      socket.off('userLeft');
    };
  }, []);
  
  const joinChat = () => {
    if (username.trim()) {
      socket.emit('join', username);
      setIsJoined(true);
    }
  };
  
  const sendMessage = () => {
    if (input.trim()) {
      socket.emit('message', input);
      socket.emit('stopTyping');
      setInput('');
    }
  };
  
  const handleTyping = (e) => {
    setInput(e.target.value);
    
    if (e.target.value) {
      socket.emit('typing');
    } else {
      socket.emit('stopTyping');
    }
  };
  
  if (!isJoined) {
    return (
      <div className="join-screen">
        <h1>Join Chat</h1>
        <input
          type="text"
          placeholder="Enter your username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && joinChat()}
        />
        <button onClick={joinChat}>Join</button>
      </div>
    );
  }
  
  return (
    <div className="chat-app">
      <div className="sidebar">
        <h3>Online Users ({users.length})</h3>
        <ul>
          {users.map((user, i) => (
            <li key={i}>{user}</li>
          ))}
        </ul>
      </div>
      
      <div className="chat-container">
        <div className="header">
          <h2>Chat Room</h2>
          <span className={isConnected ? 'status online' : 'status offline'}>
            {isConnected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected'}
          </span>
        </div>
        
        <div className="messages">
          {messages.map((msg, i) => (
            <div key={i} className={`message ${msg.type || 'user'}`}>
              {msg.type === 'system' ? (
                <em>{msg.text}</em>
              ) : (
                <>
                  <strong>{msg.username}:</strong> {msg.text}
                  <span className="timestamp">
                    {new Date(msg.timestamp).toLocaleTimeString()}
                  </span>
                </>
              )}
            </div>
          ))}
        </div>
        
        {typingUsers.size > 0 && (
          <div className="typing-indicator">
            {Array.from(typingUsers).join(', ')} {typingUsers.size === 1 ? 'is' : 'are'} typing...
          </div>
        )}
        
        <div className="input-area">
          <input
            type="text"
            value={input}
            onChange={handleTyping}
            onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
            placeholder="Type a message..."
          />
          <button onClick={sendMessage}>Send</button>
        </div>
      </div>
    </div>
  );
}

export default App;
```

---

## Interview Questions

**Q1: How to integrate Socket.io with React?**
- Install `socket.io-client`
- Create socket instance in `useEffect`
- Clean up with `socket.close()` in cleanup function
- Use state to manage connection status

**Q2: Best practice for socket in React?**
- Use **Context API** for global socket instance
- Create **custom hooks** for reusability
- **Clean up listeners** in useEffect cleanup
- Use **singleton pattern** for single connection

**Q3: How to handle socket events in React?**
```javascript
useEffect(() => {
  if (!socket) return;
  
  const handler = (data) => { /* handle */ };
  socket.on('event', handler);
  
  return () => {
    socket.off('event', handler);
  };
}, [socket]);
```

**Q4: How to prevent multiple socket connections?**
- Use **singleton pattern** or **Context API**
- Create socket outside component or in Context
- Check `socket.connected` before creating new connection

**Q5: How to type Socket.io in TypeScript React?**
```typescript
import { Socket } from 'socket.io-client';

interface ServerToClientEvents {
  message: (data: { text: string }) => void;
}

interface ClientToServerEvents {
  sendMessage: (text: string) => void;
}

const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io(url);
```

---

## Best Practices

1. **Use Context API** for global socket instance
2. **Create custom hooks** for reusability
3. **Clean up listeners** in useEffect cleanup
4. **Handle connection states** (connected, disconnected, error)
5. **Use singleton pattern** to prevent multiple connections
6. **Implement reconnection logic** gracefully
7. **Show connection status** to users
8. **Debounce/throttle** frequent events
9. **Handle authentication** with tokens
10. **Type events** with TypeScript for safety

---

## Summary

- **Installation**: `npm install socket.io-client`
- **Basic Setup**: Create socket in useEffect
- **Cleanup**: Call `socket.close()` in cleanup function
- **Custom Hooks**: `useSocket`, `useSocketEvent`
- **Context API**: Global socket instance
- **Singleton Pattern**: Single connection across app
- **Event Handling**: Add listeners in useEffect
- **Cleanup Listeners**: Use `socket.off()` in cleanup
- **Connection Status**: Track with state
- **Best Practice**: Context + custom hooks + proper cleanup
