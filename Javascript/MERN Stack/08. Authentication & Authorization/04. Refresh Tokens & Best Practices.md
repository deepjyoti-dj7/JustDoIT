# 04. Refresh Tokens & Best Practices

## Introduction

Refresh tokens are a critical component of secure authentication systems. They allow users to obtain new access tokens without re-entering credentials, balancing security and user experience.

---

## Why Refresh Tokens?

### The Problem with Long-Lived Access Tokens
```javascript
// ❌ Bad: Long-lived access token
const token = jwt.sign(
  { userId: user._id },
  process.env.JWT_SECRET,
  { expiresIn: '30d' } // If stolen, attacker has 30 days of access!
);
```

### Problems:
- If token is stolen (XSS, MITM), attacker has prolonged access
- Can't easily revoke access
- Security risk increases with token lifetime

### The Solution: Access + Refresh Tokens

```javascript
// ✅ Good: Short-lived access token + long-lived refresh token
const accessToken = jwt.sign(
  { userId: user._id },
  process.env.JWT_SECRET,
  { expiresIn: '15m' } // Short-lived
);

const refreshToken = jwt.sign(
  { userId: user._id },
  process.env.REFRESH_SECRET,
  { expiresIn: '7d' } // Long-lived
);
```

### Benefits:
✅ Access token expires quickly (limits exposure if stolen)
✅ Refresh token can be stored securely and revoked
✅ Better security without sacrificing UX
✅ Can implement token rotation for extra security

---

## Access Token vs Refresh Token

| Feature | Access Token | Refresh Token |
|---------|--------------|---------------|
| **Lifetime** | Short (5-15 minutes) | Long (days/weeks) |
| **Purpose** | Access protected resources | Obtain new access tokens |
| **Storage** | Memory/localStorage | HttpOnly cookie/Database |
| **Sent With** | Every API request | Only to refresh endpoint |
| **Contains** | User ID, role, permissions | Only user ID |
| **Revocable** | Not easily | Yes (stored in DB) |
| **Security Risk** | Lower (short-lived) | Higher (but mitigated by storage) |

---

## Implementing Refresh Tokens

### 1. Database Schema

```javascript
// models/RefreshToken.js
const mongoose = require('mongoose');

const refreshTokenSchema = new mongoose.Schema({
  token: {
    type: String,
    required: true,
    unique: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  expiresAt: {
    type: Date,
    required: true
  },
  createdByIp: String,
  revokedAt: Date,
  revokedByIp: String,
  replacedByToken: String // For token rotation
}, { timestamps: true });

// Auto-delete expired tokens
refreshTokenSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Check if token is active
refreshTokenSchema.virtual('isActive').get(function() {
  return !this.revokedAt && new Date() < this.expiresAt;
});

module.exports = mongoose.model('RefreshToken', refreshTokenSchema);
```

### 2. Generate Tokens on Login

```javascript
// controllers/authController.js
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const RefreshToken = require('../models/RefreshToken');

const generateAccessToken = (user) => {
  return jwt.sign(
    { 
      id: user._id,
      email: user.email,
      role: user.role 
    },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );
};

const generateRefreshToken = async (user, ipAddress) => {
  // Create refresh token
  const token = jwt.sign(
    { id: user._id },
    process.env.REFRESH_SECRET,
    { expiresIn: '7d' }
  );
  
  // Save to database
  await RefreshToken.create({
    token,
    userId: user._id,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
    createdByIp: ipAddress
  });
  
  return token;
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const ipAddress = req.ip;
    
    // Validate credentials
    const user = await User.findOne({ email }).select('+password');
    if (!user || !(await bcrypt.compare(password, user.password))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate tokens
    const accessToken = generateAccessToken(user);
    const refreshToken = await generateRefreshToken(user, ipAddress);
    
    // Send refresh token as HttpOnly cookie
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });
    
    res.json({
      success: true,
      accessToken,
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

### 3. Refresh Access Token

```javascript
// controllers/authController.js
exports.refreshToken = async (req, res) => {
  try {
    // Get refresh token from cookie
    const { refreshToken } = req.cookies;
    
    if (!refreshToken) {
      return res.status(401).json({ message: 'Refresh token required' });
    }
    
    // Verify refresh token
    let decoded;
    try {
      decoded = jwt.verify(refreshToken, process.env.REFRESH_SECRET);
    } catch (error) {
      return res.status(401).json({ message: 'Invalid refresh token' });
    }
    
    // Check if token exists in database and is active
    const storedToken = await RefreshToken.findOne({ 
      token: refreshToken,
      userId: decoded.id 
    });
    
    if (!storedToken || !storedToken.isActive) {
      return res.status(401).json({ message: 'Invalid or expired refresh token' });
    }
    
    // Get user
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    // Generate new access token
    const accessToken = generateAccessToken(user);
    
    res.json({
      success: true,
      accessToken
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

### 4. Revoke Refresh Token (Logout)

```javascript
exports.logout = async (req, res) => {
  try {
    const { refreshToken } = req.cookies;
    const ipAddress = req.ip;
    
    if (!refreshToken) {
      return res.status(400).json({ message: 'Refresh token required' });
    }
    
    // Revoke token
    await RefreshToken.findOneAndUpdate(
      { token: refreshToken },
      { 
        revokedAt: new Date(),
        revokedByIp: ipAddress 
      }
    );
    
    // Clear cookie
    res.clearCookie('refreshToken');
    
    res.json({ 
      success: true,
      message: 'Logged out successfully' 
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

---

## Token Rotation Strategy

Token rotation generates a new refresh token each time the access token is refreshed, invalidating the old one.

### Why Token Rotation?
✅ Detects token theft (if stolen token is used, legitimate user's request fails)
✅ Limits damage window
✅ Enhanced security

### Implementation

```javascript
exports.refreshToken = async (req, res) => {
  try {
    const { refreshToken: oldToken } = req.cookies;
    const ipAddress = req.ip;
    
    if (!oldToken) {
      return res.status(401).json({ message: 'Refresh token required' });
    }
    
    // Verify and get token from database
    const decoded = jwt.verify(oldToken, process.env.REFRESH_SECRET);
    const storedToken = await RefreshToken.findOne({ 
      token: oldToken,
      userId: decoded.id 
    });
    
    if (!storedToken || !storedToken.isActive) {
      return res.status(401).json({ message: 'Invalid refresh token' });
    }
    
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    // Generate new tokens
    const accessToken = generateAccessToken(user);
    const newRefreshToken = jwt.sign(
      { id: user._id },
      process.env.REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    // Save new refresh token
    await RefreshToken.create({
      token: newRefreshToken,
      userId: user._id,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      createdByIp: ipAddress
    });
    
    // Revoke old refresh token
    await RefreshToken.findByIdAndUpdate(storedToken._id, {
      revokedAt: new Date(),
      revokedByIp: ipAddress,
      replacedByToken: newRefreshToken
    });
    
    // Send new refresh token as cookie
    res.cookie('refreshToken', newRefreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000
    });
    
    res.json({
      success: true,
      accessToken
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

---

## Client-Side Implementation

### Axios Interceptor for Token Refresh

```javascript
// api/axios.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:5000/api',
  withCredentials: true // Send cookies
});

let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

// Request interceptor: Add access token to requests
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor: Handle token refresh
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // If error is 401 and we haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Wait for token refresh to complete
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        })
          .then(token => {
            originalRequest.headers.Authorization = `Bearer ${token}`;
            return api(originalRequest);
          })
          .catch(err => Promise.reject(err));
      }
      
      originalRequest._retry = true;
      isRefreshing = true;
      
      try {
        // Request new access token
        const { data } = await axios.post(
          'http://localhost:5000/api/auth/refresh',
          {},
          { withCredentials: true }
        );
        
        const { accessToken } = data;
        localStorage.setItem('accessToken', accessToken);
        
        // Update authorization header
        api.defaults.headers.common.Authorization = `Bearer ${accessToken}`;
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        
        processQueue(null, accessToken);
        
        return api(originalRequest);
      } catch (refreshError) {
        processQueue(refreshError, null);
        localStorage.removeItem('accessToken');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;
```

### React Hook for Authentication

```javascript
// hooks/useAuth.js
import { useState, useEffect } from 'react';
import api from '../api/axios';

export const useAuth = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is authenticated on mount
    const checkAuth = async () => {
      const token = localStorage.getItem('accessToken');
      if (token) {
        try {
          const { data } = await api.get('/auth/me');
          setUser(data.user);
        } catch (error) {
          localStorage.removeItem('accessToken');
        }
      }
      setLoading(false);
    };
    
    checkAuth();
  }, []);
  
  const login = async (email, password) => {
    const { data } = await api.post('/auth/login', { email, password });
    localStorage.setItem('accessToken', data.accessToken);
    setUser(data.user);
    return data;
  };
  
  const logout = async () => {
    await api.post('/auth/logout');
    localStorage.removeItem('accessToken');
    setUser(null);
  };
  
  return { user, login, logout, loading };
};
```

---

## Best Practices

### 1. Token Lifetimes
```javascript
// ✅ Recommended
const accessToken = jwt.sign(payload, secret, { expiresIn: '15m' });
const refreshToken = jwt.sign(payload, secret, { expiresIn: '7d' });

// For high-security applications
const accessToken = jwt.sign(payload, secret, { expiresIn: '5m' });
const refreshToken = jwt.sign(payload, secret, { expiresIn: '1d' });
```

### 2. Secure Storage
```javascript
// ✅ Access token: Memory or localStorage (will be sent with requests)
localStorage.setItem('accessToken', accessToken);

// ✅ Refresh token: HttpOnly cookie (cannot be accessed by JavaScript)
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000
});
```

### 3. Different Secrets
```javascript
// ✅ Use different secrets for access and refresh tokens
const accessToken = jwt.sign(payload, process.env.JWT_SECRET, ...);
const refreshToken = jwt.sign(payload, process.env.REFRESH_SECRET, ...);
```

### 4. Implement Token Rotation
- Generate new refresh token each time it's used
- Invalidate old refresh token
- Helps detect token theft

### 5. Store Refresh Tokens in Database
- Allows revocation
- Track token usage
- Implement "logout from all devices"

### 6. Rate Limiting on Refresh Endpoint
```javascript
const rateLimit = require('express-rate-limit');

const refreshLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests per windowMs
  message: 'Too many refresh requests, please try again later'
});

app.post('/api/auth/refresh', refreshLimiter, refreshToken);
```

### 7. Revoke on Suspicious Activity
```javascript
const revokeAllUserTokens = async (userId) => {
  await RefreshToken.updateMany(
    { userId, revokedAt: null },
    { revokedAt: new Date() }
  );
};

// Use case: Password change, account compromise
if (user.passwordChangedAt > token.iat) {
  await revokeAllUserTokens(user._id);
}
```

### 8. Clean Up Expired Tokens
```javascript
// Database index for auto-deletion
refreshTokenSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// Or manual cleanup job
const cleanupExpiredTokens = async () => {
  await RefreshToken.deleteMany({
    expiresAt: { $lt: new Date() }
  });
};

// Run daily
setInterval(cleanupExpiredTokens, 24 * 60 * 60 * 1000);
```

---

## Complete Route Setup

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticate } = require('../middleware/auth');

// Public routes
router.post('/register', authController.register);
router.post('/login', authController.login);
router.post('/refresh', authController.refreshToken);

// Protected routes
router.post('/logout', authenticate, authController.logout);
router.get('/me', authenticate, authController.getMe);
router.post('/logout-all', authenticate, authController.logoutAllDevices);

module.exports = router;
```

---

## Interview Questions

**Q1: Why use refresh tokens instead of long-lived access tokens?**
- Short-lived access tokens limit exposure if stolen
- Refresh tokens can be revoked (stored in DB)
- Better security without sacrificing UX

**Q2: Where should you store access tokens vs refresh tokens?**
- **Access token**: localStorage or memory (needs to be accessible to send with requests)
- **Refresh token**: HttpOnly cookie (prevents XSS attacks)

**Q3: What is token rotation?**
- Generating a new refresh token each time it's used
- Invalidates the old refresh token
- Helps detect token theft

**Q4: How do you revoke a refresh token?**
- Store refresh tokens in database with revocation timestamp
- Mark token as revoked when user logs out
- Check token status on refresh requests

**Q5: What happens if both access and refresh tokens expire?**
- User must log in again with credentials
- Clear stored tokens
- Redirect to login page

**Q6: Should access and refresh tokens use the same secret?**
- No, use different secrets for added security
- Prevents issues if one secret is compromised

---

## Summary

- Use **short-lived access tokens** (5-15 minutes) for API requests
- Use **long-lived refresh tokens** (days/weeks) to get new access tokens
- Store access tokens in localStorage, refresh tokens in HttpOnly cookies
- Implement **token rotation** for enhanced security
- Store refresh tokens in **database** for revocation capability
- Use **different secrets** for access and refresh tokens
- Implement **rate limiting** on refresh endpoint
- Handle token refresh **automatically** in Axios interceptor
- **Revoke all tokens** on password change or suspicious activity
- Clean up expired tokens regularly
