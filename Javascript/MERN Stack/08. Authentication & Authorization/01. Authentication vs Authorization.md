# 01. Authentication vs Authorization

## Introduction

Authentication and authorization are two fundamental concepts in application security that work together to protect resources and ensure users can only access what they're allowed to.

---

## What is Authentication?

**Authentication** is the process of verifying **who you are**.

### Key Concepts
- Confirms the identity of a user, device, or system
- Answers: "Are you really who you claim to be?"
- Typically involves credentials (username/password, biometrics, tokens)
- Happens first in the security flow

### Common Authentication Methods

#### 1. **Password-Based Authentication**
```javascript
// Simple password authentication
const authenticateUser = async (username, password) => {
  const user = await User.findOne({ username });
  
  if (!user) {
    throw new Error('User not found');
  }
  
  const isPasswordValid = await bcrypt.compare(password, user.password);
  
  if (!isPasswordValid) {
    throw new Error('Invalid credentials');
  }
  
  return user;
};
```

#### 2. **Token-Based Authentication (JWT)**
```javascript
// JWT authentication
const jwt = require('jsonwebtoken');

const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
};

const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};
```

#### 3. **Multi-Factor Authentication (MFA)**
```javascript
// MFA with TOTP
const speakeasy = require('speakeasy');

const verifyMFA = (secret, token) => {
  return speakeasy.totp.verify({
    secret: secret,
    encoding: 'base32',
    token: token,
    window: 2
  });
};
```

#### 4. **Biometric Authentication**
- Fingerprint scanning
- Facial recognition
- Retina scanning
- Voice recognition

#### 5. **OAuth & Social Login**
- Google, Facebook, GitHub
- Delegates authentication to trusted providers

---

## What is Authorization?

**Authorization** is the process of verifying **what you can do**.

### Key Concepts
- Determines permissions and access levels
- Answers: "What are you allowed to access?"
- Happens after authentication
- Controls what resources a user can view, modify, or delete

### Common Authorization Patterns

#### 1. **Role-Based Access Control (RBAC)**
```javascript
// User model with roles
const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  password: String,
  role: {
    type: String,
    enum: ['user', 'admin', 'moderator'],
    default: 'user'
  }
});

// Authorization middleware
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Access denied. Insufficient permissions.'
      });
    }
    next();
  };
};

// Usage
router.delete('/users/:id', 
  authenticate,
  authorize('admin'),
  deleteUser
);
```

#### 2. **Permission-Based Access Control**
```javascript
// User model with permissions
const userSchema = new mongoose.Schema({
  username: String,
  permissions: [{
    type: String,
    enum: ['read:users', 'write:users', 'delete:users', 'read:posts', 'write:posts']
  }]
});

// Check permissions
const hasPermission = (user, permission) => {
  return user.permissions.includes(permission);
};

// Middleware
const requirePermission = (permission) => {
  return (req, res, next) => {
    if (!hasPermission(req.user, permission)) {
      return res.status(403).json({
        success: false,
        message: `Missing required permission: ${permission}`
      });
    }
    next();
  };
};
```

#### 3. **Resource-Based Authorization**
```javascript
// Check if user owns the resource
const authorizeResourceOwner = async (req, res, next) => {
  const post = await Post.findById(req.params.id);
  
  if (!post) {
    return res.status(404).json({ message: 'Post not found' });
  }
  
  // Only owner or admin can modify
  if (post.author.toString() !== req.user.id && req.user.role !== 'admin') {
    return res.status(403).json({
      message: 'Not authorized to modify this resource'
    });
  }
  
  req.post = post;
  next();
};
```

---

## Authentication vs Authorization: Key Differences

| Aspect | Authentication | Authorization |
|--------|---------------|---------------|
| **Purpose** | Verify identity | Verify permissions |
| **Question** | "Who are you?" | "What can you do?" |
| **Process** | Login with credentials | Check access rights |
| **Order** | Happens first | Happens after authentication |
| **Data Transmitted** | Credentials (username/password) | Access tokens, roles |
| **Examples** | Login, SSO, MFA | RBAC, ACL, Permissions |
| **HTTP Status** | 401 Unauthorized | 403 Forbidden |
| **Changeable** | Less frequently | More frequently |

---

## Complete Authentication & Authorization Flow

```javascript
// 1. User Login (Authentication)
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // AUTHENTICATION: Verify who they are
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate token with user info and role
    const token = jwt.sign(
      { id: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// 2. Authenticate Middleware (Verify JWT)
const authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    req.user = user; // Attach user to request
    next();
  } catch (error) {
    res.status(401).json({ message: 'Invalid token' });
  }
};

// 3. Authorize Middleware (Check Permissions)
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ 
        message: 'Access denied. Insufficient permissions.' 
      });
    }
    next();
  };
};

// 4. Protected Route (Both Authentication & Authorization)
app.delete('/api/users/:id', 
  authenticate,           // First: Verify who you are
  authorize('admin'),     // Second: Verify what you can do
  async (req, res) => {
    // Delete user logic
    await User.findByIdAndDelete(req.params.id);
    res.json({ message: 'User deleted successfully' });
  }
);
```

---

## HTTP Status Codes

### Authentication Errors: **401 Unauthorized**
```javascript
// Invalid credentials, missing token, expired token
res.status(401).json({ message: 'Authentication required' });
```

### Authorization Errors: **403 Forbidden**
```javascript
// User is authenticated but doesn't have permission
res.status(403).json({ message: 'Access denied' });
```

---

## Real-World Example

```javascript
// Banking Application Example

// Authentication: Login to bank account
const loginToBankAccount = async (accountNumber, pin) => {
  const account = await BankAccount.findOne({ accountNumber });
  
  if (!account || !await verifyPin(pin, account.pin)) {
    throw new Error('Authentication failed'); // 401
  }
  
  return generateToken(account.id);
};

// Authorization: Check if user can perform transaction
const canPerformTransaction = (account, transactionType, amount) => {
  // Different account types have different permissions
  if (account.type === 'savings' && transactionType === 'international') {
    return false; // 403: Not authorized
  }
  
  if (account.balance < amount) {
    return false; // 403: Insufficient funds
  }
  
  return true;
};
```

---

## Interview Questions

**Q1: What's the difference between authentication and authorization?**
- **Authentication** verifies identity (who you are)
- **Authorization** verifies permissions (what you can do)
- Authentication happens first, authorization second
- 401 for authentication failures, 403 for authorization failures

**Q2: Can you have authorization without authentication?**
- Generally no, you need to know who someone is before determining what they can access
- Exception: Public resources with limited authorization (rate limiting based on IP)

**Q3: What HTTP status code for authentication vs authorization failures?**
- **401 Unauthorized**: Authentication failed (invalid credentials, missing token)
- **403 Forbidden**: Authorization failed (authenticated but lacking permissions)

**Q4: Give an example of authentication and authorization in a real app.**
- **Authentication**: User logs in with email/password
- **Authorization**: Admin can delete users, regular users cannot

**Q5: What are common authentication methods?**
- Password-based
- Token-based (JWT)
- OAuth/Social login
- Multi-factor authentication (MFA)
- Biometrics

---

## Best Practices

### Authentication
1. **Never store passwords in plain text** - always hash with bcrypt/argon2
2. **Use HTTPS** - encrypt data in transit
3. **Implement rate limiting** - prevent brute force attacks
4. **Use strong password policies** - minimum length, complexity
5. **Implement MFA** - add extra security layer
6. **Secure token storage** - HttpOnly cookies or secure storage
7. **Set token expiration** - limit token lifetime

### Authorization
1. **Principle of least privilege** - grant minimum necessary permissions
2. **Fail securely** - deny by default, allow explicitly
3. **Check permissions server-side** - never trust client
4. **Use role-based access control** - simplify permission management
5. **Validate resource ownership** - users can only access their resources
6. **Log authorization failures** - detect potential attacks
7. **Regular permission audits** - review and update access rights

---

## Summary

- **Authentication** = Identity verification ("Who are you?")
- **Authorization** = Permission verification ("What can you do?")
- Authentication happens first, authorization second
- 401 for auth failures, 403 for authorization failures
- Both are essential for comprehensive security
- Always implement server-side checks
- Use JWT tokens for stateless authentication
- Implement RBAC for scalable authorization
