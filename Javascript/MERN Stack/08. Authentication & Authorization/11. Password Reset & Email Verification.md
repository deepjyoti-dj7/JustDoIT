# 11. Password Reset & Email Verification

## Introduction

Password reset and email verification are critical features for user account security and validation. This guide covers implementing secure, production-ready flows for both.

---

## Password Reset Flow

### Overview

```
User                          Server                        Email Service
 |                               |                                  |
 |-- Request Reset ------------> |                                  |
 |                               |-- Generate Reset Token -------> |
 |                               |-- Send Email -----------------> |
 |<-- Email with Reset Link -----------------                     |
 |                               |                                  |
 |-- Click Reset Link ---------> |                                  |
 |                               |-- Verify Token ------->          |
 |<-- Reset Password Form ---    |                                  |
 |                               |                                  |
 |-- Submit New Password ------> |                                  |
 |                               |-- Hash & Save Password ->       |
 |<-- Success Response --------  |                                  |
```

---

## User Model with Reset Token

```javascript
// models/User.js
const mongoose = require('mongoose');
const crypto = require('crypto');

const userSchema = new mongoose.Schema({
  name: String,
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  passwordResetToken: String,
  passwordResetExpires: Date,
  emailVerificationToken: String,
  emailVerified: {
    type: Boolean,
    default: false
  }
}, { timestamps: true });

// Method to create password reset token
userSchema.methods.createPasswordResetToken = function() {
  // Generate random token
  const resetToken = crypto.randomBytes(32).toString('hex');
  
  // Hash token and set to user
  this.passwordResetToken = crypto
    .createHash('sha256')
    .update(resetToken)
    .digest('hex');
  
  // Set expiration (10 minutes)
  this.passwordResetExpires = Date.now() + 10 * 60 * 1000;
  
  // Return unhashed token (to send via email)
  return resetToken;
};

// Method to create email verification token
userSchema.methods.createEmailVerificationToken = function() {
  const verificationToken = crypto.randomBytes(32).toString('hex');
  
  this.emailVerificationToken = crypto
    .createHash('sha256')
    .update(verificationToken)
    .digest('hex');
  
  return verificationToken;
};

module.exports = mongoose.model('User', userSchema);
```

---

## Password Reset Implementation

### 1. Request Password Reset

```javascript
// controllers/authController.js
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail');

exports.forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    
    // Find user
    const user = await User.findOne({ email });
    
    // Always return success (don't reveal if email exists)
    if (!user) {
      return res.json({
        success: true,
        message: 'If that email exists, we sent a reset link'
      });
    }
    
    // Generate reset token
    const resetToken = user.createPasswordResetToken();
    await user.save({ validateBeforeSave: false });
    
    // Create reset URL
    const resetURL = `${process.env.CLIENT_URL}/reset-password/${resetToken}`;
    
    // Email content
    const message = `
      <h1>Password Reset Request</h1>
      <p>You requested a password reset. Click the link below to reset your password:</p>
      <a href="${resetURL}" target="_blank">Reset Password</a>
      <p>This link expires in 10 minutes.</p>
      <p>If you didn't request this, please ignore this email.</p>
    `;
    
    try {
      await sendEmail({
        to: user.email,
        subject: 'Password Reset Request',
        html: message
      });
      
      res.json({
        success: true,
        message: 'Password reset email sent'
      });
    } catch (emailError) {
      // Clear reset token if email fails
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });
      
      return res.status(500).json({
        success: false,
        message: 'Error sending email. Please try again.'
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### 2. Reset Password

```javascript
exports.resetPassword = async (req, res) => {
  try {
    const { token } = req.params;
    const { password } = req.body;
    
    // Validate password
    if (!password || password.length < 8) {
      return res.status(400).json({
        success: false,
        message: 'Password must be at least 8 characters'
      });
    }
    
    // Hash token from URL
    const hashedToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
    
    // Find user with valid token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() }
    }).select('+password');
    
    if (!user) {
      return res.status(400).json({
        success: false,
        message: 'Invalid or expired reset token'
      });
    }
    
    // Set new password (will be hashed by pre-save hook)
    user.password = password;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    user.passwordChangedAt = Date.now();
    
    await user.save();
    
    // Generate new JWT
    const jwt = require('jsonwebtoken');
    const jwtToken = jwt.sign(
      { id: user._id },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      success: true,
      message: 'Password reset successful',
      token: jwtToken
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

---

## Email Service (Nodemailer)

### Setup

```bash
npm install nodemailer
```

### Configuration

```javascript
// utils/sendEmail.js
const nodemailer = require('nodemailer');

const sendEmail = async (options) => {
  // Create transporter
  const transporter = nodemailer.createTransporter({
    host: process.env.EMAIL_HOST, // e.g., smtp.gmail.com
    port: process.env.EMAIL_PORT, // 587 for TLS
    secure: false, // true for 465, false for other ports
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS
    }
  });
  
  // Email options
  const mailOptions = {
    from: `${process.env.EMAIL_FROM_NAME} <${process.env.EMAIL_FROM}>`,
    to: options.to,
    subject: options.subject,
    html: options.html
  };
  
  // Send email
  await transporter.sendMail(mailOptions);
};

module.exports = sendEmail;
```

### Environment Variables

```env
# Gmail Example
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=your-email@gmail.com
EMAIL_FROM_NAME=Your App Name

# For Gmail, create App Password:
# https://support.google.com/accounts/answer/185833
```

---

## Email Verification Flow

### 1. Send Verification Email on Registration

```javascript
exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    // Create user
    const user = await User.create({
      name,
      email,
      password,
      emailVerified: false
    });
    
    // Generate verification token
    const verificationToken = user.createEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Verification URL
    const verificationURL = `${process.env.CLIENT_URL}/verify-email/${verificationToken}`;
    
    // Send email
    const message = `
      <h1>Welcome to Our App!</h1>
      <p>Please verify your email address by clicking the link below:</p>
      <a href="${verificationURL}" target="_blank">Verify Email</a>
      <p>This link will expire in 24 hours.</p>
    `;
    
    try {
      await sendEmail({
        to: user.email,
        subject: 'Verify Your Email',
        html: message
      });
    } catch (emailError) {
      console.error('Failed to send verification email:', emailError);
    }
    
    // Generate JWT
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    
    res.status(201).json({
      success: true,
      message: 'Registration successful. Please verify your email.',
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        emailVerified: user.emailVerified
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### 2. Verify Email

```javascript
exports.verifyEmail = async (req, res) => {
  try {
    const { token } = req.params;
    
    // Hash token
    const hashedToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
    
    // Find user with token
    const user = await User.findOne({
      emailVerificationToken: hashedToken
    });
    
    if (!user) {
      return res.status(400).json({
        success: false,
        message: 'Invalid verification token'
      });
    }
    
    // Mark email as verified
    user.emailVerified = true;
    user.emailVerificationToken = undefined;
    await user.save({ validateBeforeSave: false });
    
    res.json({
      success: true,
      message: 'Email verified successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### 3. Resend Verification Email

```javascript
exports.resendVerificationEmail = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (user.emailVerified) {
      return res.status(400).json({
        success: false,
        message: 'Email already verified'
      });
    }
    
    // Generate new token
    const verificationToken = user.createEmailVerificationToken();
    await user.save({ validateBeforeSave: false });
    
    // Send email
    const verificationURL = `${process.env.CLIENT_URL}/verify-email/${verificationToken}`;
    
    const message = `
      <h1>Email Verification</h1>
      <p>Click the link below to verify your email:</p>
      <a href="${verificationURL}" target="_blank">Verify Email</a>
    `;
    
    await sendEmail({
      to: user.email,
      subject: 'Verify Your Email',
      html: message
    });
    
    res.json({
      success: true,
      message: 'Verification email sent'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

---

## Routes

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticate } = require('../middleware/auth');

// Password reset
router.post('/forgot-password', authController.forgotPassword);
router.patch('/reset-password/:token', authController.resetPassword);

// Email verification
router.get('/verify-email/:token', authController.verifyEmail);
router.post('/resend-verification', authenticate, authController.resendVerificationEmail);

module.exports = router;
```

---

## Frontend Implementation (React)

### Forgot Password Form

```javascript
import { useState } from 'react';
import axios from 'axios';

const ForgotPassword = () => {
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setMessage('');
    
    try {
      const { data } = await axios.post('/api/auth/forgot-password', { email });
      setMessage(data.message);
    } catch (error) {
      setMessage(error.response?.data?.message || 'An error occurred');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      <h2>Forgot Password</h2>
      <form onSubmit={handleSubmit}>
        <input
          type="email"
          placeholder="Enter your email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Sending...' : 'Send Reset Link'}
        </button>
      </form>
      {message && <p>{message}</p>}
    </div>
  );
};

export default ForgotPassword;
```

### Reset Password Form

```javascript
import { useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import axios from 'axios';

const ResetPassword = () => {
  const { token } = useParams();
  const navigate = useNavigate();
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    
    if (password.length < 8) {
      setError('Password must be at least 8 characters');
      return;
    }
    
    try {
      setLoading(true);
      const { data } = await axios.patch(
        `/api/auth/reset-password/${token}`,
        { password }
      );
      
      localStorage.setItem('token', data.token);
      navigate('/dashboard');
    } catch (err) {
      setError(err.response?.data?.message || 'Reset failed');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      <h2>Reset Password</h2>
      {error && <div className="error">{error}</div>}
      <form onSubmit={handleSubmit}>
        <input
          type="password"
          placeholder="New Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
        <input
          type="password"
          placeholder="Confirm Password"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Resetting...' : 'Reset Password'}
        </button>
      </form>
    </div>
  );
};

export default ResetPassword;
```

---

## Security Best Practices

### 1. Token Security
```javascript
// Use crypto for secure random tokens
const token = crypto.randomBytes(32).toString('hex');

// Hash before storing
const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
```

### 2. Token Expiration
```javascript
// Short expiration for reset tokens
this.passwordResetExpires = Date.now() + 10 * 60 * 1000; // 10 minutes

// Check expiration
if (user.passwordResetExpires < Date.now()) {
  return res.status(400).json({ message: 'Token expired' });
}
```

### 3. Don't Reveal User Existence
```javascript
// Always return success, don't reveal if email exists
if (!user) {
  return res.json({
    success: true,
    message: 'If that email exists, we sent a reset link'
  });
}
```

### 4. Rate Limiting
```javascript
const rateLimit = require('express-rate-limit');

const resetPasswordLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 3,
  message: 'Too many password reset attempts'
});

router.post('/forgot-password', resetPasswordLimiter, authController.forgotPassword);
```

---

## Interview Questions

**Q1: How does password reset flow work?**
1. User requests reset
2. Server generates random token
3. Token hashed and stored with expiration
4. Email sent with unhashed token
5. User clicks link with token
6. Server verifies token and allows password change

**Q2: Why hash the reset token before storing?**
- Protects against database breaches
- If database is compromised, attacker can't use tokens
- Only send unhashed token via email

**Q3: Why use crypto.randomBytes instead of Math.random?**
- `crypto.randomBytes` is cryptographically secure
- `Math.random` is predictable and not secure

**Q4: Should you reveal if an email exists during password reset?**
- No, always return success message
- Prevents user enumeration attacks
- Don't leak information about registered users

**Q5: How long should reset tokens be valid?**
- Short expiration (10-30 minutes)
- Balance security and user experience
- Longer = more risk if token is compromised

---

## Summary

- **Password reset**: Generate token, send email, verify and reset
- Use **crypto.randomBytes** for secure tokens
- **Hash tokens** before storing in database
- Set **short expiration** (10-30 minutes)
- Don't **reveal user existence** in responses
- **Email verification**: Similar flow, mark account as verified
- Use **Nodemailer** for sending emails
- Implement **rate limiting** on reset endpoints
- **Clear tokens** after successful use
- Test reset flow thoroughly
