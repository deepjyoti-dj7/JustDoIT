# 02. Session vs Token Authentication

## Introduction

Session-based and token-based authentication are two fundamental approaches to maintaining user state in web applications. Understanding their differences is crucial for choosing the right authentication strategy.

---

## Session-Based Authentication

### How It Works

1. User logs in with credentials
2. Server validates credentials
3. Server creates a session and stores it (in memory, database, or Redis)
4. Server sends session ID to client via cookie
5. Client includes session ID in subsequent requests
6. Server looks up session data to authenticate requests

### Architecture Diagram
```
Client                    Server                  Session Store
  |                         |                           |
  |------ Login --------->  |                           |
  |                         |---- Create Session -----> |
  |<-- Session Cookie --|  |                           |
  |                         |                           |
  |-- Request + Cookie --> |                           |
  |                         |---- Lookup Session -----> |
  |                         |<--- Session Data -----    |
  |<----- Response -------- |                           |
```

### Implementation Example

#### Server Setup
```javascript
const express = require('express');
const session = require('express-session');
const MongoStore = require('connect-mongo');
const bcrypt = require('bcryptjs');

const app = express();

// Session configuration
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({
    mongoUrl: process.env.MONGO_URI,
    ttl: 24 * 60 * 60 // 1 day
  }),
  cookie: {
    secure: process.env.NODE_ENV === 'production', // HTTPS only in production
    httpOnly: true, // Prevent XSS
    maxAge: 1000 * 60 * 60 * 24 // 1 day
  }
}));

// Login route
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Store user data in session
    req.session.userId = user._id;
    req.session.role = user.role;
    
    res.json({
      success: true,
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Authentication middleware
const requireAuth = (req, res, next) => {
  if (!req.session.userId) {
    return res.status(401).json({ message: 'Authentication required' });
  }
  next();
};

// Protected route
app.get('/api/profile', requireAuth, async (req, res) => {
  const user = await User.findById(req.session.userId);
  res.json({ user });
});

// Logout
app.post('/api/auth/logout', (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      return res.status(500).json({ message: 'Logout failed' });
    }
    res.clearCookie('connect.sid');
    res.json({ message: 'Logged out successfully' });
  });
});
```

#### Session with Redis (Better Performance)
```javascript
const RedisStore = require('connect-redis').default;
const { createClient } = require('redis');

// Create Redis client
const redisClient = createClient({
  url: process.env.REDIS_URL
});
redisClient.connect();

// Session with Redis store
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 * 7 // 7 days
  }
}));
```

### Pros
✅ Session data stored server-side (more secure)
✅ Easy to revoke sessions (just delete from store)
✅ Can store large amounts of data
✅ Mature ecosystem and libraries
✅ Built-in CSRF protection with cookies

### Cons
❌ Requires session storage (memory/database overhead)
❌ Difficult to scale horizontally (session store needed)
❌ CORS complications with cookies
❌ Stateful server (harder to scale)
❌ Not ideal for mobile apps

---

## Token-Based Authentication (JWT)

### How It Works

1. User logs in with credentials
2. Server validates credentials
3. Server creates JWT token with user data
4. Server sends token to client
5. Client stores token (localStorage/sessionStorage)
6. Client includes token in Authorization header
7. Server verifies token signature to authenticate

### Architecture Diagram
```
Client                    Server
  |                         |
  |------ Login --------->  |
  |                         |---- Validate ----
  |                         |---- Sign JWT ----
  |<------- JWT --------|  |
  |                         |
  |-- Request + JWT -----> |
  |                         |---- Verify JWT ---
  |<----- Response -------- |
```

### JWT Structure
```
Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1IiwiaWF0IjoxNjE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### Implementation Example

#### Server Setup
```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const app = express();

// Login route
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Create JWT token
    const token = jwt.sign(
      { 
        id: user._id,
        email: user.email,
        role: user.role 
      },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Authentication middleware
const authenticateToken = async (req, res, next) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
      return res.status(401).json({ message: 'No token provided' });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Optional: Check if user still exists
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }
    
    req.user = decoded; // Attach user data to request
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token expired' });
    }
    res.status(401).json({ message: 'Invalid token' });
  }
};

// Protected route
app.get('/api/profile', authenticateToken, async (req, res) => {
  const user = await User.findById(req.user.id);
  res.json({ user });
});
```

#### Client-Side Usage
```javascript
// Login and store token
const login = async (email, password) => {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password })
  });
  
  const data = await response.json();
  
  if (data.token) {
    localStorage.setItem('token', data.token);
  }
  
  return data;
};

// Make authenticated request
const fetchProfile = async () => {
  const token = localStorage.getItem('token');
  
  const response = await fetch('/api/profile', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  
  return await response.json();
};

// Logout
const logout = () => {
  localStorage.removeItem('token');
};
```

### Pros
✅ Stateless server (easier to scale horizontally)
✅ No session storage needed
✅ Works great for mobile apps and SPAs
✅ CORS-friendly
✅ Can be used across multiple domains
✅ Self-contained (includes user data)

### Cons
❌ Token stored client-side (less secure if XSS vulnerability)
❌ Harder to revoke (must wait for expiration or use blacklist)
❌ Token size larger than session ID
❌ All data sent with every request
❌ Need refresh token strategy for long-term sessions

---

## Session vs Token: Detailed Comparison

| Feature | Session-Based | Token-Based (JWT) |
|---------|---------------|-------------------|
| **State** | Stateful (server stores session) | Stateless (token contains data) |
| **Storage** | Server (Redis, DB, Memory) | Client (localStorage, cookies) |
| **Scalability** | Harder (needs shared session store) | Easier (no server state) |
| **Revocation** | Easy (delete session) | Harder (need blacklist or short expiry) |
| **Data Size** | Small (just session ID) | Larger (entire token) |
| **Cross-Domain** | Difficult (cookie restrictions) | Easy (Authorization header) |
| **Mobile Apps** | Not ideal | Perfect |
| **Security** | More secure (data on server) | Risk if XSS exists |
| **CSRF Protection** | Needed (built-in with cookies) | Not needed (no cookies) |
| **Database Calls** | Required (lookup session) | Optional (data in token) |
| **Expiration** | Sliding (can extend) | Fixed (must refresh) |
| **Best For** | Traditional web apps | SPAs, Mobile, Microservices |

---

## Hybrid Approach: Sessions + JWT

```javascript
// Combine benefits of both
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  
  // Validate credentials
  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) {
    return res.status(401).json({ message: 'Invalid credentials' });
  }
  
  // Create JWT access token (short-lived)
  const accessToken = jwt.sign(
    { id: user._id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );
  
  // Create refresh token (long-lived, stored in session/DB)
  const refreshToken = jwt.sign(
    { id: user._id },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: '7d' }
  );
  
  // Store refresh token in Redis/DB
  await RefreshToken.create({
    token: refreshToken,
    userId: user._id,
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  });
  
  res.json({
    accessToken,
    refreshToken,
    user: { id: user._id, email: user.email }
  });
});

// Refresh access token
app.post('/api/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  // Verify refresh token
  const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
  
  // Check if refresh token exists in DB
  const storedToken = await RefreshToken.findOne({ 
    token: refreshToken,
    userId: decoded.id 
  });
  
  if (!storedToken) {
    return res.status(401).json({ message: 'Invalid refresh token' });
  }
  
  // Generate new access token
  const accessToken = jwt.sign(
    { id: decoded.id },
    process.env.JWT_SECRET,
    { expiresIn: '15m' }
  );
  
  res.json({ accessToken });
});
```

---

## When to Use Each?

### Use Session-Based When:
- Building traditional server-rendered web applications
- Need to easily revoke sessions
- Working with a monolithic architecture
- GDPR compliance requires ability to delete all user data immediately
- Team is more familiar with session management

### Use Token-Based When:
- Building SPAs (React, Vue, Angular)
- Developing mobile applications
- Implementing microservices architecture
- Need cross-domain authentication
- Require stateless, horizontally scalable servers
- Working with third-party API integrations

---

## Security Considerations

### Session-Based Security
```javascript
// Secure session configuration
app.use(session({
  secret: process.env.SESSION_SECRET, // Strong secret
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: true,        // HTTPS only
    httpOnly: true,      // Prevent XSS
    sameSite: 'strict',  // CSRF protection
    maxAge: 1000 * 60 * 60 * 24 // 1 day
  }
}));

// CSRF protection
const csrf = require('csurf');
app.use(csrf());
```

### Token-Based Security
```javascript
// Store tokens securely
// ❌ Bad: localStorage (vulnerable to XSS)
localStorage.setItem('token', token);

// ✅ Better: HttpOnly cookie
res.cookie('token', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000
});

// ✅ Best: Short-lived access token + refresh token
// Access token in memory, refresh token in HttpOnly cookie
```

---

## Interview Questions

**Q1: What's the main difference between session and token authentication?**
- **Session**: Stateful, stores session data on server, sends session ID to client
- **Token**: Stateless, stores data in token itself, no server-side storage

**Q2: Which is more scalable: sessions or tokens?**
- **Tokens** are more scalable because they're stateless
- Sessions require shared session store (Redis) for horizontal scaling

**Q3: How do you revoke a JWT token?**
- Implement token blacklist in Redis
- Use short expiration times
- Implement refresh token rotation
- Store token version in DB and check on each request

**Q4: What's the security difference?**
- **Sessions**: More secure (data on server), but need CSRF protection
- **Tokens**: Risk if XSS exists, but no CSRF risk with Authorization header

**Q5: Can you use both sessions and tokens together?**
- Yes! Hybrid approach: JWT for access tokens (short-lived), sessions/DB for refresh tokens (long-lived, revocable)

**Q6: Where should you store JWT tokens on the client?**
- ❌ localStorage (vulnerable to XSS)
- ✅ Memory (lost on refresh)
- ✅ HttpOnly cookies (best for web)
- ✅ Secure storage (mobile apps)

---

## Summary

- **Session-based**: Stateful, stores data on server, sends session ID via cookie
- **Token-based (JWT)**: Stateless, self-contained tokens, sent via Authorization header
- Sessions easier to revoke, tokens easier to scale
- Sessions better for traditional web apps, tokens better for SPAs and mobile
- Hybrid approach combines benefits: short-lived JWTs + long-lived refresh tokens
- Security critical for both: HTTPS, HttpOnly cookies, XSS/CSRF protection
- Choose based on application architecture and requirements
