# 03. JWT (JSON Web Tokens)

## Introduction

JSON Web Token (JWT) is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object. JWTs are compact, URL-safe, and self-contained tokens used primarily for authentication and information exchange.

---

## What is JWT?

### Key Characteristics
- **Self-contained**: Contains all necessary user information
- **Compact**: Small size, easy to send via URL, POST parameter, or HTTP header
- **Digitally signed**: Ensures integrity and authenticity
- **Stateless**: No need to store session data on server

### Use Cases
1. **Authentication**: Most common use case
2. **Authorization**: Determine what user can access
3. **Information Exchange**: Securely transmit data between parties
4. **Single Sign-On (SSO)**: Share authentication across services

---

## JWT Structure

A JWT consists of three parts separated by dots (.):

```
Header.Payload.Signature
```

### Example JWT
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

---

## Part 1: Header

The header typically consists of two parts:
1. **typ**: Token type (JWT)
2. **alg**: Hashing algorithm (HS256, RS256, etc.)

### Example Header
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

This JSON is Base64Url encoded to form the first part:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

### Common Algorithms
- **HS256** (HMAC SHA256): Symmetric signing (same secret for sign & verify)
- **RS256** (RSA SHA256): Asymmetric signing (private key signs, public key verifies)
- **ES256** (ECDSA SHA256): Elliptic curve digital signature

---

## Part 2: Payload

The payload contains the claims (statements about the user and additional data).

### Types of Claims

#### 1. **Registered Claims** (Reserved, standardized)
```json
{
  "iss": "issuer",           // Who issued the token
  "sub": "subject",          // Subject (user ID)
  "aud": "audience",         // Intended recipient
  "exp": 1735689600,         // Expiration time (Unix timestamp)
  "nbf": 1735603200,         // Not before (Unix timestamp)
  "iat": 1735603200,         // Issued at (Unix timestamp)
  "jti": "unique-token-id"   // JWT ID (unique identifier)
}
```

#### 2. **Public Claims** (Publicly defined)
```json
{
  "name": "John Doe",
  "email": "john@example.com"
}
```

#### 3. **Private Claims** (Custom claims)
```json
{
  "userId": "123456",
  "role": "admin",
  "permissions": ["read", "write", "delete"]
}
```

### Example Payload
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin",
  "iat": 1516239022,
  "exp": 1516242622
}
```

Base64Url encoded:
```
eyJpZCI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9
```

---

## Part 3: Signature

The signature ensures the token hasn't been tampered with.

### How Signature is Created
```javascript
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### Example
```javascript
const signature = HMACSHA256(
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEyMzQ1Njc4OTAiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9",
  "your-256-bit-secret"
);
// Result: SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

---

## Creating JWT Tokens

### Installation
```bash
npm install jsonwebtoken
```

### Basic Token Creation
```javascript
const jwt = require('jsonwebtoken');

// Simple token
const token = jwt.sign(
  { userId: '12345' },           // Payload
  process.env.JWT_SECRET,        // Secret key
  { expiresIn: '1h' }            // Options
);

console.log(token);
// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Advanced Token Creation
```javascript
const createToken = (user) => {
  const payload = {
    sub: user._id,                    // Subject (user ID)
    email: user.email,
    role: user.role,
    permissions: user.permissions,
    iat: Math.floor(Date.now() / 1000)  // Issued at
  };
  
  const options = {
    expiresIn: '15m',                 // Access token expires in 15 minutes
    issuer: 'myapp.com',              // Token issuer
    audience: 'myapp.com'             // Intended audience
  };
  
  return jwt.sign(payload, process.env.JWT_SECRET, options);
};

// Usage
const token = createToken(user);
```

### Token Creation in Login Route
```javascript
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({ 
        success: false,
        message: 'Invalid credentials' 
      });
    }
    
    // Verify password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ 
        success: false,
        message: 'Invalid credentials' 
      });
    }
    
    // Create token
    const token = jwt.sign(
      { 
        id: user._id,
        email: user.email,
        role: user.role 
      },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    // Send response
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      message: error.message 
    });
  }
});
```

---

## Verifying JWT Tokens

### Basic Verification
```javascript
const jwt = require('jsonwebtoken');

try {
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  console.log(decoded);
  // { userId: '12345', iat: 1735603200, exp: 1735606800 }
} catch (error) {
  console.error('Invalid token:', error.message);
}
```

### Verification Middleware
```javascript
const authenticateToken = async (req, res, next) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
      return res.status(401).json({ 
        success: false,
        message: 'No token provided' 
      });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Optional: Verify user still exists
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(401).json({ 
        success: false,
        message: 'User no longer exists' 
      });
    }
    
    // Optional: Check if user changed password after token was issued
    if (user.passwordChangedAt) {
      const passwordChangedTimestamp = parseInt(
        user.passwordChangedAt.getTime() / 1000,
        10
      );
      
      if (decoded.iat < passwordChangedTimestamp) {
        return res.status(401).json({ 
          success: false,
          message: 'Password recently changed. Please login again.' 
        });
      }
    }
    
    // Attach user to request
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ 
        success: false,
        message: 'Token expired' 
      });
    }
    
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ 
        success: false,
        message: 'Invalid token' 
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: 'Token verification failed' 
    });
  }
};

// Usage
app.get('/api/profile', authenticateToken, async (req, res) => {
  const user = await User.findById(req.user.id);
  res.json({ user });
});
```

### Handling Token Errors
```javascript
const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    switch (error.name) {
      case 'TokenExpiredError':
        throw new Error('Token has expired');
      
      case 'JsonWebTokenError':
        throw new Error('Invalid token');
      
      case 'NotBeforeError':
        throw new Error('Token not active yet');
      
      default:
        throw new Error('Token verification failed');
    }
  }
};
```

---

## Decoding vs Verifying

### Decode (Without Verification)
```javascript
// Decode without verifying signature
const decoded = jwt.decode(token);
console.log(decoded);
// Returns payload even if token is invalid or expired
// ⚠️ WARNING: Don't use for authentication!
```

### Verify (With Signature Check)
```javascript
// Verify AND decode
const verified = jwt.verify(token, process.env.JWT_SECRET);
// Throws error if token is invalid or expired
// ✅ Use this for authentication
```

---

## Token Expiration

### Setting Expiration
```javascript
// Different expiration formats
jwt.sign(payload, secret, { expiresIn: '1h' });       // 1 hour
jwt.sign(payload, secret, { expiresIn: '2d' });       // 2 days
jwt.sign(payload, secret, { expiresIn: '30m' });      // 30 minutes
jwt.sign(payload, secret, { expiresIn: 60 * 60 });    // 1 hour (in seconds)
jwt.sign(payload, secret, { expiresIn: '7 days' });   // 7 days
```

### Checking Expiration
```javascript
const isTokenExpired = (token) => {
  try {
    const decoded = jwt.decode(token);
    if (!decoded || !decoded.exp) return true;
    
    const currentTime = Math.floor(Date.now() / 1000);
    return decoded.exp < currentTime;
  } catch (error) {
    return true;
  }
};

if (isTokenExpired(token)) {
  console.log('Token has expired');
}
```

---

## Asymmetric JWT (RS256)

### Generate Keys
```bash
# Generate private key
ssh-keygen -t rsa -b 4096 -m PEM -f private.key

# Generate public key
openssl rsa -in private.key -pubout -outform PEM -out public.key
```

### Sign with Private Key
```javascript
const fs = require('fs');
const privateKey = fs.readFileSync('private.key');

const token = jwt.sign(
  { userId: '12345' },
  privateKey,
  { algorithm: 'RS256', expiresIn: '1h' }
);
```

### Verify with Public Key
```javascript
const publicKey = fs.readFileSync('public.key');

const decoded = jwt.verify(token, publicKey, {
  algorithms: ['RS256']
});
```

### Why Use Asymmetric?
- **Microservices**: Generate tokens in auth service, verify in other services
- **Security**: Services only need public key (can't create tokens)
- **Key Rotation**: Easier to rotate keys

---

## Complete Authentication Example

```javascript
// auth.controller.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const User = require('../models/User');

// Token generation helper
const generateToken = (user) => {
  return jwt.sign(
    { 
      id: user._id,
      email: user.email,
      role: user.role 
    },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
};

// Register
exports.register = async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12);
    
    // Create user
    const user = await User.create({
      name,
      email,
      password: hashedPassword
    });
    
    // Generate token
    const token = generateToken(user);
    
    res.status(201).json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Login
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Verify password
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate token
    const token = generateToken(user);
    
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get current user
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.json({ user });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
```

---

## Interview Questions

**Q1: What are the three parts of a JWT?**
- **Header**: Algorithm and token type
- **Payload**: Claims (user data)
- **Signature**: Ensures integrity

**Q2: What's the difference between jwt.sign() and jwt.verify()?**
- **jwt.sign()**: Creates a new token with payload and secret
- **jwt.verify()**: Validates token signature and returns decoded payload

**Q3: Should you store sensitive data in JWT payload?**
- No! JWT is Base64 encoded (not encrypted), anyone can decode it
- Only store non-sensitive data like user ID, role, email
- Never store passwords, credit cards, or sensitive personal info

**Q4: What's the difference between jwt.decode() and jwt.verify()?**
- **jwt.decode()**: Decodes without verifying signature (unsafe for auth)
- **jwt.verify()**: Verifies signature and decodes (safe for auth)

**Q5: How do you handle expired tokens?**
- Catch `TokenExpiredError`
- Return 401 status
- Client should refresh token or redirect to login

**Q6: HS256 vs RS256?**
- **HS256**: Symmetric (same secret), faster, simpler
- **RS256**: Asymmetric (private/public keys), more secure for distributed systems

**Q7: What claims should you include in JWT?**
- **Required**: `sub` (user ID), `exp` (expiration)
- **Recommended**: `iat` (issued at), `iss` (issuer)
- **Custom**: role, permissions, email (non-sensitive data)

---

## Best Practices

1. **Use Strong Secrets**
   ```javascript
   // ❌ Bad
   const secret = 'mysecret';
   
   // ✅ Good
   const secret = crypto.randomBytes(64).toString('hex');
   ```

2. **Set Appropriate Expiration**
   ```javascript
   // Short-lived access tokens
   const accessToken = jwt.sign(payload, secret, { expiresIn: '15m' });
   
   // Long-lived refresh tokens
   const refreshToken = jwt.sign(payload, secret, { expiresIn: '7d' });
   ```

3. **Never Store Sensitive Data**
   ```javascript
   // ❌ Bad
   jwt.sign({ password: 'secret123' }, secret);
   
   // ✅ Good
   jwt.sign({ userId: '123', role: 'user' }, secret);
   ```

4. **Use HTTPS**
   - Always transmit tokens over HTTPS to prevent interception

5. **Validate Token on Every Request**
   ```javascript
   app.use('/api/protected', authenticateToken);
   ```

6. **Handle Token Errors Properly**
   ```javascript
   try {
     jwt.verify(token, secret);
   } catch (error) {
     if (error.name === 'TokenExpiredError') {
       // Handle expired token
     }
   }
   ```

7. **Use Environment Variables**
   ```javascript
   // ❌ Bad
   jwt.sign(payload, 'hardcoded-secret');
   
   // ✅ Good
   jwt.sign(payload, process.env.JWT_SECRET);
   ```

---

## Summary

- JWT consists of **Header.Payload.Signature**
- Header contains algorithm and type
- Payload contains claims (user data)
- Signature ensures token integrity
- Use `jwt.sign()` to create tokens
- Use `jwt.verify()` to validate tokens (not `jwt.decode()`)
- Set appropriate expiration times
- Never store sensitive data in JWT
- Use HTTPS for transmission
- Store secret in environment variables
- HS256 for simple apps, RS256 for microservices
