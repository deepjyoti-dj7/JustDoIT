# 14. Security Best Practices

## Introduction

Security is paramount in authentication systems. This guide covers essential security best practices to protect your MERN stack application from common vulnerabilities and attacks.

---

## Password Security

### 1. **Password Hashing**

```javascript
// ❌ NEVER store plain text passwords
const user = await User.create({
  email: 'user@example.com',
  password: 'mypassword123' // DANGER!
});

// ✅ Always hash passwords
const bcrypt = require('bcryptjs');
const hashedPassword = await bcrypt.hash('mypassword123', 12);

const user = await User.create({
  email: 'user@example.com',
  password: hashedPassword
});
```

### 2. **Strong Password Policy**

```javascript
const validatePassword = (password) => {
  const minLength = 8;
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  if (password.length < minLength) {
    return { valid: false, error: 'Password must be at least 8 characters' };
  }
  
  if (!hasUppercase || !hasLowercase || !hasNumber || !hasSpecial) {
    return { 
      valid: false, 
      error: 'Password must contain uppercase, lowercase, number, and special character' 
    };
  }
  
  return { valid: true };
};
```

### 3. **Salt Rounds**

```javascript
// ❌ Too low (fast but insecure)
await bcrypt.hash(password, 4);

// ✅ Recommended
await bcrypt.hash(password, 12); // 4,096 iterations
```

---

## JWT Security

### 1. **Use Strong Secrets**

```javascript
// ❌ Weak secret
const JWT_SECRET = 'mysecret';

// ✅ Strong secret (use crypto.randomBytes)
const crypto = require('crypto');
const JWT_SECRET = crypto.randomBytes(64).toString('hex');
// Store in .env file
```

### 2. **Set Appropriate Expiration**

```javascript
// Short-lived access tokens
const accessToken = jwt.sign(
  { id: user._id },
  process.env.JWT_SECRET,
  { expiresIn: '15m' } // 15 minutes
);

// Long-lived refresh tokens
const refreshToken = jwt.sign(
  { id: user._id },
  process.env.REFRESH_SECRET,
  { expiresIn: '7d' } // 7 days
);
```

### 3. **Never Store Sensitive Data in JWT**

```javascript
// ❌ Bad: Sensitive data in token
jwt.sign({
  id: user._id,
  password: user.password,
  creditCard: user.creditCard
}, secret);

// ✅ Good: Only non-sensitive data
jwt.sign({
  id: user._id,
  email: user.email,
  role: user.role
}, secret);
```

### 4. **Validate Tokens Properly**

```javascript
try {
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  
  // Additional checks
  const user = await User.findById(decoded.id);
  
  if (!user) {
    throw new Error('User not found');
  }
  
  if (!user.isActive) {
    throw new Error('Account deactivated');
  }
  
  if (user.passwordChangedAt > decoded.iat * 1000) {
    throw new Error('Password changed after token issued');
  }
} catch (error) {
  // Handle token errors
}
```

---

## HTTPS/SSL

### 1. **Always Use HTTPS in Production**

```javascript
// Redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https' && process.env.NODE_ENV === 'production') {
    res.redirect(`https://${req.header('host')}${req.url}`);
  } else {
    next();
  }
});
```

### 2. **Secure Cookies**

```javascript
res.cookie('token', token, {
  httpOnly: true,      // Prevents XSS
  secure: true,        // HTTPS only
  sameSite: 'strict',  // CSRF protection
  maxAge: 24 * 60 * 60 * 1000 // 24 hours
});
```

---

## Rate Limiting

### Prevent Brute Force Attacks

```javascript
const rateLimit = require('express-rate-limit');

// General API rate limiter
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: 'Too many requests from this IP'
});

// Strict limiter for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 login attempts
  message: 'Too many login attempts. Try again later.',
  skipSuccessfulRequests: true // Don't count successful logins
});

app.use('/api', apiLimiter);
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);
```

---

## Input Validation & Sanitization

### 1. **Validate All Input**

```javascript
const { body, validationResult } = require('express-validator');

const validateLogin = [
  body('email')
    .trim()
    .isEmail()
    .withMessage('Invalid email')
    .normalizeEmail(),
  
  body('password')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters'),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  }
];

app.post('/api/auth/login', validateLogin, loginController);
```

### 2. **Sanitize Input**

```javascript
const validator = require('validator');

// Sanitize user input
const sanitizeInput = (input) => {
  return validator.escape(input.trim());
};

const name = sanitizeInput(req.body.name);
const email = validator.normalizeEmail(req.body.email);
```

---

## SQL/NoSQL Injection Prevention

### MongoDB Injection

```javascript
// ❌ Vulnerable to NoSQL injection
const user = await User.findOne({ email: req.body.email });

// If req.body.email = { $ne: null }, returns first user!

// ✅ Sanitize input
const validator = require('validator');

if (!validator.isEmail(req.body.email)) {
  return res.status(400).json({ message: 'Invalid email' });
}

const user = await User.findOne({ email: req.body.email });
```

### Use Mongoose Schemas

```javascript
// Mongoose schemas provide type validation
const userSchema = new mongoose.Schema({
  email: {
    type: String, // Must be string
    required: true,
    validate: {
      validator: (v) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v),
      message: 'Invalid email'
    }
  }
});
```

---

## XSS (Cross-Site Scripting) Prevention

### 1. **Escape User Input**

```javascript
const validator = require('validator');

// Escape HTML
const safeName = validator.escape(req.body.name);
// "<script>alert('xss')</script>" becomes "&lt;script&gt;alert(&#x27;xss&#x27;)&lt;&#x2F;script&gt;"
```

### 2. **Set Security Headers**

```javascript
const helmet = require('helmet');

app.use(helmet());

// Helmet sets these headers:
// X-Content-Type-Options: nosniff
// X-Frame-Options: DENY
// X-XSS-Protection: 1; mode=block
// Strict-Transport-Security: max-age=31536000; includeSubDomains
```

### 3. **Content Security Policy**

```javascript
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
  }
}));
```

---

## CSRF (Cross-Site Request Forgery) Prevention

### 1. **Use CSRF Tokens (for sessions)**

```javascript
const csrf = require('csurf');

const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});
```

### 2. **SameSite Cookies**

```javascript
res.cookie('token', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict' // Prevents CSRF
});
```

### 3. **JWT with Authorization Header (No CSRF)**

```javascript
// JWTs sent via Authorization header are not vulnerable to CSRF
const token = req.headers.authorization?.split(' ')[1];
```

---

## CORS Configuration

```javascript
const cors = require('cors');

// ❌ Don't allow all origins in production
app.use(cors());

// ✅ Specify allowed origins
const corsOptions = {
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true, // Allow cookies
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));

// ✅ Multiple origins
const allowedOrigins = [
  'http://localhost:3000',
  'https://myapp.com',
  'https://www.myapp.com'
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));
```

---

## Environment Variables

### Never Commit Secrets

```bash
# .env (add to .gitignore)
JWT_SECRET=super-secret-key-change-in-production
REFRESH_SECRET=another-secret-key
MONGO_URI=mongodb://localhost:27017/myapp
EMAIL_PASSWORD=email-password
```

```javascript
// ❌ Bad: Hardcoded secrets
const token = jwt.sign(payload, 'my-secret-key');

// ✅ Good: Use environment variables
const token = jwt.sign(payload, process.env.JWT_SECRET);
```

---

## Error Handling

### Don't Leak Information

```javascript
// ❌ Bad: Exposes implementation details
app.use((err, req, res, next) => {
  res.status(500).json({
    error: err.message,
    stack: err.stack // Leaks server info!
  });
});

// ✅ Good: Generic error in production
app.use((err, req, res, next) => {
  if (process.env.NODE_ENV === 'development') {
    res.status(500).json({
      error: err.message,
      stack: err.stack
    });
  } else {
    res.status(500).json({
      message: 'Internal server error'
    });
  }
});
```

---

## Logging & Monitoring

### Log Security Events

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Log failed login attempts
logger.warn('Failed login attempt', {
  email: req.body.email,
  ip: req.ip,
  timestamp: new Date()
});

// Log successful logins
logger.info('Successful login', {
  userId: user._id,
  ip: req.ip,
  timestamp: new Date()
});

// Log suspicious activity
logger.error('Multiple failed login attempts', {
  email: req.body.email,
  ip: req.ip,
  attempts: 5
});
```

---

## Dependency Security

### 1. **Keep Dependencies Updated**

```bash
# Check for vulnerabilities
npm audit

# Fix vulnerabilities
npm audit fix

# Check for outdated packages
npm outdated

# Update packages
npm update
```

### 2. **Use Security Tools**

```bash
# Install Snyk
npm install -g snyk

# Test for vulnerabilities
snyk test

# Monitor continuously
snyk monitor
```

---

## Security Checklist

### Authentication
- [ ] Hash passwords with bcrypt (salt rounds 12+)
- [ ] Implement strong password policy
- [ ] Use JWT with strong secrets
- [ ] Set appropriate token expiration
- [ ] Implement refresh token rotation
- [ ] Add rate limiting on auth endpoints
- [ ] Implement 2FA for sensitive accounts
- [ ] Validate email addresses
- [ ] Prevent user enumeration

### Authorization
- [ ] Implement RBAC or PBAC
- [ ] Validate permissions server-side
- [ ] Check resource ownership
- [ ] Use middleware for authorization
- [ ] Log authorization failures

### Data Protection
- [ ] Use HTTPS in production
- [ ] Set secure cookie flags
- [ ] Implement CORS properly
- [ ] Sanitize user input
- [ ] Escape output
- [ ] Use parameterized queries
- [ ] Don't expose sensitive data in responses

### Application Security
- [ ] Use Helmet for security headers
- [ ] Implement CSP (Content Security Policy)
- [ ] Protect against CSRF
- [ ] Prevent XSS attacks
- [ ] Prevent SQL/NoSQL injection
- [ ] Rate limit all endpoints
- [ ] Validate and sanitize all input
- [ ] Handle errors securely
- [ ] Log security events

### Infrastructure
- [ ] Keep dependencies updated
- [ ] Run npm audit regularly
- [ ] Use environment variables for secrets
- [ ] Never commit .env files
- [ ] Use different secrets for dev/prod
- [ ] Enable database encryption
- [ ] Regular security audits
- [ ] Monitor for suspicious activity

---

## Summary

- **Hash passwords** with bcrypt (salt rounds 12+)
- Use **HTTPS** in production
- Set **short JWT expiration** with refresh tokens
- Implement **rate limiting** on all endpoints
- **Validate and sanitize** all user input
- Use **Helmet** for security headers
- Implement **CORS** properly
- Store **secrets in environment variables**
- **Log security events** (logins, failures, suspicious activity)
- Keep **dependencies updated** (npm audit)
- Never **leak sensitive information** in errors
- Implement **2FA** for sensitive accounts
- Use **HTTPS-only** and **HttpOnly** cookies
- **Monitor** for vulnerabilities and attacks
