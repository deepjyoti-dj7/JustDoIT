# 12. Two-Factor Authentication (2FA)

## Introduction

Two-Factor Authentication (2FA) adds an extra layer of security by requiring users to provide two forms of identification: something they know (password) and something they have (phone, authenticator app).

---

## Types of 2FA

### 1. **TOTP (Time-Based One-Time Password)**
- Uses authenticator apps (Google Authenticator, Authy)
- Generates 6-digit codes that change every 30 seconds
- Most secure and recommended

### 2. **SMS-Based**
- Sends code via text message
- Less secure (SIM swapping, interception)
- Better than nothing

### 3. **Email-Based**
- Sends code via email
- Least secure
- Good for low-risk applications

### 4. **Hardware Tokens (YubiKey)**
- Physical security keys
- Most secure but requires hardware

---

## TOTP Implementation (Recommended)

### Installation

```bash
npm install speakeasy qrcode
```

### User Model

```javascript
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
  twoFactorEnabled: {
    type: Boolean,
    default: false
  },
  twoFactorSecret: String,
  twoFactorBackupCodes: [String]
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
```

### Setup 2FA

```javascript
// controllers/twoFactorController.js
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');
const User = require('../models/User');
const crypto = require('crypto');

// @desc    Generate 2FA secret and QR code
// @route   POST /api/2fa/setup
// @access  Private
exports.setup2FA = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (user.twoFactorEnabled) {
      return res.status(400).json({
        success: false,
        message: '2FA is already enabled'
      });
    }
    
    // Generate secret
    const secret = speakeasy.generateSecret({
      name: `YourApp (${user.email})`,
      issuer: 'YourApp'
    });
    
    // Save secret (temporarily, not enabled yet)
    user.twoFactorSecret = secret.base32;
    await user.save();
    
    // Generate QR code
    const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url);
    
    res.json({
      success: true,
      secret: secret.base32,
      qrCode: qrCodeUrl,
      message: 'Scan QR code with your authenticator app'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### Verify and Enable 2FA

```javascript
// @desc    Verify TOTP and enable 2FA
// @route   POST /api/2fa/verify
// @access  Private
exports.verify2FA = async (req, res) => {
  try {
    const { token } = req.body;
    const user = await User.findById(req.user.id);
    
    if (!user.twoFactorSecret) {
      return res.status(400).json({
        success: false,
        message: 'Please setup 2FA first'
      });
    }
    
    // Verify token
    const verified = speakeasy.totp.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token: token,
      window: 2 // Allow 2 time steps before/after
    });
    
    if (!verified) {
      return res.status(400).json({
        success: false,
        message: 'Invalid verification code'
      });
    }
    
    // Generate backup codes
    const backupCodes = [];
    for (let i = 0; i < 10; i++) {
      backupCodes.push(crypto.randomBytes(4).toString('hex').toUpperCase());
    }
    
    // Enable 2FA
    user.twoFactorEnabled = true;
    user.twoFactorBackupCodes = backupCodes;
    await user.save();
    
    res.json({
      success: true,
      message: '2FA enabled successfully',
      backupCodes // Show only once!
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### Login with 2FA

```javascript
// @desc    Login (Step 1: Verify password)
// @route   POST /api/auth/login
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email }).select('+password');
    
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }
    
    // Check if 2FA is enabled
    if (user.twoFactorEnabled) {
      // Generate temporary token (valid for 5 minutes)
      const tempToken = jwt.sign(
        { id: user._id, temp: true },
        process.env.JWT_SECRET,
        { expiresIn: '5m' }
      );
      
      return res.json({
        success: true,
        requiresTwoFactor: true,
        tempToken,
        message: 'Please provide 2FA code'
      });
    }
    
    // No 2FA, login normally
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    
    res.json({
      success: true,
      token,
      user: {
        id: user._id,
        email: user.email,
        name: user.name
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// @desc    Verify 2FA code (Step 2)
// @route   POST /api/auth/verify-2fa
exports.verify2FALogin = async (req, res) => {
  try {
    const { token, tempToken } = req.body;
    
    // Verify temp token
    const decoded = jwt.verify(tempToken, process.env.JWT_SECRET);
    
    if (!decoded.temp) {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }
    
    const user = await User.findById(decoded.id);
    
    if (!user || !user.twoFactorEnabled) {
      return res.status(401).json({
        success: false,
        message: 'Invalid request'
      });
    }
    
    // Verify TOTP code
    const verified = speakeasy.totp.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token: token,
      window: 2
    });
    
    if (!verified) {
      // Check if it's a backup code
      const backupCodeIndex = user.twoFactorBackupCodes.indexOf(token.toUpperCase());
      
      if (backupCodeIndex === -1) {
        return res.status(401).json({
          success: false,
          message: 'Invalid 2FA code'
        });
      }
      
      // Remove used backup code
      user.twoFactorBackupCodes.splice(backupCodeIndex, 1);
      await user.save();
    }
    
    // Generate full access token
    const accessToken = jwt.sign(
      { id: user._id },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      success: true,
      token: accessToken,
      user: {
        id: user._id,
        email: user.email,
        name: user.name
      }
    });
  } catch (error) {
    if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Session expired. Please login again.'
      });
    }
    
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### Disable 2FA

```javascript
// @desc    Disable 2FA
// @route   POST /api/2fa/disable
// @access  Private
exports.disable2FA = async (req, res) => {
  try {
    const { password, token } = req.body;
    const user = await User.findById(req.user.id).select('+password');
    
    // Verify password
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({
        success: false,
        message: 'Invalid password'
      });
    }
    
    // Verify 2FA token
    const verified = speakeasy.totp.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token: token,
      window: 2
    });
    
    if (!verified) {
      return res.status(401).json({
        success: false,
        message: 'Invalid 2FA code'
      });
    }
    
    // Disable 2FA
    user.twoFactorEnabled = false;
    user.twoFactorSecret = undefined;
    user.twoFactorBackupCodes = [];
    await user.save();
    
    res.json({
      success: true,
      message: '2FA disabled successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

---

## Frontend Implementation (React)

### Enable 2FA Component

```javascript
import { useState } from 'react';
import axios from 'axios';

const Enable2FA = () => {
  const [step, setStep] = useState(1);
  const [qrCode, setQrCode] = useState('');
  const [secret, setSecret] = useState('');
  const [verificationCode, setVerificationCode] = useState('');
  const [backupCodes, setBackupCodes] = useState([]);
  const [error, setError] = useState('');
  
  const handleSetup = async () => {
    try {
      const token = localStorage.getItem('token');
      const { data } = await axios.post(
        '/api/2fa/setup',
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      setQrCode(data.qrCode);
      setSecret(data.secret);
      setStep(2);
    } catch (err) {
      setError(err.response?.data?.message || 'Setup failed');
    }
  };
  
  const handleVerify = async () => {
    try {
      const token = localStorage.getItem('token');
      const { data } = await axios.post(
        '/api/2fa/verify',
        { token: verificationCode },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      setBackupCodes(data.backupCodes);
      setStep(3);
    } catch (err) {
      setError(err.response?.data?.message || 'Verification failed');
    }
  };
  
  return (
    <div>
      <h2>Enable Two-Factor Authentication</h2>
      
      {error && <div className="error">{error}</div>}
      
      {step === 1 && (
        <div>
          <p>Add an extra layer of security to your account</p>
          <button onClick={handleSetup}>Setup 2FA</button>
        </div>
      )}
      
      {step === 2 && (
        <div>
          <h3>Scan QR Code</h3>
          <img src={qrCode} alt="QR Code" />
          <p>Or enter this key manually: <code>{secret}</code></p>
          
          <input
            type="text"
            placeholder="Enter 6-digit code"
            value={verificationCode}
            onChange={(e) => setVerificationCode(e.target.value)}
            maxLength={6}
          />
          <button onClick={handleVerify}>Verify & Enable</button>
        </div>
      )}
      
      {step === 3 && (
        <div>
          <h3>Backup Codes</h3>
          <p>Save these codes in a safe place. Each can be used once.</p>
          <ul>
            {backupCodes.map((code, index) => (
              <li key={index}><code>{code}</code></li>
            ))}
          </ul>
          <button onClick={() => window.location.href = '/dashboard'}>
            Done
          </button>
        </div>
      )}
    </div>
  );
};

export default Enable2FA;
```

### Login with 2FA

```javascript
import { useState } from 'react';
import axios from 'axios';

const Login = () => {
  const [step, setStep] = useState(1);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [twoFactorCode, setTwoFactorCode] = useState('');
  const [tempToken, setTempToken] = useState('');
  const [error, setError] = useState('');
  
  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    
    try {
      const { data } = await axios.post('/api/auth/login', { email, password });
      
      if (data.requiresTwoFactor) {
        setTempToken(data.tempToken);
        setStep(2);
      } else {
        localStorage.setItem('token', data.token);
        window.location.href = '/dashboard';
      }
    } catch (err) {
      setError(err.response?.data?.message || 'Login failed');
    }
  };
  
  const handleVerify2FA = async (e) => {
    e.preventDefault();
    setError('');
    
    try {
      const { data } = await axios.post('/api/auth/verify-2fa', {
        token: twoFactorCode,
        tempToken
      });
      
      localStorage.setItem('token', data.token);
      window.location.href = '/dashboard';
    } catch (err) {
      setError(err.response?.data?.message || 'Verification failed');
    }
  };
  
  return (
    <div>
      <h2>Login</h2>
      
      {error && <div className="error">{error}</div>}
      
      {step === 1 && (
        <form onSubmit={handleLogin}>
          <input
            type="email"
            placeholder="Email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
          <input
            type="password"
            placeholder="Password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
          <button type="submit">Login</button>
        </form>
      )}
      
      {step === 2 && (
        <form onSubmit={handleVerify2FA}>
          <p>Enter the 6-digit code from your authenticator app</p>
          <input
            type="text"
            placeholder="000000"
            value={twoFactorCode}
            onChange={(e) => setTwoFactorCode(e.target.value)}
            maxLength={6}
            required
          />
          <button type="submit">Verify</button>
        </form>
      )}
    </div>
  );
};

export default Login;
```

---

## Routes

```javascript
// routes/twoFactor.js
const express = require('express');
const router = express.Router();
const twoFactorController = require('../controllers/twoFactorController');
const { authenticate } = require('../middleware/auth');

router.post('/setup', authenticate, twoFactorController.setup2FA);
router.post('/verify', authenticate, twoFactorController.verify2FA);
router.post('/disable', authenticate, twoFactorController.disable2FA);

module.exports = router;
```

---

## Interview Questions

**Q1: What is Two-Factor Authentication?**
- Security method requiring two forms of identification
- Something you know (password) + something you have (phone/app)
- Adds extra layer of security

**Q2: What's the difference between TOTP and SMS 2FA?**
- **TOTP**: Uses time-based codes from authenticator app, more secure
- **SMS**: Sends codes via text, vulnerable to SIM swapping

**Q3: How does TOTP work?**
- Shared secret between server and authenticator app
- Generates 6-digit codes based on current time
- Codes change every 30 seconds
- Both sides generate same code using same algorithm

**Q4: What are backup codes?**
- One-time use codes for account recovery
- Used when authenticator app is unavailable
- Should be stored securely
- Each code can only be used once

**Q5: Why use temporary token after password verification?**
- Prevents password from being sent with 2FA code
- Short-lived (5 minutes)
- Only allows 2FA verification

**Q6: Should 2FA be mandatory or optional?**
- Depends on security requirements
- Mandatory for high-security applications (banking)
- Optional for most applications
- Encourage adoption with benefits

---

## Best Practices

1. **Use TOTP over SMS** - More secure
2. **Provide backup codes** - Allow account recovery
3. **Require password for disabling 2FA** - Prevent unauthorized changes
4. **Show backup codes only once** - During setup
5. **Use temporary tokens** - Between password and 2FA steps
6. **Set time window** - Allow 1-2 time steps for clock drift
7. **Remove used backup codes** - Prevent reuse
8. **Rate limit 2FA attempts** - Prevent brute force
9. **Log 2FA events** - Track enable/disable, failed attempts
10. **Allow recovery process** - If user loses access to 2FA

---

## Summary

- **2FA** adds extra security layer
- **TOTP** most secure (Google Authenticator, Authy)
- Use **speakeasy** library for TOTP
- Generate **QR code** for easy setup
- Provide **backup codes** for recovery
- **Two-step login**: password â†’ 2FA code
- Use **temporary token** between steps
- **Verify code** with time window for clock drift
- Allow **disabling 2FA** with password + code
- **Remove used backup codes** from database
