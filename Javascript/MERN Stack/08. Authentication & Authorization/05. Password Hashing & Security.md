# 05. Password Hashing & Security

## Introduction

Password security is critical for protecting user accounts. Never store passwords in plain text! Hashing algorithms like bcrypt, argon2, and scrypt ensure passwords are stored securely and cannot be easily reversed.

---

## Why Hash Passwords?

### ❌ The Problem with Plain Text
```javascript
// NEVER DO THIS!
const userSchema = new mongoose.Schema({
  email: String,
  password: String // Storing plain text password ❌
});

await User.create({
  email: 'user@example.com',
  password: 'mypassword123' // Visible in database!
});
```

### Risks:
- Database breach exposes all passwords
- Admins/developers can see passwords
- Users often reuse passwords across sites
- Legal and compliance issues (GDPR, etc.)

### ✅ The Solution: Password Hashing
```javascript
const bcrypt = require('bcryptjs');

const hashedPassword = await bcrypt.hash('mypassword123', 12);
// $2a$12$rXw8qPTjZ5p6K.vJGHm5.u8VQ7ZxYZxYZxYZxYZxYZxYZxYZxYZxY
```

---

## Hashing vs Encryption

| Feature | Hashing | Encryption |
|---------|---------|------------|
| **Reversible** | No (one-way) | Yes (two-way) |
| **Purpose** | Verify integrity | Hide data |
| **Use Case** | Passwords | Sensitive data |
| **Output** | Fixed length | Variable length |
| **Key Required** | No | Yes |
| **Examples** | bcrypt, SHA-256 | AES, RSA |

### Hashing is One-Way
```javascript
// You can hash a password
const hash = hashFunction('password123');
// => '5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'

// But you CANNOT reverse it
const password = reverseHash(hash); // ❌ IMPOSSIBLE!

// Instead, you hash the input and compare hashes
const inputHash = hashFunction('password123');
const isValid = (hash === inputHash); // ✅ true
```

---

## bcrypt: The Standard

### Why bcrypt?
✅ **Slow by design** - resistant to brute force attacks
✅ **Adaptive** - can increase iterations as computers get faster
✅ **Salted** - adds random data to prevent rainbow table attacks
✅ **Industry standard** - battle-tested and trusted

### Installation
```bash
npm install bcryptjs
# or
npm install bcrypt  # Native binding (faster but may have install issues)
```

### Basic Usage

#### Hashing a Password
```javascript
const bcrypt = require('bcryptjs');

const hashPassword = async (password) => {
  const saltRounds = 12; // Cost factor (higher = more secure but slower)
  const hash = await bcrypt.hash(password, saltRounds);
  return hash;
};

const hash = await hashPassword('mypassword123');
console.log(hash);
// $2a$12$KIXxLVq7zJxT9hN1q2b9m.YxYxYxYxYxYxYxYxYxYxYxYxYxYxYxY
```

#### Verifying a Password
```javascript
const verifyPassword = async (password, hash) => {
  const isValid = await bcrypt.compare(password, hash);
  return isValid;
};

const isValid = await verifyPassword('mypassword123', hash);
console.log(isValid); // true

const isInvalid = await verifyPassword('wrongpassword', hash);
console.log(isInvalid); // false
```

---

## Salt Rounds (Cost Factor)

### What are Salt Rounds?
- Number of hashing iterations (2^saltRounds)
- Higher = more secure but slower
- Protects against brute force attacks

### Recommended Values
```javascript
// ❌ Too low (fast but insecure)
const hash = await bcrypt.hash(password, 4); // 16 iterations

// ✅ Good (balanced)
const hash = await bcrypt.hash(password, 10); // 1,024 iterations

// ✅ Better (recommended for 2024+)
const hash = await bcrypt.hash(password, 12); // 4,096 iterations

// ⚠️ Very secure but slow
const hash = await bcrypt.hash(password, 15); // 32,768 iterations
```

### Performance Comparison
```javascript
// Benchmark different salt rounds
const testHashingSpeed = async (password, rounds) => {
  const start = Date.now();
  await bcrypt.hash(password, rounds);
  const end = Date.now();
  console.log(`Rounds ${rounds}: ${end - start}ms`);
};

await testHashingSpeed('password123', 10); // ~60ms
await testHashingSpeed('password123', 12); // ~250ms
await testHashingSpeed('password123', 14); // ~1000ms
```

### Choosing Salt Rounds
- **10**: Fast, minimum acceptable
- **12**: Recommended for most applications
- **14**: High security applications
- **15+**: Very high security (slow)

---

## Automatic Salting

bcrypt automatically generates and includes salt in the hash:

```javascript
const hash1 = await bcrypt.hash('password123', 12);
const hash2 = await bcrypt.hash('password123', 12);

console.log(hash1);
// $2a$12$abc...xyz
console.log(hash2);
// $2a$12$def...uvw

// Same password, different hashes! (due to random salt)
console.log(hash1 === hash2); // false

// But both verify correctly
await bcrypt.compare('password123', hash1); // true
await bcrypt.compare('password123', hash2); // true
```

### Hash Structure
```
$2a$12$abcdefghijklmnopqrstuv123456789012345678901234567890
│││ │  │                      │
││└─┴──┴──────────────────────┴── Hash (31 chars)
│└─────── Salt (22 chars)
└──────── Salt rounds (12)
```

---

## Integration with Mongoose

### User Model with Password Hashing

```javascript
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Name is required']
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    validate: {
      validator: function(v) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v);
      },
      message: 'Invalid email format'
    }
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    select: false // Don't include in queries by default
  },
  passwordChangedAt: Date,
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  }
}, { timestamps: true });

// Hash password before saving
userSchema.pre('save', async function(next) {
  // Only hash if password is modified
  if (!this.isModified('password')) return next();
  
  try {
    // Hash password with cost of 12
    this.password = await bcrypt.hash(this.password, 12);
    next();
  } catch (error) {
    next(error);
  }
});

// Update passwordChangedAt when password is modified
userSchema.pre('save', function(next) {
  if (!this.isModified('password') || this.isNew) return next();
  
  // Set passwordChangedAt to 1 second in the past
  // (ensures JWT is created after password change)
  this.passwordChangedAt = Date.now() - 1000;
  next();
});

// Instance method to verify password
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Instance method to check if password changed after JWT was issued
userSchema.methods.changedPasswordAfter = function(JWTTimestamp) {
  if (this.passwordChangedAt) {
    const changedTimestamp = parseInt(this.passwordChangedAt.getTime() / 1000, 10);
    return JWTTimestamp < changedTimestamp;
  }
  return false;
};

module.exports = mongoose.model('User', userSchema);
```

### Using the Model

```javascript
// Create user (password auto-hashed)
const user = await User.create({
  name: 'John Doe',
  email: 'john@example.com',
  password: 'password123' // Will be hashed automatically
});

// Verify password
const foundUser = await User.findOne({ email: 'john@example.com' }).select('+password');
const isValid = await foundUser.comparePassword('password123');
console.log(isValid); // true
```

---

## Password Validation

### Strong Password Requirements
```javascript
const validatePassword = (password) => {
  const errors = [];
  
  // Minimum length
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters');
  }
  
  // Maximum length (bcrypt limit is 72 characters)
  if (password.length > 72) {
    errors.push('Password must be less than 72 characters');
  }
  
  // Contains uppercase
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  // Contains lowercase
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  // Contains number
  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  // Contains special character
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};

// Usage
const result = validatePassword('weak');
console.log(result);
// {
//   isValid: false,
//   errors: [
//     'Password must be at least 8 characters',
//     'Password must contain at least one uppercase letter',
//     ...
//   ]
// }
```

### Mongoose Validation
```javascript
const userSchema = new mongoose.Schema({
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [8, 'Password must be at least 8 characters'],
    validate: {
      validator: function(password) {
        // At least one uppercase, lowercase, number, special char
        return /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(password);
      },
      message: 'Password must contain uppercase, lowercase, number, and special character'
    }
  }
});
```

---

## Common Security Vulnerabilities

### 1. **Rainbow Table Attacks**
❌ **Problem**: Pre-computed hash tables
✅ **Solution**: Salting (bcrypt does this automatically)

```javascript
// Without salt (vulnerable)
const hash1 = simpleHash('password123'); // abc123
const hash2 = simpleHash('password123'); // abc123 (same!)
// Attacker can use rainbow table to reverse

// With salt (secure)
const hash1 = await bcrypt.hash('password123', 12); // $2a$12$abc...
const hash2 = await bcrypt.hash('password123', 12); // $2a$12$xyz...
// Different hashes, rainbow table useless!
```

### 2. **Brute Force Attacks**
❌ **Problem**: Try every possible password
✅ **Solution**: High salt rounds + rate limiting

```javascript
// Rate limiting on login endpoint
const rateLimit = require('express-rate-limit');

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per windowMs
  message: 'Too many login attempts. Try again later.'
});

app.post('/api/auth/login', loginLimiter, loginController);
```

### 3. **Timing Attacks**
❌ **Problem**: Attacker measures response time to determine if username exists
✅ **Solution**: Always hash password, even if user doesn't exist

```javascript
// ❌ Vulnerable
const user = await User.findOne({ email });
if (!user) {
  return res.status(401).json({ message: 'Invalid credentials' }); // Fast response
}
const isValid = await bcrypt.compare(password, user.password); // Slow response

// ✅ Secure
const user = await User.findOne({ email });
const hash = user ? user.password : await bcrypt.hash('dummy', 12);
const isValid = await bcrypt.compare(password, hash);

if (!user || !isValid) {
  return res.status(401).json({ message: 'Invalid credentials' });
}
```

---

## Other Hashing Algorithms

### argon2 (Most Secure)
```bash
npm install argon2
```

```javascript
const argon2 = require('argon2');

// Hash
const hash = await argon2.hash('password123');

// Verify
const isValid = await argon2.verify(hash, 'password123');
```

**Pros**: Winner of Password Hashing Competition, most secure
**Cons**: Less widespread adoption than bcrypt

### scrypt (Node.js Built-in)
```javascript
const crypto = require('crypto');
const util = require('util');
const scrypt = util.promisify(crypto.scrypt);

// Hash
const hash = async (password) => {
  const salt = crypto.randomBytes(16).toString('hex');
  const derivedKey = await scrypt(password, salt, 64);
  return `${salt}:${derivedKey.toString('hex')}`;
};

// Verify
const verify = async (password, hash) => {
  const [salt, key] = hash.split(':');
  const derivedKey = await scrypt(password, salt, 64);
  return key === derivedKey.toString('hex');
};
```

**Pros**: Built-in, no dependencies
**Cons**: Manual salt management

### Comparison

| Algorithm | Security | Speed | Ease of Use |
|-----------|----------|-------|-------------|
| **bcrypt** | ⭐⭐⭐⭐ | Medium | ⭐⭐⭐⭐⭐ |
| **argon2** | ⭐⭐⭐⭐⭐ | Slower | ⭐⭐⭐⭐ |
| **scrypt** | ⭐⭐⭐⭐ | Slower | ⭐⭐⭐ |
| **SHA-256** | ❌ (Too fast) | Fast | ⭐⭐⭐⭐ |

---

## Interview Questions

**Q1: Why should you never store passwords in plain text?**
- Database breach exposes all passwords
- Violates user trust and legal requirements
- Users often reuse passwords across sites

**Q2: What's the difference between hashing and encryption?**
- **Hashing**: One-way, irreversible (for passwords)
- **Encryption**: Two-way, reversible (for sensitive data)

**Q3: Why is bcrypt better than SHA-256 for passwords?**
- bcrypt is slow by design (resistant to brute force)
- bcrypt includes automatic salting
- SHA-256 is too fast (millions of hashes per second)

**Q4: What is a salt in password hashing?**
- Random data added to password before hashing
- Prevents rainbow table attacks
- Ensures same password produces different hashes

**Q5: What are salt rounds in bcrypt?**
- Number of hashing iterations (2^rounds)
- Higher = more secure but slower
- Recommended: 12 for modern applications

**Q6: How do you verify a bcrypt password?**
```javascript
const isValid = await bcrypt.compare(inputPassword, storedHash);
```

**Q7: Why use `select: false` for password field in Mongoose?**
- Prevents password from being included in query results
- Reduces risk of accidental exposure
- Must explicitly select when needed: `.select('+password')`

---

## Best Practices

1. **Use bcrypt (or argon2)** - Never use fast hashing algorithms
2. **Salt rounds: 12+** - Balance security and performance
3. **Validate password strength** - Minimum 8 characters, mixed case, numbers, symbols
4. **Hash on save** - Use Mongoose pre-save middleware
5. **Don't select password by default** - Use `select: false`
6. **Rate limit login attempts** - Prevent brute force
7. **Use constant-time comparison** - Prevent timing attacks
8. **Update hash on login** - If salt rounds increased
9. **Never log passwords** - Even in development
10. **Require password change** - After breach or suspicious activity

---

## Summary

- **Never** store passwords in plain text
- Use **bcrypt** (or argon2) for password hashing
- bcrypt is **slow by design** to prevent brute force
- **Salt rounds of 12** is recommended
- bcrypt **automatically salts** passwords
- Use **Mongoose middleware** to hash passwords on save
- **Validate password strength** on registration
- Implement **rate limiting** on login endpoint
- Use `select: false` to exclude password from queries
- Always use **HTTPS** to protect passwords in transit
