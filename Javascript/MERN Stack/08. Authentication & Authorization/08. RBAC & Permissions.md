# 08. RBAC & Permissions

## Introduction

Role-Based Access Control (RBAC) is an authorization model that restricts system access based on user roles. Instead of assigning permissions to individual users, you assign roles to users and permissions to roles.

---

## RBAC vs Permission-Based Access Control

### RBAC (Role-Based)
```javascript
// User has a role
const user = {
  id: '123',
  email: 'john@example.com',
  role: 'admin' // Single role
};

// Check role
if (user.role === 'admin') {
  // Allow access
}
```

### Permission-Based (PBAC)
```javascript
// User has specific permissions
const user = {
  id: '123',
  email: 'john@example.com',
  permissions: ['read:users', 'write:posts', 'delete:comments']
};

// Check permission
if (user.permissions.includes('delete:comments')) {
  // Allow access
}
```

### Hybrid Approach
```javascript
// User has role AND custom permissions
const user = {
  id: '123',
  email: 'john@example.com',
  role: 'editor',
  permissions: ['read:analytics'] // Additional custom permission
};
```

---

## User Model with Roles

```javascript
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: String,
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true,
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'moderator', 'admin', 'superadmin'],
    default: 'user'
  },
  isActive: {
    type: Boolean,
    default: true
  }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
```

---

## Simple Role-Based Authorization

### Middleware

```javascript
// middleware/auth.js

// Authorize based on role
exports.authorize = (...roles) => {
  return (req, res, next) => {
    // Check if user is authenticated
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authenticated'
      });
    }
    
    // Check if user has required role
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `Access denied. Requires role: ${roles.join(' or ')}`
      });
    }
    
    next();
  };
};
```

### Usage in Routes

```javascript
const { authenticate, authorize } = require('../middleware/auth');

// Only admins can delete users
router.delete('/users/:id',
  authenticate,
  authorize('admin'),
  deleteUser
);

// Admins and moderators can approve posts
router.put('/posts/:id/approve',
  authenticate,
  authorize('admin', 'moderator'),
  approvePost
);

// Only superadmin can access
router.get('/admin/stats',
  authenticate,
  authorize('superadmin'),
  getStats
);
```

---

## Role Hierarchy

Implementing role hierarchy where higher roles inherit permissions of lower roles.

```javascript
// config/roles.js
const ROLES = {
  USER: 'user',
  MODERATOR: 'moderator',
  ADMIN: 'admin',
  SUPERADMIN: 'superadmin'
};

const ROLE_HIERARCHY = {
  user: 0,
  moderator: 1,
  admin: 2,
  superadmin: 3
};

module.exports = { ROLES, ROLE_HIERARCHY };
```

### Middleware with Hierarchy

```javascript
// middleware/auth.js
const { ROLE_HIERARCHY } = require('../config/roles');

exports.authorizeMinRole = (minRole) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authenticated'
      });
    }
    
    const userRoleLevel = ROLE_HIERARCHY[req.user.role];
    const requiredRoleLevel = ROLE_HIERARCHY[minRole];
    
    if (userRoleLevel < requiredRoleLevel) {
      return res.status(403).json({
        success: false,
        message: `Access denied. Minimum role required: ${minRole}`
      });
    }
    
    next();
  };
};
```

### Usage
```javascript
// Moderator or higher (moderator, admin, superadmin)
router.delete('/comments/:id',
  authenticate,
  authorizeMinRole('moderator'),
  deleteComment
);
```

---

## Permission-Based Access Control

### User Model with Permissions

```javascript
// models/User.js
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String,
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  permissions: [{
    type: String,
    enum: [
      'read:users',
      'write:users',
      'delete:users',
      'read:posts',
      'write:posts',
      'delete:posts',
      'read:comments',
      'write:comments',
      'delete:comments',
      'manage:roles'
    ]
  }]
});

// Method to check if user has permission
userSchema.methods.hasPermission = function(permission) {
  return this.permissions.includes(permission);
};

module.exports = mongoose.model('User', userSchema);
```

### Permission Middleware

```javascript
// middleware/permissions.js

exports.requirePermission = (...permissions) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authenticated'
      });
    }
    
    // Check if user has ALL required permissions
    const hasAllPermissions = permissions.every(permission =>
      req.user.permissions.includes(permission)
    );
    
    if (!hasAllPermissions) {
      return res.status(403).json({
        success: false,
        message: `Missing required permissions: ${permissions.join(', ')}`
      });
    }
    
    next();
  };
};

exports.requireAnyPermission = (...permissions) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authenticated'
      });
    }
    
    // Check if user has ANY of the required permissions
    const hasAnyPermission = permissions.some(permission =>
      req.user.permissions.includes(permission)
    );
    
    if (!hasAnyPermission) {
      return res.status(403).json({
        success: false,
        message: `Requires one of: ${permissions.join(', ')}`
      });
    }
    
    next();
  };
};
```

### Usage
```javascript
const { requirePermission, requireAnyPermission } = require('../middleware/permissions');

// Requires specific permission
router.delete('/users/:id',
  authenticate,
  requirePermission('delete:users'),
  deleteUser
);

// Requires multiple permissions
router.post('/posts/:id/publish',
  authenticate,
  requirePermission('write:posts', 'publish:posts'),
  publishPost
);

// Requires ANY of the permissions
router.get('/admin/dashboard',
  authenticate,
  requireAnyPermission('view:analytics', 'manage:users', 'manage:posts'),
  getDashboard
);
```

---

## Hybrid RBAC + Permissions

Combine roles with custom permissions for flexibility.

### Role Configuration

```javascript
// config/roles.js
const ROLE_PERMISSIONS = {
  user: [
    'read:posts',
    'write:own-posts',
    'delete:own-posts',
    'read:comments',
    'write:comments'
  ],
  
  moderator: [
    'read:posts',
    'write:posts',
    'delete:posts',
    'read:comments',
    'write:comments',
    'delete:comments',
    'read:users'
  ],
  
  admin: [
    'read:users',
    'write:users',
    'delete:users',
    'read:posts',
    'write:posts',
    'delete:posts',
    'read:comments',
    'write:comments',
    'delete:comments',
    'manage:roles'
  ],
  
  superadmin: ['*'] // All permissions
};

module.exports = { ROLE_PERMISSIONS };
```

### Get All User Permissions

```javascript
// models/User.js
const { ROLE_PERMISSIONS } = require('../config/roles');

userSchema.methods.getAllPermissions = function() {
  // Get permissions from role
  const rolePermissions = ROLE_PERMISSIONS[this.role] || [];
  
  // Combine with custom permissions
  const allPermissions = [...new Set([...rolePermissions, ...this.permissions])];
  
  return allPermissions;
};

userSchema.methods.hasPermission = function(permission) {
  const allPermissions = this.getAllPermissions();
  
  // Superadmin has all permissions
  if (allPermissions.includes('*')) {
    return true;
  }
  
  return allPermissions.includes(permission);
};
```

### Middleware

```javascript
exports.requirePermission = (permission) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authenticated'
      });
    }
    
    if (!req.user.hasPermission(permission)) {
      return res.status(403).json({
        success: false,
        message: `Missing required permission: ${permission}`
      });
    }
    
    next();
  };
};
```

---

## Resource Ownership

Combine RBAC with resource ownership checks.

```javascript
// middleware/ownership.js

exports.canModifyPost = async (req, res, next) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({
        success: false,
        message: 'Post not found'
      });
    }
    
    // Admin can modify any post
    if (req.user.role === 'admin') {
      req.post = post;
      return next();
    }
    
    // User can only modify their own posts
    if (post.author.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to modify this post'
      });
    }
    
    req.post = post;
    next();
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};
```

### Usage
```javascript
router.put('/posts/:id',
  authenticate,
  canModifyPost,
  updatePost
);
```

---

## Dynamic Permissions Check

```javascript
// utils/permissions.js

class PermissionChecker {
  constructor(user) {
    this.user = user;
  }
  
  can(action, resource) {
    const permission = `${action}:${resource}`;
    return this.user.hasPermission(permission);
  }
  
  canRead(resource) {
    return this.can('read', resource);
  }
  
  canWrite(resource) {
    return this.can('write', resource);
  }
  
  canDelete(resource) {
    return this.can('delete', resource);
  }
  
  canManage(resource) {
    return this.can('manage', resource);
  }
}

module.exports = PermissionChecker;
```

### Usage in Controller
```javascript
const PermissionChecker = require('../utils/permissions');

exports.deleteUser = async (req, res) => {
  const permissions = new PermissionChecker(req.user);
  
  if (!permissions.canDelete('users')) {
    return res.status(403).json({
      success: false,
      message: 'Cannot delete users'
    });
  }
  
  // Proceed with deletion
  await User.findByIdAndDelete(req.params.id);
  res.json({ success: true });
};
```

---

## Admin Routes

### Manage User Roles

```javascript
// controllers/adminController.js

exports.updateUserRole = async (req, res) => {
  try {
    const { role } = req.body;
    
    // Validate role
    const validRoles = ['user', 'moderator', 'admin'];
    if (!validRoles.includes(role)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid role'
      });
    }
    
    // Prevent users from promoting themselves to admin
    if (req.params.id === req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Cannot change your own role'
      });
    }
    
    // Update user role
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { role },
      { new: true, runValidators: true }
    );
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }
    
    res.json({
      success: true,
      user
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

exports.updateUserPermissions = async (req, res) => {
  try {
    const { permissions } = req.body;
    
    const user = await User.findByIdAndUpdate(
      req.params.id,
      { permissions },
      { new: true, runValidators: true }
    );
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }
    
    res.json({
      success: true,
      user
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

### Routes
```javascript
router.put('/admin/users/:id/role',
  authenticate,
  authorize('admin'),
  updateUserRole
);

router.put('/admin/users/:id/permissions',
  authenticate,
  authorize('admin'),
  updateUserPermissions
);
```

---

## CASL (Permission Management Library)

### Installation
```bash
npm install @casl/ability
```

### Define Abilities

```javascript
// utils/abilities.js
const { AbilityBuilder, Ability } = require('@casl/ability');

const defineAbilitiesFor = (user) => {
  const { can, cannot, build } = new AbilityBuilder(Ability);
  
  if (user.role === 'admin') {
    can('manage', 'all'); // Admin can do everything
  } else if (user.role === 'moderator') {
    can('read', 'all');
    can('update', 'Post');
    can('delete', 'Comment');
  } else {
    can('read', 'Post');
    can('read', 'Comment');
    can('create', 'Post');
    can('update', 'Post', { authorId: user.id }); // Own posts only
    can('delete', 'Post', { authorId: user.id }); // Own posts only
  }
  
  return build();
};

module.exports = { defineAbilitiesFor };
```

### Middleware

```javascript
const { defineAbilitiesFor } = require('../utils/abilities');

exports.checkAbility = (action, subject) => {
  return (req, res, next) => {
    const ability = defineAbilitiesFor(req.user);
    
    if (ability.cannot(action, subject)) {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }
    
    next();
  };
};
```

### Usage
```javascript
router.delete('/posts/:id',
  authenticate,
  checkAbility('delete', 'Post'),
  deletePost
);
```

---

## Interview Questions

**Q1: What is RBAC?**
- Role-Based Access Control
- Authorization model based on user roles
- Users are assigned roles, roles have permissions
- Simplifies permission management

**Q2: RBAC vs Permission-Based Access Control?**
- **RBAC**: User has role (admin, user), role determines permissions
- **PBAC**: User has specific permissions (read:posts, delete:users)
- **Hybrid**: Combine both for flexibility

**Q3: How do you implement RBAC in Express?**
- Create authorize middleware that accepts roles
- Check if req.user.role is in allowed roles
- Return 403 if not authorized

**Q4: What's the difference between 401 and 403?**
- **401 Unauthorized**: Not authenticated (missing/invalid token)
- **403 Forbidden**: Authenticated but not authorized (insufficient permissions)

**Q5: How do you implement role hierarchy?**
- Define role levels (user: 0, moderator: 1, admin: 2)
- Compare user role level with required role level
- Higher roles inherit permissions of lower roles

**Q6: What are the benefits of RBAC?**
- Simplified permission management
- Easy to understand and maintain
- Scalable (add new roles as needed)
- Reduces errors in permission assignment

---

## Best Practices

1. **Use role hierarchy** - Higher roles inherit lower role permissions
2. **Combine RBAC + permissions** - Flexibility for edge cases
3. **Check resource ownership** - Users can only modify their own resources
4. **Prevent self-promotion** - Users can't change their own role
5. **Validate roles** - Ensure role exists before assignment
6. **Use enums** - Define valid roles in schema
7. **Audit role changes** - Log who changed what role when
8. **Minimum required role** - Use role hierarchy for simpler checks
9. **Default to least privilege** - Start with minimal permissions
10. **Test authorization** - Ensure routes properly protected

---

## Summary

- **RBAC** assigns roles to users, permissions to roles
- **authorize middleware** checks if user has required role
- **Role hierarchy** allows higher roles to inherit permissions
- **Permission-based** access for fine-grained control
- **Hybrid approach** combines roles and custom permissions
- Check **resource ownership** for user-specific resources
- Return **403** for authorization failures
- Use **CASL** library for complex permission logic
- Implement **admin routes** to manage user roles
- **Audit and log** role and permission changes
