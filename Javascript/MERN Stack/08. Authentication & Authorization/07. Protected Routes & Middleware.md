# 07. Protected Routes & Middleware

## Introduction

Protected routes ensure that only authenticated (and authorized) users can access certain endpoints. Middleware functions are the mechanism to implement this protection in Express applications.

---

## What are Protected Routes?

Protected routes are API endpoints that require authentication (and optionally authorization) before allowing access.

### Examples
```javascript
// Public routes (anyone can access)
POST /api/auth/register
POST /api/auth/login
GET  /api/products          // View products

// Protected routes (must be authenticated)
GET  /api/auth/me           // Get current user
PUT  /api/users/profile     // Update profile
POST /api/posts             // Create post

// Admin-only routes (must be authenticated AND admin)
DELETE /api/users/:id       // Delete user
GET    /api/admin/stats     // View admin stats
```

---

## Authentication Middleware

### Basic Implementation

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.authenticate = async (req, res, next) => {
  try {
    // 1. Get token from Authorization header
    let token;
    
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }
    
    // 2. Check if token exists
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized. Please login.'
      });
    }
    
    // 3. Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // 4. Get user from database
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User no longer exists'
      });
    }
    
    // 5. Attach user to request object
    req.user = user;
    
    // 6. Continue to next middleware/route handler
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }
    
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        message: 'Token expired'
      });
    }
    
    res.status(500).json({
      success: false,
      message: 'Authentication failed'
    });
  }
};
```

### Usage in Routes

```javascript
// routes/posts.js
const express = require('express');
const router = express.Router();
const { authenticate } = require('../middleware/auth');
const postController = require('../controllers/postController');

// Public routes
router.get('/', postController.getAllPosts);
router.get('/:id', postController.getPost);

// Protected routes (require authentication)
router.post('/', authenticate, postController.createPost);
router.put('/:id', authenticate, postController.updatePost);
router.delete('/:id', authenticate, postController.deletePost);

module.exports = router;
```

---

## Advanced Authentication Middleware

### With Additional Checks

```javascript
// middleware/auth.js
exports.authenticate = async (req, res, next) => {
  try {
    // Get token
    let token;
    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    } else if (req.cookies.token) {
      token = req.cookies.token; // Support cookies too
    }
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized. Please login.'
      });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Get user
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'User no longer exists'
      });
    }
    
    // Check if user is active
    if (!user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'Your account has been deactivated'
      });
    }
    
    // Check if user changed password after token was issued
    if (user.changedPasswordAfter(decoded.iat)) {
      return res.status(401).json({
        success: false,
        message: 'Password recently changed. Please login again.'
      });
    }
    
    // Check if email is verified (optional)
    if (!user.emailVerified && req.path !== '/verify-email') {
      return res.status(403).json({
        success: false,
        message: 'Please verify your email to continue'
      });
    }
    
    req.user = user;
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ success: false, message: 'Invalid token' });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ success: false, message: 'Token expired' });
    }
    res.status(500).json({ success: false, message: 'Authentication failed' });
  }
};
```

---

## Optional Authentication Middleware

Sometimes you want to authenticate users IF a token is present, but not require it.

```javascript
// middleware/auth.js
exports.optionalAuth = async (req, res, next) => {
  try {
    let token;
    if (req.headers.authorization?.startsWith('Bearer')) {
      token = req.headers.authorization.split(' ')[1];
    }
    
    if (token) {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.id);
      
      if (user) {
        req.user = user; // Attach user if token is valid
      }
    }
    
    // Continue regardless of authentication status
    next();
  } catch (error) {
    // Ignore errors, just continue without user
    next();
  }
};
```

### Usage
```javascript
// Show personalized content if logged in, public content otherwise
router.get('/feed', optionalAuth, (req, res) => {
  if (req.user) {
    // Show personalized feed
    return res.json({ feed: getPersonalizedFeed(req.user) });
  }
  // Show public feed
  res.json({ feed: getPublicFeed() });
});
```

---

## Authorization Middleware

### Role-Based Authorization

```javascript
// middleware/auth.js
exports.authorize = (...roles) => {
  return (req, res, next) => {
    // Check if user is authenticated
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Not authorized'
      });
    }
    
    // Check if user has required role
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `Access denied. Requires one of: ${roles.join(', ')}`
      });
    }
    
    next();
  };
};
```

### Usage
```javascript
const { authenticate, authorize } = require('../middleware/auth');

// Only admins can access
router.delete('/users/:id', 
  authenticate,
  authorize('admin'),
  deleteUser
);

// Admins and moderators can access
router.put('/posts/:id/approve',
  authenticate,
  authorize('admin', 'moderator'),
  approvePost
);
```

---

## Resource Ownership Middleware

Check if user owns the resource they're trying to modify.

```javascript
// middleware/resourceOwnership.js
exports.isPostOwner = async (req, res, next) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({
        success: false,
        message: 'Post not found'
      });
    }
    
    // Check if user owns the post OR is admin
    if (post.author.toString() !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to modify this post'
      });
    }
    
    // Attach post to request for use in controller
    req.post = post;
    next();
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};
```

### Usage
```javascript
const { authenticate } = require('../middleware/auth');
const { isPostOwner } = require('../middleware/resourceOwnership');

// User can only update/delete their own posts (unless admin)
router.put('/posts/:id', authenticate, isPostOwner, updatePost);
router.delete('/posts/:id', authenticate, isPostOwner, deletePost);
```

---

## Middleware Chaining

### Multiple Middleware

```javascript
// Combine authentication + authorization + ownership
router.delete('/posts/:id',
  authenticate,           // 1. Check if logged in
  authorize('user', 'admin'), // 2. Check role
  isPostOwner,           // 3. Check ownership
  deletePost             // 4. Execute controller
);
```

### Conditional Middleware

```javascript
const conditionalAuth = (req, res, next) => {
  if (req.path.startsWith('/admin')) {
    return authenticate(req, res, next);
  }
  next();
};

app.use('/api', conditionalAuth);
```

---

## Rate Limiting Middleware

```javascript
const rateLimit = require('express-rate-limit');

// General API rate limiter
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per windowMs
  message: 'Too many requests from this IP'
});

// Strict rate limiter for auth routes
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 attempts
  message: 'Too many login attempts. Try again later.'
});

// Apply to routes
app.use('/api', apiLimiter);
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);
```

---

## Complete Routes Example

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();
const { authenticate, authorize } = require('../middleware/auth');
const userController = require('../controllers/userController');

// Public routes
router.get('/', userController.getAllUsers); // Anyone can view users

// Protected routes (authentication required)
router.get('/me', 
  authenticate, 
  userController.getMe
);

router.put('/me', 
  authenticate, 
  userController.updateMe
);

router.delete('/me', 
  authenticate, 
  userController.deleteMe
);

// Admin-only routes (authentication + authorization)
router.get('/:id',
  authenticate,
  authorize('admin'),
  userController.getUser
);

router.put('/:id',
  authenticate,
  authorize('admin'),
  userController.updateUser
);

router.delete('/:id',
  authenticate,
  authorize('admin'),
  userController.deleteUser
);

module.exports = router;
```

---

## Error Handling in Middleware

### Async Error Handler Wrapper

```javascript
// utils/asyncHandler.js
module.exports = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};
```

### Usage
```javascript
const asyncHandler = require('../utils/asyncHandler');

exports.authenticate = asyncHandler(async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    throw new Error('Not authorized');
  }
  
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  const user = await User.findById(decoded.id);
  
  if (!user) {
    throw new Error('User not found');
  }
  
  req.user = user;
  next();
});
```

---

## Custom Error Classes

```javascript
// utils/AppError.js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = AppError;
```

### Usage in Middleware
```javascript
const AppError = require('../utils/AppError');

exports.authenticate = asyncHandler(async (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return next(new AppError('Not authorized. Please login.', 401));
  }
  
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  const user = await User.findById(decoded.id);
  
  if (!user) {
    return next(new AppError('User no longer exists', 401));
  }
  
  req.user = user;
  next();
});
```

---

## Testing Protected Routes

### With Jest and Supertest

```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');
const jwt = require('jsonwebtoken');

describe('Protected Routes', () => {
  let token;
  let userId;
  
  beforeAll(async () => {
    // Create test user
    const user = await User.create({
      name: 'Test User',
      email: 'test@example.com',
      password: 'password123'
    });
    
    userId = user._id;
    
    // Generate token
    token = jwt.sign({ id: userId }, process.env.JWT_SECRET);
  });
  
  afterAll(async () => {
    await User.findByIdAndDelete(userId);
  });
  
  describe('GET /api/auth/me', () => {
    it('should return 401 without token', async () => {
      const res = await request(app).get('/api/auth/me');
      
      expect(res.status).toBe(401);
      expect(res.body.success).toBe(false);
    });
    
    it('should return user data with valid token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .set('Authorization', `Bearer ${token}`);
      
      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.user.email).toBe('test@example.com');
    });
    
    it('should return 401 with invalid token', async () => {
      const res = await request(app)
        .get('/api/auth/me')
        .set('Authorization', 'Bearer invalid-token');
      
      expect(res.status).toBe(401);
    });
  });
});
```

---

## Interview Questions

**Q1: What is middleware in Express?**
- Functions that have access to request, response, and next
- Execute in sequence between request and route handler
- Can modify req/res, end request-response cycle, or call next()

**Q2: How do you protect routes in Express?**
- Create authentication middleware
- Verify JWT token from Authorization header
- Attach user to req.user if valid
- Call next() to proceed or return error

**Q3: What's the difference between authentication and authorization middleware?**
- **Authentication**: Verifies WHO the user is (checks token)
- **Authorization**: Verifies WHAT the user can do (checks role/permissions)

**Q4: How do you implement role-based access control?**
- Create authorize middleware that accepts roles
- Check if req.user.role is in allowed roles
- Return 403 if not authorized

**Q5: Why use middleware chaining?**
- Separate concerns (auth, authorization, validation)
- Reusable across routes
- Clean, modular code

**Q6: How do you handle errors in async middleware?**
- Wrap in try-catch or use asyncHandler utility
- Call next(error) to pass to error handler
- Use custom error classes for specific errors

---

## Best Practices

1. **Always validate tokens** - Check expiration, signature, user existence
2. **Use middleware chaining** - Separate authentication, authorization, validation
3. **Return appropriate status codes** - 401 for auth, 403 for authorization
4. **Attach user to request** - `req.user` for use in controllers
5. **Check additional conditions** - Active account, verified email, password changes
6. **Handle errors gracefully** - Specific error messages, proper status codes
7. **Implement rate limiting** - Prevent brute force attacks
8. **Use asyncHandler** - Avoid repetitive try-catch blocks
9. **Test protected routes** - Ensure proper authentication/authorization
10. **Log auth events** - Track failures, suspicious activity

---

## Summary

- **Protected routes** require authentication middleware
- Middleware extracts and verifies JWT token
- Attach authenticated user to **req.user**
- Use **authorize** middleware for role-based access
- Check **resource ownership** for user-specific resources
- Chain multiple middleware: **authenticate → authorize → validate**
- Return **401** for authentication failures, **403** for authorization
- Implement **rate limiting** on sensitive routes
- Use **asyncHandler** wrapper for cleaner error handling
- Test protected routes with and without valid tokens
