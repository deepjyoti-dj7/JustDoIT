# 10. Passport.js

## Introduction

Passport.js is a popular authentication middleware for Node.js that simplifies implementing various authentication strategies including local (username/password), OAuth, JWT, and more.

---

## Why Passport.js?

### Benefits
✅ **Flexible**: Supports 500+ authentication strategies
✅ **Modular**: Choose only strategies you need
✅ **Simple API**: Consistent interface across strategies
✅ **Well-maintained**: Large community, regular updates
✅ **Express integration**: Seamless middleware integration

### Common Strategies
- **Local**: Username and password
- **OAuth**: Google, Facebook, GitHub, Twitter
- **JWT**: JSON Web Tokens
- **OpenID**: OpenID Connect
- **SAML**: Enterprise SSO

---

## Installation

```bash
# Core package
npm install passport

# Strategies (install what you need)
npm install passport-local         # Username/password
npm install passport-jwt           # JWT
npm install passport-google-oauth20 # Google OAuth
npm install passport-facebook      # Facebook
npm install passport-github2       # GitHub

# Session support
npm install express-session
```

---

## Local Strategy (Username/Password)

### Configuration

```javascript
// config/passport.js
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const User = require('../models/User');
const bcrypt = require('bcryptjs');

// Configure local strategy
passport.use(
  new LocalStrategy(
    {
      usernameField: 'email', // Use email instead of username
      passwordField: 'password'
    },
    async (email, password, done) => {
      try {
        // Find user by email
        const user = await User.findOne({ email }).select('+password');
        
        if (!user) {
          return done(null, false, { message: 'Invalid credentials' });
        }
        
        // Verify password
        const isPasswordValid = await bcrypt.compare(password, user.password);
        
        if (!isPasswordValid) {
          return done(null, false, { message: 'Invalid credentials' });
        }
        
        // Success
        return done(null, user);
      } catch (error) {
        return done(error);
      }
    }
  )
);

// Serialize user for session
passport.serializeUser((user, done) => {
  done(null, user.id);
});

// Deserialize user from session
passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findById(id);
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

module.exports = passport;
```

### Server Setup

```javascript
// server.js
const express = require('express');
const session = require('express-session');
const passport = require('./config/passport');

const app = express();

app.use(express.json());

// Session middleware (must be before passport)
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));

// Passport middleware
app.use(passport.initialize());
app.use(passport.session());

// Routes
app.use('/api/auth', require('./routes/auth'));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
```

### Routes

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const passport = require('passport');

// @route   POST /api/auth/login
// @desc    Login with email and password
router.post('/login',
  passport.authenticate('local', {
    successRedirect: '/dashboard',
    failureRedirect: '/login',
    failureFlash: true // Requires connect-flash
  })
);

// Or with custom callback
router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) {
      return res.status(500).json({ message: err.message });
    }
    
    if (!user) {
      return res.status(401).json({ message: info.message });
    }
    
    req.logIn(user, (err) => {
      if (err) {
        return res.status(500).json({ message: err.message });
      }
      
      res.json({
        success: true,
        user: {
          id: user._id,
          email: user.email,
          name: user.name
        }
      });
    });
  })(req, res, next);
});

// @route   POST /api/auth/logout
// @desc    Logout user
router.post('/logout', (req, res) => {
  req.logout((err) => {
    if (err) {
      return res.status(500).json({ message: err.message });
    }
    res.json({ success: true, message: 'Logged out successfully' });
  });
});

module.exports = router;
```

### Authentication Middleware

```javascript
// middleware/auth.js

exports.isAuthenticated = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: 'Not authenticated' });
};
```

### Usage
```javascript
const { isAuthenticated } = require('../middleware/auth');

router.get('/profile', isAuthenticated, (req, res) => {
  res.json({ user: req.user });
});
```

---

## JWT Strategy

### Configuration

```javascript
// config/passport.js
const JwtStrategy = require('passport-jwt').Strategy;
const ExtractJwt = require('passport-jwt').ExtractJwt;
const User = require('../models/User');

const jwtOptions = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: process.env.JWT_SECRET
};

passport.use(
  new JwtStrategy(jwtOptions, async (payload, done) => {
    try {
      const user = await User.findById(payload.id);
      
      if (user) {
        return done(null, user);
      }
      
      return done(null, false);
    } catch (error) {
      return done(error, false);
    }
  })
);
```

### Routes

```javascript
const jwt = require('jsonwebtoken');

// Login and generate JWT
router.post('/login', async (req, res) => {
  const { email, password } = req.body;
  
  const user = await User.findOne({ email }).select('+password');
  
  if (!user || !(await user.comparePassword(password))) {
    return res.status(401).json({ message: 'Invalid credentials' });
  }
  
  // Generate JWT
  const token = jwt.sign(
    { id: user._id },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
  
  res.json({
    success: true,
    token,
    user: {
      id: user._id,
      email: user.email,
      name: user.name
    }
  });
});

// Protected route
router.get('/profile',
  passport.authenticate('jwt', { session: false }),
  (req, res) => {
    res.json({ user: req.user });
  }
);
```

---

## Multiple Strategies

Combine multiple authentication strategies.

```javascript
// config/passport.js
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const JwtStrategy = require('passport-jwt').Strategy;
const GoogleStrategy = require('passport-google-oauth20').Strategy;

// Local Strategy
passport.use('local', new LocalStrategy({
  usernameField: 'email'
}, async (email, password, done) => {
  // ... local auth logic
}));

// JWT Strategy
passport.use('jwt', new JwtStrategy(jwtOptions, async (payload, done) => {
  // ... JWT auth logic
}));

// Google Strategy
passport.use('google', new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: '/api/auth/google/callback'
}, async (accessToken, refreshToken, profile, done) => {
  // ... Google OAuth logic
}));
```

### Routes with Multiple Strategies

```javascript
// Local login
router.post('/login/local',
  passport.authenticate('local', { session: false }),
  (req, res) => {
    const token = jwt.sign({ id: req.user._id }, process.env.JWT_SECRET);
    res.json({ success: true, token });
  }
);

// Google OAuth
router.get('/login/google',
  passport.authenticate('google', { scope: ['profile', 'email'] })
);

router.get('/google/callback',
  passport.authenticate('google', { session: false }),
  (req, res) => {
    const token = jwt.sign({ id: req.user._id }, process.env.JWT_SECRET);
    res.redirect(`${process.env.CLIENT_URL}/auth/success?token=${token}`);
  }
);

// Protected route (accepts JWT)
router.get('/profile',
  passport.authenticate('jwt', { session: false }),
  (req, res) => {
    res.json({ user: req.user });
  }
);
```

---

## Custom Callback

Full control over authentication flow.

```javascript
router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    // Handle errors
    if (err) {
      return res.status(500).json({
        success: false,
        message: 'Authentication error',
        error: err.message
      });
    }
    
    // Handle authentication failure
    if (!user) {
      return res.status(401).json({
        success: false,
        message: info.message || 'Authentication failed'
      });
    }
    
    // Log user in
    req.logIn(user, (err) => {
      if (err) {
        return res.status(500).json({
          success: false,
          message: 'Login failed'
        });
      }
      
      // Custom success response
      res.json({
        success: true,
        user: {
          id: user._id,
          email: user.email,
          name: user.name,
          role: user.role
        }
      });
    });
  })(req, res, next);
});
```

---

## Passport without Sessions (JWT-based)

```javascript
// Don't use session
app.use(passport.initialize());
// Don't call passport.session()

// Routes
router.post('/login',
  passport.authenticate('local', { session: false }),
  (req, res) => {
    const token = jwt.sign({ id: req.user._id }, process.env.JWT_SECRET);
    res.json({ success: true, token });
  }
);

router.get('/profile',
  passport.authenticate('jwt', { session: false }),
  (req, res) => {
    res.json({ user: req.user });
  }
);
```

---

## Error Handling

```javascript
// Strategy with error handling
passport.use(new LocalStrategy({
  usernameField: 'email'
}, async (email, password, done) => {
  try {
    const user = await User.findOne({ email }).select('+password');
    
    if (!user) {
      return done(null, false, { message: 'User not found' });
    }
    
    if (!user.isActive) {
      return done(null, false, { message: 'Account deactivated' });
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password);
    
    if (!isPasswordValid) {
      return done(null, false, { message: 'Incorrect password' });
    }
    
    return done(null, user);
  } catch (error) {
    return done(error);
  }
}));
```

---

## Testing with Passport

```javascript
const request = require('supertest');
const app = require('../app');

describe('Authentication', () => {
  it('should login with valid credentials', async () => {
    const res = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      });
    
    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.token).toBeDefined();
  });
  
  it('should reject invalid credentials', async () => {
    const res = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'wrongpassword'
      });
    
    expect(res.status).toBe(401);
    expect(res.body.success).toBe(false);
  });
});
```

---

## Interview Questions

**Q1: What is Passport.js?**
- Authentication middleware for Node.js
- Supports 500+ authentication strategies
- Flexible and modular design

**Q2: What's the difference between session-based and JWT-based auth in Passport?**
- **Session**: Uses `passport.session()`, stores user in session
- **JWT**: Uses `{ session: false }`, stateless authentication

**Q3: What is a Passport strategy?**
- Authentication mechanism (local, OAuth, JWT, etc.)
- Pluggable modules for different auth methods
- Each strategy has its own configuration

**Q4: What do serializeUser and deserializeUser do?**
- **serializeUser**: Determines what user data to store in session
- **deserializeUser**: Retrieves full user object from stored data

**Q5: How do you use multiple strategies with Passport?**
- Configure each strategy with unique name
- Call `passport.authenticate('strategy-name')` for specific strategy

**Q6: What's the purpose of the done callback?**
- Signals completion of async authentication
- `done(error, user, info)`
- Returns error, authenticated user, or failure info

---

## Best Practices

1. **Use appropriate strategy** - Local for username/password, JWT for APIs
2. **Disable sessions for APIs** - Use `{ session: false }` with JWT
3. **Handle errors properly** - Use custom callbacks for control
4. **Validate user state** - Check isActive, emailVerified, etc.
5. **Use custom callbacks** - Better error handling and responses
6. **Don't store sensitive data** - Only store user ID in session
7. **Combine strategies** - Local + OAuth for flexibility
8. **Test authentication** - Unit and integration tests
9. **Keep strategies updated** - Regular npm updates
10. **Use environment variables** - OAuth credentials, secrets

---

## Summary

- **Passport.js** simplifies authentication in Express
- **Local Strategy** for username/password authentication
- **JWT Strategy** for stateless API authentication
- **OAuth Strategies** for social login (Google, Facebook, GitHub)
- Use **sessions** for traditional web apps
- Use **{ session: false }** for JWT-based APIs
- **serializeUser/deserializeUser** manage session data
- **Custom callbacks** provide full control over auth flow
- Support **multiple strategies** in one application
- **Test authentication** flows thoroughly
