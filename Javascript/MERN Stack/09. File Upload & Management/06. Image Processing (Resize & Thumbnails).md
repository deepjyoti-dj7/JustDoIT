# 06. Image Processing (Resize & Thumbnails)

## Introduction

Image processing is essential for optimizing performance and user experience. **Sharp** is a high-performance Node.js library for resizing, converting, and manipulating images.

---

## Why Image Processing?

### Benefits

1. **Reduced File Size** - Faster loading, less bandwidth
2. **Responsive Images** - Different sizes for different devices
3. **Thumbnails** - Quick previews without loading full images
4. **Consistent Dimensions** - Uniform UI appearance
5. **Format Conversion** - WebP for smaller sizes
6. **Image Optimization** - Automatic compression

---

## Sharp Library

### Installation

```bash
npm install sharp
```

### Basic Usage

```javascript
const sharp = require('sharp');

// Resize image
await sharp('input.jpg')
  .resize(300, 300)
  .toFile('output.jpg');

// Get image info
const metadata = await sharp('input.jpg').metadata();
console.log(metadata); // { width, height, format, size, ... }
```

---

## Resize Images

### 1. **Fixed Width & Height**

```javascript
await sharp('input.jpg')
  .resize(800, 600)  // width x height
  .toFile('resized.jpg');
```

### 2. **Maintain Aspect Ratio**

```javascript
// Resize to width, auto-calculate height
await sharp('input.jpg')
  .resize(800)
  .toFile('resized.jpg');

// Resize to height, auto-calculate width
await sharp('input.jpg')
  .resize(null, 600)
  .toFile('resized.jpg');
```

### 3. **Fit Options**

```javascript
// Cover: Crop to fill dimensions (may crop)
await sharp('input.jpg')
  .resize(800, 600, {
    fit: 'cover',
    position: 'center' // or 'top', 'bottom', 'left', 'right'
  })
  .toFile('cover.jpg');

// Contain: Fit inside dimensions (may have empty space)
await sharp('input.jpg')
  .resize(800, 600, {
    fit: 'contain',
    background: { r: 255, g: 255, b: 255, alpha: 1 } // white background
  })
  .toFile('contain.jpg');

// Fill: Ignore aspect ratio, stretch to fill
await sharp('input.jpg')
  .resize(800, 600, { fit: 'fill' })
  .toFile('fill.jpg');

// Inside: Resize to fit inside, preserve aspect ratio
await sharp('input.jpg')
  .resize(800, 600, { fit: 'inside' })
  .toFile('inside.jpg');

// Outside: Resize to cover outside, preserve aspect ratio
await sharp('input.jpg')
  .resize(800, 600, { fit: 'outside' })
  .toFile('outside.jpg');
```

---

## Create Thumbnails

### Single Thumbnail

```javascript
await sharp('input.jpg')
  .resize(200, 200, { fit: 'cover' })
  .jpeg({ quality: 80 })
  .toFile('thumbnail.jpg');
```

### Multiple Sizes

```javascript
const createMultipleSizes = async (inputPath) => {
  const sizes = [
    { name: 'thumbnail', width: 200, height: 200 },
    { name: 'small', width: 400, height: 400 },
    { name: 'medium', width: 800, height: 800 },
    { name: 'large', width: 1200, height: 1200 }
  ];
  
  const results = await Promise.all(
    sizes.map(size => 
      sharp(inputPath)
        .resize(size.width, size.height, { fit: 'cover' })
        .jpeg({ quality: 80 })
        .toFile(`${size.name}.jpg`)
    )
  );
  
  return results;
};
```

---

## Image Optimization

### Compression

```javascript
// JPEG compression
await sharp('input.jpg')
  .jpeg({ quality: 80, progressive: true })
  .toFile('compressed.jpg');

// PNG compression
await sharp('input.png')
  .png({ compressionLevel: 9, progressive: true })
  .toFile('compressed.png');

// WebP (smaller file size)
await sharp('input.jpg')
  .webp({ quality: 80 })
  .toFile('output.webp');
```

### Format Conversion

```javascript
// Convert to WebP
await sharp('input.jpg')
  .webp({ quality: 80 })
  .toFile('output.webp');

// Convert to PNG
await sharp('input.jpg')
  .png()
  .toFile('output.png');

// Convert to AVIF (best compression)
await sharp('input.jpg')
  .avif({ quality: 80 })
  .toFile('output.avif');
```

---

## Multer + Sharp Integration

### Resize After Upload

```javascript
// routes/upload.js
const multer = require('multer');
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;

// Use memory storage (don't save original)
const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 5 * 1024 * 1024 }
});

router.post('/upload', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    
    const filename = Date.now() + '.jpg';
    const outputPath = path.join('uploads', filename);
    
    // Process and save
    await sharp(req.file.buffer)
      .resize(800, 600, { fit: 'cover' })
      .jpeg({ quality: 80 })
      .toFile(outputPath);
    
    res.json({
      message: 'Image uploaded and resized',
      url: `/uploads/${filename}`
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

### Create Multiple Versions

```javascript
router.post('/upload', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    
    const timestamp = Date.now();
    const versions = {};
    
    // Original (optimized)
    const originalPath = `uploads/original-${timestamp}.jpg`;
    await sharp(req.file.buffer)
      .jpeg({ quality: 90 })
      .toFile(originalPath);
    versions.original = `/uploads/original-${timestamp}.jpg`;
    
    // Thumbnail
    const thumbPath = `uploads/thumb-${timestamp}.jpg`;
    await sharp(req.file.buffer)
      .resize(200, 200, { fit: 'cover' })
      .jpeg({ quality: 80 })
      .toFile(thumbPath);
    versions.thumbnail = `/uploads/thumb-${timestamp}.jpg`;
    
    // Medium
    const mediumPath = `uploads/medium-${timestamp}.jpg`;
    await sharp(req.file.buffer)
      .resize(800, 600, { fit: 'cover' })
      .jpeg({ quality: 80 })
      .toFile(mediumPath);
    versions.medium = `/uploads/medium-${timestamp}.jpg`;
    
    res.json({
      message: 'Image uploaded with multiple versions',
      versions
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

---

## Advanced Processing

### Cropping

```javascript
// Extract a region
await sharp('input.jpg')
  .extract({ left: 100, top: 100, width: 500, height: 500 })
  .toFile('cropped.jpg');

// Smart crop (focus on interesting areas)
await sharp('input.jpg')
  .resize(400, 400, {
    fit: 'cover',
    position: sharp.strategy.entropy // or sharp.strategy.attention
  })
  .toFile('smart-crop.jpg');
```

### Rotating

```javascript
// Rotate by angle
await sharp('input.jpg')
  .rotate(90)
  .toFile('rotated.jpg');

// Auto-rotate based on EXIF
await sharp('input.jpg')
  .rotate() // Uses EXIF orientation
  .toFile('auto-rotated.jpg');
```

### Filters and Effects

```javascript
// Grayscale
await sharp('input.jpg')
  .grayscale()
  .toFile('grayscale.jpg');

// Blur
await sharp('input.jpg')
  .blur(5)
  .toFile('blurred.jpg');

// Sharpen
await sharp('input.jpg')
  .sharpen()
  .toFile('sharpened.jpg');

// Negate (invert colors)
await sharp('input.jpg')
  .negate()
  .toFile('negative.jpg');

// Flip/Flop
await sharp('input.jpg')
  .flip() // vertical flip
  .toFile('flipped.jpg');

await sharp('input.jpg')
  .flop() // horizontal flip
  .toFile('flopped.jpg');
```

### Watermarks

```javascript
const addWatermark = async (inputPath, watermarkPath, outputPath) => {
  await sharp(inputPath)
    .composite([
      {
        input: watermarkPath,
        gravity: 'southeast' // position
      }
    ])
    .toFile(outputPath);
};
```

### Text Overlay

```javascript
// Create text overlay using SVG
const textSvg = `
  <svg width="800" height="100">
    <text x="50%" y="50%" text-anchor="middle" font-size="48" fill="white" stroke="black" stroke-width="2">
      Sample Watermark
    </text>
  </svg>
`;

await sharp('input.jpg')
  .composite([
    {
      input: Buffer.from(textSvg),
      gravity: 'south'
    }
  ])
  .toFile('watermarked.jpg');
```

---

## Complete Processing Pipeline

```javascript
// services/imageProcessor.js
const sharp = require('sharp');
const path = require('path');
const fs = require('fs').promises;

class ImageProcessor {
  constructor(uploadDir = 'uploads') {
    this.uploadDir = uploadDir;
  }
  
  async process(buffer, options = {}) {
    const {
      filename = `${Date.now()}.jpg`,
      sizes = ['thumbnail', 'small', 'medium', 'original'],
      quality = 80,
      format = 'jpeg'
    } = options;
    
    const results = {};
    
    const sizeConfigs = {
      thumbnail: { width: 200, height: 200, fit: 'cover' },
      small: { width: 400, height: 400, fit: 'cover' },
      medium: { width: 800, height: 800, fit: 'cover' },
      large: { width: 1200, height: 1200, fit: 'cover' },
      original: null // No resize
    };
    
    for (const size of sizes) {
      const config = sizeConfigs[size];
      const outputFilename = `${size}-${filename}`;
      const outputPath = path.join(this.uploadDir, outputFilename);
      
      let pipeline = sharp(buffer);
      
      // Resize if config provided
      if (config) {
        pipeline = pipeline.resize(config.width, config.height, { fit: config.fit });
      }
      
      // Apply format and quality
      if (format === 'jpeg') {
        pipeline = pipeline.jpeg({ quality });
      } else if (format === 'png') {
        pipeline = pipeline.png({ quality });
      } else if (format === 'webp') {
        pipeline = pipeline.webp({ quality });
      }
      
      // Save file
      await pipeline.toFile(outputPath);
      
      results[size] = {
        filename: outputFilename,
        path: outputPath,
        url: `/uploads/${outputFilename}`
      };
    }
    
    return results;
  }
  
  async delete(filenames) {
    await Promise.all(
      filenames.map(filename => 
        fs.unlink(path.join(this.uploadDir, filename))
      )
    );
  }
}

module.exports = new ImageProcessor();
```

### Usage

```javascript
// routes/upload.js
const imageProcessor = require('../services/imageProcessor');

router.post('/upload', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    
    const results = await imageProcessor.process(req.file.buffer, {
      filename: `${Date.now()}.jpg`,
      sizes: ['thumbnail', 'medium', 'original'],
      quality: 80,
      format: 'jpeg'
    });
    
    res.json({
      message: 'Image processed successfully',
      versions: results
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

---

## Interview Questions

**Q1: What is Sharp and why use it?**
- High-performance image processing library for Node.js
- Faster than ImageMagick and GraphicsMagick
- Supports resize, crop, rotate, format conversion
- Low memory usage

**Q2: How do you create thumbnails with Sharp?**
```javascript
await sharp('input.jpg')
  .resize(200, 200, { fit: 'cover' })
  .jpeg({ quality: 80 })
  .toFile('thumbnail.jpg');
```

**Q3: What are the fit options in Sharp?**
- `cover`: Crop to fill (default)
- `contain`: Fit inside, preserve aspect ratio
- `fill`: Stretch to fill
- `inside`: Resize to fit inside
- `outside`: Resize to cover outside

**Q4: How do you optimize images for web?**
```javascript
await sharp('input.jpg')
  .resize(800, 600)
  .jpeg({ quality: 80, progressive: true })
  .toFile('optimized.jpg');
```

**Q5: How do you convert images to WebP?**
```javascript
await sharp('input.jpg')
  .webp({ quality: 80 })
  .toFile('output.webp');
```

---

## Best Practices

1. **Use memory storage** with Multer (don't save original)
2. **Create multiple sizes** for responsive images
3. **Optimize quality** (80-90 for JPEG)
4. **Use WebP format** for smaller file sizes
5. **Auto-rotate** based on EXIF orientation
6. **Process asynchronously** to avoid blocking
7. **Delete failed uploads** immediately
8. **Cache processed images** to avoid re-processing
9. **Use progressive JPEG** for better perceived loading
10. **Set dimensions limit** to prevent memory issues

---

## Summary

- **Sharp**: High-performance image processing library
- **Resize**: `.resize(width, height, { fit })`
- **Optimize**: `.jpeg({ quality: 80 })`
- **Format conversion**: `.webp()`, `.png()`, `.avif()`
- **Thumbnails**: Create multiple sizes for different use cases
- **Multer integration**: Use memory storage + Sharp pipeline
- **Effects**: Grayscale, blur, sharpen, rotate, crop
- **Watermarks**: `.composite()` for overlays
- **Performance**: Process asynchronously, cache results
