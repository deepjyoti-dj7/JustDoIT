# 10. Security & Best Practices

## Introduction

File upload security is critical to prevent vulnerabilities like malicious file uploads, path traversal, DOS attacks, and data breaches. This guide covers essential security practices.

---

## File Upload Security Risks

### Common Vulnerabilities

1. **Malicious File Upload** - Executable files (`.exe`, `.sh`, `.php`)
2. **Path Traversal** - Filenames like `../../etc/passwd`
3. **XSS via SVG** - SVG files with embedded JavaScript
4. **DOS Attacks** - Uploading huge files to fill disk
5. **Code Injection** - PHP, JSP files executed on server
6. **MIME Type Spoofing** - Fake file extensions
7. **Zip Bombs** - Compressed files that expand massively
8. **CSRF Attacks** - Unauthorized file uploads

---

## File Type Validation

### 1. **Whitelist Approach (Recommended)**

```javascript
const ALLOWED_TYPES = {
  images: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
  documents: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
  videos: ['video/mp4', 'video/mpeg']
};

const validateFileType = (file, category) => {
  const allowedTypes = ALLOWED_TYPES[category];
  
  if (!allowedTypes) {
    throw new Error('Invalid category');
  }
  
  if (!allowedTypes.includes(file.mimetype)) {
    throw new Error(`Only ${allowedTypes.join(', ')} files are allowed`);
  }
};
```

### 2. **Never Trust MIME Type Alone**

```javascript
const FileType = require('file-type');
const fs = require('fs').promises;

const validateFileSignature = async (filePath, declaredMimetype) => {
  const buffer = await fs.readFile(filePath);
  const fileType = await FileType.fromBuffer(buffer);
  
  if (!fileType) {
    throw new Error('Unable to determine file type');
  }
  
  if (fileType.mime !== declaredMimetype) {
    throw new Error('File type mismatch');
  }
  
  return fileType;
};
```

### 3. **Block Executable Files**

```javascript
const BLOCKED_EXTENSIONS = [
  '.exe', '.bat', '.cmd', '.com', '.pif',
  '.sh', '.bash', '.zsh',
  '.php', '.jsp', '.asp', '.aspx',
  '.js', '.vbs', '.jar'
];

const isExecutable = (filename) => {
  const ext = path.extname(filename).toLowerCase();
  return BLOCKED_EXTENSIONS.includes(ext);
};

if (isExecutable(file.originalname)) {
  throw new Error('Executable files are not allowed');
}
```

---

## Filename Sanitization

### Prevent Path Traversal

```javascript
const path = require('path');

const sanitizeFilename = (filename) => {
  // Get basename only (removes directory path)
  let sanitized = path.basename(filename);
  
  // Remove null bytes
  sanitized = sanitized.replace(/\0/g, '');
  
  // Remove path separators
  sanitized = sanitized.replace(/[\/\\]/g, '');
  
  // Remove special characters
  sanitized = sanitized.replace(/[^a-zA-Z0-9._-]/g, '_');
  
  // Remove leading dots (hidden files)
  sanitized = sanitized.replace(/^\.+/, '');
  
  // Limit length
  if (sanitized.length > 255) {
    const ext = path.extname(sanitized);
    sanitized = sanitized.substring(0, 255 - ext.length) + ext;
  }
  
  return sanitized || 'unnamed';
};

// Usage
const safeFilename = sanitizeFilename(file.originalname);
```

### Use UUID for Filenames

```javascript
const { v4: uuidv4 } = require('uuid');
const path = require('path');

const generateSafeFilename = (originalName) => {
  const ext = path.extname(originalName);
  return `${uuidv4()}${ext}`;
};

// Safer: No user-controlled filename on disk
```

---

## File Size Limits

### Set Maximum Size

```javascript
const multer = require('multer');

const upload = multer({
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 10                   // Max 10 files per request
  }
});
```

### Check Available Disk Space

```javascript
const checkDiskSpace = require('check-disk-space').default;

const validateDiskSpace = async (requiredSpace) => {
  const diskSpace = await checkDiskSpace('/');
  
  if (diskSpace.free < requiredSpace) {
    throw new Error('Insufficient disk space');
  }
};

// Before accepting upload
await validateDiskSpace(100 * 1024 * 1024); // 100MB buffer
```

---

## Prevent XSS

### SVG Sanitization

```javascript
const DOMPurify = require('isomorphic-dompurify');
const fs = require('fs').promises;

const sanitizeSVG = async (filePath) => {
  const svgContent = await fs.readFile(filePath, 'utf-8');
  
  // Remove scripts and event handlers
  const clean = DOMPurify.sanitize(svgContent, {
    USE_PROFILES: { svg: true, svgFilters: true }
  });
  
  await fs.writeFile(filePath, clean);
};

// After uploading SVG
if (file.mimetype === 'image/svg+xml') {
  await sanitizeSVG(file.path);
}
```

### Content Security Policy

```javascript
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    imgSrc: ["'self'", "data:", "https:"],
    scriptSrc: ["'self'"], // No inline scripts
    objectSrc: ["'none'"]  // Block plugins
  }
}));
```

---

## Authentication & Authorization

### Require Authentication

```javascript
const authenticate = require('../middleware/auth');

router.post('/upload', authenticate, upload.single('file'), async (req, res) => {
  // Only authenticated users can upload
});
```

### Check Ownership

```javascript
router.delete('/file/:id', authenticate, async (req, res) => {
  const file = await File.findById(req.params.id);
  
  if (!file) {
    return res.status(404).json({ message: 'File not found' });
  }
  
  // Check ownership
  if (file.uploadedBy.toString() !== req.user.id && req.user.role !== 'admin') {
    return res.status(403).json({ message: 'Access denied' });
  }
  
  // Delete file
  await fs.unlink(file.path);
  await file.remove();
  
  res.json({ message: 'File deleted' });
});
```

### Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const uploadLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // 10 uploads per window
  message: 'Too many uploads. Please try again later.'
});

router.post('/upload', uploadLimiter, upload.single('file'), (req, res) => {
  // Upload logic
});
```

---

## Virus Scanning

### Using ClamAV

```bash
npm install clamscan
```

```javascript
const NodeClam = require('clamscan');

const initClamAV = async () => {
  const clamscan = await new NodeClam().init({
    removeInfected: true,
    quarantineInfected: './quarantine/',
    scanLog: './scan.log',
    debugMode: false
  });
  
  return clamscan;
};

const clamscan = await initClamAV();

router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    // Scan file for viruses
    const { isInfected, viruses } = await clamscan.isInfected(req.file.path);
    
    if (isInfected) {
      // File is infected, already removed by ClamAV
      return res.status(400).json({
        message: 'File is infected',
        viruses
      });
    }
    
    // File is clean, proceed
    res.json({ message: 'File uploaded and scanned' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

---

## Store Files Outside Web Root

### Don't Store in Public Directory

```javascript
// ❌ Bad: Files accessible directly
const storage = multer.diskStorage({
  destination: 'public/uploads/' // Anyone can access!
});

// ✅ Good: Files outside web root
const storage = multer.diskStorage({
  destination: '/var/uploads/' // Not directly accessible
});

// Serve through controlled endpoint
router.get('/file/:id', authenticate, async (req, res) => {
  const file = await File.findById(req.params.id);
  
  // Check permissions
  if (!canAccess(req.user, file)) {
    return res.status(403).json({ message: 'Access denied' });
  }
  
  res.sendFile(file.path);
});
```

---

## Logging & Monitoring

### Log Upload Activity

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'uploads.log' })
  ]
});

router.post('/upload', authenticate, upload.single('file'), async (req, res) => {
  logger.info('File upload', {
    userId: req.user.id,
    filename: req.file.filename,
    size: req.file.size,
    mimetype: req.file.mimetype,
    ip: req.ip,
    timestamp: new Date()
  });
  
  // Upload logic
});
```

### Monitor Failed Uploads

```javascript
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    logger.warn('Upload failed', {
      error: err.code,
      userId: req.user?.id,
      ip: req.ip,
      timestamp: new Date()
    });
    
    return res.status(400).json({ message: err.message });
  }
  
  next(err);
});
```

---

## Database Security

### Store Metadata, Not Files

```javascript
const fileSchema = new mongoose.Schema({
  filename: String,
  originalName: String,
  path: String,           // Server path (not exposed)
  publicUrl: String,      // Public URL (if applicable)
  size: Number,
  mimetype: String,
  uploadedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  isPublic: { type: Boolean, default: false },
  downloadCount: { type: Number, default: 0 },
  uploadedAt: { type: Date, default: Date.now },
  expiresAt: Date         // Auto-delete after expiration
});

// Don't store file content in database (except small files)
```

### Encrypt Sensitive Files

```javascript
const crypto = require('crypto');
const fs = require('fs');

const encryptFile = (inputPath, outputPath, key) => {
  return new Promise((resolve, reject) => {
    const cipher = crypto.createCipher('aes-256-cbc', key);
    const input = fs.createReadStream(inputPath);
    const output = fs.createWriteStream(outputPath);
    
    input.pipe(cipher).pipe(output);
    
    output.on('finish', resolve);
    output.on('error', reject);
  });
};

// After upload
await encryptFile(req.file.path, req.file.path + '.enc', process.env.ENCRYPTION_KEY);
fs.unlinkSync(req.file.path); // Delete unencrypted file
```

---

## CSRF Protection

```javascript
const csrf = require('csurf');

const csrfProtection = csrf({ cookie: true });

// For session-based uploads
router.post('/upload', csrfProtection, upload.single('file'), (req, res) => {
  // Upload logic
});

// For JWT-based APIs, CSRF is not needed (if using Authorization header)
```

---

## Best Practices Checklist

### Input Validation
- [ ] Whitelist allowed file types
- [ ] Validate MIME type AND extension
- [ ] Verify file signature (magic numbers)
- [ ] Sanitize filenames
- [ ] Set maximum file size
- [ ] Limit number of files per request
- [ ] Block executable files

### Storage
- [ ] Store files outside web root
- [ ] Use UUID for filenames
- [ ] Organize files in subdirectories
- [ ] Check available disk space
- [ ] Implement file expiration
- [ ] Regular cleanup of old files

### Security
- [ ] Require authentication for uploads
- [ ] Verify file ownership before access/delete
- [ ] Scan files for viruses
- [ ] Sanitize SVG files
- [ ] Implement rate limiting
- [ ] Log all upload activity
- [ ] Encrypt sensitive files
- [ ] Use HTTPS for uploads

### Performance
- [ ] Use streaming for large files
- [ ] Implement CDN for serving files
- [ ] Compress images before storage
- [ ] Generate thumbnails asynchronously
- [ ] Cache frequently accessed files

### Cloud Storage
- [ ] Use signed URLs for private files
- [ ] Set appropriate ACL permissions
- [ ] Enable versioning for important files
- [ ] Implement lifecycle policies
- [ ] Monitor storage costs

---

## Interview Questions

**Q1: How do you prevent malicious file uploads?**
- Whitelist allowed file types
- Validate file signature, not just extension
- Scan for viruses
- Store files outside web root
- Sanitize filenames

**Q2: What is path traversal and how to prevent it?**
- Attack: Filename like `../../etc/passwd`
- Prevention: Use `path.basename()`, sanitize filenames, use UUIDs

**Q3: How do you validate file types securely?**
- Check MIME type
- Validate file extension
- Verify file signature (magic numbers) using `file-type` library

**Q4: How do you prevent DOS attacks via file uploads?**
- Set file size limits
- Limit number of files per request
- Implement rate limiting
- Check available disk space
- Use queue for processing

**Q5: Should you store files in the database?**
- **No** for large files (performance, cost)
- **Store**: Metadata (filename, size, path, user)
- **File system/Cloud**: Actual file content

---

## Summary

- **Validate files**: MIME type, extension, file signature
- **Sanitize filenames**: Remove special characters, use UUID
- **Set limits**: File size, count, rate limiting
- **Block executables**: `.exe`, `.php`, `.sh`, etc.
- **Store securely**: Outside web root, encrypt sensitive files
- **Require auth**: Verify ownership before access/delete
- **Scan for viruses**: Use ClamAV or similar
- **Sanitize SVG**: Remove scripts and event handlers
- **Log activity**: Track uploads, failures, suspicious activity
- **Monitor**: Disk space, costs, security events
