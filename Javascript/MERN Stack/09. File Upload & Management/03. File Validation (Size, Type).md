# 03. File Validation (Size, Type)

## Introduction

File validation is crucial for security and performance. You must validate file size, type, and content to prevent malicious uploads and server overload.

---

## Why Validate Files?

### Security Risks

1. **Malicious Files** - Executable files (`.exe`, `.sh`)
2. **Code Injection** - PHP, JavaScript files
3. **DOS Attacks** - Large files to fill disk space
4. **XSS Attacks** - SVG with embedded scripts
5. **Path Traversal** - Filenames like `../../etc/passwd`

### Performance Issues

- Large files consume bandwidth
- Excessive storage costs
- Slow processing times

---

## File Size Validation

### 1. **Using Multer Limits**

```javascript
const multer = require('multer');

const upload = multer({
  storage: multer.diskStorage({
    destination: 'uploads/',
    filename: (req, file, cb) => {
      cb(null, Date.now() + '-' + file.originalname);
    }
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB in bytes
    files: 10                   // Max 10 files per request
  }
});
```

### 2. **Custom Size Validation**

```javascript
const validateFileSize = (maxSize) => {
  return (req, file, cb) => {
    if (file.size > maxSize) {
      return cb(new Error(`File too large. Max size: ${maxSize / (1024 * 1024)}MB`));
    }
    cb(null, true);
  };
};

const upload = multer({
  storage,
  fileFilter: validateFileSize(5 * 1024 * 1024)
});
```

### 3. **Different Limits for Different File Types**

```javascript
const fileFilter = (req, file, cb) => {
  const maxSizes = {
    'image/jpeg': 5 * 1024 * 1024,   // 5MB for images
    'image/png': 5 * 1024 * 1024,
    'application/pdf': 10 * 1024 * 1024, // 10MB for PDFs
    'video/mp4': 50 * 1024 * 1024    // 50MB for videos
  };
  
  const maxSize = maxSizes[file.mimetype];
  
  if (!maxSize) {
    return cb(new Error('File type not allowed'));
  }
  
  if (file.size > maxSize) {
    return cb(new Error(`File too large. Max size for ${file.mimetype}: ${maxSize / (1024 * 1024)}MB`));
  }
  
  cb(null, true);
};

const upload = multer({ storage, fileFilter });
```

---

## File Type Validation

### 1. **MIME Type Validation**

```javascript
const fileFilter = (req, file, cb) => {
  const allowedMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  
  if (allowedMimeTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, GIF, and WebP allowed.'));
  }
};

const upload = multer({ storage, fileFilter });
```

### 2. **File Extension Validation**

```javascript
const path = require('path');

const fileFilter = (req, file, cb) => {
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
  const ext = path.extname(file.originalname).toLowerCase();
  
  if (allowedExtensions.includes(ext)) {
    cb(null, true);
  } else {
    cb(new Error(`Invalid file extension. Allowed: ${allowedExtensions.join(', ')}`));
  }
};
```

### 3. **Combined MIME Type + Extension Validation**

```javascript
const fileFilter = (req, file, cb) => {
  const allowedTypes = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'image/gif': ['.gif'],
    'application/pdf': ['.pdf']
  };
  
  const ext = path.extname(file.originalname).toLowerCase();
  const allowedExtensions = allowedTypes[file.mimetype];
  
  if (!allowedExtensions) {
    return cb(new Error('File type not allowed'));
  }
  
  if (!allowedExtensions.includes(ext)) {
    return cb(new Error('File extension does not match MIME type'));
  }
  
  cb(null, true);
};
```

### 4. **Using Regular Expressions**

```javascript
const fileFilter = (req, file, cb) => {
  // Allow images only
  const allowedMimePattern = /^image\/(jpeg|png|gif|webp)$/;
  const allowedExtPattern = /\.(jpg|jpeg|png|gif|webp)$/i;
  
  const mimetypeValid = allowedMimePattern.test(file.mimetype);
  const extnameValid = allowedExtPattern.test(path.extname(file.originalname));
  
  if (mimetypeValid && extnameValid) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed'));
  }
};
```

---

## Content-Based Validation

### Magic Number (File Signature) Validation

MIME types can be spoofed. Use magic numbers to verify actual file content.

```javascript
const fs = require('fs');

// File signatures (magic numbers)
const fileSignatures = {
  'image/jpeg': ['ffd8ffe0', 'ffd8ffe1', 'ffd8ffe2'],
  'image/png': ['89504e47'],
  'application/pdf': ['25504446'],
  'image/gif': ['47494638']
};

const validateFileSignature = (filePath, mimetype) => {
  return new Promise((resolve, reject) => {
    const buffer = Buffer.alloc(4);
    
    fs.open(filePath, 'r', (err, fd) => {
      if (err) return reject(err);
      
      fs.read(fd, buffer, 0, 4, 0, (err) => {
        fs.close(fd, () => {});
        
        if (err) return reject(err);
        
        const hex = buffer.toString('hex');
        const signatures = fileSignatures[mimetype];
        
        if (!signatures) {
          return reject(new Error('Unsupported file type'));
        }
        
        const isValid = signatures.some(sig => hex.startsWith(sig));
        
        if (isValid) {
          resolve(true);
        } else {
          reject(new Error('File signature does not match declared type'));
        }
      });
    });
  });
};

// Usage
router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    await validateFileSignature(req.file.path, req.file.mimetype);
    res.json({ message: 'File is valid' });
  } catch (error) {
    fs.unlinkSync(req.file.path); // Delete invalid file
    res.status(400).json({ message: error.message });
  }
});
```

### Using file-type Library

```bash
npm install file-type
```

```javascript
const FileType = require('file-type');
const fs = require('fs').promises;

router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    // Read file buffer
    const buffer = await fs.readFile(req.file.path);
    
    // Detect actual file type
    const fileType = await FileType.fromBuffer(buffer);
    
    if (!fileType) {
      throw new Error('Unable to determine file type');
    }
    
    // Verify it matches declared type
    if (fileType.mime !== req.file.mimetype) {
      throw new Error(`File type mismatch. Expected ${req.file.mimetype}, got ${fileType.mime}`);
    }
    
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (!allowedTypes.includes(fileType.mime)) {
      throw new Error('File type not allowed');
    }
    
    res.json({ message: 'File validated successfully' });
  } catch (error) {
    await fs.unlink(req.file.path); // Delete invalid file
    res.status(400).json({ message: error.message });
  }
});
```

---

## Complete Validation Example

```javascript
// config/fileValidation.js
const path = require('path');

const validateFile = {
  images: {
    allowedMimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
    allowedExtensions: ['.jpg', '.jpeg', '.png', '.gif', '.webp'],
    maxSize: 5 * 1024 * 1024 // 5MB
  },
  documents: {
    allowedMimeTypes: ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
    allowedExtensions: ['.pdf', '.doc', '.docx'],
    maxSize: 10 * 1024 * 1024 // 10MB
  },
  videos: {
    allowedMimeTypes: ['video/mp4', 'video/mpeg', 'video/quicktime'],
    allowedExtensions: ['.mp4', '.mpeg', '.mov'],
    maxSize: 100 * 1024 * 1024 // 100MB
  }
};

const createFileFilter = (category) => {
  return (req, file, cb) => {
    const config = validateFile[category];
    
    if (!config) {
      return cb(new Error('Invalid file category'));
    }
    
    // Validate MIME type
    if (!config.allowedMimeTypes.includes(file.mimetype)) {
      return cb(new Error(`Invalid file type. Allowed: ${config.allowedMimeTypes.join(', ')}`));
    }
    
    // Validate extension
    const ext = path.extname(file.originalname).toLowerCase();
    if (!config.allowedExtensions.includes(ext)) {
      return cb(new Error(`Invalid file extension. Allowed: ${config.allowedExtensions.join(', ')}`));
    }
    
    cb(null, true);
  };
};

module.exports = { validateFile, createFileFilter };
```

```javascript
// routes/upload.js
const multer = require('multer');
const { createFileFilter, validateFile } = require('../config/fileValidation');

const storage = multer.diskStorage({
  destination: 'uploads/',
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// Image upload
const imageUpload = multer({
  storage,
  fileFilter: createFileFilter('images'),
  limits: { fileSize: validateFile.images.maxSize }
});

// Document upload
const documentUpload = multer({
  storage,
  fileFilter: createFileFilter('documents'),
  limits: { fileSize: validateFile.documents.maxSize }
});

router.post('/image', imageUpload.single('image'), (req, res) => {
  res.json({ message: 'Image uploaded', file: req.file });
});

router.post('/document', documentUpload.single('document'), (req, res) => {
  res.json({ message: 'Document uploaded', file: req.file });
});
```

---

## Error Handling

```javascript
app.use((err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({
        message: 'File too large',
        maxSize: '5MB'
      });
    }
    
    if (err.code === 'LIMIT_FILE_COUNT') {
      return res.status(400).json({
        message: 'Too many files',
        maxCount: 10
      });
    }
    
    if (err.code === 'LIMIT_UNEXPECTED_FILE') {
      return res.status(400).json({
        message: 'Unexpected field name',
        expectedField: 'file'
      });
    }
  }
  
  if (err.message) {
    return res.status(400).json({ message: err.message });
  }
  
  res.status(500).json({ message: 'Internal server error' });
});
```

---

## Frontend Validation

```javascript
// components/FileUpload.jsx
import { useState } from 'react';

const FileUpload = () => {
  const [error, setError] = useState('');
  
  const validateFile = (file) => {
    const maxSize = 5 * 1024 * 1024; // 5MB
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    
    // Check file size
    if (file.size > maxSize) {
      setError(`File too large. Max size: ${maxSize / (1024 * 1024)}MB`);
      return false;
    }
    
    // Check file type
    if (!allowedTypes.includes(file.type)) {
      setError('Invalid file type. Only JPEG, PNG, and GIF allowed.');
      return false;
    }
    
    setError('');
    return true;
  };
  
  const handleFileChange = (e) => {
    const file = e.target.files[0];
    
    if (file && validateFile(file)) {
      // Proceed with upload
      console.log('File is valid:', file);
    } else {
      e.target.value = ''; // Clear input
    }
  };
  
  return (
    <div>
      <input 
        type="file" 
        onChange={handleFileChange}
        accept="image/jpeg,image/png,image/gif"
      />
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </div>
  );
};

export default FileUpload;
```

---

## Interview Questions

**Q1: How do you limit file size in Multer?**
```javascript
const upload = multer({
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB
});
```

**Q2: How do you validate file types?**
Use `fileFilter` callback:
```javascript
fileFilter: (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only images allowed'));
  }
}
```

**Q3: What's the difference between MIME type and file extension?**
- **MIME type**: `file.mimetype` (e.g., `image/jpeg`) - can be spoofed
- **Extension**: `path.extname(file.originalname)` (e.g., `.jpg`) - can be changed
- **Best practice**: Validate both + check file signature

**Q4: How do you prevent spoofed file types?**
Validate file signature (magic numbers) using libraries like `file-type`:
```javascript
const fileType = await FileType.fromBuffer(buffer);
if (fileType.mime !== req.file.mimetype) {
  throw new Error('File type mismatch');
}
```

**Q5: What are Multer error codes?**
- `LIMIT_FILE_SIZE`: File exceeds size limit
- `LIMIT_FILE_COUNT`: Too many files
- `LIMIT_UNEXPECTED_FILE`: Wrong field name

---

## Best Practices

1. **Validate on both client and server** (client for UX, server for security)
2. **Check MIME type AND extension** for better security
3. **Use file signature validation** for critical applications
4. **Set appropriate size limits** based on file type
5. **Delete invalid files immediately** to save space
6. **Provide clear error messages** to users
7. **Use whitelist approach** (allow only specific types)
8. **Never trust client-side validation** alone
9. **Log validation failures** for security monitoring
10. **Sanitize filenames** to prevent path traversal

---

## Summary

- **File size**: Use Multer `limits.fileSize` option
- **File type**: Validate MIME type AND extension in `fileFilter`
- **File signature**: Use `file-type` library to verify actual content
- **Error handling**: Handle Multer errors with error middleware
- **Frontend validation**: Validate before upload for better UX
- **Security**: Always validate on server, don't trust client
- **Delete invalid files** immediately after detection
- **Whitelist approach**: Only allow specific file types
