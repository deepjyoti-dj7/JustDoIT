# 09. File Download & Streaming

## Introduction

File download and streaming are essential for serving files to users. Streaming is efficient for large files as it sends data in chunks rather than loading the entire file into memory.

---

## File Download

### Simple Download

```javascript
// routes/download.js
const express = require('express');
const path = require('path');
const fs = require('fs');

const router = express.Router();

router.get('/download/:filename', (req, res) => {
  const { filename } = req.params;
  const filePath = path.join(__dirname, '../uploads', filename);
  
  // Check if file exists
  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ message: 'File not found' });
  }
  
  // Send file for download
  res.download(filePath, (err) => {
    if (err) {
      res.status(500).json({ message: 'Download failed' });
    }
  });
});

module.exports = router;
```

### Download with Custom Filename

```javascript
router.get('/download/:id', async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({ message: 'File not found' });
    }
    
    // Download with original filename
    res.download(file.path, file.originalName, (err) => {
      if (err) {
        res.status(500).json({ message: 'Download failed' });
      }
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

### Force Download (Attachment)

```javascript
router.get('/download/:filename', (req, res) => {
  const filePath = path.join(__dirname, '../uploads', req.params.filename);
  
  // Set Content-Disposition header to force download
  res.setHeader('Content-Disposition', `attachment; filename="${req.params.filename}"`);
  res.setHeader('Content-Type', 'application/octet-stream');
  
  const fileStream = fs.createReadStream(filePath);
  fileStream.pipe(res);
});
```

---

## File Streaming

### Basic Streaming

```javascript
router.get('/stream/:filename', (req, res) => {
  const filePath = path.join(__dirname, '../uploads', req.params.filename);
  
  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ message: 'File not found' });
  }
  
  // Get file stats
  const stat = fs.statSync(filePath);
  
  // Set headers
  res.setHeader('Content-Type', 'application/octet-stream');
  res.setHeader('Content-Length', stat.size);
  
  // Create read stream and pipe to response
  const fileStream = fs.createReadStream(filePath);
  fileStream.pipe(res);
  
  // Handle errors
  fileStream.on('error', (err) => {
    res.status(500).json({ message: 'Streaming failed' });
  });
});
```

### Video Streaming with Range Support

```javascript
router.get('/video/:filename', (req, res) => {
  const filePath = path.join(__dirname, '../uploads/videos', req.params.filename);
  
  if (!fs.existsSync(filePath)) {
    return res.status(404).send('Video not found');
  }
  
  const stat = fs.statSync(filePath);
  const fileSize = stat.size;
  const range = req.headers.range;
  
  if (range) {
    // Parse range header
    const parts = range.replace(/bytes=/, "").split("-");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
    const chunkSize = (end - start) + 1;
    
    // Create read stream for range
    const fileStream = fs.createReadStream(filePath, { start, end });
    
    // Set partial content headers
    res.writeHead(206, {
      'Content-Range': `bytes ${start}-${end}/${fileSize}`,
      'Accept-Ranges': 'bytes',
      'Content-Length': chunkSize,
      'Content-Type': 'video/mp4'
    });
    
    fileStream.pipe(res);
  } else {
    // No range requested, send entire file
    res.writeHead(200, {
      'Content-Length': fileSize,
      'Content-Type': 'video/mp4'
    });
    
    fs.createReadStream(filePath).pipe(res);
  }
});
```

### Audio Streaming

```javascript
router.get('/audio/:filename', (req, res) => {
  const filePath = path.join(__dirname, '../uploads/audio', req.params.filename);
  
  if (!fs.existsSync(filePath)) {
    return res.status(404).send('Audio not found');
  }
  
  const stat = fs.statSync(filePath);
  const fileSize = stat.size;
  const range = req.headers.range;
  
  if (range) {
    const parts = range.replace(/bytes=/, "").split("-");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
    const chunkSize = (end - start) + 1;
    
    const fileStream = fs.createReadStream(filePath, { start, end });
    
    res.writeHead(206, {
      'Content-Range': `bytes ${start}-${end}/${fileSize}`,
      'Accept-Ranges': 'bytes',
      'Content-Length': chunkSize,
      'Content-Type': 'audio/mpeg'
    });
    
    fileStream.pipe(res);
  } else {
    res.writeHead(200, {
      'Content-Length': fileSize,
      'Content-Type': 'audio/mpeg'
    });
    
    fs.createReadStream(filePath).pipe(res);
  }
});
```

---

## Protected Downloads

### Download with Authentication

```javascript
const authenticate = require('../middleware/auth');

router.get('/download/:id', authenticate, async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({ message: 'File not found' });
    }
    
    // Check if user owns the file or is admin
    if (file.uploadedBy.toString() !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    res.download(file.path, file.originalName);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

### Temporary Download Links

```javascript
const jwt = require('jsonwebtoken');

// Generate temporary download link
router.get('/generate-link/:id', authenticate, async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({ message: 'File not found' });
    }
    
    // Check ownership
    if (file.uploadedBy.toString() !== req.user.id) {
      return res.status(403).json({ message: 'Access denied' });
    }
    
    // Generate token valid for 1 hour
    const token = jwt.sign(
      { fileId: file._id },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
    
    const downloadLink = `${req.protocol}://${req.get('host')}/api/download/temp/${token}`;
    
    res.json({ downloadLink });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Download with temporary token
router.get('/temp/:token', async (req, res) => {
  try {
    const decoded = jwt.verify(req.params.token, process.env.JWT_SECRET);
    const file = await File.findById(decoded.fileId);
    
    if (!file) {
      return res.status(404).json({ message: 'File not found' });
    }
    
    res.download(file.path, file.originalName);
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Download link expired' });
    }
    res.status(500).json({ message: 'Invalid download link' });
  }
});
```

---

## Download from Cloud Storage

### Download from Cloudinary

```javascript
const { cloudinary } = require('../config/cloudinary');

router.get('/cloudinary/:publicId', (req, res) => {
  const { publicId } = req.params;
  
  // Generate download URL
  const url = cloudinary.url(publicId, {
    flags: 'attachment',
    resource_type: 'auto'
  });
  
  // Redirect to Cloudinary URL
  res.redirect(url);
});
```

### Download from AWS S3

```javascript
const { s3 } = require('../config/s3');

router.get('/s3/:key', async (req, res) => {
  try {
    const { key } = req.params;
    
    const params = {
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: key
    };
    
    // Get file stream from S3
    const fileStream = s3.getObject(params).createReadStream();
    
    // Set headers
    res.setHeader('Content-Disposition', `attachment; filename="${key}"`);
    
    // Pipe stream to response
    fileStream.pipe(res);
    
    fileStream.on('error', (err) => {
      res.status(500).json({ message: 'Download failed' });
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Generate signed URL for direct download
router.get('/s3/signed/:key', async (req, res) => {
  try {
    const { key } = req.params;
    
    const params = {
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: key,
      Expires: 60 * 60, // 1 hour
      ResponseContentDisposition: `attachment; filename="${key}"`
    };
    
    const url = await s3.getSignedUrlPromise('getObject', params);
    
    res.json({ url });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});
```

---

## Frontend Download

### Trigger Download in React

```javascript
// components/FileDownload.jsx
import axios from 'axios';

const FileDownload = ({ fileId, filename }) => {
  const handleDownload = async () => {
    try {
      const response = await axios.get(`/api/download/${fileId}`, {
        responseType: 'blob' // Important for binary data
      });
      
      // Create blob URL
      const url = window.URL.createObjectURL(new Blob([response.data]));
      
      // Create temporary link and click it
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      
      // Clean up
      link.parentNode.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      alert('Download failed');
    }
  };
  
  return (
    <button onClick={handleDownload}>Download</button>
  );
};

export default FileDownload;
```

### Download with Progress

```javascript
import { useState } from 'react';
import axios from 'axios';

const DownloadWithProgress = ({ fileId, filename }) => {
  const [downloading, setDownloading] = useState(false);
  const [progress, setProgress] = useState(0);
  
  const handleDownload = async () => {
    setDownloading(true);
    setProgress(0);
    
    try {
      const response = await axios.get(`/api/download/${fileId}`, {
        responseType: 'blob',
        onDownloadProgress: (progressEvent) => {
          const percentCompleted = Math.round(
            (progressEvent.loaded * 100) / progressEvent.total
          );
          setProgress(percentCompleted);
        }
      });
      
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', filename);
      document.body.appendChild(link);
      link.click();
      link.parentNode.removeChild(link);
      window.URL.revokeObjectURL(url);
    } catch (error) {
      alert('Download failed');
    } finally {
      setDownloading(false);
    }
  };
  
  return (
    <div>
      <button onClick={handleDownload} disabled={downloading}>
        {downloading ? `Downloading... ${progress}%` : 'Download'}
      </button>
      
      {downloading && (
        <div style={{
          width: '100%',
          height: '10px',
          backgroundColor: '#e0e0e0',
          borderRadius: '5px',
          marginTop: '10px'
        }}>
          <div style={{
            width: `${progress}%`,
            height: '100%',
            backgroundColor: '#4CAF50',
            borderRadius: '5px',
            transition: 'width 0.3s'
          }} />
        </div>
      )}
    </div>
  );
};

export default DownloadWithProgress;
```

---

## Interview Questions

**Q1: What's the difference between res.send() and res.download()?**
- `res.send()`: Sends response (displays in browser)
- `res.download()`: Sets Content-Disposition header to force download

**Q2: How do you stream large files?**
```javascript
const fileStream = fs.createReadStream(filePath);
fileStream.pipe(res);
```

**Q3: What is Range header used for?**
- Enables partial content requests (video/audio seeking)
- Returns 206 Partial Content status
- Format: `Range: bytes=start-end`

**Q4: How do you implement video streaming?**
- Parse Range header
- Create read stream with start/end positions
- Set Content-Range and 206 status code
- Support seeking by handling range requests

**Q5: How do you download files in React?**
```javascript
const response = await axios.get(url, { responseType: 'blob' });
const url = window.URL.createObjectURL(new Blob([response.data]));
const link = document.createElement('a');
link.href = url;
link.download = filename;
link.click();
```

---

## Best Practices

1. **Use streaming** for large files (>10MB)
2. **Implement range support** for video/audio
3. **Validate permissions** before serving files
4. **Use temporary links** for secure downloads
5. **Set appropriate headers** (Content-Type, Content-Disposition)
6. **Handle errors** gracefully
7. **Track download analytics** (count, user, timestamp)
8. **Implement rate limiting** to prevent abuse
9. **Use CDN** for frequently downloaded files
10. **Clean up blob URLs** to prevent memory leaks

---

## Summary

- **Download**: `res.download(path, filename)`
- **Streaming**: `fs.createReadStream(path).pipe(res)`
- **Range requests**: Support partial content for video/audio
- **Protected downloads**: Verify authentication and authorization
- **Temporary links**: Use JWT tokens with expiration
- **Cloud download**: Redirect to cloud URL or stream from cloud
- **Frontend**: Use axios with `responseType: 'blob'`
- **Progress**: Track with `onDownloadProgress` callback
