# 04. File Storage (Local & Naming)

## Introduction

Proper file storage and naming strategies are essential for organization, security, and scalability. This guide covers local storage best practices and file naming conventions.

---

## Storage Strategies

### 1. **Flat Storage (Single Directory)**

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// All files in: uploads/
// uploads/1234567890-image.jpg
// uploads/1234567891-document.pdf
```

**Pros**: Simple
**Cons**: Doesn't scale, hard to manage thousands of files

### 2. **Category-Based Storage**

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    let uploadPath = 'uploads/';
    
    if (file.mimetype.startsWith('image/')) {
      uploadPath += 'images/';
    } else if (file.mimetype.startsWith('video/')) {
      uploadPath += 'videos/';
    } else if (file.mimetype === 'application/pdf') {
      uploadPath += 'documents/';
    } else {
      uploadPath += 'others/';
    }
    
    // Create directory if it doesn't exist
    const fs = require('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// uploads/images/1234567890-photo.jpg
// uploads/videos/1234567891-clip.mp4
// uploads/documents/1234567892-report.pdf
```

### 3. **Date-Based Storage**

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    
    const uploadPath = `uploads/${year}/${month}/${day}/`;
    
    const fs = require('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// uploads/2026/01/02/1234567890-image.jpg
```

### 4. **User-Based Storage**

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const userId = req.user.id; // Assuming authenticated user
    const uploadPath = `uploads/users/${userId}/`;
    
    const fs = require('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// uploads/users/507f1f77bcf86cd799439011/1234567890-avatar.jpg
```

### 5. **Hybrid Approach (User + Category + Date)**

```javascript
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const userId = req.user.id;
    const category = file.mimetype.split('/')[0]; // 'image', 'video', etc.
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    
    const uploadPath = `uploads/${userId}/${category}/${year}/${month}/`;
    
    const fs = require('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

// uploads/507f1f77bcf86cd799439011/image/2026/01/1234567890-photo.jpg
```

---

## File Naming Strategies

### 1. **Timestamp + Original Name**

```javascript
filename: (req, file, cb) => {
  cb(null, Date.now() + '-' + file.originalname);
}

// 1735833600000-vacation.jpg
```

**Pros**: Keeps original name, unique
**Cons**: Long filenames, original name may contain unsafe characters

### 2. **UUID (Universally Unique Identifier)**

```bash
npm install uuid
```

```javascript
const { v4: uuidv4 } = require('uuid');
const path = require('path');

filename: (req, file, cb) => {
  const uniqueName = uuidv4() + path.extname(file.originalname);
  cb(null, uniqueName);
}

// 3f4d5e6a-7b8c-9d0e-1f2a-3b4c5d6e7f8a.jpg
```

**Pros**: Guaranteed unique, short
**Cons**: Loses original filename

### 3. **UUID + Original Name**

```javascript
const { v4: uuidv4 } = require('uuid');
const path = require('path');

filename: (req, file, cb) => {
  const ext = path.extname(file.originalname);
  const basename = path.basename(file.originalname, ext);
  const sanitizedName = basename.replace(/[^a-zA-Z0-9]/g, '-');
  const uniqueName = `${uuidv4()}-${sanitizedName}${ext}`;
  cb(null, uniqueName);
}

// 3f4d5e6a-7b8c-9d0e-1f2a-3b4c5d6e7f8a-vacation.jpg
```

### 4. **Hashed Filename**

```javascript
const crypto = require('crypto');
const path = require('path');

filename: (req, file, cb) => {
  const hash = crypto.randomBytes(16).toString('hex');
  const ext = path.extname(file.originalname);
  cb(null, hash + ext);
}

// 5f4dcc3b5aa765d61d8327deb882cf99.jpg
```

### 5. **Timestamp + Random + Extension**

```javascript
const path = require('path');

filename: (req, file, cb) => {
  const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
  const ext = path.extname(file.originalname);
  cb(null, file.fieldname + '-' + uniqueSuffix + ext);
}

// avatar-1735833600000-123456789.jpg
```

### 6. **User ID + Timestamp**

```javascript
filename: (req, file, cb) => {
  const userId = req.user.id;
  const timestamp = Date.now();
  const ext = path.extname(file.originalname);
  cb(null, `${userId}-${timestamp}${ext}`);
}

// 507f1f77bcf86cd799439011-1735833600000.jpg
```

---

## Filename Sanitization

### Remove Unsafe Characters

```javascript
const sanitizeFilename = (filename) => {
  // Remove path separators and special characters
  return filename
    .replace(/[/\\]/g, '')           // Remove slashes
    .replace(/[^a-zA-Z0-9.-]/g, '_') // Replace special chars with underscore
    .replace(/\s+/g, '_')            // Replace spaces with underscore
    .toLowerCase();                   // Convert to lowercase
};

filename: (req, file, cb) => {
  const sanitized = sanitizeFilename(file.originalname);
  const uniqueName = Date.now() + '-' + sanitized;
  cb(null, uniqueName);
}

// Before: ../../../etc/My File!@#.jpg
// After:  1735833600000-my_file___.jpg
```

### Prevent Path Traversal

```javascript
const path = require('path');

const sanitizeFilename = (filename) => {
  // Get only the basename (no directory path)
  const basename = path.basename(filename);
  
  // Remove dangerous characters
  return basename.replace(/[^a-zA-Z0-9.-]/g, '_');
};
```

---

## Complete Storage Configuration

```javascript
// config/storage.js
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

const sanitizeFilename = (filename) => {
  const basename = path.basename(filename);
  return basename
    .replace(/[^a-zA-Z0-9.-]/g, '_')
    .toLowerCase();
};

const createStorage = (baseDir = 'uploads') => {
  return multer.diskStorage({
    destination: (req, file, cb) => {
      // Category-based path
      const category = file.mimetype.split('/')[0];
      
      // Date-based path
      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      
      // Combine paths
      const uploadPath = path.join(baseDir, category, year.toString(), month);
      
      // Create directory
      if (!fs.existsSync(uploadPath)) {
        fs.mkdirSync(uploadPath, { recursive: true });
      }
      
      cb(null, uploadPath);
    },
    
    filename: (req, file, cb) => {
      // UUID + sanitized original name
      const ext = path.extname(file.originalname);
      const basename = path.basename(file.originalname, ext);
      const sanitized = sanitizeFilename(basename);
      const uniqueName = `${uuidv4()}-${sanitized}${ext}`;
      
      cb(null, uniqueName);
    }
  });
};

module.exports = { createStorage, sanitizeFilename };
```

---

## File Metadata Storage

### Database Model

```javascript
// models/File.js
const mongoose = require('mongoose');

const fileSchema = new mongoose.Schema({
  filename: {
    type: String,
    required: true,
    unique: true
  },
  originalName: {
    type: String,
    required: true
  },
  mimetype: String,
  size: Number,
  path: String,
  url: String,
  category: {
    type: String,
    enum: ['image', 'video', 'document', 'audio', 'other']
  },
  uploadedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  uploadedAt: {
    type: Date,
    default: Date.now
  },
  isDeleted: {
    type: Boolean,
    default: false
  },
  deletedAt: Date
});

fileSchema.methods.getPublicUrl = function() {
  return `/uploads/${this.path}`;
};

module.exports = mongoose.model('File', fileSchema);
```

### Save Metadata After Upload

```javascript
// routes/upload.js
const File = require('../models/File');

router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    
    const fileData = await File.create({
      filename: req.file.filename,
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path,
      url: `/uploads/${req.file.path}`,
      category: req.file.mimetype.split('/')[0],
      uploadedBy: req.user.id
    });
    
    res.status(201).json({
      message: 'File uploaded successfully',
      file: fileData
    });
  } catch (error) {
    // Delete file if database save fails
    if (req.file) {
      fs.unlinkSync(req.file.path);
    }
    res.status(500).json({ message: error.message });
  }
});
```

---

## Disk Space Management

### Check Disk Space Before Upload

```javascript
const diskspace = require('diskspace');

const checkDiskSpace = (requiredSpace) => {
  return new Promise((resolve, reject) => {
    diskspace.check('/', (err, result) => {
      if (err) return reject(err);
      
      const availableSpace = result.free;
      if (availableSpace > requiredSpace) {
        resolve(true);
      } else {
        reject(new Error('Insufficient disk space'));
      }
    });
  });
};

router.post('/upload', async (req, res, next) => {
  try {
    await checkDiskSpace(100 * 1024 * 1024); // Require 100MB free
    next();
  } catch (error) {
    res.status(507).json({ message: 'Insufficient storage' });
  }
}, upload.single('file'), (req, res) => {
  res.json({ message: 'File uploaded' });
});
```

---

## Interview Questions

**Q1: What are common file storage strategies?**
- Flat storage (single directory)
- Category-based (images/, videos/)
- Date-based (2026/01/02/)
- User-based (users/userId/)
- Hybrid approach

**Q2: How do you generate unique filenames?**
- UUID: `uuidv4() + ext`
- Timestamp: `Date.now() + '-' + originalname`
- Hash: `crypto.randomBytes(16).toString('hex') + ext`
- Combination: `uuid + '-' + sanitized-name + ext`

**Q3: How do you sanitize filenames?**
```javascript
const sanitize = (name) => {
  return path.basename(name)
    .replace(/[^a-zA-Z0-9.-]/g, '_')
    .toLowerCase();
};
```

**Q4: How do you prevent path traversal attacks?**
- Use `path.basename()` to extract filename only
- Remove path separators (`/`, `\`)
- Validate filename doesn't contain `..`

**Q5: Should you keep original filenames?**
**No** - Security risk (path traversal, XSS)
**Yes** - Better UX (store in database, use UUID for disk)
**Best**: Store original name in database, use UUID on disk

---

## Best Practices

1. **Use unique filenames** to avoid conflicts
2. **Sanitize filenames** to prevent security issues
3. **Organize by category/date** for scalability
4. **Store metadata in database** (original name, size, user)
5. **Create directories dynamically** as needed
6. **Use UUID** for guaranteed uniqueness
7. **Prevent path traversal** with path.basename()
8. **Check disk space** before accepting uploads
9. **Clean up failed uploads** immediately
10. **Use environment variables** for base upload path

---

## Summary

- **Storage strategies**: Flat, category-based, date-based, user-based, hybrid
- **Filename generation**: UUID, timestamp, hash, combination
- **Sanitization**: Remove special characters, prevent path traversal
- **Metadata**: Store original name, size, mimetype in database
- **Organization**: Use subdirectories for scalability
- **Security**: Use `path.basename()`, sanitize filenames
- **Disk management**: Check available space before upload
