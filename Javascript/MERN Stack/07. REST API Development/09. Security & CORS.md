# Security & CORS

## Why API Security?

**Threats**:
- Unauthorized access
- Data breaches
- SQL injection
- XSS attacks
- DDoS attacks

> **Security is not optional!**

---

## CORS (Cross-Origin Resource Sharing)

### What is CORS?

**CORS** allows resources to be requested from a different origin (domain, protocol, or port).

**Example**:
```
Frontend: http://localhost:3000
Backend:  http://localhost:5000

Different ports = Different origins = CORS needed
```

### CORS Error

```
Access to fetch at 'http://localhost:5000/api/users'
from origin 'http://localhost:3000' has been blocked by CORS policy
```

---

## Enabling CORS

### Installation

```bash
npm install cors
```

### Basic Usage (Allow All)

```js
const cors = require('cors');

// Allow all origins (Development only!)
app.use(cors());
```

### Specific Origin

```js
const corsOptions = {
  origin: 'http://localhost:3000'
};

app.use(cors(corsOptions));
```

### Multiple Origins

```js
const allowedOrigins = [
  'http://localhost:3000',
  'https://myapp.com',
  'https://www.myapp.com'
];

const corsOptions = {
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true // Allow cookies
};

app.use(cors(corsOptions));
```

### Environment-Based CORS

```js
const corsOptions = {
  origin: process.env.NODE_ENV === 'production'
    ? 'https://myapp.com'
    : 'http://localhost:3000',
  credentials: true
};

app.use(cors(corsOptions));
```

### Route-Specific CORS

```js
// Public route - allow all
app.get('/api/public', cors(), (req, res) => {
  res.json({ message: 'Public data' });
});

// Private route - specific origin
const corsOptions = { origin: 'https://myapp.com' };
app.get('/api/private', cors(corsOptions), (req, res) => {
  res.json({ message: 'Private data' });
});
```

### Manual CORS Headers

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  
  next();
});
```

---

## Helmet (Security Headers)

### Installation

```bash
npm install helmet
```

### Basic Usage

```js
const helmet = require('helmet');

app.use(helmet());
```

**Helmet sets secure HTTP headers**:
- `X-Content-Type-Options: nosniff`
- `X-Frame-Options: DENY`
- `X-XSS-Protection: 1; mode=block`
- `Strict-Transport-Security`
- And more...

### Custom Configuration

```js
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"]
      }
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true
    }
  })
);
```

---

## Authentication & Authorization

### JWT (JSON Web Tokens)

#### Installation

```bash
npm install jsonwebtoken bcryptjs
```

#### Generating JWT

```js
const jwt = require('jsonwebtoken');

const generateToken = (user) => {
  return jwt.sign(
    { id: user._id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
};

// Login
exports.login = async (req, res) => {
  const { email, password } = req.body;
  
  const user = await User.findOne({ email });
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const token = generateToken(user);
  
  res.json({
    success: true,
    token,
    user: {
      id: user._id,
      name: user.name,
      email: user.email
    }
  });
};
```

#### Auth Middleware

```js
// middlewares/auth.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const auth = async (req, res, next) => {
  try {
    // Get token from header
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    
    // Find user
    const user = await User.findById(decoded.id).select('-password');
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }
    
    // Attach user to request
    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

module.exports = auth;
```

#### Usage

```js
const auth = require('../middlewares/auth');

// Protected route
router.get('/profile', auth, (req, res) => {
  res.json({ user: req.user });
});
```

### Role-Based Authorization

```js
// middlewares/authorize.js
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        error: 'You do not have permission to perform this action'
      });
    }
    next();
  };
};

module.exports = authorize;
```

#### Usage

```js
const auth = require('../middlewares/auth');
const authorize = require('../middlewares/authorize');

// Admin only
router.delete('/users/:id',
  auth,
  authorize('admin'),
  deleteUser
);

// Admin or moderator
router.put('/posts/:id',
  auth,
  authorize('admin', 'moderator'),
  updatePost
);
```

---

## Input Validation & Sanitization

### express-validator

```js
const { body, validationResult } = require('express-validator');

router.post('/users',
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 8 }),
    body('name').trim().escape()
  ],
  (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    // Process request
  }
);
```

---

## SQL Injection Prevention

### Use Parameterized Queries

```js
// ❌ Bad: SQL Injection vulnerable
const query = `SELECT * FROM users WHERE email = '${email}'`;

// ✅ Good: Parameterized query
const query = 'SELECT * FROM users WHERE email = ?';
db.query(query, [email]);
```

### With MongoDB (NoSQL Injection)

```js
// ❌ Bad: NoSQL Injection vulnerable
User.findOne({ email: req.body.email });

// ✅ Good: Validate and sanitize
const { body } = require('express-validator');

router.post('/login',
  body('email').isEmail().normalizeEmail(),
  async (req, res) => {
    const user = await User.findOne({ email: req.body.email });
  }
);
```

---

## XSS Prevention

### Escape User Input

```js
const { body } = require('express-validator');

// Escape HTML
body('comment').trim().escape();
```

### Content Security Policy (CSP)

```js
const helmet = require('helmet');

app.use(
  helmet.contentSecurityPolicy({
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"]
    }
  })
);
```

---

## Rate Limiting

```js
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // Max 100 requests per windowMs
});

app.use('/api/', limiter);

// Stricter for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5
});

app.post('/api/auth/login', authLimiter, login);
```

---

## HTTPS/SSL

### Redirect HTTP to HTTPS

```js
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https' && process.env.NODE_ENV === 'production') {
    res.redirect(`https://${req.header('host')}${req.url}`);
  } else {
    next();
  }
});
```

### Strict Transport Security

```js
app.use(helmet.hsts({
  maxAge: 31536000,
  includeSubDomains: true,
  preload: true
}));
```

---

## Environment Variables

### .env

```
JWT_SECRET=your_super_secret_key_here
DB_URI=mongodb://localhost:27017/mydb
NODE_ENV=production
```

### Never Commit Secrets

```gitignore
# .gitignore
.env
.env.local
.env.production
```

---

## Data Encryption

### Password Hashing

```js
const bcrypt = require('bcryptjs');

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Compare passwords
userSchema.methods.comparePassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};
```

---

## Security Checklist

### ✅ Must-Have

- [ ] Use HTTPS in production
- [ ] Implement authentication (JWT)
- [ ] Hash passwords (bcrypt)
- [ ] Enable CORS properly
- [ ] Use Helmet for security headers
- [ ] Validate and sanitize all inputs
- [ ] Implement rate limiting
- [ ] Use environment variables for secrets
- [ ] Keep dependencies updated
- [ ] Implement proper error handling

### ✅ Recommended

- [ ] Role-based authorization
- [ ] Request logging (morgan)
- [ ] SQL/NoSQL injection prevention
- [ ] XSS protection
- [ ] CSRF protection (for cookies)
- [ ] File upload restrictions
- [ ] API versioning
- [ ] Regular security audits

---

## Complete Security Example

```js
const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
require('dotenv').config();

const app = express();

// Security middleware
app.use(helmet());

app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || 'http://localhost:3000',
  credentials: true
}));

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
});
app.use('/api/', limiter);

// Logging
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Routes
app.use('/api/auth', require('./routes/auth'));
app.use('/api/users', require('./routes/users'));

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    success: false,
    error: process.env.NODE_ENV === 'production'
      ? 'Internal server error'
      : err.message
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

---

## Interview Questions

### Q1: What is CORS?
**Answer**: Cross-Origin Resource Sharing allows resources from different origins (domain/port/protocol) to be requested.

### Q2: Why use Helmet?
**Answer**: Helmet sets secure HTTP headers to protect against common web vulnerabilities.

### Q3: How do you prevent SQL injection?
**Answer**: Use parameterized queries/prepared statements, never concatenate user input into queries.

### Q4: What's the difference between authentication and authorization?
**Answer**:
- **Authentication**: Who you are (login)
- **Authorization**: What you can do (permissions)

### Q5: How do you store passwords securely?
**Answer**: Hash with bcrypt (not encrypt!). Never store plain text passwords.

### Q6: What is JWT?
**Answer**: JSON Web Token - a stateless authentication token containing encoded user data.

---

## Summary

- **CORS**: Enable for cross-origin requests
- **Helmet**: Security headers middleware
- **JWT**: Stateless authentication
- **Authorization**: Role-based access control
- **Validation**: Sanitize all user input
- **Rate Limiting**: Prevent abuse
- **HTTPS**: Encrypt data in transit
- **Hashing**: Use bcrypt for passwords
- **Environment Variables**: Never commit secrets
- **Security**: Defense in depth - multiple layers
