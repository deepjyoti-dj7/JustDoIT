# API Design & RESTful Routes

## What is API Design?

**API Design** is the process of creating interfaces that are:
- Intuitive and easy to use
- Consistent and predictable
- Well-documented
- Scalable and maintainable

> **Good API design = Happy developers**

---

## RESTful Route Patterns

### Basic CRUD Operations

```
Resource: Users

GET    /api/users          - Get all users
GET    /api/users/:id      - Get single user
POST   /api/users          - Create user
PUT    /api/users/:id      - Update user (full)
PATCH  /api/users/:id      - Update user (partial)
DELETE /api/users/:id      - Delete user
```

### Nested Resources

```
User's Posts:
GET    /api/users/:userId/posts           - Get user's posts
POST   /api/users/:userId/posts           - Create post for user
GET    /api/users/:userId/posts/:postId   - Get specific post
DELETE /api/users/:userId/posts/:postId   - Delete user's post

Post's Comments:
GET    /api/posts/:postId/comments         - Get post's comments
POST   /api/posts/:postId/comments         - Create comment
```

**Rule**: Don't nest more than 2 levels deep.

```
❌ Bad: /api/users/:id/posts/:id/comments/:id/replies
✅ Good: /api/comments/:id/replies
```

---

## URL Design Principles

### 1. Use Nouns, Not Verbs

```
❌ Bad:
/getUsers
/createUser
/deleteUser
/updateUser

✅ Good:
GET    /users
POST   /users
DELETE /users/:id
PUT    /users/:id
```

### 2. Use Plural Nouns

```
❌ Bad: /user/123
✅ Good: /users/123

❌ Bad: /product/456
✅ Good: /products/456
```

### 3. Use Lowercase and Hyphens

```
❌ Bad:
/userProfiles
/user_profiles
/UserProfiles

✅ Good:
/user-profiles
```

### 4. Keep URLs Short and Meaningful

```
❌ Bad: /api/v1/application/users/get-all-active-users-list
✅ Good: /api/v1/users?status=active
```

---

## Query Parameters vs Path Parameters

### Path Parameters (Required)

Identify a specific resource.

```js
GET /api/users/:id          // Required: user ID
GET /api/posts/:postId      // Required: post ID
```

### Query Parameters (Optional)

Filter, sort, paginate, or modify the response.

```js
GET /api/users?role=admin&status=active
GET /api/products?category=electronics&sort=price&order=desc
GET /api/posts?page=2&limit=10
```

### Examples

```js
// Path parameter: Identify resource
GET /api/users/123

// Query parameters: Filter results
GET /api/users?role=admin
GET /api/users?created_after=2024-01-01

// Combination
GET /api/users/123/posts?status=published&limit=5
```

---

## Filtering, Sorting, and Searching

### Filtering

```
GET /api/products?category=electronics
GET /api/users?role=admin&status=active
GET /api/posts?author=john&published=true
```

```js
// Implementation
app.get('/api/products', (req, res) => {
  const { category, minPrice, maxPrice } = req.query;
  
  let query = {};
  if (category) query.category = category;
  if (minPrice) query.price = { $gte: minPrice };
  if (maxPrice) query.price = { ...query.price, $lte: maxPrice };
  
  const products = await Product.find(query);
  res.json(products);
});
```

### Sorting

```
GET /api/products?sort=price           // Ascending
GET /api/products?sort=-price          // Descending
GET /api/users?sort=name,-createdAt    // Multiple fields
```

```js
// Implementation
app.get('/api/products', async (req, res) => {
  const { sort } = req.query;
  
  let sortObj = {};
  if (sort) {
    const fields = sort.split(',');
    fields.forEach(field => {
      if (field.startsWith('-')) {
        sortObj[field.substring(1)] = -1; // Descending
      } else {
        sortObj[field] = 1; // Ascending
      }
    });
  }
  
  const products = await Product.find().sort(sortObj);
  res.json(products);
});
```

### Searching

```
GET /api/products?search=laptop
GET /api/users?q=john
```

```js
// Implementation
app.get('/api/products', async (req, res) => {
  const { search } = req.query;
  
  const query = search
    ? { $text: { $search: search } }
    : {};
  
  const products = await Product.find(query);
  res.json(products);
});
```

---

## Pagination

### Page-Based Pagination

```
GET /api/posts?page=2&limit=10
```

```js
app.get('/api/posts', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;
  
  const posts = await Post.find()
    .skip(skip)
    .limit(limit);
  
  const total = await Post.countDocuments();
  
  res.json({
    data: posts,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  });
});
```

### Cursor-Based Pagination

```
GET /api/posts?cursor=abc123&limit=10
```

```js
app.get('/api/posts', async (req, res) => {
  const { cursor, limit = 10 } = req.query;
  
  const query = cursor
    ? { _id: { $gt: cursor } }
    : {};
  
  const posts = await Post.find(query)
    .limit(parseInt(limit));
  
  const nextCursor = posts.length > 0
    ? posts[posts.length - 1]._id
    : null;
  
  res.json({
    data: posts,
    nextCursor
  });
});
```

---

## Field Selection (Sparse Fieldsets)

Return only requested fields.

```
GET /api/users?fields=name,email
GET /api/products?fields=name,price,image
```

```js
app.get('/api/users', async (req, res) => {
  const { fields } = req.query;
  
  const select = fields
    ? fields.split(',').join(' ')
    : '';
  
  const users = await User.find().select(select);
  res.json(users);
});

// Response
[
  { "name": "John", "email": "john@example.com" },
  { "name": "Jane", "email": "jane@example.com" }
]
```

---

## API Versioning

### 1. URL Versioning (Recommended)

```
/api/v1/users
/api/v2/users
```

```js
// v1
app.get('/api/v1/users', (req, res) => {
  // Old logic
});

// v2
app.get('/api/v2/users', (req, res) => {
  // New logic
});
```

### 2. Header Versioning

```
GET /api/users
Accept-Version: v1
```

```js
app.get('/api/users', (req, res) => {
  const version = req.headers['accept-version'];
  
  if (version === 'v2') {
    // New logic
  } else {
    // Old logic
  }
});
```

### 3. Query Parameter Versioning

```
GET /api/users?version=1
```

---

## Response Format

### Success Response

```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "message": "User retrieved successfully"
}
```

### List Response with Pagination

```json
{
  "success": true,
  "data": [
    { "id": 1, "name": "John" },
    { "id": 2, "name": "Jane" }
  ],
  "pagination": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "pages": 10
  }
}
```

### Error Response

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": [
      {
        "field": "email",
        "message": "Must be a valid email"
      }
    ]
  }
}
```

---

## API Design Best Practices

### 1. Be Consistent

```
✅ Good: Use same patterns everywhere
/api/users
/api/products
/api/orders

❌ Bad: Inconsistent patterns
/getUsers
/api/products
/order-list
```

### 2. Use Proper HTTP Methods

```
✅ Good:
GET    /users     - Read
POST   /users     - Create
PUT    /users/:id - Update
DELETE /users/:id - Delete

❌ Bad:
GET /users/delete/:id  // Should be DELETE
POST /users/update/:id // Should be PUT/PATCH
```

### 3. Return Appropriate Status Codes

```js
// 200 OK - Successful GET/PUT/PATCH
res.status(200).json({ user });

// 201 Created - Successful POST
res.status(201).json({ user });

// 204 No Content - Successful DELETE
res.status(204).send();

// 400 Bad Request - Invalid data
res.status(400).json({ error: 'Invalid email' });

// 404 Not Found - Resource doesn't exist
res.status(404).json({ error: 'User not found' });
```

### 4. Use Standard Response Format

```js
// Success
{
  "success": true,
  "data": { ... }
}

// Error
{
  "success": false,
  "error": {
    "message": "...",
    "code": "..."
  }
}
```

### 5. Document Your API

Use Swagger/OpenAPI for documentation.

```yaml
/users:
  get:
    summary: Get all users
    parameters:
      - name: page
        in: query
        type: integer
    responses:
      200:
        description: Successful response
```

---

## Common API Patterns

### Bulk Operations

```
POST /api/users/bulk
[
  { "name": "John" },
  { "name": "Jane" }
]

DELETE /api/users/bulk
{
  "ids": [1, 2, 3]
}
```

### Actions on Resources

```
POST /api/users/:id/activate
POST /api/users/:id/deactivate
POST /api/orders/:id/cancel
POST /api/posts/:id/publish
```

### Relationships

```
GET  /api/users/:id/followers
POST /api/users/:id/follow
DELETE /api/users/:id/unfollow
```

---

## Interview Questions

### Q1: What's the difference between PUT and PATCH?
**Answer**: PUT replaces the entire resource, PATCH updates only specified fields.

### Q2: Should you use /user or /users?
**Answer**: Use plural `/users` for consistency, even for single resources (`/users/:id`).

### Q3: How do you handle API versioning?
**Answer**: Best practice is URL versioning (`/api/v1/users`, `/api/v2/users`).

### Q4: What's the difference between query and path parameters?
**Answer**:
- **Path**: Identify specific resource (required)
- **Query**: Filter, sort, paginate (optional)

### Q5: How do you design pagination?
**Answer**: Use query parameters: `?page=2&limit=10`. Return data with pagination metadata (total, pages, etc.).

### Q6: Should nested routes be deep?
**Answer**: No, limit to 2 levels. Instead of `/users/:id/posts/:id/comments/:id`, use `/comments/:id`.

---

## Summary

- **RESTful Routes**: Use HTTP methods + resource URLs
- **URL Design**: Lowercase, hyphens, plural nouns, no verbs
- **Query Parameters**: For filtering, sorting, pagination
- **Path Parameters**: For identifying specific resources
- **Versioning**: Use URL versioning (`/api/v1/`)
- **Response Format**: Consistent structure (success, data, error)
- **Best Practices**: Be consistent, use proper HTTP methods, return appropriate status codes
- **Pagination**: Page-based or cursor-based
- **Keep it simple**: Don't over-nest resources
