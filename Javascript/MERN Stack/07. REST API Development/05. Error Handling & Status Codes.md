# Error Handling & Status Codes

## Why Error Handling?

**Proper error handling**:
- Improves debugging
- Better user experience
- Prevents app crashes
- Security (don't leak sensitive info)

> **Fail gracefully, not catastrophically.**

---

## Types of Errors

### 1. Operational Errors

Expected errors during normal operation:
- Invalid user input
- Resource not found
- Network failures
- Database connection issues

**Handling**: Return appropriate error response to client.

### 2. Programming Errors

Bugs in the code:
- Syntax errors
- Undefined variables
- Type errors
- Logic errors

**Handling**: Fix the code, log error, crash gracefully.

---

## Basic Error Handling

### Try-Catch

```js
app.get('/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.json({ success: true, data: user });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
```

---

## Global Error Handler

### Creating Error Handler Middleware

```js
// middlewares/errorHandler.js
const errorHandler = (err, req, res, next) => {
  console.error(err.stack);
  
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  
  res.status(statusCode).json({
    success: false,
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && {
        stack: err.stack
      })
    }
  });
};

module.exports = errorHandler;
```

### Using in Express

```js
const errorHandler = require('./middlewares/errorHandler');

// Routes
app.use('/api/users', usersRouter);
app.use('/api/products', productsRouter);

// Error handler MUST be last
app.use(errorHandler);
```

---

## Custom Error Class

### AppError Class

```js
// utils/AppError.js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;
    
    Error.captureStackTrace(this, this.constructor);
  }
}

module.exports = AppError;
```

### Usage

```js
const AppError = require('../utils/AppError');

app.get('/users/:id', async (req, res, next) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (!user) {
      return next(new AppError('User not found', 404));
    }
    
    res.json({ success: true, data: user });
  } catch (error) {
    next(error);
  }
});
```

### Enhanced Error Handler

```js
// middlewares/errorHandler.js
const errorHandler = (err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || 'error';
  
  if (process.env.NODE_ENV === 'development') {
    // Development: Send full error details
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        statusCode: err.statusCode,
        stack: err.stack
      }
    });
  } else {
    // Production: Send minimal error info
    if (err.isOperational) {
      // Operational, trusted error: send message to client
      res.status(err.statusCode).json({
        success: false,
        error: {
          message: err.message
        }
      });
    } else {
      // Programming or unknown error: don't leak details
      console.error('ERROR:', err);
      res.status(500).json({
        success: false,
        error: {
          message: 'Something went wrong'
        }
      });
    }
  }
};

module.exports = errorHandler;
```

---

## Async Error Handling

### AsyncHandler Wrapper

```js
// utils/asyncHandler.js
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

module.exports = asyncHandler;
```

### Usage

```js
const asyncHandler = require('../utils/asyncHandler');
const AppError = require('../utils/AppError');

exports.getUser = asyncHandler(async (req, res, next) => {
  const user = await User.findById(req.params.id);
  
  if (!user) {
    return next(new AppError('User not found', 404));
  }
  
  res.json({ success: true, data: user });
});
```

**No try-catch needed!** Errors automatically caught and passed to error handler.

---

## HTTP Status Codes

### 2xx Success

| Code | Name | When to Use | Example |
|------|------|-------------|----------|
| 200 | OK | Successful GET, PUT, PATCH | `res.status(200).json({ user })` |
| 201 | Created | Successful POST | `res.status(201).json({ user })` |
| 204 | No Content | Successful DELETE | `res.status(204).send()` |

### 3xx Redirection

| Code | Name | When to Use |
|------|------|-------------|
| 301 | Moved Permanently | Resource permanently moved |
| 302 | Found | Temporary redirect |
| 304 | Not Modified | Cached version valid |

### 4xx Client Errors

| Code | Name | When to Use | Example |
|------|------|-------------|----------|
| 400 | Bad Request | Invalid request data | `res.status(400).json({ error: 'Invalid email' })` |
| 401 | Unauthorized | Not authenticated | `res.status(401).json({ error: 'Login required' })` |
| 403 | Forbidden | Authenticated but no permission | `res.status(403).json({ error: 'Admin only' })` |
| 404 | Not Found | Resource doesn't exist | `res.status(404).json({ error: 'User not found' })` |
| 409 | Conflict | Duplicate resource | `res.status(409).json({ error: 'Email exists' })` |
| 422 | Unprocessable Entity | Validation failed | `res.status(422).json({ errors: [...] })` |
| 429 | Too Many Requests | Rate limit exceeded | `res.status(429).json({ error: 'Too many requests' })` |

### 5xx Server Errors

| Code | Name | When to Use |
|------|------|-------------|
| 500 | Internal Server Error | Unexpected error |
| 502 | Bad Gateway | Invalid upstream response |
| 503 | Service Unavailable | Server down/maintenance |

---

## Specific Error Handlers

### Mongoose Errors

```js
// utils/errorHandlers.js

// Cast Error (Invalid ObjectId)
const handleCastError = (err) => {
  const message = `Invalid ${err.path}: ${err.value}`;
  return new AppError(message, 400);
};

// Duplicate Key Error
const handleDuplicateKeyError = (err) => {
  const field = Object.keys(err.keyValue)[0];
  const message = `${field} already exists`;
  return new AppError(message, 409);
};

// Validation Error
const handleValidationError = (err) => {
  const errors = Object.values(err.errors).map(e => e.message);
  const message = `Validation failed: ${errors.join(', ')}`;
  return new AppError(message, 422);
};

module.exports = {
  handleCastError,
  handleDuplicateKeyError,
  handleValidationError
};
```

### Enhanced Error Handler

```js
const AppError = require('../utils/AppError');
const {
  handleCastError,
  handleDuplicateKeyError,
  handleValidationError
} = require('../utils/errorHandlers');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;
  
  // Mongoose CastError
  if (err.name === 'CastError') {
    error = handleCastError(err);
  }
  
  // Mongoose Duplicate Key
  if (err.code === 11000) {
    error = handleDuplicateKeyError(err);
  }
  
  // Mongoose Validation Error
  if (err.name === 'ValidationError') {
    error = handleValidationError(err);
  }
  
  // JWT Errors
  if (err.name === 'JsonWebTokenError') {
    error = new AppError('Invalid token', 401);
  }
  
  if (err.name === 'TokenExpiredError') {
    error = new AppError('Token expired', 401);
  }
  
  res.status(error.statusCode || 500).json({
    success: false,
    error: {
      message: error.message || 'Internal Server Error'
    }
  });
};

module.exports = errorHandler;
```

---

## 404 Handler

### Not Found Middleware

```js
// middlewares/notFound.js
const AppError = require('../utils/AppError');

const notFound = (req, res, next) => {
  next(new AppError(`Route ${req.originalUrl} not found`, 404));
};

module.exports = notFound;
```

### Usage

```js
const notFound = require('./middlewares/notFound');
const errorHandler = require('./middlewares/errorHandler');

// Routes
app.use('/api/users', usersRouter);

// 404 handler (after all routes)
app.use(notFound);

// Error handler (must be last)
app.use(errorHandler);
```

---

## Structured Error Response

### Standard Format

```js
// Success
{
  "success": true,
  "data": { ... }
}

// Error
{
  "success": false,
  "error": {
    "message": "User not found",
    "code": "NOT_FOUND",
    "statusCode": 404,
    "timestamp": "2024-01-01T12:00:00Z"
  }
}
```

### Enhanced AppError

```js
class AppError extends Error {
  constructor(message, statusCode, code = null) {
    super(message);
    
    this.statusCode = statusCode;
    this.code = code || this.getErrorCode(statusCode);
    this.isOperational = true;
    this.timestamp = new Date().toISOString();
    
    Error.captureStackTrace(this, this.constructor);
  }
  
  getErrorCode(statusCode) {
    const codes = {
      400: 'BAD_REQUEST',
      401: 'UNAUTHORIZED',
      403: 'FORBIDDEN',
      404: 'NOT_FOUND',
      409: 'CONFLICT',
      422: 'VALIDATION_ERROR',
      500: 'INTERNAL_ERROR'
    };
    return codes[statusCode] || 'UNKNOWN_ERROR';
  }
}
```

---

## Validation Errors

```js
const { validationResult } = require('express-validator');

const validate = (req, res, next) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    return res.status(422).json({
      success: false,
      error: {
        message: 'Validation failed',
        code: 'VALIDATION_ERROR',
        details: errors.array().map(err => ({
          field: err.param,
          message: err.msg,
          value: err.value
        }))
      }
    });
  }
  
  next();
};
```

---

## Error Logging

### Using Winston

```bash
npm install winston
```

```js
// utils/logger.js
const winston = require('winston');

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

module.exports = logger;
```

### Usage in Error Handler

```js
const logger = require('../utils/logger');

const errorHandler = (err, req, res, next) => {
  // Log error
  logger.error({
    message: err.message,
    statusCode: err.statusCode,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip
  });
  
  // Send response
  res.status(err.statusCode || 500).json({
    success: false,
    error: { message: err.message }
  });
};
```

---

## Unhandled Rejections & Exceptions

```js
// server.js
const server = app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  console.error('UNHANDLED REJECTION! Shutting down...');
  console.error(err.name, err.message);
  
  server.close(() => {
    process.exit(1);
  });
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  console.error('UNCAUGHT EXCEPTION! Shutting down...');
  console.error(err.name, err.message);
  process.exit(1);
});
```

---

## Interview Questions

### Q1: What's the difference between operational and programming errors?
**Answer**: 
- **Operational**: Expected errors (404, validation)
- **Programming**: Bugs in code (syntax, logic errors)

### Q2: What status code for validation errors?
**Answer**: **422 Unprocessable Entity** (or 400 Bad Request).

### Q3: Difference between 401 and 403?
**Answer**:
- **401 Unauthorized**: Not authenticated (login required)
- **403 Forbidden**: Authenticated but lacks permission

### Q4: How do you handle async errors in Express?
**Answer**: Use async handler wrapper that catches errors and passes to `next()`.

### Q5: Should error messages reveal sensitive info?
**Answer**: No! In production, send generic messages. Log detailed errors server-side.

### Q6: What's the proper order of middleware?
**Answer**: Routes first, then 404 handler, then error handler (must be last).

---

## Summary

- **Error Types**: Operational (expected) vs Programming (bugs)
- **Global Error Handler**: Middleware with 4 params (err, req, res, next)
- **Custom Error Class**: AppError with statusCode, message
- **Async Handler**: Wrapper to catch async errors
- **Status Codes**: 4xx (client), 5xx (server)
- **Specific Handlers**: Mongoose, JWT, validation errors
- **Production**: Hide details, log errors
- **Development**: Show full stack trace
- **Always**: Fail gracefully, never crash
