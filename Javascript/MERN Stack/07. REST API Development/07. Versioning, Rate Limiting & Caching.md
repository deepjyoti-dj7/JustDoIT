# Versioning, Rate Limiting & Caching

## API Versioning

### Why Version APIs?

**Reasons**:
- Backward compatibility
- Breaking changes
- Multiple client versions
- Gradual migration

> **Never break existing clients!**

---

## Versioning Strategies

### 1. URL Versioning (Recommended)

Most common and clear approach.

```
/api/v1/users
/api/v2/users
```

```js
// v1
app.use('/api/v1/users', usersV1Router);

// v2
app.use('/api/v2/users', usersV2Router);
```

**Pros**: Clear, easy to route, RESTful
**Cons**: URL changes

### 2. Header Versioning

```
GET /api/users
Accept-Version: v1
```

```js
app.use('/api/users', (req, res, next) => {
  const version = req.headers['accept-version'] || 'v1';
  
  if (version === 'v2') {
    return usersV2Handler(req, res, next);
  }
  
  usersV1Handler(req, res, next);
});
```

**Pros**: Clean URLs
**Cons**: Less visible, harder to test

### 3. Query Parameter Versioning

```
GET /api/users?version=1
GET /api/users?v=2
```

```js
app.get('/api/users', (req, res) => {
  const version = req.query.version || '1';
  
  if (version === '2') {
    return getUsersV2(req, res);
  }
  
  getUsersV1(req, res);
});
```

**Pros**: Simple
**Cons**: Clutters query string

### 4. Content Negotiation

```
GET /api/users
Accept: application/vnd.myapi.v1+json
```

**Pros**: RESTful, follows HTTP standards
**Cons**: Complex, less intuitive

---

## Implementing URL Versioning

### Folder Structure

```
api/
├── v1/
│   ├── controllers/
│   ├── routes/
│   └── index.js
├── v2/
│   ├── controllers/
│   ├── routes/
│   └── index.js
└── index.js
```

### api/v1/routes/users.js

```js
const express = require('express');
const router = express.Router();
const { getUsers, getUser } = require('../controllers/userController');

router.get('/', getUsers);
router.get('/:id', getUser);

module.exports = router;
```

### api/v1/index.js

```js
const express = require('express');
const router = express.Router();
const usersRouter = require('./routes/users');

router.use('/users', usersRouter);

module.exports = router;
```

### server.js

```js
const v1Router = require('./api/v1');
const v2Router = require('./api/v2');

app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);
```

---

## Rate Limiting

### Why Rate Limiting?

**Prevents**:
- DDoS attacks
- Brute force attacks
- API abuse
- Server overload

**Benefits**:
- Fair usage
- Cost control
- Better performance

---

## express-rate-limit

### Installation

```bash
npm install express-rate-limit
```

### Basic Usage

```js
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Max 100 requests per windowMs
  message: 'Too many requests, please try again later',
  standardHeaders: true, // Return rate limit info in headers
  legacyHeaders: false
});

// Apply to all requests
app.use(limiter);
```

### Route-Specific Rate Limiting

```js
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Max 5 login attempts per 15 min
  message: 'Too many login attempts, please try again later'
});

app.post('/api/auth/login', loginLimiter, login);
```

### Custom Key Generator

```js
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  keyGenerator: (req) => {
    // Rate limit by user ID if authenticated, else by IP
    return req.user?.id || req.ip;
  }
});
```

### Custom Response

```js
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  handler: (req, res) => {
    res.status(429).json({
      success: false,
      error: {
        message: 'Too many requests',
        retryAfter: req.rateLimit.resetTime
      }
    });
  }
});
```

### Skip Conditions

```js
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  skip: (req) => {
    // Skip rate limiting for admins
    return req.user?.role === 'admin';
  }
});
```

---

## Rate Limiting with Redis

For distributed systems, use Redis to share rate limit state.

### Installation

```bash
npm install rate-limit-redis redis
```

### Implementation

```js
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');

const redisClient = redis.createClient({
  host: 'localhost',
  port: 6379
});

const limiter = rateLimit({
  store: new RedisStore({
    client: redisClient,
    prefix: 'rate-limit:'
  }),
  windowMs: 15 * 60 * 1000,
  max: 100
});

app.use(limiter);
```

---

## Tiered Rate Limiting

Different limits for different user types.

```js
const getRateLimiter = (req, res, next) => {
  const user = req.user;
  
  let max = 100; // Default
  
  if (user) {
    if (user.plan === 'premium') {
      max = 1000;
    } else if (user.plan === 'basic') {
      max = 500;
    }
  }
  
  const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max,
    keyGenerator: () => user?.id || req.ip
  });
  
  limiter(req, res, next);
};

app.use('/api', getRateLimiter);
```

---

## Response Headers

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1640000000
```

```js
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  standardHeaders: true, // Add X-RateLimit-* headers
  handler: (req, res) => {
    res.status(429).json({
      error: 'Too many requests',
      retryAfter: res.getHeader('X-RateLimit-Reset')
    });
  }
});
```

---

## Caching

### Why Caching?

**Benefits**:
- Faster response times
- Reduced database load
- Lower costs
- Better scalability

**Cache**: Frequently accessed, rarely changed data
**Don't cache**: User-specific, real-time data

---

## In-Memory Caching (Node-Cache)

### Installation

```bash
npm install node-cache
```

### Basic Usage

```js
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 }); // 10 minutes TTL

app.get('/api/products', async (req, res) => {
  const cacheKey = 'products';
  
  // Check cache
  const cached = cache.get(cacheKey);
  if (cached) {
    return res.json({
      success: true,
      data: cached,
      cached: true
    });
  }
  
  // Query database
  const products = await Product.find();
  
  // Store in cache
  cache.set(cacheKey, products);
  
  res.json({
    success: true,
    data: products,
    cached: false
  });
});
```

### Cache Middleware

```js
// middlewares/cache.js
const NodeCache = require('node-cache');
const cache = new NodeCache({ stdTTL: 600 });

const cacheMiddleware = (duration) => {
  return (req, res, next) => {
    if (req.method !== 'GET') {
      return next();
    }
    
    const key = req.originalUrl;
    const cached = cache.get(key);
    
    if (cached) {
      return res.json(cached);
    }
    
    // Override res.json to cache response
    const originalJson = res.json.bind(res);
    res.json = (data) => {
      cache.set(key, data, duration);
      originalJson(data);
    };
    
    next();
  };
};

module.exports = cacheMiddleware;
```

### Usage

```js
const cache = require('./middlewares/cache');

// Cache for 10 minutes
app.get('/api/products', cache(600), getProducts);

// Cache for 1 hour
app.get('/api/categories', cache(3600), getCategories);
```

---

## Redis Caching

### Installation

```bash
npm install redis
```

### Basic Usage

```js
const redis = require('redis');
const client = redis.createClient();

await client.connect();

app.get('/api/products', async (req, res) => {
  const cacheKey = 'products';
  
  // Check cache
  const cached = await client.get(cacheKey);
  if (cached) {
    return res.json({
      success: true,
      data: JSON.parse(cached),
      cached: true
    });
  }
  
  // Query database
  const products = await Product.find();
  
  // Cache for 10 minutes
  await client.setEx(cacheKey, 600, JSON.stringify(products));
  
  res.json({
    success: true,
    data: products,
    cached: false
  });
});
```

### Redis Cache Middleware

```js
// middlewares/redisCache.js
const redis = require('redis');
const client = redis.createClient();

await client.connect();

const redisCache = (duration) => {
  return async (req, res, next) => {
    if (req.method !== 'GET') {
      return next();
    }
    
    const key = req.originalUrl;
    const cached = await client.get(key);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }
    
    const originalJson = res.json.bind(res);
    res.json = async (data) => {
      await client.setEx(key, duration, JSON.stringify(data));
      originalJson(data);
    };
    
    next();
  };
};

module.exports = redisCache;
```

---

## Cache Invalidation

### Manual Invalidation

```js
const cache = require('./utils/cache');

exports.createProduct = async (req, res) => {
  const product = await Product.create(req.body);
  
  // Invalidate products cache
  cache.del('products');
  
  res.status(201).json({ success: true, data: product });
};

exports.updateProduct = async (req, res) => {
  const product = await Product.findByIdAndUpdate(req.params.id, req.body);
  
  // Invalidate specific product and list cache
  cache.del(`product:${req.params.id}`);
  cache.del('products');
  
  res.json({ success: true, data: product });
};
```

### Pattern-Based Invalidation (Redis)

```js
const invalidateCache = async (pattern) => {
  const keys = await client.keys(pattern);
  if (keys.length > 0) {
    await client.del(keys);
  }
};

// Invalidate all product caches
await invalidateCache('product:*');
```

---

## HTTP Caching Headers

### Cache-Control

```js
app.get('/api/products', (req, res) => {
  // Cache for 1 hour
  res.set('Cache-Control', 'public, max-age=3600');
  res.json({ products });
});
```

### ETag (Entity Tag)

```js
const etag = require('etag');

app.get('/api/products', async (req, res) => {
  const products = await Product.find();
  const data = JSON.stringify(products);
  const etagValue = etag(data);
  
  // Check if client has same version
  if (req.headers['if-none-match'] === etagValue) {
    return res.status(304).send(); // Not Modified
  }
  
  res.set('ETag', etagValue);
  res.json({ success: true, data: products });
});
```

---

## Best Practices

### Versioning
1. **Use URL versioning** - Most clear and simple
2. **Maintain old versions** - For at least 6-12 months
3. **Document changes** - Changelog for each version
4. **Deprecate gracefully** - Give advance notice

### Rate Limiting
1. **Use Redis** - For distributed systems
2. **Different tiers** - Free, basic, premium
3. **Inform users** - Return rate limit headers
4. **Whitelist** - For trusted IPs/users

### Caching
1. **Cache static data** - Categories, settings
2. **Short TTL** - For frequently changing data
3. **Invalidate on write** - Clear cache on updates
4. **Use Redis** - For production/distributed systems

---

## Interview Questions

### Q1: What are common API versioning strategies?
**Answer**: URL versioning (/v1/), header versioning, query parameters. URL versioning is most common.

### Q2: Why use rate limiting?
**Answer**: Prevent abuse, DDoS attacks, ensure fair usage, control costs.

### Q3: What's the difference between node-cache and Redis?
**Answer**: Node-cache is in-memory (single server). Redis is external (distributed, shared across servers).

### Q4: When should you cache data?
**Answer**: Frequently accessed, rarely changed data. Don't cache user-specific or real-time data.

### Q5: What's cache invalidation?
**Answer**: Removing cached data when underlying data changes. "Hardest problem in computer science."

---

## Summary

- **Versioning**: URL versioning is most common (/api/v1/)
- **Rate Limiting**: Prevents abuse with express-rate-limit
- **Tiered Limits**: Different limits for free/premium users
- **Redis**: For distributed rate limiting and caching
- **In-Memory Cache**: node-cache for single-server apps
- **Cache Invalidation**: Clear cache on data updates
- **HTTP Caching**: Cache-Control, ETag headers
- **Best Practices**: Document changes, use Redis for production
