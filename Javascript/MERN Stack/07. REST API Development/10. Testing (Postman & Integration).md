# API Testing (Postman & Integration)

## Why Test APIs?

**Benefits**:
- Catch bugs early
- Ensure reliability
- Prevent regressions
- Document behavior
- Confidence in deployments

> **Untested code is broken code.**

---

## Types of API Testing

### 1. Manual Testing (Postman)
### 2. Unit Testing (Jest)
### 3. Integration Testing (Supertest)
### 4. End-to-End Testing

---

## Postman

### Creating Requests

#### GET Request

```
GET http://localhost:3000/api/users
```

#### POST Request

```
POST http://localhost:3000/api/users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "password": "password123"
}
```

#### With Authentication

```
GET http://localhost:3000/api/users/profile
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

## Postman Collections

### Organizing Requests

```
My API Collection
├── Auth
│   ├── Register
│   ├── Login
│   └── Logout
├── Users
│   ├── Get All Users
│   ├── Get User
│   ├── Create User
│   ├── Update User
│   └── Delete User
└── Products
    ├── Get Products
    └── Create Product
```

---

## Environment Variables (Postman)

### Creating Environment

```
Development Environment:
  baseUrl: http://localhost:3000
  token: {{authToken}}

Production Environment:
  baseUrl: https://api.myapp.com
  token: {{authToken}}
```

### Using Variables

```
GET {{baseUrl}}/api/users
Authorization: Bearer {{token}}
```

---

## Postman Tests (Scripts)

### Basic Assertions

```js
// Status code
pm.test("Status code is 200", function () {
  pm.response.to.have.status(200);
});

// Response time
pm.test("Response time is less than 200ms", function () {
  pm.expect(pm.response.responseTime).to.be.below(200);
});

// Content-Type header
pm.test("Content-Type is JSON", function () {
  pm.response.to.have.header("Content-Type", /json/);
});
```

### Response Body Validation

```js
pm.test("Response has success property", function () {
  const jsonData = pm.response.json();
  pm.expect(jsonData).to.have.property('success');
  pm.expect(jsonData.success).to.be.true;
});

pm.test("User has correct structure", function () {
  const jsonData = pm.response.json();
  pm.expect(jsonData.data).to.have.property('id');
  pm.expect(jsonData.data).to.have.property('name');
  pm.expect(jsonData.data).to.have.property('email');
});

pm.test("Email is valid format", function () {
  const jsonData = pm.response.json();
  pm.expect(jsonData.data.email).to.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
});
```

### Saving Response Data

```js
// Save token from login response
pm.test("Login successful", function () {
  const jsonData = pm.response.json();
  pm.expect(jsonData).to.have.property('token');
  
  // Save token to environment
  pm.environment.set("authToken", jsonData.token);
});

// Save user ID
pm.test("User created", function () {
  const jsonData = pm.response.json();
  pm.environment.set("userId", jsonData.data.id);
});
```

---

## Automated Testing Flow

### 1. Register User

```
POST {{baseUrl}}/api/auth/register

Body:
{
  "name": "Test User",
  "email": "test@example.com",
  "password": "password123"
}

Tests:
pm.test("User registered", function () {
  pm.response.to.have.status(201);
  const jsonData = pm.response.json();
  pm.environment.set("userId", jsonData.data.id);
});
```

### 2. Login

```
POST {{baseUrl}}/api/auth/login

Body:
{
  "email": "test@example.com",
  "password": "password123"
}

Tests:
pm.test("Login successful", function () {
  pm.response.to.have.status(200);
  const jsonData = pm.response.json();
  pm.environment.set("authToken", jsonData.token);
});
```

### 3. Get Profile (Authenticated)

```
GET {{baseUrl}}/api/users/profile
Authorization: Bearer {{authToken}}

Tests:
pm.test("Profile retrieved", function () {
  pm.response.to.have.status(200);
  const jsonData = pm.response.json();
  pm.expect(jsonData.data.id).to.eql(pm.environment.get("userId"));
});
```

---

## Running Collections

### Collection Runner

1. Click **Runner** in Postman
2. Select collection
3. Select environment
4. Click **Run**

### Command Line (Newman)

```bash
npm install -g newman

# Run collection
newman run my-collection.json -e development.json

# With reporters
newman run my-collection.json -e development.json -r cli,html
```

---

## Integration Testing

### Installation

```bash
npm install --save-dev jest supertest
```

### package.json

```json
{
  "scripts": {
    "test": "jest --watchAll --verbose"
  },
  "jest": {
    "testEnvironment": "node"
  }
}
```

---

## Supertest Basics

### Basic Test

```js
// __tests__/users.test.js
const request = require('supertest');
const app = require('../app');

describe('User API', () => {
  test('GET /api/users - should return all users', async () => {
    const response = await request(app)
      .get('/api/users')
      .expect('Content-Type', /json/)
      .expect(200);
    
    expect(response.body.success).toBe(true);
    expect(Array.isArray(response.body.data)).toBe(true);
  });
});
```

### POST Request Test

```js
test('POST /api/users - should create user', async () => {
  const newUser = {
    name: 'John Doe',
    email: 'john@example.com',
    password: 'password123'
  };
  
  const response = await request(app)
    .post('/api/users')
    .send(newUser)
    .expect('Content-Type', /json/)
    .expect(201);
  
  expect(response.body.success).toBe(true);
  expect(response.body.data).toHaveProperty('id');
  expect(response.body.data.name).toBe(newUser.name);
  expect(response.body.data.email).toBe(newUser.email);
});
```

### Authentication Test

```js
let authToken;
let userId;

describe('Auth API', () => {
  test('POST /api/auth/register - should register user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(201);
    
    userId = response.body.data.id;
  });
  
  test('POST /api/auth/login - should login user', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);
    
    expect(response.body.token).toBeDefined();
    authToken = response.body.token;
  });
  
  test('GET /api/users/profile - should get profile', async () => {
    const response = await request(app)
      .get('/api/users/profile')
      .set('Authorization', `Bearer ${authToken}`)
      .expect(200);
    
    expect(response.body.data.id).toBe(userId);
  });
});
```

---

## Complete CRUD Test Suite

```js
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

let userId;

beforeAll(async () => {
  // Setup: Connect to test database
  await mongoose.connect(process.env.TEST_DB_URI);
});

afterAll(async () => {
  // Cleanup: Clear database and close connection
  await User.deleteMany({});
  await mongoose.connection.close();
});

describe('User CRUD Operations', () => {
  // CREATE
  test('POST /api/users - Create user', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      })
      .expect(201);
    
    expect(response.body.data).toHaveProperty('id');
    userId = response.body.data.id;
  });
  
  // READ ALL
  test('GET /api/users - Get all users', async () => {
    const response = await request(app)
      .get('/api/users')
      .expect(200);
    
    expect(Array.isArray(response.body.data)).toBe(true);
    expect(response.body.data.length).toBeGreaterThan(0);
  });
  
  // READ ONE
  test('GET /api/users/:id - Get single user', async () => {
    const response = await request(app)
      .get(`/api/users/${userId}`)
      .expect(200);
    
    expect(response.body.data.id).toBe(userId);
    expect(response.body.data.name).toBe('John Doe');
  });
  
  // UPDATE
  test('PUT /api/users/:id - Update user', async () => {
    const response = await request(app)
      .put(`/api/users/${userId}`)
      .send({ name: 'Jane Doe' })
      .expect(200);
    
    expect(response.body.data.name).toBe('Jane Doe');
  });
  
  // DELETE
  test('DELETE /api/users/:id - Delete user', async () => {
    await request(app)
      .delete(`/api/users/${userId}`)
      .expect(204);
    
    // Verify deletion
    await request(app)
      .get(`/api/users/${userId}`)
      .expect(404);
  });
});
```

---

## Error Handling Tests

```js
describe('Error Handling', () => {
  test('404 - Not Found', async () => {
    await request(app)
      .get('/api/users/invalid-id')
      .expect(404);
  });
  
  test('400 - Validation Error', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({
        name: 'John',
        email: 'invalid-email' // Invalid format
      })
      .expect(400);
    
    expect(response.body.success).toBe(false);
    expect(response.body.error).toBeDefined();
  });
  
  test('401 - Unauthorized', async () => {
    await request(app)
      .get('/api/users/profile')
      // No auth token
      .expect(401);
  });
});
```

---

## Testing Middleware

### Auth Middleware Test

```js
const auth = require('../middlewares/auth');
const jwt = require('jsonwebtoken');

describe('Auth Middleware', () => {
  test('should authenticate valid token', async () => {
    const user = { id: '123', email: 'test@example.com' };
    const token = jwt.sign(user, process.env.JWT_SECRET);
    
    const req = {
      header: jest.fn().mockReturnValue(`Bearer ${token}`)
    };
    const res = {};
    const next = jest.fn();
    
    await auth(req, res, next);
    
    expect(req.user).toBeDefined();
    expect(next).toHaveBeenCalled();
  });
  
  test('should reject invalid token', async () => {
    const req = {
      header: jest.fn().mockReturnValue('Bearer invalid-token')
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };
    const next = jest.fn();
    
    await auth(req, res, next);
    
    expect(res.status).toHaveBeenCalledWith(401);
    expect(next).not.toHaveBeenCalled();
  });
});
```

---

## Mocking Database

### Using jest.mock()

```js
jest.mock('../models/User');
const User = require('../models/User');

test('GET /api/users - Mocked', async () => {
  const mockUsers = [
    { id: '1', name: 'John' },
    { id: '2', name: 'Jane' }
  ];
  
  User.find.mockResolvedValue(mockUsers);
  
  const response = await request(app)
    .get('/api/users')
    .expect(200);
  
  expect(response.body.data).toEqual(mockUsers);
});
```

---

## Test Coverage

### Running with Coverage

```bash
npm test -- --coverage
```

### package.json

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "testEnvironment": "node",
    "coveragePathIgnorePatterns": ["/node_modules/"]
  }
}
```

---

## CI/CD Integration

### GitHub Actions

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '18'
      
      - run: npm install
      - run: npm test
      
      - name: Run Newman Tests
        run: |
          npm install -g newman
          newman run postman-collection.json -e environment.json
```

---

## Best Practices

### 1. Test Structure
- **Arrange**: Set up test data
- **Act**: Execute the function
- **Assert**: Verify results

### 2. Independent Tests
Each test should be independent and not rely on others.

### 3. Use Test Database
Never test on production database.

### 4. Clean Up
Clear test data after each test.

### 5. Descriptive Names
```js
test('should return 404 when user not found', ...);
```

### 6. Test Edge Cases
- Empty inputs
- Invalid data
- Missing fields
- Unauthorized access

---

## Interview Questions

### Q1: What is Supertest?
**Answer**: A library for testing HTTP APIs in Node.js. It allows you to make HTTP requests and assert responses.

### Q2: What's the difference between unit and integration tests?
**Answer**:
- **Unit**: Test individual functions in isolation
- **Integration**: Test multiple components together

### Q3: How do you test authenticated routes?
**Answer**: Generate a valid JWT token and include it in the Authorization header.

### Q4: What is test coverage?
**Answer**: Percentage of code covered by tests. High coverage (>80%) is good but 100% isn't always necessary.

### Q5: Why use a separate test database?
**Answer**: To avoid polluting production data and allow destructive operations during tests.

---

## Summary

- **Postman**: Manual testing, collections, environments
- **Newman**: Command-line Postman runner
- **Jest**: Testing framework
- **Supertest**: HTTP testing library
- **Integration Tests**: Test API endpoints end-to-end
- **Mocking**: Isolate tests from dependencies
- **Coverage**: Measure how much code is tested
- **CI/CD**: Automate tests on every commit
- **Best Practice**: Independent, descriptive, clean tests
