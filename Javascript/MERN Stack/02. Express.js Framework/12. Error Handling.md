# 12. Error Handling

## What is Error Handling?

Catches and handles errors that occur during request processing.

---

## Basic Error Handling

### Synchronous Errors

Express catches them automatically:

```javascript
app.get('/error', (req, res) => {
  throw new Error('Something went wrong!');
  // Express catches this automatically
});
```

### Asynchronous Errors

Must pass to `next()`:

```javascript
app.get('/async', (req, res, next) => {
  setTimeout(() => {
    try {
      throw new Error('Async error');
    } catch (err) {
      next(err);  // Pass to error handler
    }
  }, 1000);
});
```

---

## Error Handling Middleware

**Must have 4 parameters** (err, req, res, next):

```javascript
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```

**❗ Must be defined LAST** (after all routes):

```javascript
// Routes
app.get('/', (req, res) => {
  res.send('Home');
});

// Error handler (last)
app.use((err, req, res, next) => {
  res.status(500).json({ error: err.message });
});
```

---

## Custom Error Handler

```javascript
app.use((err, req, res, next) => {
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';
  
  res.status(statusCode).json({
    success: false,
    error: message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
});
```

---

## Custom Error Classes

### NotFoundError

```javascript
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 404;
    this.name = 'NotFoundError';
  }
}

app.get('/users/:id', (req, res, next) => {
  const user = findUser(req.params.id);
  if (!user) {
    return next(new NotFoundError('User not found'));
  }
  res.json(user);
});
```

### ValidationError

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 400;
    this.name = 'ValidationError';
  }
}

app.post('/users', (req, res, next) => {
  const { email } = req.body;
  if (!email) {
    return next(new ValidationError('Email is required'));
  }
  res.json({ message: 'User created' });
});
```

### UnauthorizedError

```javascript
class UnauthorizedError extends Error {
  constructor(message = 'Unauthorized') {
    super(message);
    this.statusCode = 401;
    this.name = 'UnauthorizedError';
  }
}
```

---

## Async Error Wrapper

Automatically catches async errors:

```javascript
const asyncHandler = (fn) => {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

// Usage
app.get('/users', asyncHandler(async (req, res) => {
  const users = await User.find();  // If error, auto caught
  res.json(users);
}));
```

---

## 404 Handler

Handle routes that don't exist:

```javascript
// After all routes
app.use((req, res, next) => {
  res.status(404).json({
    error: 'Route not found',
    path: req.originalUrl
  });
});

// Or with custom error
app.use((req, res, next) => {
  next(new NotFoundError(`Route ${req.originalUrl} not found`));
});
```

---

## Complete Error Setup

```javascript
const express = require('express');
const app = express();

app.use(express.json());

// Custom error classes
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
  }
}

// Async handler
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// Routes
app.get('/users/:id', asyncHandler(async (req, res) => {
  const user = await findUser(req.params.id);
  if (!user) {
    throw new AppError('User not found', 404);
  }
  res.json(user);
}));

app.post('/users', asyncHandler(async (req, res) => {
  if (!req.body.email) {
    throw new AppError('Email required', 400);
  }
  const user = await createUser(req.body);
  res.status(201).json(user);
}));

// 404 handler
app.use((req, res, next) => {
  next(new AppError(`Route ${req.originalUrl} not found`, 404));
});

// Global error handler
app.use((err, req, res, next) => {
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Internal Server Error';
  
  // Development error
  if (process.env.NODE_ENV === 'development') {
    res.status(err.statusCode).json({
      success: false,
      error: err.message,
      stack: err.stack,
      err: err
    });
  } 
  // Production error
  else {
    res.status(err.statusCode).json({
      success: false,
      error: err.isOperational ? err.message : 'Something went wrong'
    });
  }
});

app.listen(3000);
```

---

## Error Types

### Operational Errors (Expected)

Can be handled gracefully:
- Invalid user input
- Database connection failed
- File not found
- Timeout errors

```javascript
class OperationalError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
  }
}
```

### Programmer Errors (Bugs)

Should crash and restart:
- Undefined variable
- Null reference
- Wrong function call

```javascript
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
  process.exit(1);  // Restart
});

process.on('unhandledRejection', (err) => {
  console.error('Unhandled Rejection:', err);
  process.exit(1);
});
```

---

## Practical Examples

### Database Errors

```javascript
app.get('/users', asyncHandler(async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (err) {
    if (err.name === 'MongoError') {
      throw new AppError('Database error', 500);
    }
    throw err;
  }
}));
```

### Validation Errors

```javascript
app.post('/register', asyncHandler(async (req, res) => {
  const { email, password } = req.body;
  
  if (!email || !password) {
    throw new AppError('Email and password required', 400);
  }
  
  if (password.length < 6) {
    throw new AppError('Password must be at least 6 characters', 400);
  }
  
  const user = await createUser({ email, password });
  res.status(201).json(user);
}));
```

### Authentication Errors

```javascript
const authenticate = (req, res, next) => {
  const token = req.headers.authorization;
  
  if (!token) {
    return next(new AppError('No token provided', 401));
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    next(new AppError('Invalid token', 401));
  }
};
```

---

## Error Logging

### Simple Console Logging

```javascript
app.use((err, req, res, next) => {
  console.error(`[${new Date().toISOString()}] ${err.message}`);
  console.error(err.stack);
  
  res.status(err.statusCode || 500).json({
    error: err.message
  });
});
```

### Advanced Logging (Winston)

```bash
npm install winston
```

```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: 'error',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.Console()
  ]
});

app.use((err, req, res, next) => {
  logger.error({
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method
  });
  
  res.status(err.statusCode || 500).json({
    error: err.message
  });
});
```

---

## Best Practices

✅ **Use error middleware**: Define at the end  
✅ **Use async handler**: Wrap async routes  
✅ **Use custom errors**: Create error classes  
✅ **Log errors**: Use winston or similar  
✅ **Hide stack traces**: In production  
✅ **Return proper status codes**: 400, 401, 404, 500  
✅ **Validate input**: Before processing  
❌ **Don't expose sensitive info**: In error messages  
❌ **Don't ignore errors**: Always handle them  

---

## Summary

**Error Handling:**
- Synchronous errors: Auto-caught
- Async errors: Use `next(err)` or async handler
- Error middleware: 4 parameters (err, req, res, next)

**Custom Errors:**
```javascript
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}
```

**Async Handler:**
```javascript
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};
```

**Common Pattern:**
```javascript
app.get('/route', asyncHandler(async (req, res) => {
  if (!data) throw new AppError('Not found', 404);
  res.json(data);
}));

app.use((err, req, res, next) => {
  res.status(err.statusCode || 500).json({
    error: err.message
  });
});
```

**Next:** Learn about File Uploads!
