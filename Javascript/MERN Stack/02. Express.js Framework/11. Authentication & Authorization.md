# 11. Authentication & Authorization

## Authentication vs Authorization

**Authentication** = Who you are (Login)  
**Authorization** = What you can do (Permissions)

---

## Authentication Methods

### 1. Session-Based Authentication

```javascript
const session = require('express-session');

app.use(session({
  secret: 'my-secret',
  resave: false,
  saveUninitialized: false
}));

// Login
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  if (username === 'john' && password === 'pass123') {
    req.session.userId = 1;
    req.session.username = username;
    res.json({ message: 'Login successful' });
  } else {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});

// Protected route
app.get('/dashboard', (req, res) => {
  if (req.session.userId) {
    res.json({ message: `Welcome ${req.session.username}` });
  } else {
    res.status(401).json({ error: 'Please login' });
  }
});

// Logout
app.post('/logout', (req, res) => {
  req.session.destroy();
  res.json({ message: 'Logged out' });
});
```

### 2. JWT (JSON Web Tokens)

```bash
npm install jsonwebtoken bcryptjs
```

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const SECRET_KEY = 'your-secret-key';

// Register
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  
  const hashedPassword = await bcrypt.hash(password, 10);
  
  // Save user to database
  const user = await User.create({ username, password: hashedPassword });
  
  res.json({ message: 'User registered' });
});

// Login
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  const user = await User.findOne({ username });
  
  if (!user) {
    return res.status(401).json({ error: 'User not found' });
  }
  
  const isValid = await bcrypt.compare(password, user.password);
  
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid password' });
  }
  
  // Generate token
  const token = jwt.sign(
    { id: user.id, username: user.username },
    SECRET_KEY,
    { expiresIn: '24h' }
  );
  
  res.json({ token });
});

// Verify middleware
const authenticateToken = (req, res, next) => {
  const token = req.headers['authorization']?.split(' ')[1];  // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = user;
    next();
  });
};

// Protected route
app.get('/protected', authenticateToken, (req, res) => {
  res.json({ message: `Hello ${req.user.username}` });
});
```

---

## Authorization (Role-Based Access)

### Role Middleware

```javascript
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Not authorized' });
    }
    
    next();
  };
};

// Usage
app.delete('/users/:id', 
  authenticateToken, 
  authorize('admin'), 
  (req, res) => {
    res.json({ message: 'User deleted' });
  }
);

app.post('/posts', 
  authenticateToken, 
  authorize('admin', 'editor'), 
  (req, res) => {
    res.json({ message: 'Post created' });
  }
);
```

---

## Complete Authentication Example

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const app = express();
app.use(express.json());

const SECRET_KEY = process.env.JWT_SECRET || 'secret';
const users = [];  // In production, use database

// Register
app.post('/auth/register', async (req, res) => {
  try {
    const { username, password, role = 'user' } = req.body;
    
    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password required' });
    }
    
    const exists = users.find(u => u.username === username);
    if (exists) {
      return res.status(400).json({ error: 'User already exists' });
    }
    
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const user = {
      id: users.length + 1,
      username,
      password: hashedPassword,
      role
    };
    
    users.push(user);
    
    res.status(201).json({ 
      message: 'User registered',
      user: { id: user.id, username: user.username, role: user.role }
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Login
app.post('/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    
    const user = users.find(u => u.username === username);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const token = jwt.sign(
      { id: user.id, username: user.username, role: user.role },
      SECRET_KEY,
      { expiresIn: '24h' }
    );
    
    res.json({ token, user: { id: user.id, username, role: user.role } });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Authenticate middleware
const authenticate = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// Authorize middleware
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Not authorized' });
    }
    next();
  };
};

// Public route
app.get('/public', (req, res) => {
  res.json({ message: 'Public content' });
});

// Protected route (any authenticated user)
app.get('/profile', authenticate, (req, res) => {
  res.json({ user: req.user });
});

// Admin only
app.get('/admin', authenticate, authorize('admin'), (req, res) => {
  res.json({ message: 'Admin content', users });
});

// Admin or editor
app.post('/posts', authenticate, authorize('admin', 'editor'), (req, res) => {
  res.json({ message: 'Post created' });
});

app.listen(3000);
```

---

## Password Security

### Hashing with bcrypt

```javascript
const bcrypt = require('bcryptjs');

// Hash password
const salt = await bcrypt.genSalt(10);
const hashedPassword = await bcrypt.hash(password, salt);

// Or shorter
const hashedPassword = await bcrypt.hash(password, 10);

// Verify password
const isValid = await bcrypt.compare(password, hashedPassword);
```

---

## JWT Best Practices

### Refresh Tokens

```javascript
let refreshTokens = [];

// Login with refresh token
app.post('/auth/login', async (req, res) => {
  // ... verify credentials
  
  const accessToken = jwt.sign(user, SECRET_KEY, { expiresIn: '15m' });
  const refreshToken = jwt.sign(user, REFRESH_SECRET, { expiresIn: '7d' });
  
  refreshTokens.push(refreshToken);
  
  res.json({ accessToken, refreshToken });
});

// Refresh access token
app.post('/auth/refresh', (req, res) => {
  const { token } = req.body;
  
  if (!token || !refreshTokens.includes(token)) {
    return res.status(403).json({ error: 'Invalid refresh token' });
  }
  
  jwt.verify(token, REFRESH_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    
    const accessToken = jwt.sign(
      { id: user.id, username: user.username },
      SECRET_KEY,
      { expiresIn: '15m' }
    );
    
    res.json({ accessToken });
  });
});

// Logout
app.post('/auth/logout', (req, res) => {
  const { token } = req.body;
  refreshTokens = refreshTokens.filter(t => t !== token);
  res.json({ message: 'Logged out' });
});
```

---

## OAuth 2.0 (Third-Party)

### Using Passport.js

```bash
npm install passport passport-google-oauth20
```

```javascript
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: '/auth/google/callback'
}, (accessToken, refreshToken, profile, done) => {
  // Save or find user in database
  User.findOrCreate({ googleId: profile.id }, (err, user) => {
    return done(err, user);
  });
}));

app.use(passport.initialize());

app.get('/auth/google',
  passport.authenticate('google', { scope: ['profile', 'email'] })
);

app.get('/auth/google/callback',
  passport.authenticate('google', { failureRedirect: '/login' }),
  (req, res) => {
    res.redirect('/dashboard');
  }
);
```

---

## Best Practices

✅ **Hash passwords**: Use bcrypt (never store plain text)  
✅ **Use HTTPS**: Always in production  
✅ **Short token expiry**: 15min for access, 7days for refresh  
✅ **Validate inputs**: Check username/password format  
✅ **Rate limit login**: Prevent brute force  
✅ **Use environment variables**: Store secrets securely  
✅ **Implement logout**: Clear tokens/sessions  
❌ **Don't expose user info**: In JWT payload  
❌ **Don't store tokens in localStorage**: Use httpOnly cookies  

---

## Summary

**Authentication:**
- Session-based: `express-session`
- Token-based: JWT with `jsonwebtoken`

**Authorization:**
- Role-based access control (RBAC)
- Middleware to check roles

**Common Pattern:**
```javascript
// Login
const token = jwt.sign(user, SECRET, { expiresIn: '24h' });

// Middleware
const authenticate = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  jwt.verify(token, SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid' });
    req.user = user;
    next();
  });
};

// Protected
app.get('/protected', authenticate, (req, res) => {
  res.json({ user: req.user });
});
```

**Next:** Learn about Database Integration!
