# 13. Callbacks & Callback Hell

## What is a Callback?

A **callback** is a function passed as an argument to another function, to be executed later.

```javascript
// Regular function
function greet(name) {
  console.log('Hello ' + name);
}

// Function with callback
function processUser(name, callback) {
  console.log('Processing...');
  callback(name);
}

processUser('John', greet);
// Output:
// Processing...
// Hello John
```

---

## Why Use Callbacks?

Node.js is **asynchronous** - operations don't block execution.

```javascript
// ❌ Synchronous (blocks)
const data = fs.readFileSync('file.txt');
console.log(data);
console.log('Done');  // Waits for file to be read

// ✅ Asynchronous (non-blocking)
fs.readFile('file.txt', (err, data) => {
  console.log(data);
});
console.log('Done');  // Runs immediately!

// Output:
// Done
// (file contents)
```

---

## Callback Pattern

Standard Node.js callback signature: **Error-first callbacks**

```javascript
function doSomething(arg, callback) {
  // callback(error, result)
  if (error) {
    callback(error, null);
  } else {
    callback(null, result);
  }
}

// Usage
doSomething('value', (err, result) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log('Result:', result);
});
```

---

## Simple Examples

### Example 1: setTimeout

```javascript
console.log('Start');

setTimeout(() => {
  console.log('After 2 seconds');
}, 2000);

console.log('End');

// Output:
// Start
// End
// After 2 seconds
```

### Example 2: File Reading

```javascript
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log('File contents:', data);
});
```

### Example 3: Custom Callback

```javascript
function fetchUser(id, callback) {
  setTimeout(() => {
    const user = { id: id, name: 'John' };
    callback(null, user);
  }, 1000);
}

fetchUser(1, (err, user) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('User:', user);
});
```

---

## Multiple Callbacks (Sequential)

When you need to do things in order:

```javascript
const fs = require('fs');

// Read file, then process, then save
fs.readFile('input.txt', 'utf8', (err, data) => {
  if (err) throw err;
  
  const processed = data.toUpperCase();
  
  fs.writeFile('output.txt', processed, (err) => {
    if (err) throw err;
    console.log('File saved!');
  });
});
```

---

## Callback Hell (Pyramid of Doom)

When callbacks are nested too deep:

```javascript
// ❌ Callback Hell
const fs = require('fs');

fs.readFile('file1.txt', 'utf8', (err, data1) => {
  if (err) throw err;
  
  fs.readFile('file2.txt', 'utf8', (err, data2) => {
    if (err) throw err;
    
    fs.readFile('file3.txt', 'utf8', (err, data3) => {
      if (err) throw err;
      
      fs.writeFile('output.txt', data1 + data2 + data3, (err) => {
        if (err) throw err;
        
        console.log('Done!');
      });
    });
  });
});
```

**Problems:**
- Hard to read
- Hard to maintain
- Error handling duplicated
- Difficult to debug

---

## Solutions to Callback Hell

### Solution 1: Named Functions

```javascript
const fs = require('fs');

function readFile1(callback) {
  fs.readFile('file1.txt', 'utf8', (err, data) => {
    if (err) return callback(err);
    callback(null, data);
  });
}

function readFile2(data1, callback) {
  fs.readFile('file2.txt', 'utf8', (err, data2) => {
    if (err) return callback(err);
    callback(null, data1 + data2);
  });
}

function writeFile(data, callback) {
  fs.writeFile('output.txt', data, callback);
}

// Use them
readFile1((err, data1) => {
  if (err) throw err;
  
  readFile2(data1, (err, combined) => {
    if (err) throw err;
    
    writeFile(combined, (err) => {
      if (err) throw err;
      console.log('Done!');
    });
  });
});
```

Better, but still nested.

---

### Solution 2: Promises (Best)

```javascript
const fs = require('fs').promises;

fs.readFile('file1.txt', 'utf8')
  .then(data1 => fs.readFile('file2.txt', 'utf8'))
  .then(data2 => fs.readFile('file3.txt', 'utf8'))
  .then(data3 => fs.writeFile('output.txt', data3))
  .then(() => console.log('Done!'))
  .catch(err => console.error('Error:', err));
```

Even better with **async/await**:

```javascript
async function processFiles() {
  try {
    const data1 = await fs.readFile('file1.txt', 'utf8');
    const data2 = await fs.readFile('file2.txt', 'utf8');
    const data3 = await fs.readFile('file3.txt', 'utf8');
    await fs.writeFile('output.txt', data1 + data2 + data3);
    console.log('Done!');
  } catch (err) {
    console.error('Error:', err);
  }
}

processFiles();
```

---

## Real-World Example

### Bad (Callback Hell):

```javascript
getUserById(1, (err, user) => {
  if (err) throw err;
  
  getPostsByUser(user.id, (err, posts) => {
    if (err) throw err;
    
    getComments(posts[0].id, (err, comments) => {
      if (err) throw err;
      
      console.log(comments);
    });
  });
});
```

### Good (Promises):

```javascript
getUserById(1)
  .then(user => getPostsByUser(user.id))
  .then(posts => getComments(posts[0].id))
  .then(comments => console.log(comments))
  .catch(err => console.error(err));
```

### Better (Async/Await):

```javascript
async function getCommentsForUser(userId) {
  try {
    const user = await getUserById(userId);
    const posts = await getPostsByUser(user.id);
    const comments = await getComments(posts[0].id);
    console.log(comments);
  } catch (err) {
    console.error(err);
  }
}

getCommentsForUser(1);
```

---

## Error Handling

### Always Check Errors

```javascript
// ✅ Good
fs.readFile('file.txt', (err, data) => {
  if (err) {
    console.error('Error:', err);
    return;  // Stop execution
  }
  console.log(data);
});

// ❌ Bad (crashes if error)
fs.readFile('file.txt', (err, data) => {
  console.log(data);  // Uncaught error!
});
```

### Centralized Error Handling

```javascript
function handleError(err) {
  console.error('Error occurred:', err.message);
  // Log to file, send to monitoring service, etc.
}

fs.readFile('file.txt', (err, data) => {
  if (err) return handleError(err);
  console.log(data);
});
```

---

## Callback Best Practices

✅ **Always handle errors first**: Check `err` parameter  
✅ **Return after callback**: Prevent further execution  
✅ **Use named functions**: Avoid deep nesting  
✅ **Keep callbacks shallow**: Max 2-3 levels  
✅ **Use promises/async-await**: Modern alternative  
❌ **Don't throw in callbacks**: Use `callback(err)` instead  
❌ **Don't call callback twice**: Causes bugs  

---

## Common Mistakes

### Mistake 1: Calling Callback Multiple Times

```javascript
// ❌ Bad
function doSomething(callback) {
  if (error) {
    callback(error);
    // Still continues!
  }
  callback(null, result);  // Called again!
}

// ✅ Good
function doSomething(callback) {
  if (error) {
    return callback(error);  // Return stops execution
  }
  callback(null, result);
}
```

### Mistake 2: Forgetting Error Parameter

```javascript
// ❌ Bad
fs.readFile('file.txt', (data) => {
  console.log(data);  // What if error?
});

// ✅ Good
fs.readFile('file.txt', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```

### Mistake 3: Mixing Sync and Async

```javascript
// ❌ Bad (unpredictable)
function getData(callback) {
  if (cache) {
    callback(cache);  // Synchronous
  } else {
    fetchData((data) => {
      callback(data);  // Asynchronous
    });
  }
}

// ✅ Good (always async)
function getData(callback) {
  if (cache) {
    process.nextTick(() => callback(cache));
  } else {
    fetchData((data) => {
      callback(data);
    });
  }
}
```

---

## Callback vs Promises vs Async/Await

| Feature | Callbacks | Promises | Async/Await |
|---------|-----------|----------|-------------|
| **Readability** | ❌ Hard | ✅ Good | ✅ Best |
| **Error Handling** | Manual | `.catch()` | `try/catch` |
| **Nesting** | Deep | Flat | Flat |
| **Learning Curve** | Easy | Medium | Easy |
| **Modern?** | Old | Modern | Most Modern |

---

## Summary

- **Callbacks** are functions passed to other functions
- Node.js uses **error-first callbacks**: `(err, result) => {}`
- **Callback Hell** happens when callbacks are nested too deep
- **Solutions:**
  - Use named functions
  - Use promises (`.then()`)
  - Use async/await (best)
- Always handle errors first
- Return after calling callback
- Modern code prefers **Promises** and **Async/Await**

**Next:** Learn about Promises!
