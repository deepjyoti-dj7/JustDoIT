# 15. Async/Await & Error Handling

## What is Async/Await?

**Async/Await** is modern syntax for working with promises. It makes asynchronous code look synchronous.

```javascript
// With Promises
fetchData()
  .then(data => processData(data))
  .then(result => console.log(result))
  .catch(err => console.error(err));

// With Async/Await
async function getData() {
  try {
    const data = await fetchData();
    const result = await processData(data);
    console.log(result);
  } catch (err) {
    console.error(err);
  }
}
```

---

## async Keyword

Defines an **async function** (always returns a promise):

```javascript
async function myFunction() {
  return 'Hello';
}

// Same as:
function myFunction() {
  return Promise.resolve('Hello');
}

// Usage
myFunction().then(result => console.log(result));  // 'Hello'
```

---

## await Keyword

**Waits** for a promise to resolve:

```javascript
async function fetchUser() {
  const response = await fetch('https://api.example.com/user');
  const user = await response.json();
  return user;
}

// await pauses execution until promise resolves
```

**Rules:**
- Can only use `await` inside `async` function
- `await` pauses function execution (not the entire program)

---

## Basic Example

```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function example() {
  console.log('Start');
  await delay(2000);  // Wait 2 seconds
  console.log('After 2 seconds');
  await delay(1000);  // Wait 1 second
  console.log('After 3 seconds total');
}

example();
// Output:
// Start
// (2 second pause)
// After 2 seconds
// (1 second pause)
// After 3 seconds total
```

---

## File Operations

### Reading Files

```javascript
const fs = require('fs').promises;

async function readFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    console.log(data);
  } catch (err) {
    console.error('Error:', err);
  }
}

readFile();
```

### Writing Files

```javascript
const fs = require('fs').promises;

async function writeFile() {
  try {
    await fs.writeFile('output.txt', 'Hello World!');
    console.log('File written!');
  } catch (err) {
    console.error('Error:', err);
  }
}

writeFile();
```

---

## Sequential Operations

Execute operations **one after another**:

```javascript
async function processFiles() {
  try {
    const file1 = await fs.readFile('file1.txt', 'utf8');
    console.log('File 1 loaded');
    
    const file2 = await fs.readFile('file2.txt', 'utf8');
    console.log('File 2 loaded');
    
    const file3 = await fs.readFile('file3.txt', 'utf8');
    console.log('File 3 loaded');
    
    const combined = file1 + file2 + file3;
    await fs.writeFile('output.txt', combined);
    console.log('Done!');
    
  } catch (err) {
    console.error('Error:', err);
  }
}
```

---

## Parallel Operations

Execute operations **simultaneously** (faster):

```javascript
async function loadFiles() {
  try {
    // ❌ Sequential (slow - 3 seconds)
    const file1 = await fs.readFile('file1.txt', 'utf8');
    const file2 = await fs.readFile('file2.txt', 'utf8');
    const file3 = await fs.readFile('file3.txt', 'utf8');
    
    // ✅ Parallel (fast - 1 second)
    const [file1, file2, file3] = await Promise.all([
      fs.readFile('file1.txt', 'utf8'),
      fs.readFile('file2.txt', 'utf8'),
      fs.readFile('file3.txt', 'utf8')
    ]);
    
    console.log('All files loaded!');
    
  } catch (err) {
    console.error('Error:', err);
  }
}
```

---

## Error Handling

### try/catch

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
  } catch (err) {
    console.error('Error:', err.message);
    return null;
  }
}
```

### Multiple try/catch

```javascript
async function process() {
  let user;
  let posts;
  
  // Handle each operation separately
  try {
    user = await fetchUser(1);
  } catch (err) {
    console.error('Error fetching user:', err);
    return;
  }
  
  try {
    posts = await fetchPosts(user.id);
  } catch (err) {
    console.error('Error fetching posts:', err);
    posts = [];  // Use default
  }
  
  console.log(user, posts);
}
```

### Catching Specific Errors

```javascript
async function readFile() {
  try {
    const data = await fs.readFile('file.txt', 'utf8');
    return data;
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.error('File not found');
    } else if (err.code === 'EACCES') {
      console.error('Permission denied');
    } else {
      console.error('Unknown error:', err);
    }
    throw err;  // Re-throw if needed
  }
}
```

---

## Real-World Examples

### Example 1: API Call Chain

```javascript
async function getUserPosts(userId) {
  try {
    // Get user
    const user = await fetch(`/api/users/${userId}`).then(r => r.json());
    console.log('User:', user.name);
    
    // Get user's posts
    const posts = await fetch(`/api/posts?userId=${userId}`).then(r => r.json());
    console.log('Posts:', posts.length);
    
    // Get comments for first post
    const comments = await fetch(`/api/comments?postId=${posts[0].id}`).then(r => r.json());
    console.log('Comments:', comments.length);
    
    return { user, posts, comments };
    
  } catch (err) {
    console.error('Error:', err);
    throw err;
  }
}

getUserPosts(1);
```

### Example 2: Database Operations

```javascript
async function createUser(userData) {
  try {
    // Start transaction
    await db.beginTransaction();
    
    // Create user
    const user = await db.users.create(userData);
    
    // Create profile
    await db.profiles.create({ userId: user.id });
    
    // Create settings
    await db.settings.create({ userId: user.id });
    
    // Commit transaction
    await db.commit();
    
    return user;
    
  } catch (err) {
    // Rollback on error
    await db.rollback();
    console.error('Error creating user:', err);
    throw err;
  }
}
```

### Example 3: File Processing

```javascript
const fs = require('fs').promises;

async function processLargeFile() {
  try {
    // Read file
    const content = await fs.readFile('data.txt', 'utf8');
    
    // Process data
    const lines = content.split('\n');
    const processed = lines.map(line => line.toUpperCase());
    
    // Save result
    await fs.writeFile('output.txt', processed.join('\n'));
    
    console.log(`Processed ${lines.length} lines`);
    
  } catch (err) {
    console.error('Error:', err);
  }
}

processLargeFile();
```

---

## Return Values

```javascript
async function getValue() {
  return 42;
}

// Returns a Promise
getValue().then(value => console.log(value));  // 42

// Or use await
async function main() {
  const value = await getValue();
  console.log(value);  // 42
}
```

---

## Top-Level Await (Node 14.8+)

```javascript
// In ES modules (.mjs or "type": "module")
const data = await fetch('https://api.example.com/data');
const json = await data.json();
console.log(json);

// No need to wrap in async function!
```

---

## Loops with Async/Await

### for...of Loop

```javascript
async function processUsers(userIds) {
  for (const id of userIds) {
    const user = await fetchUser(id);  // Sequential
    console.log(user.name);
  }
}

processUsers([1, 2, 3, 4, 5]);
```

### Parallel with map

```javascript
async function processUsers(userIds) {
  const promises = userIds.map(id => fetchUser(id));
  const users = await Promise.all(promises);  // Parallel
  users.forEach(user => console.log(user.name));
}

processUsers([1, 2, 3, 4, 5]);
```

---

## Error Propagation

```javascript
async function level3() {
  throw new Error('Error at level 3');
}

async function level2() {
  await level3();  // Error propagates up
}

async function level1() {
  try {
    await level2();
  } catch (err) {
    console.error('Caught:', err.message);  // 'Error at level 3'
  }
}

level1();
```

---

## Timeout with Async/Await

```javascript
function timeout(ms) {
  return new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), ms)
  );
}

async function fetchWithTimeout(url, ms) {
  try {
    const result = await Promise.race([
      fetch(url),
      timeout(ms)
    ]);
    return result;
  } catch (err) {
    console.error('Request timed out');
    throw err;
  }
}

fetchWithTimeout('https://api.example.com', 5000);
```

---

## Retry Logic

```javascript
async function fetchWithRetry(url, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url);
      return response;
    } catch (err) {
      console.log(`Attempt ${i + 1} failed`);
      if (i === retries - 1) throw err;  // Last attempt
      await new Promise(resolve => setTimeout(resolve, 1000));  // Wait 1s
    }
  }
}

fetchWithRetry('https://api.example.com');
```

---

## Best Practices

✅ **Use try/catch**: Always handle errors  
✅ **Await in parallel**: Use `Promise.all()` when possible  
✅ **Return early**: On errors to prevent further execution  
✅ **Use descriptive names**: `fetchUser` not `getData`  
✅ **Keep functions focused**: One responsibility per function  
❌ **Don't forget await**: Returns promise, not value  
❌ **Don't await in loops unnecessarily**: Use `Promise.all()`  
❌ **Don't mix callbacks and async/await**: Choose one style  

---

## Common Mistakes

### Mistake 1: Forgetting await

```javascript
// ❌ Bad
async function getData() {
  const data = fetchData();  // Forgot await!
  console.log(data);  // Promise, not data
}

// ✅ Good
async function getData() {
  const data = await fetchData();
  console.log(data);
}
```

### Mistake 2: Awaiting in Loop (Sequential)

```javascript
// ❌ Slow (sequential)
async function getUsers(ids) {
  const users = [];
  for (const id of ids) {
    users.push(await fetchUser(id));  // Waits for each
  }
  return users;
}

// ✅ Fast (parallel)
async function getUsers(ids) {
  return await Promise.all(ids.map(id => fetchUser(id)));
}
```

### Mistake 3: Not Handling Errors

```javascript
// ❌ Bad (crashes on error)
async function getData() {
  const data = await fetchData();
  return data;
}

// ✅ Good
async function getData() {
  try {
    const data = await fetchData();
    return data;
  } catch (err) {
    console.error('Error:', err);
    return null;
  }
}
```

---

## Async/Await vs Promises

| Feature | Promises | Async/Await |
|---------|----------|-------------|
| **Syntax** | `.then()/.catch()` | `try/catch` |
| **Readability** | Good | Better |
| **Error Handling** | `.catch()` | `try/catch` |
| **Sequential** | Chaining | Natural |
| **Parallel** | `Promise.all()` | `Promise.all()` |
| **Debugging** | Harder | Easier |

---

## Summary

- **async** makes function return a promise
- **await** pauses execution until promise resolves
- Use **try/catch** for error handling
- Use **Promise.all()** for parallel operations
- **Sequential**: Use multiple `await` statements
- **Parallel**: Use `await Promise.all()`
- Always handle errors with try/catch
- Async/await makes async code look synchronous
- Top-level await works in ES modules

**Next:** Learn about debugging Node.js applications!
