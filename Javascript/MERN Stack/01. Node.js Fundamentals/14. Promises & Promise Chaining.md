# 14. Promises & Promise Chaining

## What is a Promise?

A **Promise** is an object representing the eventual completion (or failure) of an asynchronous operation.

**States:**
- **Pending**: Initial state, operation in progress
- **Fulfilled**: Operation completed successfully
- **Rejected**: Operation failed

```
┌─────────┐
│ Pending │
└────┬────┘
     │
     ├─────▶ Fulfilled (Success) → .then()
     │
     └─────▶ Rejected (Error) → .catch()
```

---

## Creating a Promise

```javascript
const myPromise = new Promise((resolve, reject) => {
  // Do async operation
  const success = true;
  
  if (success) {
    resolve('Operation successful!');
  } else {
    reject('Operation failed!');
  }
});
```

---

## Using Promises

### Basic Usage

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Done!');
  }, 2000);
});

promise
  .then(result => {
    console.log(result);  // 'Done!' after 2 seconds
  })
  .catch(error => {
    console.error(error);
  });
```

---

## .then() and .catch()

```javascript
const promise = new Promise((resolve, reject) => {
  const random = Math.random();
  
  if (random > 0.5) {
    resolve('Success!');
  } else {
    reject('Failed!');
  }
});

promise
  .then(result => {
    console.log('Result:', result);
  })
  .catch(error => {
    console.error('Error:', error);
  })
  .finally(() => {
    console.log('Promise completed');
  });
```

---

## Real Example: File Reading

### Callback Style (Old):

```javascript
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error:', err);
    return;
  }
  console.log(data);
});
```

### Promise Style:

```javascript
const fs = require('fs').promises;

fs.readFile('file.txt', 'utf8')
  .then(data => {
    console.log(data);
  })
  .catch(err => {
    console.error('Error:', err);
  });
```

---

## Promise Chaining

Execute multiple async operations in sequence:

```javascript
const fs = require('fs').promises;

fs.readFile('user.json', 'utf8')
  .then(data => {
    const user = JSON.parse(data);
    return fs.readFile(`${user.id}.txt`, 'utf8');
  })
  .then(fileData => {
    console.log('File data:', fileData);
    return fileData.toUpperCase();
  })
  .then(uppercase => {
    console.log('Uppercase:', uppercase);
  })
  .catch(err => {
    console.error('Error:', err);
  });
```

**Key Rule**: Return a value or promise from `.then()` to chain.

---

## Example: Sequential API Calls

```javascript
function getUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: 'John', postsId: 123 });
    }, 1000);
  });
}

function getPosts(postsId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1' },
        { id: 2, title: 'Post 2' }
      ]);
    }, 1000);
  });
}

function getComments(postId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(['Comment 1', 'Comment 2']);
    }, 1000);
  });
}

// Chain them
getUser(1)
  .then(user => {
    console.log('User:', user);
    return getPosts(user.postsId);
  })
  .then(posts => {
    console.log('Posts:', posts);
    return getComments(posts[0].id);
  })
  .then(comments => {
    console.log('Comments:', comments);
  })
  .catch(err => {
    console.error('Error:', err);
  });
```

---

## Creating Custom Promises

```javascript
function fetchData(url) {
  return new Promise((resolve, reject) => {
    // Simulate API call
    setTimeout(() => {
      if (url) {
        resolve({ data: 'Some data' });
      } else {
        reject(new Error('URL is required'));
      }
    }, 1000);
  });
}

// Usage
fetchData('https://api.example.com')
  .then(response => {
    console.log(response.data);
  })
  .catch(err => {
    console.error(err.message);
  });
```

---

## Promise.all()

Run multiple promises **in parallel**, wait for all:

```javascript
const promise1 = Promise.resolve(1);
const promise2 = Promise.resolve(2);
const promise3 = Promise.resolve(3);

Promise.all([promise1, promise2, promise3])
  .then(results => {
    console.log(results);  // [1, 2, 3]
  })
  .catch(err => {
    console.error(err);
  });
```

### Real Example:

```javascript
const fs = require('fs').promises;

const files = ['file1.txt', 'file2.txt', 'file3.txt'];

const promises = files.map(file => fs.readFile(file, 'utf8'));

Promise.all(promises)
  .then(contents => {
    console.log('All files:', contents);
  })
  .catch(err => {
    console.error('Error reading files:', err);
  });
```

**Note**: If **any** promise rejects, `Promise.all()` rejects immediately.

---

## Promise.allSettled()

Wait for all promises (doesn't fail fast):

```javascript
const promises = [
  Promise.resolve('Success 1'),
  Promise.reject('Error 1'),
  Promise.resolve('Success 2')
];

Promise.allSettled(promises)
  .then(results => {
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        console.log('Success:', result.value);
      } else {
        console.log('Failed:', result.reason);
      }
    });
  });

// Output:
// Success: Success 1
// Failed: Error 1
// Success: Success 2
```

---

## Promise.race()

Returns first promise to **settle** (fulfill or reject):

```javascript
const promise1 = new Promise(resolve => setTimeout(resolve, 500, 'Fast'));
const promise2 = new Promise(resolve => setTimeout(resolve, 1000, 'Slow'));

Promise.race([promise1, promise2])
  .then(result => {
    console.log(result);  // 'Fast'
  });
```

### Use Case: Timeout

```javascript
function fetchWithTimeout(url, timeout) {
  const fetchPromise = fetch(url);
  
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeout);
  });
  
  return Promise.race([fetchPromise, timeoutPromise]);
}

fetchWithTimeout('https://api.example.com', 5000)
  .then(response => console.log(response))
  .catch(err => console.error(err.message));
```

---

## Promise.any()

Returns first promise to **fulfill**:

```javascript
const promises = [
  Promise.reject('Error 1'),
  Promise.resolve('Success 1'),
  Promise.resolve('Success 2')
];

Promise.any(promises)
  .then(result => {
    console.log(result);  // 'Success 1'
  })
  .catch(err => {
    console.error('All promises rejected');
  });
```

---

## Error Handling

### Single Catch

```javascript
promise1
  .then(result1 => promise2(result1))
  .then(result2 => promise3(result2))
  .then(result3 => console.log(result3))
  .catch(err => {
    // Catches errors from any promise
    console.error('Error:', err);
  });
```

### Multiple Catches

```javascript
promise1
  .then(result => {
    return promise2(result);
  })
  .catch(err => {
    console.error('Error in promise1:', err);
    return 'default value';  // Recovery
  })
  .then(result => {
    console.log('Continuing with:', result);
  });
```

---

## finally()

Runs regardless of success or failure:

```javascript
fetchData()
  .then(data => {
    console.log('Data:', data);
  })
  .catch(err => {
    console.error('Error:', err);
  })
  .finally(() => {
    console.log('Cleanup: Close loading spinner');
  });
```

---

## Converting Callbacks to Promises

### Manual Conversion:

```javascript
const fs = require('fs');

function readFilePromise(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  });
}

// Usage
readFilePromise('file.txt')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

### Using util.promisify:

```javascript
const fs = require('fs');
const util = require('util');

const readFile = util.promisify(fs.readFile);

readFile('file.txt', 'utf8')
  .then(data => console.log(data))
  .catch(err => console.error(err));
```

---

## Promise Methods Summary

| Method | Description |
|--------|-------------|
| `Promise.all()` | Wait for all, fail if any fails |
| `Promise.allSettled()` | Wait for all, never fails |
| `Promise.race()` | First to settle (resolve or reject) |
| `Promise.any()` | First to fulfill (resolve) |
| `Promise.resolve()` | Create fulfilled promise |
| `Promise.reject()` | Create rejected promise |

---

## Best Practices

✅ **Always use .catch()**: Handle errors  
✅ **Return promises in .then()**: Enable chaining  
✅ **Use Promise.all() for parallel**: Faster execution  
✅ **Use .finally() for cleanup**: Close connections, spinners  
✅ **Avoid nesting promises**: Use chaining instead  
❌ **Don't forget to return**: Breaks the chain  
❌ **Don't mix callbacks and promises**: Choose one  

---

## Common Mistakes

### Mistake 1: Not Returning

```javascript
// ❌ Bad (promise not chained)
promise1
  .then(result => {
    promise2(result);  // Forgot to return!
  })
  .then(result => {
    console.log(result);  // undefined
  });

// ✅ Good
promise1
  .then(result => {
    return promise2(result);  // Return it!
  })
  .then(result => {
    console.log(result);
  });
```

### Mistake 2: Nested Promises

```javascript
// ❌ Bad (callback hell with promises)
promise1.then(result1 => {
  promise2.then(result2 => {
    promise3.then(result3 => {
      console.log(result3);
    });
  });
});

// ✅ Good (chaining)
promise1
  .then(result1 => promise2)
  .then(result2 => promise3)
  .then(result3 => console.log(result3));
```

---

## Summary

- **Promise** represents async operation result
- Three states: Pending, Fulfilled, Rejected
- `.then()` handles success, `.catch()` handles errors
- `.finally()` runs regardless of outcome
- **Promise chaining** executes operations sequentially
- **Promise.all()** runs multiple promises in parallel
- **Promise.allSettled()** waits for all (doesn't fail fast)
- **Promise.race()** returns first to settle
- Use **util.promisify()** to convert callbacks to promises

**Next:** Learn about Async/Await!
