# 04. Modules & require

## What are Modules?

Modules are **reusable pieces of code** that can be imported and exported between files.

### Benefits:
- ✅ Code organization
- ✅ Reusability
- ✅ Maintainability
- ✅ Avoid namespace pollution

---

## Types of Modules

### 1. **Built-in Modules** (Core modules)
Provided by Node.js (no installation needed)

```javascript
const fs = require('fs');
const path = require('path');
const http = require('http');
```

### 2. **Local Modules** (Your own files)
Created by you

```javascript
const myModule = require('./myModule');
const utils = require('./utils/helpers');
```

### 3. **Third-party Modules** (NPM packages)
Installed via NPM

```javascript
const express = require('express');
const mongoose = require('mongoose');
```

---

## Creating a Module

### **math.js** (Export module)

```javascript
// Method 1: Export individual items
exports.add = (a, b) => a + b;
exports.subtract = (a, b) => a - b;

// Method 2: Export object
module.exports = {
  multiply: (a, b) => a * b,
  divide: (a, b) => a / b
};

// Method 3: Export single function/class
module.exports = function Calculator() {
  this.add = (a, b) => a + b;
};
```

### **app.js** (Import module)

```javascript
// Import entire module
const math = require('./math');

console.log(math.add(5, 3));       // 8
console.log(math.subtract(5, 3));  // 2
```

---

## exports vs module.exports

### Understanding the difference:

```javascript
// Behind the scenes:
// module.exports = {}
// exports = module.exports  (reference to same object)

// ✅ This works
exports.name = 'John';
exports.age = 30;

// ❌ This breaks the reference
exports = { name: 'John' };  // exports now points to new object

// ✅ This works
module.exports = { name: 'John' };  // Correct way
```

### Rule of Thumb:
- Use **exports** for adding properties
- Use **module.exports** for replacing entire object

---

## Module Patterns

### Pattern 1: **Object Export**

```javascript
// user.js
module.exports = {
  name: 'Alice',
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
};

// app.js
const user = require('./user');
user.greet();  // Hello, I'm Alice
```

### Pattern 2: **Function Export**

```javascript
// logger.js
module.exports = function log(message) {
  console.log(`[LOG]: ${message}`);
};

// app.js
const log = require('./logger');
log('Server started');  // [LOG]: Server started
```

### Pattern 3: **Class Export**

```javascript
// Person.js
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

module.exports = Person;

// app.js
const Person = require('./Person');
const alice = new Person('Alice');
alice.greet();  // Hello, I'm Alice
```

### Pattern 4: **Multiple Exports**

```javascript
// utils.js
const formatDate = (date) => date.toISOString();
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);

module.exports = { formatDate, capitalize };

// app.js
const { formatDate, capitalize } = require('./utils');
console.log(capitalize('hello'));  // Hello
```

---

## Module Caching

**Modules are cached after first load**

```javascript
// counter.js
let count = 0;
module.exports = {
  increment() { count++; },
  getCount() { return count; }
};

// app.js
const counter1 = require('./counter');
const counter2 = require('./counter');

counter1.increment();
console.log(counter1.getCount());  // 1
console.log(counter2.getCount());  // 1 (same instance!)

// Both point to the same cached module
console.log(counter1 === counter2);  // true
```

### Clear Cache (rarely needed):

```javascript
delete require.cache[require.resolve('./counter')];
```

---

## Module Resolution

How `require()` finds modules:

```javascript
require('express');      // 1. Check node_modules/
require('./math');       // 2. Relative path
require('/abs/path');    // 3. Absolute path
require('math.js');      // 4. Add .js if not found
```

### Resolution Order:
1. Core modules (fs, path, http)
2. ./file or ../file (relative)
3. /abs/path (absolute)
4. node_modules/ (searches up directory tree)

---

## File Extensions

Node.js tries extensions in order:
1. .js
2. .json
3. .node (C++ addon)

```javascript
// All equivalent
require('./math');
require('./math.js');
require('./math.json');
```

---

## Folder as Module

If you require a folder, Node.js looks for:

### 1. **package.json** with "main" field

```json
{
  "main": "lib/index.js"
}
```

### 2. **index.js** in that folder

```
my-module/
├── index.js    ← Default entry point
└── utils.js
```

```javascript
require('./my-module');  // Loads index.js
```

---

## Circular Dependencies

### ⚠️ Problem:

```javascript
// a.js
const b = require('./b');
module.exports = { name: 'Module A' };

// b.js
const a = require('./a');  // Gets incomplete export!
module.exports = { name: 'Module B' };
```

### ✅ Solution:
Avoid circular dependencies or use lazy loading

```javascript
// b.js
module.exports = {
  getName() {
    const a = require('./a');  // Load when needed
    return a.name;
  }
};
```

---

## Global vs Local Modules

### **Local** (Default):
```bash
npm install express
```
```javascript
const express = require('express');
```

### **Global** (CLI tools):
```bash
npm install -g nodemon
```
```bash
nodemon app.js
```

---

## Common Built-in Modules

```javascript
const fs = require('fs');           // File system
const path = require('path');       // File paths
const http = require('http');       // HTTP server
const https = require('https');     // HTTPS server
const os = require('os');           // OS information
const crypto = require('crypto');   // Cryptography
const util = require('util');       // Utilities
const events = require('events');   // Event emitter
```

---

## Best Practices

✅ **Use const** for require: `const fs = require('fs')`  
✅ **Require at top**: Import at file start  
✅ **Use relative paths**: `./` or `../` for local modules  
✅ **Destructure**: `const { readFile } = require('fs')`  
✅ **Avoid circular deps**: Redesign module structure  
✅ **Cache wisely**: Understand module caching  

---

## Summary

- Modules organize code into reusable pieces
- 3 types: Built-in, Local, Third-party
- `exports` adds properties, `module.exports` replaces object
- Modules are cached after first load
- Node.js resolves modules: core → relative → node_modules
- Avoid circular dependencies

**Next:** Learn the difference between CommonJS and ES6 modules!
