# 03. Node.js Architecture & Event Loop

## Node.js Architecture

```
┌─────────────────────────────────────┐
│     JavaScript Code (Your App)      │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│         Node.js Bindings            │
│    (JavaScript ↔ C++ Interface)     │
└──────────────┬──────────────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────┐          ┌─────▼─────┐
│   V8   │          │  libuv    │
│ Engine │          │(Event Loop)│
└────────┘          └───────────┘
```

### Components:

1. **V8 Engine**
   - JavaScript execution engine (C++)
   - Developed by Google for Chrome
   - Compiles JS to machine code
   - Memory management & garbage collection

2. **libuv**
   - C library for async I/O
   - Implements event loop
   - Thread pool for file operations
   - Cross-platform compatibility

3. **Node.js Bindings**
   - Bridge between JavaScript and C++
   - Provides access to system resources

4. **Node.js APIs**
   - Built-in modules (fs, http, path, etc.)
   - JavaScript layer on top of C++ bindings

---

## The Event Loop

### What is the Event Loop?

The event loop is the mechanism that makes Node.js **non-blocking** and **asynchronous**.

### Single-Threaded Model

```javascript
// JavaScript runs on single thread
console.log('1. Start');

setTimeout(() => {
  console.log('2. Timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('3. Promise');
});

console.log('4. End');

// Output:
// 1. Start
// 4. End
// 3. Promise
// 2. Timeout
```

---

## Event Loop Phases

```
   ┌───────────────────────────┐
┌─▶│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │           poll            │◀─── Incoming connections,
│  └─────────────┬─────────────┘     data, etc.
│  ┌─────────────▼─────────────┐
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────▼─────────────┐
│  │      close callbacks      │
│  └─────────────┬─────────────┘
└──────────────────────────────┘
```

### 1. **Timers Phase**
- Executes callbacks from `setTimeout()` and `setInterval()`

### 2. **Pending Callbacks Phase**
- Executes I/O callbacks deferred to next loop iteration

### 3. **Idle, Prepare Phase**
- Internal use only

### 4. **Poll Phase** (Most important)
- Retrieves new I/O events
- Executes I/O callbacks
- Waits for callbacks if queue is empty

### 5. **Check Phase**
- Executes `setImmediate()` callbacks

### 6. **Close Callbacks Phase**
- Executes close event callbacks (e.g., `socket.on('close')`)

---

## Call Stack, Task Queue, Microtask Queue

### Example:

```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

// Output: 1, 4, 3, 2
```

### How it works:

1. **Call Stack**: Synchronous code executes immediately
   - `console.log('1')` → Output: 1
   - `console.log('4')` → Output: 4

2. **Microtask Queue**: Promises (higher priority)
   - `Promise.then()` → Output: 3

3. **Task Queue**: setTimeout, setInterval (lower priority)
   - `setTimeout()` → Output: 2

### Priority Order:
```
Call Stack > Microtask Queue > Task Queue
```

---

## Blocking vs Non-Blocking

### ❌ Blocking Code (Synchronous)

```javascript
const fs = require('fs');

// Blocks execution until file is read
const data = fs.readFileSync('file.txt', 'utf8');
console.log(data);
console.log('This waits for file to be read');
```

### ✅ Non-Blocking Code (Asynchronous)

```javascript
const fs = require('fs');

// Doesn't block - continues execution
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
console.log('This runs immediately!');
```

---

## Thread Pool (libuv)

Some operations are too expensive for event loop:
- File I/O
- DNS lookups
- Compression
- Cryptography

**libuv uses a thread pool** (default: 4 threads)

```javascript
// File operations use thread pool
fs.readFile('file.txt', (err, data) => {
  // Runs in thread pool
  console.log(data);
});
```

### Configure Thread Pool Size:

```javascript
// Set before any I/O operations
process.env.UV_THREADPOOL_SIZE = 8;
```

---

## Common Misconceptions

### ❌ "Node.js is single-threaded for everything"
**Reality:** JavaScript execution is single-threaded, but I/O operations use thread pool.

### ❌ "setTimeout(fn, 0) executes immediately"
**Reality:** It executes after current call stack and microtasks.

### ❌ "Node.js can't handle CPU-intensive tasks"
**Reality:** It can, but it blocks the event loop. Use Worker Threads for CPU-heavy tasks.

---

## Practical Example

```javascript
const fs = require('fs');

console.log('Start');

// Microtask
Promise.resolve().then(() => console.log('Promise 1'));

// Timer (Task queue)
setTimeout(() => console.log('Timeout 1'), 0);

// I/O operation (Thread pool)
fs.readFile('file.txt', () => {
  console.log('File read');
  
  // Another microtask
  Promise.resolve().then(() => console.log('Promise 2'));
  
  // setImmediate (Check phase)
  setImmediate(() => console.log('Immediate'));
});

setTimeout(() => console.log('Timeout 2'), 0);

console.log('End');

// Output:
// Start
// End
// Promise 1
// Timeout 1
// Timeout 2
// File read
// Promise 2
// Immediate
```

---

## Best Practices

✅ **Use async operations**: Avoid blocking the event loop  
✅ **Break CPU-intensive tasks**: Use `setImmediate()` or Worker Threads  
✅ **Handle errors**: Always handle async errors  
✅ **Understand execution order**: Know the difference between microtasks and tasks  

---

## Summary

- Node.js architecture: V8 + libuv + Node.js bindings
- Event loop enables non-blocking I/O
- Single-threaded JavaScript, but I/O uses thread pool
- Execution order: Call Stack → Microtasks → Tasks
- Event loop has 6 phases (timers, poll, check are key)
- Non-blocking code is the Node.js way!

**Next:** Learn about modules and the `require` system!
