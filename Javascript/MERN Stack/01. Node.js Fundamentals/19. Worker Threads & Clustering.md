# 19. Worker Threads & Clustering

## Why Worker Threads?

Node.js is **single-threaded** by default. CPU-intensive tasks block the event loop.

**Problem:**
```javascript
// This blocks everything!
app.get('/compute', (req, res) => {
  let result = 0;
  for (let i = 0; i < 10000000000; i++) {
    result += i;
  }
  res.json({ result });
});
// Other requests wait until this finishes!
```

**Solutions:**
1. **Worker Threads** - Use multiple threads
2. **Clustering** - Use multiple processes

---

## Worker Threads

Run JavaScript in parallel threads.

### Installation

```bash
# Built-in since Node.js 10.5.0
# No installation needed!
```

### Basic Usage

**worker.js:**
```javascript
const { parentPort } = require('worker_threads');

// Receive data from main thread
parentPort.on('message', (data) => {
  console.log('Worker received:', data);
  
  // Do heavy computation
  let result = 0;
  for (let i = 0; i < data.count; i++) {
    result += i;
  }
  
  // Send result back
  parentPort.postMessage({ result });
});
```

**main.js:**
```javascript
const { Worker } = require('worker_threads');

// Create worker
const worker = new Worker('./worker.js');

// Send data to worker
worker.postMessage({ count: 1000000000 });

// Receive data from worker
worker.on('message', (data) => {
  console.log('Main received:', data);
});

// Handle errors
worker.on('error', (err) => {
  console.error('Worker error:', err);
});

// Worker finished
worker.on('exit', (code) => {
  console.log(`Worker exited with code ${code}`);
});
```

---

## Inline Worker

```javascript
const { Worker } = require('worker_threads');

const workerCode = `
  const { parentPort } = require('worker_threads');
  
  parentPort.on('message', (num) => {
    const result = num * num;
    parentPort.postMessage(result);
  });
`;

const worker = new Worker(workerCode, { eval: true });

worker.postMessage(5);

worker.on('message', (result) => {
  console.log('Result:', result);  // 25
});
```

---

## Passing Data

```javascript
const { Worker } = require('worker_threads');

const worker = new Worker('./worker.js');

// Send different data types
worker.postMessage({ type: 'number', value: 42 });
worker.postMessage({ type: 'string', value: 'Hello' });
worker.postMessage({ type: 'array', value: [1, 2, 3] });
worker.postMessage({ type: 'object', value: { name: 'John' } });
```

---

## Worker Pool Pattern

```javascript
const { Worker } = require('worker_threads');

class WorkerPool {
  constructor(workerScript, poolSize) {
    this.workerScript = workerScript;
    this.poolSize = poolSize;
    this.workers = [];
    this.queue = [];
    
    // Create workers
    for (let i = 0; i < poolSize; i++) {
      this.workers.push(this.createWorker());
    }
  }
  
  createWorker() {
    const worker = new Worker(this.workerScript);
    worker.isBusy = false;
    
    worker.on('message', (result) => {
      worker.isBusy = false;
      worker.currentTask.resolve(result);
      this.processQueue();
    });
    
    worker.on('error', (err) => {
      worker.currentTask.reject(err);
    });
    
    return worker;
  }
  
  exec(data) {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject };
      this.queue.push(task);
      this.processQueue();
    });
  }
  
  processQueue() {
    if (this.queue.length === 0) return;
    
    // Find available worker
    const worker = this.workers.find(w => !w.isBusy);
    if (!worker) return;
    
    const task = this.queue.shift();
    worker.isBusy = true;
    worker.currentTask = task;
    worker.postMessage(task.data);
  }
}

// Usage
const pool = new WorkerPool('./worker.js', 4);

pool.exec({ count: 1000000 }).then(result => {
  console.log('Result 1:', result);
});

pool.exec({ count: 2000000 }).then(result => {
  console.log('Result 2:', result);
});
```

---

## Real Example: Image Processing

**worker.js:**
```javascript
const { parentPort } = require('worker_threads');
const sharp = require('sharp');

parentPort.on('message', async (data) => {
  try {
    // Resize image
    await sharp(data.input)
      .resize(data.width, data.height)
      .toFile(data.output);
    
    parentPort.postMessage({ success: true });
  } catch (err) {
    parentPort.postMessage({ success: false, error: err.message });
  }
});
```

**main.js:**
```javascript
const { Worker } = require('worker_threads');

function resizeImage(input, output, width, height) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./worker.js');
    
    worker.postMessage({ input, output, width, height });
    
    worker.on('message', (result) => {
      if (result.success) {
        resolve();
      } else {
        reject(new Error(result.error));
      }
    });
    
    worker.on('error', reject);
  });
}

// Process multiple images in parallel
const images = [
  { input: '1.jpg', output: 'thumb1.jpg', width: 200, height: 200 },
  { input: '2.jpg', output: 'thumb2.jpg', width: 200, height: 200 },
  { input: '3.jpg', output: 'thumb3.jpg', width: 200, height: 200 }
];

Promise.all(images.map(img => resizeImage(img.input, img.output, img.width, img.height)))
  .then(() => console.log('All images processed'))
  .catch(err => console.error('Error:', err));
```

---

## Clustering

Create multiple Node.js processes to handle more load.

### Basic Cluster

```javascript
const cluster = require('cluster');
const http = require('http');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} starting`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  // Worker died
  cluster.on('exit', (worker, code) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork();  // Restart
  });
  
} else {
  // Worker process
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end(`Worker ${process.pid} handled request`);
  }).listen(3000);
  
  console.log(`Worker ${process.pid} started`);
}
```

---

## Cluster with Express

```javascript
const cluster = require('cluster');
const express = require('express');
const os = require('os');

const numCPUs = os.cpus().length;

if (cluster.isMaster) {
  console.log(`Master process ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died. Starting new worker...`);
    cluster.fork();
  });
  
} else {
  const app = express();
  
  app.get('/', (req, res) => {
    res.send(`Handled by worker ${process.pid}`);
  });
  
  app.listen(3000, () => {
    console.log(`Worker ${process.pid} started on port 3000`);
  });
}
```

---

## Load Distribution

Cluster automatically distributes incoming connections:

```
            ┌─────────────┐
            │   Master    │
            └──────┬──────┘
                   │
         ┌─────────┼─────────┐
         │         │         │
    ┌────▼───┐ ┌──▼────┐ ┌──▼────┐
    │Worker 1│ │Worker 2│ │Worker 3│
    └────────┘ └────────┘ └────────┘
```

---

## Worker Communication

```javascript
const cluster = require('cluster');

if (cluster.isMaster) {
  const worker = cluster.fork();
  
  // Send message to worker
  worker.send({ cmd: 'start', data: 'Hello' });
  
  // Receive message from worker
  worker.on('message', (msg) => {
    console.log('Master received:', msg);
  });
  
} else {
  // Receive message from master
  process.on('message', (msg) => {
    console.log('Worker received:', msg);
    
    // Send message back to master
    process.send({ response: 'Got it!' });
  });
}
```

---

## Graceful Shutdown with Clustering

```javascript
const cluster = require('cluster');
const express = require('express');

if (cluster.isMaster) {
  const workers = [];
  
  for (let i = 0; i < 4; i++) {
    workers.push(cluster.fork());
  }
  
  // Graceful shutdown
  process.on('SIGTERM', () => {
    console.log('Master shutting down...');
    
    workers.forEach(worker => {
      worker.send('shutdown');
      worker.disconnect();
    });
    
    setTimeout(() => {
      workers.forEach(worker => worker.kill());
      process.exit(0);
    }, 10000);
  });
  
} else {
  const app = express();
  const server = app.listen(3000);
  
  process.on('message', (msg) => {
    if (msg === 'shutdown') {
      server.close(() => {
        console.log(`Worker ${process.pid} shut down`);
        process.exit(0);
      });
    }
  });
}
```

---

## Worker Threads vs Clustering

| Feature | Worker Threads | Clustering |
|---------|---------------|-----------|
| **Type** | Threads | Processes |
| **Memory** | Shared | Separate |
| **Communication** | Fast (shared memory) | IPC (slower) |
| **CPU Tasks** | ✅ Excellent | ❌ Not ideal |
| **I/O Tasks** | ⚠️ Not needed | ✅ Good |
| **Use Case** | Heavy computation | Scale web servers |

---

## When to Use What?

### Use Worker Threads:
- CPU-intensive calculations
- Image/video processing
- Data compression
- Encryption/hashing
- Large file parsing

### Use Clustering:
- Scale web servers
- Handle more concurrent requests
- Utilize all CPU cores for I/O
- High-availability applications

---

## PM2 (Production Clustering)

```bash
npm install -g pm2
```

**app.js:**
```javascript
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello from PM2');
});

app.listen(3000);
```

Run with PM2:
```bash
# Start with cluster mode (4 instances)
pm2 start app.js -i 4

# Or use max CPUs
pm2 start app.js -i max

# List processes
pm2 list

# Monitor
pm2 monit

# Stop
pm2 stop app

# Restart
pm2 restart app

# Delete
pm2 delete app
```

---

## Best Practices

✅ **Use worker threads for CPU tasks**: Heavy computations  
✅ **Use clustering for web servers**: Handle more requests  
✅ **Handle worker errors**: Restart failed workers  
✅ **Limit worker count**: Match CPU cores  
✅ **Use PM2 in production**: Better management  
❌ **Don't share state**: Workers have separate memory  
❌ **Don't create too many workers**: Overhead  

---

## Summary

**Worker Threads:**
- Use multiple threads within one process
- Good for CPU-intensive tasks
- Share memory (faster communication)
- `parentPort.postMessage()` for communication

**Clustering:**
- Use multiple processes
- Good for scaling web servers
- Separate memory (isolated)
- Automatic load balancing
- Auto-restart failed workers

**Tools:**
- Native `cluster` module
- **PM2** for production (recommended)

**Next:** Learn about performance optimization and best practices!
