# 18. Process & Child Processes

## What is the Process Object?

**process** is a global object that provides information about the current Node.js process.

```javascript
// No need to require, it's global
console.log(process.pid);  // Process ID
console.log(process.version);  // Node.js version
console.log(process.platform);  // Operating system
```

---

## Process Information

```javascript
// Process ID
console.log('PID:', process.pid);

// Node.js version
console.log('Version:', process.version);  // v18.12.0

// Platform
console.log('Platform:', process.platform);  // linux, darwin, win32

// Architecture
console.log('Architecture:', process.arch);  // x64, arm

// Current directory
console.log('CWD:', process.cwd());

// Uptime (seconds)
console.log('Uptime:', process.uptime());

// Memory usage
console.log('Memory:', process.memoryUsage());
// {
//   rss: 24576000,        // Resident Set Size
//   heapTotal: 6385664,   // Total heap
//   heapUsed: 4079648,    // Used heap
//   external: 1234567     // C++ objects
// }
```

---

## Command Line Arguments

```javascript
// process.argv - array of command line arguments
console.log(process.argv);

// Run: node app.js arg1 arg2 arg3
// Output:
// [
//   '/usr/local/bin/node',     // Node executable
//   '/path/to/app.js',         // Script file
//   'arg1',                    // Arguments start here
//   'arg2',
//   'arg3'
// ]

// Get actual arguments (skip first 2)
const args = process.argv.slice(2);
console.log('Arguments:', args);
```

### Example: CLI Calculator

```javascript
// calculator.js
const [num1, operator, num2] = process.argv.slice(2);

const a = parseFloat(num1);
const b = parseFloat(num2);

switch (operator) {
  case '+':
    console.log(a + b);
    break;
  case '-':
    console.log(a - b);
    break;
  case '*':
    console.log(a * b);
    break;
  case '/':
    console.log(a / b);
    break;
  default:
    console.log('Invalid operator');
}

// Run: node calculator.js 10 + 5
// Output: 15
```

---

## Environment Variables

```javascript
// Access environment variables
console.log(process.env.NODE_ENV);
console.log(process.env.PORT);
console.log(process.env.HOME);  // User home directory

// Set environment variable (affects only current process)
process.env.MY_VAR = 'value';
```

---

## Exit Process

```javascript
// Exit with success (0)
process.exit(0);

// Exit with error (1)
process.exit(1);

// Example: Exit on error
if (!process.env.API_KEY) {
  console.error('API_KEY not found!');
  process.exit(1);
}
```

---

## Process Events

```javascript
// Before exit
process.on('exit', (code) => {
  console.log(`Process exiting with code: ${code}`);
  // Only synchronous code here!
});

// Uncaught exception
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception:', err);
  process.exit(1);
});

// Unhandled promise rejection
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', reason);
  process.exit(1);
});

// SIGINT (Ctrl+C)
process.on('SIGINT', () => {
  console.log('Received SIGINT, gracefully shutting down...');
  // Cleanup code
  process.exit(0);
});

// SIGTERM (kill command)
process.on('SIGTERM', () => {
  console.log('Received SIGTERM, shutting down...');
  process.exit(0);
});
```

---

## Graceful Shutdown

```javascript
const express = require('express');
const app = express();

const server = app.listen(3000);

// Graceful shutdown
function shutdown() {
  console.log('Shutting down gracefully...');
  
  server.close(() => {
    console.log('HTTP server closed');
    // Close database connections, etc.
    process.exit(0);
  });
  
  // Force shutdown after 10 seconds
  setTimeout(() => {
    console.error('Forcing shutdown');
    process.exit(1);
  }, 10000);
}

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);
```

---

## Standard Input/Output

### Standard Output (stdout)

```javascript
// Same as console.log
process.stdout.write('Hello World\n');

// No automatic newline
process.stdout.write('Hello ');
process.stdout.write('World\n');
```

### Standard Error (stderr)

```javascript
// Error output
process.stderr.write('Error occurred!\n');

// Same as console.error
console.error('Error!');
```

### Standard Input (stdin)

```javascript
// Read from terminal
process.stdin.on('data', (data) => {
  console.log('You typed:', data.toString().trim());
});

// Example: Interactive input
console.log('What is your name?');
process.stdin.once('data', (data) => {
  const name = data.toString().trim();
  console.log(`Hello ${name}!`);
  process.exit(0);
});
```

---

## Child Processes

Run external commands or scripts from Node.js.

```javascript
const { exec, spawn, fork } = require('child_process');
```

---

## exec() - Run Shell Commands

```javascript
const { exec } = require('child_process');

// Run command
exec('ls -la', (error, stdout, stderr) => {
  if (error) {
    console.error('Error:', error);
    return;
  }
  
  console.log('Output:', stdout);
  
  if (stderr) {
    console.error('Errors:', stderr);
  }
});
```

### Example: Git Commands

```javascript
const { exec } = require('child_process');

exec('git status', (error, stdout) => {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  console.log(stdout);
});

// Git log
exec('git log --oneline -5', (error, stdout) => {
  if (error) return;
  console.log('Recent commits:');
  console.log(stdout);
});
```

---

## spawn() - Stream Output

Better for long-running processes:

```javascript
const { spawn } = require('child_process');

// Spawn process
const ls = spawn('ls', ['-la']);

// Listen to stdout
ls.stdout.on('data', (data) => {
  console.log(`Output: ${data}`);
});

// Listen to stderr
ls.stderr.on('data', (data) => {
  console.error(`Error: ${data}`);
});

// Process exit
ls.on('close', (code) => {
  console.log(`Process exited with code ${code}`);
});
```

### Example: Run Python Script

```javascript
const { spawn } = require('child_process');

const python = spawn('python3', ['script.py', 'arg1', 'arg2']);

python.stdout.on('data', (data) => {
  console.log(`Python output: ${data}`);
});

python.stderr.on('data', (data) => {
  console.error(`Python error: ${data}`);
});

python.on('close', (code) => {
  console.log(`Python script exited with code ${code}`);
});
```

---

## fork() - Run Node.js Scripts

Creates a new Node.js process:

**worker.js:**
```javascript
// worker.js
process.on('message', (msg) => {
  console.log('Worker received:', msg);
  
  // Do heavy computation
  const result = msg.num * 2;
  
  // Send result back
  process.send({ result });
});
```

**main.js:**
```javascript
const { fork } = require('child_process');

// Fork worker
const worker = fork('worker.js');

// Send message to worker
worker.send({ num: 10 });

// Receive message from worker
worker.on('message', (msg) => {
  console.log('Main received:', msg);  // { result: 20 }
});
```

---

## exec vs spawn vs fork

| Method | Use Case | Output | Best For |
|--------|----------|--------|----------|
| **exec()** | Shell commands | Buffered | Short commands (ls, git) |
| **spawn()** | External programs | Streaming | Long-running processes |
| **fork()** | Node.js scripts | IPC | CPU-intensive tasks |

---

## Practical Examples

### Example 1: File Compression

```javascript
const { exec } = require('child_process');

function compressFile(filename) {
  exec(`gzip ${filename}`, (error, stdout, stderr) => {
    if (error) {
      console.error('Compression failed:', error.message);
      return;
    }
    console.log(`${filename} compressed successfully`);
  });
}

compressFile('large-file.txt');
```

### Example 2: Image Processing

```javascript
const { spawn } = require('child_process');

function resizeImage(input, output, width, height) {
  const convert = spawn('convert', [
    input,
    '-resize', `${width}x${height}`,
    output
  ]);
  
  convert.on('close', (code) => {
    if (code === 0) {
      console.log('Image resized successfully');
    } else {
      console.error('Image resize failed');
    }
  });
}

resizeImage('photo.jpg', 'thumbnail.jpg', 200, 200);
```

### Example 3: Parallel Processing

```javascript
const { fork } = require('child_process');

function processInParallel(data) {
  const workers = [];
  
  // Create 4 workers
  for (let i = 0; i < 4; i++) {
    const worker = fork('worker.js');
    workers.push(worker);
  }
  
  // Distribute work
  data.forEach((item, index) => {
    const worker = workers[index % 4];
    worker.send(item);
  });
  
  // Collect results
  workers.forEach(worker => {
    worker.on('message', (result) => {
      console.log('Result:', result);
    });
  });
}
```

---

## execFile() - Run Executable

```javascript
const { execFile } = require('child_process');

// Run executable directly (no shell)
execFile('node', ['--version'], (error, stdout) => {
  if (error) throw error;
  console.log('Node version:', stdout);
});
```

---

## Promise-Based Execution

```javascript
const util = require('util');
const exec = util.promisify(require('child_process').exec);

async function runCommand() {
  try {
    const { stdout, stderr } = await exec('ls -la');
    console.log('Output:', stdout);
  } catch (err) {
    console.error('Error:', err);
  }
}

runCommand();
```

---

## Best Practices

✅ **Handle errors**: Always check error parameter  
✅ **Use spawn for large output**: Avoids buffer overflow  
✅ **Validate input**: Prevent command injection  
✅ **Set timeouts**: Prevent hanging processes  
✅ **Clean up**: Kill processes when done  
✅ **Use promises**: Cleaner async code  
❌ **Don't trust user input**: Sanitize before exec  
❌ **Don't ignore stderr**: Check for errors  

---

## Security Warning

```javascript
// ❌ Dangerous (command injection)
const userInput = req.body.filename;
exec(`rm ${userInput}`);  // User could input: file.txt; rm -rf /

// ✅ Safe (use spawn with array)
const { spawn } = require('child_process');
spawn('rm', [userInput]);
```

---

## Summary

**process Object:**
- `process.argv` - Command line arguments
- `process.env` - Environment variables
- `process.exit()` - Exit process
- `process.cwd()` - Current directory
- `process.memoryUsage()` - Memory info

**Child Processes:**
- **exec()** - Run shell commands (buffered output)
- **spawn()** - Run programs (streaming output)
- **fork()** - Run Node.js scripts (IPC communication)
- **execFile()** - Run executables directly

**Use Cases:**
- Run shell commands (git, npm)
- Execute scripts (Python, Ruby)
- Process images/videos
- Parallel processing
- CPU-intensive tasks

**Next:** Learn about worker threads!
