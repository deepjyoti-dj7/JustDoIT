# useContext Hook

## What is useContext?

`useContext` is a Hook that lets you read and subscribe to **Context** from your component.

Context provides a way to pass data through the component tree without manually passing props at every level.

---

## Basic Syntax

```jsx
const value = useContext(SomeContext);
```

---

## Creating and Using Context

### 1. Create Context

```jsx
import { createContext } from 'react';

// Create context with default value
const ThemeContext = createContext('light');
```

### 2. Provide Context Value

```jsx
function App() {
  const [theme, setTheme] = useState('dark');

  return (
    <ThemeContext.Provider value={theme}>
      <Toolbar />
    </ThemeContext.Provider>
  );
}
```

### 3. Consume Context with useContext

```jsx
import { useContext } from 'react';

function Button() {
  const theme = useContext(ThemeContext);
  
  return (
    <button className={`btn-${theme}`}>
      Click me
    </button>
  );
}
```

---

## Complete Example: Theme Context

```jsx
import { createContext, useContext, useState } from 'react';

// 1. Create Context
const ThemeContext = createContext();

// 2. Create Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  const value = {
    theme,
    toggleTheme
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Create Custom Hook (optional but recommended)
function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  
  return context;
}

// 4. Use in Components
function App() {
  return (
    <ThemeProvider>
      <Header />
      <MainContent />
      <Footer />
    </ThemeProvider>
  );
}

function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header className={theme}>
      <h1>My App</h1>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  );
}

function MainContent() {
  const { theme } = useTheme();
  
  return (
    <main className={theme}>
      <p>Current theme: {theme}</p>
    </main>
  );
}
```

---

## Common Use Cases

### 1. Authentication Context

```jsx
import { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);

  const login = async (email, password) => {
    setLoading(true);
    try {
      const response = await loginAPI(email, password);
      setUser(response.user);
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };

  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

// Usage
function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();

  if (loading) return <LoadingSpinner />;
  if (!isAuthenticated) return <Navigate to="/login" />;
  
  return children;
}

function UserProfile() {
  const { user, logout } = useAuth();
  
  return (
    <div>
      <h2>Welcome, {user.name}!</h2>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

### 2. Language/Localization Context

```jsx
const LanguageContext = createContext();

function LanguageProvider({ children }) {
  const [language, setLanguage] = useState('en');

  const translations = {
    en: {
      welcome: 'Welcome',
      goodbye: 'Goodbye'
    },
    es: {
      welcome: 'Bienvenido',
      goodbye: 'Adiós'
    }
  };

  const t = (key) => translations[language][key] || key;

  const value = {
    language,
    setLanguage,
    t
  };

  return (
    <LanguageContext.Provider value={value}>
      {children}
    </LanguageContext.Provider>
  );
}

function useLanguage() {
  return useContext(LanguageContext);
}

// Usage
function Greeting() {
  const { t, language, setLanguage } = useLanguage();
  
  return (
    <div>
      <h1>{t('welcome')}</h1>
      <select value={language} onChange={(e) => setLanguage(e.target.value)}>
        <option value="en">English</option>
        <option value="es">Español</option>
      </select>
    </div>
  );
}
```

### 3. Shopping Cart Context

```jsx
const CartContext = createContext();

function CartProvider({ children }) {
  const [items, setItems] = useState([]);

  const addItem = (product) => {
    setItems(prev => {
      const existing = prev.find(item => item.id === product.id);
      
      if (existing) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      
      return [...prev, { ...product, quantity: 1 }];
    });
  };

  const removeItem = (productId) => {
    setItems(prev => prev.filter(item => item.id !== productId));
  };

  const updateQuantity = (productId, quantity) => {
    setItems(prev =>
      prev.map(item =>
        item.id === productId ? { ...item, quantity } : item
      )
    );
  };

  const clearCart = () => setItems([]);

  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);

  const value = {
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    total,
    itemCount
  };

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

function useCart() {
  return useContext(CartContext);
}

// Usage
function ProductCard({ product }) {
  const { addItem } = useCart();
  
  return (
    <div>
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button onClick={() => addItem(product)}>Add to Cart</button>
    </div>
  );
}

function CartSummary() {
  const { items, total, itemCount } = useCart();
  
  return (
    <div>
      <p>Items: {itemCount}</p>
      <p>Total: ${total.toFixed(2)}</p>
    </div>
  );
}
```

---

## Multiple Contexts

You can use multiple contexts in a single component.

```jsx
function Component() {
  const theme = useContext(ThemeContext);
  const user = useContext(AuthContext);
  const language = useContext(LanguageContext);
  
  return <div className={theme}>{user.name}</div>;
}

// Or nest providers
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <MainApp />
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}
```

---

## Context with useReducer

Combine Context and useReducer for global state management.

```jsx
const TodoContext = createContext();

const initialState = {
  todos: [],
  filter: 'all'
};

function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload
      };
    
    default:
      return state;
  }
}

function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  const value = {
    todos: state.todos,
    filter: state.filter,
    dispatch
  };

  return (
    <TodoContext.Provider value={value}>
      {children}
    </TodoContext.Provider>
  );
}

function useTodos() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error('useTodos must be used within TodoProvider');
  }
  return context;
}

// Usage
function TodoList() {
  const { todos, dispatch } = useTodos();
  
  const addTodo = (text) => {
    dispatch({
      type: 'ADD_TODO',
      payload: { id: Date.now(), text, completed: false }
    });
  };
  
  return (
    <div>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </div>
  );
}
```

---

## Performance Considerations

### Problem: Unnecessary Re-renders

```jsx
// ❌ Every value change re-renders all consumers
function Provider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  const value = { user, theme, setUser, setTheme };
  
  // New object on every render!
  return <Context.Provider value={value}>{children}</Context.Provider>;
}
```

### Solution 1: useMemo

```jsx
// ✅ Memoize value object
function Provider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  const value = useMemo(
    () => ({ user, theme, setUser, setTheme }),
    [user, theme]
  );
  
  return <Context.Provider value={value}>{children}</Context.Provider>;
}
```

### Solution 2: Split Contexts

```jsx
// ✅ Separate frequently-changing data
const UserContext = createContext();
const ThemeContext = createContext();

function Providers({ children }) {
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}

// Components only re-render when their specific context changes
```

---

## Avoiding Prop Drilling

### Without Context (Prop Drilling)

```jsx
// ❌ Passing props through many levels
function App() {
  const [user, setUser] = useState(null);
  return <Page user={user} setUser={setUser} />;
}

function Page({ user, setUser }) {
  return <Layout user={user} setUser={setUser} />;
}

function Layout({ user, setUser }) {
  return <Sidebar user={user} setUser={setUser} />;
}

function Sidebar({ user, setUser }) {
  return <UserMenu user={user} setUser={setUser} />;
}
```

### With Context

```jsx
// ✅ Direct access via context
function App() {
  return (
    <UserProvider>
      <Page />
    </UserProvider>
  );
}

function UserMenu() {
  const { user, setUser } = useUser();
  return <div>{user.name}</div>;
}
```

---

## Interview Questions

### Q1: What is useContext?
**Answer**: useContext is a Hook that reads a context value and subscribes to its changes. It provides a way to pass data through the component tree without prop drilling.

### Q2: When should you use Context?
**Answer**: Use Context when:
- Data is needed by many components at different levels
- Avoiding prop drilling through multiple layers
- Global state (theme, language, auth)
- Not changing frequently (performance consideration)

Don't use Context for:
- All state management (consider libraries for complex state)
- Frequently changing data (causes re-renders)
- Local component state

### Q3: How do you prevent unnecessary re-renders with Context?
**Answer**:
1. **Memoize value object** with useMemo
2. **Split contexts** for different data
3. **Move state down** closer to where it's used
4. **Use composition** to avoid re-rendering children

### Q4: What's the difference between Context and props?
**Answer**:
- **Props**: Explicit, passed down one level, better for component reusability
- **Context**: Implicit, accessible anywhere in tree, better for global data

Props are preferred for most cases. Use Context to avoid deep prop drilling.

### Q5: Can you have multiple providers for the same context?
**Answer**: Yes. Nested providers override outer providers for their subtree:

```jsx
<ThemeContext.Provider value="light">
  <Component /> // Uses "light"
  <ThemeContext.Provider value="dark">
    <Component /> // Uses "dark"
  </ThemeContext.Provider>
</ThemeContext.Provider>
```

### Q6: What happens if you use useContext without a Provider?
**Answer**: It returns the default value passed to `createContext()`. If no default was provided, it returns `undefined`.

### Q7: How is useContext different from Consumer?
**Answer**: useContext is simpler and more readable:

```jsx
// Old way: Consumer
<ThemeContext.Consumer>
  {theme => <div className={theme}>Content</div>}
</ThemeContext.Consumer>

// New way: useContext
const theme = useContext(ThemeContext);
<div className={theme}>Content</div>
```

---

## Best Practices

1. **Create custom hooks** for each context (`useAuth`, `useTheme`)
2. **Provide default values** in createContext
3. **Validate context usage** - throw error if used outside provider
4. **Memoize context value** to prevent unnecessary re-renders
5. **Split large contexts** into smaller, focused ones
6. **Keep context close** to where it's needed
7. **Don't overuse** - props are often better
8. **Document context** - what it provides and when to use
9. **Use TypeScript** for type safety
10. **Consider alternatives** - Redux, Zustand for complex state

---

## Summary

- **useContext** reads context values without prop drilling
- **createContext** creates a context
- **Provider** supplies context value to tree
- Create **custom hooks** for better DX
- **Memoize values** to prevent re-renders
- **Split contexts** for better performance
- Use for **global/shared** data, not all state
- Context + useReducer = simple state management
- **Validate** context usage with error checks
- **Don't overuse** - props are often clearer

