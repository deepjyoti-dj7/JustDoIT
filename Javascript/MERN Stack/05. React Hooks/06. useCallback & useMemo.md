# useCallback & useMemo Hooks

## Performance Optimization Hooks

**useCallback** and **useMemo** are performance optimization hooks that help avoid unnecessary re-calculations and re-renders.

---

## useMemo

`useMemo` memoizes a **computed value** and only recomputes when dependencies change.

### Syntax

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### Basic Example

```jsx
import { useMemo, useState } from 'react';

function ExpensiveComponent({ items }) {
  const [count, setCount] = useState(0);

  // ❌ Without useMemo - runs on every render
  const expensiveCalculation = items.reduce((sum, item) => sum + item.value, 0);

  // ✅ With useMemo - only recalculates when items change
  const total = useMemo(() => {
    console.log('Calculating total...');
    return items.reduce((sum, item) => sum + item.value, 0);
  }, [items]);

  return (
    <div>
      <p>Total: {total}</p>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </div>
  );
}
```

### When to Use useMemo

```jsx
// ✅ Use for expensive calculations
const sortedList = useMemo(() => {
  return items.sort((a, b) => a.value - b.value);
}, [items]);

// ✅ Use for filtered/mapped large arrays
const filteredData = useMemo(() => {
  return data.filter(item => item.active);
}, [data]);

// ❌ Don't use for simple calculations
const sum = useMemo(() => a + b, [a, b]); // Overkill

// ❌ Don't use when dependencies always change
const random = useMemo(() => Math.random(), [Date.now()]); // Pointless
```

---

## useCallback

`useCallback` memoizes a **function** and only recreates it when dependencies change.

### Syntax

```jsx
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

### Basic Example

```jsx
import { useCallback, useState } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  const [value, setValue] = useState(0);

  // ❌ Without useCallback - new function on every render
  const handleClick = () => {
    console.log('Clicked:', value);
  };

  // ✅ With useCallback - same function unless value changes
  const handleClickMemo = useCallback(() => {
    console.log('Clicked:', value);
  }, [value]);

  return (
    <div>
      <Child onClick={handleClickMemo} />
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
    </div>
  );
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click Me</button>;
});
```

### When to Use useCallback

```jsx
// ✅ Passing callbacks to memoized child components
<MemoizedChild onSubmit={handleSubmit} />

// ✅ As dependency in other hooks
useEffect(() => {
  fetchData();
}, [fetchData]); // fetchData should be useCallback

// ✅ In custom hooks
function useCustomHook(callback) {
  useEffect(() => {
    callback();
  }, [callback]); // callback should be useCallback
}

// ❌ Don't use without React.memo child
<RegularChild onClick={handleClick} /> // Won't prevent re-renders

// ❌ Don't use when not passed as prop
const handler = useCallback(() => {...}, []); // Stored only locally
```

---

## useMemo vs useCallback

```jsx
// useMemo - returns memoized VALUE
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

// useCallback - returns memoized FUNCTION
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);

// useCallback is equivalent to:
const memoizedCallback = useMemo(() => () => doSomething(a, b), [a, b]);
```

| Hook | Returns | Use Case |
|------|---------|----------|
| **useMemo** | Memoized value | Expensive calculations, filtered/sorted data |
| **useCallback** | Memoized function | Event handlers, callbacks passed to children |

---

## Complete Example: Search & Filter

```jsx
import { useState, useMemo, useCallback, memo } from 'react';

function ProductList({ products }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name');
  const [category, setCategory] = useState('all');

  // useMemo for filtered and sorted data
  const filteredProducts = useMemo(() => {
    console.log('Filtering products...');
    
    let filtered = products;

    // Filter by category
    if (category !== 'all') {
      filtered = filtered.filter(p => p.category === category);
    }

    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(p =>
        p.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    // Sort
    filtered = [...filtered].sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      if (sortBy === 'price') {
        return a.price - b.price;
      }
      return 0;
    });

    return filtered;
  }, [products, searchTerm, category, sortBy]);

  // useMemo for statistics
  const stats = useMemo(() => {
    console.log('Calculating stats...');
    return {
      total: filteredProducts.length,
      avgPrice: filteredProducts.reduce((sum, p) => sum + p.price, 0) / filteredProducts.length || 0
    };
  }, [filteredProducts]);

  // useCallback for event handlers
  const handleSearch = useCallback((e) => {
    setSearchTerm(e.target.value);
  }, []);

  const handleCategoryChange = useCallback((e) => {
    setCategory(e.target.value);
  }, []);

  const handleSortChange = useCallback((e) => {
    setSortBy(e.target.value);
  }, []);

  const handleProductClick = useCallback((productId) => {
    console.log('Product clicked:', productId);
    // Navigate or show details
  }, []);

  return (
    <div>
      <SearchBar
        value={searchTerm}
        onChange={handleSearch}
      />
      
      <Filters
        category={category}
        sortBy={sortBy}
        onCategoryChange={handleCategoryChange}
        onSortChange={handleSortChange}
      />

      <Stats total={stats.total} avgPrice={stats.avgPrice} />

      <ProductGrid
        products={filteredProducts}
        onProductClick={handleProductClick}
      />
    </div>
  );
}

// Memoized child components
const SearchBar = memo(({ value, onChange }) => {
  console.log('SearchBar rendered');
  return (
    <input
      type="text"
      value={value}
      onChange={onChange}
      placeholder="Search products..."
    />
  );
});

const Filters = memo(({ category, sortBy, onCategoryChange, onSortChange }) => {
  console.log('Filters rendered');
  return (
    <div>
      <select value={category} onChange={onCategoryChange}>
        <option value="all">All Categories</option>
        <option value="electronics">Electronics</option>
        <option value="clothing">Clothing</option>
      </select>

      <select value={sortBy} onChange={onSortChange}>
        <option value="name">Name</option>
        <option value="price">Price</option>
      </select>
    </div>
  );
});

const Stats = memo(({ total, avgPrice }) => {
  console.log('Stats rendered');
  return (
    <div>
      <p>Total: {total}</p>
      <p>Average Price: ${avgPrice.toFixed(2)}</p>
    </div>
  );
});

const ProductGrid = memo(({ products, onProductClick }) => {
  console.log('ProductGrid rendered');
  return (
    <div className="grid">
      {products.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onClick={onProductClick}
        />
      ))}
    </div>
  );
});

const ProductCard = memo(({ product, onClick }) => {
  return (
    <div onClick={() => onClick(product.id)}>
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  );
});
```

---

## React.memo

`React.memo` prevents component re-renders if props haven't changed.

### Basic Usage

```jsx
// Without memo - re-renders every time parent renders
function Child({ name }) {
  console.log('Child rendered');
  return <div>{name}</div>;
}

// With memo - only re-renders if name changes
const Child = React.memo(function Child({ name }) {
  console.log('Child rendered');
  return <div>{name}</div>;
});
```

### Custom Comparison

```jsx
const Child = React.memo(
  function Child({ user }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip render)
    return prevProps.user.id === nextProps.user.id;
  }
);
```

---

## Combining All Three

```jsx
import { useState, useMemo, useCallback, memo } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');

  // useMemo for filtered todos
  const filteredTodos = useMemo(() => {
    if (filter === 'active') return todos.filter(t => !t.completed);
    if (filter === 'completed') return todos.filter(t => t.completed);
    return todos;
  }, [todos, filter]);

  // useCallback for event handlers
  const addTodo = useCallback((text) => {
    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }]);
  }, []);

  const toggleTodo = useCallback((id) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  }, []);

  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []);

  return (
    <div>
      <TodoInput onAdd={addTodo} />
      <FilterButtons filter={filter} setFilter={setFilter} />
      <TodoList
        todos={filteredTodos}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
      />
    </div>
  );
}

// Memoized components with memoized callbacks
const TodoInput = memo(({ onAdd }) => {
  const [text, setText] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      onAdd(text);
      setText('');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button type="submit">Add</button>
    </form>
  );
});

const TodoList = memo(({ todos, onToggle, onDelete }) => {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        />
      ))}
    </ul>
  );
});

const TodoItem = memo(({ todo, onToggle, onDelete }) => {
  return (
    <li>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
        {todo.text}
      </span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
});
```

---

## Common Pitfalls

### 1. Dependencies Array

```jsx
// ❌ Missing dependencies
const memoized = useMemo(() => {
  return items.filter(item => item.category === category);
}, [items]); // Missing 'category'!

// ✅ All dependencies included
const memoized = useMemo(() => {
  return items.filter(item => item.category === category);
}, [items, category]);
```

### 2. Object/Array Dependencies

```jsx
// ❌ New object on every render
function Parent() {
  const config = { theme: 'dark' }; // New object!
  return <Child config={config} />;
}

// ✅ Memoize object
function Parent() {
  const config = useMemo(() => ({ theme: 'dark' }), []);
  return <Child config={config} />;
}
```

### 3. Premature Optimization

```jsx
// ❌ Overusing - adds overhead
const sum = useCallback(() => a + b, [a, b]); // Too simple
const name = useMemo(() => firstName + ' ' + lastName, [firstName, lastName]); // Unnecessary

// ✅ Only use for expensive operations
const sortedData = useMemo(() => {
  return hugeArray.sort((a, b) => a.value - b.value);
}, [hugeArray]);
```

---

## Interview Questions

### Q1: What's the difference between useMemo and useCallback?
**Answer**:
- **useMemo**: Returns memoized **value** from a function
- **useCallback**: Returns memoized **function**

`useCallback(fn, deps)` = `useMemo(() => fn, deps)`

### Q2: When should you use useMemo?
**Answer**: Use when:
- Expensive calculations (sorting, filtering large arrays)
- Avoiding re-creating objects/arrays on every render
- Passing objects to memoized child components
- Performance profiling shows bottleneck

Don't use for simple calculations - adds overhead.

### Q3: When should you use useCallback?
**Answer**: Use when:
- Passing callbacks to memoized (`React.memo`) children
- Function is a dependency in useEffect/useMemo
- Creating functions in custom hooks

Don't use if callback isn't passed to memoized components.

### Q4: What is React.memo?
**Answer**: React.memo is a higher-order component that memoizes component rendering. Component only re-renders if props change (shallow comparison).

```jsx
const MemoizedComponent = React.memo(Component);
```

Works with useCallback/useMemo to prevent unnecessary re-renders.

### Q5: Can you use useMemo/useCallback without dependencies?
**Answer**: Yes, with empty array `[]`:

```jsx
const value = useMemo(() => expensiveCalc(), []); // Runs once
const callback = useCallback(() => doSomething(), []); // Created once
```

Similar to storing in a ref - value never updates.

### Q6: What are the performance costs of these hooks?
**Answer**: useMemo/useCallback have overhead:
- Store previous values in memory
- Check dependencies on each render
- Only beneficial when:
  - Calculation is expensive
  - Preventing re-renders of large child trees

Profile before optimizing!

### Q7: How do you debug useMemo/useCallback?
**Answer**:
- Add console.logs inside functions
- Use React DevTools Profiler
- Check dependency array with ESLint rules
- Verify memoized components with `React.memo`

---

## Best Practices

1. **Don't optimize prematurely** - measure first
2. **Use ESLint rules** - `exhaustive-deps` warns about missing dependencies
3. **Combine with React.memo** - useCallback only helps with memoized children
4. **Keep calculations pure** - no side effects in useMemo
5. **Don't memoize everything** - has overhead
6. **Use for expensive operations** - sorting, filtering, complex calculations
7. **Memoize objects/arrays** passed to memoized children
8. **Profile with React DevTools** - see actual impact
9. **Consider alternatives** - moving state down, composition
10. **Document why** - comment why optimization is needed

---

## When NOT to Use

```jsx
// ❌ Simple calculations
const sum = useMemo(() => a + b, [a, b]);

// ❌ Not expensive
const fullName = useMemo(() => `${first} ${last}`, [first, last]);

// ❌ Always different dependencies
const random = useMemo(() => Math.random(), [Date.now()]);

// ❌ Callback not passed to memoized component
const handler = useCallback(() => console.log('hi'), []);
return <div onClick={handler}>Click</div>; // div not memoized

// ✅ Better alternatives
const sum = a + b; // Just calculate
const fullName = `${first} ${last}`; // Simple string
const handler = () => console.log('hi'); // No memo needed
```

---

## Summary

- **useMemo**: Memoize **values** - expensive calculations
- **useCallback**: Memoize **functions** - callbacks to children
- **React.memo**: Memoize **components** - prevent re-renders
- Use **together** for maximum optimization
- Don't **overuse** - has overhead
- Always include **dependencies** correctly
- **Profile first** - measure actual impact
- Focus on **expensive operations**
- ESLint helps catch **missing dependencies**
- **Document** why optimization is needed

