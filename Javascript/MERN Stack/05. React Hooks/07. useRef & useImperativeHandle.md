# 11. useRef Hook

# useRef & useImperativeHandle Hooks

## useRef Hook

`useRef` returns a mutable ref object whose `.current` property persists across renders.

---

## Basic Syntax

```jsx
const refContainer = useRef(initialValue);
```

**Returns**: Object with `.current` property initialized to `initialValue`

---

## Use Case 1: Accessing DOM Elements

### Basic DOM Access

```jsx
import { useRef } from 'react';

function TextInput() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

### Form Example

```jsx
function LoginForm() {
  const emailRef = useRef(null);
  const passwordRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    
    const email = emailRef.current.value;
    const password = passwordRef.current.value;
    
    console.log({ email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={emailRef}
        type="email"
        placeholder="Email"
      />
      <input
        ref={passwordRef}
        type="password"
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

---

## Use Case 2: Storing Mutable Values

Unlike state, **updating a ref doesn't trigger re-renders**.

### Counter Without Re-renders

```jsx
function RenderCounter() {
  const renderCount = useRef(0);

  // Increments on every render, but doesn't cause re-render
  renderCount.current++;

  return <div>Renders: {renderCount.current}</div>;
}
```

### Previous Value

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef();

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  const prevCount = prevCountRef.current;

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

## Use Case 3: Timers and Intervals

### Clearable Timer

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    if (intervalRef.current !== null) return; // Already running

    intervalRef.current = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const resetTimer = () => {
    stopTimer();
    setSeconds(0);
  };

  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return (
    <div>
      <p>Seconds: {seconds}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
      <button onClick={resetTimer}>Reset</button>
    </div>
  );
}
```

---

## Use Case 4: Debouncing with useRef

```jsx
function SearchInput() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const debounceTimerRef = useRef(null);

  const handleSearch = (value) => {
    setQuery(value);

    // Clear previous timer
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    // Set new timer
    debounceTimerRef.current = setTimeout(() => {
      // Perform search
      fetch(`/api/search?q=${value}`)
        .then(res => res.json())
        .then(data => setResults(data));
    }, 500);
  };

  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Use Case 5: Callback Refs

Dynamic refs using callback functions.

```jsx
function MeasureElement() {
  const [height, setHeight] = useState(0);

  const measuredRef = useCallback(node => {
    if (node !== null) {
      setHeight(node.getBoundingClientRect().height);
    }
  }, []);

  return (
    <div>
      <div ref={measuredRef}>
        <h1>Hello, world</h1>
        <p>This content will be measured</p>
      </div>
      <p>Height: {height}px</p>
    </div>
  );
}
```

---

## useRef vs useState

| Feature | useRef | useState |
|---------|--------|----------|
| Triggers re-render | ❌ No | ✅ Yes |
| Persists across renders | ✅ Yes | ✅ Yes |
| Mutable | ✅ Yes | ❌ No (immutable) |
| Use case | DOM access, timers, mutable values | UI state, re-rendering |

```jsx
// useState - triggers re-render
const [count, setCount] = useState(0);
setCount(1); // Component re-renders

// useRef - no re-render
const countRef = useRef(0);
countRef.current = 1; // No re-render
```

---

## useImperativeHandle Hook

`useImperativeHandle` customizes the instance value exposed to parent components when using `ref`.

### Basic Syntax

```jsx
useImperativeHandle(ref, createHandle, [deps]);
```

---

## Why useImperativeHandle?

By default, parent components can access all DOM methods when using ref. useImperativeHandle **restricts** what's exposed.

### Without useImperativeHandle

```jsx
function Parent() {
  const inputRef = useRef();

  useEffect(() => {
    // Access to ALL input methods
    inputRef.current.focus();
    inputRef.current.value = 'Can do anything';
  }, []);

  return <input ref={inputRef} />;
}
```

### With useImperativeHandle

```jsx
import { forwardRef, useImperativeHandle, useRef } from 'react';

// Child component
const CustomInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  // Expose only specific methods
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    clear: () => {
      inputRef.current.value = '';
    }
    // Don't expose setValue, blur, etc.
  }));

  return <input ref={inputRef} {...props} />;
});

// Parent component
function Parent() {
  const customInputRef = useRef();

  const handleClick = () => {
    customInputRef.current.focus(); // ✅ Works
    customInputRef.current.clear(); // ✅ Works
    // customInputRef.current.value = 'test'; // ❌ Not exposed
  };

  return (
    <div>
      <CustomInput ref={customInputRef} />
      <button onClick={handleClick}>Focus & Clear</button>
    </div>
  );
}
```

---

## Complete Example: Video Player

```jsx
import { forwardRef, useImperativeHandle, useRef, useState } from 'react';

const VideoPlayer = forwardRef((props, ref) => {
  const videoRef = useRef();
  const [isPlaying, setIsPlaying] = useState(false);

  useImperativeHandle(ref, () => ({
    play: () => {
      videoRef.current.play();
      setIsPlaying(true);
    },
    pause: () => {
      videoRef.current.pause();
      setIsPlaying(false);
    },
    seek: (time) => {
      videoRef.current.currentTime = time;
    },
    getCurrentTime: () => {
      return videoRef.current.currentTime;
    },
    getDuration: () => {
      return videoRef.current.duration;
    },
    setVolume: (volume) => {
      videoRef.current.volume = Math.min(Math.max(volume, 0), 1);
    }
  }));

  return (
    <div>
      <video
        ref={videoRef}
        src={props.src}
        onPlay={() => setIsPlaying(true)}
        onPause={() => setIsPlaying(false)}
      />
      <p>{isPlaying ? 'Playing' : 'Paused'}</p>
    </div>
  );
});

// Parent component
function App() {
  const playerRef = useRef();

  return (
    <div>
      <VideoPlayer
        ref={playerRef}
        src="video.mp4"
      />

      <div>
        <button onClick={() => playerRef.current.play()}>
          Play
        </button>
        <button onClick={() => playerRef.current.pause()}>
          Pause
        </button>
        <button onClick={() => playerRef.current.seek(10)}>
          Seek to 10s
        </button>
        <button onClick={() => playerRef.current.setVolume(0.5)}>
          50% Volume
        </button>
      </div>
    </div>
  );
}
```

---

## Complete Example: Modal with Imperative Handle

```jsx
const Modal = forwardRef(({ children }, ref) => {
  const [isOpen, setIsOpen] = useState(false);
  const dialogRef = useRef();

  useImperativeHandle(ref, () => ({
    open: () => {
      setIsOpen(true);
      dialogRef.current?.showModal();
    },
    close: () => {
      setIsOpen(false);
      dialogRef.current?.close();
    },
    toggle: () => {
      if (isOpen) {
        setIsOpen(false);
        dialogRef.current?.close();
      } else {
        setIsOpen(true);
        dialogRef.current?.showModal();
      }
    }
  }));

  if (!isOpen) return null;

  return (
    <dialog ref={dialogRef}>
      <div>
        {children}
        <button onClick={() => {
          setIsOpen(false);
          dialogRef.current?.close();
        }}>
          Close
        </button>
      </div>
    </dialog>
  );
});

// Usage
function App() {
  const modalRef = useRef();

  return (
    <div>
      <button onClick={() => modalRef.current.open()}>
        Open Modal
      </button>

      <Modal ref={modalRef}>
        <h2>Modal Content</h2>
        <p>This is a modal</p>
      </Modal>
    </div>
  );
}
```

---

## Common Patterns

### 1. Focus Management

```jsx
const FocusableInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(),
    blur: () => inputRef.current.blur(),
    select: () => inputRef.current.select()
  }));

  return <input ref={inputRef} {...props} />;
});
```

### 2. Animation Controls

```jsx
const AnimatedBox = forwardRef((props, ref) => {
  const boxRef = useRef();

  useImperativeHandle(ref, () => ({
    slideIn: () => {
      boxRef.current.classList.add('slide-in');
    },
    slideOut: () => {
      boxRef.current.classList.add('slide-out');
    },
    reset: () => {
      boxRef.current.classList.remove('slide-in', 'slide-out');
    }
  }));

  return <div ref={boxRef} {...props} />;
});
```

### 3. Form Controls

```jsx
const Form = forwardRef((props, ref) => {
  const formRef = useRef();

  useImperativeHandle(ref, () => ({
    submit: () => {
      formRef.current.requestSubmit();
    },
    reset: () => {
      formRef.current.reset();
    },
    getValues: () => {
      const formData = new FormData(formRef.current);
      return Object.fromEntries(formData);
    }
  }));

  return <form ref={formRef}>{props.children}</form>;
});
```

---

## Interview Questions

### Q1: What is useRef?
**Answer**: useRef returns a mutable ref object with a `.current` property that persists across renders. Unlike state, updating a ref doesn't trigger re-renders.

### Q2: When should you use useRef instead of useState?
**Answer**: Use useRef when:
- Accessing DOM elements
- Storing mutable values that don't need re-renders (timers, previous values)
- Storing values between renders without causing re-render

Use useState for values that should trigger UI updates.

### Q3: What is the difference between useRef and createRef?
**Answer**:
- **useRef**: Persists across renders (functional components)
- **createRef**: Creates new ref on every render (class components)

useRef is for functional components, createRef is for class components.

### Q4: What is useImperativeHandle?
**Answer**: useImperativeHandle customizes the instance value exposed when using ref. It restricts what parent components can access, providing only specific methods instead of the entire DOM node.

### Q5: When should you use useImperativeHandle?
**Answer**: When:
- Building reusable component libraries
- Need to expose custom API instead of DOM methods
- Want to encapsulate implementation details
- Creating components like modals, players, custom inputs

Avoid overuse - prefer props and callbacks for most cases.

### Q6: What is forwardRef?
**Answer**: forwardRef lets components receive a ref and forward it to a child component:

```jsx
const MyInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});
```

Required when passing refs to functional components.

### Q7: Can you have multiple refs on one element?
**Answer**: Yes, using callback refs:

```jsx
<div ref={node => {
  ref1.current = node;
  ref2.current = node;
}} />
```

Or create a helper function to merge refs.

---

## Best Practices

1. **Use refs for imperative actions** - focus, scroll, animations
2. **Don't overuse** - prefer declarative React patterns
3. **Initialize refs** - `useRef(null)` for DOM refs
4. **Clean up timers** - clear intervals/timeouts in useEffect cleanup
5. **Use forwardRef** when passing refs to custom components
6. **Limit useImperativeHandle** - only expose necessary methods
7. **Don't read/write refs during render** - use useEffect
8. **Combine with useCallback** for dynamic refs
9. **Document exposed API** when using useImperativeHandle
10. **Prefer controlled components** over refs for forms

---

## Common Mistakes

```jsx
// ❌ Reading ref during render
function Bad() {
  const ref = useRef();
  console.log(ref.current); // undefined on first render
  return <div ref={ref} />;
}

// ✅ Read in useEffect
function Good() {
  const ref = useRef();
  
  useEffect(() => {
    console.log(ref.current); // Available here
  }, []);
  
  return <div ref={ref} />;
}

// ❌ Forgetting cleanup
function Bad() {
  const intervalRef = useRef();
  intervalRef.current = setInterval(() => {}, 1000);
  // Never cleared!
}

// ✅ Cleanup in useEffect
function Good() {
  const intervalRef = useRef();
  
  useEffect(() => {
    intervalRef.current = setInterval(() => {}, 1000);
    return () => clearInterval(intervalRef.current);
  }, []);
}
```

---

## Summary

### useRef
- **Mutable** ref object that persists across renders
- **Doesn't trigger re-renders** when updated
- **Use cases**: DOM access, timers, storing mutable values
- Access with `.current` property
- Initialize with `useRef(null)` for DOM refs

### useImperativeHandle
- **Customizes** ref exposure to parent
- Works with **forwardRef**
- Exposes **custom API** instead of DOM methods
- Use for **component libraries** and encapsulation
- **Don't overuse** - prefer props/callbacks

### Key Differences
- **useRef** doesn't re-render, **useState** does
- **useRef** is mutable, **useState** is immutable
- **useRef** for imperative, **props** for declarative
- **Refs** bypass React, **state** goes through React


