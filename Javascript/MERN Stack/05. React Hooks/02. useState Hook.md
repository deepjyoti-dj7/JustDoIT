# useState Hook

## What is useState?

`useState` is a React Hook that lets you add **state** to functional components.

### Basic Syntax

```jsx
const [state, setState] = useState(initialValue);
```

- **state**: Current state value
- **setState**: Function to update the state
- **initialValue**: Initial state value

---

## Basic Usage

### Simple Counter

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

### Multiple State Variables

```jsx
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);

  return (
    <form>
      <input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
        placeholder="Name"
      />
      <input 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
        placeholder="Email"
      />
      <input 
        type="number"
        value={age} 
        onChange={(e) => setAge(Number(e.target.value))} 
        placeholder="Age"
      />
    </form>
  );
}
```

---

## State Types

### 1. Primitive Values

```jsx
// String
const [name, setName] = useState('Alice');

// Number
const [count, setCount] = useState(0);

// Boolean
const [isActive, setIsActive] = useState(true);

// Null/Undefined
const [data, setData] = useState(null);
```

### 2. Objects

```jsx
function UserProfile() {
  const [user, setUser] = useState({
    name: 'Alice',
    email: 'alice@example.com',
    age: 25
  });

  // Update single property (spread operator)
  const updateEmail = (newEmail) => {
    setUser({ ...user, email: newEmail });
  };

  // Better: Functional update
  const updateName = (newName) => {
    setUser(prevUser => ({ ...prevUser, name: newName }));
  };

  return (
    <div>
      <p>{user.name} - {user.email}</p>
      <button onClick={() => updateEmail('newemail@example.com')}>
        Update Email
      </button>
    </div>
  );
}
```

### 3. Arrays

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);

  // Add item
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, done: false }]);
  };

  // Remove item
  const removeTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  // Update item
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <span 
            style={{ textDecoration: todo.done ? 'line-through' : 'none' }}
            onClick={() => toggleTodo(todo.id)}
          >
            {todo.text}
          </span>
          <button onClick={() => removeTodo(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

---

## Functional Updates

When new state depends on previous state, use **functional updates**.

### Why Functional Updates?

```jsx
// ❌ May use stale state
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1);  // Still uses old count!
    // Result: count increases by 1, not 2
  };
}

// ✅ Always uses latest state
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(c => c + 1);
    setCount(c => c + 1);
    // Result: count increases by 2
  };
}
```

### Async Updates

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ❌ Wrong: Uses stale count
  const incrementAsync = () => {
    setTimeout(() => {
      setCount(count + 1);  // count from when timeout was set
    }, 1000);
  };

  // ✅ Correct: Always uses latest count
  const incrementAsync = () => {
    setTimeout(() => {
      setCount(c => c + 1);  // Latest count
    }, 1000);
  };
}
```

---

## Lazy Initialization

For expensive initial state calculations, use **lazy initialization**.

```jsx
// ❌ Runs on every render
function Component() {
  const [state, setState] = useState(expensiveComputation());
  // expensiveComputation() runs on every render!
}

// ✅ Runs only once
function Component() {
  const [state, setState] = useState(() => {
    return expensiveComputation();
  });
  // Function only called on initial render
}
```

### Example: Reading from localStorage

```jsx
function useLocalStorageState(key, defaultValue) {
  const [state, setState] = useState(() => {
    // Only reads from localStorage on mount
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : defaultValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(state));
  }, [key, state]);

  return [state, setState];
}

// Usage
function App() {
  const [theme, setTheme] = useLocalStorageState('theme', 'light');
  return <button onClick={() => setTheme('dark')}>{theme}</button>;
}
```

---

## State Update Batching

React batches multiple state updates for performance.

```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  const handleClick = () => {
    // Both updates batched together = single re-render
    setCount(c => c + 1);
    setFlag(f => !f);
  };

  console.log('Rendered'); // Only logs once per click

  return <button onClick={handleClick}>Click</button>;
}
```

---

## Common Patterns

### 1. Toggle Boolean

```jsx
function Component() {
  const [isOpen, setIsOpen] = useState(false);

  // ✅ Toggle pattern
  const toggle = () => setIsOpen(prev => !prev);

  return <button onClick={toggle}>{isOpen ? 'Close' : 'Open'}</button>;
}
```

### 2. Counter with Limits

```jsx
function Component() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(c => Math.min(c + 1, 10)); // Max 10
  };

  const decrement = () => {
    setCount(c => Math.max(c - 1, 0)); // Min 0
  };

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment} disabled={count >= 10}>+</button>
      <button onClick={decrement} disabled={count <= 0}>-</button>
    </div>
  );
}
```

### 3. Form State Object

```jsx
function LoginForm() {
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    rememberMe: false
  });

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name="username"
        value={formData.username}
        onChange={handleChange}
      />
      <input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
      />
      <label>
        <input
          name="rememberMe"
          type="checkbox"
          checked={formData.rememberMe}
          onChange={handleChange}
        />
        Remember Me
      </label>
      <button type="submit">Login</button>
    </form>
  );
}
```

### 4. Loading States

```jsx
function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/data');
      const json = await response.json();
      setData(json);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return null;

  return <div>{JSON.stringify(data)}</div>;
}
```

### 5. Previous State Comparison

```jsx
function Component({ value }) {
  const [prevValue, setPrevValue] = useState(value);
  const [count, setCount] = useState(0);

  if (value !== prevValue) {
    setPrevValue(value);
    setCount(0); // Reset count when value changes
  }

  return <div>{count}</div>;
}
```

---

## State Immutability

Always treat state as **immutable**. Never mutate directly.

### Objects

```jsx
// ❌ Wrong: Direct mutation
const updateUser = () => {
  user.name = 'Bob';
  setUser(user); // React won't detect change!
};

// ✅ Correct: Create new object
const updateUser = () => {
  setUser({ ...user, name: 'Bob' });
};

// ✅ Better: Functional update
const updateUser = () => {
  setUser(prev => ({ ...prev, name: 'Bob' }));
};
```

### Arrays

```jsx
const [items, setItems] = useState([1, 2, 3]);

// ❌ Wrong: Direct mutation
items.push(4);
setItems(items);

// ✅ Correct: Create new array
setItems([...items, 4]);

// Remove item
setItems(items.filter(item => item !== 2));

// Update item
setItems(items.map(item => 
  item === 2 ? 20 : item
));

// Insert at position
const insertAt = (arr, index, item) => [
  ...arr.slice(0, index),
  item,
  ...arr.slice(index)
];
setItems(insertAt(items, 1, 99));
```

### Nested Objects

```jsx
const [user, setUser] = useState({
  name: 'Alice',
  address: {
    city: 'NYC',
    zip: '10001'
  }
});

// ❌ Wrong
user.address.city = 'LA';
setUser(user);

// ✅ Correct: Spread all levels
setUser({
  ...user,
  address: {
    ...user.address,
    city: 'LA'
  }
});

// ✅ Alternative: Use immer library
import { produce } from 'immer';

setUser(produce(draft => {
  draft.address.city = 'LA';
}));
```

---

## Common Mistakes

### 1. Mutating State

```jsx
// ❌ Wrong
const handleClick = () => {
  items.push(newItem);
  setItems(items);
};

// ✅ Correct
const handleClick = () => {
  setItems([...items, newItem]);
};
```

### 2. Depending on Previous State

```jsx
// ❌ May be stale
setCount(count + 1);

// ✅ Always fresh
setCount(c => c + 1);
```

### 3. Calling setState in Render

```jsx
// ❌ Infinite loop
function Component() {
  const [count, setCount] = useState(0);
  setCount(count + 1); // Called during render!
}

// ✅ Correct: Use useEffect
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1);
  }, []);
}
```

---

## Interview Questions

### Q1: What is useState and how does it work?
**Answer**: `useState` is a Hook that adds state to functional components. It returns an array with the current state value and a setter function. When the setter is called, it triggers a re-render with the new state value.

```jsx
const [count, setCount] = useState(0);
```

### Q2: Can you call useState conditionally?
**Answer**: No. Hooks must be called at the top level, not inside conditions, loops, or nested functions. This ensures hooks are called in the same order on every render.

```jsx
// ❌ Wrong
if (condition) {
  const [state, setState] = useState(0);
}

// ✅ Correct
const [state, setState] = useState(condition ? 0 : null);
```

### Q3: What is lazy initialization in useState?
**Answer**: Lazy initialization defers expensive initial state calculations until the first render by passing a function to useState instead of a value.

```jsx
// Runs on every render
const [state, setState] = useState(expensiveFunction());

// Runs only on first render
const [state, setState] = useState(() => expensiveFunction());
```

### Q4: Why use functional updates?
**Answer**: Functional updates ensure you're working with the latest state, especially important when:
- Multiple updates happen in quick succession
- Updates happen asynchronously (timers, callbacks)
- State depends on previous state

```jsx
// May use stale state
setCount(count + 1);

// Always uses latest state
setCount(c => c + 1);
```

### Q5: Does React batch state updates?
**Answer**: Yes. React batches multiple state updates within event handlers into a single re-render for performance. In React 18+, automatic batching also applies to promises, setTimeout, and native event handlers.

### Q6: How do you update object state?
**Answer**: Use the spread operator to create a new object with updated properties:

```jsx
setUser({ ...user, name: 'Bob' });

// Or with functional update
setUser(prev => ({ ...prev, name: 'Bob' }));
```

### Q7: What's the difference between useState and regular variables?
**Answer**:
- **Regular variable**: Doesn't persist across renders, changes don't trigger re-renders
- **useState**: Persists across renders, setter triggers re-render

```jsx
let count = 0; // Reset on every render
const [count, setCount] = useState(0); // Persists
```

---

## Best Practices

1. **Use functional updates** when state depends on previous value
2. **Initialize with lazy function** for expensive calculations
3. **Keep state minimal** - derive values instead of storing them
4. **Never mutate state directly** - always create new objects/arrays
5. **Group related state** in objects when values change together
6. **Separate independent state** into multiple useState calls
7. **Use descriptive names** for state variables
8. **Colocate state** close to where it's used
9. **Consider useReducer** for complex state logic
10. **Batch updates** naturally happen in event handlers

---

## Summary

- **useState** adds state to functional components
- Returns **[state, setState]** array
- State updates trigger **re-renders**
- Use **functional updates** for state based on previous state
- Use **lazy initialization** for expensive initial calculations
- Always treat state as **immutable**
- React **batches** multiple state updates for performance
- State must be updated with **setter function**, not directly
- Call useState at **top level** only, never conditionally

