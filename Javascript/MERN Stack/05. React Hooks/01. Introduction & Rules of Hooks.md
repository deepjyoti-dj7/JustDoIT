# Introduction & Rules of Hooks

## What are React Hooks?

Hooks are **functions** that let you use state and other React features in functional components without writing a class.

Introduced in React 16.8 (February 2019), hooks revolutionized how we write React components.

---

## Why Hooks?

### Problems with Class Components

```jsx
// ❌ Class component: Verbose and complex
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.increment = this.increment.bind(this); // Need to bind
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={this.increment}>+</button>
      </div>
    );
  }
}
```

### Solution with Hooks

```jsx
// ✅ Functional component with hooks: Clean and simple
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

---

## Benefits of Hooks

### 1. **Reusable Logic**
Extract stateful logic into custom hooks, reuse across components.

```jsx
// Custom hook
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  return { count, increment, decrement };
}

// Use in multiple components
function ComponentA() {
  const { count, increment } = useCounter(0);
  return <button onClick={increment}>{count}</button>;
}

function ComponentB() {
  const { count, decrement } = useCounter(10);
  return <button onClick={decrement}>{count}</button>;
}
```

### 2. **Better Code Organization**
Group related logic together instead of splitting across lifecycle methods.

```jsx
// ❌ Class: Logic scattered
class UserProfile extends Component {
  componentDidMount() {
    fetchUser();      // User logic
    trackPageView();  // Analytics logic
    connectSocket();  // WebSocket logic
  }

  componentWillUnmount() {
    disconnectSocket();  // WebSocket cleanup
  }
}

// ✅ Hooks: Logic grouped by concern
function UserProfile() {
  // User logic together
  useEffect(() => {
    fetchUser();
  }, []);

  // Analytics logic together
  useEffect(() => {
    trackPageView();
  }, []);

  // WebSocket logic together
  useEffect(() => {
    const socket = connectSocket();
    return () => socket.disconnect();
  }, []);
}
```

### 3. **Simpler Mental Model**
No `this` keyword, no binding, easier to understand.

```jsx
// ❌ Class: Need to understand 'this'
handleClick = () => {
  this.setState({ count: this.state.count + 1 });
}

// ✅ Hooks: Just JavaScript closures
const handleClick = () => {
  setCount(count + 1);
}
```

### 4. **Easier Testing**
Functional components with hooks are easier to test.

```jsx
// Custom hook can be tested independently
function useCounter() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(c => c + 1);
  return { count, increment };
}

// Test the hook
import { renderHook, act } from '@testing-library/react-hooks';

test('useCounter', () => {
  const { result } = renderHook(() => useCounter());
  
  expect(result.current.count).toBe(0);
  
  act(() => {
    result.current.increment();
  });
  
  expect(result.current.count).toBe(1);
});
```

### 5. **Smaller Bundle Size**
Functional components with hooks produce smaller bundles than class components.

---

## Built-in React Hooks

### Basic Hooks
- **useState**: Add state to functional components
- **useEffect**: Perform side effects (data fetching, subscriptions, etc.)
- **useContext**: Access React Context

### Additional Hooks
- **useReducer**: Alternative to useState for complex state logic
- **useCallback**: Memoize callback functions
- **useMemo**: Memoize expensive computations
- **useRef**: Access DOM elements or persist values across renders
- **useImperativeHandle**: Customize ref exposure to parent components
- **useLayoutEffect**: Run effects synchronously after DOM mutations
- **useDebugValue**: Display custom label in React DevTools

---

## Rules of Hooks

### Rule 1: Only Call Hooks at the Top Level

**❌ Don't call hooks inside loops, conditions, or nested functions**

```jsx
// ❌ Wrong: Conditional hook
function Component({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // Error!
  }
}

// ❌ Wrong: Hook in loop
function Component({ items }) {
  items.forEach(item => {
    const [state, setState] = useState(item); // Error!
  });
}

// ❌ Wrong: Hook in nested function
function Component() {
  function handleClick() {
    const [state, setState] = useState(0); // Error!
  }
}
```

**✅ Always call hooks at the top level of your function**

```jsx
// ✅ Correct: Hooks at top level
function Component({ condition, items }) {
  const [state, setState] = useState(0);
  const [data, setData] = useState([]);
  
  // Use conditional logic AFTER calling hooks
  useEffect(() => {
    if (condition) {
      // Do something
    }
  }, [condition]);
  
  return <div>{state}</div>;
}
```

**Why?** React relies on the order of hook calls to preserve state between renders. Conditional hooks break this order.

---

### Rule 2: Only Call Hooks from React Functions

**✅ Call hooks from:**
- React functional components
- Custom hooks

**❌ Don't call hooks from:**
- Regular JavaScript functions
- Class components

```jsx
// ❌ Wrong: Hook in regular function
function calculateTotal() {
  const [total, setTotal] = useState(0); // Error!
  return total;
}

// ❌ Wrong: Hook in class
class MyComponent extends Component {
  method() {
    const [state, setState] = useState(0); // Error!
  }
}

// ✅ Correct: Hook in functional component
function MyComponent() {
  const [state, setState] = useState(0);
  return <div>{state}</div>;
}

// ✅ Correct: Hook in custom hook
function useCustomHook() {
  const [state, setState] = useState(0);
  return state;
}
```

---

## ESLint Plugin

Install the official ESLint plugin to enforce hook rules:

```bash
npm install eslint-plugin-react-hooks --save-dev
```

Configure in `.eslintrc`:

```json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

This plugin will:
- Enforce the Rules of Hooks
- Check effect dependencies
- Provide warnings and errors

---

## Hook Call Order

React relies on the **order** in which hooks are called.

```jsx
function Component({ condition }) {
  // First render
  const [name, setName] = useState('Alice');     // Hook 1
  const [age, setAge] = useState(25);            // Hook 2
  const [email, setEmail] = useState('');        // Hook 3

  // ❌ Second render (if condition changes)
  const [name, setName] = useState('Alice');     // Hook 1
  if (condition) {
    const [age, setAge] = useState(25);          // Hook 2 (sometimes)
  }
  const [email, setEmail] = useState('');        // Hook 3 or 2?

  // React gets confused about which state belongs to which hook!
}
```

React maintains an internal list of hooks in the order they're called. This order must be the same on every render.

---

## Common Mistakes

### 1. Conditional Hooks

```jsx
// ❌ Wrong
function Component({ user }) {
  if (user) {
    const [data, setData] = useState(null);
  }
}

// ✅ Correct: Initialize with conditional value
function Component({ user }) {
  const [data, setData] = useState(user ? null : undefined);
}
```

### 2. Hooks in Loops

```jsx
// ❌ Wrong
function Component({ items }) {
  return items.map(item => {
    const [selected, setSelected] = useState(false);
    return <div>{item.name}</div>;
  });
}

// ✅ Correct: Extract to component
function Item({ item }) {
  const [selected, setSelected] = useState(false);
  return <div>{item.name}</div>;
}

function Component({ items }) {
  return items.map(item => <Item key={item.id} item={item} />);
}
```

### 3. Hooks in Event Handlers

```jsx
// ❌ Wrong
function Component() {
  const handleClick = () => {
    const [clicked, setClicked] = useState(false);
  };
}

// ✅ Correct: Hook at top level
function Component() {
  const [clicked, setClicked] = useState(false);
  
  const handleClick = () => {
    setClicked(true);
  };
}
```

---

## Migration from Classes to Hooks

### Class Component
```jsx
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  componentDidMount() {
    document.title = `Count: ${this.state.count}`;
  }

  componentDidUpdate() {
    document.title = `Count: ${this.state.count}`;
  }

  render() {
    return (
      <div>
        <p>{this.state.count}</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Increment
        </button>
      </div>
    );
  }
}
```

### Functional Component with Hooks
```jsx
import { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    document.title = `Count: ${count}`;
  }, [count]);

  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

---

## Interview Questions

### Q1: What are React Hooks?
**Answer**: Hooks are functions that let you use state and other React features in functional components. They were introduced in React 16.8 to eliminate the need for class components and provide a more direct API to React concepts.

### Q2: What are the Rules of Hooks?
**Answer**: Two rules:
1. **Only call hooks at the top level** - Don't call hooks inside loops, conditions, or nested functions
2. **Only call hooks from React functions** - Call from functional components or custom hooks only

These rules ensure hooks work correctly by preserving their call order between renders.

### Q3: Why were hooks introduced?
**Answer**: Hooks solve several problems:
- **Reusability**: Share stateful logic without HOCs or render props
- **Complexity**: Organize code by feature, not lifecycle
- **Classes**: Avoid `this` binding and class complexity
- **Bundle size**: Smaller bundles with functional components
- **Testing**: Easier to test pure functions

### Q4: Can you use hooks in class components?
**Answer**: No. Hooks only work in functional components and custom hooks. If you need to use hooks, convert the class component to a functional component.

### Q5: What happens if you break the Rules of Hooks?
**Answer**: Breaking the rules causes bugs because React relies on hook call order to track state. Conditional hooks or hooks in loops will:
- Cause incorrect state assignments
- Trigger React errors
- Lead to unpredictable behavior

Use the `eslint-plugin-react-hooks` to catch these errors.

### Q6: What is the difference between hooks and lifecycle methods?
**Answer**:
- **Lifecycle methods**: Split related logic across multiple methods (componentDidMount, componentDidUpdate, componentWillUnmount)
- **Hooks**: Group related logic together in useEffect

Hooks provide a more cohesive way to handle side effects.

### Q7: Can you conditionally call a hook?
**Answer**: No. Hooks must be called unconditionally at the top level. However, you can conditionally execute code *inside* a hook:

```jsx
// ❌ Wrong
if (condition) {
  useEffect(() => {}, []);
}

// ✅ Correct
useEffect(() => {
  if (condition) {
    // Conditional logic inside hook
  }
}, [condition]);
```

---

## Best Practices

1. **Always use ESLint plugin** - Catch hook violations early
2. **Name custom hooks with "use" prefix** - `useAuth`, `useFetch`, etc.
3. **Keep hooks at the top level** - Never inside conditions, loops, or nested functions
4. **One concern per useEffect** - Separate different side effects
5. **Extract reusable logic** - Create custom hooks for common patterns
6. **Declare dependencies correctly** - Include all values used inside effects
7. **Use functional updates** - When state depends on previous state
8. **Cleanup in useEffect** - Return cleanup function when needed
9. **Start with built-in hooks** - Before creating custom ones
10. **Understand each hook's purpose** - Use the right hook for the job

---

## Summary

- **Hooks** are functions that add React features to functional components
- Introduced to solve problems with classes: reusability, complexity, `this` binding
- **Two rules**: Call at top level only, from React functions only
- Use **ESLint plugin** to enforce rules automatically
- Hooks must be called in the **same order** every render
- Enable **better code organization** and **reusability**
- Custom hooks let you **extract and share logic**
- Functional components with hooks are the **modern React way**
