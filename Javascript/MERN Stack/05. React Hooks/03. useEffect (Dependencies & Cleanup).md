# useEffect (Dependencies & Cleanup)

## What is useEffect?

`useEffect` is a Hook that lets you perform **side effects** in functional components.

Side effects include:
- Data fetching
- Subscriptions
- Manually changing the DOM
- Timers
- Logging

---

## Basic Syntax

```jsx
useEffect(() => {
  // Effect code
  
  return () => {
    // Cleanup code (optional)
  };
}, [dependencies]);
```

---

## Dependency Array Patterns

### 1. No Dependency Array - Runs After Every Render

```jsx
useEffect(() => {
  console.log('Runs after every render');
});
```

**Use case**: Rarely needed, usually indicates a problem.

### 2. Empty Dependency Array - Runs Once on Mount

```jsx
useEffect(() => {
  console.log('Runs once on mount');
}, []);
```

**Use cases**:
- Initial data fetch
- Set up subscriptions
- Initialize third-party libraries

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Fetch user data once on mount
    fetchUser(userId).then(setUser);
  }, []);

  return <div>{user?.name}</div>;
}
```

### 3. With Dependencies - Runs When Dependencies Change

```jsx
useEffect(() => {
  console.log('Runs when dependency changes');
}, [dependency]);
```

**Use cases**:
- Refetch data when props change
- Update based on state changes

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Refetch when userId changes
    fetchUser(userId).then(setUser);
  }, [userId]);

  return <div>{user?.name}</div>;
}
```

---

## Common Use Cases

### 1. Data Fetching

```jsx
function Posts() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let isMounted = true;

    const fetchPosts = async () => {
      try {
        const response = await fetch('/api/posts');
        const data = await response.json();
        
        if (isMounted) {
          setPosts(data);
          setLoading(false);
        }
      } catch (error) {
        if (isMounted) {
          console.error('Error:', error);
          setLoading(false);
        }
      }
    };

    fetchPosts();

    // Cleanup: prevent state update if unmounted
    return () => {
      isMounted = false;
    };
  }, []);

  if (loading) return <div>Loading...</div>;
  return <PostList posts={posts} />;
}
```

### 2. Document Title

```jsx
function PageTitle({ title, count }) {
  useEffect(() => {
    document.title = `${title} (${count})`;
  }, [title, count]); // Update when title or count changes

  return <h1>{title}</h1>;
}
```

### 3. Event Listeners

```jsx
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    // Add event listener
    window.addEventListener('resize', handleResize);

    // Cleanup: remove event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Empty array: set up once, clean up on unmount

  return <div>{size.width} x {size.height}</div>;
}
```

### 4. Timers and Intervals

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    // Cleanup: clear interval
    return () => clearInterval(interval);
  }, []);

  return <div>Seconds: {seconds}</div>;
}
```

### 5. WebSocket Connections

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const socket = new WebSocket(`ws://chat.com/${roomId}`);

    socket.onmessage = (event) => {
      setMessages(prev => [...prev, event.data]);
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    // Cleanup: close socket
    return () => {
      socket.close();
    };
  }, [roomId]); // Reconnect when roomId changes

  return (
    <div>
      {messages.map((msg, i) => (
        <p key={i}>{msg}</p>
      ))}
    </div>
  );
}
```

### 6. Local Storage Sync

```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// Usage
function App() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Theme: {theme}
    </button>
  );
}
```

---

## Cleanup Functions

Cleanup prevents memory leaks and unwanted behavior when:
- Component unmounts
- Effect re-runs (before running again)

### When to Use Cleanup

```jsx
useEffect(() => {
  // Setup
  const subscription = subscribe();
  const timer = setInterval(() => {}, 1000);
  window.addEventListener('resize', handleResize);

  // Cleanup
  return () => {
    subscription.unsubscribe();
    clearInterval(timer);
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

### Cleanup Execution Order

```jsx
function Component({ id }) {
  useEffect(() => {
    console.log('Effect runs for id:', id);

    return () => {
      console.log('Cleanup runs for id:', id);
    };
  }, [id]);
}

// When id changes from 1 to 2:
// 1. Cleanup runs for id: 1
// 2. Effect runs for id: 2
```

---

## Dependencies

### Rules for Dependencies

1. **Include all values** from component scope used in effect
2. **Primitive values** that change should be dependencies
3. **Objects/arrays** create new references, be careful
4. **Functions** from component should be dependencies (or use useCallback)

### Missing Dependencies Warning

```jsx
// ⚠️ Warning: userId should be in dependencies
function Component({ userId }) {
  useEffect(() => {
    fetchUser(userId);
  }, []); // Missing userId!
}

// ✅ Correct
function Component({ userId }) {
  useEffect(() => {
    fetchUser(userId);
  }, [userId]);
}
```

### Multiple Dependencies

```jsx
function SearchResults({ query, category, sortBy }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    // Runs when any dependency changes
    searchAPI(query, category, sortBy)
      .then(setResults);
  }, [query, category, sortBy]);

  return <ResultsList results={results} />;
}
```

### Object/Array Dependencies

```jsx
// ❌ Problem: New object on every render
function Component() {
  const config = { theme: 'dark' }; // New reference every render!

  useEffect(() => {
    applyConfig(config);
  }, [config]); // Effect runs every render
}

// ✅ Solution 1: Primitive dependencies
function Component() {
  const theme = 'dark';

  useEffect(() => {
    applyConfig({ theme });
  }, [theme]); // Only when theme changes
}

// ✅ Solution 2: useMemo
function Component() {
  const config = useMemo(() => ({ theme: 'dark' }), []);

  useEffect(() => {
    applyConfig(config);
  }, [config]); // Stable reference
}
```

### Function Dependencies

```jsx
// ❌ Problem: New function every render
function Component({ userId }) {
  const fetchData = () => {
    fetch(`/api/users/${userId}`);
  };

  useEffect(() => {
    fetchData();
  }, [fetchData]); // New function every render!
}

// ✅ Solution 1: Include userId directly
function Component({ userId }) {
  useEffect(() => {
    fetch(`/api/users/${userId}`);
  }, [userId]);
}

// ✅ Solution 2: useCallback
function Component({ userId }) {
  const fetchData = useCallback(() => {
    fetch(`/api/users/${userId}`);
  }, [userId]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);
}
```

---

## Advanced Patterns

### 1. Debouncing

```jsx
function SearchInput() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    // Debounce search: wait 500ms after user stops typing
    const timer = setTimeout(() => {
      if (query) {
        searchAPI(query).then(setResults);
      }
    }, 500);

    // Cleanup: cancel previous timer
    return () => clearTimeout(timer);
  }, [query]);

  return (
    <input 
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

### 2. AbortController for Fetch

```jsx
function DataFetcher({ url }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    fetch(url, { signal: controller.signal })
      .then(res => res.json())
      .then(setData)
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error('Fetch error:', err);
        }
      });

    // Cleanup: abort fetch if URL changes or unmounts
    return () => controller.abort();
  }, [url]);

  return <div>{JSON.stringify(data)}</div>;
}
```

### 3. Polling

```jsx
function LiveData() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = () => {
      fetch('/api/live-data')
        .then(res => res.json())
        .then(setData);
    };

    // Initial fetch
    fetchData();

    // Poll every 5 seconds
    const interval = setInterval(fetchData, 5000);

    // Cleanup
    return () => clearInterval(interval);
  }, []);

  return <div>{JSON.stringify(data)}</div>;
}
```

### 4. Synchronizing with External Store

```jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}
```

---

## Common Mistakes

### 1. Infinite Loop

```jsx
// ❌ Infinite loop: state update causes re-render
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount(count + 1); // Triggers re-render
  }); // No dependency array: runs after every render!
}

// ✅ Fix: Add empty dependency array
useEffect(() => {
  setCount(count + 1);
}, []);
```

### 2. Missing Dependencies

```jsx
// ❌ Stale closure: count will always be 0
function Component() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount(count + 1); // Uses count from when effect ran
    }, 1000);

    return () => clearInterval(timer);
  }, []); // count not in dependencies!
}

// ✅ Fix: Functional update
useEffect(() => {
  const timer = setInterval(() => {
    setCount(c => c + 1); // Uses latest count
  }, 1000);

  return () => clearInterval(timer);
}, []);
```

### 3. Not Cleaning Up

```jsx
// ❌ Memory leak: timer continues after unmount
useEffect(() => {
  setInterval(() => {
    console.log('Tick');
  }, 1000);
}, []);

// ✅ Fix: Return cleanup function
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Tick');
  }, 1000);

  return () => clearInterval(timer);
}, []);
```

---

## Interview Questions

### Q1: What is useEffect?
**Answer**: useEffect is a Hook that performs side effects in functional components. It runs after render and can optionally clean up before the next effect or when the component unmounts.

### Q2: When does useEffect run?
**Answer**: Depends on the dependency array:
- **No array**: After every render
- **Empty array []**: Once after initial render (mount)
- **With dependencies [dep]**: After initial render and when dependencies change

### Q3: What is cleanup in useEffect?
**Answer**: Cleanup is a function returned from useEffect that runs:
- Before the effect runs again (if dependencies changed)
- When the component unmounts

Used to clean up subscriptions, timers, event listeners, etc.

### Q4: What happens if you don't include dependencies?
**Answer**: You may get stale values (closures) or the effect may not run when it should. ESLint plugin warns about missing dependencies.

### Q5: Can you have multiple useEffect hooks?
**Answer**: Yes! It's recommended to separate concerns into different effects:

```jsx
useEffect(() => {
  // Effect 1: Data fetching
}, [userId]);

useEffect(() => {
  // Effect 2: Document title
}, [title]);
```

### Q6: How do you prevent useEffect from running on mount?
**Answer**: Use a ref to track if it's the first render:

```jsx
const isFirstRender = useRef(true);

useEffect(() => {
  if (isFirstRender.current) {
    isFirstRender.current = false;
    return;
  }
  
  // Runs on updates only
}, [dependency]);
```

### Q7: What's the difference between useEffect and useLayoutEffect?
**Answer**:
- **useEffect**: Runs asynchronously after render, doesn't block painting
- **useLayoutEffect**: Runs synchronously after DOM mutations, before painting

Use useLayoutEffect only when you need to measure/mutate DOM before the browser paints.

---

## Best Practices

1. **One concern per effect** - separate unrelated logic
2. **Always clean up** side effects (timers, subscriptions, listeners)
3. **Include all dependencies** - use ESLint plugin
4. **Use functional updates** to avoid stale closures
5. **Handle race conditions** with cleanup flags or AbortController
6. **Avoid objects/arrays** as dependencies (use useMemo)
7. **Don't call hooks conditionally** - put conditions inside useEffect
8. **Extract reusable logic** into custom hooks
9. **Be cautious with infinite loops** - check dependency array
10. **Think about cleanup** for every setup

---

## Summary

- **useEffect** handles side effects in functional components
- Runs **after render** by default
- **Dependency array** controls when effect runs
- **Cleanup function** prevents memory leaks
- Include **all dependencies** used in effect
- Use **functional updates** to avoid stale values
- **Multiple effects** are better than one complex effect
- Always **clean up** timers, subscriptions, listeners
- **ESLint plugin** catches missing dependencies

