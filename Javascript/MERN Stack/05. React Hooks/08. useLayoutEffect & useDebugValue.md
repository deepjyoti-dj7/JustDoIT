# useLayoutEffect & useDebugValue Hooks

## useLayoutEffect Hook

`useLayoutEffect` is identical to `useEffect` but fires **synchronously after all DOM mutations** and before the browser paints.

---

## Basic Syntax

```jsx
useLayoutEffect(() => {
  // Side effect code
  
  return () => {
    // Cleanup (optional)
  };
}, [dependencies]);
```

---

## useEffect vs useLayoutEffect

| Feature | useEffect | useLayoutEffect |
|---------|-----------|-----------------|
| Execution timing | **After paint** (asynchronous) | **Before paint** (synchronous) |
| Blocks painting | ❌ No | ✅ Yes |
| Use for | Data fetching, subscriptions, most side effects | DOM measurements, synchronous DOM updates |
| Performance | Better (non-blocking) | Can block painting |

### Visual Timeline

```
Component renders
    ↓
DOM mutations
    ↓
useLayoutEffect runs ← Synchronous, blocks paint
    ↓
Browser paints screen
    ↓
useEffect runs ← Asynchronous, after paint
```

---

## When to Use useLayoutEffect

### 1. Measuring DOM Elements

```jsx
import { useLayoutEffect, useRef, useState } from 'react';

function MeasureElement() {
  const elementRef = useRef(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    // Measure before paint to avoid flicker
    const { width, height } = elementRef.current.getBoundingClientRect();
    setDimensions({ width, height });
  }, []);

  return (
    <div>
      <div ref={elementRef}>
        <h1>Measure Me</h1>
        <p>Some content here</p>
      </div>
      <p>Width: {dimensions.width}px</p>
      <p>Height: {dimensions.height}px</p>
    </div>
  );
}
```

### 2. Synchronous DOM Updates

```jsx
function Tooltip({ children, text }) {
  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);

  useLayoutEffect(() => {
    if (!tooltipRef.current || !triggerRef.current) return;

    // Position tooltip before paint to avoid visual jump
    const triggerRect = triggerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();

    tooltipRef.current.style.left = `${triggerRect.left}px`;
    tooltipRef.current.style.top = `${triggerRect.bottom + 5}px`;
  });

  return (
    <div>
      <div ref={triggerRef}>{children}</div>
      <div ref={tooltipRef} className="tooltip">
        {text}
      </div>
    </div>
  );
}
```

### 3. Preventing Visual Flicker

```jsx
// ❌ Using useEffect - causes flicker
function FlickerExample() {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    // Runs after paint - user sees element before hiding
    setIsVisible(true);
  }, []);

  return isVisible ? <div>Content</div> : null;
}

// ✅ Using useLayoutEffect - no flicker
function NoFlickerExample() {
  const [isVisible, setIsVisible] = useState(false);

  useLayoutEffect(() => {
    // Runs before paint - no visible flicker
    setIsVisible(true);
  }, []);

  return isVisible ? <div>Content</div> : null;
}
```

---

## Complete Example: Tooltip Positioning

```jsx
import { useLayoutEffect, useRef, useState } from 'react';

function Tooltip({ content, children }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);

  useLayoutEffect(() => {
    if (!isVisible || !triggerRef.current || !tooltipRef.current) return;

    const triggerRect = triggerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();

    let top = triggerRect.bottom + 5;
    let left = triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2);

    // Prevent overflow
    if (left < 0) left = 5;
    if (left + tooltipRect.width > window.innerWidth) {
      left = window.innerWidth - tooltipRect.width - 5;
    }

    if (top + tooltipRect.height > window.innerHeight) {
      top = triggerRect.top - tooltipRect.height - 5;
    }

    setPosition({ top, left });
  }, [isVisible]);

  return (
    <>
      <div
        ref={triggerRef}
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
      >
        {children}
      </div>

      {isVisible && (
        <div
          ref={tooltipRef}
          style={{
            position: 'fixed',
            top: `${position.top}px`,
            left: `${position.left}px`,
            backgroundColor: 'black',
            color: 'white',
            padding: '8px',
            borderRadius: '4px',
            zIndex: 1000
          }}
        >
          {content}
        </div>
      )}
    </>
  );
}

// Usage
function App() {
  return (
    <div>
      <Tooltip content="This is helpful information">
        <button>Hover me</button>
      </Tooltip>
    </div>
  );
}
```

---

## Example: Scroll to Element

```jsx
function ScrollToView({ targetId }) {
  const elementRef = useRef(null);

  useLayoutEffect(() => {
    if (elementRef.current) {
      // Scroll before paint to avoid visible jump
      elementRef.current.scrollIntoView({
        behavior: 'smooth',
        block: 'center'
      });
    }
  }, [targetId]);

  return <div ref={elementRef} id={targetId}>Target Element</div>;
}
```

---

## When NOT to Use useLayoutEffect

```jsx
// ❌ Data fetching - use useEffect
useLayoutEffect(() => {
  fetch('/api/data')
    .then(res => res.json())
    .then(setData);
}, []);

// ❌ Subscriptions - use useEffect
useLayoutEffect(() => {
  const unsubscribe = subscribe();
  return unsubscribe;
}, []);

// ❌ Not DOM-related - use useEffect
useLayoutEffect(() => {
  console.log('Component mounted');
}, []);
```

---

## useDebugValue Hook

`useDebugValue` displays a label for custom hooks in React DevTools.

---

## Basic Syntax

```jsx
useDebugValue(value);
// or with formatting
useDebugValue(value, formatFn);
```

---

## Basic Example

```jsx
import { useDebugValue, useState } from 'react';

function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  // Shows "Online: true" or "Online: false" in DevTools
  useDebugValue(isOnline ? 'Online' : 'Offline');

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}

// In component
function App() {
  const isOnline = useOnlineStatus();
  // In DevTools: useOnlineStatus: "Online" or "Offline"
  
  return <div>{isOnline ? 'Connected' : 'Disconnected'}</div>;
}
```

---

## Format Function

For expensive formatting, use the second parameter:

```jsx
function useUser(userId) {
  const [user, setUser] = useState(null);

  // Format function only runs when DevTools is open
  useDebugValue(user, user => {
    return user ? `${user.name} (${user.email})` : 'No user';
  });

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  return user;
}
```

---

## Multiple Debug Values

```jsx
function useComplexHook() {
  const [state, setState] = useState({
    count: 0,
    items: [],
    loading: false
  });

  // Show formatted object in DevTools
  useDebugValue({
    count: state.count,
    itemCount: state.items.length,
    status: state.loading ? 'Loading' : 'Idle'
  });

  return [state, setState];
}
```

---

## Complete Example: Custom Form Hook

```jsx
import { useDebugValue, useState } from 'react';

function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  // Debug info visible in DevTools
  useDebugValue({
    fields: Object.keys(values).length,
    hasErrors: Object.keys(errors).length > 0,
    touchedFields: Object.keys(touched).length
  });

  const handleChange = (name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
  };

  const handleBlur = (name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    reset
  };
}

// Usage
function LoginForm() {
  const form = useForm({ email: '', password: '' });
  // DevTools shows: fields: 2, hasErrors: false, touchedFields: 0

  return (
    <form>
      <input
        value={form.values.email}
        onChange={(e) => form.handleChange('email', e.target.value)}
        onBlur={() => form.handleBlur('email')}
      />
      <input
        value={form.values.password}
        onChange={(e) => form.handleChange('password', e.target.value)}
        onBlur={() => form.handleBlur('password')}
      />
    </form>
  );
}
```

---

## Example: useDebugValue with Date

```jsx
function useTimer(duration) {
  const [timeLeft, setTimeLeft] = useState(duration);

  // Format as human-readable time
  useDebugValue(timeLeft, (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  });

  useEffect(() => {
    const interval = setInterval(() => {
      setTimeLeft(t => Math.max(0, t - 1));
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return timeLeft;
}
```

---

## Interview Questions

### Q1: What is useLayoutEffect?
**Answer**: useLayoutEffect is identical to useEffect but runs **synchronously after DOM mutations and before browser paint**. It blocks the browser from painting until it completes.

### Q2: When should you use useLayoutEffect instead of useEffect?
**Answer**: Use useLayoutEffect when:
- Measuring DOM elements (getBoundingClientRect)
- Making synchronous DOM updates to prevent flicker
- Positioning tooltips, modals, or popovers
- Reading layout and synchronously re-rendering

Use useEffect for everything else (data fetching, subscriptions, etc.).

### Q3: What are the performance implications of useLayoutEffect?
**Answer**: useLayoutEffect **blocks painting**, which can make your app feel slower. Only use it when necessary to prevent visual artifacts. useEffect is preferred for most cases as it doesn't block painting.

### Q4: What is useDebugValue?
**Answer**: useDebugValue displays a custom label for custom hooks in React DevTools. It helps with debugging by showing meaningful information about hook state.

### Q5: When should you use useDebugValue?
**Answer**: Use in **custom hooks** to display helpful debug information. Don't use in regular components - only in hooks that are shared/reused. Especially useful in libraries.

### Q6: What's the second parameter of useDebugValue?
**Answer**: The second parameter is a **format function** that only runs when DevTools is open. Use it for expensive formatting:

```jsx
useDebugValue(value, expensiveFormat);
```

This prevents performance impact when DevTools isn't open.

### Q7: Can you use useLayoutEffect on the server?
**Answer**: No, useLayoutEffect doesn't run during server-side rendering. React will warn you. Use useEffect for SSR-compatible code, or suppress the warning if needed.

---

## Best Practices

### useLayoutEffect
1. **Prefer useEffect** - only use useLayoutEffect when necessary
2. **Use for DOM measurements** - getBoundingClientRect, scroll positions
3. **Prevent flicker** - synchronous DOM updates
4. **Don't fetch data** - use useEffect instead
5. **Be aware of performance** - blocks painting
6. **SSR compatibility** - doesn't run on server
7. **Keep it fast** - runs before paint
8. **Clean up properly** - return cleanup function

### useDebugValue
1. **Use in custom hooks only** - not in components
2. **Provide meaningful labels** - help debugging
3. **Use format function** for expensive formatting
4. **Keep it simple** - don't add complex logic
5. **Consider removing** in production builds
6. **Document custom hooks** - complement with comments
7. **Show relevant state** - not all internal details

---

## Common Patterns

### Measuring Elements

```jsx
function useMeasure() {
  const ref = useRef();
  const [bounds, setBounds] = useState({ width: 0, height: 0 });

  useLayoutEffect(() => {
    if (ref.current) {
      const rect = ref.current.getBoundingClientRect();
      setBounds({ width: rect.width, height: rect.height });
    }
  });

  useDebugValue(bounds, b => `${b.width}x${b.height}`);

  return [ref, bounds];
}

// Usage
function Component() {
  const [ref, bounds] = useMeasure();
  return <div ref={ref}>Size: {bounds.width}x{bounds.height}</div>;
}
```

### Focus Management

```jsx
function useFocus() {
  const ref = useRef();
  const [isFocused, setIsFocused] = useState(false);

  useLayoutEffect(() => {
    if (isFocused && ref.current) {
      ref.current.focus();
    }
  }, [isFocused]);

  useDebugValue(isFocused ? 'Focused' : 'Blurred');

  return [ref, setIsFocused];
}
```

---

## Summary

### useLayoutEffect
- Runs **synchronously** after DOM mutations
- **Before browser paint** (blocks painting)
- Use for **DOM measurements** and preventing flicker
- **Performance cost** - blocks rendering
- Prefer **useEffect** for most cases
- Not compatible with **SSR**

### useDebugValue
- Shows labels in **React DevTools**
- Use in **custom hooks** only
- **Format function** prevents performance impact
- Helps **debugging** complex hooks
- Optional **second parameter** for formatting
- Only visible when **DevTools is open**

### Key Differences
- **useEffect**: Asynchronous, after paint, non-blocking
- **useLayoutEffect**: Synchronous, before paint, blocking
- Use **useLayoutEffect** only when visual correctness requires it
- Use **useDebugValue** to document custom hook behavior


