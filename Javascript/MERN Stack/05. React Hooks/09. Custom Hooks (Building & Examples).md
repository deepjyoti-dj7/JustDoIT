# Custom Hooks (Building & Examples)

## What are Custom Hooks?

Custom Hooks are **reusable functions** that use React Hooks internally. They let you extract component logic into reusable functions.

**Key Points:**
- Start with `use` prefix (convention)
- Can call other hooks
- Encapsulate stateful logic
- Promote code reuse
- Each call creates independent state

---

## Why Custom Hooks?

### Without Custom Hook (Code Duplication)

```jsx
// Component 1
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then(data => {
      setUser(data);
      setLoading(false);
    });
  }, []);

  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

// Component 2 - Same logic duplicated!
function UserSettings() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then(data => {
      setUser(data);
      setLoading(false);
    });
  }, []);

  if (loading) return <div>Loading...</div>;
  return <div>{user.email}</div>;
}
```

### With Custom Hook (Reusable)

```jsx
// Custom Hook
function useUser() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then(data => {
      setUser(data);
      setLoading(false);
    });
  }, []);

  return { user, loading };
}

// Component 1
function UserProfile() {
  const { user, loading } = useUser();
  
  if (loading) return <div>Loading...</div>;
  return <div>{user.name}</div>;
}

// Component 2
function UserSettings() {
  const { user, loading } = useUser();
  
  if (loading) return <div>Loading...</div>;
  return <div>{user.email}</div>;
}
```

---

## Building Custom Hooks

### Basic Structure

```jsx
function useCustomHook(parameter) {
  // 1. State
  const [state, setState] = useState(initialValue);

  // 2. Side effects
  useEffect(() => {
    // Logic here
  }, [dependencies]);

  // 3. Return value(s)
  return state; // or return { state, helper functions }
}
```

---

## Example 1: useLocalStorage

Store state in localStorage with automatic sync.

```jsx
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // Initialize state from localStorage or use initialValue
  const [storedValue, setStoredValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  // Update localStorage when state changes
  const setValue = (value) => {
    try {
      // Allow value to be a function (like useState)
      const valueToStore = value instanceof Function 
        ? value(storedValue) 
        : value;
      
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// Usage
function App() {
  const [name, setName] = useLocalStorage('name', 'Guest');
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <p>Hello, {name}!</p>
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle Theme ({theme})
      </button>
    </div>
  );
}
```

---

## Example 2: useFetch

Reusable data fetching hook.

```jsx
import { useState, useEffect } from 'react';

function useFetch(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      
      try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const json = await response.json();
        setData(json);
        setError(null);
      } catch (err) {
        setError(err.message);
        setData(null);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]); // Re-fetch when URL changes

  return { data, loading, error };
}

// Usage
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

---

## Example 3: useDebounce

Debounce values to limit how often they update.

```jsx
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // Set timeout to update debounced value
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup: clear timeout if value changes before delay
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// Usage: Search with debounce
function SearchBox() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const [results, setResults] = useState([]);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // Perform search only after user stops typing
      fetch(`/api/search?q=${debouncedSearchTerm}`)
        .then(res => res.json())
        .then(data => setResults(data));
    }
  }, [debouncedSearchTerm]);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      <ul>
        {results.map(item => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Example 4: useToggle

Simple boolean state toggle.

```jsx
import { useState, useCallback } from 'react';

function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);

  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return [value, toggle, setTrue, setFalse];
}

// Usage
function Modal() {
  const [isOpen, toggleModal, openModal, closeModal] = useToggle(false);

  return (
    <div>
      <button onClick={openModal}>Open Modal</button>
      
      {isOpen && (
        <div className="modal">
          <h2>Modal Content</h2>
          <button onClick={closeModal}>Close</button>
        </div>
      )}
    </div>
  );
}
```

---

## Example 5: useWindowSize

Track window dimensions.

```jsx
import { useState, useEffect } from 'react';

function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    window.addEventListener('resize', handleResize);
    
    // Cleanup
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}

// Usage
function ResponsiveComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>Window size: {width} x {height}</p>
      {width < 768 ? (
        <MobileView />
      ) : (
        <DesktopView />
      )}
    </div>
  );
}
```

---

## Example 6: useOnClickOutside

Detect clicks outside an element.

```jsx
import { useEffect } from 'react';

function useOnClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      // Do nothing if clicking ref's element or descendants
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      
      handler(event);
    };

    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);

    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler]);
}

// Usage
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useOnClickOutside(dropdownRef, () => setIsOpen(false));

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>Menu</button>
      {isOpen && (
        <div className="dropdown-menu">
          <a href="#1">Item 1</a>
          <a href="#2">Item 2</a>
        </div>
      )}
    </div>
  );
}
```

---

## Example 7: usePrevious

Access previous value of state or props.

```jsx
import { useRef, useEffect } from 'react';

function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

---

## Example 8: useAsync

Handle async operations with loading/error states.

```jsx
import { useState, useEffect, useCallback } from 'react';

function useAsync(asyncFunction, immediate = true) {
  const [status, setStatus] = useState('idle');
  const [value, setValue] = useState(null);
  const [error, setError] = useState(null);

  const execute = useCallback((...params) => {
    setStatus('pending');
    setValue(null);
    setError(null);

    return asyncFunction(...params)
      .then(response => {
        setValue(response);
        setStatus('success');
      })
      .catch(error => {
        setError(error);
        setStatus('error');
      });
  }, [asyncFunction]);

  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [execute, immediate]);

  return { execute, status, value, error };
}

// Usage
function UserProfile({ userId }) {
  const fetchUser = useCallback(() => {
    return fetch(`/api/users/${userId}`).then(res => res.json());
  }, [userId]);

  const { execute, status, value: user, error } = useAsync(fetchUser, true);

  if (status === 'pending') return <div>Loading...</div>;
  if (status === 'error') return <div>Error: {error.message}</div>;
  if (status === 'success') return <div>Hello, {user.name}!</div>;

  return null;
}
```

---

## Example 9: useMediaQuery

Match CSS media queries in React.

```jsx
import { useState, useEffect } from 'react';

function useMediaQuery(query) {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handler = (e) => setMatches(e.matches);

    // Set initial value
    setMatches(mediaQuery.matches);

    // Listen for changes
    mediaQuery.addEventListener('change', handler);

    return () => mediaQuery.removeEventListener('change', handler);
  }, [query]);

  return matches;
}

// Usage
function ResponsiveApp() {
  const isMobile = useMediaQuery('(max-width: 768px)');
  const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
  const isDesktop = useMediaQuery('(min-width: 1025px)');

  return (
    <div>
      {isMobile && <MobileNav />}
      {isTablet && <TabletNav />}
      {isDesktop && <DesktopNav />}
    </div>
  );
}
```

---

## Example 10: useForm

Simplified form handling.

```jsx
import { useState } from 'react';

function useForm(initialValues, onSubmit) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    try {
      await onSubmit(values);
    } catch (err) {
      setErrors(err);
    } finally {
      setIsSubmitting(false);
    }
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };

  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    reset
  };
}

// Usage
function LoginForm() {
  const form = useForm(
    { email: '', password: '' },
    async (values) => {
      const response = await login(values);
      return response;
    }
  );

  return (
    <form onSubmit={form.handleSubmit}>
      <input
        name="email"
        value={form.values.email}
        onChange={form.handleChange}
      />
      <input
        name="password"
        type="password"
        value={form.values.password}
        onChange={form.handleChange}
      />
      <button type="submit" disabled={form.isSubmitting}>
        {form.isSubmitting ? 'Loading...' : 'Login'}
      </button>
    </form>
  );
}
```

---

## Custom Hook Rules

1. **Name must start with "use"** - `useSomething()`
2. **Can call other hooks** - useState, useEffect, etc.
3. **Must follow hook rules** - top level, not in loops/conditions
4. **Return useful values** - state, functions, or objects
5. **Keep them focused** - single responsibility
6. **Make them reusable** - accept parameters

---

## Interview Questions

### Q1: What are custom hooks?
**Answer**: Custom hooks are JavaScript functions that start with "use" and can call other hooks. They extract reusable stateful logic from components, promoting code reuse without changing component hierarchy.

### Q2: When should you create a custom hook?
**Answer**: Create custom hooks when:
- Logic is duplicated across multiple components
- Complex stateful logic needs encapsulation
- Want to share non-visual logic
- Building a reusable library

Don't create for one-time use or simple logic.

### Q3: Can custom hooks return anything?
**Answer**: Yes! Custom hooks can return:
- Single value: `const value = useHook()`
- Array: `const [value, setValue] = useHook()`
- Object: `const { value, loading } = useHook()`

Choose based on convenience and use case.

### Q4: Do custom hooks share state between components?
**Answer**: No! Each call to a custom hook creates **independent state**. If two components use the same custom hook, they have separate state.

To share state, combine custom hooks with Context.

### Q5: Can you use hooks inside custom hooks?
**Answer**: Yes! That's the whole point. Custom hooks can use:
- useState, useEffect, useContext, etc.
- Other custom hooks
- Any React hooks

Just follow the rules of hooks.

### Q6: What's the difference between custom hooks and utilities?
**Answer**:
- **Custom hooks**: Use React hooks, manage state/effects, must start with "use"
- **Utilities**: Plain functions, no hooks, can be called anywhere

```jsx
// Custom hook - uses hooks
function useUser() {
  const [user, setUser] = useState(null);
  return user;
}

// Utility - plain function
function formatDate(date) {
  return date.toLocaleDateString();
}
```

### Q7: Can custom hooks access props?
**Answer**: Yes, by passing props as parameters:

```jsx
function useUserData(userId) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  return user;
}

// Usage
function Profile({ userId }) {
  const user = useUserData(userId);
}
```

---

## Best Practices

1. **Start name with "use"** - convention and linter requirement
2. **Keep focused** - single responsibility
3. **Return useful interface** - array, object, or single value
4. **Accept parameters** - make configurable
5. **Document usage** - JSDoc comments
6. **Handle cleanup** - return cleanup from useEffect
7. **Optimize performance** - useCallback, useMemo when needed
8. **Test independently** - hooks are testable
9. **Use TypeScript** - type parameters and return values
10. **Share in libraries** - publish reusable hooks

---

## Summary

- **Custom hooks** extract reusable stateful logic
- Start with **"use"** prefix
- Can **call other hooks**
- Each call has **independent state**
- Return **values/functions** for component use
- Follow **rules of hooks**
- Great for **code reuse** without HOCs or render props
- Can be **composed** together
- Should be **focused** and single-purpose
- Enable **sharing logic** across components

