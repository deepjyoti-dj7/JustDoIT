# Hooks Best Practices

## Rules of Hooks

### 1. Only Call Hooks at the Top Level

**Don't** call hooks inside loops, conditions, or nested functions.

```jsx
// ❌ Wrong
function Bad({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // Conditional hook!
  }
  
  for (let i = 0; i < 10; i++) {
    useEffect(() => {}); // Hook in loop!
  }
}

// ✅ Correct
function Good({ condition }) {
  const [state, setState] = useState(0);
  
  useEffect(() => {
    if (condition) {
      // Condition inside hook
    }
  }, [condition]);
}
```

**Why?** React relies on hook call order to preserve state between renders.

---

### 2. Only Call Hooks from React Functions

Call hooks from:
- ✅ React function components
- ✅ Custom hooks

**Don't** call hooks from:
- ❌ Regular JavaScript functions
- ❌ Class components
- ❌ Event handlers directly

```jsx
// ❌ Wrong
function regularFunction() {
  const [state, setState] = useState(0); // Not a component!
}

// ✅ Correct
function MyComponent() {
  const [state, setState] = useState(0);
}

function useCustomHook() {
  const [state, setState] = useState(0);
}
```

---

## useState Best Practices

### 1. Initialize with Function for Expensive Computations

```jsx
// ❌ Runs on every render
const [state, setState] = useState(expensiveCalculation());

// ✅ Runs only once
const [state, setState] = useState(() => expensiveCalculation());
```

### 2. Update Based on Previous State

```jsx
// ❌ May have stale values
const increment = () => setState(count + 1);

// ✅ Always uses latest value
const increment = () => setState(prev => prev + 1);
```

### 3. Don't Store Derived Data in State

```jsx
// ❌ Redundant state
const [items, setItems] = useState([]);
const [itemCount, setItemCount] = useState(0);

// Must keep in sync
setItems(newItems);
setItemCount(newItems.length);

// ✅ Calculate derived values
const [items, setItems] = useState([]);
const itemCount = items.length; // Just calculate it
```

### 4. Merge Related State

```jsx
// ❌ Too many separate states
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [age, setAge] = useState(0);
const [email, setEmail] = useState('');

// ✅ Group related data
const [user, setUser] = useState({
  firstName: '',
  lastName: '',
  age: 0,
  email: ''
});
```

---

## useEffect Best Practices

### 1. Always Specify Dependencies

```jsx
// ❌ Missing dependencies
useEffect(() => {
  fetchData(userId); // userId not in deps!
}, []);

// ✅ Include all dependencies
useEffect(() => {
  fetchData(userId);
}, [userId]);
```

### 2. Cleanup Side Effects

```jsx
// ❌ No cleanup - memory leak
useEffect(() => {
  const subscription = subscribe();
}, []);

// ✅ Cleanup subscriptions
useEffect(() => {
  const subscription = subscribe();
  return () => subscription.unsubscribe();
}, []);
```

### 3. Separate Concerns with Multiple useEffect

```jsx
// ❌ Mixing concerns
useEffect(() => {
  fetchUser(userId);
  trackPageView();
  subscribeToUpdates();
}, [userId]);

// ✅ Separate effects
useEffect(() => {
  fetchUser(userId);
}, [userId]);

useEffect(() => {
  trackPageView();
}, []);

useEffect(() => {
  const unsub = subscribeToUpdates();
  return unsub;
}, []);
```

### 4. Move Functions Inside useEffect

```jsx
// ❌ Function in dependencies
function fetchData() {
  // fetch logic
}

useEffect(() => {
  fetchData();
}, [fetchData]); // New function every render!

// ✅ Define inside useEffect
useEffect(() => {
  function fetchData() {
    // fetch logic
  }
  fetchData();
}, []);

// ✅ Or use useCallback
const fetchData = useCallback(() => {
  // fetch logic
}, []);

useEffect(() => {
  fetchData();
}, [fetchData]);
```

---

## Performance Optimization

### 1. Use useMemo for Expensive Calculations

```jsx
// ❌ Recalculates every render
function Component({ items }) {
  const sortedItems = items.sort((a, b) => a.value - b.value);
  return <List items={sortedItems} />;
}

// ✅ Only recalculate when items change
function Component({ items }) {
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => a.value - b.value);
  }, [items]);
  
  return <List items={sortedItems} />;
}
```

### 2. Use useCallback for Function Props

```jsx
// ❌ New function every render
function Parent() {
  const handleClick = () => console.log('clicked');
  return <MemoizedChild onClick={handleClick} />;
}

// ✅ Memoize callback
function Parent() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return <MemoizedChild onClick={handleClick} />;
}
```

### 3. Memoize Components with React.memo

```jsx
// ❌ Re-renders even if props unchanged
function Child({ name }) {
  return <div>{name}</div>;
}

// ✅ Only re-renders if props change
const Child = React.memo(function Child({ name }) {
  return <div>{name}</div>;
});
```

### 4. Don't Optimize Prematurely

```jsx
// ❌ Unnecessary optimization
const sum = useMemo(() => a + b, [a, b]); // Too simple

// ✅ Just calculate it
const sum = a + b;
```

---

## Context Best Practices

### 1. Split Contexts by Frequency of Change

```jsx
// ❌ Everything in one context
const AppContext = createContext();

function Provider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  return (
    <AppContext.Provider value={{ user, theme, setUser, setTheme }}>
      {children}
    </AppContext.Provider>
  );
}

// ✅ Separate contexts
const UserContext = createContext();
const ThemeContext = createContext();

function Providers({ children }) {
  return (
    <UserContext.Provider value={userValue}>
      <ThemeContext.Provider value={themeValue}>
        {children}
      </ThemeContext.Provider>
    </UserContext.Provider>
  );
}
```

### 2. Memoize Context Values

```jsx
// ❌ New object every render
function Provider({ children }) {
  const [user, setUser] = useState(null);
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// ✅ Memoize value
function Provider({ children }) {
  const [user, setUser] = useState(null);
  
  const value = useMemo(() => ({ user, setUser }), [user]);
  
  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}
```

### 3. Create Custom Hooks for Context

```jsx
// ❌ Use context directly
function Component() {
  const context = useContext(UserContext);
  if (!context) throw new Error('...');
  return <div>{context.user.name}</div>;
}

// ✅ Custom hook with validation
function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
}

function Component() {
  const { user } = useUser();
  return <div>{user.name}</div>;
}
```

---

## Custom Hooks Best Practices

### 1. Name with "use" Prefix

```jsx
// ❌ Wrong naming
function fetchData() {
  const [data, setData] = useState(null);
  return data;
}

// ✅ Correct naming
function useData() {
  const [data, setData] = useState(null);
  return data;
}
```

### 2. Return Consistent Interface

```jsx
// ❌ Inconsistent return
function useData(condition) {
  if (condition) {
    return { data, loading };
  }
  return data; // Different return type!
}

// ✅ Consistent return
function useData(condition) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  
  return { data, loading }; // Always same shape
}
```

### 3. Keep Hooks Focused

```jsx
// ❌ Hook doing too much
function useEverything() {
  const user = useUser();
  const theme = useTheme();
  const data = useFetch('/api/data');
  const [count, setCount] = useState(0);
  // Too many responsibilities!
}

// ✅ Focused, single-purpose hooks
function useUser() { /* user logic */ }
function useTheme() { /* theme logic */ }
function useData() { /* data fetching */ }
```

---

## Common Patterns

### 1. Conditional Rendering

```jsx
// ✅ Good pattern
function Component({ isLoading, error, data }) {
  if (isLoading) return <Spinner />;
  if (error) return <Error message={error} />;
  if (!data) return null;
  return <Data value={data} />;
}
```

### 2. Data Fetching

```jsx
// ✅ Comprehensive data fetching
function useDataFetch(url) {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null
  });

  useEffect(() => {
    let cancelled = false;

    const fetchData = async () => {
      setState(prev => ({ ...prev, loading: true }));
      
      try {
        const response = await fetch(url);
        const json = await response.json();
        
        if (!cancelled) {
          setState({ data: json, loading: false, error: null });
        }
      } catch (error) {
        if (!cancelled) {
          setState({ data: null, loading: false, error: error.message });
        }
      }
    };

    fetchData();

    return () => {
      cancelled = true; // Prevent state update on unmounted component
    };
  }, [url]);

  return state;
}
```

### 3. Form Handling

```jsx
// ✅ Reusable form hook
function useForm(initialValues, validate) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
    
    // Validate on change if field was touched
    if (touched[name]) {
      const fieldErrors = validate({ [name]: value });
      setErrors(prev => ({ ...prev, ...fieldErrors }));
    }
  };

  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    
    // Validate on blur
    const fieldErrors = validate({ [name]: values[name] });
    setErrors(prev => ({ ...prev, ...fieldErrors }));
  };

  const handleSubmit = (onSubmit) => async (e) => {
    e.preventDefault();
    
    const validationErrors = validate(values);
    setErrors(validationErrors);
    
    if (Object.keys(validationErrors).length === 0) {
      await onSubmit(values);
    }
  };

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit
  };
}
```

---

## Debugging Tips

### 1. Use React DevTools

- Inspect component hooks
- View hook values in real-time
- Track re-renders

### 2. Log Dependencies

```jsx
// Debug effect dependencies
useEffect(() => {
  console.log('Effect ran with:', { userId, filter });
}, [userId, filter]);
```

### 3. Use useDebugValue

```jsx
function useCustomHook(value) {
  useDebugValue(value, v => `Custom: ${v}`);
  // Shows in DevTools
}
```

### 4. Check for Infinite Loops

```jsx
// ❌ Infinite loop
useEffect(() => {
  setCount(count + 1); // Updates state, triggers re-render, runs effect again!
}, [count]);

// ✅ Use functional update
useEffect(() => {
  setCount(prev => prev + 1);
}, []); // Or remove from deps if intended
```

---

## ESLint Plugin

Install and use `eslint-plugin-react-hooks`:

```bash
npm install eslint-plugin-react-hooks --save-dev
```

```json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

This catches:
- Hooks called conditionally
- Missing dependencies
- Invalid hook usage

---

## Testing Hooks

### Use @testing-library/react-hooks

```jsx
import { renderHook, act } from '@testing-library/react-hooks';

test('useCounter', () => {
  const { result } = renderHook(() => useCounter());
  
  expect(result.current.count).toBe(0);
  
  act(() => {
    result.current.increment();
  });
  
  expect(result.current.count).toBe(1);
});
```

---

## Anti-Patterns to Avoid

### 1. Overusing useEffect

```jsx
// ❌ Don't use effect for derived state
const [items, setItems] = useState([]);
const [count, setCount] = useState(0);

useEffect(() => {
  setCount(items.length);
}, [items]);

// ✅ Just calculate it
const [items, setItems] = useState([]);
const count = items.length;
```

### 2. Modifying State in Render

```jsx
// ❌ Don't modify state during render
function Component() {
  const [count, setCount] = useState(0);
  setCount(count + 1); // Infinite loop!
  return <div>{count}</div>;
}

// ✅ Modify in event handler or effect
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(1);
  }, []);
  
  return <div>{count}</div>;
}
```

### 3. Ignoring Dependency Warnings

```jsx
// ❌ Ignoring ESLint warning
useEffect(() => {
  doSomething(value);
}, []); // ESLint warns about missing 'value'

// ✅ Fix the dependencies
useEffect(() => {
  doSomething(value);
}, [value]);
```

---

## Summary Checklist

### ✅ Do:
- Call hooks at top level
- Use ESLint plugin
- Specify all dependencies
- Clean up effects
- Memoize expensive calculations
- Split contexts by concern
- Name custom hooks with "use"
- Test hooks independently
- Profile before optimizing

### ❌ Don't:
- Call hooks conditionally
- Call hooks in loops
- Ignore dependency warnings
- Overuse optimization hooks
- Store derived state
- Modify state during render
- Forget cleanup functions
- Mix concerns in one effect
- Optimize prematurely

---

## Key Takeaways

1. **Follow Rules of Hooks** - top level, React functions only
2. **Manage Dependencies** - always specify correct dependencies
3. **Clean Up Effects** - prevent memory leaks
4. **Optimize Wisely** - profile first, optimize when needed
5. **Split Concerns** - multiple focused effects > one big effect
6. **Custom Hooks** - extract reusable logic
7. **Context Carefully** - memoize values, split by concern
8. **Test Thoroughly** - hooks are testable
9. **Use Tools** - ESLint, DevTools, testing libraries
10. **Keep Learning** - hooks ecosystem evolving


