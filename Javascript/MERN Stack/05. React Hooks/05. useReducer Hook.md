# useReducer Hook

## What is useReducer?

`useReducer` is a Hook that lets you manage complex state logic using a **reducer function**.

It's an alternative to `useState` when state transitions are complex or the next state depends on the previous one.

---

## Basic Syntax

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

**Parameters:**
- `reducer`: Function `(state, action) => newState`
- `initialState`: Initial state value

**Returns:**
- `state`: Current state
- `dispatch`: Function to trigger state updates

---

## Simple Example: Counter

```jsx
import { useReducer } from 'react';

// Reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return { count: 0 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function Counter() {
  const [state, dispatch] = useReducer(
    counterReducer,
    { count: 0 }
  );

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>
        +
      </button>
      <button onClick={() => dispatch({ type: 'decrement' })}>
        -
      </button>
      <button onClick={() => dispatch({ type: 'reset' })}>
        Reset
      </button>
    </div>
  );
}
```

---

## Reducer Function Pattern

### Basic Structure

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'ACTION_TYPE':
      return newState;
    default:
      return state;
      // or throw new Error('Unknown action');
  }
}
```

### With Payload

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'SET_NAME':
      return { ...state, name: action.payload };
    
    case 'SET_AGE':
      return { ...state, age: action.payload };
    
    case 'UPDATE_USER':
      return { ...state, ...action.payload };
    
    default:
      return state;
  }
}

// Usage
dispatch({ type: 'SET_NAME', payload: 'John' });
dispatch({ type: 'UPDATE_USER', payload: { name: 'John', age: 30 } });
```

---

## Complete Example: Todo List

```jsx
import { useReducer, useState } from 'react';

const initialState = {
  todos: [],
  filter: 'all'
};

function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false
          }
        ]
      };

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };

    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };

    case 'EDIT_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload.id
            ? { ...todo, text: action.payload.text }
            : todo
        )
      };

    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload
      };

    case 'CLEAR_COMPLETED':
      return {
        ...state,
        todos: state.todos.filter(todo => !todo.completed)
      };

    default:
      return state;
  }
}

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  const [input, setInput] = useState('');

  const addTodo = () => {
    if (input.trim()) {
      dispatch({ type: 'ADD_TODO', payload: input });
      setInput('');
    }
  };

  const filteredTodos = state.todos.filter(todo => {
    if (state.filter === 'active') return !todo.completed;
    if (state.filter === 'completed') return todo.completed;
    return true;
  });

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && addTodo()}
      />
      <button onClick={addTodo}>Add</button>

      <div>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'all' })}>
          All
        </button>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'active' })}>
          Active
        </button>
        <button onClick={() => dispatch({ type: 'SET_FILTER', payload: 'completed' })}>
          Completed
        </button>
        <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>
          Clear Completed
        </button>
      </div>

      <ul>
        {filteredTodos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Lazy Initialization

For expensive initial state computation:

```jsx
function init(initialCount) {
  // Expensive computation
  return { count: initialCount * 2 };
}

function Counter({ initialCount }) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  // init runs only once
}
```

---

## useReducer vs useState

### When to use useState

```jsx
// ✅ Simple, independent state
const [name, setName] = useState('');
const [age, setAge] = useState(0);
const [email, setEmail] = useState('');
```

### When to use useReducer

```jsx
// ✅ Complex, related state
const [state, dispatch] = useReducer(reducer, {
  name: '',
  age: 0,
  email: '',
  address: {
    street: '',
    city: ''
  }
});

// Complex state transitions
dispatch({ type: 'UPDATE_PROFILE', payload: userData });
```

**Use useReducer when:**
- State logic is complex
- Multiple sub-values
- Next state depends on previous
- State transitions need to be tested independently
- Want to centralize state logic
- Need predictable state updates

**Use useState when:**
- Simple state updates
- Independent values
- Direct state setting
- No complex logic

---

## Action Creators

Encapsulate action creation for cleaner code:

```jsx
// Action creators
const actions = {
  addTodo: (text) => ({ type: 'ADD_TODO', payload: text }),
  toggleTodo: (id) => ({ type: 'TOGGLE_TODO', payload: id }),
  deleteTodo: (id) => ({ type: 'DELETE_TODO', payload: id }),
  setFilter: (filter) => ({ type: 'SET_FILTER', payload: filter })
};

// Usage
function TodoList() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  return (
    <div>
      <button onClick={() => dispatch(actions.addTodo('New task'))}>
        Add
      </button>
      <button onClick={() => dispatch(actions.setFilter('completed'))}>
        Show Completed
      </button>
    </div>
  );
}
```

---

## Complex Example: Form with Validation

```jsx
const initialFormState = {
  values: {
    username: '',
    email: '',
    password: ''
  },
  errors: {},
  touched: {},
  isSubmitting: false
};

function formReducer(state, action) {
  switch (action.type) {
    case 'CHANGE':
      return {
        ...state,
        values: {
          ...state.values,
          [action.field]: action.value
        }
      };

    case 'BLUR':
      return {
        ...state,
        touched: {
          ...state.touched,
          [action.field]: true
        }
      };

    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.payload
      };

    case 'SUBMIT_START':
      return {
        ...state,
        isSubmitting: true
      };

    case 'SUBMIT_END':
      return {
        ...state,
        isSubmitting: false
      };

    case 'RESET':
      return initialFormState;

    default:
      return state;
  }
}

function RegistrationForm() {
  const [state, dispatch] = useReducer(formReducer, initialFormState);

  const validate = (values) => {
    const errors = {};
    
    if (!values.username) {
      errors.username = 'Required';
    } else if (values.username.length < 3) {
      errors.username = 'Must be at least 3 characters';
    }

    if (!values.email) {
      errors.email = 'Required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Invalid email';
    }

    if (!values.password) {
      errors.password = 'Required';
    } else if (values.password.length < 6) {
      errors.password = 'Must be at least 6 characters';
    }

    return errors;
  };

  const handleChange = (e) => {
    dispatch({
      type: 'CHANGE',
      field: e.target.name,
      value: e.target.value
    });
  };

  const handleBlur = (e) => {
    dispatch({
      type: 'BLUR',
      field: e.target.name
    });

    const errors = validate(state.values);
    dispatch({ type: 'SET_ERRORS', payload: errors });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    const errors = validate(state.values);
    dispatch({ type: 'SET_ERRORS', payload: errors });

    if (Object.keys(errors).length === 0) {
      dispatch({ type: 'SUBMIT_START' });
      
      try {
        await registerUser(state.values);
        dispatch({ type: 'RESET' });
      } catch (error) {
        dispatch({
          type: 'SET_ERRORS',
          payload: { submit: error.message }
        });
      } finally {
        dispatch({ type: 'SUBMIT_END' });
      }
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          name="username"
          value={state.values.username}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Username"
        />
        {state.touched.username && state.errors.username && (
          <span>{state.errors.username}</span>
        )}
      </div>

      <div>
        <input
          name="email"
          type="email"
          value={state.values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Email"
        />
        {state.touched.email && state.errors.email && (
          <span>{state.errors.email}</span>
        )}
      </div>

      <div>
        <input
          name="password"
          type="password"
          value={state.values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        />
        {state.touched.password && state.errors.password && (
          <span>{state.errors.password}</span>
        )}
      </div>

      {state.errors.submit && <div>{state.errors.submit}</div>}

      <button type="submit" disabled={state.isSubmitting}>
        {state.isSubmitting ? 'Submitting...' : 'Register'}
      </button>
    </form>
  );
}
```

---

## useReducer with Context

For global state management:

```jsx
import { createContext, useContext, useReducer } from 'react';

const StoreContext = createContext();

function storeReducer(state, action) {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [...state.notifications, action.payload]
      };
    default:
      return state;
  }
}

function StoreProvider({ children }) {
  const [state, dispatch] = useReducer(storeReducer, {
    user: null,
    theme: 'light',
    notifications: []
  });

  return (
    <StoreContext.Provider value={{ state, dispatch }}>
      {children}
    </StoreContext.Provider>
  );
}

function useStore() {
  const context = useContext(StoreContext);
  if (!context) {
    throw new Error('useStore must be used within StoreProvider');
  }
  return context;
}

// Usage
function App() {
  return (
    <StoreProvider>
      <Header />
      <MainContent />
    </StoreProvider>
  );
}

function Header() {
  const { state, dispatch } = useStore();

  return (
    <header>
      <span>{state.user?.name}</span>
      <button onClick={() => dispatch({ type: 'SET_THEME', payload: 'dark' })}>
        Toggle Theme
      </button>
    </header>
  );
}
```

---

## TypeScript with useReducer

```typescript
type State = {
  count: number;
  error: string | null;
};

type Action =
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'set'; payload: number }
  | { type: 'error'; payload: string };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + 1 };
    case 'decrement':
      return { ...state, count: state.count - 1 };
    case 'set':
      return { ...state, count: action.payload };
    case 'error':
      return { ...state, error: action.payload };
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, {
    count: 0,
    error: null
  });

  // TypeScript ensures type safety
  dispatch({ type: 'increment' }); // ✅
  dispatch({ type: 'set', payload: 10 }); // ✅
  // dispatch({ type: 'unknown' }); // ❌ Error
}
```

---

## Interview Questions

### Q1: What is useReducer?
**Answer**: useReducer is a Hook for managing complex state using a reducer function. It takes a reducer and initial state, returns current state and dispatch function.

### Q2: When should you use useReducer instead of useState?
**Answer**: Use useReducer when:
- State logic is complex with multiple sub-values
- Next state depends on previous state
- Want to centralize state logic
- State transitions need testing separately
- Managing related state values together

Use useState for simple, independent state.

### Q3: What are the parameters of useReducer?
**Answer**:
1. **reducer**: `(state, action) => newState`
2. **initialState**: Initial state value
3. **init** (optional): Lazy initialization function

### Q4: How does useReducer relate to Redux?
**Answer**: useReducer follows the same pattern as Redux:
- Reducer function: `(state, action) => newState`
- Dispatch actions to update state
- Predictable state updates

Differences:
- useReducer is built-in, Redux is external
- Redux has middleware, DevTools, persistence
- useReducer is simpler for local state
- Redux is better for large-scale global state

### Q5: Can you update only part of state in a reducer?
**Answer**: Yes, using spread operator:

```jsx
case 'UPDATE_NAME':
  return { ...state, name: action.payload }; // Other fields unchanged
```

Always return new state object - don't mutate!

### Q6: What's lazy initialization in useReducer?
**Answer**: Passing a third argument (init function) to compute initial state:

```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

`init(initialArg)` runs only once. Useful for expensive computations.

### Q7: How do you combine useReducer with Context?
**Answer**:

```jsx
const Context = createContext();

function Provider({ children }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <Context.Provider value={{ state, dispatch }}>
      {children}
    </Context.Provider>
  );
}
```

This creates a simple state management solution.

---

## Best Practices

1. **Keep reducers pure** - no side effects
2. **Return new state objects** - don't mutate
3. **Handle default case** - throw error or return state
4. **Use action types as constants** to avoid typos
5. **Use action creators** for complex actions
6. **Split large reducers** into smaller ones
7. **Test reducers independently** - they're pure functions
8. **Use TypeScript** for type safety
9. **Combine with Context** for global state
10. **Consider immer** for complex nested updates

---

## Common Patterns

### Action Type Constants

```jsx
const ACTIONS = {
  INCREMENT: 'increment',
  DECREMENT: 'decrement',
  RESET: 'reset'
};

dispatch({ type: ACTIONS.INCREMENT });
```

### Reducer Composition

```jsx
function appReducer(state, action) {
  return {
    user: userReducer(state.user, action),
    todos: todosReducer(state.todos, action),
    settings: settingsReducer(state.settings, action)
  };
}
```

### Immer for Immutability

```jsx
import { useImmerReducer } from 'use-immer';

function reducer(draft, action) {
  switch (action.type) {
    case 'ADD_TODO':
      draft.todos.push(action.payload); // Direct mutation in draft
      break;
  }
}

const [state, dispatch] = useImmerReducer(reducer, initialState);
```

---

## Summary

- **useReducer** manages complex state with reducer function
- **Reducer**: `(state, action) => newState` - pure function
- **dispatch** triggers state updates with actions
- Use for **complex state**, multiple sub-values, or related state
- Combine with **Context** for global state management
- **Action creators** encapsulate action creation
- **Lazy initialization** for expensive initial state
- Reducers are **pure** and **testable**
- Great alternative to **useState** for complex logic
- Can be combined with **TypeScript** for type safety

