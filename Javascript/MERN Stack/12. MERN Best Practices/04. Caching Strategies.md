# 04. Caching Strategies

## Introduction

Caching stores frequently accessed data for faster retrieval. This guide covers caching strategies for MERN applications including browser caching, Redis, and CDN.

---

## Types of Caching

### 1. Browser Caching
- Static assets (images, CSS, JS)
- HTTP headers control caching

### 2. Application Caching (Redis)
- Database query results
- Session data
- API responses

### 3. CDN Caching
- Global content delivery
- Static files distributed worldwide

### 4. Database Caching
- Query result caching
- Connection pooling

---

## Browser Caching

### HTTP Cache Headers

```javascript
// Express - Static files
const express = require('express');
const path = require('path');

const app = express();

// Cache static assets for 1 year
app.use('/static', express.static('public', {
  maxAge: '1y',
  immutable: true
}));

// Custom cache headers
app.get('/api/data', (req, res) => {
  res.set('Cache-Control', 'public, max-age=300'); // 5 minutes
  res.json({ data: 'cached data' });
});

// No cache for sensitive data
app.get('/api/user/profile', (req, res) => {
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.json({ user: userData });
});
```

### Cache-Control Directives

```
Cache-Control: public, max-age=31536000, immutable
              │      │             └─ Never revalidate
              │      └─────────── Cache for 1 year
              └─────────────────── Can be cached by anyone
```

**Directives**:
- `public`: Can be cached by browsers and CDNs
- `private`: Only browser can cache
- `no-cache`: Must revalidate before use
- `no-store`: Don't cache at all
- `max-age=3600`: Cache for 3600 seconds
- `immutable`: Never changes, no revalidation needed

---

## Redis Caching

### Setup

```bash
# Install Redis
sudo apt install redis-server  # Ubuntu
brew install redis              # macOS

# Start Redis
redis-server

# Install Node.js client
npm install redis
```

### Basic Usage

```javascript
const redis = require('redis');
const client = redis.createClient({
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD
});

client.on('connect', () => {
  console.log('Redis connected');
});

client.on('error', (err) => {
  console.error('Redis error:', err);
});

module.exports = client;
```

### Caching API Responses

```javascript
const redis = require('./config/redis');

// Middleware for caching
const cacheMiddleware = (duration) => {
  return async (req, res, next) => {
    const key = `cache:${req.originalUrl}`;
    
    try {
      const cachedData = await redis.get(key);
      
      if (cachedData) {
        console.log('Cache hit');
        return res.json(JSON.parse(cachedData));
      }
      
      console.log('Cache miss');
      // Store original send function
      const originalSend = res.json;
      
      // Override send to cache response
      res.json = function(data) {
        redis.setex(key, duration, JSON.stringify(data));
        originalSend.call(this, data);
      };
      
      next();
    } catch (error) {
      console.error('Cache error:', error);
      next();
    }
  };
};

// Usage
app.get('/api/users', cacheMiddleware(300), async (req, res) => {
  const users = await User.find().select('-password');
  res.json(users);
});
```

### Caching Database Queries

```javascript
const User = require('./models/User');
const redis = require('./config/redis');

// Get user with caching
async function getUserById(userId) {
  const cacheKey = `user:${userId}`;
  
  // Check cache
  const cached = await redis.get(cacheKey);
  if (cached) {
    console.log('Cache hit');
    return JSON.parse(cached);
  }
  
  // Query database
  console.log('Cache miss - querying database');
  const user = await User.findById(userId).select('-password').lean();
  
  // Store in cache (expire after 1 hour)
  await redis.setex(cacheKey, 3600, JSON.stringify(user));
  
  return user;
}

// Invalidate cache on update
async function updateUser(userId, updates) {
  const user = await User.findByIdAndUpdate(userId, updates, { new: true });
  
  // Invalidate cache
  await redis.del(`user:${userId}`);
  
  return user;
}
```

### Cache Patterns

**1. Cache-Aside (Lazy Loading)**
```javascript
async function getData(key) {
  // Check cache
  let data = await redis.get(key);
  
  if (!data) {
    // Load from database
    data = await db.query(key);
    // Store in cache
    await redis.set(key, JSON.stringify(data));
  }
  
  return JSON.parse(data);
}
```

**2. Write-Through**
```javascript
async function saveData(key, value) {
  // Write to database
  await db.save(key, value);
  // Write to cache
  await redis.set(key, JSON.stringify(value));
}
```

**3. Write-Behind (Write-Back)**
```javascript
async function saveData(key, value) {
  // Write to cache immediately
  await redis.set(key, JSON.stringify(value));
  // Write to database asynchronously
  setImmediate(() => db.save(key, value));
}
```

### Cache Invalidation

```javascript
// Delete single key
await redis.del('user:123');

// Delete multiple keys
await redis.del(['user:123', 'user:456']);

// Delete by pattern
const keys = await redis.keys('user:*');
if (keys.length > 0) {
  await redis.del(keys);
}

// Set expiration
await redis.expire('user:123', 3600); // 1 hour

// Check TTL
const ttl = await redis.ttl('user:123');
console.log(`Expires in ${ttl} seconds`);
```

---

## Session Caching

```javascript
const session = require('express-session');
const RedisStore = require('connect-redis')(session);
const redis = require('redis');

const redisClient = redis.createClient();

app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24 // 24 hours
  }
}));
```

---

## Frontend Caching (React)

### React Query

```javascript
import { useQuery, useMutation, useQueryClient } from 'react-query';

function Users() {
  const queryClient = useQueryClient();
  
  // Fetch with caching
  const { data, isLoading } = useQuery(
    'users',
    () => fetch('/api/users').then(res => res.json()),
    {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    }
  );
  
  // Mutation with cache invalidation
  const mutation = useMutation(
    (newUser) => fetch('/api/users', {
      method: 'POST',
      body: JSON.stringify(newUser)
    }),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users');
      }
    }
  );
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div>
      {data.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}
```

### Local Storage Caching

```javascript
// Cache utility
const cache = {
  set: (key, value, ttl) => {
    const item = {
      value,
      expiry: Date.now() + ttl
    };
    localStorage.setItem(key, JSON.stringify(item));
  },
  
  get: (key) => {
    const item = localStorage.getItem(key);
    if (!item) return null;
    
    const { value, expiry } = JSON.parse(item);
    
    if (Date.now() > expiry) {
      localStorage.removeItem(key);
      return null;
    }
    
    return value;
  },
  
  remove: (key) => {
    localStorage.removeItem(key);
  }
};

// Usage
function useCachedData(key, fetcher, ttl = 5 * 60 * 1000) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const cached = cache.get(key);
    
    if (cached) {
      setData(cached);
      setLoading(false);
    } else {
      fetcher().then(result => {
        cache.set(key, result, ttl);
        setData(result);
        setLoading(false);
      });
    }
  }, [key]);
  
  return { data, loading };
}
```

---

## CDN Caching

### CloudFlare Example

```javascript
// Set cache headers for CDN
app.get('/api/public/posts', (req, res) => {
  res.set('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
  res.set('CDN-Cache-Control', 'max-age=86400'); // CDN caches for 24 hours
  res.json(posts);
});

// Bypass cache
app.get('/api/user/profile', (req, res) => {
  res.set('Cache-Control', 'private, no-cache');
  res.json(userProfile);
});
```

---

## Best Practices

### 1. Cache Expiration
- Set appropriate TTL values
- Shorter for frequently updated data
- Longer for static content

### 2. Cache Invalidation
- Invalidate on updates
- Use versioned keys
- Implement cache warming

### 3. Cache Hierarchy
```
Browser Cache (fastest, smallest)
  ↓
CDN Cache (fast, distributed)
  ↓
Application Cache (Redis)
  ↓
Database Query Cache
  ↓
Database (slowest, source of truth)
```

### 4. Avoid Cache Stampede

```javascript
// Use locking to prevent multiple queries
const locks = new Map();

async function getDataWithLock(key) {
  // Check cache
  let data = await redis.get(key);
  if (data) return JSON.parse(data);
  
  // Acquire lock
  if (locks.has(key)) {
    // Wait for existing request
    return locks.get(key);
  }
  
  // Create promise for this request
  const promise = (async () => {
    const result = await db.query(key);
    await redis.setex(key, 3600, JSON.stringify(result));
    locks.delete(key);
    return result;
  })();
  
  locks.set(key, promise);
  return promise;
}
```

---

## Interview Questions

**Q1: What is caching?**
- Storing frequently accessed data in fast storage
- Reduces database load
- Improves response time

**Q2: Redis vs Memcached?**
- **Redis**: Persistence, data structures, pub/sub
- **Memcached**: Simple key-value, faster for simple use cases

**Q3: Cache invalidation strategies?**
- **Time-based**: TTL expiration
- **Event-based**: Invalidate on update/delete
- **Manual**: Clear cache explicitly

**Q4: What is cache stampede?**
- Multiple requests query DB when cache expires
- Solution: Locking, staggered expiration

**Q5: Cache-Control directives?**
- `public`: Can be cached by anyone
- `private`: Browser only
- `max-age`: Cache duration
- `no-cache`: Revalidate before use
- `no-store`: Don't cache

---

## Summary

- **Browser**: HTTP headers (Cache-Control, max-age)
- **Redis**: Application-level caching, session storage
- **Patterns**: Cache-aside, write-through, write-behind
- **Invalidation**: TTL, event-based, manual
- **Frontend**: React Query, LocalStorage
- **CDN**: Global content delivery
- **Best Practice**: Set TTL, invalidate on updates, cache hierarchy
