# 02. Code Splitting & Lazy Loading

## Introduction

Code splitting and lazy loading improve application performance by loading only necessary code. This reduces initial bundle size and speeds up page loads. This guide covers techniques for React applications.

---

## Why Code Splitting?

### Problems with Large Bundles

**Without Code Splitting**:
```
bundle.js (500 KB)
├─ Home component (50 KB)
├─ Dashboard component (100 KB)
├─ Admin Panel (150 KB)
├─ User Profile (80 KB)
└─ Other components (120 KB)

User visits home page → Downloads entire 500 KB
```

**With Code Splitting**:
```
Initial bundle (100 KB)
├─ Home component (50 KB)
├─ Core utilities (50 KB)

Lazy loaded:
├─ Dashboard.chunk.js (100 KB) - loads on /dashboard
├─ Admin.chunk.js (150 KB) - loads on /admin
└─ Profile.chunk.js (80 KB) - loads on /profile

User visits home page → Downloads 100 KB (80% reduction!)
```

### Benefits

1. **Faster Initial Load**: Smaller initial bundle
2. **Better Performance**: Load code on demand
3. **Improved UX**: Faster Time to Interactive (TTI)
4. **Reduced Bandwidth**: Users download only what they need
5. **Better Caching**: Smaller chunks cache better

---

## React.lazy() and Suspense

### Basic Example

```javascript
import React, { lazy, Suspense } from 'react';

// Regular import (included in main bundle)
import Home from './pages/Home';

// Lazy import (separate chunk)
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));
const Settings = lazy(() => import('./pages/Settings'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dashboard />
    </Suspense>
  );
}
```

### With React Router

```javascript
import React, { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import LoadingSpinner from './components/LoadingSpinner';

// Lazy load route components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const UserProfile = lazy(() => import('./pages/UserProfile'));
const AdminPanel = lazy(() => import('./pages/AdminPanel'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile/:id" element={<UserProfile />} />
          <Route path="/admin" element={<AdminPanel />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}

export default App;
```

### Better Loading Fallback

```javascript
// components/LoadingSpinner.jsx
function LoadingSpinner() {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Loading...</p>
    </div>
  );
}

// components/PageLoader.jsx
function PageLoader() {
  return (
    <div className="page-loader">
      <div className="skeleton">
        <div className="skeleton-header"></div>
        <div className="skeleton-content"></div>
        <div className="skeleton-content"></div>
      </div>
    </div>
  );
}
```

---

## Nested Suspense

### Multiple Loading States

```javascript
import React, { lazy, Suspense } from 'react';

const Sidebar = lazy(() => import('./components/Sidebar'));
const MainContent = lazy(() => import('./components/MainContent'));
const Comments = lazy(() => import('./components/Comments'));

function Dashboard() {
  return (
    <div className="dashboard">
      <Suspense fallback={<div>Loading sidebar...</div>}>
        <Sidebar />
      </Suspense>
      
      <Suspense fallback={<div>Loading content...</div>}>
        <MainContent />
        
        <Suspense fallback={<div>Loading comments...</div>}>
          <Comments />
        </Suspense>
      </Suspense>
    </div>
  );
}
```

---

## Route-Based Code Splitting

### Complete Example

```javascript
import React, { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import Layout from './components/Layout';
import LoadingSpinner from './components/LoadingSpinner';

// Public routes - loaded immediately
import Login from './pages/Login';
import Register from './pages/Register';

// Private routes - lazy loaded
const Dashboard = lazy(() => import('./pages/Dashboard'));
const UserList = lazy(() => import('./pages/users/UserList'));
const UserDetail = lazy(() => import('./pages/users/UserDetail'));
const PostList = lazy(() => import('./pages/posts/PostList'));
const PostCreate = lazy(() => import('./pages/posts/PostCreate'));
const Settings = lazy(() => import('./pages/Settings'));
const AdminPanel = lazy(() => import('./pages/admin/AdminPanel'));

// Wrapper for lazy routes
const LazyRoute = ({ children }) => (
  <Suspense fallback={<LoadingSpinner />}>
    {children}
  </Suspense>
);

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public routes */}
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        
        {/* Protected routes with lazy loading */}
        <Route path="/" element={<Layout />}>
          <Route index element={
            <LazyRoute><Dashboard /></LazyRoute>
          } />
          
          <Route path="users">
            <Route index element={
              <LazyRoute><UserList /></LazyRoute>
            } />
            <Route path=":id" element={
              <LazyRoute><UserDetail /></LazyRoute>
            } />
          </Route>
          
          <Route path="posts">
            <Route index element={
              <LazyRoute><PostList /></LazyRoute>
            } />
            <Route path="new" element={
              <LazyRoute><PostCreate /></LazyRoute>
            } />
          </Route>
          
          <Route path="settings" element={
            <LazyRoute><Settings /></LazyRoute>
          } />
          
          <Route path="admin" element={
            <LazyRoute><AdminPanel /></LazyRoute>
          } />
        </Route>
        
        <Route path="*" element={<Navigate to="/" />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

---

## Component-Based Code Splitting

### Modal Example

```javascript
import React, { lazy, Suspense, useState } from 'react';

// Modal loaded only when opened
const Modal = lazy(() => import('./components/Modal'));
const UserEditForm = lazy(() => import('./components/UserEditForm'));

function UserList() {
  const [showModal, setShowModal] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowModal(true)}>Edit User</button>
      
      {showModal && (
        <Suspense fallback={<div>Loading form...</div>}>
          <Modal onClose={() => setShowModal(false)}>
            <UserEditForm />
          </Modal>
        </Suspense>
      )}
    </div>
  );
}
```

### Tab-Based Loading

```javascript
import React, { lazy, Suspense, useState } from 'react';

const ProfileTab = lazy(() => import('./tabs/ProfileTab'));
const SettingsTab = lazy(() => import('./tabs/SettingsTab'));
const ActivityTab = lazy(() => import('./tabs/ActivityTab'));

function UserProfile() {
  const [activeTab, setActiveTab] = useState('profile');
  
  const renderTab = () => {
    switch (activeTab) {
      case 'profile':
        return <ProfileTab />;
      case 'settings':
        return <SettingsTab />;
      case 'activity':
        return <ActivityTab />;
      default:
        return null;
    }
  };
  
  return (
    <div>
      <nav>
        <button onClick={() => setActiveTab('profile')}>Profile</button>
        <button onClick={() => setActiveTab('settings')}>Settings</button>
        <button onClick={() => setActiveTab('activity')}>Activity</button>
      </nav>
      
      <Suspense fallback={<div>Loading tab...</div>}>
        {renderTab()}
      </Suspense>
    </div>
  );
}
```

---

## Named Exports with Lazy Loading

### Problem & Solution

```javascript
// components/Charts.js
export const LineChart = () => { ... };
export const BarChart = () => { ... };
export const PieChart = () => { ... };

// ❌ Won't work - lazy needs default export
const LineChart = lazy(() => import('./components/Charts').LineChart);

// ✅ Solution 1: Re-export as default
const LineChart = lazy(() => 
  import('./components/Charts').then(module => ({ default: module.LineChart }))
);

// ✅ Solution 2: Create separate files
// components/LineChart.js
export default function LineChart() { ... }

const LineChart = lazy(() => import('./components/LineChart'));
```

---

## Prefetching and Preloading

### Magic Comments

```javascript
// Prefetch - load when browser is idle
const AdminPanel = lazy(() => 
  import(/* webpackPrefetch: true */ './pages/AdminPanel')
);

// Preload - load immediately with parent
const Dashboard = lazy(() => 
  import(/* webpackPreload: true */ './pages/Dashboard')
);

// Chunk name for better debugging
const UserProfile = lazy(() => 
  import(/* webpackChunkName: "user-profile" */ './pages/UserProfile')
);
```

### Manual Prefetch

```javascript
// Prefetch on hover
function NavLink({ to, children }) {
  const handleMouseEnter = () => {
    // Prefetch component
    import(`./pages/${to}`);
  };
  
  return (
    <Link to={to} onMouseEnter={handleMouseEnter}>
      {children}
    </Link>
  );
}
```

---

## Library Code Splitting

### Heavy Libraries

```javascript
// Load chart library only when needed
import React, { lazy, Suspense, useState } from 'react';

const Chart = lazy(() => import('./components/Chart'));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowChart(true)}>Show Chart</button>
      
      {showChart && (
        <Suspense fallback={<div>Loading chart...</div>}>
          <Chart />
        </Suspense>
      )}
    </div>
  );
}

// components/Chart.jsx
import { Line } from 'react-chartjs-2';
import 'chart.js/auto';

function Chart({ data }) {
  return <Line data={data} />;
}

export default Chart;
```

---

## Error Boundaries with Lazy Loading

```javascript
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Lazy loading error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h2>Something went wrong loading this component.</h2>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage
function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingSpinner />}>
        <LazyComponent />
      </Suspense>
    </ErrorBoundary>
  );
}
```

---

## Bundle Analysis

### Analyze Bundle Size

```bash
# Install bundle analyzer
npm install --save-dev webpack-bundle-analyzer

# Analyze
npm run build
npx webpack-bundle-analyzer build/bundle-stats.json
```

### Create React App

```bash
# Generate stats
npm run build -- --stats

# Analyze
npx webpack-bundle-analyzer build/bundle-stats.json
```

---

## Best Practices

### 1. Route-Based Splitting (Primary)

Split by routes first - biggest impact.

### 2. Component-Based Splitting (Secondary)

Split heavy components (charts, editors, modals).

### 3. Don't Over-Split

```javascript
// ❌ Too granular
const Button = lazy(() => import('./Button'));

// ✅ Keep small components in main bundle
import Button from './Button';
```

### 4. Meaningful Loading States

```javascript
// ❌ Generic
<Suspense fallback={<div>Loading...</div>}>

// ✅ Specific and informative
<Suspense fallback={<DashboardSkeleton />}>
```

### 5. Error Boundaries

Always wrap lazy components in error boundaries.

### 6. Prefetch Important Routes

Prefetch routes users are likely to visit next.

---

## Interview Questions

**Q1: What is code splitting?**
- Breaking bundle into smaller chunks
- Load code on demand
- Reduces initial bundle size

**Q2: How to implement lazy loading in React?**
```javascript
const Component = lazy(() => import('./Component'));
<Suspense fallback={<Loading />}>
  <Component />
</Suspense>
```

**Q3: When to use code splitting?**
- Route-based: Different pages
- Component-based: Heavy components (charts, editors)
- Library-based: Large third-party libraries

**Q4: Difference between prefetch and preload?**
- **Prefetch**: Load when browser idle (future navigation)
- **Preload**: Load immediately with parent (high priority)

**Q5: What is Suspense?**
- React component for handling loading states
- Shows fallback while lazy component loads
- Can be nested for granular loading

---

## Summary

- **React.lazy()**: Dynamic import for components
- **Suspense**: Handle loading states with fallback
- **Route-Based**: Split by routes (biggest impact)
- **Component-Based**: Split heavy components
- **Prefetch**: Load when idle (webpackPrefetch)
- **Error Boundaries**: Handle loading failures
- **Best Practice**: Don't over-split, meaningful loading states
