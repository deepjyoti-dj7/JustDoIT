# 01. Project Structure & Organization

## Introduction

A well-organized project structure improves maintainability, scalability, and team collaboration. This guide covers best practices for structuring MERN stack applications.

---

## Monorepo vs Separate Repositories

### Monorepo (Single Repository)

```
mern-app/
  client/          # React frontend
  server/          # Node.js backend
  shared/          # Shared utilities/types
  package.json     # Root package.json
```

**Pros**:
- Single git repository
- Easier code sharing
- Coordinated versioning
- Simpler CI/CD

**Cons**:
- Larger repository size
- Can be complex at scale
- Requires build tools (Lerna, Nx)

### Separate Repositories

```
mern-app-frontend/   # React repo
mern-app-backend/    # Node.js repo
```

**Pros**:
- Independent deployment
- Smaller, focused repos
- Team autonomy
- Easier access control

**Cons**:
- Harder to share code
- Need separate CI/CD pipelines
- Version coordination needed

---

## Backend Structure (Node.js/Express)

### Feature-Based Structure (Recommended)

```
backend/
  src/
    config/
      database.js
      env.js
      passport.js
    features/
      auth/
        auth.controller.js
        auth.service.js
        auth.routes.js
        auth.model.js
        auth.validation.js
        auth.test.js
      users/
        user.controller.js
        user.service.js
        user.routes.js
        user.model.js
        user.validation.js
        user.test.js
      posts/
        post.controller.js
        post.service.js
        post.routes.js
        post.model.js
        post.test.js
    middleware/
      auth.middleware.js
      error.middleware.js
      validation.middleware.js
    utils/
      logger.js
      email.js
      constants.js
    app.js
    server.js
  tests/
    integration/
    unit/
  .env
  .env.example
  .gitignore
  package.json
  README.md
```

### Layer-Based Structure (Traditional)

```
backend/
  src/
    controllers/
      auth.controller.js
      user.controller.js
      post.controller.js
    models/
      User.js
      Post.js
    routes/
      auth.routes.js
      user.routes.js
      post.routes.js
    services/
      auth.service.js
      user.service.js
      email.service.js
    middleware/
      auth.js
      error.js
    utils/
      logger.js
    config/
      database.js
    app.js
    server.js
```

### File Responsibilities

**server.js** - Entry point
```javascript
const app = require('./app');
const connectDB = require('./config/database');

connectDB();

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

**app.js** - Express app configuration
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const errorMiddleware = require('./middleware/error.middleware');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Routes
app.use('/api/auth', require('./features/auth/auth.routes'));
app.use('/api/users', require('./features/users/user.routes'));
app.use('/api/posts', require('./features/posts/post.routes'));

// Error handling
app.use(errorMiddleware);

module.exports = app;
```

**controller.js** - Handle HTTP requests
```javascript
const userService = require('./user.service');

exports.getUsers = async (req, res, next) => {
  try {
    const users = await userService.getAllUsers();
    res.json(users);
  } catch (error) {
    next(error);
  }
};

exports.getUserById = async (req, res, next) => {
  try {
    const user = await userService.getUserById(req.params.id);
    res.json(user);
  } catch (error) {
    next(error);
  }
};
```

**service.js** - Business logic
```javascript
const User = require('./user.model');

exports.getAllUsers = async () => {
  return await User.find().select('-password');
};

exports.getUserById = async (id) => {
  const user = await User.findById(id).select('-password');
  if (!user) {
    throw new Error('User not found');
  }
  return user;
};

exports.createUser = async (userData) => {
  const user = new User(userData);
  await user.save();
  return user;
};
```

**routes.js** - Define endpoints
```javascript
const express = require('express');
const router = express.Router();
const userController = require('./user.controller');
const authMiddleware = require('../../middleware/auth.middleware');
const { validateUser } = require('./user.validation');

router.get('/', authMiddleware, userController.getUsers);
router.get('/:id', authMiddleware, userController.getUserById);
router.post('/', validateUser, userController.createUser);
router.put('/:id', authMiddleware, validateUser, userController.updateUser);
router.delete('/:id', authMiddleware, userController.deleteUser);

module.exports = router;
```

**model.js** - Database schema
```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  }
}, { timestamps: true });

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

module.exports = mongoose.model('User', userSchema);
```

---

## Frontend Structure (React)

### Feature-Based Structure (Recommended)

```
frontend/
  public/
    index.html
    favicon.ico
  src/
    features/
      auth/
        Login.jsx
        Register.jsx
        authSlice.js        # Redux slice
        authAPI.js          # API calls
        authHooks.js        # Custom hooks
      users/
        UserList.jsx
        UserProfile.jsx
        userSlice.js
        userAPI.js
      posts/
        PostList.jsx
        PostDetail.jsx
        CreatePost.jsx
        postSlice.js
        postAPI.js
    components/
      common/
        Button.jsx
        Input.jsx
        Modal.jsx
        Navbar.jsx
      layout/
        Header.jsx
        Footer.jsx
        Sidebar.jsx
    hooks/
      useAuth.js
      useFetch.js
      useDebounce.js
    services/
      api.js              # Axios instance
      auth.service.js
      user.service.js
    utils/
      constants.js
      helpers.js
      validators.js
    store/
      store.js            # Redux store
    routes/
      AppRoutes.jsx
      PrivateRoute.jsx
    styles/
      global.css
      variables.css
    App.jsx
    index.js
  .env
  .env.example
  .gitignore
  package.json
```

### Component Organization

**Component Folder Pattern**
```
components/
  Button/
    Button.jsx
    Button.test.jsx
    Button.module.css
    index.js            # Export
```

**index.js** (Barrel export)
```javascript
export { default } from './Button';
```

### Redux Structure

```
store/
  store.js
  slices/
    authSlice.js
    userSlice.js
    postSlice.js
```

**authSlice.js**
```javascript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import authAPI from '../../features/auth/authAPI';

export const login = createAsyncThunk(
  'auth/login',
  async (credentials, { rejectWithValue }) => {
    try {
      const response = await authAPI.login(credentials);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState: {
    user: null,
    token: null,
    loading: false,
    error: null
  },
  reducers: {
    logout: (state) => {
      state.user = null;
      state.token = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(login.pending, (state) => {
        state.loading = true;
      })
      .addCase(login.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload.user;
        state.token = action.payload.token;
      })
      .addCase(login.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  }
});

export const { logout } = authSlice.actions;
export default authSlice.reducer;
```

---

## Naming Conventions

### Backend

```javascript
// Files: camelCase or kebab-case
user.controller.js
auth.service.js
error.middleware.js

// Variables & Functions: camelCase
const getUserById = async (id) => { ... };
const userService = require('./user.service');

// Classes & Models: PascalCase
class UserService { ... }
const User = mongoose.model('User', userSchema);

// Constants: UPPER_SNAKE_CASE
const MAX_LOGIN_ATTEMPTS = 5;
const JWT_SECRET = process.env.JWT_SECRET;
```

### Frontend

```javascript
// Components: PascalCase
UserProfile.jsx
LoginForm.jsx

// Hooks: camelCase with 'use' prefix
useAuth.js
useFetch.js

// Utils & Services: camelCase
api.js
auth.service.js

// CSS Modules: same as component
UserProfile.module.css
```

---

## Configuration Management

### Environment Variables

**.env.example** (Backend)
```bash
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/myapp
JWT_SECRET=your_jwt_secret_here
JWT_EXPIRE=7d
CLIENT_URL=http://localhost:3000
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
```

**.env.example** (Frontend)
```bash
REACT_APP_API_URL=http://localhost:5000/api
REACT_APP_ENVIRONMENT=development
```

### Config File

```javascript
// config/env.js
module.exports = {
  env: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 5000,
  database: {
    uri: process.env.MONGO_URI,
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true
    }
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expire: process.env.JWT_EXPIRE || '7d'
  },
  client: {
    url: process.env.CLIENT_URL || 'http://localhost:3000'
  }
};
```

---

## Package.json Scripts

### Backend

```json
{
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.js",
    "lint:fix": "eslint src/**/*.js --fix",
    "format": "prettier --write \"src/**/*.js\""
  }
}
```

### Frontend

```json
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "test:coverage": "react-scripts test --coverage --watchAll=false",
    "lint": "eslint src/**/*.{js,jsx}",
    "lint:fix": "eslint src/**/*.{js,jsx} --fix",
    "format": "prettier --write \"src/**/*.{js,jsx,css}\""
  }
}
```

---

## Best Practices

### 1. Separation of Concerns
- **Controllers**: Handle requests/responses
- **Services**: Business logic
- **Models**: Data structure
- **Routes**: API endpoints

### 2. DRY (Don't Repeat Yourself)
- Extract reusable code into utilities
- Use shared components
- Create custom hooks

### 3. Single Responsibility
- Each file/function does one thing
- Small, focused modules

### 4. Consistent Naming
- Follow team conventions
- Use descriptive names
- Avoid abbreviations

### 5. Documentation
- README.md in each major folder
- Comment complex logic
- API documentation (Swagger)

---

## Interview Questions

**Q1: Feature-based vs Layer-based structure?**
- **Feature-based**: Group by feature/domain (auth/, users/)
- **Layer-based**: Group by type (controllers/, models/)
- Feature-based scales better for large apps

**Q2: Where to put business logic?**
- **Service layer**, not in controllers
- Controllers only handle HTTP
- Services contain reusable business logic

**Q3: How to organize shared code?**
- `utils/` for pure functions
- `middleware/` for Express middleware
- `components/common/` for shared React components
- `shared/` folder in monorepo

**Q4: Monorepo vs separate repos?**
- Monorepo: easier code sharing, coordinated releases
- Separate: independent deployment, team autonomy
- Use monorepo for small-medium projects

**Q5: Where to put API calls in React?**
- Create `services/` or `api/` folder
- Use Axios instance with interceptors
- Can also use RTK Query or React Query

---

## Summary

- **Structure**: Feature-based (recommended) or layer-based
- **Backend**: Controllers, services, models, routes separation
- **Frontend**: Features, components, hooks, services organization
- **Naming**: Consistent conventions (camelCase, PascalCase)
- **Config**: Environment variables, config files
- **Best Practice**: Separation of concerns, DRY, single responsibility
