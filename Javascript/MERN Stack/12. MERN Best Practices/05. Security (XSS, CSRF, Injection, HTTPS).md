# 05. Security (XSS, CSRF, Injection, HTTPS)

## Introduction

Security is critical for protecting user data and preventing attacks. This guide covers common vulnerabilities (XSS, CSRF, SQL/NoSQL injection) and best practices for MERN applications.

---

## Cross-Site Scripting (XSS)

### What is XSS?

Attacker injects malicious scripts into web pages viewed by other users.

### Types

**1. Stored XSS** - Stored in database
```javascript
// User submits malicious comment
comment = "<script>alert('XSS')</script>";
// Stored in DB, executed when others view
```

**2. Reflected XSS** - In URL parameters
```javascript
// URL: /search?q=<script>alert('XSS')</script>
// Immediately reflected in response
```

**3. DOM-based XSS** - Client-side manipulation
```javascript
// Vulnerable code
document.getElementById('output').innerHTML = userInput;
```

### Prevention

**Backend - Input Sanitization**
```javascript
const validator = require('validator');
const xss = require('xss');

// Sanitize input
app.post('/api/comments', (req, res) => {
  const comment = xss(req.body.comment); // Remove dangerous HTML
  const email = validator.normalizeEmail(req.body.email);
  
  // Validate
  if (!validator.isEmail(email)) {
    return res.status(400).json({ error: 'Invalid email' });
  }
  
  // Save sanitized data
  Comment.create({ comment, email });
});
```

**Frontend - React (Automatic Escaping)**
```javascript
// ✅ React automatically escapes
function Comment({ text }) {
  return <div>{text}</div>; // Safe - escaped
}

// ❌ Dangerous - bypasses escaping
function Comment({ text }) {
  return <div dangerouslySetInnerHTML={{ __html: text }} />;
}

// ✅ If HTML needed, sanitize first
import DOMPurify from 'dompurify';

function Comment({ text }) {
  const sanitized = DOMPurify.sanitize(text);
  return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
}
```

**Content Security Policy (CSP)**
```javascript
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'", "trusted-cdn.com"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'", "api.example.com"],
  }
}));
```

---

## Cross-Site Request Forgery (CSRF)

### What is CSRF?

Attacker tricks user into making unwanted requests to authenticated site.

**Example Attack**:
```html
<!-- Malicious site -->
<img src="https://bank.com/transfer?to=attacker&amount=1000" />
<!-- If user is logged into bank.com, transfer executes! -->
```

### Prevention

**1. CSRF Tokens**
```javascript
const csrf = require('csurf');
const cookieParser = require('cookie-parser');

// Setup
const csrfProtection = csrf({ cookie: true });
app.use(cookieParser());
app.use(csrfProtection);

// Send token to client
app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});

// Verify token on submission
app.post('/submit', csrfProtection, (req, res) => {
  // Token automatically verified
  res.send('Data processed');
});
```

**Frontend - Include Token**
```javascript
// In form
<form method="POST" action="/submit">
  <input type="hidden" name="_csrf" value={csrfToken} />
  <button type="submit">Submit</button>
</form>

// In Axios
axios.defaults.headers.common['X-CSRF-TOKEN'] = csrfToken;

axios.post('/api/data', formData);
```

**2. SameSite Cookies**
```javascript
app.use(session({
  cookie: {
    sameSite: 'strict', // or 'lax'
    secure: true,
    httpOnly: true
  }
}));
```

**3. Check Referer/Origin**
```javascript
app.use((req, res, next) => {
  const allowedOrigins = ['https://myapp.com'];
  const origin = req.headers.origin;
  
  if (req.method !== 'GET' && !allowedOrigins.includes(origin)) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  next();
});
```

---

## SQL/NoSQL Injection

### SQL Injection

```javascript
// ❌ Vulnerable
const query = `SELECT * FROM users WHERE email = '${email}'`;
// Attacker input: ' OR '1'='1
// Result: SELECT * FROM users WHERE email = '' OR '1'='1'

// ✅ Use parameterized queries
const query = 'SELECT * FROM users WHERE email = ?';
db.query(query, [email]);
```

### NoSQL Injection (MongoDB)

```javascript
// ❌ Vulnerable
app.post('/login', (req, res) => {
  User.findOne({ email: req.body.email, password: req.body.password });
});
// Attacker sends: { "email": { "$ne": null }, "password": { "$ne": null } }
// Matches any user!

// ✅ Sanitize input
const mongoSanitize = require('express-mongo-sanitize');

app.use(mongoSanitize()); // Removes $ and . from req.body, req.params, req.query

// ✅ Validate input types
app.post('/login', (req, res) => {
  const { email, password } = req.body;
  
  if (typeof email !== 'string' || typeof password !== 'string') {
    return res.status(400).json({ error: 'Invalid input' });
  }
  
  User.findOne({ email, password });
});

// ✅ Use schema validation
const userSchema = new mongoose.Schema({
  email: { type: String, required: true },
  password: { type: String, required: true }
});
```

---

## Authentication & Authorization

### Password Security

```javascript
const bcrypt = require('bcryptjs');

// Hash password before saving
const hashPassword = async (password) => {
  const salt = await bcrypt.genSalt(10);
  return await bcrypt.hash(password, salt);
};

// Compare password
const comparePassword = async (password, hash) => {
  return await bcrypt.compare(password, hash);
};

// In User model
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await hashPassword(this.password);
  next();
});
```

### JWT Security

```javascript
const jwt = require('jsonwebtoken');

// Generate token
const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    {
      expiresIn: '7d',
      issuer: 'myapp.com',
      audience: 'myapp-users'
    }
  );
};

// Verify token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET, {
      issuer: 'myapp.com',
      audience: 'myapp-users'
    });
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Middleware
const authMiddleware = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};
```

### Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

// General rate limit
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: 'Too many requests'
});

// Strict limit for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Too many login attempts'
});

app.use('/api/', limiter);
app.use('/api/auth/login', authLimiter);
```

---

## HTTPS/SSL

### Force HTTPS

```javascript
// Redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (process.env.NODE_ENV === 'production' && !req.secure) {
    return res.redirect(`https://${req.headers.host}${req.url}`);
  }
  next();
});

// HSTS header
app.use(helmet.hsts({
  maxAge: 31536000, // 1 year
  includeSubDomains: true,
  preload: true
}));
```

### Secure Cookies

```javascript
res.cookie('token', jwt, {
  httpOnly: true,     // Can't be accessed by JavaScript
  secure: true,       // Only sent over HTTPS
  sameSite: 'strict', // CSRF protection
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
});
```

---

## Security Headers (Helmet)

```javascript
const helmet = require('helmet');

app.use(helmet());

// Or configure individual headers
app.use(helmet.contentSecurityPolicy());
app.use(helmet.dnsPrefetchControl());
app.use(helmet.frameguard({ action: 'deny' }));
app.use(helmet.hidePoweredBy());
app.use(helmet.hsts());
app.use(helmet.ieNoOpen());
app.use(helmet.noSniff());
app.use(helmet.referrerPolicy());
app.use(helmet.xssFilter());
```

---

## Input Validation

```javascript
const { body, validationResult } = require('express-validator');

app.post('/api/users',
  [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 6 }),
    body('name').trim().isLength({ min: 2 }).escape()
  ],
  (req, res) => {
    const errors = validationResult(req);
    
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    
    // Process validated data
  }
);
```

---

## Environment Variables

```javascript
// ❌ Don't commit secrets
const JWT_SECRET = 'my_secret_key';

// ✅ Use environment variables
const JWT_SECRET = process.env.JWT_SECRET;

// Validate required env vars
const requiredEnvVars = ['JWT_SECRET', 'MONGO_URI', 'NODE_ENV'];
requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
});
```

---

## Dependency Security

```bash
# Check for vulnerabilities
npm audit

# Fix vulnerabilities
npm audit fix

# Force fix (may break things)
npm audit fix --force

# Use Snyk
npm install -g snyk
snyk test
snyk wizard
```

---

## Security Checklist

### Backend
- [ ] Use HTTPS in production
- [ ] Hash passwords with bcrypt
- [ ] Implement JWT authentication
- [ ] Sanitize user input
- [ ] Use parameterized queries
- [ ] Install security headers (Helmet)
- [ ] Implement rate limiting
- [ ] Enable CORS properly
- [ ] Validate input with express-validator
- [ ] Use environment variables for secrets
- [ ] Keep dependencies updated
- [ ] Implement CSRF protection

### Frontend
- [ ] Sanitize HTML (DOMPurify)
- [ ] Never use dangerouslySetInnerHTML without sanitizing
- [ ] Validate user input
- [ ] Store tokens securely (httpOnly cookies)
- [ ] Implement CSP headers
- [ ] Use HTTPS
- [ ] Keep dependencies updated

---

## Interview Questions

**Q1: What is XSS and how to prevent it?**
- Injecting malicious scripts
- Prevention: Escape output, sanitize input, CSP headers

**Q2: What is CSRF?**
- Tricks user into making unwanted requests
- Prevention: CSRF tokens, SameSite cookies, check origin

**Q3: How to prevent NoSQL injection?**
- Sanitize input (express-mongo-sanitize)
- Validate input types
- Use schema validation

**Q4: How to store passwords securely?**
- Hash with bcrypt (not MD5, SHA1)
- Add salt (bcrypt does automatically)
- Never store plain text

**Q5: What security headers does Helmet provide?**
- Content-Security-Policy
- X-Frame-Options
- X-XSS-Protection
- Strict-Transport-Security
- X-Content-Type-Options

---

## Summary

- **XSS**: Sanitize input, escape output, CSP headers
- **CSRF**: Tokens, SameSite cookies, check origin
- **Injection**: Parameterized queries, sanitize input, validate types
- **Auth**: bcrypt passwords, JWT tokens, rate limiting
- **HTTPS**: Force redirect, secure cookies, HSTS
- **Headers**: Use Helmet for security headers
- **Best Practice**: Never trust user input, validate everything
