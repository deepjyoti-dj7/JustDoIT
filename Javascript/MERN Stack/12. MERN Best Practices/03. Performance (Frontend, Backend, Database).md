# 03. Performance (Frontend, Backend, Database)

## Introduction

Performance optimization ensures fast, responsive applications. This guide covers optimization techniques for frontend (React), backend (Node.js), and database (MongoDB).

---

## Frontend Performance (React)

### 1. React.memo() - Prevent Unnecessary Re-renders

```javascript
// Without memo - re-renders on every parent update
function UserCard({ user }) {
  console.log('UserCard rendered');
  return <div>{user.name}</div>;
}

// With memo - only re-renders if props change
const UserCard = React.memo(function UserCard({ user }) {
  console.log('UserCard rendered');
  return <div>{user.name}</div>;
});

// Custom comparison
const UserCard = React.memo(
  function UserCard({ user }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    return prevProps.user.id === nextProps.user.id;
  }
);
```

### 2. useMemo() - Memoize Expensive Calculations

```javascript
import { useMemo } from 'react';

function ProductList({ products }) {
  // ❌ Recalculates on every render
  const sortedProducts = products.sort((a, b) => b.price - a.price);
  
  // ✅ Only recalculates when products change
  const sortedProducts = useMemo(() => {
    console.log('Sorting products...');
    return products.sort((a, b) => b.price - a.price);
  }, [products]);
  
  return (
    <div>
      {sortedProducts.map(product => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

### 3. useCallback() - Memoize Functions

```javascript
import { useCallback, useState } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ New function on every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  // ✅ Same function reference
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []);
  
  return <Child onClick={handleClick} />;
}

const Child = React.memo(({ onClick }) => {
  console.log('Child rendered');
  return <button onClick={onClick}>Click</button>;
});
```

### 4. Virtualization - Large Lists

```javascript
import { FixedSizeList } from 'react-window';

// Without virtualization - renders 10,000 items
function ProductList({ products }) {
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}

// With virtualization - only renders visible items
function ProductList({ products }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ProductCard product={products[index]} />
    </div>
  );
  
  return (
    <FixedSizeList
      height={600}
      itemCount={products.length}
      itemSize={100}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

### 5. Debouncing and Throttling

```javascript
import { useState, useCallback } from 'react';
import { debounce } from 'lodash';

function SearchBar() {
  const [results, setResults] = useState([]);
  
  // Debounce search - wait 300ms after user stops typing
  const handleSearch = useCallback(
    debounce(async (query) => {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();
      setResults(data);
    }, 300),
    []
  );
  
  return (
    <input
      type="text"
      onChange={(e) => handleSearch(e.target.value)}
      placeholder="Search..."
    />
  );
}

// Throttle scroll event
const handleScroll = useCallback(
  throttle(() => {
    console.log('Scrolling...');
  }, 200),
  []
);
```

### 6. Image Optimization

```javascript
// Lazy loading images
function ProductImage({ src, alt }) {
  return (
    <img
      src={src}
      alt={alt}
      loading="lazy"
      decoding="async"
    />
  );
}

// Responsive images
function ResponsiveImage({ src, alt }) {
  return (
    <picture>
      <source
        media="(min-width: 768px)"
        srcSet={`${src}-large.webp`}
        type="image/webp"
      />
      <source
        media="(min-width: 768px)"
        srcSet={`${src}-large.jpg`}
      />
      <source
        srcSet={`${src}-small.webp`}
        type="image/webp"
      />
      <img src={`${src}-small.jpg`} alt={alt} loading="lazy" />
    </picture>
  );
}
```

### 7. Code Splitting

```javascript
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

---

## Backend Performance (Node.js)

### 1. Async/Await - Non-Blocking Operations

```javascript
// ❌ Blocking - processes sequentially
app.get('/users/:id', (req, res) => {
  const user = getUserSync(req.params.id);
  const posts = getPostsSync(user.id);
  const comments = getCommentsSync(posts);
  res.json({ user, posts, comments });
});

// ✅ Non-blocking - parallel execution
app.get('/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    // Run in parallel
    const [posts, followers] = await Promise.all([
      Post.find({ userId: user.id }),
      User.find({ following: user.id })
    ]);
    
    res.json({ user, posts, followers });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. Compression

```javascript
const compression = require('compression');
const express = require('express');

const app = express();

// Enable gzip compression
app.use(compression());

// Responses will be compressed automatically
app.get('/api/data', (req, res) => {
  res.json({ data: largeDataArray });
});
```

### 3. Clustering - Utilize All CPU Cores

```javascript
const cluster = require('cluster');
const os = require('os');
const express = require('express');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  console.log(`Master process starting ${numCPUs} workers...`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker) => {
    console.log(`Worker ${worker.process.pid} died, starting new worker`);
    cluster.fork();
  });
} else {
  // Workers share TCP connection
  const app = express();
  
  app.get('/', (req, res) => {
    res.send(`Process ${process.pid} handling request`);
  });
  
  app.listen(3000);
  console.log(`Worker ${process.pid} started`);
}
```

### 4. Connection Pooling

```javascript
const mongoose = require('mongoose');

mongoose.connect(process.env.MONGO_URI, {
  maxPoolSize: 10,        // Max connections
  minPoolSize: 5,         // Min connections
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
});
```

### 5. Pagination

```javascript
// ❌ Returns all records
app.get('/api/posts', async (req, res) => {
  const posts = await Post.find();
  res.json(posts);
});

// ✅ Paginated response
app.get('/api/posts', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;
  
  const [posts, total] = await Promise.all([
    Post.find().skip(skip).limit(limit).lean(),
    Post.countDocuments()
  ]);
  
  res.json({
    posts,
    currentPage: page,
    totalPages: Math.ceil(total / limit),
    totalItems: total
  });
});
```

### 6. Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per window
  message: 'Too many requests from this IP'
});

app.use('/api/', limiter);
```

---

## Database Performance (MongoDB)

### 1. Indexes

```javascript
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    unique: true,
    index: true  // Single field index
  },
  username: {
    type: String,
    index: true
  },
  createdAt: {
    type: Date,
    default: Date.now,
    index: true
  }
});

// Compound index
userSchema.index({ email: 1, username: 1 });

// Text index for search
userSchema.index({ name: 'text', bio: 'text' });

// Explain query to check index usage
const explain = await User.find({ email: 'test@example.com' }).explain();
console.log(explain);
```

### 2. Select Only Needed Fields

```javascript
// ❌ Returns all fields
const users = await User.find();

// ✅ Select specific fields
const users = await User.find().select('name email -_id');

// ✅ Exclude fields
const users = await User.find().select('-password -__v');
```

### 3. Lean Queries

```javascript
// ❌ Returns Mongoose documents (heavier)
const users = await User.find();

// ✅ Returns plain JavaScript objects (faster)
const users = await User.find().lean();
```

### 4. Limit and Skip

```javascript
// Limit results
const users = await User.find().limit(10);

// Skip results (pagination)
const users = await User.find().skip(20).limit(10);
```

### 5. Aggregation Pipeline

```javascript
// Efficient data processing
const stats = await Post.aggregate([
  { $match: { published: true } },
  { $group: {
    _id: '$category',
    count: { $sum: 1 },
    avgLikes: { $avg: '$likes' }
  }},
  { $sort: { count: -1 } },
  { $limit: 10 }
]);
```

### 6. Avoid N+1 Queries

```javascript
// ❌ N+1 problem - multiple queries
const posts = await Post.find();
for (const post of posts) {
  post.author = await User.findById(post.authorId);
}

// ✅ Use populate - single query with join
const posts = await Post.find().populate('author', 'name email');

// ✅ Manual optimization
const posts = await Post.find();
const authorIds = posts.map(p => p.authorId);
const authors = await User.find({ _id: { $in: authorIds } });
const authorMap = new Map(authors.map(a => [a._id.toString(), a]));
posts.forEach(post => {
  post.author = authorMap.get(post.authorId.toString());
});
```

---

## Performance Monitoring

### 1. Lighthouse (Frontend)

```bash
npm install -g lighthouse
lighthouse https://yoursite.com --view
```

### 2. Chrome DevTools

- Performance tab: Record and analyze
- Network tab: Check load times
- Coverage tab: Find unused CSS/JS

### 3. Backend Monitoring

```javascript
// Response time middleware
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.url} - ${duration}ms`);
  });
  next();
});
```

---

## Interview Questions

**Q1: How to optimize React re-renders?**
- Use React.memo() for components
- useMemo() for expensive calculations
- useCallback() for functions
- Proper key prop in lists

**Q2: What is virtualization?**
- Render only visible items in large lists
- Libraries: react-window, react-virtualized
- Improves performance for 1000+ items

**Q3: How to optimize MongoDB queries?**
- Create indexes on queried fields
- Use .lean() for read-only data
- Select only needed fields
- Use aggregation pipelines
- Avoid N+1 queries

**Q4: What is clustering in Node.js?**
- Utilize all CPU cores
- Master process forks worker processes
- Each worker handles requests
- Built-in load balancing

**Q5: Difference between debounce and throttle?**
- **Debounce**: Execute after delay (search input)
- **Throttle**: Execute at most once per interval (scroll events)

---

## Summary

- **Frontend**: React.memo, useMemo, useCallback, virtualization, lazy loading
- **Backend**: Async/await, compression, clustering, connection pooling, pagination
- **Database**: Indexes, lean queries, select fields, aggregation, avoid N+1
- **Monitoring**: Lighthouse, DevTools, response time tracking
- **Best Practice**: Measure first, optimize bottlenecks, avoid premature optimization
