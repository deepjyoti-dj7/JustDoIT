# 10. Scalability (Microservices, Load Balancing)

## Introduction

Scalability ensures your application can handle growing user loads and data. This guide covers horizontal/vertical scaling, microservices architecture, load balancing, and database scaling for MERN applications.

---

## Types of Scaling

### Vertical Scaling (Scale Up)

Increase resources (CPU, RAM) of existing server.

**Pros**:
- Simple to implement
- No code changes needed
- Works for databases

**Cons**:
- Hardware limits
- Single point of failure
- Expensive at scale
- Downtime for upgrades

**Example**:
```
Before: 2 CPU cores, 4GB RAM
After:  8 CPU cores, 32GB RAM
```

### Horizontal Scaling (Scale Out)

Add more servers to distribute load.

**Pros**:
- No hardware limits
- Better fault tolerance
- Cost-effective
- No downtime

**Cons**:
- Code must be stateless
- Data consistency challenges
- More complex infrastructure

**Example**:
```
Before: 1 server
After:  5 servers behind load balancer
```

---

## Stateless Application Design

### Why Stateless?

Enables horizontal scaling by allowing any server to handle any request.

### Session Management

**❌ Stateful (Bad for Scaling)**:
```javascript
// Session stored in server memory
const session = require('express-session');

app.use(session({
  secret: 'secret',
  resave: false,
  saveUninitialized: false
}));

app.post('/login', (req, res) => {
  req.session.userId = user.id; // Stored in this server only!
  res.send('Logged in');
});
```

**✅ Stateless (Good for Scaling)**:
```javascript
// Use JWT tokens
const jwt = require('jsonwebtoken');

app.post('/login', (req, res) => {
  const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);
  res.json({ token }); // Client stores token
});

app.get('/profile', authMiddleware, (req, res) => {
  // Any server can verify token
  res.json(req.user);
});

// Or use Redis for shared sessions
const RedisStore = require('connect-redis')(session);
const redis = require('redis');
const client = redis.createClient();

app.use(session({
  store: new RedisStore({ client }),
  secret: 'secret'
}));
```

---

## Load Balancing

### What is Load Balancing?

Distributes incoming traffic across multiple servers.

### Nginx Load Balancer

```nginx
# nginx.conf
upstream backend {
  # Load balancing methods:
  
  # Round Robin (default) - rotate requests
  server localhost:5001;
  server localhost:5002;
  server localhost:5003;
  
  # Least Connections
  # least_conn;
  
  # IP Hash (sticky sessions)
  # ip_hash;
}

server {
  listen 80;
  
  location /api {
    proxy_pass http://backend;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
  
  # Serve React app
  location / {
    root /var/www/frontend;
    try_files $uri /index.html;
  }
}
```

### Running Multiple Node.js Instances

**Using PM2**:
```bash
# Install PM2
npm install -g pm2

# Start app in cluster mode
pm2 start server.js -i max  # Uses all CPU cores
pm2 start server.js -i 4    # Uses 4 instances

# Monitor
pm2 monit
pm2 list

# Reload without downtime
pm2 reload server
```

**Using Node.js Cluster Module**:
```javascript
const cluster = require('cluster');
const os = require('os');
const express = require('express');

if (cluster.isMaster) {
  const numCPUs = os.cpus().length;
  console.log(`Master process ${process.pid} is running`);
  
  // Fork workers
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }
  
  cluster.on('exit', (worker, code, signal) => {
    console.log(`Worker ${worker.process.pid} died`);
    cluster.fork(); // Restart worker
  });
} else {
  // Workers share TCP connection
  const app = express();
  
  app.get('/', (req, res) => {
    res.send(`Worker ${process.pid} handled request`);
  });
  
  app.listen(5000, () => {
    console.log(`Worker ${process.pid} started`);
  });
}
```

---

## Caching for Scalability

### Redis Caching

```javascript
const redis = require('redis');
const client = redis.createClient();

// Cache frequently accessed data
const getUser = async (userId) => {
  const cacheKey = `user:${userId}`;
  
  // Check cache first
  const cached = await client.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // Fetch from database
  const user = await User.findById(userId);
  
  // Store in cache (expires in 1 hour)
  await client.setex(cacheKey, 3600, JSON.stringify(user));
  
  return user;
};
```

### CDN for Static Assets

```javascript
// Serve static files from CDN
const CDN_URL = 'https://cdn.example.com';

// In React
<img src={`${CDN_URL}/images/logo.png`} alt="Logo" />
```

---

## Database Scaling

### 1. Indexing

```javascript
// Create indexes for frequently queried fields
const userSchema = new mongoose.Schema({
  email: { type: String, index: true, unique: true },
  username: { type: String, index: true },
  createdAt: { type: Date, index: true }
});

// Compound index
userSchema.index({ email: 1, isActive: 1 });
```

### 2. Database Replication (Read Replicas)

```javascript
// MongoDB replica set connection
const mongoose = require('mongoose');

mongoose.connect('mongodb://primary:27017,secondary1:27017,secondary2:27017/mydb', {
  replicaSet: 'myReplicaSet',
  readPreference: 'secondaryPreferred' // Read from secondaries when possible
});
```

### 3. Database Sharding

```javascript
// Shard by userId (MongoDB)
// Each shard handles a range of user IDs

// Shard 1: userId 0-1000000
// Shard 2: userId 1000001-2000000
// Shard 3: userId 2000001-3000000

// MongoDB handles routing automatically
sh.enableSharding('mydb');
sh.shardCollection('mydb.users', { userId: 1 });
```

### 4. Connection Pooling

```javascript
// MongoDB connection pool
mongoose.connect(process.env.MONGO_URI, {
  maxPoolSize: 10,
  minPoolSize: 5,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000
});
```

---

## Microservices Architecture

### Monolith vs Microservices

**Monolith**:
```
One large application
├── User service
├── Product service
├── Order service
└── Payment service
```

**Microservices**:
```
Separate services communicating via API
├── User Service (port 5001)
├── Product Service (port 5002)
├── Order Service (port 5003)
└── Payment Service (port 5004)
```

### Microservices Example

**User Service**:
```javascript
// user-service/server.js
const express = require('express');
const app = express();

app.get('/api/users/:id', async (req, res) => {
  const user = await User.findById(req.params.id);
  res.json(user);
});

app.listen(5001, () => console.log('User service on 5001'));
```

**Order Service** (calls User Service):
```javascript
// order-service/server.js
const express = require('express');
const axios = require('axios');
const app = express();

app.get('/api/orders/:id', async (req, res) => {
  const order = await Order.findById(req.params.id);
  
  // Fetch user from User Service
  const userResponse = await axios.get(
    `http://user-service:5001/api/users/${order.userId}`
  );
  
  res.json({
    ...order.toObject(),
    user: userResponse.data
  });
});

app.listen(5003, () => console.log('Order service on 5003'));
```

### API Gateway

```javascript
// gateway/server.js
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');
const app = express();

// Route requests to appropriate services
app.use('/api/users', createProxyMiddleware({
  target: 'http://user-service:5001',
  changeOrigin: true
}));

app.use('/api/products', createProxyMiddleware({
  target: 'http://product-service:5002',
  changeOrigin: true
}));

app.use('/api/orders', createProxyMiddleware({
  target: 'http://order-service:5003',
  changeOrigin: true
}));

app.listen(8000, () => console.log('API Gateway on 8000'));
```

### Docker Compose for Microservices

```yaml
version: '3.8'

services:
  gateway:
    build: ./gateway
    ports:
      - "8000:8000"
    depends_on:
      - user-service
      - product-service
      - order-service
  
  user-service:
    build: ./user-service
    environment:
      - MONGO_URI=mongodb://mongo:27017/users
  
  product-service:
    build: ./product-service
    environment:
      - MONGO_URI=mongodb://mongo:27017/products
  
  order-service:
    build: ./order-service
    environment:
      - MONGO_URI=mongodb://mongo:27017/orders
  
  mongo:
    image: mongo:5
    volumes:
      - mongo-data:/data/db
  
  redis:
    image: redis:6

volumes:
  mongo-data:
```

---

## Message Queues

### RabbitMQ for Async Communication

```javascript
const amqp = require('amqplib');

// Producer (Order Service)
const connection = await amqp.connect('amqp://localhost');
const channel = await connection.createChannel();
const queue = 'order_created';

await channel.assertQueue(queue);

app.post('/api/orders', async (req, res) => {
  const order = await Order.create(req.body);
  
  // Send message to queue
  channel.sendToQueue(queue, Buffer.from(JSON.stringify(order)));
  
  res.status(201).json(order);
});

// Consumer (Email Service)
const connection = await amqp.connect('amqp://localhost');
const channel = await connection.createChannel();
const queue = 'order_created';

await channel.assertQueue(queue);

channel.consume(queue, (msg) => {
  const order = JSON.parse(msg.content.toString());
  
  // Send order confirmation email
  sendEmail(order.email, 'Order Confirmation', order);
  
  channel.ack(msg);
});
```

---

## Performance Optimization

### 1. Pagination

```javascript
app.get('/api/posts', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;
  
  const posts = await Post.find()
    .skip(skip)
    .limit(limit)
    .sort({ createdAt: -1 });
  
  const total = await Post.countDocuments();
  
  res.json({
    posts,
    page,
    totalPages: Math.ceil(total / limit)
  });
});
```

### 2. Compression

```javascript
const compression = require('compression');

app.use(compression()); // Gzip responses
```

### 3. Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // Limit per IP
});

app.use('/api/', limiter);
```

---

## Monitoring and Auto-Scaling

### Health Check Endpoint

```javascript
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'OK', uptime: process.uptime() });
});
```

### Metrics

```javascript
const prometheus = require('prom-client');

const httpRequestDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code']
});

app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration.labels(req.method, req.route?.path, res.statusCode)
      .observe(duration);
  });
  next();
});

app.get('/metrics', async (req, res) => {
  res.set('Content-Type', prometheus.register.contentType);
  res.end(await prometheus.register.metrics());
});
```

---

## Interview Questions

**Q1: Horizontal vs Vertical Scaling?**
- **Vertical**: Add resources (CPU, RAM) to existing server
- **Horizontal**: Add more servers, distribute load

**Q2: What is load balancing?**
- Distributes traffic across multiple servers
- Algorithms: Round Robin, Least Connections, IP Hash

**Q3: Monolith vs Microservices?**
- **Monolith**: One application, easier to develop, harder to scale
- **Microservices**: Separate services, complex, easier to scale independently

**Q4: How to make app stateless?**
- Use JWT instead of sessions
- Store sessions in Redis (shared)
- Avoid server-side state

**Q5: Database scaling techniques?**
- Indexing, replication (read replicas), sharding, caching

---

## Summary

- **Scaling**: Vertical (add resources), Horizontal (add servers)
- **Stateless**: JWT, Redis sessions for horizontal scaling
- **Load Balancing**: Nginx, PM2 cluster mode
- **Caching**: Redis, CDN for static assets
- **Database**: Indexing, replication, sharding, connection pooling
- **Microservices**: Separate services, API gateway, message queues
- **Best Practice**: Monitor, auto-scale, optimize queries, paginate
