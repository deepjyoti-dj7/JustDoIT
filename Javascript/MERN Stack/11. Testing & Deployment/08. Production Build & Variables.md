# 08. Production Build & Variables

## Introduction

Production builds optimize applications for performance, security, and efficiency. This guide covers creating production builds for React frontend and Node.js backend with proper environment configuration.

---

## React Production Build

### Create React App Build

```bash
# Create production build
npm run build

# Output:
# build/
#   static/
#     css/
#       main.[hash].css
#     js/
#       main.[hash].js
#   index.html
#   asset-manifest.json
```

### Build Optimizations

1. **Minification**: Code is compressed
2. **Tree Shaking**: Unused code removed
3. **Code Splitting**: Smaller bundle chunks
4. **Asset Optimization**: Images, fonts optimized
5. **Source Maps**: Optional debugging maps

### Build Analysis

```bash
# Install bundle analyzer
npm install --save-dev webpack-bundle-analyzer

# Analyze build
npm run build
npx webpack-bundle-analyzer build/bundle-stats.json
```

### Build Configuration

```javascript
// package.json
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "build:analyze": "npm run build && npx webpack-bundle-analyzer build/bundle-stats.json"
  }
}
```

---

## Vite Production Build

```bash
# Create production build
npm run build

# Preview production build locally
npm run preview
```

### Vite Configuration

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    sourcemap: false,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // Remove console.logs
      },
    },
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
        },
      },
    },
  },
});
```

---

## Environment Variables

### React Environment Variables

**Create React App**:

```bash
# .env
REACT_APP_API_URL=http://localhost:5000/api
REACT_APP_ENV=development

# .env.production
REACT_APP_API_URL=https://api.myapp.com/api
REACT_APP_ENV=production

# .env.local (ignored by git)
REACT_APP_SECRET_KEY=local_secret
```

**Usage**:
```javascript
// src/config.js
export const API_URL = process.env.REACT_APP_API_URL;
export const ENV = process.env.REACT_APP_ENV;

// Usage in components
import { API_URL } from './config';

fetch(`${API_URL}/users`)
  .then(res => res.json())
  .then(data => console.log(data));
```

**Vite**:

```bash
# .env
VITE_API_URL=http://localhost:5000/api
VITE_APP_NAME=My App

# .env.production
VITE_API_URL=https://api.myapp.com/api
```

**Usage**:
```javascript
const API_URL = import.meta.env.VITE_API_URL;
const APP_NAME = import.meta.env.VITE_APP_NAME;
```

### Node.js Environment Variables

```bash
# .env.development
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/myapp
JWT_SECRET=dev_secret_key
JWT_EXPIRE=7d
CLIENT_URL=http://localhost:3000

# .env.production
NODE_ENV=production
PORT=5000
MONGO_URI=mongodb+srv://user:pass@cluster.mongodb.net/myapp
JWT_SECRET=super_strong_production_secret_key_here_1234567890
JWT_EXPIRE=30d
CLIENT_URL=https://myapp.com

# Email configuration
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=noreply@myapp.com
SMTP_PASS=email_password

# AWS S3 (for file uploads)
AWS_ACCESS_KEY_ID=your_access_key
AWS_SECRET_ACCESS_KEY=your_secret_key
AWS_BUCKET_NAME=myapp-uploads
AWS_REGION=us-east-1
```

**Loading**:
```javascript
// config/env.js
require('dotenv').config();

module.exports = {
  NODE_ENV: process.env.NODE_ENV || 'development',
  PORT: process.env.PORT || 5000,
  MONGO_URI: process.env.MONGO_URI,
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRE: process.env.JWT_EXPIRE || '7d',
  CLIENT_URL: process.env.CLIENT_URL,
  
  SMTP: {
    HOST: process.env.SMTP_HOST,
    PORT: process.env.SMTP_PORT,
    USER: process.env.SMTP_USER,
    PASS: process.env.SMTP_PASS,
  },
  
  AWS: {
    ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID,
    SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY,
    BUCKET_NAME: process.env.AWS_BUCKET_NAME,
    REGION: process.env.AWS_REGION,
  },
};

// Usage
const config = require('./config/env');
const PORT = config.PORT;
```

### Environment Validation

```javascript
// config/validateEnv.js
const requiredEnvVars = [
  'NODE_ENV',
  'PORT',
  'MONGO_URI',
  'JWT_SECRET',
  'CLIENT_URL',
];

const validateEnv = () => {
  const missingVars = requiredEnvVars.filter(
    varName => !process.env[varName]
  );
  
  if (missingVars.length > 0) {
    console.error('Missing required environment variables:');
    missingVars.forEach(varName => console.error(`  - ${varName}`));
    process.exit(1);
  }
  
  console.log('âœ… All required environment variables are set');
};

module.exports = validateEnv;

// server.js
require('dotenv').config();
const validateEnv = require('./config/validateEnv');

validateEnv();

// ... rest of server code
```

---

## Backend Production Setup

### Production Server Configuration

```javascript
// server.js
const express = require('express');
const mongoose = require('mongoose');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const cors = require('cors');
require('dotenv').config();

const app = express();

// Security middleware
app.use(helmet());
app.use(mongoSanitize()); // Prevent NoSQL injection

// Compression
app.use(compression());

// CORS
const corsOptions = {
  origin: process.env.CLIENT_URL,
  credentials: true,
};
app.use(cors(corsOptions));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP',
});
app.use('/api/', limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Database connection with retry logic
const connectDB = async () => {
  const options = {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  };
  
  try {
    await mongoose.connect(process.env.MONGO_URI, options);
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    // Retry after 5 seconds
    setTimeout(connectDB, 5000);
  }
};

connectDB();

// Routes
app.use('/api/users', require('./routes/users'));
app.use('/api/auth', require('./routes/auth'));

// Serve static files in production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static('client/build'));
  
  app.get('*', (req, res) => {
    res.sendFile(path.resolve(__dirname, 'client', 'build', 'index.html'));
  });
}

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  
  const statusCode = err.statusCode || 500;
  const message = process.env.NODE_ENV === 'production'
    ? 'Something went wrong'
    : err.message;
  
  res.status(statusCode).json({ error: message });
});

const PORT = process.env.PORT || 5000;
const server = app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('Process terminated');
  });
});
```

### Production Dependencies

```json
{
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.0.0",
    "dotenv": "^16.0.3",
    "helmet": "^7.0.0",
    "compression": "^1.7.4",
    "express-rate-limit": "^6.7.0",
    "express-mongo-sanitize": "^2.2.0",
    "cors": "^2.8.5",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22",
    "jest": "^29.5.0",
    "supertest": "^6.3.3"
  }
}
```

---

## Optimization Techniques

### 1. Code Splitting

```javascript
// Lazy loading routes
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

### 2. Image Optimization

```javascript
// Use modern formats (WebP)
// Lazy load images
import { LazyLoadImage } from 'react-lazy-load-image-component';

function ImageComponent() {
  return (
    <LazyLoadImage
      src="/images/photo.webp"
      alt="Description"
      effect="blur"
    />
  );
}
```

### 3. Caching

```javascript
// Service Worker (CRA automatically includes)
// Cache API responses
const getCachedData = async (url) => {
  const cache = await caches.open('api-cache');
  const cachedResponse = await cache.match(url);
  
  if (cachedResponse) {
    return cachedResponse.json();
  }
  
  const response = await fetch(url);
  cache.put(url, response.clone());
  return response.json();
};
```

### 4. Database Indexing

```javascript
// User model with indexes
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    index: true, // Index for faster queries
  },
  username: {
    type: String,
    index: true,
  },
  createdAt: {
    type: Date,
    default: Date.now,
    index: true,
  },
});

// Compound index
userSchema.index({ email: 1, username: 1 });
```

---

## Production Checklist

### Frontend

- [ ] Run production build (`npm run build`)
- [ ] Remove console.logs
- [ ] Enable source maps only if needed
- [ ] Optimize images (WebP, lazy loading)
- [ ] Code splitting implemented
- [ ] Bundle size analyzed
- [ ] Environment variables configured
- [ ] Service worker registered (PWA)

### Backend

- [ ] Environment variables set
- [ ] Database indexes created
- [ ] Rate limiting enabled
- [ ] Helmet security middleware
- [ ] Compression enabled
- [ ] Error handling implemented
- [ ] Logging configured
- [ ] CORS configured
- [ ] Input validation
- [ ] SQL/NoSQL injection prevention

### Performance

- [ ] Database queries optimized
- [ ] Caching implemented
- [ ] CDN for static assets
- [ ] Gzip compression enabled
- [ ] HTTP/2 enabled
- [ ] Lazy loading images
- [ ] Code splitting

---

## Interview Questions

**Q1: What happens during npm run build?**
- Code minification and uglification
- Tree shaking (remove unused code)
- Asset optimization
- Creates production-ready bundle

**Q2: CRA vs Vite build process?**
- **CRA**: Uses Webpack, slower builds
- **Vite**: Uses esbuild/Rollup, faster builds

**Q3: How to pass environment variables to React?**
- CRA: Prefix with `REACT_APP_`
- Vite: Prefix with `VITE_`
- Access via `process.env.REACT_APP_*` or `import.meta.env.VITE_*`

**Q4: Production security best practices?**
- Use helmet middleware
- Rate limiting
- Input validation
- CORS configuration
- Environment variables for secrets
- HTTPS only

**Q5: How to optimize React bundle size?**
- Code splitting (lazy loading)
- Tree shaking
- Remove unused dependencies
- Analyze bundle with webpack-bundle-analyzer
- Use production build

---

## Summary

- **Production Build**: `npm run build` for React, optimized bundle
- **Environment Variables**: .env files, REACT_APP_ prefix, never commit
- **Backend Security**: Helmet, rate limiting, input validation
- **Optimization**: Code splitting, lazy loading, caching
- **Checklist**: Build, test, optimize, secure
- **Best Practice**: Validate env vars, use compression, enable CORS
