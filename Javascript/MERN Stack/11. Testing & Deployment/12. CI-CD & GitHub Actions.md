# 12. CI/CD & GitHub Actions

## Introduction

CI/CD (Continuous Integration/Continuous Deployment) automates testing and deployment. GitHub Actions provides workflow automation directly in GitHub. This guide covers setting up CI/CD pipelines for MERN applications.

---

## What is CI/CD?

### Continuous Integration (CI)

**Automatically**:
- Run tests on every push/PR
- Check code quality (linting)
- Build application
- Detect integration issues early

### Continuous Deployment (CD)

**Automatically**:
- Deploy to staging on merge to develop
- Deploy to production on merge to main
- Rollback if tests fail

### Benefits

- **Faster delivery**: Automated deployment
- **Fewer bugs**: Tests run automatically
- **Consistent process**: Same steps every time
- **Quick feedback**: Know immediately if build fails

---

## GitHub Actions Basics

### Workflow Structure

```yaml
name: Workflow Name

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  job-name:
    runs-on: ubuntu-latest
    
    steps:
      - name: Step 1
        run: echo "Hello"
      
      - name: Step 2
        run: npm test
```

### Key Concepts

- **Workflow**: Automated process defined in YAML
- **Event**: Trigger (push, pull_request, schedule)
- **Job**: Set of steps that run on same runner
- **Step**: Individual task (run command, use action)
- **Runner**: Server that executes workflow (ubuntu, macos, windows)
- **Action**: Reusable unit (checkout code, setup node)

---

## CI Workflow for Backend

### .github/workflows/backend-ci.yml

```yaml
name: Backend CI

on:
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
  pull_request:
    branches: [main]
    paths:
      - 'backend/**'

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
    
    services:
      mongodb:
        image: mongo:6
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand({ ping: 1 })'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./backend
        run: npm ci
      
      - name: Run linter
        working-directory: ./backend
        run: npm run lint
      
      - name: Run tests
        working-directory: ./backend
        run: npm test
        env:
          NODE_ENV: test
          MONGO_URI: mongodb://localhost:27017/test
          JWT_SECRET: test_secret
      
      - name: Generate coverage report
        working-directory: ./backend
        run: npm run test:coverage
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/coverage/lcov.info
          flags: backend
```

---

## CI Workflow for Frontend

### .github/workflows/frontend-ci.yml

```yaml
name: Frontend CI

on:
  push:
    branches: [main, develop]
    paths:
      - 'frontend/**'
  pull_request:
    branches: [main]
    paths:
      - 'frontend/**'

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Run linter
        working-directory: ./frontend
        run: npm run lint
      
      - name: Run tests
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false
        env:
          CI: true
      
      - name: Build production
        working-directory: ./frontend
        run: npm run build
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build
          path: frontend/build
```

---

## CD Workflow (Deploy to Heroku)

### .github/workflows/deploy.yml

```yaml
name: Deploy to Heroku

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to Heroku
        uses: akhileshns/heroku-deploy@v3.12.14
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: my-app-backend
          heroku_email: ${{ secrets.HEROKU_EMAIL }}
          appdir: backend
      
      - name: Verify deployment
        run: |
          sleep 10
          curl -f https://my-app-backend.herokuapp.com/health || exit 1
```

---

## CD Workflow (Deploy to Vercel)

### .github/workflows/deploy-vercel.yml

```yaml
name: Deploy to Vercel

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          working-directory: ./frontend
          vercel-args: '--prod'
```

---

## CD Workflow (Deploy to AWS EC2)

### .github/workflows/deploy-ec2.yml

```yaml
name: Deploy to EC2

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ubuntu/my-app
            git pull origin main
            npm install
            pm2 restart my-app
```

---

## Docker Build & Push

### .github/workflows/docker.yml

```yaml
name: Docker Build & Push

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: username/my-app
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

---

## GitHub Secrets

### Adding Secrets

1. Go to repository Settings
2. Secrets and variables → Actions
3. New repository secret
4. Add:
   - `HEROKU_API_KEY`
   - `HEROKU_EMAIL`
   - `VERCEL_TOKEN`
   - `EC2_HOST`
   - `EC2_SSH_KEY`
   - `DOCKER_USERNAME`
   - `DOCKER_PASSWORD`
   - `MONGO_URI`
   - `JWT_SECRET`

### Using Secrets

```yaml
steps:
  - name: Deploy
    env:
      API_KEY: ${{ secrets.API_KEY }}
    run: echo "Deploying with API key"
```

---

## Caching Dependencies

### Cache npm packages

```yaml
- name: Setup Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '18'
    cache: 'npm'
    cache-dependency-path: package-lock.json

# Or manual caching
- name: Cache node modules
  uses: actions/cache@v3
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

---

## Matrix Strategy (Multiple Versions)

```yaml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node-version: [16.x, 18.x, 20.x]
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm test
```

---

## Environment-based Deployment

```yaml
name: Deploy

on:
  push:
    branches:
      - main
      - develop

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy to Staging
        if: github.ref == 'refs/heads/develop'
        run: echo "Deploying to staging"
      
      - name: Deploy to Production
        if: github.ref == 'refs/heads/main'
        run: echo "Deploying to production"
```

---

## Scheduled Workflows

```yaml
name: Nightly Tests

on:
  schedule:
    - cron: '0 2 * * *'  # Run at 2 AM UTC daily

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm test
```

---

## Best Practices

### 1. Fail Fast

```yaml
strategy:
  fail-fast: true  # Stop all jobs if one fails
```

### 2. Use Workflow Templates

Create reusable workflows in `.github/workflows/`.

### 3. Conditional Steps

```yaml
- name: Deploy
  if: success() && github.ref == 'refs/heads/main'
  run: npm run deploy
```

### 4. Job Dependencies

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: npm test
  
  deploy:
    needs: test  # Run only if test succeeds
    runs-on: ubuntu-latest
    steps:
      - run: npm run deploy
```

### 5. Artifacts

```yaml
- name: Upload logs
  if: failure()
  uses: actions/upload-artifact@v3
  with:
    name: test-logs
    path: logs/
```

---

## Interview Questions

**Q1: What is CI/CD?**
- **CI**: Continuous Integration - auto test on push
- **CD**: Continuous Deployment - auto deploy to production

**Q2: GitHub Actions workflow structure?**
- Workflow → Jobs → Steps
- Triggered by events (push, PR, schedule)
- Runs on runners (ubuntu, macos, windows)

**Q3: How to add secrets?**
- Repository Settings → Secrets and variables → Actions
- Access via `${{ secrets.SECRET_NAME }}`

**Q4: What is matrix strategy?**
- Test on multiple OS/Node versions
- Runs job for each combination

**Q5: Benefits of CI/CD?**
- Automated testing and deployment
- Faster feedback on bugs
- Consistent deployment process
- Reduced manual errors

---

## Summary

- **CI**: Auto-test on push/PR, lint, coverage
- **CD**: Auto-deploy to Heroku/Vercel/EC2
- **GitHub Actions**: Workflows in `.github/workflows/`
- **Secrets**: Store sensitive data (API keys, tokens)
- **Caching**: Speed up workflows (npm packages)
- **Matrix**: Test multiple versions
- **Best Practice**: Fail fast, use artifacts, job dependencies
