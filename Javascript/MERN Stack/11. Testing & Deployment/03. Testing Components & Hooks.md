# 03. Testing Components & Hooks

## Introduction

Testing React components and custom hooks ensures UI reliability and state management correctness. This guide covers component testing patterns, hooks testing, and best practices.

---

## Testing Functional Components

### Simple Component

```javascript
// Greeting.js
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

export default Greeting;

// Greeting.test.js
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('renders greeting with name', () => {
  render(<Greeting name="John" />);
  expect(screen.getByText('Hello, John!')).toBeInTheDocument();
});

test('renders different names', () => {
  const { rerender } = render(<Greeting name="Alice" />);
  expect(screen.getByText('Hello, Alice!')).toBeInTheDocument();
  
  rerender(<Greeting name="Bob" />);
  expect(screen.getByText('Hello, Bob!')).toBeInTheDocument();
});
```

### Component with State

```javascript
// Counter.js
import { useState } from 'react';

function Counter({ initialCount = 0 }) {
  const [count, setCount] = useState(initialCount);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

export default Counter;

// Counter.test.js
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import Counter from './Counter';

describe('Counter', () => {
  test('renders with initial count', () => {
    render(<Counter initialCount={5} />);
    expect(screen.getByText('Count: 5')).toBeInTheDocument();
  });
  
  test('increments count on increment button click', async () => {
    const user = userEvent.setup();
    render(<Counter />);
    
    const incrementButton = screen.getByRole('button', { name: /increment/i });
    
    await user.click(incrementButton);
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
    
    await user.click(incrementButton);
    expect(screen.getByText('Count: 2')).toBeInTheDocument();
  });
  
  test('decrements count on decrement button click', async () => {
    const user = userEvent.setup();
    render(<Counter initialCount={5} />);
    
    await user.click(screen.getByRole('button', { name: /decrement/i }));
    expect(screen.getByText('Count: 4')).toBeInTheDocument();
  });
  
  test('resets count to zero', async () => {
    const user = userEvent.setup();
    render(<Counter initialCount={10} />);
    
    await user.click(screen.getByRole('button', { name: /reset/i }));
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
  });
});
```

---

## Testing Forms

### Form Component

```javascript
// ContactForm.js
import { useState } from 'react';

function ContactForm({ onSubmit }) {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  });
  const [errors, setErrors] = useState({});
  
  const validate = () => {
    const newErrors = {};
    if (!formData.name) newErrors.name = 'Name is required';
    if (!formData.email) newErrors.email = 'Email is required';
    if (!formData.message) newErrors.message = 'Message is required';
    return newErrors;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    const newErrors = validate();
    
    if (Object.keys(newErrors).length === 0) {
      onSubmit(formData);
      setFormData({ name: '', email: '', message: '' });
    } else {
      setErrors(newErrors);
    }
  };
  
  const handleChange = (e) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
    // Clear error for this field
    if (errors[e.target.name]) {
      setErrors({ ...errors, [e.target.name]: '' });
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label htmlFor="name">Name</label>
        <input
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
        {errors.name && <span role="alert">{errors.name}</span>}
      </div>
      
      <div>
        <label htmlFor="email">Email</label>
        <input
          id="email"
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
        />
        {errors.email && <span role="alert">{errors.email}</span>}
      </div>
      
      <div>
        <label htmlFor="message">Message</label>
        <textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleChange}
        />
        {errors.message && <span role="alert">{errors.message}</span>}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
}

export default ContactForm;

// ContactForm.test.js
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ContactForm from './ContactForm';

describe('ContactForm', () => {
  test('renders all form fields', () => {
    render(<ContactForm onSubmit={jest.fn()} />);
    
    expect(screen.getByLabelText(/name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/message/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();
  });
  
  test('shows validation errors for empty fields', async () => {
    const user = userEvent.setup();
    render(<ContactForm onSubmit={jest.fn()} />);
    
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    expect(screen.getByText('Name is required')).toBeInTheDocument();
    expect(screen.getByText('Email is required')).toBeInTheDocument();
    expect(screen.getByText('Message is required')).toBeInTheDocument();
  });
  
  test('submits form with valid data', async () => {
    const user = userEvent.setup();
    const handleSubmit = jest.fn();
    render(<ContactForm onSubmit={handleSubmit} />);
    
    await user.type(screen.getByLabelText(/name/i), 'John Doe');
    await user.type(screen.getByLabelText(/email/i), 'john@example.com');
    await user.type(screen.getByLabelText(/message/i), 'Hello there!');
    
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    expect(handleSubmit).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com',
      message: 'Hello there!'
    });
  });
  
  test('clears form after successful submission', async () => {
    const user = userEvent.setup();
    render(<ContactForm onSubmit={jest.fn()} />);
    
    const nameInput = screen.getByLabelText(/name/i);
    const emailInput = screen.getByLabelText(/email/i);
    const messageInput = screen.getByLabelText(/message/i);
    
    await user.type(nameInput, 'John Doe');
    await user.type(emailInput, 'john@example.com');
    await user.type(messageInput, 'Test message');
    
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    expect(nameInput).toHaveValue('');
    expect(emailInput).toHaveValue('');
    expect(messageInput).toHaveValue('');
  });
  
  test('clears error when user starts typing', async () => {
    const user = userEvent.setup();
    render(<ContactForm onSubmit={jest.fn()} />);
    
    // Trigger validation error
    await user.click(screen.getByRole('button', { name: /submit/i }));
    expect(screen.getByText('Name is required')).toBeInTheDocument();
    
    // Start typing
    await user.type(screen.getByLabelText(/name/i), 'John');
    
    // Error should be cleared
    expect(screen.queryByText('Name is required')).not.toBeInTheDocument();
  });
});
```

---

## Testing Components with Context

### Context Provider

```javascript
// AuthContext.js
import { createContext, useContext, useState } from 'react';

const AuthContext = createContext(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  
  const login = (userData) => {
    setUser(userData);
  };
  
  const logout = () => {
    setUser(null);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

// UserProfile.js
import { useAuth } from './AuthContext';

function UserProfile() {
  const { user, logout } = useAuth();
  
  if (!user) {
    return <div>Please log in</div>;
  }
  
  return (
    <div>
      <h1>Welcome, {user.name}!</h1>
      <p>Email: {user.email}</p>
      <button onClick={logout}>Logout</button>
    </div>
  );
}

export default UserProfile;

// UserProfile.test.js
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { AuthProvider } from './AuthContext';
import UserProfile from './UserProfile';

// Helper function to render with provider
function renderWithAuth(component, { user = null } = {}) {
  return render(
    <AuthProvider>
      {component}
    </AuthProvider>
  );
}

test('shows login message when no user', () => {
  renderWithAuth(<UserProfile />);
  expect(screen.getByText('Please log in')).toBeInTheDocument();
});

test('shows user profile when logged in', () => {
  const TestComponent = () => {
    const { login } = useAuth();
    
    // Auto-login for test
    React.useEffect(() => {
      login({ name: 'John Doe', email: 'john@test.com' });
    }, []);
    
    return <UserProfile />;
  };
  
  renderWithAuth(<TestComponent />);
  
  expect(screen.getByText('Welcome, John Doe!')).toBeInTheDocument();
  expect(screen.getByText('Email: john@test.com')).toBeInTheDocument();
});

test('logout clears user', async () => {
  const user = userEvent.setup();
  
  const TestComponent = () => {
    const { login } = useAuth();
    
    React.useEffect(() => {
      login({ name: 'John Doe', email: 'john@test.com' });
    }, []);
    
    return <UserProfile />;
  };
  
  renderWithAuth(<TestComponent />);
  
  await user.click(screen.getByRole('button', { name: /logout/i }));
  
  expect(screen.getByText('Please log in')).toBeInTheDocument();
});
```

---

## Testing Custom Hooks

### Using renderHook

```javascript
// useCounter.js
import { useState } from 'react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

export default useCounter;

// useCounter.test.js
import { renderHook, act } from '@testing-library/react';
import useCounter from './useCounter';

describe('useCounter', () => {
  test('initializes with default value', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });
  
  test('initializes with custom value', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });
  
  test('increments count', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(2);
  });
  
  test('decrements count', () => {
    const { result } = renderHook(() => useCounter(5));
    
    act(() => {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });
  
  test('resets to initial value', () => {
    const { result } = renderHook(() => useCounter(10));
    
    act(() => {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(12);
    
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(10);
  });
});
```

### Testing Hooks with Dependencies

```javascript
// useFetch.js
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        
        const json = await response.json();
        
        if (!cancelled) {
          setData(json);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, [url]);
  
  return { data, loading, error };
}

export default useFetch;

// useFetch.test.js
import { renderHook, waitFor } from '@testing-library/react';
import useFetch from './useFetch';

global.fetch = jest.fn();

beforeEach(() => {
  fetch.mockClear();
});

test('fetches data successfully', async () => {
  const mockData = { id: 1, name: 'Test' };
  fetch.mockResolvedValueOnce({
    ok: true,
    json: async () => mockData
  });
  
  const { result } = renderHook(() => useFetch('/api/data'));
  
  // Initially loading
  expect(result.current.loading).toBe(true);
  expect(result.current.data).toBeNull();
  
  // Wait for data
  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });
  
  expect(result.current.data).toEqual(mockData);
  expect(result.current.error).toBeNull();
});

test('handles fetch error', async () => {
  fetch.mockResolvedValueOnce({
    ok: false
  });
  
  const { result } = renderHook(() => useFetch('/api/data'));
  
  await waitFor(() => {
    expect(result.current.loading).toBe(false);
  });
  
  expect(result.current.error).toBe('Network response was not ok');
  expect(result.current.data).toBeNull();
});

test('refetches when URL changes', async () => {
  const mockData1 = { id: 1, name: 'Test 1' };
  const mockData2 = { id: 2, name: 'Test 2' };
  
  fetch
    .mockResolvedValueOnce({
      ok: true,
      json: async () => mockData1
    })
    .mockResolvedValueOnce({
      ok: true,
      json: async () => mockData2
    });
  
  const { result, rerender } = renderHook(
    ({ url }) => useFetch(url),
    { initialProps: { url: '/api/data/1' } }
  );
  
  await waitFor(() => {
    expect(result.current.data).toEqual(mockData1);
  });
  
  // Change URL
  rerender({ url: '/api/data/2' });
  
  await waitFor(() => {
    expect(result.current.data).toEqual(mockData2);
  });
});
```

---

## Testing with Router

```javascript
// UserPage.js
import { useParams, useNavigate } from 'react-router-dom';
import { useState, useEffect } from 'react';

function UserPage() {
  const { userId } = useParams();
  const navigate = useNavigate();
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // Fetch user data
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));
  }, [userId]);
  
  if (!user) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={() => navigate('/')}>Go Home</button>
    </div>
  );
}

export default UserPage;

// UserPage.test.js
import { render, screen, waitFor } from '@testing-library/react';
import { MemoryRouter, Routes, Route } from 'react-router-dom';
import userEvent from '@testing-library/user-event';
import UserPage from './UserPage';

global.fetch = jest.fn();

function renderWithRouter(component, { route = '/' } = {}) {
  return render(
    <MemoryRouter initialEntries={[route]}>
      <Routes>
        <Route path="/users/:userId" element={component} />
        <Route path="/" element={<div>Home Page</div>} />
      </Routes>
    </MemoryRouter>
  );
}

test('displays user data', async () => {
  const mockUser = { id: '123', name: 'John Doe' };
  fetch.mockResolvedValueOnce({
    json: async () => mockUser
  });
  
  renderWithRouter(<UserPage />, { route: '/users/123' });
  
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
});

test('navigates to home on button click', async () => {
  const user = userEvent.setup();
  const mockUser = { id: '123', name: 'John Doe' };
  fetch.mockResolvedValueOnce({
    json: async () => mockUser
  });
  
  renderWithRouter(<UserPage />, { route: '/users/123' });
  
  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
  
  await user.click(screen.getByRole('button', { name: /go home/i }));
  
  expect(screen.getByText('Home Page')).toBeInTheDocument();
});
```

---

## Interview Questions

**Q1: How to test custom hooks?**
- Use `renderHook` from `@testing-library/react`
- Wrap state updates in `act()`
- Access hook return value via `result.current`

**Q2: How to test components with Context?**
- Create wrapper component with Provider
- Use custom render function with Provider
- Test consumer components with provider

**Q3: What is the `act` function?**
- Ensures all state updates are processed
- Required when updating state outside React render
- `userEvent` automatically wraps in `act`

**Q4: How to test forms?**
- Use `userEvent.type()` for inputs
- Test validation errors
- Verify submit callback with `jest.fn()`
- Test field clearing and error clearing

**Q5: How to test React Router components?**
- Wrap in `MemoryRouter` or `BrowserRouter`
- Use `initialEntries` for initial route
- Test navigation with `useNavigate` hook

---

## Best Practices

1. **Test user behavior**, not implementation
2. **Use renderHook** for custom hooks
3. **Wrap state updates** in `act()`
4. **Create wrapper utilities** for providers
5. **Test accessibility** (roles, labels, aria)
6. **Avoid testing internal state** directly
7. **Test async operations** with `waitFor`
8. **Mock external dependencies** (API, router)
9. **Use descriptive test names**
10. **Keep tests isolated** and independent

---

## Summary

- **Component Testing**: Render, query, interact, assert
- **Forms**: Test validation, submission, field changes
- **Context**: Create wrapper with provider
- **Custom Hooks**: Use `renderHook` and `act`
- **Router**: Wrap in `MemoryRouter` with routes
- **Async**: Use `waitFor` and `findBy` queries
- **Best Practice**: Test behavior, use proper queries, mock deps
