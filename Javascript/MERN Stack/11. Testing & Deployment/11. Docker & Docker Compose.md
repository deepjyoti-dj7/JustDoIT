# 11. Docker & Docker Compose

## Introduction

Docker containerizes applications for consistent environments across development and production. Docker Compose orchestrates multi-container applications. This guide covers Dockerizing MERN stack applications.

---

## Docker Basics

### What is Docker?

**Docker** packages applications with dependencies into containers.

**Benefits**:
- **Consistency**: Same environment everywhere
- **Isolation**: Dependencies don't conflict
- **Portability**: Run anywhere Docker runs
- **Efficiency**: Lighter than VMs

### Key Concepts

- **Image**: Blueprint for container (read-only)
- **Container**: Running instance of image
- **Dockerfile**: Instructions to build image
- **Docker Hub**: Registry for images
- **Volume**: Persistent data storage
- **Network**: Communication between containers

### Installation

```bash
# macOS
brew install --cask docker

# Ubuntu
sudo apt update
sudo apt install docker.io docker-compose
sudo systemctl start docker
sudo systemctl enable docker

# Add user to docker group
sudo usermod -aG docker $USER

# Verify
docker --version
docker-compose --version
```

---

## Dockerizing Node.js Backend

### Dockerfile

```dockerfile
# Dockerfile

# Base image
FROM node:18-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Expose port
EXPOSE 5000

# Start command
CMD ["node", "server.js"]
```

### Multi-stage Build (Optimized)

```dockerfile
# Development stage
FROM node:18-alpine AS development
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]

# Production stage
FROM node:18-alpine AS production
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 5000
CMD ["node", "server.js"]
```

### .dockerignore

```
node_modules
npm-debug.log
.env
.git
.gitignore
README.md
.vscode
coverage
.DS_Store
```

### Build and Run

```bash
# Build image
docker build -t my-backend:latest .

# Run container
docker run -d -p 5000:5000 --name backend my-backend:latest

# With environment variables
docker run -d \
  -p 5000:5000 \
  -e MONGO_URI="mongodb://mongo:27017/mydb" \
  -e JWT_SECRET="secret" \
  --name backend \
  my-backend:latest

# View logs
docker logs backend
docker logs -f backend  # Follow logs

# Stop container
docker stop backend

# Remove container
docker rm backend

# Remove image
docker rmi my-backend:latest
```

---

## Dockerizing React Frontend

### Dockerfile

```dockerfile
# Dockerfile

# Build stage
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Nginx Configuration

```nginx
# nginx.conf
server {
    listen 80;
    server_name localhost;
    
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    # Cache static assets
    location /static/ {
        root /usr/share/nginx/html;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### Build and Run

```bash
# Build
docker build -t my-frontend:latest .

# Run
docker run -d -p 3000:80 --name frontend my-frontend:latest

# Access: http://localhost:3000
```

---

## Docker Compose

### What is Docker Compose?

Orchestrates multiple containers with a single configuration file.

### docker-compose.yml (Full MERN Stack)

```yaml
version: '3.8'

services:
  # MongoDB
  mongo:
    image: mongo:6
    container_name: mongodb
    restart: unless-stopped
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password123
      MONGO_INITDB_DATABASE: myapp
    volumes:
      - mongo-data:/data/db
    networks:
      - mern-network
  
  # Backend (Node.js/Express)
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: backend
    restart: unless-stopped
    ports:
      - "5000:5000"
    environment:
      NODE_ENV: production
      PORT: 5000
      MONGO_URI: mongodb://admin:password123@mongo:27017/myapp?authSource=admin
      JWT_SECRET: your_jwt_secret_key
      CLIENT_URL: http://localhost:3000
    depends_on:
      - mongo
    networks:
      - mern-network
    volumes:
      - ./backend:/app
      - /app/node_modules
  
  # Frontend (React)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: frontend
    restart: unless-stopped
    ports:
      - "3000:80"
    environment:
      REACT_APP_API_URL: http://localhost:5000/api
    depends_on:
      - backend
    networks:
      - mern-network

volumes:
  mongo-data:

networks:
  mern-network:
    driver: bridge
```

### Development docker-compose.yml

```yaml
version: '3.8'

services:
  mongo:
    image: mongo:6
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db
  
  backend:
    build:
      context: ./backend
      target: development
    ports:
      - "5000:5000"
    environment:
      NODE_ENV: development
      MONGO_URI: mongodb://mongo:27017/myapp
    volumes:
      - ./backend:/app
      - /app/node_modules
    depends_on:
      - mongo
    command: npm run dev
  
  frontend:
    build:
      context: ./frontend
      target: development
    ports:
      - "3000:3000"
    environment:
      REACT_APP_API_URL: http://localhost:5000/api
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - backend
    stdin_open: true
    tty: true

volumes:
  mongo-data:
```

### Docker Compose Commands

```bash
# Start all services
docker-compose up

# Start in detached mode
docker-compose up -d

# Build and start
docker-compose up --build

# Stop services
docker-compose down

# Stop and remove volumes
docker-compose down -v

# View logs
docker-compose logs
docker-compose logs backend
docker-compose logs -f  # Follow logs

# List running services
docker-compose ps

# Restart service
docker-compose restart backend

# Execute command in service
docker-compose exec backend sh
docker-compose exec mongo mongosh

# Scale service
docker-compose up -d --scale backend=3
```

---

## Environment Variables

### .env File

```bash
# .env
MONGO_ROOT_USER=admin
MONGO_ROOT_PASSWORD=password123
MONGO_DATABASE=myapp
JWT_SECRET=your_jwt_secret
NODE_ENV=production
```

### Using in docker-compose.yml

```yaml
services:
  mongo:
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_ROOT_USER}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_ROOT_PASSWORD}
  
  backend:
    environment:
      MONGO_URI: mongodb://${MONGO_ROOT_USER}:${MONGO_ROOT_PASSWORD}@mongo:27017/${MONGO_DATABASE}
      JWT_SECRET: ${JWT_SECRET}
      NODE_ENV: ${NODE_ENV}
```

---

## Volumes and Persistence

### Named Volumes

```yaml
services:
  mongo:
    volumes:
      - mongo-data:/data/db  # Named volume

volumes:
  mongo-data:  # Declare volume
```

### Bind Mounts (Development)

```yaml
services:
  backend:
    volumes:
      - ./backend:/app          # Sync local code
      - /app/node_modules       # Exclude node_modules
```

---

## Docker Best Practices

### 1. Use .dockerignore

Exclude unnecessary files from image.

### 2. Multi-stage Builds

Reduce image size by separating build and runtime.

### 3. Use Alpine Images

```dockerfile
FROM node:18-alpine  # Smaller than node:18
```

### 4. Don't Run as Root

```dockerfile
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
```

### 5. Minimize Layers

```dockerfile
# Bad
RUN npm install express
RUN npm install mongoose
RUN npm install dotenv

# Good
RUN npm install express mongoose dotenv
```

### 6. Use .env Files

Don't hardcode secrets in Dockerfile or docker-compose.yml.

### 7. Health Checks

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s \
  CMD node healthcheck.js || exit 1
```

---

## Docker Hub

### Push Image

```bash
# Login
docker login

# Tag image
docker tag my-backend:latest username/my-backend:latest

# Push
docker push username/my-backend:latest
```

### Pull and Run

```bash
docker pull username/my-backend:latest
docker run -d -p 5000:5000 username/my-backend:latest
```

---

## Common Issues

### Issue 1: Port Already in Use

```bash
# Find process using port
lsof -i :5000

# Kill process
kill -9 <PID>

# Or use different port
docker run -p 5001:5000 my-backend
```

### Issue 2: Container Can't Connect to MongoDB

- Use service name (`mongo`) instead of `localhost`
- Ensure containers are on same network
- Check `depends_on` in docker-compose.yml

### Issue 3: Changes Not Reflecting

```bash
# Rebuild without cache
docker-compose up --build --force-recreate

# Or
docker-compose build --no-cache
```

---

## Interview Questions

**Q1: What is Docker?**
- Containerization platform
- Packages app + dependencies
- Consistent environments

**Q2: Docker vs VM?**
- **Docker**: Shares OS kernel, lightweight, fast startup
- **VM**: Full OS, heavier, slower startup

**Q3: What is docker-compose.yml?**
- Configuration for multi-container apps
- Defines services, networks, volumes
- `docker-compose up` to start all

**Q4: How to persist MongoDB data?**
```yaml
services:
  mongo:
    volumes:
      - mongo-data:/data/db
volumes:
  mongo-data:
```

**Q5: Multi-stage builds benefit?**
- Smaller image size
- Separate build and runtime dependencies
- More secure (no build tools in production)

---

## Summary

- **Docker**: Containerization, Dockerfile, build/run images
- **Dockerfile**: Instructions to build image, FROM, COPY, RUN, CMD
- **Docker Compose**: Multi-container orchestration, docker-compose.yml
- **MERN Stack**: Separate containers for MongoDB, backend, frontend
- **Volumes**: Persist data (named volumes, bind mounts)
- **Networks**: Containers communicate via service names
- **Best Practice**: .dockerignore, multi-stage builds, Alpine images, .env files
