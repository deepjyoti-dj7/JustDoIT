# 05. API Testing (Supertest & Database)

## Introduction

API testing verifies backend routes, controllers, and database interactions. Supertest is a popular library for testing Node.js HTTP servers. This guide covers API testing strategies for Express/Node.js backends.

---

## Supertest Basics

### Installation

```bash
npm install --save-dev supertest
```

### Basic Example

```javascript
// app.js
const express = require('express');
const app = express();

app.use(express.json());

app.get('/api/hello', (req, res) => {
  res.json({ message: 'Hello World' });
});

module.exports = app;

// app.test.js
const request = require('supertest');
const app = require('./app');

describe('GET /api/hello', () => {
  test('returns hello message', async () => {
    const response = await request(app)
      .get('/api/hello')
      .expect('Content-Type', /json/)
      .expect(200);
    
    expect(response.body.message).toBe('Hello World');
  });
});
```

---

## Testing HTTP Methods

### GET Request

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();

const users = [
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
];

router.get('/', (req, res) => {
  res.json(users);
});

router.get('/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ error: 'User not found' });
  res.json(user);
});

module.exports = router;

// users.test.js
const request = require('supertest');
const app = require('../app');

describe('User API', () => {
  describe('GET /api/users', () => {
    test('returns all users', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect(200);
      
      expect(response.body).toHaveLength(2);
      expect(response.body[0]).toHaveProperty('name');
    });
  });
  
  describe('GET /api/users/:id', () => {
    test('returns user by id', async () => {
      const response = await request(app)
        .get('/api/users/1')
        .expect(200);
      
      expect(response.body.name).toBe('John Doe');
      expect(response.body.email).toBe('john@example.com');
    });
    
    test('returns 404 for non-existent user', async () => {
      const response = await request(app)
        .get('/api/users/999')
        .expect(404);
      
      expect(response.body.error).toBe('User not found');
    });
  });
});
```

### POST Request

```javascript
// routes/users.js
router.post('/', (req, res) => {
  const { name, email } = req.body;
  
  if (!name || !email) {
    return res.status(400).json({ error: 'Name and email are required' });
  }
  
  const newUser = {
    id: users.length + 1,
    name,
    email
  };
  
  users.push(newUser);
  res.status(201).json(newUser);
});

// users.test.js
describe('POST /api/users', () => {
  test('creates new user', async () => {
    const newUser = {
      name: 'Bob Johnson',
      email: 'bob@example.com'
    };
    
    const response = await request(app)
      .post('/api/users')
      .send(newUser)
      .expect(201);
    
    expect(response.body).toHaveProperty('id');
    expect(response.body.name).toBe('Bob Johnson');
    expect(response.body.email).toBe('bob@example.com');
  });
  
  test('returns 400 for missing fields', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ name: 'Bob' })
      .expect(400);
    
    expect(response.body.error).toBe('Name and email are required');
  });
});
```

### PUT/PATCH Request

```javascript
// routes/users.js
router.put('/:id', (req, res) => {
  const user = users.find(u => u.id === parseInt(req.params.id));
  if (!user) return res.status(404).json({ error: 'User not found' });
  
  const { name, email } = req.body;
  if (name) user.name = name;
  if (email) user.email = email;
  
  res.json(user);
});

// users.test.js
describe('PUT /api/users/:id', () => {
  test('updates user', async () => {
    const response = await request(app)
      .put('/api/users/1')
      .send({ name: 'John Updated' })
      .expect(200);
    
    expect(response.body.name).toBe('John Updated');
  });
  
  test('returns 404 for non-existent user', async () => {
    await request(app)
      .put('/api/users/999')
      .send({ name: 'Test' })
      .expect(404);
  });
});
```

### DELETE Request

```javascript
// routes/users.js
router.delete('/:id', (req, res) => {
  const index = users.findIndex(u => u.id === parseInt(req.params.id));
  if (index === -1) return res.status(404).json({ error: 'User not found' });
  
  users.splice(index, 1);
  res.status(204).send();
});

// users.test.js
describe('DELETE /api/users/:id', () => {
  test('deletes user', async () => {
    await request(app)
      .delete('/api/users/1')
      .expect(204);
    
    // Verify deletion
    await request(app)
      .get('/api/users/1')
      .expect(404);
  });
});
```

---

## Testing with MongoDB

### Setup Test Database

```javascript
// config/database.js
const mongoose = require('mongoose');

const connectDB = async () => {
  const dbURI = process.env.NODE_ENV === 'test'
    ? process.env.MONGO_TEST_URI
    : process.env.MONGO_URI;
  
  await mongoose.connect(dbURI);
};

module.exports = connectDB;

// .env.test
MONGO_TEST_URI=mongodb://localhost:27017/test_db
NODE_ENV=test
```

### Test Helpers

```javascript
// tests/setup.js
const mongoose = require('mongoose');
const { MongoMemoryServer } = require('mongodb-memory-server');

let mongoServer;

// Connect to in-memory database before tests
beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  await mongoose.connect(mongoUri);
});

// Clear database between tests
afterEach(async () => {
  const collections = mongoose.connection.collections;
  for (const key in collections) {
    await collections[key].deleteMany({});
  }
});

// Disconnect and stop server after tests
afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});
```

### User Model

```javascript
// models/User.js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  }
}, { timestamps: true });

module.exports = mongoose.model('User', userSchema);
```

### Testing with Real Database

```javascript
// routes/users.test.js
const request = require('supertest');
const mongoose = require('mongoose');
const app = require('../app');
const User = require('../models/User');

require('./setup'); // Import test setup

describe('User API with Database', () => {
  describe('POST /api/users', () => {
    test('creates user in database', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      expect(response.body).toHaveProperty('_id');
      expect(response.body.name).toBe('John Doe');
      
      // Verify in database
      const dbUser = await User.findById(response.body._id);
      expect(dbUser).toBeTruthy();
      expect(dbUser.email).toBe('john@example.com');
    });
    
    test('prevents duplicate email', async () => {
      await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      });
      
      const response = await request(app)
        .post('/api/users')
        .send({
          name: 'Jane Doe',
          email: 'john@example.com',
          password: 'password456'
        })
        .expect(400);
      
      expect(response.body.error).toContain('email');
    });
  });
  
  describe('GET /api/users', () => {
    beforeEach(async () => {
      await User.create([
        { name: 'User 1', email: 'user1@example.com', password: 'pass1' },
        { name: 'User 2', email: 'user2@example.com', password: 'pass2' },
        { name: 'User 3', email: 'user3@example.com', password: 'pass3' }
      ]);
    });
    
    test('returns all users', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect(200);
      
      expect(response.body).toHaveLength(3);
    });
  });
  
  describe('GET /api/users/:id', () => {
    test('returns user by id', async () => {
      const user = await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      });
      
      const response = await request(app)
        .get(`/api/users/${user._id}`)
        .expect(200);
      
      expect(response.body.name).toBe('John Doe');
      expect(response.body.email).toBe('john@example.com');
    });
    
    test('returns 404 for invalid id', async () => {
      const fakeId = new mongoose.Types.ObjectId();
      
      await request(app)
        .get(`/api/users/${fakeId}`)
        .expect(404);
    });
  });
  
  describe('PUT /api/users/:id', () => {
    test('updates user', async () => {
      const user = await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      });
      
      const response = await request(app)
        .put(`/api/users/${user._id}`)
        .send({ name: 'John Updated' })
        .expect(200);
      
      expect(response.body.name).toBe('John Updated');
      
      // Verify in database
      const updatedUser = await User.findById(user._id);
      expect(updatedUser.name).toBe('John Updated');
    });
  });
  
  describe('DELETE /api/users/:id', () => {
    test('deletes user', async () => {
      const user = await User.create({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123'
      });
      
      await request(app)
        .delete(`/api/users/${user._id}`)
        .expect(204);
      
      // Verify deletion
      const deletedUser = await User.findById(user._id);
      expect(deletedUser).toBeNull();
    });
  });
});
```

---

## Testing Authentication

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};

module.exports = authMiddleware;

// routes/auth.test.js
const request = require('supertest');
const jwt = require('jsonwebtoken');
const app = require('../app');
const User = require('../models/User');

require('./setup');

describe('Authentication', () => {
  describe('POST /api/auth/register', () => {
    test('registers new user', async () => {
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          name: 'John Doe',
          email: 'john@example.com',
          password: 'password123'
        })
        .expect(201);
      
      expect(response.body).toHaveProperty('token');
      expect(response.body.user.email).toBe('john@example.com');
    });
  });
  
  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      await request(app)
        .post('/api/auth/register')
        .send({
          name: 'John Doe',
          email: 'john@example.com',
          password: 'password123'
        });
    });
    
    test('logs in with valid credentials', async () => {
      const response = await request(app)
        .post('/api/auth/login')
        .send({
          email: 'john@example.com',
          password: 'password123'
        })
        .expect(200);
      
      expect(response.body).toHaveProperty('token');
    });
    
    test('rejects invalid password', async () => {
      await request(app)
        .post('/api/auth/login')
        .send({
          email: 'john@example.com',
          password: 'wrongpassword'
        })
        .expect(401);
    });
  });
  
  describe('Protected Routes', () => {
    let token;
    
    beforeEach(async () => {
      const response = await request(app)
        .post('/api/auth/register')
        .send({
          name: 'John Doe',
          email: 'john@example.com',
          password: 'password123'
        });
      
      token = response.body.token;
    });
    
    test('allows access with valid token', async () => {
      await request(app)
        .get('/api/profile')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);
    });
    
    test('denies access without token', async () => {
      await request(app)
        .get('/api/profile')
        .expect(401);
    });
    
    test('denies access with invalid token', async () => {
      await request(app)
        .get('/api/profile')
        .set('Authorization', 'Bearer invalid_token')
        .expect(401);
    });
  });
});
```

---

## Testing Query Parameters

```javascript
// routes/products.js
router.get('/', async (req, res) => {
  const { category, minPrice, maxPrice, sort } = req.query;
  
  let query = {};
  if (category) query.category = category;
  if (minPrice || maxPrice) {
    query.price = {};
    if (minPrice) query.price.$gte = Number(minPrice);
    if (maxPrice) query.price.$lte = Number(maxPrice);
  }
  
  const sortOptions = sort === 'price' ? { price: 1 } : { createdAt: -1 };
  
  const products = await Product.find(query).sort(sortOptions);
  res.json(products);
});

// products.test.js
describe('GET /api/products', () => {
  test('filters by category', async () => {
    const response = await request(app)
      .get('/api/products')
      .query({ category: 'electronics' })
      .expect(200);
    
    response.body.forEach(product => {
      expect(product.category).toBe('electronics');
    });
  });
  
  test('filters by price range', async () => {
    const response = await request(app)
      .get('/api/products')
      .query({ minPrice: 10, maxPrice: 50 })
      .expect(200);
    
    response.body.forEach(product => {
      expect(product.price).toBeGreaterThanOrEqual(10);
      expect(product.price).toBeLessThanOrEqual(50);
    });
  });
});
```

---

## Interview Questions

**Q1: What is Supertest?**
- Library for testing HTTP servers
- Works with Express, Koa, etc.
- Provides chainable API for assertions

**Q2: How to test database operations?**
- Use in-memory database (MongoDB Memory Server)
- Clear data between tests
- Verify operations in database

**Q3: How to test protected routes?**
- Generate valid JWT token
- Set Authorization header
- Test both authorized and unauthorized access

**Q4: Best practices for API testing?**
- Isolate tests (clear DB between tests)
- Test happy path and error cases
- Use beforeEach/afterEach for setup/cleanup
- Mock external services

**Q5: How to test different HTTP methods?**
```javascript
await request(app).get('/api/users').expect(200);
await request(app).post('/api/users').send(data).expect(201);
await request(app).put('/api/users/1').send(data).expect(200);
await request(app).delete('/api/users/1').expect(204);
```

---

## Summary

- **Supertest**: Testing HTTP servers, chainable API
- **HTTP Methods**: GET, POST, PUT, DELETE testing
- **Database**: MongoDB Memory Server, clear between tests
- **Authentication**: Test login, register, protected routes
- **Query Params**: Test filtering, sorting, pagination
- **Setup/Teardown**: beforeAll, afterAll, beforeEach, afterEach
- **Best Practice**: Isolate tests, test error cases, verify in DB
