# 04. Mocking, Spies & Coverage

## Introduction

Mocking and spies help isolate code during testing by replacing dependencies. Code coverage measures how much code is tested. This guide covers Jest mocking, spies, and coverage tools.

---

## Why Mocking?

### Benefits

1. **Isolation** - Test units independently
2. **Speed** - Avoid slow operations (API calls, DB queries)
3. **Control** - Simulate edge cases and errors
4. **Reliability** - Tests don't depend on external services
5. **Determinism** - Consistent, predictable results

---

## Jest Mock Functions

### jest.fn()

```javascript
// Create mock function
const mockFn = jest.fn();

// Call it
mockFn('hello');
mockFn('world');

// Assertions
expect(mockFn).toHaveBeenCalled();
expect(mockFn).toHaveBeenCalledTimes(2);
expect(mockFn).toHaveBeenCalledWith('hello');
expect(mockFn).toHaveBeenLastCalledWith('world');

// Check all calls
expect(mockFn.mock.calls).toEqual([['hello'], ['world']]);
```

### Mock Return Values

```javascript
// Return specific value
const mockFn = jest.fn().mockReturnValue(42);
expect(mockFn()).toBe(42);

// Return different values on consecutive calls
const mockFn = jest.fn()
  .mockReturnValueOnce('first')
  .mockReturnValueOnce('second')
  .mockReturnValue('default');

expect(mockFn()).toBe('first');
expect(mockFn()).toBe('second');
expect(mockFn()).toBe('default');

// Async mock
const mockAsync = jest.fn().mockResolvedValue('async result');
await expect(mockAsync()).resolves.toBe('async result');

// Reject with error
const mockError = jest.fn().mockRejectedValue(new Error('Failed'));
await expect(mockError()).rejects.toThrow('Failed');
```

### Mock Implementation

```javascript
const mockFn = jest.fn((a, b) => a + b);
expect(mockFn(2, 3)).toBe(5);

// mockImplementation
const mockFn = jest.fn().mockImplementation((a, b) => a + b);

// mockImplementationOnce
const mockFn = jest.fn()
  .mockImplementationOnce(() => 'first')
  .mockImplementationOnce(() => 'second');

expect(mockFn()).toBe('first');
expect(mockFn()).toBe('second');
```

---

## Mocking Modules

### jest.mock()

```javascript
// utils.js
export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// calculator.js
import { add, multiply } from './utils';

export function calculate(a, b) {
  const sum = add(a, b);
  const product = multiply(a, b);
  return { sum, product };
}

// calculator.test.js
import { calculate } from './calculator';
import { add, multiply } from './utils';

jest.mock('./utils'); // Auto-mocks all exports

test('calculate uses add and multiply', () => {
  add.mockReturnValue(10);
  multiply.mockReturnValue(20);
  
  const result = calculate(2, 3);
  
  expect(add).toHaveBeenCalledWith(2, 3);
  expect(multiply).toHaveBeenCalledWith(2, 3);
  expect(result).toEqual({ sum: 10, product: 20 });
});
```

### Partial Mocking

```javascript
// Mock only specific functions
jest.mock('./utils', () => ({
  ...jest.requireActual('./utils'), // Keep real implementations
  multiply: jest.fn() // Mock only multiply
}));

import { add, multiply } from './utils';

test('partial mock', () => {
  multiply.mockReturnValue(100);
  
  expect(add(2, 3)).toBe(5); // Real implementation
  expect(multiply(2, 3)).toBe(100); // Mocked
});
```

### Mock ES6 Classes

```javascript
// UserService.js
class UserService {
  async getUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
}

export default UserService;

// UserController.js
import UserService from './UserService';

class UserController {
  constructor() {
    this.userService = new UserService();
  }
  
  async getUserDetails(id) {
    const user = await this.userService.getUser(id);
    return { ...user, displayName: user.name.toUpperCase() };
  }
}

export default UserController;

// UserController.test.js
import UserController from './UserController';
import UserService from './UserService';

jest.mock('./UserService');

test('getUserDetails transforms user data', async () => {
  const mockUser = { id: 1, name: 'John Doe' };
  
  UserService.prototype.getUser = jest.fn().mockResolvedValue(mockUser);
  
  const controller = new UserController();
  const result = await controller.getUserDetails(1);
  
  expect(result.displayName).toBe('JOHN DOE');
  expect(UserService.prototype.getUser).toHaveBeenCalledWith(1);
});
```

---

## Mocking Axios

```javascript
// api.js
import axios from 'axios';

export async function fetchUser(id) {
  const response = await axios.get(`/api/users/${id}`);
  return response.data;
}

// api.test.js
import axios from 'axios';
import { fetchUser } from './api';

jest.mock('axios');

test('fetchUser returns user data', async () => {
  const mockUser = { id: 1, name: 'John Doe' };
  axios.get.mockResolvedValue({ data: mockUser });
  
  const user = await fetchUser(1);
  
  expect(axios.get).toHaveBeenCalledWith('/api/users/1');
  expect(user).toEqual(mockUser);
});

test('fetchUser handles error', async () => {
  axios.get.mockRejectedValue(new Error('Network error'));
  
  await expect(fetchUser(1)).rejects.toThrow('Network error');
});
```

---

## Mocking Local Storage

```javascript
// storage.js
export function saveToken(token) {
  localStorage.setItem('authToken', token);
}

export function getToken() {
  return localStorage.getItem('authToken');
}

export function clearToken() {
  localStorage.removeItem('authToken');
}

// storage.test.js
import { saveToken, getToken, clearToken } from './storage';

// Mock localStorage
const localStorageMock = (() => {
  let store = {};
  
  return {
    getItem: (key) => store[key] || null,
    setItem: (key, value) => {
      store[key] = value.toString();
    },
    removeItem: (key) => {
      delete store[key];
    },
    clear: () => {
      store = {};
    }
  };
})();

global.localStorage = localStorageMock;

beforeEach(() => {
  localStorage.clear();
});

test('saveToken stores token', () => {
  saveToken('abc123');
  expect(localStorage.getItem('authToken')).toBe('abc123');
});

test('getToken retrieves token', () => {
  localStorage.setItem('authToken', 'xyz789');
  expect(getToken()).toBe('xyz789');
});

test('clearToken removes token', () => {
  localStorage.setItem('authToken', 'abc123');
  clearToken();
  expect(localStorage.getItem('authToken')).toBeNull();
});
```

---

## Spies

### jest.spyOn()

```javascript
// math.js
export const calculator = {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b
};

// math.test.js
import { calculator } from './math';

test('spy on add method', () => {
  const spy = jest.spyOn(calculator, 'add');
  
  const result = calculator.add(2, 3);
  
  expect(spy).toHaveBeenCalledWith(2, 3);
  expect(result).toBe(5); // Real implementation still called
  
  spy.mockRestore(); // Restore original implementation
});

test('spy with mock implementation', () => {
  const spy = jest.spyOn(calculator, 'multiply').mockReturnValue(100);
  
  const result = calculator.multiply(2, 3);
  
  expect(spy).toHaveBeenCalledWith(2, 3);
  expect(result).toBe(100); // Mocked value
  
  spy.mockRestore();
  expect(calculator.multiply(2, 3)).toBe(6); // Original implementation
});
```

### Spy on Console

```javascript
test('logs error message', () => {
  const consoleSpy = jest.spyOn(console, 'error').mockImplementation();
  
  console.error('Something went wrong');
  
  expect(consoleSpy).toHaveBeenCalledWith('Something went wrong');
  
  consoleSpy.mockRestore();
});
```

---

## Mocking Timers

### jest.useFakeTimers()

```javascript
// debounce.js
export function debounce(fn, delay) {
  let timeoutId;
  
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

// debounce.test.js
import { debounce } from './debounce';

jest.useFakeTimers();

test('debounce delays function execution', () => {
  const mockFn = jest.fn();
  const debouncedFn = debounce(mockFn, 1000);
  
  debouncedFn('hello');
  
  // Not called yet
  expect(mockFn).not.toHaveBeenCalled();
  
  // Fast-forward time
  jest.advanceTimersByTime(500);
  expect(mockFn).not.toHaveBeenCalled();
  
  jest.advanceTimersByTime(500);
  expect(mockFn).toHaveBeenCalledWith('hello');
});

test('debounce cancels previous calls', () => {
  const mockFn = jest.fn();
  const debouncedFn = debounce(mockFn, 1000);
  
  debouncedFn('first');
  jest.advanceTimersByTime(500);
  
  debouncedFn('second');
  jest.advanceTimersByTime(500);
  
  debouncedFn('third');
  jest.advanceTimersByTime(1000);
  
  // Only last call executed
  expect(mockFn).toHaveBeenCalledTimes(1);
  expect(mockFn).toHaveBeenCalledWith('third');
});

afterEach(() => {
  jest.clearAllTimers();
});
```

---

## Code Coverage

### Running Coverage

```bash
# Run tests with coverage
npm test -- --coverage

# Coverage for specific files
npm test -- --coverage --collectCoverageFrom="src/components/**/*.js"

# Watch mode with coverage
npm test -- --coverage --watchAll
```

### Coverage Report

```
--------------------|---------|----------|---------|---------|-------------------
File                | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
--------------------|---------|----------|---------|---------|-------------------
All files           |   85.71 |    83.33 |      80 |   85.71 |                  
 calculator.js      |     100 |      100 |     100 |     100 |                  
 utils.js           |   66.67 |       50 |      50 |   66.67 | 8-10             
--------------------|---------|----------|---------|---------|-------------------
```

### Coverage Metrics

- **% Stmts** - Statement coverage
- **% Branch** - Branch coverage (if/else)
- **% Funcs** - Function coverage
- **% Lines** - Line coverage

### Coverage Configuration

```javascript
// jest.config.js
module.exports = {
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',
    '!src/**/*.test.js',
    '!src/reportWebVitals.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/components/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  },
  coverageReporters: ['text', 'lcov', 'html']
};
```

### Ignoring Code from Coverage

```javascript
// Ignore next line
/* istanbul ignore next */
function unreachableCode() {
  // This won't be counted in coverage
}

// Ignore function
/* istanbul ignore next */
function debugFunction() {
  console.log('Debug only');
}

// Ignore else branch
if (condition) {
  // tested
} /* istanbul ignore next */ else {
  // not tested, but ignored
}
```

---

## Manual Mocks

### __mocks__ Directory

```
src/
  __mocks__/
    axios.js
    fs.js
  components/
  utils/
```

```javascript
// __mocks__/axios.js
const axios = {
  get: jest.fn(() => Promise.resolve({ data: {} })),
  post: jest.fn(() => Promise.resolve({ data: {} })),
  put: jest.fn(() => Promise.resolve({ data: {} })),
  delete: jest.fn(() => Promise.resolve({ data: {} }))
};

export default axios;
```

---

## Best Practices

### 1. Clear Mocks Between Tests

```javascript
beforeEach(() => {
  jest.clearAllMocks();
});

// Or in individual tests
test('example', () => {
  mockFn.mockClear();
  // test code
});
```

### 2. Mock Only What You Need

```javascript
// Bad - mocking everything
jest.mock('./utils');

// Good - partial mock
jest.mock('./utils', () => ({
  ...jest.requireActual('./utils'),
  expensiveFunction: jest.fn()
}));
```

### 3. Restore Mocks

```javascript
afterEach(() => {
  jest.restoreAllMocks();
});
```

### 4. Use Meaningful Assertions

```javascript
// Bad
expect(mockFn).toHaveBeenCalled();

// Good
expect(mockFn).toHaveBeenCalledWith({ id: 1, name: 'John' });
expect(mockFn).toHaveBeenCalledTimes(1);
```

---

## Interview Questions

**Q1: What is mocking?**
- Replacing real implementations with test doubles
- Isolates code for testing
- Controls behavior and return values

**Q2: Difference between mock and spy?**
- **Mock**: Completely replaces implementation
- **Spy**: Wraps real implementation, tracks calls

**Q3: What is code coverage?**
- Percentage of code executed during tests
- Metrics: statements, branches, functions, lines
- Tool: `jest --coverage`

**Q4: How to mock axios in Jest?**
```javascript
jest.mock('axios');
axios.get.mockResolvedValue({ data: mockData });
```

**Q5: What are fake timers?**
- Mock implementation of setTimeout/setInterval
- Control time progression in tests
- Use `jest.useFakeTimers()` and `jest.advanceTimersByTime()`

---

## Summary

- **jest.fn()**: Create mock functions
- **jest.mock()**: Mock entire modules
- **jest.spyOn()**: Spy on existing methods
- **Mocking**: Axios, localStorage, timers, classes
- **Coverage**: --coverage flag, thresholds, reports
- **Clear Mocks**: beforeEach, afterEach
- **Best Practice**: Mock only what's needed, use meaningful assertions
