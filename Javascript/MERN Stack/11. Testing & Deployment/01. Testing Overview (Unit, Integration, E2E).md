# 01. Testing Overview (Unit, Integration, E2E)

## Introduction

Testing ensures code quality, prevents bugs, and provides confidence in refactoring. This guide covers different testing levels: Unit, Integration, and End-to-End (E2E) testing for MERN applications.

---

## Why Testing?

### Benefits

1. **Catch Bugs Early** - Find issues before production
2. **Refactoring Confidence** - Change code safely
3. **Documentation** - Tests describe expected behavior
4. **Reduce Regression** - Prevent old bugs from returning
5. **Faster Development** - Less time debugging
6. **Better Design** - Testable code is often better designed

### Testing Pyramid

```
        /\
       /  \      E2E Tests (Few)
      /____\     - Slowest, most expensive
     /      \    - Test complete user flows
    /        \   
   / Integration\  Integration Tests (Some)
  /______________\ - Test module interactions
 /                \ 
/    Unit Tests    \ Unit Tests (Many)
____________________  - Fast, focused, abundant
                      - Test individual functions
```

---

## Testing Levels

### 1. Unit Testing

**Definition**: Test individual units of code in isolation (functions, classes, components).

**Characteristics**:
- Fast execution
- Isolated (mock dependencies)
- Test one thing at a time
- Most abundant in codebase

**Example**:
```javascript
// utils.js
export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// utils.test.js
import { add, multiply } from './utils';

test('add should sum two numbers', () => {
  expect(add(2, 3)).toBe(5);
});

test('multiply should multiply two numbers', () => {
  expect(multiply(3, 4)).toBe(12);
});
```

**React Component Unit Test**:
```javascript
// Button.js
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// Button.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

test('renders button with text', () => {
  render(<Button>Click me</Button>);
  expect(screen.getByText('Click me')).toBeInTheDocument();
});

test('calls onClick when clicked', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click</Button>);
  
  fireEvent.click(screen.getByText('Click'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

**Backend Unit Test**:
```javascript
// userService.js
class UserService {
  createUser(userData) {
    if (!userData.email) {
      throw new Error('Email is required');
    }
    return { id: 1, ...userData };
  }
}

// userService.test.js
const UserService = require('./userService');

test('creates user with valid data', () => {
  const service = new UserService();
  const user = service.createUser({ email: 'test@test.com', name: 'John' });
  
  expect(user).toHaveProperty('id');
  expect(user.email).toBe('test@test.com');
});

test('throws error when email is missing', () => {
  const service = new UserService();
  
  expect(() => {
    service.createUser({ name: 'John' });
  }).toThrow('Email is required');
});
```

---

### 2. Integration Testing

**Definition**: Test how multiple units work together (modules, components, API + database).

**Characteristics**:
- Test interactions between components
- May use real dependencies or test doubles
- Slower than unit tests
- Test workflows and data flow

**React Integration Test**:
```javascript
// LoginForm.js
import { useState } from 'react';
import axios from 'axios';

function LoginForm({ onSuccess }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const response = await axios.post('/api/login', { email, password });
      onSuccess(response.data);
    } catch (err) {
      setError('Login failed');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      {error && <div role="alert">{error}</div>}
      <button type="submit">Login</button>
    </form>
  );
}

// LoginForm.test.js
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import axios from 'axios';
import LoginForm from './LoginForm';

jest.mock('axios');

test('successful login flow', async () => {
  const onSuccess = jest.fn();
  const mockResponse = { data: { token: 'abc123', user: { name: 'John' } } };
  axios.post.mockResolvedValue(mockResponse);
  
  render(<LoginForm onSuccess={onSuccess} />);
  
  // Fill form
  fireEvent.change(screen.getByPlaceholderText('Email'), {
    target: { value: 'test@test.com' }
  });
  fireEvent.change(screen.getByPlaceholderText('Password'), {
    target: { value: 'password123' }
  });
  
  // Submit
  fireEvent.click(screen.getByText('Login'));
  
  // Verify API call
  await waitFor(() => {
    expect(axios.post).toHaveBeenCalledWith('/api/login', {
      email: 'test@test.com',
      password: 'password123'
    });
  });
  
  // Verify success callback
  expect(onSuccess).toHaveBeenCalledWith(mockResponse.data);
});
```

**Backend Integration Test (API + Database)**:
```javascript
// userController.test.js
const request = require('supertest');
const app = require('./app');
const User = require('./models/User');
const mongoose = require('mongoose');

beforeAll(async () => {
  await mongoose.connect(process.env.TEST_DATABASE_URL);
});

afterAll(async () => {
  await mongoose.connection.close();
});

beforeEach(async () => {
  await User.deleteMany({});
});

test('POST /api/users creates a user', async () => {
  const userData = {
    name: 'John Doe',
    email: 'john@test.com',
    password: 'password123'
  };
  
  const response = await request(app)
    .post('/api/users')
    .send(userData)
    .expect(201);
  
  expect(response.body).toHaveProperty('id');
  expect(response.body.email).toBe(userData.email);
  
  // Verify in database
  const user = await User.findById(response.body.id);
  expect(user).toBeTruthy();
  expect(user.name).toBe(userData.name);
});

test('GET /api/users returns all users', async () => {
  // Seed database
  await User.create([
    { name: 'User 1', email: 'user1@test.com', password: 'pass' },
    { name: 'User 2', email: 'user2@test.com', password: 'pass' }
  ]);
  
  const response = await request(app)
    .get('/api/users')
    .expect(200);
  
  expect(response.body).toHaveLength(2);
});
```

---

### 3. End-to-End (E2E) Testing

**Definition**: Test complete user flows from start to finish, simulating real user behavior.

**Characteristics**:
- Test entire application stack
- Use real browser (Cypress, Playwright)
- Slowest and most expensive
- Catch integration issues across layers

**Cypress E2E Test**:
```javascript
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('http://localhost:3000/login');
  });
  
  it('should login successfully with valid credentials', () => {
    // Fill login form
    cy.get('input[type="email"]').type('user@example.com');
    cy.get('input[type="password"]').type('password123');
    
    // Submit
    cy.get('button[type="submit"]').click();
    
    // Verify redirect to dashboard
    cy.url().should('include', '/dashboard');
    cy.contains('Welcome back').should('be.visible');
    
    // Verify token stored
    cy.window().its('localStorage.token').should('exist');
  });
  
  it('should show error with invalid credentials', () => {
    cy.get('input[type="email"]').type('wrong@example.com');
    cy.get('input[type="password"]').type('wrongpass');
    cy.get('button[type="submit"]').click();
    
    // Verify error message
    cy.contains('Invalid credentials').should('be.visible');
    
    // Verify still on login page
    cy.url().should('include', '/login');
  });
});

describe('Full User Journey', () => {
  it('complete signup to post creation flow', () => {
    // Sign up
    cy.visit('/signup');
    cy.get('[name="name"]').type('John Doe');
    cy.get('[name="email"]').type('john@example.com');
    cy.get('[name="password"]').type('SecurePass123!');
    cy.get('button[type="submit"]').click();
    
    // Verify dashboard
    cy.url().should('include', '/dashboard');
    
    // Create post
    cy.get('[data-testid="create-post-btn"]').click();
    cy.get('[name="title"]').type('My First Post');
    cy.get('[name="content"]').type('This is my first post content.');
    cy.get('button[type="submit"]').click();
    
    // Verify post appears
    cy.contains('My First Post').should('be.visible');
    
    // Logout
    cy.get('[data-testid="logout-btn"]').click();
    cy.url().should('include', '/login');
  });
});
```

---

## Test Comparison

| Aspect | Unit | Integration | E2E |
|--------|------|-------------|-----|
| **Scope** | Single function/component | Multiple modules | Entire application |
| **Speed** | Very fast (ms) | Moderate (seconds) | Slow (minutes) |
| **Cost** | Low | Medium | High |
| **Isolation** | High (mocked deps) | Medium | Low (real system) |
| **Confidence** | Low | Medium | High |
| **Maintenance** | Easy | Moderate | Complex |
| **Quantity** | Many (70-80%) | Some (15-20%) | Few (5-10%) |
| **Tools** | Jest, Mocha | Jest, Supertest | Cypress, Playwright |
| **Debugging** | Easy | Moderate | Difficult |

---

## Testing Strategy for MERN Stack

### Frontend (React)

```
Unit Tests (70%):
- Utility functions
- Custom hooks
- Individual components (isolated)
- Pure functions

Integration Tests (20%):
- Form submissions with API calls
- Component interactions
- Context providers with consumers
- Route navigation

E2E Tests (10%):
- Critical user flows (login, checkout)
- Multi-page workflows
- Error scenarios
```

### Backend (Node.js/Express)

```
Unit Tests (70%):
- Controllers (with mocked services)
- Services (with mocked models)
- Middleware
- Utility functions
- Validators

Integration Tests (20%):
- API endpoints (with test database)
- Database operations
- Authentication flows
- File uploads

E2E Tests (10%):
- Complete API workflows
- External service integrations
- Payment processing
```

---

## Test-Driven Development (TDD)

### TDD Cycle (Red-Green-Refactor)

```
1. RED: Write a failing test
   ↓
2. GREEN: Write minimal code to pass
   ↓
3. REFACTOR: Improve code quality
   ↓
   (Repeat)
```

### Example: TDD Workflow

```javascript
// 1. RED - Write failing test
test('calculateDiscount applies 10% discount', () => {
  expect(calculateDiscount(100, 10)).toBe(90);
});
// Test fails (function doesn't exist)

// 2. GREEN - Write minimal code
function calculateDiscount(price, percentage) {
  return price - (price * percentage / 100);
}
// Test passes

// 3. REFACTOR - Improve code
function calculateDiscount(price, percentage) {
  if (price < 0 || percentage < 0 || percentage > 100) {
    throw new Error('Invalid input');
  }
  return price - (price * percentage / 100);
}

// Add more tests for edge cases
test('throws error for negative price', () => {
  expect(() => calculateDiscount(-10, 10)).toThrow('Invalid input');
});
```

---

## Testing Best Practices

### 1. AAA Pattern (Arrange-Act-Assert)

```javascript
test('user registration', () => {
  // Arrange - Setup
  const userData = { name: 'John', email: 'john@test.com' };
  const userService = new UserService();
  
  // Act - Execute
  const result = userService.register(userData);
  
  // Assert - Verify
  expect(result).toHaveProperty('id');
  expect(result.email).toBe(userData.email);
});
```

### 2. Test One Thing

```javascript
// Bad - Testing multiple things
test('user operations', () => {
  const user = createUser();
  expect(user).toBeTruthy();
  
  const updated = updateUser(user.id, { name: 'New Name' });
  expect(updated.name).toBe('New Name');
  
  deleteUser(user.id);
  expect(getUser(user.id)).toBeNull();
});

// Good - Separate tests
test('createUser creates a user', () => {
  const user = createUser();
  expect(user).toBeTruthy();
});

test('updateUser updates user name', () => {
  const user = createUser();
  const updated = updateUser(user.id, { name: 'New Name' });
  expect(updated.name).toBe('New Name');
});

test('deleteUser removes user', () => {
  const user = createUser();
  deleteUser(user.id);
  expect(getUser(user.id)).toBeNull();
});
```

### 3. Descriptive Test Names

```javascript
// Bad
test('test1', () => { /* ... */ });
test('user', () => { /* ... */ });

// Good
test('createUser throws error when email is missing', () => { /* ... */ });
test('login returns token for valid credentials', () => { /* ... */ });
test('cart shows empty message when no items', () => { /* ... */ });
```

### 4. Avoid Test Interdependence

```javascript
// Bad - Tests depend on execution order
let userId;

test('create user', () => {
  userId = createUser();
  expect(userId).toBeTruthy();
});

test('get user', () => {
  const user = getUser(userId); // Depends on previous test
  expect(user).toBeTruthy();
});

// Good - Independent tests
test('create user', () => {
  const userId = createUser();
  expect(userId).toBeTruthy();
});

test('get user', () => {
  const userId = createUser(); // Create own data
  const user = getUser(userId);
  expect(user).toBeTruthy();
});
```

---

## Interview Questions

**Q1: What's the difference between unit and integration tests?**
- **Unit**: Test single function/component in isolation with mocked dependencies
- **Integration**: Test multiple components working together with real or test dependencies

**Q2: What is the testing pyramid?**
- Majority unit tests (fast, cheap, many)
- Some integration tests (moderate speed/cost)
- Few E2E tests (slow, expensive, critical paths only)

**Q3: What is TDD?**
- Test-Driven Development: Write test first, then code to pass it
- Cycle: Red (fail) → Green (pass) → Refactor
- Benefits: Better design, full coverage, regression prevention

**Q4: When to use E2E tests?**
- Critical user journeys (login, checkout, payment)
- Complex workflows across multiple pages
- Smoke tests before deployment

**Q5: What's the AAA pattern?**
- **Arrange**: Set up test data and conditions
- **Act**: Execute the code being tested
- **Assert**: Verify the expected outcome

---

## Summary

- **Unit Tests**: Individual functions/components, fast, isolated, abundant
- **Integration Tests**: Multiple modules together, moderate speed, workflows
- **E2E Tests**: Complete user flows, slow, real browser, critical paths
- **Testing Pyramid**: Many unit, some integration, few E2E
- **TDD**: Write test first, then implementation
- **Best Practices**: AAA pattern, test one thing, descriptive names, independence
- **MERN Strategy**: 70% unit, 20% integration, 10% E2E
- **Tools**: Jest (unit/integration), Cypress (E2E), Supertest (API)
