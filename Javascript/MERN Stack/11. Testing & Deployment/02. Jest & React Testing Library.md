# 02. Jest & React Testing Library

## Introduction

**Jest** is a JavaScript testing framework by Facebook, and **React Testing Library** (RTL) is a testing utility for React. Together, they provide a complete testing solution for React applications.

---

## Jest Overview

### What is Jest?

- **Test Runner**: Executes tests and reports results
- **Assertion Library**: Provides `expect()` matchers
- **Mocking**: Built-in mocking capabilities
- **Coverage**: Code coverage reports
- **Snapshot Testing**: UI snapshot comparison
- **Watch Mode**: Re-runs tests on file changes

### Key Features

```javascript
✅ Zero configuration for Create React App
✅ Fast parallel test execution
✅ Built-in code coverage
✅ Powerful mocking (functions, modules, timers)
✅ Snapshot testing
✅ Interactive watch mode
```

---

## Installation & Setup

### Create React App (Pre-configured)

```bash
npx create-react-app my-app
cd my-app
npm test
```

### Manual Setup (Existing Project)

```bash
npm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

### Configuration (jest.config.js)

```javascript
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js'
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',
    '!src/reportWebVitals.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### Setup File (src/setupTests.js)

```javascript
import '@testing-library/jest-dom';

// Mock global objects
global.localStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn()
};

// Mock window.matchMedia
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  }))
});
```

---

## Jest Basics

### Test Structure

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}

// math.test.js
import { add, subtract } from './math';

// Test suite
describe('Math utilities', () => {
  // Individual test
  test('add should sum two numbers', () => {
    expect(add(2, 3)).toBe(5);
  });
  
  // Alternative: it()
  it('subtract should return difference', () => {
    expect(subtract(5, 3)).toBe(2);
  });
  
  // Nested describe
  describe('edge cases', () => {
    test('add handles negative numbers', () => {
      expect(add(-2, -3)).toBe(-5);
    });
  });
});
```

### Common Matchers

```javascript
// Equality
expect(value).toBe(5);                    // Strict equality (===)
expect(object).toEqual({ a: 1, b: 2 });  // Deep equality

// Truthiness
expect(value).toBeTruthy();
expect(value).toBeFalsy();
expect(value).toBeNull();
expect(value).toBeUndefined();
expect(value).toBeDefined();

// Numbers
expect(value).toBeGreaterThan(3);
expect(value).toBeLessThan(5);
expect(value).toBeCloseTo(0.3); // Floating point

// Strings
expect(text).toMatch(/hello/);
expect(text).toContain('world');

// Arrays
expect(array).toContain('item');
expect(array).toHaveLength(3);

// Objects
expect(object).toHaveProperty('key');
expect(object).toMatchObject({ a: 1 });

// Exceptions
expect(() => throwError()).toThrow();
expect(() => throwError()).toThrow('Error message');

// Async
await expect(promise).resolves.toBe(value);
await expect(promise).rejects.toThrow();
```

### Setup & Teardown

```javascript
describe('Database tests', () => {
  // Runs once before all tests
  beforeAll(() => {
    console.log('Connect to database');
  });
  
  // Runs before each test
  beforeEach(() => {
    console.log('Clear database');
  });
  
  // Runs after each test
  afterEach(() => {
    console.log('Cleanup');
  });
  
  // Runs once after all tests
  afterAll(() => {
    console.log('Disconnect from database');
  });
  
  test('test 1', () => {
    expect(true).toBe(true);
  });
  
  test('test 2', () => {
    expect(false).toBe(false);
  });
});
```

---

## React Testing Library (RTL)

### Philosophy

```
"The more your tests resemble the way your software is used,
the more confidence they can give you."
```

**Key Principles**:
1. Test behavior, not implementation
2. Query by accessibility (like users do)
3. Avoid testing internal state
4. Focus on user interactions

### Basic Component Test

```javascript
// Button.js
function Button({ onClick, children, disabled = false }) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
}

export default Button;

// Button.test.js
import { render, screen, fireEvent } from '@testing-library/react';
import Button from './Button';

test('renders button with text', () => {
  render(<Button>Click me</Button>);
  
  const button = screen.getByText('Click me');
  expect(button).toBeInTheDocument();
});

test('calls onClick when clicked', () => {
  const handleClick = jest.fn();
  render(<Button onClick={handleClick}>Click me</Button>);
  
  const button = screen.getByText('Click me');
  fireEvent.click(button);
  
  expect(handleClick).toHaveBeenCalledTimes(1);
});

test('button is disabled when disabled prop is true', () => {
  render(<Button disabled>Click me</Button>);
  
  const button = screen.getByText('Click me');
  expect(button).toBeDisabled();
});
```

---

## Queries

### Query Types

```javascript
// getBy* - Returns element or throws error (use for assertions)
screen.getByText('Submit');
screen.getByRole('button');

// queryBy* - Returns element or null (use for non-existence)
const element = screen.queryByText('Not found');
expect(element).not.toBeInTheDocument();

// findBy* - Returns promise (use for async)
const element = await screen.findByText('Loaded data');

// getAllBy*, queryAllBy*, findAllBy* - Return arrays
const buttons = screen.getAllByRole('button');
```

### Query Priority (Best to Worst)

```javascript
// 1. Accessible to everyone (BEST)
screen.getByRole('button', { name: /submit/i });
screen.getByLabelText('Email');
screen.getByPlaceholderText('Enter email');
screen.getByText('Submit');

// 2. Semantic queries
screen.getByAltText('Profile picture');
screen.getByTitle('Close');

// 3. Test IDs (LAST RESORT)
screen.getByTestId('custom-element');
```

### Common Queries

```javascript
import { render, screen } from '@testing-library/react';

render(<LoginForm />);

// By Role (Preferred)
screen.getByRole('button', { name: /submit/i });
screen.getByRole('textbox', { name: /email/i });
screen.getByRole('heading', { level: 1 });

// By Label Text
screen.getByLabelText('Email');
screen.getByLabelText(/password/i);

// By Placeholder
screen.getByPlaceholderText('Enter your email');

// By Text
screen.getByText('Welcome back');
screen.getByText(/hello/i); // Regex, case-insensitive

// By Test ID
screen.getByTestId('login-form');

// Multiple elements
const buttons = screen.getAllByRole('button');
expect(buttons).toHaveLength(3);
```

---

## User Interactions

### fireEvent vs userEvent

```javascript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// fireEvent - Lower level, dispatches DOM events
fireEvent.click(button);
fireEvent.change(input, { target: { value: 'text' } });

// userEvent - Higher level, simulates real user interactions (PREFERRED)
const user = userEvent.setup();
await user.click(button);
await user.type(input, 'text');
```

### userEvent Examples

```javascript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import LoginForm from './LoginForm';

test('user can fill and submit login form', async () => {
  const user = userEvent.setup();
  const handleSubmit = jest.fn();
  
  render(<LoginForm onSubmit={handleSubmit} />);
  
  const emailInput = screen.getByLabelText(/email/i);
  const passwordInput = screen.getByLabelText(/password/i);
  const submitButton = screen.getByRole('button', { name: /submit/i });
  
  // Type in inputs
  await user.type(emailInput, 'test@example.com');
  await user.type(passwordInput, 'password123');
  
  // Click submit
  await user.click(submitButton);
  
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});

test('user interactions', async () => {
  const user = userEvent.setup();
  
  // Click
  await user.click(button);
  await user.dblClick(button);
  
  // Type
  await user.type(input, 'Hello');
  await user.clear(input);
  
  // Keyboard
  await user.keyboard('{Enter}');
  await user.keyboard('{Shift>}A{/Shift}'); // Shift+A
  
  // Select
  await user.selectOptions(select, 'option1');
  
  // Upload file
  const file = new File(['content'], 'test.png', { type: 'image/png' });
  await user.upload(fileInput, file);
  
  // Hover
  await user.hover(element);
  await user.unhover(element);
});
```

---

## Async Testing

### waitFor

```javascript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import axios from 'axios';

jest.mock('axios');

test('loads and displays data', async () => {
  const mockData = { name: 'John Doe', email: 'john@test.com' };
  axios.get.mockResolvedValue({ data: mockData });
  
  render(<UserProfile userId="123" />);
  
  // Initially shows loading
  expect(screen.getByText(/loading/i)).toBeInTheDocument();
  
  // Wait for data to load
  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
  
  expect(screen.queryByText(/loading/i)).not.toBeInTheDocument();
});
```

### findBy Queries (Built-in waitFor)

```javascript
test('displays user data after loading', async () => {
  axios.get.mockResolvedValue({ data: { name: 'John' } });
  
  render(<UserProfile />);
  
  // findBy automatically waits (up to 1000ms by default)
  const heading = await screen.findByRole('heading', { name: /john/i });
  expect(heading).toBeInTheDocument();
});
```

---

## Complete Example

### Component

```javascript
// TodoList.js
import { useState } from 'react';

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, { id: Date.now(), text: input, completed: false }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    <div>
      <h1>Todo List</h1>
      
      <div>
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && addTodo()}
          placeholder="Add todo"
          aria-label="New todo"
        />
        <button onClick={addTodo}>Add</button>
      </div>
      
      {todos.length === 0 ? (
        <p>No todos yet</p>
      ) : (
        <ul>
          {todos.map(todo => (
            <li key={todo.id}>
              <input
                type="checkbox"
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
                aria-label={`Toggle ${todo.text}`}
              />
              <span
                style={{
                  textDecoration: todo.completed ? 'line-through' : 'none'
                }}
              >
                {todo.text}
              </span>
              <button
                onClick={() => deleteTodo(todo.id)}
                aria-label={`Delete ${todo.text}`}
              >
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default TodoList;
```

### Tests

```javascript
// TodoList.test.js
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import TodoList from './TodoList';

describe('TodoList', () => {
  test('renders todo list heading', () => {
    render(<TodoList />);
    expect(screen.getByRole('heading', { name: /todo list/i })).toBeInTheDocument();
  });
  
  test('shows empty message when no todos', () => {
    render(<TodoList />);
    expect(screen.getByText(/no todos yet/i)).toBeInTheDocument();
  });
  
  test('can add a new todo', async () => {
    const user = userEvent.setup();
    render(<TodoList />);
    
    const input = screen.getByLabelText(/new todo/i);
    const addButton = screen.getByRole('button', { name: /add/i });
    
    // Type and add todo
    await user.type(input, 'Buy groceries');
    await user.click(addButton);
    
    // Verify todo appears
    expect(screen.getByText('Buy groceries')).toBeInTheDocument();
    expect(input).toHaveValue('');
    expect(screen.queryByText(/no todos yet/i)).not.toBeInTheDocument();
  });
  
  test('can add todo by pressing Enter', async () => {
    const user = userEvent.setup();
    render(<TodoList />);
    
    const input = screen.getByLabelText(/new todo/i);
    
    await user.type(input, 'Learn testing{Enter}');
    
    expect(screen.getByText('Learn testing')).toBeInTheDocument();
  });
  
  test('can toggle todo completion', async () => {
    const user = userEvent.setup();
    render(<TodoList />);
    
    // Add todo
    await user.type(screen.getByLabelText(/new todo/i), 'Task 1{Enter}');
    
    const checkbox = screen.getByLabelText(/toggle task 1/i);
    const text = screen.getByText('Task 1');
    
    // Initially not completed
    expect(checkbox).not.toBeChecked();
    expect(text).not.toHaveStyle('text-decoration: line-through');
    
    // Toggle completion
    await user.click(checkbox);
    
    expect(checkbox).toBeChecked();
    expect(text).toHaveStyle('text-decoration: line-through');
  });
  
  test('can delete a todo', async () => {
    const user = userEvent.setup();
    render(<TodoList />);
    
    // Add todo
    await user.type(screen.getByLabelText(/new todo/i), 'Delete me{Enter}');
    
    expect(screen.getByText('Delete me')).toBeInTheDocument();
    
    // Delete todo
    const deleteButton = screen.getByLabelText(/delete delete me/i);
    await user.click(deleteButton);
    
    expect(screen.queryByText('Delete me')).not.toBeInTheDocument();
    expect(screen.getByText(/no todos yet/i)).toBeInTheDocument();
  });
  
  test('can add multiple todos', async () => {
    const user = userEvent.setup();
    render(<TodoList />);
    
    const input = screen.getByLabelText(/new todo/i);
    
    await user.type(input, 'Todo 1{Enter}');
    await user.type(input, 'Todo 2{Enter}');
    await user.type(input, 'Todo 3{Enter}');
    
    expect(screen.getByText('Todo 1')).toBeInTheDocument();
    expect(screen.getByText('Todo 2')).toBeInTheDocument();
    expect(screen.getByText('Todo 3')).toBeInTheDocument();
    
    const checkboxes = screen.getAllByRole('checkbox');
    expect(checkboxes).toHaveLength(3);
  });
});
```

---

## Running Tests

```bash
# Run all tests
npm test

# Run tests in watch mode
npm test -- --watch

# Run specific test file
npm test -- TodoList.test.js

# Run tests matching pattern
npm test -- --testNamePattern="can add"

# Run with coverage
npm test -- --coverage

# Run without watch mode
npm test -- --watchAll=false
```

---

## Interview Questions

**Q1: What is React Testing Library?**
- Testing utility for React that encourages testing user behavior
- Queries elements like users do (by text, role, label)
- Focuses on accessibility and real user interactions

**Q2: Difference between getBy, queryBy, findBy?**
- `getBy*`: Throws error if not found (for assertions)
- `queryBy*`: Returns null if not found (for non-existence)
- `findBy*`: Returns promise, waits for element (for async)

**Q3: What is userEvent vs fireEvent?**
- `userEvent`: Simulates real user interactions (click, type, etc.) - PREFERRED
- `fireEvent`: Low-level DOM event dispatching

**Q4: How to test async components?**
- Use `findBy*` queries (built-in waiting)
- Use `waitFor()` for complex conditions
- Use `async/await` in tests

**Q5: What are Jest matchers?**
- Functions for assertions: `toBe`, `toEqual`, `toContain`, etc.
- Custom matchers from `@testing-library/jest-dom`
- Used with `expect()`: `expect(value).toBe(5)`

---

## Best Practices

1. **Query by accessibility** (role, label, text)
2. **Use userEvent** over fireEvent
3. **Test behavior**, not implementation
4. **Avoid testing internal state** (use `screen` queries)
5. **Use descriptive test names**
6. **Keep tests independent**
7. **Mock external dependencies** (API calls)
8. **Test user flows**, not just components
9. **Use waitFor** for async updates
10. **Maintain high coverage** but focus on critical paths

---

## Summary

- **Jest**: Test runner, assertions, mocking, coverage
- **RTL**: React testing utility, user-centric queries
- **Queries**: getBy (error), queryBy (null), findBy (async)
- **Priority**: Role > Label > Text > TestId
- **Interactions**: userEvent (preferred) or fireEvent
- **Async**: findBy, waitFor, async/await
- **Matchers**: toBe, toEqual, toBeInTheDocument, etc.
- **Best Practice**: Test user behavior, not implementation
