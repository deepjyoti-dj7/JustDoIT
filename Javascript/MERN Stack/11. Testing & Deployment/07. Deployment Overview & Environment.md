# 07. Deployment Overview & Environment

## Introduction

Deployment is the process of making your application accessible to users. This guide covers deployment strategies, environment configuration, and best practices for MERN stack applications.

---

## Deployment Strategies

### 1. Traditional Hosting

**Description**: Deploy to VPS (Virtual Private Server) or dedicated server

**Providers**:
- DigitalOcean
- AWS EC2
- Linode
- Vultr

**Pros**:
- Full control over environment
- Flexibility in configuration
- Cost-effective for large scale

**Cons**:
- Requires server management
- Manual scaling
- More DevOps knowledge needed

### 2. Platform as a Service (PaaS)

**Description**: Managed platform handling infrastructure

**Providers**:
- Heroku
- Railway
- Render
- Fly.io

**Pros**:
- Easy deployment (git push)
- Auto-scaling
- Built-in CI/CD
- No server management

**Cons**:
- Higher cost at scale
- Less control
- Platform lock-in

### 3. Serverless

**Description**: Function-based execution, pay per request

**Providers**:
- AWS Lambda
- Google Cloud Functions
- Azure Functions
- Vercel Functions

**Pros**:
- Pay only for usage
- Auto-scaling
- No server management

**Cons**:
- Cold start latency
- Execution time limits
- Stateless architecture required

### 4. Container Orchestration

**Description**: Deploy containerized applications

**Providers**:
- AWS ECS/EKS
- Google Kubernetes Engine
- Azure Kubernetes Service
- DigitalOcean Kubernetes

**Pros**:
- Consistent environments
- Easy scaling
- Good for microservices

**Cons**:
- Complex setup
- Steeper learning curve
- Higher operational overhead

---

## MERN Stack Deployment Approaches

### Approach 1: Separate Deployments

**Frontend** (React): Static hosting
- Vercel
- Netlify
- AWS S3 + CloudFront
- GitHub Pages

**Backend** (Node.js): Server/PaaS
- Heroku
- Railway
- AWS EC2
- Render

**Database** (MongoDB):
- MongoDB Atlas (recommended)
- Self-hosted on VPS

**Pros**:
- Optimized hosting for each layer
- Independent scaling
- Better for large applications

**Cons**:
- More complex setup
- CORS configuration needed
- Multiple deployment processes

### Approach 2: Unified Deployment

**Full Stack**: Single server
- Heroku
- Railway
- DigitalOcean App Platform

**Structure**:
```
project/
  client/          # React app
  server/          # Express app
  package.json     # Root package.json
```

**Pros**:
- Simpler deployment
- No CORS issues
- Single codebase

**Cons**:
- Monolithic architecture
- Harder to scale independently
- Frontend and backend coupled

---

## Environment Configuration

### Environment Variables

**Purpose**:
- Store sensitive data (API keys, secrets)
- Different configs for dev/prod
- Platform-specific settings

**Common Variables**:

```bash
# .env.development
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/myapp
JWT_SECRET=dev_secret_key
CLIENT_URL=http://localhost:3000

# .env.production
NODE_ENV=production
PORT=5000
MONGO_URI=mongodb+srv://user:pass@cluster.mongodb.net/myapp
JWT_SECRET=prod_strong_secret_key_here
CLIENT_URL=https://myapp.com
```

### Loading Environment Variables

```javascript
// Using dotenv
require('dotenv').config();

const PORT = process.env.PORT || 5000;
const MONGO_URI = process.env.MONGO_URI;
const JWT_SECRET = process.env.JWT_SECRET;

if (!MONGO_URI || !JWT_SECRET) {
  console.error('Missing required environment variables');
  process.exit(1);
}
```

### React Environment Variables

**Create React App**:
```bash
# .env
REACT_APP_API_URL=http://localhost:5000/api
REACT_APP_ENVIRONMENT=development

# .env.production
REACT_APP_API_URL=https://api.myapp.com/api
REACT_APP_ENVIRONMENT=production
```

**Usage**:
```javascript
const API_URL = process.env.REACT_APP_API_URL;

fetch(`${API_URL}/users`)
  .then(res => res.json())
  .then(data => console.log(data));
```

**Vite**:
```bash
# .env
VITE_API_URL=http://localhost:5000/api
```

**Usage**:
```javascript
const API_URL = import.meta.env.VITE_API_URL;
```

### Security Best Practices

1. **Never commit .env files**
```bash
# .gitignore
.env
.env.local
.env.production
```

2. **Use strong secrets in production**
```javascript
// Generate JWT secret
const crypto = require('crypto');
const secret = crypto.randomBytes(64).toString('hex');
console.log(secret);
```

3. **Validate required variables**
```javascript
const requiredEnvVars = ['MONGO_URI', 'JWT_SECRET', 'PORT'];

requiredEnvVars.forEach(varName => {
  if (!process.env[varName]) {
    throw new Error(`Missing required environment variable: ${varName}`);
  }
});
```

4. **Different secrets for different environments**
- Development: Simple secrets for easy debugging
- Production: Strong, randomly generated secrets

---

## Preparing for Deployment

### 1. Database Setup

**MongoDB Atlas**:
1. Create account at mongodb.com/atlas
2. Create cluster (free M0 tier available)
3. Create database user
4. Whitelist IP addresses (0.0.0.0/0 for dynamic IPs)
5. Get connection string

```
mongodb+srv://username:password@cluster.mongodb.net/database?retryWrites=true&w=majority
```

### 2. Backend Preparation

```javascript
// server.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

const app = express();

// Middleware
app.use(cors({
  origin: process.env.CLIENT_URL,
  credentials: true
}));
app.use(express.json());

// Database connection
mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log('MongoDB connected'))
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  });

// Routes
app.use('/api/users', require('./routes/users'));
app.use('/api/auth', require('./routes/auth'));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date() });
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 3. Frontend Configuration

```javascript
// src/config/api.js
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

export default API_URL;

// src/services/api.js
import axios from 'axios';
import API_URL from '../config/api';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add token to requests
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;
```

### 4. Package.json Scripts

**Backend**:
```json
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "engines": {
    "node": "18.x"
  }
}
```

**Frontend**:
```json
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

### 5. CORS Configuration

```javascript
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = [
      'http://localhost:3000',
      'https://myapp.com',
      'https://www.myapp.com'
    ];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
};

app.use(cors(corsOptions));
```

---

## Deployment Checklist

### Pre-Deployment

- [ ] All tests passing
- [ ] Code reviewed and merged
- [ ] Environment variables configured
- [ ] Database backup created
- [ ] Production database setup (MongoDB Atlas)
- [ ] API keys and secrets generated
- [ ] CORS configured correctly
- [ ] Error handling implemented
- [ ] Logging configured

### Security

- [ ] No hardcoded secrets
- [ ] .env files in .gitignore
- [ ] HTTPS enabled
- [ ] Rate limiting implemented
- [ ] Input validation
- [ ] SQL injection prevention
- [ ] XSS protection
- [ ] CSRF protection

### Performance

- [ ] Code minified and bundled
- [ ] Images optimized
- [ ] Database indexes created
- [ ] Caching implemented
- [ ] CDN configured (for static assets)

### Monitoring

- [ ] Error tracking (Sentry, Rollbar)
- [ ] Analytics (Google Analytics, Mixpanel)
- [ ] Uptime monitoring (UptimeRobot, Pingdom)
- [ ] Performance monitoring (New Relic, DataDog)

---

## Interview Questions

**Q1: What are environment variables?**
- Configuration values stored outside code
- Different values for dev/staging/prod
- Accessed via `process.env`

**Q2: PaaS vs IaaS vs Serverless?**
- **PaaS**: Heroku, managed platform
- **IaaS**: AWS EC2, manage servers yourself
- **Serverless**: Lambda, pay per execution

**Q3: How to handle secrets in production?**
- Use environment variables
- Never commit to version control
- Use secret management services (AWS Secrets Manager)
- Rotate secrets regularly

**Q4: Deployment strategies for MERN?**
- **Separate**: Frontend on Vercel, Backend on Heroku, DB on Atlas
- **Unified**: Full stack on Railway/Render

**Q5: How to configure CORS?**
```javascript
app.use(cors({
  origin: process.env.CLIENT_URL,
  credentials: true
}));
```

---

## Summary

- **Deployment Options**: PaaS (Heroku), Traditional (EC2), Serverless (Lambda)
- **MERN Approaches**: Separate deployments or unified
- **Environment Variables**: .env files, never commit secrets
- **Database**: MongoDB Atlas for production
- **CORS**: Configure allowed origins
- **Checklist**: Tests, security, performance, monitoring
- **Best Practice**: Use CI/CD, automate deployments
