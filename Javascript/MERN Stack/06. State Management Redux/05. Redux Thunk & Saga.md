# Redux Thunk & Saga

## Async Actions in Redux

By default, Redux only handles **synchronous** actions. For async operations (API calls, timers), we need middleware.

Two popular solutions:
1. **Redux Thunk** - Simple, function-based
2. **Redux Saga** - Complex, generator-based

---

## Redux Thunk

**Redux Thunk** allows action creators to return **functions** instead of actions.

### Installation

```bash
npm install redux-thunk
```

### Setup

```js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

const store = createStore(
  rootReducer,
  applyMiddleware(thunk)
);
```

---

## Basic Thunk Example

### Without Thunk (Synchronous Only)

```js
// ❌ Can't do async in action creators
const fetchUserSuccess = (user) => ({
  type: 'FETCH_USER_SUCCESS',
  payload: user
});

// This won't work!
const fetchUser = (id) => {
  const user = await fetch(`/api/users/${id}`); // Error!
  return { type: 'FETCH_USER_SUCCESS', payload: user };
};
```

### With Thunk (Async Supported)

```js
// ✅ Thunk returns a function
const fetchUser = (id) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    try {
      const response = await fetch(`/api/users/${id}`);
      const user = await response.json();
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });
    }
  };
};

// Usage
dispatch(fetchUser(123));
```

---

## Thunk Signature

A thunk is a function that returns a function:

```js
const thunkActionCreator = (params) => {
  return (dispatch, getState) => {
    // Can dispatch multiple actions
    // Can access current state
    // Can perform async operations
  };
};
```

**Parameters:**
- `dispatch`: Function to dispatch actions
- `getState`: Function to get current state

---

## Complete Thunk Example: Todo App

### Actions

```js
// Action types
const FETCH_TODOS_START = 'FETCH_TODOS_START';
const FETCH_TODOS_SUCCESS = 'FETCH_TODOS_SUCCESS';
const FETCH_TODOS_ERROR = 'FETCH_TODOS_ERROR';
const ADD_TODO_START = 'ADD_TODO_START';
const ADD_TODO_SUCCESS = 'ADD_TODO_SUCCESS';

// Thunk action creators
export const fetchTodos = () => {
  return async (dispatch) => {
    dispatch({ type: FETCH_TODOS_START });
    
    try {
      const response = await fetch('/api/todos');
      const todos = await response.json();
      dispatch({ type: FETCH_TODOS_SUCCESS, payload: todos });
    } catch (error) {
      dispatch({ type: FETCH_TODOS_ERROR, payload: error.message });
    }
  };
};

export const addTodo = (text) => {
  return async (dispatch, getState) => {
    dispatch({ type: ADD_TODO_START });
    
    try {
      const response = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      
      const todo = await response.json();
      dispatch({ type: ADD_TODO_SUCCESS, payload: todo });
      
      // Can access state
      const state = getState();
      console.log('Total todos:', state.todos.length);
    } catch (error) {
      dispatch({ type: FETCH_TODOS_ERROR, payload: error.message });
    }
  };
};
```

### Reducer

```js
const initialState = {
  todos: [],
  loading: false,
  error: null
};

export function todosReducer(state = initialState, action) {
  switch (action.type) {
    case FETCH_TODOS_START:
    case ADD_TODO_START:
      return {
        ...state,
        loading: true,
        error: null
      };
    
    case FETCH_TODOS_SUCCESS:
      return {
        ...state,
        loading: false,
        todos: action.payload
      };
    
    case ADD_TODO_SUCCESS:
      return {
        ...state,
        loading: false,
        todos: [...state.todos, action.payload]
      };
    
    case FETCH_TODOS_ERROR:
      return {
        ...state,
        loading: false,
        error: action.payload
      };
    
    default:
      return state;
  }
}
```

### Component

```jsx
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchTodos, addTodo } from './actions';

function TodoList() {
  const { todos, loading, error } = useSelector(state => state.todos);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchTodos());
  }, [dispatch]);

  const handleAdd = () => {
    dispatch(addTodo('New todo'));
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <button onClick={handleAdd}>Add Todo</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

---

## Advanced Thunk Patterns

### Conditional Dispatch

```js
const fetchUserIfNeeded = (userId) => {
  return (dispatch, getState) => {
    const state = getState();
    
    // Only fetch if not already loaded
    if (!state.users[userId]) {
      return dispatch(fetchUser(userId));
    }
  };
};
```

### Chaining Thunks

```js
const loginAndFetchData = (credentials) => {
  return async (dispatch) => {
    await dispatch(login(credentials));
    await dispatch(fetchUserProfile());
    await dispatch(fetchUserPosts());
  };
};
```

### Error Handling

```js
const fetchWithRetry = (url, retries = 3) => {
  return async (dispatch) => {
    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(url);
        const data = await response.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
        return;
      } catch (error) {
        if (i === retries - 1) {
          dispatch({ type: 'FETCH_ERROR', payload: error.message });
        }
      }
    }
  };
};
```

---

## Redux Saga

**Redux Saga** uses ES6 **generators** to make async flows easy to read, write, and test.

### Installation

```bash
npm install redux-saga
```

### Setup

```js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import rootReducer from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();

const store = createStore(
  rootReducer,
  applyMiddleware(sagaMiddleware)
);

sagaMiddleware.run(rootSaga);
```

---

## Basic Saga Example

### Saga

```js
import { call, put, takeEvery } from 'redux-saga/effects';

// Worker saga
function* fetchUserSaga(action) {
  try {
    // Dispatch loading action
    yield put({ type: 'FETCH_USER_START' });
    
    // Make API call
    const response = yield call(fetch, `/api/users/${action.payload}`);
    const user = yield call([response, 'json']);
    
    // Dispatch success action
    yield put({ type: 'FETCH_USER_SUCCESS', payload: user });
  } catch (error) {
    // Dispatch error action
    yield put({ type: 'FETCH_USER_ERROR', payload: error.message });
  }
}

// Watcher saga
function* watchFetchUser() {
  yield takeEvery('FETCH_USER_REQUEST', fetchUserSaga);
}

// Root saga
export default function* rootSaga() {
  yield watchFetchUser();
}
```

### Component

```jsx
import { useDispatch } from 'react-redux';

function UserProfile({ userId }) {
  const dispatch = useDispatch();

  useEffect(() => {
    // Dispatch action - saga will handle the rest
    dispatch({ type: 'FETCH_USER_REQUEST', payload: userId });
  }, [userId, dispatch]);

  // Rest of component...
}
```

---

## Saga Effects

### 1. call - Call functions

```js
import { call } from 'redux-saga/effects';

function* saga() {
  const result = yield call(fetch, '/api/data');
  const data = yield call([result, 'json']);
}
```

### 2. put - Dispatch actions

```js
import { put } from 'redux-saga/effects';

function* saga() {
  yield put({ type: 'ACTION_TYPE', payload: data });
}
```

### 3. takeEvery - Listen to all actions

```js
import { takeEvery } from 'redux-saga/effects';

function* watchFetchUser() {
  yield takeEvery('FETCH_USER', fetchUserSaga);
}
```

### 4. takeLatest - Cancel previous, run latest

```js
import { takeLatest } from 'redux-saga/effects';

function* watchSearch() {
  yield takeLatest('SEARCH', searchSaga); // Cancels previous searches
}
```

### 5. select - Get state

```js
import { select } from 'redux-saga/effects';

const getUser = state => state.user;

function* saga() {
  const user = yield select(getUser);
}
```

### 6. fork - Non-blocking call

```js
import { fork } from 'redux-saga/effects';

function* saga() {
  yield fork(backgroundTask); // Non-blocking
  yield call(blockingTask);   // Blocking
}
```

---

## Complete Saga Example: Todo App

```js
import { call, put, takeEvery, takeLatest, select } from 'redux-saga/effects';

// API functions
const api = {
  fetchTodos: () => fetch('/api/todos').then(res => res.json()),
  addTodo: (text) => fetch('/api/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text })
  }).then(res => res.json())
};

// Worker sagas
function* fetchTodosSaga() {
  try {
    yield put({ type: 'FETCH_TODOS_START' });
    const todos = yield call(api.fetchTodos);
    yield put({ type: 'FETCH_TODOS_SUCCESS', payload: todos });
  } catch (error) {
    yield put({ type: 'FETCH_TODOS_ERROR', payload: error.message });
  }
}

function* addTodoSaga(action) {
  try {
    yield put({ type: 'ADD_TODO_START' });
    const todo = yield call(api.addTodo, action.payload);
    yield put({ type: 'ADD_TODO_SUCCESS', payload: todo });
    
    // Can access state
    const todos = yield select(state => state.todos);
    console.log('Total todos:', todos.length);
  } catch (error) {
    yield put({ type: 'ADD_TODO_ERROR', payload: error.message });
  }
}

// Watcher sagas
function* watchFetchTodos() {
  yield takeEvery('FETCH_TODOS_REQUEST', fetchTodosSaga);
}

function* watchAddTodo() {
  yield takeEvery('ADD_TODO_REQUEST', addTodoSaga);
}

// Root saga
export default function* rootSaga() {
  yield [
    watchFetchTodos(),
    watchAddTodo()
  ];
}
```

---

## Thunk vs Saga

| Feature | Redux Thunk | Redux Saga |
|---------|-------------|------------|
| Learning curve | Easy | Steep |
| Syntax | Functions | Generators |
| Testing | Harder | Easier |
| Async control | Basic | Advanced |
| Cancellation | Manual | Built-in |
| Debouncing | Manual | Built-in |
| Best for | Simple async | Complex flows |
| Bundle size | Tiny (~2KB) | Larger (~20KB) |

### When to Use Thunk

- Simple async operations
- Small to medium apps
- Team unfamiliar with generators
- Quick prototyping

### When to Use Saga

- Complex async flows
- Need cancellation/debouncing
- Advanced patterns (racing, forking)
- Large applications
- Team comfortable with generators

---

## Interview Questions

### Q1: What is Redux Thunk?
**Answer**: Redux Thunk is middleware that allows action creators to return functions instead of action objects. These functions receive `dispatch` and `getState`, enabling async operations.

### Q2: What is Redux Saga?
**Answer**: Redux Saga is middleware that uses ES6 generators to handle side effects. It makes async flows easier to read, write, and test compared to callbacks or promises.

### Q3: What's the difference between Thunk and Saga?
**Answer**:
- **Thunk**: Simple, function-based, good for basic async
- **Saga**: Complex, generator-based, powerful for advanced flows

Thunk is easier to learn, Saga is more powerful.

### Q4: How do you test thunks?
**Answer**: Mock `dispatch` and `getState`:

```js
const dispatch = jest.fn();
const getState = jest.fn(() => ({ count: 0 }));

await thunkAction()(dispatch, getState);

expect(dispatch).toHaveBeenCalledWith({ type: 'ACTION' });
```

### Q5: How do you test sagas?
**Answer**: Test saga step by step:

```js
const gen = fetchUserSaga({ payload: 1 });

expect(gen.next().value).toEqual(call(api.fetchUser, 1));
expect(gen.next(user).value).toEqual(put({ type: 'SUCCESS', payload: user }));
```

### Q6: What is takeLatest in Saga?
**Answer**: `takeLatest` cancels the previous saga execution and runs only the latest. Useful for search/autocomplete to cancel outdated requests.

### Q7: Can you use both Thunk and Saga together?
**Answer**: Yes! You can use both middleware simultaneously:

```js
applyMiddleware(thunk, sagaMiddleware)
```

---

## Best Practices

### Thunk
1. **Keep thunks focused** - Single responsibility
2. **Handle errors** - Always use try-catch
3. **Dispatch loading states** - Show UI feedback
4. **Use async/await** - Cleaner than promises
5. **Test thunks** - Mock dispatch and getState

### Saga
1. **Separate workers and watchers** - Clear organization
2. **Use try-catch** - Error handling in workers
3. **Test sagas** - Step-by-step testing
4. **Use takeLatest** for debouncing
5. **Keep sagas pure** - Side effects in call()

---

## Summary

- **Redux Thunk**: Simple, function-based async middleware
- Returns **functions** that receive `dispatch` and `getState`
- Good for **simple async** operations
- **Easy to learn**, minimal boilerplate

- **Redux Saga**: Advanced, generator-based middleware
- Uses **ES6 generators** and effects
- Powerful for **complex flows** (cancellation, racing, forking)
- **Easier to test**, harder to learn

- Choose **Thunk** for simplicity
- Choose **Saga** for complex async logic
- Can use **both together** if needed

