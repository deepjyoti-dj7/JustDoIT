# Introduction to Redux

## What is Redux?

**Redux** is a predictable state container for JavaScript applications. It helps you manage **global state** in a consistent and testable way.

---

## Why Use Redux?

### Problems Redux Solves

1. **Prop Drilling** - Passing props through many levels
2. **Shared State** - Multiple components need same data
3. **State Updates** - Complex state transitions
4. **Predictability** - Hard to track state changes
5. **Time Travel** - No way to replay state changes

### Without Redux (Prop Drilling)

```jsx
function App() {
  const [user, setUser] = useState(null);
  return <Page user={user} setUser={setUser} />;
}

function Page({ user, setUser }) {
  return <Layout user={user} setUser={setUser} />;
}

function Layout({ user, setUser }) {
  return <Sidebar user={user} setUser={setUser} />;
}

function Sidebar({ user, setUser }) {
  return <UserMenu user={user} setUser={setUser} />;
}

function UserMenu({ user, setUser }) {
  // Finally can use it!
  return <div>{user.name}</div>;
}
```

### With Redux (Direct Access)

```jsx
import { useSelector } from 'react-redux';

function UserMenu() {
  // Access directly from any component!
  const user = useSelector(state => state.user);
  return <div>{user.name}</div>;
}
```

---

## When to Use Redux?

### ✅ Use Redux When:

- Large amounts of application state
- State updated frequently
- Logic to update state is complex
- Medium to large codebase with many developers
- Need to see how state changes over time (time travel debugging)
- Caching server data on client

### ❌ Don't Use Redux When:

- Small, simple applications
- State is mostly local to components
- Learning React (master React first)
- Overhead not justified
- Context API is sufficient

---

## Core Principles

### 1. Single Source of Truth

The entire application state is stored in a **single store**.

```js
const state = {
  user: { id: 1, name: 'John' },
  posts: [{ id: 1, title: 'Hello' }],
  ui: { theme: 'dark' }
};
```

### 2. State is Read-Only

The only way to change state is to **dispatch an action**.

```js
// ❌ Can't do this
state.user.name = 'Jane';

// ✅ Must dispatch action
store.dispatch({ type: 'UPDATE_USER', payload: { name: 'Jane' } });
```

### 3. Changes Made with Pure Functions

Reducers are **pure functions** that take previous state and action, return new state.

```js
function userReducer(state = initialState, action) {
  switch (action.type) {
    case 'UPDATE_USER':
      return { ...state, ...action.payload }; // New object
    default:
      return state;
  }
}
```

---

## Redux vs Other Solutions

### Redux vs Context API

| Feature | Redux | Context API |
|---------|-------|-------------|
| Learning curve | Steeper | Gentler |
| Boilerplate | More | Less |
| DevTools | Excellent | Basic |
| Performance | Optimized | Can cause re-renders |
| Middleware | Yes | No |
| Time travel | Yes | No |
| Best for | Large apps | Small to medium |

### Redux vs MobX

| Feature | Redux | MobX |
|---------|-------|------|
| Paradigm | Functional | OOP |
| Mutability | Immutable | Mutable |
| Boilerplate | More | Less |
| Learning curve | Steeper | Gentler |
| Predictability | Very high | Lower |
| DevTools | Excellent | Good |

### Redux vs Zustand

| Feature | Redux | Zustand |
|---------|-------|--------|
| Bundle size | Larger | Tiny |
| Boilerplate | More | Minimal |
| Learning curve | Steeper | Very gentle |
| Ecosystem | Huge | Growing |
| Middleware | Rich | Simple |
| Best for | Large apps | Small to medium |

---

## Redux Ecosystem

### Core Libraries

1. **Redux** - Core library
2. **React-Redux** - React bindings
3. **Redux Toolkit** - Official recommended way (simplifies Redux)

### Popular Middleware

1. **Redux Thunk** - Async actions (included in Redux Toolkit)
2. **Redux Saga** - Complex async flows
3. **Redux Observable** - RxJS-based

### DevTools

1. **Redux DevTools Extension** - Time travel debugging
2. **React DevTools** - Component inspection

---

## Basic Example

### Traditional Redux

```js
import { createStore } from 'redux';

// 1. Define initial state
const initialState = { count: 0 };

// 2. Create reducer
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 3. Create store
const store = createStore(counterReducer);

// 4. Dispatch actions
store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); // { count: 1 }

store.dispatch({ type: 'INCREMENT' });
console.log(store.getState()); // { count: 2 }

store.dispatch({ type: 'DECREMENT' });
console.log(store.getState()); // { count: 1 }
```

### With React

```jsx
import { Provider, useSelector, useDispatch } from 'react-redux';
import { createStore } from 'redux';

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// Store
const store = createStore(counterReducer);

// App component
function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

// Counter component
function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
    </div>
  );
}
```

---

## Redux Data Flow

```
┌─────────────┐
│  Component  │
└──────┬──────┘
       │ dispatch(action)
       ▼
┌─────────────┐
│    Store    │
└──────┬──────┘
       │ pass action
       ▼
┌─────────────┐
│   Reducer   │
└──────┬──────┘
       │ return new state
       ▼
┌─────────────┐
│    Store    │
└──────┬──────┘
       │ notify subscribers
       ▼
┌─────────────┐
│  Component  │ (re-renders)
└─────────────┘
```

---

## Installation

### Redux + React-Redux

```bash
npm install redux react-redux
```

### Redux Toolkit (Recommended)

```bash
npm install @reduxjs/toolkit react-redux
```

---

## Interview Questions

### Q1: What is Redux?
**Answer**: Redux is a predictable state container for JavaScript apps. It provides a centralized store for state that needs to be shared across the entire application, with rules ensuring state can only be updated in a predictable fashion.

### Q2: What are the three principles of Redux?
**Answer**:
1. **Single source of truth** - One store for entire app
2. **State is read-only** - Only change via actions
3. **Changes made with pure functions** - Reducers are pure

### Q3: When should you use Redux?
**Answer**: Use Redux when:
- App has large amounts of state
- State updated frequently
- Update logic is complex
- Medium to large codebase
- Need time travel debugging

Don't use for small apps or when learning React.

### Q4: What's the difference between Redux and Context API?
**Answer**:
- Redux has better DevTools, middleware, time travel
- Context is simpler, less boilerplate
- Redux optimized for performance
- Context can cause unnecessary re-renders
- Redux better for large apps

### Q5: What is Redux Toolkit?
**Answer**: Redux Toolkit is the official recommended way to write Redux logic. It includes utilities to simplify common use cases like store setup, creating reducers, immutable update logic, and async logic.

### Q6: Is Redux still relevant in 2024+?
**Answer**: Yes, for large applications with complex state. However, simpler alternatives (Zustand, Jotai) are popular for smaller apps. Redux Toolkit has made Redux much more developer-friendly.

---

## Advantages

1. **Predictable** - Same input = same output
2. **Centralized** - Single source of truth
3. **Debuggable** - Time travel debugging
4. **Testable** - Pure functions easy to test
5. **Maintainable** - Clear patterns
6. **Ecosystem** - Large community, many tools
7. **SSR Support** - Works with server rendering
8. **Performance** - Optimized updates

---

## Disadvantages

1. **Boilerplate** - Lots of setup code
2. **Learning Curve** - Steep for beginners
3. **Complexity** - Overkill for small apps
4. **Verbosity** - More code to write
5. **Indirection** - Hard to trace for newcomers

---

## Summary

- **Redux** is a state management library
- Based on **three principles**: single source of truth, read-only state, pure reducers
- Solves **prop drilling** and **shared state** problems
- Has excellent **DevTools** and **ecosystem**
- **Redux Toolkit** is the modern, recommended approach
- Use for **large applications** with complex state
- Consider **alternatives** for small apps
- **Predictable**, **testable**, and **maintainable**

