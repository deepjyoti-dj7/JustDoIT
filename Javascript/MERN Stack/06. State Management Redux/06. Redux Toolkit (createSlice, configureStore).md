# Redux Toolkit (RTK)

## What is Redux Toolkit?

**Redux Toolkit (RTK)** is the **official, opinionated** way to write Redux logic.

It simplifies Redux by:
- Reducing boilerplate code
- Providing sensible defaults
- Including best practices
- Built-in middleware (Thunk)
- Immutability with Immer

> **RTK is now the standard way to write Redux.**

---

## Why Redux Toolkit?

### Traditional Redux Problems

```js
// âŒ Old Redux - Too much boilerplate!

// Action types
const INCREMENT = 'counter/INCREMENT';
const DECREMENT = 'counter/DECREMENT';

// Action creators
const increment = () => ({ type: INCREMENT });
const decrement = () => ({ type: DECREMENT });

// Reducer
const counterReducer = (state = { value: 0 }, action) => {
  switch (action.type) {
    case INCREMENT:
      return { ...state, value: state.value + 1 };
    case DECREMENT:
      return { ...state, value: state.value - 1 };
    default:
      return state;
  }
};

// Store
const store = createStore(
  counterReducer,
  applyMiddleware(thunk)
);
```

### Redux Toolkit Solution

```js
// âœ… RTK - Clean and concise!

import { createSlice, configureStore } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: state => { state.value += 1 },
    decrement: state => { state.value -= 1 }
  }
});

const store = configureStore({
  reducer: { counter: counterSlice.reducer }
});
```

**50% less code!** ðŸŽ‰

---

## Installation

```bash
npm install @reduxjs/toolkit react-redux
```

---

## Core APIs

### 1. configureStore
### 2. createSlice
### 3. createAsyncThunk
### 4. createEntityAdapter

---

## 1. configureStore

Simplifies store setup with sensible defaults.

### Basic Setup

```js
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';
import userReducer from './userSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
    user: userReducer
  }
});

export default store;
```

**What it does:**
- Combines reducers automatically
- Adds Redux Thunk middleware
- Enables Redux DevTools
- Adds development checks (immutability, serializability)

### Advanced Configuration

```js
import { configureStore } from '@reduxjs/toolkit';
import logger from 'redux-logger';

const store = configureStore({
  reducer: {
    counter: counterReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== 'production'
});
```

---

## 2. createSlice

Creates reducer, action creators, and action types in one place.

### Basic Example

```js
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // âœ… Mutate directly! (Immer magic)
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

// Auto-generated action creators
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// Reducer
export default counterSlice.reducer;
```

### Using in Component

```jsx
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from './counterSlice';

function Counter() {
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>
    </div>
  );
}
```

---

## Complete Example: Todo App

### todoSlice.js

```js
import { createSlice } from '@reduxjs/toolkit';

const todoSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push({
        id: Date.now(),
        text: action.payload,
        completed: false
      });
    },
    toggleTodo: (state, action) => {
      const todo = state.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    deleteTodo: (state, action) => {
      return state.filter(todo => todo.id !== action.payload);
    }
  }
});

export const { addTodo, toggleTodo, deleteTodo } = todoSlice.actions;
export default todoSlice.reducer;
```

### store.js

```js
import { configureStore } from '@reduxjs/toolkit';
import todoReducer from './todoSlice';

export const store = configureStore({
  reducer: {
    todos: todoReducer
  }
});
```

### TodoList.jsx

```jsx
import { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { addTodo, toggleTodo, deleteTodo } from './todoSlice';

function TodoList() {
  const [text, setText] = useState('');
  const todos = useSelector((state) => state.todos);
  const dispatch = useDispatch();

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      dispatch(addTodo(text));
      setText('');
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Add todo"
        />
        <button type="submit">Add</button>
      </form>

      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => dispatch(deleteTodo(todo.id))}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default TodoList;
```

---

## 3. createAsyncThunk

Handles async logic (API calls) with automatic action types.

### Basic Usage

```js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunk
export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId) => {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
);

const userSlice = createSlice({
  name: 'user',
  initialState: {
    data: null,
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

export default userSlice.reducer;
```

### Component Usage

```jsx
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { fetchUser } from './userSlice';

function UserProfile({ userId }) {
  const { data, loading, error } = useSelector((state) => state.user);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchUser(userId));
  }, [userId, dispatch]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return null;

  return <div>{data.name}</div>;
}
```

---

## Complete Async Example: Posts

### postsSlice.js

```js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// Async thunks
export const fetchPosts = createAsyncThunk(
  'posts/fetchPosts',
  async () => {
    const response = await fetch('/api/posts');
    return response.json();
  }
);

export const addPost = createAsyncThunk(
  'posts/addPost',
  async (post) => {
    const response = await fetch('/api/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(post)
    });
    return response.json();
  }
);

export const deletePost = createAsyncThunk(
  'posts/deletePost',
  async (id) => {
    await fetch(`/api/posts/${id}`, { method: 'DELETE' });
    return id;
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Fetch posts
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      })
      // Add post
      .addCase(addPost.fulfilled, (state, action) => {
        state.items.push(action.payload);
      })
      // Delete post
      .addCase(deletePost.fulfilled, (state, action) => {
        state.items = state.items.filter(post => post.id !== action.payload);
      });
  }
});

export default postsSlice.reducer;
```

---

## Prepare Callback

Customize action payload before dispatch.

```js
const todoSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: {
      reducer: (state, action) => {
        state.push(action.payload);
      },
      prepare: (text) => {
        return {
          payload: {
            id: Date.now(),
            text,
            completed: false,
            createdAt: new Date().toISOString()
          }
        };
      }
    }
  }
});

// Usage
dispatch(addTodo('Buy milk')); 
// Payload: { id: 123, text: 'Buy milk', completed: false, createdAt: '2024-...' }
```

---

## 4. createEntityAdapter

Manages normalized state (collections of items).

### Example

```js
import { createSlice, createEntityAdapter } from '@reduxjs/toolkit';

const usersAdapter = createEntityAdapter({
  selectId: (user) => user.id,
  sortComparer: (a, b) => a.name.localeCompare(b.name)
});

const usersSlice = createSlice({
  name: 'users',
  initialState: usersAdapter.getInitialState(),
  reducers: {
    addUser: usersAdapter.addOne,
    addUsers: usersAdapter.addMany,
    updateUser: usersAdapter.updateOne,
    removeUser: usersAdapter.removeOne
  }
});

// Selectors
export const {
  selectAll: selectAllUsers,
  selectById: selectUserById,
  selectIds: selectUserIds
} = usersAdapter.getSelectors((state) => state.users);
```

---

## Immer Integration

RTK uses **Immer** internally, allowing "mutative" code.

### Traditional Redux (Immutable)

```js
// âŒ Must return new objects
const reducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_USER':
      return {
        ...state,
        user: {
          ...state.user,
          name: action.payload
        }
      };
  }
};
```

### RTK (Mutative with Immer)

```js
// âœ… "Mutate" directly (Immer makes it immutable)
const slice = createSlice({
  name: 'user',
  initialState: { user: { name: 'John' } },
  reducers: {
    updateUser: (state, action) => {
      state.user.name = action.payload; // Looks mutable, but isn't!
    }
  }
});
```

**Immer converts mutations to immutable updates!**

---

## TypeScript Support

RTK has excellent TypeScript support.

```typescript
import { createSlice, PayloadAction, configureStore } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    }
  }
});

const store = configureStore({
  reducer: { counter: counterSlice.reducer }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

---

## Interview Questions

### Q1: What is Redux Toolkit?
**Answer**: Redux Toolkit (RTK) is the official, opinionated way to write Redux. It simplifies Redux by reducing boilerplate, providing sensible defaults, and including best practices.

### Q2: What's the difference between createSlice and createReducer?
**Answer**: 
- `createSlice` creates reducer + action creators + types
- `createReducer` only creates reducer

`createSlice` is higher-level and more convenient.

### Q3: How does Immer work in RTK?
**Answer**: Immer allows you to write "mutative" code in reducers. It tracks changes and produces immutable updates automatically.

```js
state.value += 1; // Looks mutable, but Immer makes it immutable!
```

### Q4: What is createAsyncThunk used for?
**Answer**: `createAsyncThunk` handles async logic (API calls) and automatically generates pending/fulfilled/rejected action types.

### Q5: Can you use RTK with old Redux code?
**Answer**: Yes! RTK is fully compatible with traditional Redux. You can migrate gradually.

### Q6: What's included in configureStore?
**Answer**:
- Combines reducers
- Adds Redux Thunk middleware
- Enables Redux DevTools
- Adds development checks (immutability/serializability)

### Q7: What is extraReducers in createSlice?
**Answer**: `extraReducers` handles actions from:
- `createAsyncThunk`
- Other slices
- External actions

Regular `reducers` only handles actions from the same slice.

---

## Best Practices

1. **Use RTK for all new Redux code** - It's the official way
2. **Use createSlice** - Don't write reducers manually
3. **Normalize data with createEntityAdapter** - For collections
4. **Use createAsyncThunk** - For async operations
5. **Keep slices small** - One feature per slice
6. **Co-locate related logic** - Actions, reducers, selectors together
7. **Use TypeScript** - RTK has excellent TS support
8. **Leverage Immer** - Write simple "mutative" code

---

## Migration from Old Redux

### Before (Old Redux)

```js
// Action types
const ADD_TODO = 'ADD_TODO';

// Action creators
const addTodo = (text) => ({ type: ADD_TODO, payload: text });

// Reducer
const todosReducer = (state = [], action) => {
  switch (action.type) {
    case ADD_TODO:
      return [...state, { id: Date.now(), text: action.payload }];
    default:
      return state;
  }
};
```

### After (RTK)

```js
const todoSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push({ id: Date.now(), text: action.payload });
    }
  }
});

export const { addTodo } = todoSlice.actions;
export default todoSlice.reducer;
```

---

## Summary

- **Redux Toolkit (RTK)** is the official, modern way to write Redux
- **configureStore**: Simplified store setup with sensible defaults
- **createSlice**: Creates reducer + actions + types in one place
- **createAsyncThunk**: Handles async operations (API calls)
- **createEntityAdapter**: Manages normalized collections
- **Immer**: Write "mutative" code that's actually immutable
- **50-70% less boilerplate** compared to old Redux
- **TypeScript support** is excellent
- **Use RTK for all new projects** - it's the standard now

