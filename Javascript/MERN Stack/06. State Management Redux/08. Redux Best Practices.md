# Redux Best Practices

## Overview

Redux is powerful, but improper use can lead to:
- Bloated state
- Performance issues
- Unmaintainable code
- Prop drilling

This guide covers **proven patterns** for scalable Redux applications.

---

## 1. State Structure

### ✅ Do: Normalize State

Store data in a normalized (flat) structure.

```js
// ❌ Bad: Nested structure
const state = {
  posts: [
    { id: 1, title: 'Post 1', author: { id: 10, name: 'John' } },
    { id: 2, title: 'Post 2', author: { id: 10, name: 'John' } }
  ]
};

// ✅ Good: Normalized structure
const state = {
  posts: {
    byId: {
      1: { id: 1, title: 'Post 1', authorId: 10 },
      2: { id: 2, title: 'Post 2', authorId: 10 }
    },
    allIds: [1, 2]
  },
  authors: {
    byId: {
      10: { id: 10, name: 'John' }
    },
    allIds: [10]
  }
};
```

**Benefits:**
- Avoid data duplication
- Easier updates
- Better performance

### Use createEntityAdapter

```js
import { createEntityAdapter, createSlice } from '@reduxjs/toolkit';

const postsAdapter = createEntityAdapter();

const postsSlice = createSlice({
  name: 'posts',
  initialState: postsAdapter.getInitialState(),
  reducers: {
    addPost: postsAdapter.addOne,
    addPosts: postsAdapter.addMany,
    updatePost: postsAdapter.updateOne,
    removePost: postsAdapter.removeOne
  }
});
```

---

## 2. What Goes in State?

### ✅ Store in Redux:
- **Global data** (user, auth, settings)
- **Shared data** (used by multiple components)
- **Server cache** (API responses)
- **Complex data** (needs serialization)

### ❌ Don't Store in Redux:
- **Form state** (use local state or form libraries)
- **UI state** (modals, dropdowns - use local state)
- **Derived data** (compute on the fly)
- **Non-serializable values** (functions, Promises, class instances)

### Example

```js
// ❌ Bad: Everything in Redux
const state = {
  user: { ... },
  modalOpen: true,              // ❌ UI state
  searchInput: 'hello',         // ❌ Form state
  filteredPosts: [...],         // ❌ Derived data
  fetchPromise: Promise.resolve() // ❌ Non-serializable
};

// ✅ Good: Only global/shared data
const state = {
  user: { ... },
  posts: { ... },
  comments: { ... }
};
```

---

## 3. Folder Structure

### Feature-Based Structure (Recommended)

```
src/
├── features/
│   ├── auth/
│   │   ├── authSlice.js
│   │   ├── authAPI.js
│   │   ├── Login.jsx
│   │   └── authSelectors.js
│   ├── posts/
│   │   ├── postsSlice.js
│   │   ├── postsAPI.js
│   │   ├── PostsList.jsx
│   │   └── postsSelectors.js
│   └── users/
│       ├── usersSlice.js
│       └── UserProfile.jsx
├── app/
│   └── store.js
└── components/
    └── common/
```

### Redux Ducks Pattern

All Redux logic in one file per feature:

```js
// features/posts/postsSlice.js

// Action types
const FETCH_POSTS = 'posts/FETCH_POSTS';

// Slice
const postsSlice = createSlice({
  name: 'posts',
  initialState: { ... },
  reducers: { ... }
});

// Selectors
export const selectAllPosts = state => state.posts.items;
export const selectPostById = (state, id) => state.posts.byId[id];

// Actions
export const { addPost, removePost } = postsSlice.actions;

// Reducer
export default postsSlice.reducer;
```

---

## 4. Action Best Practices

### ✅ Do: Use Action Creators

```js
// ✅ Good: Action creator
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: { text }
});

dispatch(addTodo('Buy milk'));
```

### ✅ Do: Use RTK's createSlice

```js
const todosSlice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push({ id: Date.now(), text: action.payload });
    }
  }
});

export const { addTodo } = todosSlice.actions;
```

### ❌ Don't: Put Logic in Actions

```js
// ❌ Bad: Logic in action
const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: {
    id: Date.now(),
    text: text.trim().toLowerCase()
  }
});

// ✅ Good: Logic in reducer or selector
const todosSlice = createSlice({
  name: 'todos',
  reducers: {
    addTodo: (state, action) => {
      state.push({
        id: Date.now(),
        text: action.payload.trim().toLowerCase()
      });
    }
  }
});
```

---

## 5. Reducer Best Practices

### ✅ Do: Keep Reducers Pure

```js
// ✅ Good: Pure reducer
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    default:
      return state;
  }
}

// ❌ Bad: Impure (mutates, uses Date.now)
function reducer(state, action) {
  state.count++; // ❌ Mutation
  state.timestamp = Date.now(); // ❌ Non-deterministic
  return state;
}
```

### ✅ Do: Use Immer (RTK does this automatically)

```js
// ✅ RTK with Immer: "Mutate" safely
const slice = createSlice({
  name: 'todos',
  initialState: [],
  reducers: {
    addTodo: (state, action) => {
      state.push(action.payload); // Looks like mutation, but isn't!
    }
  }
});
```

### ❌ Don't: Perform Side Effects

```js
// ❌ Bad: API call in reducer
function reducer(state, action) {
  if (action.type === 'FETCH_USERS') {
    fetch('/api/users').then(...); // ❌ Side effect!
  }
  return state;
}

// ✅ Good: Side effects in thunks/sagas
const fetchUsers = createAsyncThunk('users/fetch', async () => {
  const response = await fetch('/api/users');
  return response.json();
});
```

---

## 6. Selectors Best Practices

### ✅ Use Reselect for Memoization

```bash
npm install reselect
```

```js
import { createSelector } from 'reselect';

// Input selectors
const selectTodos = state => state.todos;
const selectFilter = state => state.filter;

// Memoized selector
export const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    console.log('Computing filtered todos...'); // Only runs when inputs change
    return todos.filter(todo => todo.status === filter);
  }
);
```

**Benefits:**
- Avoid unnecessary re-computations
- Better performance

### ✅ Co-locate Selectors with Slices

```js
// features/todos/todosSlice.js

const todosSlice = createSlice({ ... });

// Selectors
export const selectAllTodos = state => state.todos;
export const selectTodoById = (state, id) => state.todos.find(t => t.id === id);

export default todosSlice.reducer;
```

---

## 7. Async Logic Best Practices

### ✅ Use createAsyncThunk (RTK)

```js
import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

export const fetchPosts = createAsyncThunk(
  'posts/fetch',
  async () => {
    const response = await fetch('/api/posts');
    return response.json();
  }
);

const postsSlice = createSlice({
  name: 'posts',
  initialState: { items: [], loading: false, error: null },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.items = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});
```

### ✅ Or Use RTK Query

```js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

export const { useGetPostsQuery } = api;
```

---

## 8. Performance Optimization

### ✅ Normalize State

```js
// ✅ Good: Normalized (O(1) lookup)
const state = {
  users: {
    byId: { 1: { name: 'John' }, 2: { name: 'Jane' } },
    allIds: [1, 2]
  }
};

// ❌ Bad: Array (O(n) lookup)
const state = {
  users: [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' }
  ]
};
```

### ✅ Use Memoized Selectors

```js
import { createSelector } from 'reselect';

export const selectExpensiveComputation = createSelector(
  [selectData],
  (data) => {
    // Expensive computation only runs when data changes
    return data.map(item => /* complex logic */);
  }
);
```

### ✅ Split Large Slices

```js
// ❌ Bad: One giant slice
const appSlice = createSlice({
  name: 'app',
  initialState: { users: [], posts: [], comments: [], ... }
});

// ✅ Good: Separate slices
const usersSlice = createSlice({ ... });
const postsSlice = createSlice({ ... });
const commentsSlice = createSlice({ ... });
```

### ✅ Use shallowEqual for useSelector

```js
import { useSelector, shallowEqual } from 'react-redux';

// ❌ Re-renders on every state change (even if data is same)
const data = useSelector(state => ({ user: state.user, posts: state.posts }));

// ✅ Only re-renders if data actually changes
const data = useSelector(
  state => ({ user: state.user, posts: state.posts }),
  shallowEqual
);
```

---

## 9. TypeScript Best Practices

### ✅ Type RootState and AppDispatch

```typescript
import { configureStore } from '@reduxjs/toolkit';
import usersReducer from './usersSlice';

export const store = configureStore({
  reducer: {
    users: usersReducer
  }
});

// Infer types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

### ✅ Create Typed Hooks

```typescript
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from './store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

### ✅ Use in Components

```typescript
import { useAppSelector, useAppDispatch } from './hooks';

function MyComponent() {
  const users = useAppSelector(state => state.users); // ✅ Typed!
  const dispatch = useAppDispatch(); // ✅ Typed!
}
```

---

## 10. Testing Best Practices

### Test Reducers

```js
import reducer, { increment } from './counterSlice';

test('increment', () => {
  const state = { value: 0 };
  const newState = reducer(state, increment());
  expect(newState.value).toBe(1);
});
```

### Test Async Thunks

```js
import { fetchUsers } from './usersSlice';

test('fetchUsers', async () => {
  const dispatch = jest.fn();
  const getState = jest.fn();
  
  global.fetch = jest.fn(() =>
    Promise.resolve({ json: () => Promise.resolve([{ id: 1 }]) })
  );
  
  await fetchUsers()(dispatch, getState);
  
  expect(dispatch).toHaveBeenCalledWith({ type: 'users/fetch/pending' });
});
```

### Test Selectors

```js
import { selectFilteredTodos } from './todosSlice';

test('selectFilteredTodos', () => {
  const state = {
    todos: [
      { id: 1, text: 'Test', completed: false },
      { id: 2, text: 'Done', completed: true }
    ],
    filter: 'completed'
  };
  
  const result = selectFilteredTodos(state);
  expect(result).toHaveLength(1);
  expect(result[0].id).toBe(2);
});
```

---

## Common Anti-Patterns

### ❌ 1. Prop Drilling

Don't pass Redux data through many components.

```jsx
// ❌ Bad
<App>
  <Header user={user} /> {/* Passing down */}
    <Navbar user={user} /> {/* Passing down */}
      <Avatar user={user} /> {/* Finally used */}
</App>

// ✅ Good: Connect directly
function Avatar() {
  const user = useSelector(state => state.user);
  return <img src={user.avatar} />;
}
```

### ❌ 2. Storing Everything in Redux

```js
// ❌ Bad: Form input in Redux
const [input, setInput] = useState('');
dispatch(setSearchQuery(input)); // ❌ Don't do this!

// ✅ Good: Local state for forms
const [input, setInput] = useState('');
```

### ❌ 3. Not Using RTK

```js
// ❌ Bad: Manual Redux
const INCREMENT = 'INCREMENT';
const increment = () => ({ type: INCREMENT });
const reducer = (state, action) => { ... };

// ✅ Good: Use Redux Toolkit
const slice = createSlice({ ... });
```

### ❌ 4. Mutating State

```js
// ❌ Bad: Direct mutation
function reducer(state, action) {
  state.count++; // ❌ Mutation!
  return state;
}

// ✅ Good: Immutable update (or use RTK/Immer)
function reducer(state, action) {
  return { ...state, count: state.count + 1 };
}
```

---

## Redux DevTools Tips

### Time-Travel Debugging

- Click on actions to jump to that state
- Useful for debugging complex flows

### State Diff

- See what changed between actions
- Helps identify unexpected mutations

### Trace

- See which component dispatched an action
- Enable in DevTools settings

### Export/Import State

```js
// Export state for debugging
const state = store.getState();
console.log(JSON.stringify(state));

// Import state for testing
store.dispatch({ type: '__IMPORT_STATE__', state: importedState });
```

---

## Summary Checklist

### State Structure
- ✅ Normalize complex/nested data
- ✅ Use `createEntityAdapter` for collections
- ✅ Only store global/shared data

### Actions & Reducers
- ✅ Use RTK's `createSlice`
- ✅ Keep reducers pure (no side effects)
- ✅ Use Immer for immutability

### Async Logic
- ✅ Use `createAsyncThunk` or RTK Query
- ✅ Handle loading/error states

### Selectors
- ✅ Use Reselect for expensive computations
- ✅ Co-locate selectors with slices

### Performance
- ✅ Normalize state for O(1) lookups
- ✅ Memoize selectors
- ✅ Use `shallowEqual` in `useSelector`

### File Structure
- ✅ Feature-based folders
- ✅ Collocate related code

### Testing
- ✅ Test reducers, selectors, thunks
- ✅ Mock API calls

### TypeScript
- ✅ Type `RootState` and `AppDispatch`
- ✅ Create typed hooks

---

## Final Recommendations

1. **Use Redux Toolkit** - Don't use vanilla Redux
2. **Normalize state** - Avoid nested structures
3. **Use RTK Query** - For API-heavy apps
4. **Memoize selectors** - For performance
5. **Type everything** - If using TypeScript
6. **Test thoroughly** - Reducers, selectors, thunks
7. **Follow official docs** - They're excellent!

**Redux is simple when you follow best practices.** ✨

