# Redux Core Concepts (Actions, Reducers, Store)

## The Three Core Concepts

1. **Store** - Holds the application state
2. **Actions** - Describe what happened
3. **Reducers** - Specify how state changes

---

## Actions

Actions are **plain JavaScript objects** that describe what happened. They must have a `type` property.

### Basic Action

```js
const action = {
  type: 'ADD_TODO'
};
```

### Action with Payload

```js
const action = {
  type: 'ADD_TODO',
  payload: {
    id: 1,
    text: 'Learn Redux',
    completed: false
  }
};
```

### Action Creators

Functions that create actions:

```js
// Action creator
function addTodo(text) {
  return {
    type: 'ADD_TODO',
    payload: {
      id: Date.now(),
      text,
      completed: false
    }
  };
}

// Usage
const action = addTodo('Learn Redux');
store.dispatch(action);
```

### Action Type Constants

Prevent typos by using constants:

```js
// Action types
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';
const DELETE_TODO = 'DELETE_TODO';

// Action creators
const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { id: Date.now(), text, completed: false }
});

const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: id
});

const deleteTodo = (id) => ({
  type: DELETE_TODO,
  payload: id
});
```

---

## Reducers

Reducers are **pure functions** that take the current state and an action, and return a new state.

### Reducer Signature

```js
(previousState, action) => newState
```

### Basic Reducer

```js
const initialState = {
  count: 0
};

function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    
    case 'DECREMENT':
      return { count: state.count - 1 };
    
    case 'RESET':
      return { count: 0 };
    
    default:
      return state;
  }
}
```

### Reducer Rules

1. **Pure function** - No side effects
2. **Return new state** - Don't mutate
3. **Handle default case** - Return current state
4. **Synchronous** - No async operations

```js
// ❌ Wrong - Mutating state
function badReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      state.count++; // Mutation!
      return state;
    default:
      return state;
  }
}

// ✅ Correct - Return new object
function goodReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 }; // New object
    default:
      return state;
  }
}
```

### Complex Reducer Example

```js
const initialState = {
  todos: [],
  filter: 'all'
};

function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload
      };
    
    default:
      return state;
  }
}
```

### Combining Reducers

Split large reducers into smaller ones:

```js
import { combineReducers } from 'redux';

// Todos reducer
function todosReducer(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    default:
      return state;
  }
}

// Filter reducer
function filterReducer(state = 'all', action) {
  switch (action.type) {
    case 'SET_FILTER':
      return action.payload;
    default:
      return state;
  }
}

// User reducer
function userReducer(state = null, action) {
  switch (action.type) {
    case 'LOGIN':
      return action.payload;
    case 'LOGOUT':
      return null;
    default:
      return state;
  }
}

// Combine into root reducer
const rootReducer = combineReducers({
  todos: todosReducer,
  filter: filterReducer,
  user: userReducer
});

// State shape:
// {
//   todos: [],
//   filter: 'all',
//   user: null
// }
```

---

## Store

The store holds the application state and provides methods to interact with it.

### Creating a Store

```js
import { createStore } from 'redux';

const store = createStore(rootReducer);
```

### Store Methods

#### 1. getState()

Get current state:

```js
const state = store.getState();
console.log(state);
```

#### 2. dispatch(action)

Dispatch an action:

```js
store.dispatch({ type: 'INCREMENT' });
store.dispatch(addTodo('Learn Redux'));
```

#### 3. subscribe(listener)

Listen to state changes:

```js
const unsubscribe = store.subscribe(() => {
  console.log('State changed:', store.getState());
});

// Later, stop listening
unsubscribe();
```

### Complete Example

```js
import { createStore } from 'redux';

// 1. Define action types
const ADD_TODO = 'ADD_TODO';
const TOGGLE_TODO = 'TOGGLE_TODO';
const DELETE_TODO = 'DELETE_TODO';

// 2. Create action creators
const addTodo = (text) => ({
  type: ADD_TODO,
  payload: { id: Date.now(), text, completed: false }
});

const toggleTodo = (id) => ({
  type: TOGGLE_TODO,
  payload: id
});

const deleteTodo = (id) => ({
  type: DELETE_TODO,
  payload: id
});

// 3. Create reducer
const initialState = {
  todos: []
};

function todoReducer(state = initialState, action) {
  switch (action.type) {
    case ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, action.payload]
      };
    
    case TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    
    default:
      return state;
  }
}

// 4. Create store
const store = createStore(todoReducer);

// 5. Subscribe to changes
store.subscribe(() => {
  console.log('Current state:', store.getState());
});

// 6. Dispatch actions
store.dispatch(addTodo('Learn Redux'));
// Current state: { todos: [{ id: 123, text: 'Learn Redux', completed: false }] }

store.dispatch(addTodo('Build an app'));
// Current state: { todos: [{ id: 123, ... }, { id: 124, ... }] }

store.dispatch(toggleTodo(123));
// Current state: { todos: [{ id: 123, text: 'Learn Redux', completed: true }, ...] }

store.dispatch(deleteTodo(123));
// Current state: { todos: [{ id: 124, ... }] }
```

---

## Immutability Patterns

### Arrays

```js
// Add item
return {
  ...state,
  items: [...state.items, newItem]
};

// Remove item
return {
  ...state,
  items: state.items.filter(item => item.id !== id)
};

// Update item
return {
  ...state,
  items: state.items.map(item =>
    item.id === id ? { ...item, ...updates } : item
  )
};

// Replace array
return {
  ...state,
  items: newItems
};
```

### Objects

```js
// Update property
return {
  ...state,
  name: 'New name'
};

// Update nested object
return {
  ...state,
  user: {
    ...state.user,
    name: 'New name'
  }
};

// Deep nested update
return {
  ...state,
  user: {
    ...state.user,
    address: {
      ...state.user.address,
      city: 'New York'
    }
  }
};
```

---

## Interview Questions

### Q1: What are actions in Redux?
**Answer**: Actions are plain JavaScript objects that describe what happened. They must have a `type` property and optionally a `payload` with data. They're the only way to trigger state changes.

### Q2: What are action creators?
**Answer**: Action creators are functions that create and return action objects. They make dispatching actions easier and more maintainable.

```js
const addTodo = (text) => ({ type: 'ADD_TODO', payload: text });
store.dispatch(addTodo('Learn Redux'));
```

### Q3: What is a reducer?
**Answer**: A reducer is a pure function that takes the current state and an action, and returns a new state. It describes how the state changes in response to actions.

### Q4: What are the rules for reducers?
**Answer**:
1. Must be pure (no side effects)
2. Must not mutate state (return new objects)
3. Must handle the default case
4. Must be synchronous
5. Same inputs always produce same output

### Q5: What does combineReducers do?
**Answer**: `combineReducers` combines multiple reducer functions into a single root reducer. Each reducer manages its own slice of state.

```js
const rootReducer = combineReducers({
  todos: todosReducer,
  user: userReducer
});
```

### Q6: What are the main store methods?
**Answer**:
- `getState()` - Returns current state
- `dispatch(action)` - Dispatches an action
- `subscribe(listener)` - Adds change listener
- `replaceReducer(nextReducer)` - Replaces reducer

### Q7: Why is immutability important in Redux?
**Answer**: Immutability ensures:
- Predictable state changes
- Easy debugging (can compare references)
- Time travel debugging works
- Performance optimizations (shallow comparison)
- Enables undo/redo functionality

---

## Best Practices

1. **Use action type constants** - Prevent typos
2. **Use action creators** - Encapsulate action creation
3. **Keep reducers pure** - No side effects
4. **Never mutate state** - Always return new objects
5. **Handle default case** - Return current state
6. **Split large reducers** - Use combineReducers
7. **Organize by feature** - Group related code
8. **Use descriptive action types** - 'ADD_TODO' not 'ADD'
9. **Single responsibility** - One action type per action
10. **Keep state normalized** - Avoid nested data

---

## Common Patterns

### Resetting State

```js
function rootReducer(state, action) {
  if (action.type === 'RESET_APP') {
    state = undefined; // Reset to initial state
  }
  return appReducer(state, action);
}
```

### Handling Loading States

```js
const initialState = {
  data: null,
  loading: false,
  error: null
};

function dataReducer(state = initialState, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    
    case 'FETCH_SUCCESS':
      return { ...state, loading: false, data: action.payload };
    
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    
    default:
      return state;
  }
}
```

---

## Summary

- **Actions** describe what happened (plain objects with type)
- **Action creators** are functions that return actions
- **Reducers** specify how state changes (pure functions)
- **Store** holds state and provides getState, dispatch, subscribe
- **combineReducers** combines multiple reducers
- **Immutability** is crucial - never mutate state
- Use **constants** for action types
- Keep reducers **pure** and **synchronous**
- Follow **patterns** for common scenarios

