# RTK Query

## What is RTK Query?

**RTK Query** is a powerful data fetching and caching tool built into Redux Toolkit.

Think of it as **React Query** + **Redux** combined.

**Key Features:**
- Auto-generated hooks
- Automatic caching
- Request deduplication
- Auto re-fetching
- Optimistic updates
- TypeScript support

> **No more manual API state management!**

---

## Why RTK Query?

### Without RTK Query (Manual Approach)

```js
// âŒ Lots of boilerplate for each API call!

const fetchPosts = createAsyncThunk('posts/fetch', async () => {
  const response = await fetch('/api/posts');
  return response.json();
});

const postsSlice = createSlice({
  name: 'posts',
  initialState: { data: [], loading: false, error: null },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});

// Repeat for every API endpoint! ðŸ˜«
```

### With RTK Query

```js
// âœ… Define API once, auto-generate hooks!

const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => 'posts'
    })
  })
});

export const { useGetPostsQuery } = api;

// Use in component
function Posts() {
  const { data, isLoading, error } = useGetPostsQuery();
  // That's it! ðŸŽ‰
}
```

---

## Installation

RTK Query is included in Redux Toolkit.

```bash
npm install @reduxjs/toolkit react-redux
```

---

## Basic Setup

### 1. Create API Slice

```js
// src/services/api.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com' }),
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    }),
    getPost: builder.query({
      query: (id) => `/posts/${id}`
    })
  })
});

export const { useGetPostsQuery, useGetPostQuery } = api;
```

### 2. Add to Store

```js
// src/store.js
import { configureStore } from '@reduxjs/toolkit';
import { api } from './services/api';

export const store = configureStore({
  reducer: {
    [api.reducerPath]: api.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
});
```

### 3. Use in Component

```jsx
import { useGetPostsQuery } from './services/api';

function Posts() {
  const { data, isLoading, isError, error } = useGetPostsQuery();

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

**That's all the code you need!** ðŸš€

---

## Query Endpoints

### Basic Query

```js
endpoints: (builder) => ({
  getPosts: builder.query({
    query: () => '/posts'
  })
})
```

### Query with Parameters

```js
endpoints: (builder) => ({
  getPost: builder.query({
    query: (id) => `/posts/${id}`
  })
})

// Usage
const { data } = useGetPostQuery(5);
```

### Query with Multiple Parameters

```js
endpoints: (builder) => ({
  getPostsByUser: builder.query({
    query: ({ userId, limit }) => ({
      url: '/posts',
      params: { userId, _limit: limit }
    })
  })
})

// Usage
const { data } = useGetPostsByUserQuery({ userId: 1, limit: 10 });
```

### Query with Headers

```js
endpoints: (builder) => ({
  getProtectedData: builder.query({
    query: () => ({
      url: '/protected',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    })
  })
})
```

---

## Mutation Endpoints

Mutations are for **POST, PUT, PATCH, DELETE** operations.

### Basic Mutation

```js
endpoints: (builder) => ({
  addPost: builder.mutation({
    query: (post) => ({
      url: '/posts',
      method: 'POST',
      body: post
    })
  })
})
```

### Using Mutation in Component

```jsx
import { useAddPostMutation } from './services/api';

function AddPost() {
  const [addPost, { isLoading, isSuccess }] = useAddPostMutation();

  const handleSubmit = async (e) => {
    e.preventDefault();
    const post = { title: 'New Post', body: 'Content' };
    
    try {
      await addPost(post).unwrap();
      alert('Post added!');
    } catch (error) {
      alert('Error: ' + error.message);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Adding...' : 'Add Post'}
      </button>
      {isSuccess && <p>Post added successfully!</p>}
    </form>
  );
}
```

---

## Complete CRUD Example

### API Slice

```js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const postsApi = createApi({
  reducerPath: 'postsApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Posts'],
  endpoints: (builder) => ({
    // Get all posts
    getPosts: builder.query({
      query: () => '/posts',
      providesTags: ['Posts']
    }),
    
    // Get single post
    getPost: builder.query({
      query: (id) => `/posts/${id}`,
      providesTags: (result, error, id) => [{ type: 'Posts', id }]
    }),
    
    // Create post
    addPost: builder.mutation({
      query: (post) => ({
        url: '/posts',
        method: 'POST',
        body: post
      }),
      invalidatesTags: ['Posts']
    }),
    
    // Update post
    updatePost: builder.mutation({
      query: ({ id, ...patch }) => ({
        url: `/posts/${id}`,
        method: 'PATCH',
        body: patch
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
    }),
    
    // Delete post
    deletePost: builder.mutation({
      query: (id) => ({
        url: `/posts/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: ['Posts']
    })
  })
});

export const {
  useGetPostsQuery,
  useGetPostQuery,
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation
} = postsApi;
```

### Component

```jsx
import {
  useGetPostsQuery,
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation
} from './services/postsApi';

function PostsList() {
  const { data: posts, isLoading } = useGetPostsQuery();
  const [addPost] = useAddPostMutation();
  const [updatePost] = useUpdatePostMutation();
  const [deletePost] = useDeletePostMutation();

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <button onClick={() => addPost({ title: 'New Post' })}>
        Add Post
      </button>
      
      {posts.map(post => (
        <div key={post.id}>
          <h3>{post.title}</h3>
          <button onClick={() => updatePost({ id: post.id, title: 'Updated' })}>
            Update
          </button>
          <button onClick={() => deletePost(post.id)}>
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}
```

---

## Caching & Tags

### providesTags (What data this query provides)

```js
getPosts: builder.query({
  query: () => '/posts',
  providesTags: ['Posts'] // This query provides "Posts" data
})
```

### invalidatesTags (What data this mutation invalidates)

```js
addPost: builder.mutation({
  query: (post) => ({
    url: '/posts',
    method: 'POST',
    body: post
  }),
  invalidatesTags: ['Posts'] // Invalidate "Posts" cache â†’ auto-refetch
})
```

**After `addPost`, `getPosts` automatically re-fetches!**

### Advanced Tags

```js
endpoints: (builder) => ({
  getPosts: builder.query({
    query: () => '/posts',
    providesTags: (result) =>
      result
        ? [
            ...result.map(({ id }) => ({ type: 'Posts', id })),
            { type: 'Posts', id: 'LIST' }
          ]
        : [{ type: 'Posts', id: 'LIST' }]
  }),
  
  updatePost: builder.mutation({
    query: ({ id, ...patch }) => ({
      url: `/posts/${id}`,
      method: 'PATCH',
      body: patch
    }),
    invalidatesTags: (result, error, { id }) => [{ type: 'Posts', id }]
  })
});
```

This invalidates **only the updated post**, not all posts.

---

## Auto-Refetching

### Manual Refetch

```jsx
function Posts() {
  const { data, refetch } = useGetPostsQuery();

  return (
    <div>
      <button onClick={refetch}>Refresh</button>
      {/* ... */}
    </div>
  );
}
```

### Polling (Auto-refetch every X seconds)

```jsx
function Posts() {
  const { data } = useGetPostsQuery(undefined, {
    pollingInterval: 3000 // Refetch every 3 seconds
  });
  
  return <div>{/* ... */}</div>;
}
```

### Refetch on Focus/Reconnect

```js
const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  refetchOnMountOrArgChange: 30, // Refetch if data is older than 30s
  refetchOnFocus: true,           // Refetch when window regains focus
  refetchOnReconnect: true,       // Refetch on reconnect
  endpoints: (builder) => ({
    // ...
  })
});
```

---

## Optimistic Updates

Update UI immediately, rollback if request fails.

```js
updatePost: builder.mutation({
  query: ({ id, ...patch }) => ({
    url: `/posts/${id}`,
    method: 'PATCH',
    body: patch
  }),
  async onQueryStarted({ id, ...patch }, { dispatch, queryFulfilled }) {
    // Optimistic update
    const patchResult = dispatch(
      postsApi.util.updateQueryData('getPosts', undefined, (draft) => {
        const post = draft.find(p => p.id === id);
        if (post) Object.assign(post, patch);
      })
    );
    
    try {
      await queryFulfilled;
    } catch {
      // Rollback on error
      patchResult.undo();
    }
  }
})
```

---

## Conditional Fetching

Skip query based on condition.

```jsx
function UserProfile({ userId }) {
  const { data } = useGetUserQuery(userId, {
    skip: !userId // Don't fetch if no userId
  });

  if (!userId) return <div>No user selected</div>;
  return <div>{data?.name}</div>;
}
```

---

## Lazy Queries

Trigger query manually.

```jsx
import { useLazyGetPostQuery } from './services/api';

function SearchPosts() {
  const [trigger, result] = useLazyGetPostQuery();

  const handleSearch = (id) => {
    trigger(id);
  };

  return (
    <div>
      <button onClick={() => handleSearch(5)}>Search Post 5</button>
      {result.data && <div>{result.data.title}</div>}
    </div>
  );
}
```

---

## Authentication

### With Token

```js
const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    }
  }),
  endpoints: (builder) => ({
    // ...
  })
});
```

### Custom Base Query with Error Handling

```js
import { fetchBaseQuery } from '@reduxjs/toolkit/query/react';

const baseQuery = fetchBaseQuery({ baseUrl: '/api' });

const baseQueryWithReauth = async (args, api, extraOptions) => {
  let result = await baseQuery(args, api, extraOptions);
  
  if (result.error?.status === 401) {
    // Try to refresh token
    const refreshResult = await baseQuery('/refresh', api, extraOptions);
    
    if (refreshResult.data) {
      // Store new token
      api.dispatch(setToken(refreshResult.data.token));
      // Retry original query
      result = await baseQuery(args, api, extraOptions);
    } else {
      // Logout
      api.dispatch(logout());
    }
  }
  
  return result;
};

const api = createApi({
  baseQuery: baseQueryWithReauth,
  endpoints: (builder) => ({
    // ...
  })
});
```

---

## Code Splitting

Load API endpoints on demand.

### api.js (Base)

```js
export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: () => ({})
});
```

### postsApi.js (Extended)

```js
import { api } from './api';

export const postsApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getPosts: builder.query({
      query: () => '/posts'
    })
  })
});

export const { useGetPostsQuery } = postsApi;
```

### usersApi.js (Extended)

```js
import { api } from './api';

export const usersApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => '/users'
    })
  })
});

export const { useGetUsersQuery } = usersApi;
```

---

## TypeScript Support

RTK Query has excellent TypeScript support.

```typescript
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

interface Post {
  id: number;
  title: string;
  body: string;
}

export const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getPosts: builder.query<Post[], void>({
      query: () => '/posts'
    }),
    getPost: builder.query<Post, number>({
      query: (id) => `/posts/${id}`
    }),
    addPost: builder.mutation<Post, Partial<Post>>({
      query: (post) => ({
        url: '/posts',
        method: 'POST',
        body: post
      })
    })
  })
});
```

---

## Interview Questions

### Q1: What is RTK Query?
**Answer**: RTK Query is a data fetching and caching tool built into Redux Toolkit. It auto-generates hooks, handles caching, and simplifies API state management.

### Q2: How is RTK Query different from React Query?
**Answer**:
- **RTK Query**: Redux-based, integrated with Redux store
- **React Query**: Standalone, not Redux-based

Both have similar features (caching, auto-refetch, etc.).

### Q3: What are providesTags and invalidatesTags?
**Answer**:
- `providesTags`: Marks what data a query provides
- `invalidatesTags`: Marks what data a mutation invalidates

When tags are invalidated, related queries auto-refetch.

### Q4: How does RTK Query handle caching?
**Answer**: RTK Query caches results by endpoint and arguments. It automatically reuses cached data and refetches when stale.

### Q5: What's the difference between query and mutation?
**Answer**:
- `query`: For GET requests (read data)
- `mutation`: For POST/PUT/PATCH/DELETE (modify data)

### Q6: Can RTK Query work without Redux?
**Answer**: No, RTK Query requires Redux Toolkit and integrates with the Redux store.

### Q7: How do you handle authentication in RTK Query?
**Answer**: Use `prepareHeaders` in `fetchBaseQuery`:

```js
prepareHeaders: (headers, { getState }) => {
  const token = getState().auth.token;
  if (token) headers.set('Authorization', `Bearer ${token}`);
  return headers;
}
```

---

## Best Practices

1. **Use tags for automatic refetching** - Avoid manual cache management
2. **Implement optimistic updates** - Better UX
3. **Split API by feature** - Use `injectEndpoints` for code splitting
4. **Use TypeScript** - Excellent type safety
5. **Handle errors globally** - Custom base query with error handling
6. **Leverage polling** - For real-time data needs
7. **Use conditional fetching** - Skip unnecessary requests
8. **Normalize responses** - For complex nested data

---

## Summary

- **RTK Query** simplifies data fetching in Redux
- **Auto-generates hooks** from API definitions
- **Automatic caching** and request deduplication
- **Tags system** for automatic refetching
- **Optimistic updates** for better UX
- **Polling, lazy queries, conditional fetching** built-in
- **TypeScript support** is excellent
- **No more manual API state management!**
- Use for **API-heavy apps** with Redux

