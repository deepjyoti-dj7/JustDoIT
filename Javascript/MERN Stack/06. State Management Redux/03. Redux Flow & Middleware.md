# Redux Flow & Middleware

## Redux Data Flow

Redux follows a **strict unidirectional data flow**.

### The Complete Flow

```
1. User interacts with UI
   ↓
2. Component dispatches action
   ↓
3. Store passes action to middleware
   ↓
4. Middleware processes action (optional)
   ↓
5. Store passes action to reducer
   ↓
6. Reducer returns new state
   ↓
7. Store updates state
   ↓
8. Store notifies subscribers
   ↓
9. Component re-renders with new state
```

### Visual Diagram

```
┌─────────────┐
│   UI/View   │
└──────┬──────┘
       │ User action (click, input, etc.)
       ↓
┌──────────────────┐
│    dispatch()    │
└──────┬───────────┘
       │ Action object
       ↓
┌──────────────────┐
│   Middleware(s)  │ ← Intercept actions
└──────┬───────────┘
       │ Modified/async action
       ↓
┌──────────────────┐
│     Reducer      │ ← Pure function
└──────┬───────────┘
       │ New state
       ↓
┌──────────────────┐
│      Store       │ ← Single source of truth
└──────┬───────────┘
       │ State updated
       ↓
┌──────────────────┐
│   UI/View        │ ← Re-renders
└──────────────────┘
```

---

## Step-by-Step Example

### 1. Initial Setup

```js
import { createStore } from 'redux';

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    default:
      return state;
  }
}

// Create store
const store = createStore(counterReducer);
```

### 2. Subscribe to Changes

```js
store.subscribe(() => {
  console.log('State changed:', store.getState());
});
```

### 3. Dispatch Action

```js
store.dispatch({ type: 'INCREMENT' });
// State changed: { count: 1 }
```

### 4. With React Component

```jsx
import { useSelector, useDispatch } from 'react-redux';

function Counter() {
  // 1. Select state from store
  const count = useSelector(state => state.count);
  
  // 2. Get dispatch function
  const dispatch = useDispatch();

  // 3. Dispatch action on click
  const handleClick = () => {
    dispatch({ type: 'INCREMENT' });
  };

  // 4. Render with current state
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

---

## Middleware

**Middleware** provides a way to extend Redux with custom functionality. It sits between dispatching an action and the moment it reaches the reducer.

### What is Middleware?

Middleware is a function that:
- Intercepts every action
- Can modify, delay, or cancel actions
- Can dispatch additional actions
- Has access to `getState()` and `dispatch()`

### Middleware Signature

```js
const middleware = store => next => action => {
  // Do something before
  const result = next(action);
  // Do something after
  return result;
};
```

---

## Built-in Middleware Examples

### 1. Logger Middleware

Logs actions and state:

```js
const loggerMiddleware = store => next => action => {
  console.log('Dispatching:', action);
  console.log('Previous state:', store.getState());
  
  const result = next(action);
  
  console.log('Next state:', store.getState());
  return result;
};
```

### 2. Crash Reporter Middleware

```js
const crashReporter = store => next => action => {
  try {
    return next(action);
  } catch (err) {
    console.error('Caught an exception!', err);
    // Send to error reporting service
    throw err;
  }
};
```

### 3. Delay Middleware

```js
const delayMiddleware = store => next => action => {
  if (action.meta && action.meta.delay) {
    setTimeout(() => next(action), action.meta.delay);
  } else {
    return next(action);
  }
};

// Usage
dispatch({
  type: 'DELAYED_ACTION',
  meta: { delay: 1000 }
});
```

---

## Applying Middleware

### With Redux

```js
import { createStore, applyMiddleware } from 'redux';

const store = createStore(
  rootReducer,
  applyMiddleware(logger, crashReporter, delay)
);
```

### With Redux DevTools

```js
import { createStore, applyMiddleware, compose } from 'redux';

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(logger, thunk))
);
```

---

## Popular Middleware

### 1. Redux Thunk

Handle async actions:

```js
import thunk from 'redux-thunk';

// Async action creator
const fetchUser = (id) => {
  return async (dispatch, getState) => {
    dispatch({ type: 'FETCH_USER_START' });
    
    try {
      const response = await fetch(`/api/users/${id}`);
      const user = await response.json();
      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });
    } catch (error) {
      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });
    }
  };
};

// Apply middleware
const store = createStore(rootReducer, applyMiddleware(thunk));
```

### 2. Redux Logger

Logs actions and state changes:

```js
import logger from 'redux-logger';

const store = createStore(
  rootReducer,
  applyMiddleware(logger)
);
```

### 3. Redux Saga

Handle complex async flows:

```js
import createSagaMiddleware from 'redux-saga';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();

const store = createStore(
  rootReducer,
  applyMiddleware(sagaMiddleware)
);

sagaMiddleware.run(rootSaga);
```

---

## Creating Custom Middleware

### Template

```js
const customMiddleware = store => next => action => {
  // Before reducer
  console.log('Before:', action);
  
  // Call next middleware or reducer
  const result = next(action);
  
  // After reducer
  console.log('After:', store.getState());
  
  return result;
};
```

### Analytics Middleware

```js
const analyticsMiddleware = store => next => action => {
  // Track specific actions
  if (action.type === 'USER_LOGIN') {
    analytics.track('User Logged In', {
      userId: action.payload.id
    });
  }
  
  return next(action);
};
```

### API Middleware

```js
const apiMiddleware = store => next => action => {
  // Check if action has API call metadata
  if (!action.meta || !action.meta.api) {
    return next(action);
  }

  const { url, method, body } = action.meta.api;

  // Dispatch loading action
  store.dispatch({ type: `${action.type}_START` });

  // Make API call
  fetch(url, { method, body: JSON.stringify(body) })
    .then(res => res.json())
    .then(data => {
      store.dispatch({
        type: `${action.type}_SUCCESS`,
        payload: data
      });
    })
    .catch(error => {
      store.dispatch({
        type: `${action.type}_ERROR`,
        payload: error.message
      });
    });
};

// Usage
dispatch({
  type: 'FETCH_USERS',
  meta: {
    api: {
      url: '/api/users',
      method: 'GET'
    }
  }
});
```

---

## Middleware Execution Order

```js
const store = createStore(
  rootReducer,
  applyMiddleware(first, second, third)
);

// Flow:
// dispatch(action)
//   → first middleware
//   → second middleware  
//   → third middleware
//   → reducer
//   ← third middleware
//   ← second middleware
//   ← first middleware
```

### Example

```js
const first = store => next => action => {
  console.log('1: Before');
  const result = next(action);
  console.log('1: After');
  return result;
};

const second = store => next => action => {
  console.log('2: Before');
  const result = next(action);
  console.log('2: After');
  return result;
};

const store = createStore(reducer, applyMiddleware(first, second));

store.dispatch({ type: 'TEST' });

// Output:
// 1: Before
// 2: Before
// Reducer runs
// 2: After
// 1: After
```

---

## Interview Questions

### Q1: What is middleware in Redux?
**Answer**: Middleware provides a way to extend Redux with custom functionality between dispatching an action and the moment it reaches the reducer. It can log actions, make async calls, modify actions, or dispatch other actions.

### Q2: How does middleware work?
**Answer**: Middleware wraps the store's `dispatch` function. When you dispatch an action, it goes through all middleware in order before reaching the reducer. Each middleware can:
- Pass action to next middleware with `next(action)`
- Modify the action
- Dispatch additional actions
- Cancel the action (not call next)

### Q3: What is the middleware signature?
**Answer**:
```js
const middleware = store => next => action => {
  return next(action);
};
```
It's a curried function that receives `store`, returns a function that receives `next`, which returns a function that receives `action`.

### Q4: What's the difference between middleware and reducers?
**Answer**:
- **Middleware**: Handles side effects, async logic, runs before reducer
- **Reducers**: Pure functions, synchronous, calculate new state

Middleware is for "how to get data", reducers are for "what the data looks like".

### Q5: What is Redux Thunk?
**Answer**: Redux Thunk is middleware that allows you to write action creators that return functions instead of actions. These functions can perform async operations and dispatch actions when ready.

### Q6: Can middleware dispatch actions?
**Answer**: Yes! Middleware has access to `store.dispatch()` and can dispatch actions:

```js
const middleware = store => next => action => {
  store.dispatch({ type: 'ANOTHER_ACTION' });
  return next(action);
};
```

### Q7: What's the order of middleware execution?
**Answer**: Middleware executes in the order it's applied:

```js
applyMiddleware(first, second, third)
// Order: first → second → third → reducer → third → second → first
```

---

## Best Practices

1. **Keep middleware focused** - Single responsibility
2. **Always call `next()`** - Unless you want to stop propagation
3. **Handle errors** - Use try-catch
4. **Order matters** - Place middleware strategically
5. **Don't mutate action** - Create new objects
6. **Use existing middleware** - Don't reinvent the wheel
7. **Test middleware** - They're just functions
8. **Document side effects** - Make them clear
9. **Be careful with dispatch** - Can cause infinite loops
10. **Use Redux Toolkit** - Includes thunk by default

---

## Common Use Cases

1. **Logging** - Log every action and state change
2. **Async actions** - API calls, timers
3. **Analytics** - Track user actions
4. **Error handling** - Catch and report errors
5. **Authentication** - Add auth tokens to requests
6. **Caching** - Cache API responses
7. **Optimistic updates** - Update UI before API confirms
8. **Batching** - Combine multiple actions
9. **Routing** - Navigate on certain actions
10. **Validation** - Validate actions before processing

---

## Summary

- Redux follows **strict unidirectional flow**
- Flow: UI → dispatch → middleware → reducer → store → UI
- **Middleware** intercepts actions before they reach reducers
- Used for **async operations**, logging, analytics, etc.
- Popular middleware: **Thunk**, **Saga**, **Logger**
- Middleware signature: `store => next => action => {}`
- **Order matters** - middleware executes sequentially
- Can **dispatch actions** and **access state**
- Keep middleware **focused** and **pure** when possible
- **Redux Toolkit** includes thunk middleware by default
