# React Best Practices

## Code Organization

### 1. Folder Structure

```
src/
├── components/           # Reusable components
│   ├── common/          # Generic components (Button, Input)
│   ├── layout/          # Layout components (Header, Footer)
│   └── features/        # Feature-specific components
├── pages/               # Page components
├── hooks/               # Custom hooks
├── context/             # Context providers
├── utils/               # Utility functions
├── services/            # API services
├── constants/           # Constants and configs
├── types/               # TypeScript types (if using TS)
├── styles/              # Global styles
└── assets/              # Images, fonts, etc.
```

### 2. Component File Structure

```jsx
// Imports
import { useState, useEffect } from 'react';
import PropTypes from 'prop-types';
import './UserCard.css';

// Component
function UserCard({ user, onEdit, onDelete }) {
  // State
  const [isExpanded, setIsExpanded] = useState(false);
  
  // Effects
  useEffect(() => {
    // ...
  }, []);
  
  // Event handlers
  const handleToggle = () => setIsExpanded(!isExpanded);
  
  // Render
  return (
    <div className="user-card">
      {/* JSX */}
    </div>
  );
}

// PropTypes
UserCard.propTypes = {
  user: PropTypes.object.isRequired,
  onEdit: PropTypes.func,
  onDelete: PropTypes.func
};

// Default props
UserCard.defaultProps = {
  onEdit: () => {},
  onDelete: () => {}
};

// Export
export default UserCard;
```

---

## Naming Conventions

### Components
```jsx
// ✅ PascalCase for components
function UserProfile() { }
function TodoList() { }

// ❌ Wrong
function userProfile() { }
function todo_list() { }
```

### Functions & Variables
```jsx
// ✅ camelCase
const handleClick = () => {};
const userName = 'Alice';

// ❌ Wrong
const HandleClick = () => {};
const user_name = 'Alice';
```

### Constants
```jsx
// ✅ UPPER_SNAKE_CASE
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;
```

### Files
```jsx
// ✅ Component files: PascalCase
UserProfile.jsx
TodoList.jsx

// ✅ Utility files: camelCase
apiHelpers.js
dateUtils.js
```

---

## Component Best Practices

### 1. Keep Components Small

```jsx
// ❌ Too large
function Dashboard() {
  // 500+ lines of code
  // Multiple responsibilities
}

// ✅ Break into smaller components
function Dashboard() {
  return (
    <>
      <Header />
      <Sidebar />
      <MainContent />
      <Footer />
    </>
  );
}
```

### 2. Single Responsibility

```jsx
// ❌ Bad: Multiple responsibilities
function UserDashboard() {
  // Fetch user data
  // Handle authentication
  // Render profile
  // Handle notifications
  // Manage settings
}

// ✅ Good: Single responsibility
function UserProfile() { /* Only profile */ }
function NotificationPanel() { /* Only notifications */ }
function UserSettings() { /* Only settings */ }
```

### 3. Prop Destructuring

```jsx
// ❌ Repetitive
function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>{props.email}</p>
      <span>{props.age}</span>
    </div>
  );
}

// ✅ Clean with destructuring
function UserCard({ name, email, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
      <span>{age}</span>
    </div>
  );
}
```

### 4. Default Props

```jsx
function Button({ 
  label = 'Click me', 
  variant = 'primary', 
  disabled = false,
  onClick = () => {}
}) {
  return (
    <button 
      className={`btn-${variant}`} 
      disabled={disabled}
      onClick={onClick}
    >
      {label}
    </button>
  );
}
```

---

## State Management

### 1. Minimize State

```jsx
// ❌ Redundant state
function ProductList({ products }) {
  const [products, setProducts] = useState(products); // Duplicate!
  const [count, setCount] = useState(products.length); // Derived!
}

// ✅ Minimal state
function ProductList({ products }) {
  // Count is derived, not stored
  const count = products.length;
}
```

### 2. Lift State Up Appropriately

```jsx
// ✅ State at the right level
function SearchableList({ items }) {
  const [query, setQuery] = useState('');
  
  const filtered = items.filter(item => 
    item.name.includes(query)
  );
  
  return (
    <>
      <SearchBar value={query} onChange={setQuery} />
      <ItemList items={filtered} />
    </>
  );
}
```

### 3. Use Functional Updates

```jsx
// ❌ May use stale state
setCount(count + 1);

// ✅ Always uses latest state
setCount(c => c + 1);

// ❌ Stale state in async
setTimeout(() => {
  setCount(count + 1); // Uses count from when timeout was set
}, 1000);

// ✅ Latest state
setTimeout(() => {
  setCount(c => c + 1); // Uses current count
}, 1000);
```

### 4. Colocate State

```jsx
// ❌ State too high
function App() {
  const [modalOpen, setModalOpen] = useState(false); // Only Modal needs this
  
  return (
    <>
      <Header />
      <Sidebar />
      <Modal isOpen={modalOpen} onClose={() => setModalOpen(false)} />
    </>
  );
}

// ✅ State in the component that needs it
function Modal() {
  const [isOpen, setIsOpen] = useState(false);
  // ...
}
```

---

## Performance Optimization

### 1. React.memo

```jsx
import { memo } from 'react';

// Prevents re-render if props haven't changed
const ExpensiveComponent = memo(({ data }) => {
  console.log('Rendering ExpensiveComponent');
  return <div>{data}</div>;
});

// Custom comparison
const UserCard = memo(
  ({ user }) => <div>{user.name}</div>,
  (prevProps, nextProps) => prevProps.user.id === nextProps.user.id
);
```

### 2. useMemo

```jsx
import { useMemo } from 'react';

function ProductList({ products, category }) {
  // Memoize expensive computation
  const filtered = useMemo(() => {
    console.log('Filtering products...');
    return products.filter(p => p.category === category);
  }, [products, category]); // Only recompute when these change

  return <List items={filtered} />;
}
```

### 3. useCallback

```jsx
import { useCallback } from 'react';

function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ New function on every render
  const handleClick = () => {
    console.log('Clicked');
  };
  
  // ✅ Memoized function
  const handleClick = useCallback(() => {
    console.log('Clicked');
  }, []); // Dependencies
  
  return <Child onClick={handleClick} />;
}
```

### 4. Code Splitting

```jsx
import { lazy, Suspense } from 'react';

// Lazy load components
const Dashboard = lazy(() => import('./Dashboard'));
const Settings = lazy(() => import('./Settings'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Dashboard />
    </Suspense>
  );
}
```

### 5. Virtualization

```jsx
import { FixedSizeList } from 'react-window';

function LargeList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>{items[index].name}</div>
      )}
    </FixedSizeList>
  );
}
```

---

## Hooks Best Practices

### Rules of Hooks

```jsx
// ✅ Call hooks at top level
function Component() {
  const [state, setState] = useState(0);
  useEffect(() => {}, []);
  
  return <div>{state}</div>;
}

// ❌ Don't call hooks conditionally
function Component({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // Wrong!
  }
}

// ❌ Don't call hooks in loops
function Component({ items }) {
  items.forEach(item => {
    const [state, setState] = useState(0); // Wrong!
  });
}
```

### Custom Hooks

```jsx
// Extract reusable logic
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// Usage
function App() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  return <button onClick={() => setTheme('dark')}>{theme}</button>;
}
```

### Dependencies in useEffect

```jsx
// ✅ Include all dependencies
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]); // userId is dependency
}

// ❌ Missing dependencies
useEffect(() => {
  fetchUser(userId).then(setUser);
}, []); // Warning: userId not in dependencies
```

---

## Error Handling

### 1. Error Boundaries

```jsx
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 2. Try-Catch for Async

```jsx
function DataFetcher() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('/api/data');
      const json = await response.json();
      setData(json);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, []);

  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  return <DataDisplay data={data} />;
}
```

---

## Accessibility (a11y)

### 1. Semantic HTML

```jsx
// ✅ Semantic
<nav>
  <ul>
    <li><a href="/home">Home</a></li>
  </ul>
</nav>

// ❌ Non-semantic
<div className="nav">
  <div onClick={goHome}>Home</div>
</div>
```

### 2. ARIA Attributes

```jsx
function Modal({ isOpen, title, children, onClose }) {
  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
      hidden={!isOpen}
    >
      <h2 id="modal-title">{title}</h2>
      <div>{children}</div>
      <button onClick={onClose} aria-label="Close modal">
        ×
      </button>
    </div>
  );
}
```

### 3. Keyboard Navigation

```jsx
function Dropdown({ items }) {
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      toggleDropdown();
    }
    if (e.key === 'Escape') {
      closeDropdown();
    }
  };

  return (
    <button
      onClick={toggleDropdown}
      onKeyDown={handleKeyDown}
      aria-expanded={isOpen}
      aria-haspopup="true"
    >
      Menu
    </button>
  );
}
```

### 4. Form Labels

```jsx
// ✅ Accessible
<label htmlFor="email">Email</label>
<input id="email" type="email" />

// ❌ Not accessible
<span>Email</span>
<input type="email" />
```

---

## Security Best Practices

### 1. Avoid Dangerously Set HTML

```jsx
// ❌ XSS vulnerability
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// ✅ Safe
<div>{userInput}</div>

// ✅ If HTML is needed, sanitize first
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{ 
  __html: DOMPurify.sanitize(userInput) 
}} />
```

### 2. Validate User Input

```jsx
function SearchForm() {
  const [query, setQuery] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    
    // Validate input
    if (!query.trim()) return;
    if (query.length > 100) {
      alert('Query too long');
      return;
    }
    
    // Sanitize before sending
    const sanitized = query.trim();
    searchAPI(sanitized);
  };
}
```

### 3. Secure API Calls

```jsx
// ✅ Use environment variables for sensitive data
const API_KEY = process.env.REACT_APP_API_KEY;

// ❌ Never hardcode secrets
const API_KEY = 'sk-1234567890abcdef'; // Wrong!

// ✅ Send tokens in headers, not URLs
fetch('/api/data', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

---

## Testing Best Practices

### 1. Unit Testing Components

```jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('button click increments counter', async () => {
  render(<Counter />);
  
  const button = screen.getByRole('button');
  await userEvent.click(button);
  
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

### 2. Test User Interactions

```jsx
test('form submission', async () => {
  const handleSubmit = jest.fn();
  render(<LoginForm onSubmit={handleSubmit} />);
  
  await userEvent.type(screen.getByLabelText('Email'), 'test@example.com');
  await userEvent.type(screen.getByLabelText('Password'), 'password123');
  await userEvent.click(screen.getByRole('button', { name: 'Login' }));
  
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});
```

---

## Common Pitfalls to Avoid

### 1. Mutating State

```jsx
// ❌ Direct mutation
state.items.push(newItem);
setState(state);

// ✅ Immutable update
setState({ items: [...state.items, newItem] });
```

### 2. Missing Keys in Lists

```jsx
// ❌ No key or index as key
{items.map((item, i) => <Item key={i} {...item} />)}

// ✅ Unique, stable key
{items.map(item => <Item key={item.id} {...item} />)}
```

### 3. Inline Function Definitions

```jsx
// ❌ New function on every render
<Child onClick={() => console.log('click')} />

// ✅ Memoized or defined outside
const handleClick = useCallback(() => console.log('click'), []);
<Child onClick={handleClick} />
```

### 4. Unnecessary Re-renders

```jsx
// ❌ Always creates new object
<Child config={{ theme: 'dark' }} />

// ✅ Memoize object
const config = useMemo(() => ({ theme: 'dark' }), []);
<Child config={config} />
```

---

## Summary Checklist

**Code Quality**
- [ ] Components are small and focused
- [ ] Descriptive naming conventions
- [ ] Proper folder structure
- [ ] Consistent code formatting

**Performance**
- [ ] Use React.memo for expensive components
- [ ] Memoize expensive computations with useMemo
- [ ] Use useCallback for event handlers in optimized components
- [ ] Implement code splitting for large bundles
- [ ] Virtualize long lists

**State Management**
- [ ] Minimize state (derive when possible)
- [ ] Lift state to appropriate level
- [ ] Use functional updates for state based on previous state
- [ ] Colocate state with components that use it

**Hooks**
- [ ] Follow Rules of Hooks (top level, not in conditions)
- [ ] Include all dependencies in useEffect
- [ ] Extract reusable logic into custom hooks
- [ ] Clean up effects when needed

**Accessibility**
- [ ] Use semantic HTML
- [ ] Provide ARIA attributes when needed
- [ ] Ensure keyboard navigation
- [ ] Add labels to form inputs

**Security**
- [ ] Sanitize user input
- [ ] Avoid dangerouslySetInnerHTML
- [ ] Use environment variables for secrets
- [ ] Validate all inputs

**Testing**
- [ ] Write tests for critical functionality
- [ ] Test user interactions
- [ ] Use React Testing Library
- [ ] Maintain good test coverage

---

## Summary

- **Keep components small**, focused, and reusable
- **Organize code** with clear folder structure
- **Follow naming conventions**: PascalCase for components, camelCase for functions
- **Optimize performance** with memo, useMemo, useCallback
- **Manage state efficiently**: minimize, colocate, use functional updates
- **Follow Rules of Hooks** and include all dependencies
- **Ensure accessibility** with semantic HTML and ARIA
- **Handle errors** with boundaries and try-catch
- **Test components** thoroughly
- **Avoid common pitfalls**: state mutation, missing keys, inline functions
