# Lifecycle Methods

## Component Lifecycle Overview

React components go through three phases:
1. **Mounting**: Component is created and inserted into the DOM
2. **Updating**: Component re-renders due to changes in props or state
3. **Unmounting**: Component is removed from the DOM

---

## Lifecycle in Functional Components (Hooks)

Modern React uses **hooks** to handle lifecycle in functional components.

### useEffect Hook

The `useEffect` hook handles side effects and replaces most lifecycle methods.

#### Basic Syntax
```jsx
import { useEffect } from 'react';

useEffect(() => {
  // Effect code runs here
  
  return () => {
    // Cleanup code (optional)
  };
}, [dependencies]);
```

---

## Mounting Phase

### ComponentDidMount Equivalent

Runs **once** after component mounts (empty dependency array).

```jsx
import { useEffect, useState } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Runs once after mount
    console.log('Component mounted');
    fetchUser(userId).then(data => setUser(data));
  }, []); // Empty array = mount only

  return <div>{user?.name}</div>;
}
```

**Use Cases**:
- Fetch initial data
- Set up subscriptions
- Initialize third-party libraries
- Add event listeners

---

## Updating Phase

### ComponentDidUpdate Equivalent

Runs when **dependencies change**.

```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // Runs when userId changes
    console.log('userId changed:', userId);
    fetchUser(userId).then(data => setUser(data));
  }, [userId]); // Runs when userId changes

  return <div>{user?.name}</div>;
}
```

**Use Cases**:
- Fetch data when props change
- Update DOM based on state
- Sync with external systems

### Multiple Dependencies

```jsx
function SearchResults({ query, filters, sortBy }) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    // Runs when any dependency changes
    fetchResults(query, filters, sortBy)
      .then(data => setResults(data));
  }, [query, filters, sortBy]);

  return <ResultsList results={results} />;
}
```

---

## Unmounting Phase

### ComponentWillUnmount Equivalent

Return a **cleanup function** from useEffect.

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    // Setup
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);

    // Cleanup (runs before unmount)
    return () => {
      console.log('Cleaning up timer');
      clearInterval(interval);
    };
  }, []);

  return <div>Seconds: {seconds}</div>;
}
```

**Use Cases**:
- Clear timers/intervals
- Cancel network requests
- Remove event listeners
- Unsubscribe from services

---

## Common useEffect Patterns

### 1. Run on Every Render

```jsx
useEffect(() => {
  console.log('Runs after every render');
  // No dependencies array
});
```

### 2. Run Once on Mount

```jsx
useEffect(() => {
  console.log('Runs once on mount');
}, []);
```

### 3. Run When Dependencies Change

```jsx
useEffect(() => {
  console.log('Runs when count changes');
}, [count]);
```

### 4. Cleanup on Unmount

```jsx
useEffect(() => {
  return () => {
    console.log('Cleanup on unmount');
  };
}, []);
```

### 5. Cleanup on Dependency Change

```jsx
useEffect(() => {
  const subscription = subscribe(userId);
  
  return () => {
    subscription.unsubscribe();
  };
}, [userId]); // Cleanup runs before next effect
```

---

## Real-World Examples

### Fetching Data

```jsx
function Posts() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true; // Prevent state update if unmounted

    setLoading(true);
    fetch('https://api.example.com/posts')
      .then(res => res.json())
      .then(data => {
        if (isMounted) {
          setPosts(data);
          setLoading(false);
        }
      })
      .catch(err => {
        if (isMounted) {
          setError(err.message);
          setLoading(false);
        }
      });

    return () => {
      isMounted = false; // Cleanup flag
    };
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <PostList posts={posts} />;
}
```

### Event Listeners

```jsx
function WindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };

    // Add listener
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div>{size.width} x {size.height}</div>;
}
```

### Document Title

```jsx
function PageTitle({ title, count }) {
  useEffect(() => {
    document.title = `${title} (${count})`;
  }, [title, count]);

  return <h1>{title}</h1>;
}
```

### WebSocket Connection

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const socket = new WebSocket(`ws://chat.example.com/${roomId}`);

    socket.onmessage = (event) => {
      setMessages(prev => [...prev, event.data]);
    };

    return () => {
      socket.close();
    };
  }, [roomId]); // Reconnect when roomId changes

  return <MessageList messages={messages} />;
}
```

### Local Storage Sync

```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// Usage
function Settings() {
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Toggle Theme: {theme}
    </button>
  );
}
```

---

## Class Component Lifecycle Methods

### Mounting

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { data: null };
    console.log('1. Constructor');
  }

  static getDerivedStateFromProps(props, state) {
    console.log('2. getDerivedStateFromProps');
    return null; // or new state
  }

  componentDidMount() {
    console.log('3. componentDidMount');
    // Fetch data, add listeners, etc.
  }

  render() {
    console.log('Render');
    return <div>{this.state.data}</div>;
  }
}
```

### Updating

```jsx
class MyComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    // Return false to prevent re-render
    return nextProps.id !== this.props.id;
  }

  componentDidUpdate(prevProps, prevState) {
    // Called after update
    if (prevProps.id !== this.props.id) {
      this.fetchData(this.props.id);
    }
  }

  render() {
    return <div>{this.props.data}</div>;
  }
}
```

### Unmounting

```jsx
class MyComponent extends React.Component {
  componentWillUnmount() {
    // Cleanup: remove listeners, cancel requests, etc.
    clearInterval(this.timerID);
  }

  render() {
    return <div>Component</div>;
  }
}
```

### Error Handling

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

---

## Lifecycle Method vs Hook Comparison

| Class Method | Hook Equivalent |
|--------------|----------------|
| `constructor` | `useState` initialization |
| `componentDidMount` | `useEffect(() => {}, [])` |
| `componentDidUpdate` | `useEffect(() => {}, [deps])` |
| `componentWillUnmount` | `useEffect(() => { return cleanup }, [])` |
| `shouldComponentUpdate` | `React.memo()` |
| `getDerivedStateFromProps` | Update state in render or `useState` with props |
| `componentDidCatch` | No hook equivalent (use class) |

---

## Common Mistakes & Solutions

### 1. Missing Dependencies

```jsx
// ❌ Wrong: Missing dependency
function BadExample({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, []); // userId is missing!
}

// ✅ Correct: Include all dependencies
function GoodExample({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
}
```

### 2. Infinite Loop

```jsx
// ❌ Wrong: Infinite loop
function BadExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1); // Triggers re-render
  }, [count]); // Effect runs again
}

// ✅ Correct: Proper condition
function GoodExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    if (count < 10) {
      setCount(count + 1);
    }
  }, [count]);
}
```

### 3. Not Cleaning Up

```jsx
// ❌ Wrong: Memory leak
function BadExample() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Tick');
    }, 1000);
    // No cleanup!
  }, []);
}

// ✅ Correct: Cleanup
function GoodExample() {
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Tick');
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
}
```

### 4. Stale Closure

```jsx
// ❌ Wrong: Stale count value
function BadExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setInterval(() => {
      setCount(count + 1); // Always uses initial count (0)
    }, 1000);
  }, []);
}

// ✅ Correct: Functional update
function GoodExample() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(c => c + 1); // Uses latest count
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
}
```

---

## Interview Questions

### Q1: What is the component lifecycle in React?
**Answer**: Component lifecycle has three phases:
1. **Mounting**: Component is created and added to DOM
2. **Updating**: Component re-renders due to state/props changes
3. **Unmounting**: Component is removed from DOM

In functional components, `useEffect` handles all lifecycle logic.

### Q2: When does useEffect run?
**Answer**: Depends on the dependency array:
- **No array**: Runs after every render
- **Empty array `[]`**: Runs once on mount
- **With dependencies `[dep]`**: Runs on mount and when dependencies change

### Q3: What is cleanup in useEffect?
**Answer**: Cleanup is a function returned from useEffect that runs:
- Before the component unmounts
- Before re-running the effect (if dependencies changed)

Used to clear timers, remove listeners, cancel requests, etc.

```jsx
useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer); // Cleanup
}, []);
```

### Q4: How do you prevent infinite loops in useEffect?
**Answer**: 
- Include all dependencies in the array
- Don't update state that's in dependencies without conditions
- Use functional state updates for counters
- Separate effects with different dependencies

### Q5: What is the equivalent of componentDidMount in hooks?
**Answer**: `useEffect` with empty dependency array:

```jsx
useEffect(() => {
  // Runs once after mount
}, []);
```

### Q6: Can you use multiple useEffect hooks?
**Answer**: Yes! It's recommended to separate concerns:

```jsx
function Component() {
  // Effect 1: Fetch data
  useEffect(() => {
    fetchData();
  }, []);

  // Effect 2: Update title
  useEffect(() => {
    document.title = title;
  }, [title]);

  // Effect 3: Handle resize
  useEffect(() => {
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
}
```

### Q7: Why is the dependency array important?
**Answer**: The dependency array:
- Controls when effects run
- Prevents unnecessary executions
- Avoids infinite loops
- Ensures effects use latest values
- Optimizes performance

Omitting dependencies can cause bugs (stale values) or performance issues.

---

## Best Practices

1. **Always specify dependencies** - use ESLint plugin to catch missing deps
2. **Separate concerns** - use multiple useEffect for different logic
3. **Clean up side effects** - return cleanup function when needed
4. **Use functional updates** to avoid stale closures
5. **Handle loading/error states** in data fetching
6. **Prevent updates on unmounted components** with cleanup flags
7. **Avoid objects/arrays as dependencies** - they create new references
8. **Keep effects focused** - one responsibility per effect
9. **Use custom hooks** to extract reusable lifecycle logic
10. **Consider useLayoutEffect** for DOM measurements (rare cases)

---

## Summary

- React components have **three lifecycle phases**: mounting, updating, unmounting
- **useEffect** is the primary hook for handling side effects in functional components
- Empty dependency array `[]` runs effect **once on mount**
- Dependencies array `[dep]` runs effect when **dependencies change**
- **Cleanup functions** prevent memory leaks and clean up resources
- **Always include all dependencies** to avoid bugs
- Use **multiple useEffect hooks** to separate concerns
- Functional components with hooks are **preferred** over class lifecycle methods
