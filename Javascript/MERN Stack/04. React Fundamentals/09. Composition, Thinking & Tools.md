# Composition, Thinking & Tools

## Component Composition

Composition is building complex UIs by combining simple, focused components.

### Composition vs Inheritance

React recommends **composition over inheritance** for code reuse.

```jsx
// ✅ Good: Composition
function Dialog({ title, children }) {
  return (
    <div className="dialog">
      <h1>{title}</h1>
      <div className="content">{children}</div>
    </div>
  );
}

function WelcomeDialog() {
  return (
    <Dialog title="Welcome">
      <p>Thank you for visiting!</p>
    </Dialog>
  );
}

// ❌ Avoid: Inheritance (not the React way)
class BaseDialog extends Component { ... }
class WelcomeDialog extends BaseDialog { ... }
```

---

## Containment

Components that don't know their children ahead of time use `children` prop.

### Basic Containment

```jsx
function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

// Usage
<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>
```

### Multiple Slots

```jsx
function Layout({ header, sidebar, content, footer }) {
  return (
    <div className="layout">
      <header>{header}</header>
      <div className="main">
        <aside>{sidebar}</aside>
        <main>{content}</main>
      </div>
      <footer>{footer}</footer>
    </div>
  );
}

// Usage
<Layout
  header={<Header />}
  sidebar={<Sidebar />}
  content={<MainContent />}
  footer={<Footer />}
/>
```

---

## Specialization

Create specific versions of generic components.

```jsx
// Generic component
function Dialog({ title, message, type }) {
  const className = `dialog dialog-${type}`;
  
  return (
    <div className={className}>
      <h1>{title}</h1>
      <p>{message}</p>
    </div>
  );
}

// Specialized components
function ErrorDialog({ message }) {
  return (
    <Dialog
      title="Error"
      message={message}
      type="error"
    />
  );
}

function SuccessDialog({ message }) {
  return (
    <Dialog
      title="Success"
      message={message}
      type="success"
    />
  );
}
```

---

## Compound Components

Components that work together as a unit.

```jsx
function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <div className="tabs">
      {React.Children.map(children, (child, index) =>
        React.cloneElement(child, {
          isActive: index === activeTab,
          onActivate: () => setActiveTab(index)
        })
      )}
    </div>
  );
}

function Tab({ label, children, isActive, onActivate }) {
  return (
    <div className={`tab ${isActive ? 'active' : ''}`}>
      <button onClick={onActivate}>{label}</button>
      {isActive && <div className="content">{children}</div>}
    </div>
  );
}

// Usage
<Tabs>
  <Tab label="Profile">Profile content</Tab>
  <Tab label="Settings">Settings content</Tab>
  <Tab label="Notifications">Notifications content</Tab>
</Tabs>
```

---

## Render Props Pattern

Share code between components using a prop whose value is a function.

```jsx
function Mouse({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMove);
    return () => window.removeEventListener('mousemove', handleMove);
  }, []);

  return render(position);
}

// Usage
<Mouse render={({ x, y }) => (
  <h1>Mouse position: {x}, {y}</h1>
)} />
```

---

## Thinking in React

### Step 1: Break UI into Component Hierarchy

```
ProductTable
├── SearchBar
└── ProductList
    └── ProductRow
```

### Step 2: Build Static Version

```jsx
function ProductTable({ products }) {
  return (
    <div>
      <SearchBar />
      <ProductList products={products} />
    </div>
  );
}

function SearchBar() {
  return (
    <input type="text" placeholder="Search..." />
  );
}

function ProductList({ products }) {
  return (
    <ul>
      {products.map(product => (
        <ProductRow key={product.id} product={product} />
      ))}
    </ul>
  );
}

function ProductRow({ product }) {
  return <li>{product.name} - ${product.price}</li>;
}
```

### Step 3: Identify Minimal State

Ask for each piece of data:
1. Does it change over time? If not, it's not state
2. Is it passed from parent via props? If yes, it's not state
3. Can you compute it from existing state/props? If yes, it's not state

```jsx
// State: search query, filtered results
const [searchQuery, setSearchQuery] = useState('');

// Not state: original products (passed as props)
// Not state: filtered products (computed from state + props)
const filteredProducts = products.filter(p =>
  p.name.toLowerCase().includes(searchQuery.toLowerCase())
);
```

### Step 4: Identify Where State Should Live

Find the common owner component of all components that need the state.

```jsx
function ProductTable({ products }) {
  // State lives here (common parent)
  const [searchQuery, setSearchQuery] = useState('');

  const filteredProducts = products.filter(p =>
    p.name.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <div>
      <SearchBar value={searchQuery} onChange={setSearchQuery} />
      <ProductList products={filteredProducts} />
    </div>
  );
}
```

### Step 5: Add Inverse Data Flow

```jsx
function SearchBar({ value, onChange }) {
  return (
    <input
      type="text"
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

---

## React Developer Tools

### Browser Extension

Install React DevTools for Chrome/Firefox:
- Inspect component hierarchy
- View props and state
- Track component updates
- Profile performance
- Debug hooks

### Features

#### 1. Components Tab
```
<App>
  └── <UserList>
      └── <UserCard> props: { name: "Alice", age: 25 }
```

#### 2. Profiler Tab
- Measure rendering performance
- Identify slow components
- Track why components re-render
- Record interaction timings

#### 3. Settings
- Highlight updates
- Show component names
- Filter components
- Trace updates source

---

## VS Code Extensions

### 1. ES7+ React/Redux/React-Native snippets

Quick snippets:
- `rafce` → React Arrow Function Component Export
- `rfc` → React Function Component
- `useS` → useState hook
- `useE` → useEffect hook

### 2. Simple React Snippets

Additional snippets:
- `imr` → import React
- `imrs` → import React, { useState }
- `imrc` → import React, { Component }

### 3. React Developer Tools

Integrated DevTools in VS Code.

### 4. ESLint

Catch errors and enforce best practices:
```json
{
  "extends": [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ]
}
```

### 5. Prettier

Code formatting:
```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

---

## Debugging Techniques

### 1. Console Logging

```jsx
function Component({ user }) {
  console.log('Rendering with user:', user);
  console.log('Props:', { user });
  
  useEffect(() => {
    console.log('Effect ran');
  }, []);

  return <div>{user.name}</div>;
}
```

### 2. React DevTools

- Inspect props/state in Components tab
- Track re-renders with "Highlight updates"
- Profile performance issues
- Debug hooks state

### 3. Debugger Statement

```jsx
function Component() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    debugger; // Pauses execution
    setCount(count + 1);
  };

  return <button onClick={handleClick}>{count}</button>;
}
```

### 4. Error Boundaries

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught:', error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>Something went wrong.</h1>
          <details>
            <summary>Error details</summary>
            <pre>{this.state.error.toString()}</pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 5. React Strict Mode

Detect potential problems in development:

```jsx
import { StrictMode } from 'react';

<StrictMode>
  <App />
</StrictMode>
```

Helps identify:
- Unsafe lifecycle methods
- Legacy string ref usage
- Unexpected side effects
- Deprecated APIs

### 6. Why Did You Render

Track unnecessary re-renders:

```bash
npm install @welldone-software/why-did-you-render
```

```jsx
import whyDidYouRender from '@welldone-software/why-did-you-render';

if (process.env.NODE_ENV === 'development') {
  whyDidYouRender(React, {
    trackAllPureComponents: true,
  });
}
```

---

## Performance Tools

### React Profiler API

```jsx
import { Profiler } from 'react';

function onRenderCallback(
  id, // Component that was rendered
  phase, // "mount" or "update"
  actualDuration, // Time spent rendering
  baseDuration, // Estimated time without memoization
  startTime, // When React began rendering
  commitTime, // When React committed update
  interactions // Set of interactions belonging to this update
) {
  console.log(`${id} took ${actualDuration}ms to render`);
}

<Profiler id="App" onRender={onRenderCallback}>
  <App />
</Profiler>
```

### React DevTools Profiler

1. Open React DevTools
2. Switch to Profiler tab
3. Click record
4. Interact with app
5. Stop recording
6. Analyze flame graph

---

## Component Design Principles

### 1. Single Responsibility

Each component should do one thing well.

```jsx
// ❌ Bad: Multiple responsibilities
function UserDashboard() {
  // Fetching data
  // Filtering data
  // Rendering multiple sections
  // Handling forms
}

// ✅ Good: Single responsibility
function UserDashboard() {
  return (
    <>
      <UserProfile />
      <UserStats />
      <UserSettings />
    </>
  );
}
```

### 2. DRY (Don't Repeat Yourself)

```jsx
// ❌ Bad: Repetition
<button className="btn btn-primary">Save</button>
<button className="btn btn-primary">Submit</button>
<button className="btn btn-primary">Continue</button>

// ✅ Good: Reusable component
function Button({ children, onClick }) {
  return (
    <button className="btn btn-primary" onClick={onClick}>
      {children}
    </button>
  );
}

<Button onClick={handleSave}>Save</Button>
<Button onClick={handleSubmit}>Submit</Button>
```

### 3. Prop Drilling vs Context

```jsx
// ❌ Prop drilling (passing through many levels)
<A user={user}>
  <B user={user}>
    <C user={user}>
      <D user={user} />
    </C>
  </B>
</A>

// ✅ Context API
const UserContext = createContext();

function App() {
  const user = { name: 'Alice' };
  return (
    <UserContext.Provider value={user}>
      <A />
    </UserContext.Provider>
  );
}

function D() {
  const user = useContext(UserContext);
  return <div>{user.name}</div>;
}
```

---

## Interview Questions

### Q1: What is component composition?
**Answer**: Component composition is building complex UIs by combining simple, reusable components rather than using inheritance. React favors composition over inheritance for code reuse.

Benefits:
- Better reusability
- Easier to understand
- More flexible
- Follows React principles

### Q2: What is the children prop?
**Answer**: The `children` prop is a special prop that contains the content between component tags. Used for composition and creating wrapper components.

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

<Card><p>Content</p></Card>
```

### Q3: What are render props?
**Answer**: Render props is a pattern where a component receives a function as a prop that returns a React element. Used to share stateful logic between components.

```jsx
<DataFetcher render={data => <Display data={data} />} />
```

Modern alternative: custom hooks.

### Q4: How do you debug React applications?
**Answer**: Multiple approaches:
1. **React DevTools**: Inspect components, props, state
2. **Console.log**: Log props, state, renders
3. **Debugger**: Set breakpoints with `debugger`
4. **Error Boundaries**: Catch and display errors
5. **Profiler**: Measure performance
6. **Strict Mode**: Detect problems in development

### Q5: What is the "Thinking in React" approach?
**Answer**: Step-by-step methodology:
1. Break UI into component hierarchy
2. Build static version (no state)
3. Identify minimal state representation
4. Determine where state should live
5. Add inverse data flow (callbacks)

### Q6: What are compound components?
**Answer**: Compound components are components designed to work together as a cohesive unit. They share implicit state and work together to provide complete functionality.

Example: `<Tabs>` and `<Tab>`, `<Select>` and `<Option>`

### Q7: When should you use Context vs Props?
**Answer**:
- **Props**: Default choice, explicit data flow, nearby components
- **Context**: Avoid prop drilling, global data (theme, auth, language), deeply nested components

Don't overuse Context – it can make components less reusable.

---

## Best Practices

1. **Favor composition** over inheritance
2. **Keep components small** and focused
3. **Use descriptive names** for components and props
4. **Extract reusable logic** into custom hooks
5. **Avoid prop drilling** with Context when appropriate
6. **Use React DevTools** for debugging and profiling
7. **Think in components** – break down UI systematically
8. **Follow single responsibility** principle
9. **Document complex components** with PropTypes or TypeScript
10. **Profile performance** regularly during development

---

## Summary

- **Composition** is preferred over inheritance in React
- Use **children prop** for flexible component APIs
- **Render props** share logic (now mostly replaced by hooks)
- **Think in React**: break down UI → identify state → determine data flow
- **React DevTools** essential for debugging and performance analysis
- Design components following **single responsibility** principle
- Use **Context API** to avoid excessive prop drilling
- **Error Boundaries** catch errors in component trees
- **Profile and debug** with built-in React tools
- Keep components **small, focused, and reusable**
