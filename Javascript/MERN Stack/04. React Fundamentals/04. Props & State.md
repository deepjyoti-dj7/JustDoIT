# Props & State

## Props (Properties)

Props are **read-only inputs** passed from parent to child components. They enable component reusability and data flow.

### Basic Props Usage

```jsx
// Parent component
function App() {
  return (
    <Welcome 
      name="Alice" 
      age={25} 
      isStudent={true} 
    />
  );
}

// Child component
function Welcome(props) {
  return (
    <div>
      <h1>Hello, {props.name}!</h1>
      <p>Age: {props.age}</p>
      <p>Student: {props.isStudent ? 'Yes' : 'No'}</p>
    </div>
  );
}
```

### Props Destructuring

```jsx
// Cleaner syntax
function Welcome({ name, age, isStudent }) {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Age: {age}</p>
      <p>Student: {isStudent ? 'Yes' : 'No'}</p>
    </div>
  );
}
```

### Props with Default Values

```jsx
function Button({ label = 'Click Me', variant = 'primary', disabled = false }) {
  return (
    <button className={`btn-${variant}`} disabled={disabled}>
      {label}
    </button>
  );
}

// Usage
<Button />  // Uses all defaults
<Button label="Submit" variant="success" />
```

---

## Types of Props

### 1. String Props
```jsx
<UserCard name="Alice" role="Admin" />
```

### 2. Number Props
```jsx
<Counter initialCount={10} step={5} />
```

### 3. Boolean Props
```jsx
<Modal isOpen={true} closable={false} />
// Shorthand for true
<Modal isOpen closable />
```

### 4. Array Props
```jsx
<TodoList items={['Task 1', 'Task 2', 'Task 3']} />
```

### 5. Object Props
```jsx
<UserProfile user={{ name: 'Alice', email: 'alice@example.com' }} />
```

### 6. Function Props (Callbacks)
```jsx
function Parent() {
  const handleClick = (message) => {
    console.log(message);
  };

  return <Child onClick={handleClick} />;
}

function Child({ onClick }) {
  return <button onClick={() => onClick('Button clicked!')}>Click</button>;
}
```

### 7. Children Props
```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

// Usage
<Card>
  <h2>Title</h2>
  <p>Content goes here</p>
</Card>
```

---

## Props Validation (PropTypes)

```jsx
import PropTypes from 'prop-types';

function UserCard({ name, age, email, isActive }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

UserCard.propTypes = {
  name: PropTypes.string.isRequired,
  age: PropTypes.number.isRequired,
  email: PropTypes.string,
  isActive: PropTypes.bool
};

UserCard.defaultProps = {
  isActive: false
};
```

---

## State

State is **mutable data** managed internally by a component. When state changes, the component re-renders.

### useState Hook (Functional Components)

```jsx
import { useState } from 'react';

function Counter() {
  // [stateVariable, setterFunction] = useState(initialValue)
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

### Multiple State Variables

```jsx
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    try {
      await login(email, password);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
      />
      <input 
        type="password"
        value={password} 
        onChange={(e) => setPassword(e.target.value)} 
      />
      {error && <p className="error">{error}</p>}
      <button disabled={isLoading}>
        {isLoading ? 'Loading...' : 'Login'}
      </button>
    </form>
  );
}
```

### Object State

```jsx
function UserProfile() {
  const [user, setUser] = useState({
    name: '',
    email: '',
    age: 0
  });

  // Update single property (spread operator)
  const updateName = (name) => {
    setUser({ ...user, name });
  };

  // Better: functional update
  const updateEmail = (email) => {
    setUser(prevUser => ({ ...prevUser, email }));
  };

  return (
    <div>
      <input 
        value={user.name}
        onChange={(e) => updateName(e.target.value)}
        placeholder="Name"
      />
      <input 
        value={user.email}
        onChange={(e) => updateEmail(e.target.value)}
        placeholder="Email"
      />
    </div>
  );
}
```

### Array State

```jsx
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');

  // Add item
  const addTodo = () => {
    setTodos([...todos, { id: Date.now(), text: input, done: false }]);
    setInput('');
  };

  // Remove item
  const removeTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  // Toggle item
  const toggleTodo = (id) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };

  return (
    <div>
      <input 
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <span 
              style={{ textDecoration: todo.done ? 'line-through' : 'none' }}
              onClick={() => toggleTodo(todo.id)}
            >
              {todo.text}
            </span>
            <button onClick={() => removeTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## State in Class Components

```jsx
import { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  // Functional setState (safer for async updates)
  decrement = () => {
    this.setState(prevState => ({
      count: prevState.count - 1
    }));
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>+</button>
        <button onClick={this.decrement}>-</button>
      </div>
    );
  }
}
```

---

## Props vs State

| Aspect | Props | State |
|--------|-------|-------|
| **Definition** | Data passed from parent | Data managed internally |
| **Mutability** | Immutable (read-only) | Mutable |
| **Who controls** | Parent component | Component itself |
| **Changes trigger** | Parent re-render | Component re-render |
| **Purpose** | Configuration & data flow | Dynamic, interactive data |
| **Access** | `props.name` or `{name}` | `state.name` or `[name, setName]` |

```jsx
// Props example
function Child({ message }) {  // ❌ Cannot modify message
  return <p>{message}</p>;
}

// State example
function Parent() {
  const [message, setMessage] = useState('Hello');  // ✅ Can modify
  return <Child message={message} />;
}
```

---

## State Immutability

**Never mutate state directly!** Always create new objects/arrays.

### ❌ Wrong (Mutation)
```jsx
// Objects
const updateUser = () => {
  user.name = 'Bob';  // ❌ Direct mutation
  setUser(user);
};

// Arrays
const addItem = () => {
  items.push('new item');  // ❌ Direct mutation
  setItems(items);
};
```

### ✅ Correct (Immutable)
```jsx
// Objects
const updateUser = () => {
  setUser({ ...user, name: 'Bob' });  // ✅ New object
};

// Arrays
const addItem = () => {
  setItems([...items, 'new item']);  // ✅ New array
};
```

### Why Immutability Matters
- React compares references to detect changes
- Direct mutation doesn't trigger re-renders
- Immutability enables time-travel debugging
- Prevents unexpected side effects

---

## Lifting State Up

When multiple components need to share state, lift it to their common parent.

```jsx
// ❌ State in both children (out of sync)
function TemperatureInput() {
  const [temp, setTemp] = useState(0);
  return <input value={temp} onChange={e => setTemp(e.target.value)} />;
}

// ✅ State lifted to parent (shared)
function Parent() {
  const [temp, setTemp] = useState(0);

  return (
    <div>
      <CelsiusInput temp={temp} onChange={setTemp} />
      <FahrenheitInput temp={temp} onChange={setTemp} />
    </div>
  );
}

function CelsiusInput({ temp, onChange }) {
  return (
    <input 
      value={temp} 
      onChange={(e) => onChange(e.target.value)} 
    />
  );
}
```

---

## Derived State

Compute values from props/state instead of storing them.

```jsx
// ❌ Storing derived state
function CartTotal({ items }) {
  const [total, setTotal] = useState(0);
  
  useEffect(() => {
    setTotal(items.reduce((sum, item) => sum + item.price, 0));
  }, [items]);
  
  return <p>Total: ${total}</p>;
}

// ✅ Computing derived value
function CartTotal({ items }) {
  const total = items.reduce((sum, item) => sum + item.price, 0);
  return <p>Total: ${total}</p>;
}
```

---

## Lazy State Initialization

For expensive initial state calculations:

```jsx
// ❌ Runs on every render
function Component() {
  const [state, setState] = useState(expensiveComputation());
}

// ✅ Runs only once
function Component() {
  const [state, setState] = useState(() => expensiveComputation());
}
```

---

## Interview Questions

### Q1: What is the difference between props and state?
**Answer**:
- **Props**: Read-only data passed from parent to child, controlled by parent, immutable
- **State**: Internal mutable data managed by component, can be updated, triggers re-renders

Example: A button's label is a prop (set by parent), but whether it's pressed is state (managed by button).

### Q2: Can you modify props inside a component?
**Answer**: No. Props are read-only. Attempting to modify props violates React's unidirectional data flow and can cause bugs. If you need to modify data, use state or pass a callback function as a prop.

```jsx
// ❌ Wrong
function Child({ value }) {
  value = 'new value';  // Error!
}

// ✅ Correct
function Child({ value, onChange }) {
  <button onClick={() => onChange('new value')}>Change</button>
}
```

### Q3: Why is state immutability important in React?
**Answer**: 
- React uses shallow comparison to detect changes
- Direct mutation doesn't trigger re-renders
- Immutability enables performance optimizations (PureComponent, React.memo)
- Prevents bugs from shared references
- Supports features like undo/redo

### Q4: What is lifting state up?
**Answer**: Moving state to the closest common ancestor when multiple components need to share and synchronize state. The parent manages state and passes it down via props along with update handlers.

Benefits:
- Single source of truth
- Data synchronization
- Easier debugging

### Q5: When should you use props vs state?
**Answer**:
- **Use Props**: Data comes from parent, doesn't change within component, configuration values
- **Use State**: Data changes over time, user interactions, internal component data, async data

### Q6: What is the children prop?
**Answer**: Special prop that passes content between component tags. Used for composition and wrapper components.

```jsx
function Card({ children }) {
  return <div className="card">{children}</div>;
}

<Card>
  <h2>Title</h2>
  <p>Content</p>
</Card>
```

### Q7: How do you update object state in React?
**Answer**: Use the spread operator to create a new object:

```jsx
const [user, setUser] = useState({ name: 'Alice', age: 25 });

// Update single property
setUser({ ...user, age: 26 });

// Functional update (safer for async)
setUser(prev => ({ ...prev, age: 26 }));
```

### Q8: What happens when you call setState?
**Answer**:
1. React schedules a re-render (asynchronous)
2. React batches multiple setState calls for performance
3. Component re-renders with new state
4. Virtual DOM compares and updates real DOM
5. Effects and callbacks run if dependencies changed

---

## Best Practices

1. **Keep state minimal** - derive values when possible
2. **Use functional updates** for state based on previous state
3. **Lift state up** only when necessary
4. **Colocate state** close to where it's used
5. **Never mutate state directly** - use spread operators
6. **Use PropTypes** or TypeScript for type safety
7. **Destructure props** for cleaner code
8. **Initialize state properly** - use lazy initialization for expensive operations
9. **Avoid redundant state** - compute derived values instead

---

## Summary

- **Props** pass data from parent to child (read-only)
- **State** manages internal component data (mutable)
- Always maintain **immutability** when updating state
- **Lift state up** to share data between components
- Use **useState** hook for state in functional components
- Prefer **derived state** over storing computed values
- Props flow down, events flow up (unidirectional data flow)
