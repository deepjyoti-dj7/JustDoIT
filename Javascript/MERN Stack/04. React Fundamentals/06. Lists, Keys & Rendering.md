# Lists, Keys & Rendering

## Rendering Lists

Transform arrays into JSX elements using JavaScript's `.map()` method.

### Basic List Rendering

```jsx
function ShoppingList() {
  const items = ['Milk', 'Bread', 'Eggs', 'Butter'];

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}
```

### Rendering Object Arrays

```jsx
function UserList() {
  const users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
    { id: 3, name: 'Charlie', email: 'charlie@example.com' }
  ];

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>
          <strong>{user.name}</strong> - {user.email}
        </li>
      ))}
    </ul>
  );
}
```

### Component Lists

```jsx
function TodoList({ todos }) {
  return (
    <div className="todo-list">
      {todos.map(todo => (
        <TodoItem 
          key={todo.id}
          id={todo.id}
          text={todo.text}
          completed={todo.completed}
        />
      ))}
    </div>
  );
}

function TodoItem({ id, text, completed }) {
  return (
    <div className={`todo-item ${completed ? 'completed' : ''}`}>
      <span>{text}</span>
    </div>
  );
}
```

---

## Keys in React

Keys help React identify which items have changed, been added, or removed. They give elements a **stable identity**.

### Why Keys Matter

```jsx
// ❌ Without keys - React doesn't know which item changed
{items.map(item => <Item>{item}</Item>)}

// ✅ With keys - React can track each item
{items.map(item => <Item key={item.id}>{item}</Item>)}
```

### Key Requirements

1. **Unique among siblings** (not globally)
2. **Stable** (same key for same item across renders)
3. **Predictable** (not random)

### Good Keys

```jsx
// ✅ Unique ID from data
{users.map(user => <User key={user.id} {...user} />)}

// ✅ Combination of properties
{items.map(item => (
  <Item key={`${item.category}-${item.id}`} {...item} />
))}

// ✅ Email (if unique and stable)
{users.map(user => <User key={user.email} {...user} />)}
```

### Bad Keys

```jsx
// ❌ Index (problematic when list changes)
{items.map((item, index) => <Item key={index} {...item} />)}

// ❌ Random values (changes on every render)
{items.map(item => <Item key={Math.random()} {...item} />)}

// ❌ Non-unique values
{items.map(item => <Item key={item.category} {...item} />)}
```

---

## Index as Key: When and Why

### When Index is OK ✅

```jsx
// Static list (never reordered, added, or removed)
const staticItems = ['About', 'Contact', 'Privacy'];

function Navigation() {
  return (
    <nav>
      {staticItems.map((item, index) => (
        <a key={index} href={`/${item.toLowerCase()}`}>
          {item}
        </a>
      ))}
    </nav>
  );
}
```

### When Index is BAD ❌

```jsx
// Dynamic list (items can be reordered)
function TodoList({ todos, onToggle }) {
  return (
    <ul>
      {todos.map((todo, index) => (
        // ❌ Using index - will cause bugs when sorting/filtering
        <TodoItem 
          key={index}  // Wrong!
          todo={todo}
          onToggle={onToggle}
        />
      ))}
    </ul>
  );
}

// ✅ Correct: Use stable ID
{todos.map(todo => (
  <TodoItem key={todo.id} todo={todo} onToggle={onToggle} />
))}
```

### Problems with Index Keys

```jsx
function ProblematicExample() {
  const [items, setItems] = useState([
    { id: 1, text: 'Apple', input: '' },
    { id: 2, text: 'Banana', input: '' },
    { id: 3, text: 'Cherry', input: '' }
  ]);

  const removeFirst = () => setItems(items.slice(1));

  return (
    <div>
      {/* ❌ Using index as key */}
      {items.map((item, index) => (
        <div key={index}>
          <span>{item.text}</span>
          <input />  {/* Input state will get mismatched! */}
        </div>
      ))}
      <button onClick={removeFirst}>Remove First</button>
    </div>
  );
}
```

**Result**: After removing "Apple", the input for "Banana" will show data from "Cherry"'s input!

---

## Extracting Components with Keys

```jsx
// ❌ Wrong: Key on inner element
function NumberList({ numbers }) {
  return (
    <ul>
      {numbers.map(number => {
        return <ListItem number={number} />;  // Missing key!
      })}
    </ul>
  );
}

function ListItem({ number }) {
  return <li key={number}>{number}</li>;  // Key here is wrong!
}

// ✅ Correct: Key on component in map()
function NumberList({ numbers }) {
  return (
    <ul>
      {numbers.map(number => (
        <ListItem key={number} number={number} />  // Key here!
      ))}
    </ul>
  );
}

function ListItem({ number }) {
  return <li>{number}</li>;  // No key needed
}
```

**Rule**: Keys go on the element in the `.map()` call, not inside the component.

---

## Filtering and Sorting Lists

### Filtering

```jsx
function ProductList({ products, category }) {
  const filteredProducts = products.filter(
    product => product.category === category
  );

  return (
    <div>
      {filteredProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### Sorting

```jsx
function UserList({ users, sortBy }) {
  const sortedUsers = [...users].sort((a, b) => {
    if (sortBy === 'name') {
      return a.name.localeCompare(b.name);
    }
    if (sortBy === 'age') {
      return a.age - b.age;
    }
    return 0;
  });

  return (
    <ul>
      {sortedUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </ul>
  );
}
```

### Filter + Sort

```jsx
function TaskList({ tasks, filter, sortBy }) {
  const processedTasks = tasks
    .filter(task => {
      if (filter === 'active') return !task.completed;
      if (filter === 'completed') return task.completed;
      return true;  // 'all'
    })
    .sort((a, b) => {
      if (sortBy === 'priority') return b.priority - a.priority;
      if (sortBy === 'date') return new Date(b.date) - new Date(a.date);
      return 0;
    });

  return (
    <div>
      {processedTasks.map(task => (
        <TaskItem key={task.id} task={task} />
      ))}
    </div>
  );
}
```

---

## Nested Lists

```jsx
function NestedList({ categories }) {
  return (
    <div>
      {categories.map(category => (
        <div key={category.id}>
          <h3>{category.name}</h3>
          <ul>
            {category.items.map(item => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
}
```

---

## Conditional List Rendering

### Empty State

```jsx
function TaskList({ tasks }) {
  if (tasks.length === 0) {
    return (
      <div className="empty-state">
        <p>No tasks yet. Add one to get started!</p>
      </div>
    );
  }

  return (
    <ul>
      {tasks.map(task => (
        <TaskItem key={task.id} task={task} />
      ))}
    </ul>
  );
}
```

### Inline Empty State

```jsx
function TaskList({ tasks }) {
  return (
    <div>
      {tasks.length === 0 ? (
        <p>No tasks available</p>
      ) : (
        <ul>
          {tasks.map(task => (
            <TaskItem key={task.id} task={task} />
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

## Performance Optimization

### Using React.memo for List Items

```jsx
import { memo } from 'react';

// Prevents re-render if props haven't changed
const TodoItem = memo(({ todo, onToggle, onDelete }) => {
  console.log('Rendering:', todo.text);
  
  return (
    <div className="todo-item">
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </div>
  );
});

function TodoList({ todos, onToggle, onDelete }) {
  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        />
      ))}
    </div>
  );
}
```

### Virtualization for Large Lists

For lists with 1000+ items, use virtualization libraries:

```jsx
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

**Libraries**:
- `react-window` (lightweight)
- `react-virtualized` (feature-rich)

---

## Handling Dynamic Lists

### Adding Items

```jsx
function AddItemExample() {
  const [items, setItems] = useState([
    { id: 1, text: 'Item 1' },
    { id: 2, text: 'Item 2' }
  ]);
  const [input, setInput] = useState('');

  const addItem = () => {
    const newItem = {
      id: Date.now(),  // Simple ID generation
      text: input
    };
    setItems([...items, newItem]);
    setInput('');
  };

  return (
    <div>
      <input value={input} onChange={e => setInput(e.target.value)} />
      <button onClick={addItem}>Add</button>
      <ul>
        {items.map(item => (
          <li key={item.id}>{item.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

### Removing Items

```jsx
function RemoveItemExample() {
  const [items, setItems] = useState([
    { id: 1, text: 'Item 1' },
    { id: 2, text: 'Item 2' },
    { id: 3, text: 'Item 3' }
  ]);

  const removeItem = (id) => {
    setItems(items.filter(item => item.id !== id));
  };

  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {item.text}
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </li>
      ))}
    </ul>
  );
}
```

### Updating Items

```jsx
function UpdateItemExample() {
  const [items, setItems] = useState([
    { id: 1, text: 'Item 1', completed: false },
    { id: 2, text: 'Item 2', completed: false }
  ]);

  const toggleItem = (id) => {
    setItems(items.map(item =>
      item.id === id ? { ...item, completed: !item.completed } : item
    ));
  };

  return (
    <ul>
      {items.map(item => (
        <li 
          key={item.id}
          style={{ textDecoration: item.completed ? 'line-through' : 'none' }}
          onClick={() => toggleItem(item.id)}
        >
          {item.text}
        </li>
      ))}
    </ul>
  );
}
```

---

## Interview Questions

### Q1: Why are keys important in React lists?
**Answer**: Keys help React identify which items have changed, been added, or removed. They:
- Enable efficient reconciliation (diffing algorithm)
- Preserve component state across re-renders
- Prevent rendering bugs
- Improve performance

Without keys, React can't track elements correctly, leading to incorrect updates or lost state.

### Q2: Can you use array index as a key?
**Answer**: Only use index as key when:
- List is static (never reordered, filtered, or modified)
- Items have no unique ID
- List items have no internal state

Avoid index keys for dynamic lists because reordering breaks the identity mapping, causing:
- Wrong components receiving wrong props
- Lost component state
- Performance issues

### Q3: What happens if you don't provide a key?
**Answer**: React will:
- Show a console warning
- Use index as key by default
- May have rendering bugs if list changes
- Performance degradation

Always provide explicit, stable keys for lists.

### Q4: Where should the key prop be placed?
**Answer**: On the outermost element returned by `.map()`, not inside the component:

```jsx
// ✅ Correct
{items.map(item => <Item key={item.id} {...item} />)}

// ❌ Wrong
{items.map(item => <Item {...item} />)}  // Key inside Item
```

### Q5: Can keys be duplicated?
**Answer**: Keys must be unique among siblings, but:
- Can be duplicated in different arrays
- Don't need to be globally unique
- Should be stable (same key for same data)

```jsx
// ✅ OK: Different lists
<List1>{items1.map(i => <Item key={i.id} />)}</List1>
<List2>{items2.map(i => <Item key={i.id} />)}</List2>

// ❌ Bad: Same list
{items.map(i => <Item key="same-key" />)}  // All same key!
```

### Q6: How do you optimize rendering of large lists?
**Answer**:
1. **Virtualization**: Render only visible items (react-window, react-virtualized)
2. **Memoization**: Use `React.memo()` on list items
3. **Proper keys**: Use stable, unique keys
4. **Avoid inline functions**: Define handlers outside or use useCallback
5. **Pagination**: Load data in chunks
6. **Lazy loading**: Load more as user scrolls

### Q7: What is the best way to generate keys?
**Answer**:
1. **Database IDs**: `key={item.id}` (best)
2. **Unique properties**: `key={item.email}` (if unique)
3. **Composite keys**: `key={${item.category}-${item.id}}`
4. **UUIDs**: Generate with `uuid` library
5. **Index**: Only for static lists (last resort)

Never use `Math.random()` or `Date.now()` – they change on every render!

---

## Best Practices

1. **Always provide keys** for list items
2. **Use stable, unique IDs** from data
3. **Avoid index as key** for dynamic lists
4. **Place key on outermost element** in `.map()`
5. **Don't use random values** for keys
6. **Extract list items** to separate components for readability
7. **Show empty states** for empty lists
8. **Optimize large lists** with virtualization
9. **Use React.memo** for expensive list items
10. **Filter and sort before rendering** for better UX

---

## Summary

- Use `.map()` to render lists from arrays
- **Keys** are crucial for React's reconciliation process
- Keys must be **unique among siblings** and **stable**
- Use **data IDs** for keys, not array index (unless static)
- Place keys on the **element in `.map()`**, not inside components
- Optimize large lists with **virtualization** and **memoization**
- Show **empty states** when lists are empty
- Extract list items to separate components for better organization
