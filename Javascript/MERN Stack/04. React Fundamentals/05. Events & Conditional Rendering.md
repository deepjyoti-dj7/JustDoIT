# Events & Conditional Rendering

## Event Handling in React

React events use **camelCase** naming and pass functions as event handlers (not strings).

### Basic Event Handling

```jsx
// HTML (string)
<button onclick="handleClick()">Click</button>

// React (function reference)
<button onClick={handleClick}>Click</button>
```

### Common Events

```jsx
function EventExamples() {
  const handleClick = () => console.log('Clicked!');
  const handleChange = (e) => console.log(e.target.value);
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted');
  };
  const handleKeyPress = (e) => {
    if (e.key === 'Enter') console.log('Enter pressed');
  };

  return (
    <div>
      <button onClick={handleClick}>Click Me</button>
      <input onChange={handleChange} />
      <form onSubmit={handleSubmit}>
        <input onKeyPress={handleKeyPress} />
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}
```

---

## Event Types

### 1. Mouse Events
```jsx
function MouseEvents() {
  return (
    <div
      onClick={() => console.log('Click')}
      onDoubleClick={() => console.log('Double click')}
      onMouseEnter={() => console.log('Mouse enter')}
      onMouseLeave={() => console.log('Mouse leave')}
      onMouseMove={() => console.log('Mouse move')}
      onMouseDown={() => console.log('Mouse down')}
      onMouseUp={() => console.log('Mouse up')}
    >
      Hover or click me
    </div>
  );
}
```

### 2. Keyboard Events
```jsx
function KeyboardEvents() {
  const handleKeyDown = (e) => {
    console.log(`Key pressed: ${e.key}`);
    console.log(`Ctrl: ${e.ctrlKey}, Shift: ${e.shiftKey}`);
  };

  return (
    <input
      onKeyDown={handleKeyDown}
      onKeyUp={(e) => console.log('Key released')}
      onKeyPress={(e) => console.log('Key press')}
      placeholder="Type something"
    />
  );
}
```

### 3. Form Events
```jsx
function FormEvents() {
  return (
    <form
      onSubmit={(e) => e.preventDefault()}
      onChange={(e) => console.log('Form changed')}
      onReset={() => console.log('Form reset')}
    >
      <input
        onFocus={() => console.log('Input focused')}
        onBlur={() => console.log('Input blurred')}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### 4. Clipboard Events
```jsx
function ClipboardEvents() {
  return (
    <input
      onCopy={(e) => console.log('Copied:', e.clipboardData.getData('text'))}
      onCut={(e) => console.log('Cut')}
      onPaste={(e) => console.log('Pasted:', e.clipboardData.getData('text'))}
    />
  );
}
```

---

## Synthetic Events

React wraps native browser events in **SyntheticEvent** for:
- Cross-browser compatibility
- Better performance (event pooling)
- Consistent API

```jsx
function SyntheticEventExample() {
  const handleClick = (e) => {
    console.log(e);              // SyntheticEvent
    console.log(e.type);         // 'click'
    console.log(e.target);       // DOM element
    console.log(e.currentTarget);// Element with handler
    console.log(e.nativeEvent);  // Original browser event
  };

  return <button onClick={handleClick}>Click</button>;
}
```

### Event Properties
```jsx
function EventProperties({ value }) {
  const handleEvent = (e) => {
    e.preventDefault();       // Prevent default behavior
    e.stopPropagation();      // Stop event bubbling
    
    console.log(e.target);    // Element that triggered event
    console.log(e.currentTarget); // Element with handler
    console.log(e.type);      // Event type: 'click', 'change', etc.
  };
}
```

---

## Passing Arguments to Event Handlers

### Method 1: Arrow Function
```jsx
function TodoList({ todos }) {
  const handleDelete = (id) => {
    console.log('Deleting:', id);
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={() => handleDelete(todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Method 2: Bind
```jsx
function TodoList({ todos }) {
  const handleDelete = (id) => {
    console.log('Deleting:', id);
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={handleDelete.bind(null, todo.id)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

### Method 3: Data Attributes
```jsx
function TodoList({ todos }) {
  const handleDelete = (e) => {
    const id = e.currentTarget.dataset.id;
    console.log('Deleting:', id);
  };

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
          <button data-id={todo.id} onClick={handleDelete}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

---

## Conditional Rendering

Render different UI based on state or props.

### 1. If-Else Statement

```jsx
function UserGreeting({ isLoggedIn, username }) {
  if (isLoggedIn) {
    return <h1>Welcome back, {username}!</h1>;
  } else {
    return <h1>Please sign in.</h1>;
  }
}
```

### 2. Ternary Operator

```jsx
function UserGreeting({ isLoggedIn, username }) {
  return (
    <h1>
      {isLoggedIn ? `Welcome back, ${username}!` : 'Please sign in.'}
    </h1>
  );
}
```

### 3. Logical && Operator

```jsx
function Notification({ hasNotifications, count }) {
  return (
    <div>
      {hasNotifications && (
        <span className="badge">You have {count} new messages</span>
      )}
    </div>
  );
}
```

### 4. Logical || Operator (Fallback)

```jsx
function UserProfile({ user }) {
  return (
    <div>
      <h2>{user.name || 'Anonymous'}</h2>
      <p>{user.bio || 'No bio available'}</p>
    </div>
  );
}
```

### 5. Switch Statement

```jsx
function StatusMessage({ status }) {
  switch (status) {
    case 'loading':
      return <p>Loading...</p>;
    case 'success':
      return <p>Success!</p>;
    case 'error':
      return <p>Error occurred</p>;
    default:
      return null;
  }
}
```

### 6. Element Variables

```jsx
function LoginControl({ isLoggedIn }) {
  let button;

  if (isLoggedIn) {
    button = <LogoutButton />;
  } else {
    button = <LoginButton />;
  }

  return (
    <div>
      <h1>User Panel</h1>
      {button}
    </div>
  );
}
```

### 7. Immediately Invoked Function

```jsx
function ComplexConditional({ user }) {
  return (
    <div>
      {(() => {
        if (!user) return <p>Loading...</p>;
        if (user.role === 'admin') return <AdminPanel />;
        if (user.role === 'user') return <UserPanel />;
        return <GuestPanel />;
      })()}
    </div>
  );
}
```

---

## Conditional Rendering Patterns

### Showing/Hiding Elements

```jsx
function Accordion() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        {isOpen ? 'Hide' : 'Show'} Details
      </button>
      {isOpen && (
        <div className="content">
          <p>This is the accordion content</p>
        </div>
      )}
    </div>
  );
}
```

### Multiple Conditions

```jsx
function UserDashboard({ user, isLoading, error }) {
  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return <LoginPrompt />;
  
  return <Dashboard user={user} />;
}
```

### Conditional Classes

```jsx
function Button({ isPrimary, isDisabled, children }) {
  const className = `btn ${isPrimary ? 'btn-primary' : 'btn-secondary'} ${isDisabled ? 'disabled' : ''}`;
  
  return <button className={className}>{children}</button>;
}

// Or with a library like classnames
import classNames from 'classnames';

function Button({ isPrimary, isDisabled, children }) {
  return (
    <button
      className={classNames('btn', {
        'btn-primary': isPrimary,
        'btn-secondary': !isPrimary,
        'disabled': isDisabled
      })}
    >
      {children}
    </button>
  );
}
```

### Conditional Styles

```jsx
function Alert({ type, message }) {
  const style = {
    padding: '10px',
    borderRadius: '4px',
    backgroundColor: type === 'error' ? '#f44336' : '#4caf50',
    color: 'white'
  };

  return <div style={style}>{message}</div>;
}
```

---

## Preventing Component Rendering

Return `null` to prevent rendering:

```jsx
function WarningBanner({ showWarning }) {
  if (!showWarning) {
    return null;  // Component returns nothing
  }

  return (
    <div className="warning">
      <p>Warning: This action cannot be undone!</p>
    </div>
  );
}
```

---

## Real-World Examples

### Authentication Flow

```jsx
function App() {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkAuth().then(user => {
      setUser(user);
      setIsLoading(false);
    });
  }, []);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  return user ? <Dashboard user={user} /> : <LoginPage />;
}
```

### Modal Dialog

```jsx
function ModalExample() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      
      {isOpen && (
        <div className="modal-overlay">
          <div className="modal">
            <h2>Modal Title</h2>
            <p>Modal content</p>
            <button onClick={() => setIsOpen(false)}>Close</button>
          </div>
        </div>
      )}
    </div>
  );
}
```

### Form Validation

```jsx
function SignupForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};
    if (!email) newErrors.email = 'Email is required';
    if (!email.includes('@')) newErrors.email = 'Invalid email';
    if (password.length < 6) newErrors.password = 'Password must be 6+ characters';
    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const newErrors = validate();
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
    } else {
      // Submit form
      console.log('Form valid');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      {errors.email && <span className="error">{errors.email}</span>}
      
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      {errors.password && <span className="error">{errors.password}</span>}
      
      <button type="submit">Sign Up</button>
    </form>
  );
}
```

---

## Interview Questions

### Q1: What are Synthetic Events in React?
**Answer**: Synthetic Events are React's cross-browser wrapper around native browser events. They:
- Provide consistent API across all browsers
- Use event pooling for performance
- Support all standard event properties
- Auto-bind to component context
- Can access native event via `e.nativeEvent`

### Q2: How do you pass parameters to event handlers?
**Answer**: Three main approaches:
1. **Arrow function**: `onClick={() => handleClick(id)}`
2. **Bind**: `onClick={handleClick.bind(null, id)}`
3. **Data attributes**: `data-id={id}` and read from `e.currentTarget.dataset.id`

Arrow function is most common but creates new function on each render. For performance-critical lists, use data attributes.

### Q3: What is the difference between onClick={handleClick} and onClick={handleClick()}?
**Answer**:
- `onClick={handleClick}`: Passes function reference, calls on click ✅
- `onClick={handleClick()}`: Calls immediately during render, passes return value ❌

```jsx
<button onClick={handleClick}>Click</button>      // ✅ Correct
<button onClick={handleClick()}>Click</button>    // ❌ Calls immediately
<button onClick={() => handleClick()}>Click</button>  // ✅ Also correct
```

### Q4: How do you prevent default behavior in React?
**Answer**: Call `e.preventDefault()` in event handler:

```jsx
const handleSubmit = (e) => {
  e.preventDefault();  // Prevents form submission
  // Handle form logic
};

<form onSubmit={handleSubmit}>
```

Cannot use `return false` like in traditional HTML.

### Q5: What are different ways to do conditional rendering?
**Answer**:
1. **if-else**: Full conditional logic
2. **Ternary**: `{condition ? <A/> : <B/>}`
3. **Logical &&**: `{condition && <Component/>}`
4. **Switch**: Multiple conditions
5. **Element variables**: Store JSX in variables
6. **Return null**: Prevent rendering

Choose based on complexity and readability.

### Q6: What is event bubbling and how do you stop it?
**Answer**: Event bubbling is when an event propagates from child to parent elements. Stop it with `e.stopPropagation()`:

```jsx
<div onClick={handleParent}>
  <button onClick={(e) => {
    e.stopPropagation();  // Prevents handleParent from firing
    handleButton();
  }}>
    Click
  </button>
</div>
```

### Q7: Why should you not use index as a key in lists?
**Answer**: Using index as key can cause bugs when:
- List order changes
- Items are added/removed
- Items are reordered

React uses keys to track elements. Index-based keys break this when list mutates, causing incorrect rendering or lost state.

```jsx
// ❌ Bad
{items.map((item, index) => <Item key={index} {...item} />)}

// ✅ Good
{items.map(item => <Item key={item.id} {...item} />)}
```

---

## Best Practices

1. **Use camelCase** for event names (`onClick`, not `onclick`)
2. **Pass function references**, not function calls
3. **Prevent defaults** when needed (`e.preventDefault()`)
4. **Use descriptive handler names** (`handleSubmit`, not `handle`)
5. **Keep handlers close** to where they're used
6. **Use conditional rendering** for cleaner code than hiding with CSS
7. **Return null** to prevent rendering, not empty elements
8. **Avoid inline functions** in performance-critical lists
9. **Use event delegation** for dynamic lists
10. **Prefer && over ternary** for simple show/hide

---

## Summary

- React events use **camelCase** and function references
- **Synthetic Events** provide cross-browser compatibility
- Pass arguments via arrow functions, bind, or data attributes
- **Conditional rendering** uses if-else, ternary, &&, or switch
- **Prevent defaults** with `e.preventDefault()`
- **Stop propagation** with `e.stopPropagation()`
- Return **null** to prevent component rendering
- Choose conditional rendering approach based on complexity
