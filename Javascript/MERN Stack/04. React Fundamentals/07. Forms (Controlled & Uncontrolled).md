# Forms (Controlled & Uncontrolled)

## Form Fundamentals in React

React provides two approaches to handle form inputs: **Controlled** and **Uncontrolled** components.

---

## Controlled Components (Recommended)

In controlled components, React controls the form data through state. The input value is always derived from state.

### Basic Controlled Input

```jsx
import { useState } from 'react';

function ControlledInput() {
  const [value, setValue] = useState('');

  return (
    <div>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <p>You typed: {value}</p>
    </div>
  );
}
```

### Controlled Form Example

```jsx
function LoginForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Form submitted:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <input
        type="password"
        name="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

---

## Uncontrolled Components

Uncontrolled components store form data in the DOM itself. Access values using refs.

### Basic Uncontrolled Input

```jsx
import { useRef } from 'react';

function UncontrolledInput() {
  const inputRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Value:', inputRef.current.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input ref={inputRef} type="text" defaultValue="Initial" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Uncontrolled Form Example

```jsx
function UncontrolledForm() {
  const emailRef = useRef(null);
  const passwordRef = useRef(null);

  const handleSubmit = (e) => {
    e.preventDefault();
    const formData = {
      email: emailRef.current.value,
      password: passwordRef.current.value
    };
    console.log('Form submitted:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={emailRef}
        type="email"
        defaultValue=""
        placeholder="Email"
      />
      <input
        ref={passwordRef}
        type="password"
        defaultValue=""
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

---

## Controlled vs Uncontrolled

| Aspect | Controlled | Uncontrolled |
|--------|------------|--------------|
| **State** | React state | DOM state |
| **Value prop** | `value={state}` | `defaultValue="..."` |
| **Access** | Direct from state | Via ref |
| **Validation** | Real-time, easy | On submit only |
| **Performance** | Re-renders on change | Better (no re-renders) |
| **Use case** | Most forms | File inputs, legacy code |
| **Recommendation** | ✅ Preferred | ⚠️ Rarely needed |

---

## Different Input Types

### Text Input

```jsx
function TextInput() {
  const [text, setText] = useState('');

  return (
    <input
      type="text"
      value={text}
      onChange={(e) => setText(e.target.value)}
      placeholder="Enter text"
    />
  );
}
```

### Textarea

```jsx
function TextareaExample() {
  const [message, setMessage] = useState('');

  return (
    <textarea
      value={message}
      onChange={(e) => setMessage(e.target.value)}
      placeholder="Enter message"
      rows={4}
    />
  );
}
```

### Select Dropdown

```jsx
function SelectExample() {
  const [country, setCountry] = useState('usa');

  return (
    <select value={country} onChange={(e) => setCountry(e.target.value)}>
      <option value="usa">United States</option>
      <option value="uk">United Kingdom</option>
      <option value="canada">Canada</option>
      <option value="india">India</option>
    </select>
  );
}
```

### Multi-Select

```jsx
function MultiSelectExample() {
  const [selected, setSelected] = useState([]);

  const handleChange = (e) => {
    const options = Array.from(e.target.selectedOptions);
    setSelected(options.map(option => option.value));
  };

  return (
    <select multiple value={selected} onChange={handleChange}>
      <option value="react">React</option>
      <option value="vue">Vue</option>
      <option value="angular">Angular</option>
    </select>
  );
}
```

### Checkbox

```jsx
function CheckboxExample() {
  const [isChecked, setIsChecked] = useState(false);

  return (
    <label>
      <input
        type="checkbox"
        checked={isChecked}
        onChange={(e) => setIsChecked(e.target.checked)}
      />
      I agree to terms and conditions
    </label>
  );
}
```

### Multiple Checkboxes

```jsx
function MultipleCheckboxes() {
  const [hobbies, setHobbies] = useState({
    reading: false,
    sports: false,
    music: false
  });

  const handleChange = (e) => {
    const { name, checked } = e.target;
    setHobbies(prev => ({
      ...prev,
      [name]: checked
    }));
  };

  return (
    <div>
      <label>
        <input
          type="checkbox"
          name="reading"
          checked={hobbies.reading}
          onChange={handleChange}
        />
        Reading
      </label>
      <label>
        <input
          type="checkbox"
          name="sports"
          checked={hobbies.sports}
          onChange={handleChange}
        />
        Sports
      </label>
      <label>
        <input
          type="checkbox"
          name="music"
          checked={hobbies.music}
          onChange={handleChange}
        />
        Music
      </label>
    </div>
  );
}
```

### Radio Buttons

```jsx
function RadioExample() {
  const [gender, setGender] = useState('male');

  return (
    <div>
      <label>
        <input
          type="radio"
          value="male"
          checked={gender === 'male'}
          onChange={(e) => setGender(e.target.value)}
        />
        Male
      </label>
      <label>
        <input
          type="radio"
          value="female"
          checked={gender === 'female'}
          onChange={(e) => setGender(e.target.value)}
        />
        Female
      </label>
      <label>
        <input
          type="radio"
          value="other"
          checked={gender === 'other'}
          onChange={(e) => setGender(e.target.value)}
        />
        Other
      </label>
    </div>
  );
}
```

### File Input (Uncontrolled)

```jsx
function FileUpload() {
  const fileRef = useRef(null);
  const [fileName, setFileName] = useState('');

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    setFileName(file ? file.name : '');
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const file = fileRef.current.files[0];
    console.log('Selected file:', file);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        ref={fileRef}
        type="file"
        onChange={handleFileChange}
      />
      {fileName && <p>Selected: {fileName}</p>}
      <button type="submit">Upload</button>
    </form>
  );
}
```

---

## Form Validation

### Basic Validation

```jsx
function SignupForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};

    if (!formData.username) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }

    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    return newErrors;
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    // Clear error on change
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validate();

    if (Object.keys(validationErrors).length === 0) {
      console.log('Form is valid:', formData);
      // Submit form
    } else {
      setErrors(validationErrors);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
          placeholder="Username"
        />
        {errors.username && <span className="error">{errors.username}</span>}
      </div>

      <div>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          placeholder="Email"
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>

      <div>
        <input
          type="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          placeholder="Password"
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>

      <button type="submit">Sign Up</button>
    </form>
  );
}
```

### Real-time Validation

```jsx
function RealTimeValidation() {
  const [email, setEmail] = useState('');
  const [emailError, setEmailError] = useState('');

  const validateEmail = (value) => {
    if (!value) return 'Email is required';
    if (!/\S+@\S+\.\S+/.test(value)) return 'Email is invalid';
    return '';
  };

  const handleEmailChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    setEmailError(validateEmail(value));
  };

  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleEmailChange}
        className={emailError ? 'input-error' : ''}
      />
      {emailError && <span className="error">{emailError}</span>}
    </div>
  );
}
```

---

## Form Libraries

### React Hook Form (Popular)

```jsx
import { useForm } from 'react-hook-form';

function HookFormExample() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const onSubmit = (data) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input
        {...register('email', {
          required: 'Email is required',
          pattern: {
            value: /\S+@\S+\.\S+/,
            message: 'Invalid email'
          }
        })}
      />
      {errors.email && <span>{errors.email.message}</span>}

      <input
        type="password"
        {...register('password', {
          required: 'Password is required',
          minLength: {
            value: 6,
            message: 'Password must be at least 6 characters'
          }
        })}
      />
      {errors.password && <span>{errors.password.message}</span>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

### Formik (Popular Alternative)

```jsx
import { useFormik } from 'formik';

function FormikExample() {
  const formik = useFormik({
    initialValues: {
      email: '',
      password: ''
    },
    validate: values => {
      const errors = {};
      if (!values.email) errors.email = 'Required';
      if (!values.password) errors.password = 'Required';
      return errors;
    },
    onSubmit: values => {
      console.log(values);
    }
  });

  return (
    <form onSubmit={formik.handleSubmit}>
      <input
        name="email"
        value={formik.values.email}
        onChange={formik.handleChange}
      />
      {formik.errors.email && <span>{formik.errors.email}</span>}

      <input
        type="password"
        name="password"
        value={formik.values.password}
        onChange={formik.handleChange}
      />
      {formik.errors.password && <span>{formik.errors.password}</span>}

      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## Advanced Form Patterns

### Dynamic Form Fields

```jsx
function DynamicForm() {
  const [fields, setFields] = useState([{ id: 1, value: '' }]);

  const addField = () => {
    setFields([...fields, { id: Date.now(), value: '' }]);
  };

  const removeField = (id) => {
    setFields(fields.filter(field => field.id !== id));
  };

  const updateField = (id, value) => {
    setFields(fields.map(field =>
      field.id === id ? { ...field, value } : field
    ));
  };

  return (
    <div>
      {fields.map(field => (
        <div key={field.id}>
          <input
            value={field.value}
            onChange={(e) => updateField(field.id, e.target.value)}
          />
          <button onClick={() => removeField(field.id)}>Remove</button>
        </div>
      ))}
      <button onClick={addField}>Add Field</button>
    </div>
  );
}
```

### Multi-Step Form

```jsx
function MultiStepForm() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    // Step 1
    firstName: '',
    lastName: '',
    // Step 2
    email: '',
    phone: '',
    // Step 3
    address: '',
    city: ''
  });

  const nextStep = () => setStep(step + 1);
  const prevStep = () => setStep(step - 1);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log('Final data:', formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      {step === 1 && (
        <div>
          <h2>Step 1: Personal Info</h2>
          <input
            name="firstName"
            value={formData.firstName}
            onChange={handleChange}
            placeholder="First Name"
          />
          <input
            name="lastName"
            value={formData.lastName}
            onChange={handleChange}
            placeholder="Last Name"
          />
          <button type="button" onClick={nextStep}>Next</button>
        </div>
      )}

      {step === 2 && (
        <div>
          <h2>Step 2: Contact Info</h2>
          <input
            name="email"
            value={formData.email}
            onChange={handleChange}
            placeholder="Email"
          />
          <input
            name="phone"
            value={formData.phone}
            onChange={handleChange}
            placeholder="Phone"
          />
          <button type="button" onClick={prevStep}>Back</button>
          <button type="button" onClick={nextStep}>Next</button>
        </div>
      )}

      {step === 3 && (
        <div>
          <h2>Step 3: Address</h2>
          <input
            name="address"
            value={formData.address}
            onChange={handleChange}
            placeholder="Address"
          />
          <input
            name="city"
            value={formData.city}
            onChange={handleChange}
            placeholder="City"
          />
          <button type="button" onClick={prevStep}>Back</button>
          <button type="submit">Submit</button>
        </div>
      )}
    </form>
  );
}
```

---

## Interview Questions

### Q1: What is the difference between controlled and uncontrolled components?
**Answer**:
- **Controlled**: React state controls input value via `value` prop. Single source of truth, real-time validation possible
- **Uncontrolled**: DOM controls input value, accessed via refs with `defaultValue`. Better performance, less code

**Controlled** is recommended for most cases for better control and validation.

### Q2: When would you use an uncontrolled component?
**Answer**: Use uncontrolled components when:
- File inputs (only uncontrolled option)
- Integrating with non-React code
- Simple forms without validation
- Performance is critical (avoid re-renders)
- Legacy code integration

### Q3: How do you handle form validation in React?
**Answer**: Several approaches:
1. **Manual**: useState for errors, validate on submit or onChange
2. **HTML5**: Use built-in validation attributes (required, pattern, min, max)
3. **Libraries**: React Hook Form, Formik, Yup (schema validation)

Choose based on complexity: manual for simple forms, libraries for complex validation.

### Q4: What is the difference between value and defaultValue?
**Answer**:
- **value**: Controlled component, React manages state, updates on every change
- **defaultValue**: Uncontrolled component, sets initial value only, DOM manages thereafter

```jsx
// Controlled
<input value={state} onChange={handleChange} />

// Uncontrolled
<input defaultValue="initial" ref={inputRef} />
```

### Q5: How do you handle multiple inputs in a form?
**Answer**: Use a single state object with computed property names:

```jsx
const [formData, setFormData] = useState({ name: '', email: '' });

const handleChange = (e) => {
  const { name, value } = e.target;
  setFormData(prev => ({ ...prev, [name]: value }));
};

<input name="name" value={formData.name} onChange={handleChange} />
<input name="email" value={formData.email} onChange={handleChange} />
```

### Q6: Why use preventDefault() in form submission?
**Answer**: `e.preventDefault()` prevents the default browser behavior of reloading the page on form submit. This allows React to handle submission with JavaScript, making it a SPA (Single Page Application) experience.

```jsx
const handleSubmit = (e) => {
  e.preventDefault();  // Prevents page reload
  // Handle form logic
};
```

### Q7: How do you reset a form in React?
**Answer**:
- **Controlled**: Reset state to initial values
- **Uncontrolled**: Use form's `reset()` method or set `key` prop

```jsx
// Controlled
setFormData({ name: '', email: '' });

// Uncontrolled
formRef.current.reset();

// Force remount with key
<form key={formKey}>...</form>
setFormKey(Date.now());
```

---

## Best Practices

1. **Use controlled components** for most forms
2. **Validate early and often** - real-time feedback improves UX
3. **Disable submit button** during submission
4. **Show clear error messages** near the input
5. **Use form libraries** for complex forms (React Hook Form)
6. **Clear errors on input change** for better UX
7. **Use HTML5 validation** as first layer (type, required, pattern)
8. **Prevent default submission** to avoid page reload
9. **Use refs for file inputs** (must be uncontrolled)
10. **Keep form state minimal** - derive values when possible

---

## Summary

- **Controlled components** use React state (`value` + `onChange`)
- **Uncontrolled components** use DOM state (refs + `defaultValue`)
- Controlled components are **recommended** for better control
- Use **different input types**: text, select, checkbox, radio, file
- Implement **validation** for better UX and data integrity
- Use **form libraries** (React Hook Form, Formik) for complex forms
- Always use **`e.preventDefault()`** to prevent page reload
- File inputs must be **uncontrolled** (access via refs)
