# Components (Functional & Class)

## What are Components?

Components are the **building blocks** of React applications. They are independent, reusable pieces of UI that:
- Accept inputs (props)
- Return React elements describing what should appear on screen
- Can manage their own state
- Can be composed together to build complex UIs

---

## Types of Components

### 1. Functional Components (Modern Approach) ⭐

Functions that return JSX. With hooks, they can handle state and lifecycle.

#### Basic Syntax
```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}
```

#### With Arrow Function
```jsx
const Welcome = (props) => {
  return <h1>Hello, {props.name}!</h1>;
};
```

#### With Destructuring
```jsx
const Welcome = ({ name }) => {
  return <h1>Hello, {name}!</h1>;
};
```

#### Complete Example
```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}

export default Counter;
```

---

### 2. Class Components (Legacy Approach)

ES6 classes that extend `React.Component`.

#### Basic Syntax
```jsx
import React from 'react';

class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}
```

#### Complete Example
```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  decrement = () => {
    this.setState({ count: this.state.count - 1 });
  };

  render() {
    return (
      <div>
        <h2>Count: {this.state.count}</h2>
        <button onClick={this.increment}>+</button>
        <button onClick={this.decrement}>-</button>
      </div>
    );
  }
}

export default Counter;
```

---

## Functional vs Class Components

| Feature | Functional | Class |
|---------|------------|-------|
| **Syntax** | Simple function | ES6 class |
| **State** | `useState` hook | `this.state` |
| **Lifecycle** | `useEffect` hook | Lifecycle methods |
| **Performance** | Slightly better | Slightly slower |
| **Boilerplate** | Less code | More code |
| **Learning Curve** | Easier | Steeper |
| **Modern** | ✅ Recommended | ⚠️ Legacy |
| **`this` keyword** | Not needed | Required |
| **Testing** | Easier | More complex |

---

## Component Lifecycle

### Functional Component Lifecycle (with Hooks)

```jsx
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  // Mounting + Updating
  useEffect(() => {
    fetchUser(userId).then(data => setUser(data));
  }, [userId]); // Runs when userId changes

  // Mounting only (componentDidMount equivalent)
  useEffect(() => {
    console.log('Component mounted');
  }, []); // Empty dependency array

  // Cleanup (componentWillUnmount equivalent)
  useEffect(() => {
    return () => {
      console.log('Component will unmount');
    };
  }, []);

  return <div>{user?.name}</div>;
}
```

### Class Component Lifecycle

```jsx
class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = { user: null };
  }

  // Mounting
  componentDidMount() {
    fetchUser(this.props.userId)
      .then(data => this.setState({ user: data }));
  }

  // Updating
  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      fetchUser(this.props.userId)
        .then(data => this.setState({ user: data }));
    }
  }

  // Unmounting
  componentWillUnmount() {
    console.log('Component will unmount');
  }

  render() {
    return <div>{this.state.user?.name}</div>;
  }
}
```

---

## Props in Components

### Functional Component with Props
```jsx
// Parent
function App() {
  return <UserCard name="Alice" age={25} isActive={true} />;
}

// Child
function UserCard({ name, age, isActive }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>Age: {age}</p>
      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}
```

### Class Component with Props
```jsx
class UserCard extends Component {
  render() {
    const { name, age, isActive } = this.props;
    return (
      <div>
        <h3>{name}</h3>
        <p>Age: {age}</p>
        <p>Status: {isActive ? 'Active' : 'Inactive'}</p>
      </div>
    );
  }
}
```

### Default Props
```jsx
// Functional
function Button({ label = 'Click Me', variant = 'primary' }) {
  return <button className={variant}>{label}</button>;
}

// Class
class Button extends Component {
  static defaultProps = {
    label: 'Click Me',
    variant: 'primary'
  };

  render() {
    return <button className={this.props.variant}>{this.props.label}</button>;
  }
}
```

---

## State Management

### Functional Component (useState)
```jsx
import { useState } from 'react';

function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState({});

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({ email, password });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Class Component (this.state)
```jsx
class LoginForm extends Component {
  constructor(props) {
    super(props);
    this.state = {
      email: '',
      password: '',
      errors: {}
    };
  }

  handleSubmit = (e) => {
    e.preventDefault();
    console.log(this.state);
  };

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type="email"
          value={this.state.email}
          onChange={(e) => this.setState({ email: e.target.value })}
          placeholder="Email"
        />
        <input
          type="password"
          value={this.state.password}
          onChange={(e) => this.setState({ password: e.target.value })}
          placeholder="Password"
        />
        <button type="submit">Login</button>
      </form>
    );
  }
}
```

---

## When to Use Each?

### Use Functional Components When:
- ✅ Starting a new project
- ✅ Want cleaner, more concise code
- ✅ Need modern React features (hooks)
- ✅ Want better performance
- ✅ Easier testing and debugging

### Use Class Components When:
- ⚠️ Maintaining legacy code
- ⚠️ Team is more familiar with classes
- ⚠️ Using older third-party libraries requiring classes

**Recommendation**: Always use functional components for new code.

---

## Component Composition

### Example: Building Complex UI

```jsx
// Small, reusable components
function Avatar({ src, alt }) {
  return <img src={src} alt={alt} className="avatar" />;
}

function UserInfo({ user }) {
  return (
    <div className="user-info">
      <Avatar src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
    </div>
  );
}

function Comment({ comment }) {
  return (
    <div className="comment">
      <UserInfo user={comment.author} />
      <p>{comment.text}</p>
      <span>{comment.date}</span>
    </div>
  );
}

// Composed together
function CommentList({ comments }) {
  return (
    <div className="comment-list">
      {comments.map(comment => (
        <Comment key={comment.id} comment={comment} />
      ))}
    </div>
  );
}
```

---

## Pure Components

Components that render the same output for the same props/state.

### Functional Pure Component
```jsx
import { memo } from 'react';

const UserCard = memo(({ name, email }) => {
  console.log('Rendering UserCard');
  return (
    <div>
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
});
```

### Class Pure Component
```jsx
import { PureComponent } from 'react';

class UserCard extends PureComponent {
  render() {
    console.log('Rendering UserCard');
    return (
      <div>
        <h3>{this.props.name}</h3>
        <p>{this.props.email}</p>
      </div>
    );
  }
}
```

**Benefits**: Prevents unnecessary re-renders, improving performance.

---

## Higher-Order Components (HOC)

Function that takes a component and returns a new component.

```jsx
// HOC
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) return <div>Loading...</div>;
    return <Component {...props} />;
  };
}

// Original Component
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

// Enhanced Component
const UserListWithLoading = withLoading(UserList);

// Usage
<UserListWithLoading isLoading={loading} users={users} />
```

---

## Interview Questions

### Q1: What is the difference between functional and class components?
**Answer**: 
- **Functional**: Plain JavaScript functions, use hooks for state/lifecycle, less boilerplate, modern approach
- **Class**: ES6 classes extending React.Component, use `this.state` and lifecycle methods, more verbose, legacy approach

Functional components are now preferred due to hooks, better performance, and cleaner syntax.

### Q2: What are React Hooks and why were they introduced?
**Answer**: Hooks are functions that let you use state and lifecycle features in functional components. Introduced to:
- Eliminate need for class components
- Reuse stateful logic without HOCs or render props
- Simplify code organization
- Avoid confusion with `this` keyword
- Make code more testable

Common hooks: `useState`, `useEffect`, `useContext`, `useRef`, `useMemo`, `useCallback`.

### Q3: Can you use hooks in class components?
**Answer**: No. Hooks only work in functional components. If you need to use hooks, convert the class component to a functional component. This is a design decision by React team to encourage migration to functional components.

### Q4: What is a Pure Component?
**Answer**: A component that renders the same output for the same props and state. React optimizes pure components by:
- Shallow comparison of props/state before re-rendering
- Skipping render if nothing changed
- Improving performance

Use `React.memo()` for functional components or `PureComponent` for class components.

### Q5: What is the purpose of the `key` prop in components?
**Answer**: The `key` prop helps React identify which items in a list have changed, been added, or removed. It:
- Must be unique among siblings
- Should be stable (not index unless list is static)
- Helps React optimize re-renders
- Prevents bugs when list order changes

```jsx
{items.map(item => <Item key={item.id} {...item} />)}
```

### Q6: What is component composition?
**Answer**: Building complex UIs by combining smaller, focused components. Benefits:
- **Reusability**: Use components in multiple places
- **Maintainability**: Easier to update small components
- **Testability**: Test components in isolation
- **Separation of Concerns**: Each component has one responsibility

Example: `<App>` → `<Header>` → `<Navigation>` → `<NavItem>`

### Q7: What is the difference between props and state?
**Answer**:
- **Props**: Data passed from parent to child, immutable, controlled by parent
- **State**: Internal data managed by component, mutable, can be updated by component

```jsx
// Props (from parent)
<UserCard name="Alice" />

// State (internal)
const [count, setCount] = useState(0);
```

---

## Best Practices

1. **Always use functional components** for new code
2. **Keep components small and focused** (single responsibility)
3. **Use meaningful component names** (PascalCase)
4. **Extract reusable logic** into custom hooks
5. **Avoid deeply nested components** (max 2-3 levels)
6. **Use prop destructuring** for cleaner code
7. **Memoize expensive components** with `React.memo()`
8. **Organize by feature** not by type

---

## Summary

- Components are the foundation of React applications
- **Functional components** are the modern, recommended approach
- **Class components** are legacy but still supported
- Use hooks (`useState`, `useEffect`) for state and lifecycle in functional components
- Compose small, reusable components to build complex UIs
- Pure components optimize performance by preventing unnecessary renders
- Always prefer functional components for new development
