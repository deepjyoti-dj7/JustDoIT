# 13. Plugins, Transactions & Validation

## Mongoose Plugins

Reusable schema functionality.

### Create Plugin

```javascript
// plugins/timestamp.js
module.exports = function timestampPlugin(schema, options) {
  schema.add({
    createdAt: { type: Date, default: Date.now },
    updatedAt: Date
  });
  
  schema.pre('save', function(next) {
    this.updatedAt = Date.now();
    next();
  });
};
```

### Use Plugin

```javascript
const timestampPlugin = require('./plugins/timestamp');

const userSchema = new mongoose.Schema({
  name: String,
  email: String
});

// Apply plugin
userSchema.plugin(timestampPlugin);

const User = mongoose.model('User', userSchema);
```

### Popular Plugins

**1. mongoose-paginate-v2:**

```javascript
const mongoosePaginate = require('mongoose-paginate-v2');

userSchema.plugin(mongoosePaginate);

// Usage
const result = await User.paginate({}, { page: 1, limit: 10 });
console.log(result.docs);  // Documents
console.log(result.totalPages);  // Total pages
```

**2. mongoose-delete (Soft Delete):**

```javascript
const mongooseDelete = require('mongoose-delete');

userSchema.plugin(mongooseDelete, { deletedAt: true });

// Usage
await user.delete();  // Soft delete
await User.findDeleted();  // Find deleted
await User.findWithDeleted();  // Find all
```

---

## Transactions

Execute multiple operations atomically.

### Why Transactions?

Ensure all operations succeed or all fail (ACID).

**Use case:** Transfer money between accounts

### Basic Transaction

```javascript
const session = await mongoose.startSession();
session.startTransaction();

try {
  // Operation 1
  await Account.updateOne(
    { _id: fromId },
    { $inc: { balance: -100 } },
    { session }
  );
  
  // Operation 2
  await Account.updateOne(
    { _id: toId },
    { $inc: { balance: 100 } },
    { session }
  );
  
  // Commit transaction
  await session.commitTransaction();
  console.log('✅ Transaction successful');
  
} catch (err) {
  // Rollback on error
  await session.abortTransaction();
  console.error('❌ Transaction failed:', err);
  
} finally {
  session.endSession();
}
```

### Transaction with Create

```javascript
const session = await mongoose.startSession();
session.startTransaction();

try {
  const user = await User.create(
    [{ name: 'John', email: 'john@example.com' }],
    { session }
  );
  
  await Post.create(
    [{ title: 'First Post', author: user[0]._id }],
    { session }
  );
  
  await session.commitTransaction();
  
} catch (err) {
  await session.abortTransaction();
  throw err;
  
} finally {
  session.endSession();
}
```

### Transaction Helper Function

```javascript
const runTransaction = async (operations) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const result = await operations(session);
    await session.commitTransaction();
    return result;
    
  } catch (err) {
    await session.abortTransaction();
    throw err;
    
  } finally {
    session.endSession();
  }
};

// Usage
await runTransaction(async (session) => {
  await User.create([{ name: 'John' }], { session });
  await Post.create([{ title: 'Post' }], { session });
});
```

---

## Custom Validation

### Validator Function

```javascript
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    validate: {
      validator: function(v) {
        return /^\S+@\S+\.\S+$/.test(v);
      },
      message: 'Invalid email format'
    }
  },
  age: {
    type: Number,
    validate: {
      validator: function(v) {
        return v >= 18;
      },
      message: 'Must be 18 or older'
    }
  }
});
```

### Async Validator

Check if email exists:

```javascript
const userSchema = new mongoose.Schema({
  email: {
    type: String,
    validate: {
      validator: async function(email) {
        const user = await User.findOne({ email });
        return !user;  // Valid if email doesn't exist
      },
      message: 'Email already exists'
    }
  }
});
```

### Multiple Validators

```javascript
const userSchema = new mongoose.Schema({
  password: {
    type: String,
    validate: [
      {
        validator: function(v) {
          return v.length >= 8;
        },
        message: 'Password must be at least 8 characters'
      },
      {
        validator: function(v) {
          return /[A-Z]/.test(v);
        },
        message: 'Password must contain uppercase letter'
      },
      {
        validator: function(v) {
          return /[0-9]/.test(v);
        },
        message: 'Password must contain number'
      }
    ]
  }
});
```

### Custom Error Messages

```javascript
const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username is required'],
    minlength: [3, 'Username must be at least 3 characters'],
    maxlength: [20, 'Username cannot exceed 20 characters'],
    match: [/^[a-zA-Z0-9]+$/, 'Username can only contain letters and numbers']
  }
});
```

---

## Validation Triggers

### Manual Validation

```javascript
const user = new User({ name: 'John' });

try {
  await user.validate();
  console.log('✅ Valid');
} catch (err) {
  console.error('❌ Validation error:', err.message);
}
```

### Skip Validation

```javascript
// Save without validation
await user.save({ validateBeforeSave: false });

// Update without validation
await User.updateOne({ _id: id }, { age: -5 }, { runValidators: false });
```

### Update with Validation

```javascript
// Validation runs by default on save, not update
// Enable validation on update:
await User.updateOne(
  { _id: id },
  { age: 30 },
  { runValidators: true }
);
```

---

## Error Handling

### Validation Errors

```javascript
try {
  await user.save();
} catch (err) {
  if (err.name === 'ValidationError') {
    console.log('Validation failed:');
    for (let field in err.errors) {
      console.log(`- ${field}: ${err.errors[field].message}`);
    }
  }
}
```

### Duplicate Key Error

```javascript
try {
  await User.create({ email: 'john@example.com' });
} catch (err) {
  if (err.code === 11000) {
    console.log('Email already exists');
  }
}
```

---

## Complete Example

**models/User.js:**

```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true,
    minlength: [3, 'Username too short'],
    maxlength: [20, 'Username too long'],
    validate: {
      validator: function(v) {
        return /^[a-zA-Z0-9]+$/.test(v);
      },
      message: 'Username can only contain letters and numbers'
    }
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    validate: {
      validator: function(v) {
        return /^\S+@\S+\.\S+$/.test(v);
      },
      message: 'Invalid email format'
    }
  },
  password: {
    type: String,
    required: true,
    minlength: [8, 'Password must be at least 8 characters']
  }
}, { timestamps: true });

// Hash password before save
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});

module.exports = mongoose.model('User', userSchema);
```

---

## Best Practices

✅ **Use plugins**: For reusable logic  
✅ **Use transactions**: For critical operations  
✅ **Validate input**: Always validate user data  
✅ **Custom validators**: For complex rules  
✅ **Error handling**: Handle validation errors  
❌ **Don't skip validation**: Unless absolutely necessary  
❌ **Don't forget runValidators**: On updates  

---

## Summary

**Plugins:**
```javascript
schema.plugin(pluginFunction);
```

**Transactions:**
```javascript
const session = await mongoose.startSession();
session.startTransaction();
try {
  await Model.create([{...}], { session });
  await session.commitTransaction();
} catch (err) {
  await session.abortTransaction();
} finally {
  session.endSession();
}
```

**Validation:**
```javascript
{
  type: String,
  validate: {
    validator: function(v) { return ... },
    message: 'Error message'
  }
}
```

**Error Handling:**
```javascript
try {
  await user.save();
} catch (err) {
  if (err.name === 'ValidationError') { ... }
  if (err.code === 11000) { ... }
}
```

**Next**: Learn Mongoose Best Practices!
