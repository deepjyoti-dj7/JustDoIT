# 14. Mongoose Best Practices

## Schema Design

### 1. Use Proper Types

✅ **Good:**
```javascript
const schema = new mongoose.Schema({
  name: { type: String, required: true },
  age: { type: Number, min: 0 },
  email: { type: String, unique: true, lowercase: true },
  createdAt: { type: Date, default: Date.now }
});
```

❌ **Bad:**
```javascript
const schema = new mongoose.Schema({
  name: String,  // No validation
  age: Number,   // No constraints
  data: {}       // Avoid plain objects
});
```

### 2. Add Timestamps

✅ **Good:**
```javascript
const schema = new mongoose.Schema({
  name: String
}, { timestamps: true });
```

### 3. Use Virtuals for Computed Properties

✅ **Good:**
```javascript
schema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});
```

❌ **Bad:**
```javascript
// Don't store computed values
const schema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  fullName: String  // ❌ Redundant
});
```

---

## Validation

### 1. Always Validate

✅ **Good:**
```javascript
const schema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    lowercase: true,
    validate: {
      validator: v => /^\S+@\S+\.\S+$/.test(v),
      message: 'Invalid email'
    }
  },
  age: {
    type: Number,
    min: [0, 'Age must be positive'],
    max: [120, 'Age too high']
  }
});
```

### 2. Use Custom Error Messages

✅ **Good:**
```javascript
name: {
  type: String,
  required: [true, 'Name is required'],
  minlength: [3, 'Name too short']
}
```

❌ **Bad:**
```javascript
name: {
  type: String,
  required: true  // Generic error message
}
```

---

## Query Optimization

### 1. Use Indexes

✅ **Good:**
```javascript
const schema = new mongoose.Schema({
  email: { type: String, unique: true, index: true },
  status: { type: String, index: true },
  createdAt: { type: Date, index: true }
});

// Compound index
schema.index({ city: 1, age: -1 });
```

### 2. Select Only Needed Fields

✅ **Good:**
```javascript
const users = await User.find().select('name email');
```

❌ **Bad:**
```javascript
const users = await User.find();  // Fetches all fields
```

### 3. Use lean() for Read-Only Data

✅ **Good:**
```javascript
// Returns plain JavaScript object (faster)
const users = await User.find().lean();
```

❌ **Bad:**
```javascript
// Returns Mongoose document (slower)
const users = await User.find();
```

### 4. Use Pagination

✅ **Good:**
```javascript
const page = 1;
const limit = 10;
const users = await User
  .find()
  .skip((page - 1) * limit)
  .limit(limit);
```

❌ **Bad:**
```javascript
const users = await User.find();  // Fetches all
```

---

## Error Handling

### 1. Handle Errors Properly

✅ **Good:**
```javascript
try {
  const user = await User.create(data);
  res.json(user);
} catch (err) {
  if (err.name === 'ValidationError') {
    return res.status(400).json({ error: err.message });
  }
  if (err.code === 11000) {
    return res.status(400).json({ error: 'Email already exists' });
  }
  res.status(500).json({ error: 'Server error' });
}
```

❌ **Bad:**
```javascript
const user = await User.create(data);
res.json(user);  // ❌ No error handling
```

### 2. Use Middleware for Common Logic

✅ **Good:**
```javascript
schema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});
```

---

## Security

### 1. Hash Passwords

✅ **Good:**
```javascript
const bcrypt = require('bcrypt');

schema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, 10);
  next();
});
```

❌ **Bad:**
```javascript
const schema = new mongoose.Schema({
  password: String  // ❌ Stored in plain text
});
```

### 2. Don't Expose Sensitive Data

✅ **Good:**
```javascript
schema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.password;
  delete obj.__v;
  return obj;
};
```

### 3. Sanitize Input

✅ **Good:**
```javascript
const schema = new mongoose.Schema({
  email: {
    type: String,
    lowercase: true,
    trim: true
  },
  name: {
    type: String,
    trim: true
  }
});
```

---

## Connection Management

### 1. Use Environment Variables

✅ **Good:**
```javascript
require('dotenv').config();
mongoose.connect(process.env.MONGO_URI);
```

❌ **Bad:**
```javascript
mongoose.connect('mongodb://localhost:27017/mydb');  // ❌ Hardcoded
```

### 2. Handle Connection Events

✅ **Good:**
```javascript
mongoose.connection.on('connected', () => {
  console.log('✅ MongoDB connected');
});

mongoose.connection.on('error', (err) => {
  console.error('❌ MongoDB error:', err);
});

mongoose.connection.on('disconnected', () => {
  console.log('⚠️ MongoDB disconnected');
});
```

### 3. Graceful Shutdown

✅ **Good:**
```javascript
process.on('SIGINT', async () => {
  await mongoose.connection.close();
  console.log('MongoDB disconnected on app termination');
  process.exit(0);
});
```

---

## Code Organization

### 1. Separate Models

✅ **Good:**
```
models/
  User.js
  Post.js
  Comment.js
```

### 2. Use Controllers

✅ **Good:**
```javascript
// controllers/userController.js
exports.getUsers = async (req, res) => {
  try {
    const users = await User.find().select('name email');
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// routes/userRoutes.js
const { getUsers } = require('../controllers/userController');
router.get('/users', getUsers);
```

---

## Common Pitfalls

### 1. Forgetting runValidators on Update

❌ **Bad:**
```javascript
await User.updateOne({ _id: id }, { age: -5 });
// ❌ Validation doesn't run
```

✅ **Good:**
```javascript
await User.updateOne(
  { _id: id },
  { age: 30 },
  { runValidators: true }
);
```

### 2. Not Using new: true

❌ **Bad:**
```javascript
const user = await User.findByIdAndUpdate(id, { name: 'Jane' });
// Returns old document
```

✅ **Good:**
```javascript
const user = await User.findByIdAndUpdate(
  id,
  { name: 'Jane' },
  { new: true }
);
```

### 3. Over-Populating

❌ **Bad:**
```javascript
const posts = await Post.find()
  .populate('author')
  .populate('comments')
  .populate('comments.user')
  .populate('tags');
// ❌ Too many joins, slow
```

✅ **Good:**
```javascript
const posts = await Post.find()
  .populate('author', 'name email');  // Only needed fields
```

---

## Performance Tips

✅ **Use indexes** on frequently queried fields  
✅ **Use lean()** for read-only data  
✅ **Select only needed fields**  
✅ **Use pagination** for large datasets  
✅ **Use projection** to exclude large fields  
✅ **Batch operations** with insertMany/bulkWrite  
❌ **Don't fetch all documents** without limit  
❌ **Don't over-index** (slows writes)  
❌ **Don't use Mixed type** unless necessary  

---

## Summary Checklist

**Schema Design:**
- ✅ Use proper types and validation
- ✅ Add timestamps
- ✅ Use virtuals for computed properties
- ✅ Add custom error messages

**Queries:**
- ✅ Use indexes
- ✅ Select only needed fields
- ✅ Use lean() for read-only
- ✅ Use pagination

**Security:**
- ✅ Hash passwords
- ✅ Sanitize input (trim, lowercase)
- ✅ Don't expose sensitive data
- ✅ Use environment variables

**Error Handling:**
- ✅ Try-catch blocks
- ✅ Handle ValidationError
- ✅ Handle duplicate key errors

**Code Organization:**
- ✅ Separate models, controllers, routes
- ✅ Use middleware for common logic
- ✅ Handle connection events

**Next**: Learn Performance & Optimization!
