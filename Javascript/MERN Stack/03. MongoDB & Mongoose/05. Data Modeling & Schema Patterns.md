# 05. Data Modeling & Schema Patterns

## Data Modeling Approaches

### 1. Embedding (Denormalization)

Store related data in a single document.

**Example - User with Address:**

```json
{
  "_id": ObjectId("..."),
  "name": "John Doe",
  "email": "john@example.com",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "zipCode": "10001"
  }
}
```

**Pros:**
- ✅ Single query to get all data
- ✅ Better performance
- ✅ Atomic operations

**Cons:**
- ❌ Document size limit (16MB)
- ❌ Data duplication
- ❌ Hard to update related data

**When to use:**
- One-to-One relationships
- One-to-Few relationships
- Data accessed together

---

### 2. Referencing (Normalization)

Store references to documents in other collections.

**Example - User and Posts:**

**Users collection:**
```json
{
  "_id": ObjectId("user123"),
  "name": "John Doe",
  "email": "john@example.com"
}
```

**Posts collection:**
```json
{
  "_id": ObjectId("..."),
  "title": "My Post",
  "content": "...",
  "author": ObjectId("user123")
}
```

**Pros:**
- ✅ No duplication
- ✅ Smaller documents
- ✅ Easy to update

**Cons:**
- ❌ Multiple queries needed
- ❌ No joins (use $lookup)

**When to use:**
- One-to-Many relationships
- Many-to-Many relationships
- Data updated independently

---

## Relationship Patterns

### One-to-One

**Embed when data is always accessed together:**

```json
{
  "_id": 1,
  "name": "John",
  "profile": {
    "bio": "Developer",
    "avatar": "avatar.jpg"
  }
}
```

### One-to-Few

**Embed small arrays:**

```json
{
  "_id": 1,
  "name": "John",
  "addresses": [
    { "type": "home", "city": "NYC" },
    { "type": "work", "city": "LA" }
  ]
}
```

### One-to-Many

**Reference for large collections:**

**Author:**
```json
{
  "_id": ObjectId("author1"),
  "name": "John Doe"
}
```

**Books:**
```json
{
  "_id": ObjectId("book1"),
  "title": "MongoDB Guide",
  "author_id": ObjectId("author1")
}
```

### Many-to-Many

**Students and Courses:**

**Students:**
```json
{
  "_id": ObjectId("student1"),
  "name": "Alice",
  "courses": [
    ObjectId("course1"),
    ObjectId("course2")
  ]
}
```

**Courses:**
```json
{
  "_id": ObjectId("course1"),
  "name": "MongoDB",
  "students": [
    ObjectId("student1"),
    ObjectId("student2")
  ]
}
```

---

## Schema Design Patterns

### 1. Attribute Pattern

Store variable attributes in array.

**Problem:** Products with different specs

**Solution:**
```json
{
  "name": "Laptop",
  "specs": [
    { "key": "RAM", "value": "16GB" },
    { "key": "CPU", "value": "i7" },
    { "key": "Storage", "value": "512GB" }
  ]
}
```

### 2. Bucket Pattern

Group time-series data into buckets.

**Problem:** IoT sensor data (millions of records)

**Solution:**
```json
{
  "sensor_id": "sensor1",
  "date": "2024-01-01",
  "measurements": [
    { "time": "00:00", "temp": 20 },
    { "time": "01:00", "temp": 21 },
    { "time": "02:00", "temp": 19 }
  ]
}
```

### 3. Computed Pattern

Pre-calculate values to avoid runtime computation.

**Example - Total revenue:**
```json
{
  "order_id": 1,
  "items": [
    { "name": "Item1", "price": 100 },
    { "name": "Item2", "price": 50 }
  ],
  "total": 150  // Pre-computed
}
```

### 4. Subset Pattern

Store subset of data for frequent access.

**Problem:** Product with 1000 reviews

**Solution:**
```json
{
  "_id": "product1",
  "name": "Laptop",
  "recent_reviews": [
    { "rating": 5, "comment": "Great!" },
    { "rating": 4, "comment": "Good" }
  ],
  "total_reviews": 1000,
  "avg_rating": 4.5
}
```

Full reviews in separate collection.

### 5. Extended Reference Pattern

Copy frequently accessed fields.

**Orders with customer info:**
```json
{
  "order_id": 1,
  "customer": {
    "_id": ObjectId("customer1"),
    "name": "John Doe",  // Copied for quick access
    "email": "john@example.com"  // Copied
  },
  "items": [...]
}
```

---

## Design Principles

### Favor Embedding When:

✅ One-to-Few relationship  
✅ Data accessed together  
✅ Data doesn't change often  
✅ Atomic updates needed  

### Favor Referencing When:

✅ One-to-Many relationship  
✅ Many-to-Many relationship  
✅ Data changes frequently  
✅ Data accessed independently  
✅ Large documents (avoid 16MB limit)  

---

## Practical Examples

### Blog Application

**Users (Reference):**
```json
{
  "_id": ObjectId("user1"),
  "username": "john_doe",
  "email": "john@example.com"
}
```

**Posts (Embed comments, reference author):**
```json
{
  "_id": ObjectId("post1"),
  "title": "My First Post",
  "content": "...",
  "author": ObjectId("user1"),
  "comments": [
    {
      "user": "alice",
      "text": "Great post!",
      "date": ISODate("2024-01-01")
    }
  ],
  "tags": ["mongodb", "tutorial"]
}
```

### E-commerce

**Products:**
```json
{
  "_id": ObjectId("product1"),
  "name": "Laptop",
  "price": 999,
  "category": "Electronics",
  "inventory": {
    "quantity": 50,
    "warehouse": "NYC"
  },
  "reviews": [
    { "rating": 5, "comment": "Excellent!" }
  ]
}
```

**Orders (Reference products):**
```json
{
  "_id": ObjectId("order1"),
  "customer_id": ObjectId("user1"),
  "items": [
    {
      "product_id": ObjectId("product1"),
      "quantity": 1,
      "price": 999
    }
  ],
  "total": 999,
  "status": "shipped"
}
```

---

## Anti-Patterns to Avoid

❌ **Massive arrays**: Unbounded arrays grow indefinitely  
❌ **Massive documents**: Approaching 16MB limit  
❌ **Unnecessary indexes**: Slow writes  
❌ **Bloated documents**: Unused fields  
❌ **Case-sensitive queries**: Without proper indexing  

---

## Summary

**Embedding:**
- Store related data together
- Fast reads, single query
- Use for 1-to-1, 1-to-Few

**Referencing:**
- Store IDs to other documents
- Avoid duplication
- Use for 1-to-Many, Many-to-Many

**Design Patterns:**
- **Attribute**: Variable fields
- **Bucket**: Time-series data
- **Computed**: Pre-calculate values
- **Subset**: Recent/important data
- **Extended Reference**: Copy frequently accessed fields

**Rule of Thumb:**
```
If data is accessed together → Embed
If data changes independently → Reference
```

**Next**: Learn Indexing & Performance!
