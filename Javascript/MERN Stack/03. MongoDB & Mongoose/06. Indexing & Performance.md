# 06. Indexing & Performance

## What are Indexes?

Indexes improve query performance by reducing the number of documents MongoDB scans.

**Without Index**: Scans all documents (COLLSCAN)  
**With Index**: Scans only indexed documents (IXSCAN)  

---

## Creating Indexes

### Single Field Index

```javascript
// Create index on email field
db.users.createIndex({ email: 1 });

// 1 = ascending, -1 = descending
db.users.createIndex({ age: -1 });
```

### Compound Index

Index on multiple fields:

```javascript
db.users.createIndex({ city: 1, age: -1 });
```

### Unique Index

Ensure field values are unique:

```javascript
db.users.createIndex({ email: 1 }, { unique: true });
```

### Text Index

For text search:

```javascript
db.posts.createIndex({ title: "text", content: "text" });

// Search
db.posts.find({ $text: { $search: "mongodb tutorial" } });
```

---

## Index Types

### 1. Single Field

```javascript
db.users.createIndex({ name: 1 });
```

### 2. Compound

```javascript
db.users.createIndex({ city: 1, age: 1 });
```

### 3. Multikey (Arrays)

```javascript
db.posts.createIndex({ tags: 1 });
```

### 4. Text

```javascript
db.articles.createIndex({ content: "text" });
```

### 5. Geospatial

```javascript
db.places.createIndex({ location: "2dsphere" });
```

---

## Index Management

### View Indexes

```javascript
// List all indexes
db.users.getIndexes();
```

### Drop Index

```javascript
// Drop by name
db.users.dropIndex("email_1");

// Drop by specification
db.users.dropIndex({ email: 1 });

// Drop all indexes (except _id)
db.users.dropIndexes();
```

### Index Names

```javascript
// Custom name
db.users.createIndex(
  { email: 1 },
  { name: "email_unique_index" }
);
```

---

## Query Performance

### Explain Plan

```javascript
// Check query execution
db.users.find({ email: "john@example.com" }).explain("executionStats");
```

**Output:**
```json
{
  "executionStats": {
    "executionTimeMillis": 0,
    "totalDocsExamined": 1,
    "nReturned": 1,
    "executionStages": {
      "stage": "IXSCAN",  // Index scan (good)
      "indexName": "email_1"
    }
  }
}
```

**Stages:**
- `IXSCAN`: Index scan ✅ (good)
- `COLLSCAN`: Collection scan ❌ (slow)

---

## Performance Best Practices

### 1. Index Frequently Queried Fields

```javascript
// If you query by email often
db.users.createIndex({ email: 1 });
```

### 2. Use Compound Indexes

```javascript
// For queries like: city='NYC' AND age>25
db.users.createIndex({ city: 1, age: 1 });
```

**Order matters:**
```javascript
// Good for: city='NYC' AND age>25
db.users.createIndex({ city: 1, age: 1 });

// Also good for: city='NYC'
// NOT optimal for: age>25 only
```

### 3. Limit Fields Returned

```javascript
// Only get needed fields
db.users.find(
  { city: "NYC" },
  { name: 1, email: 1, _id: 0 }
);
```

### 4. Use Projection

```javascript
// Exclude large fields
db.users.find({}, { largeField: 0 });
```

### 5. Limit Results

```javascript
db.users.find({ city: "NYC" }).limit(10);
```

---

## Covered Queries

Query satisfied entirely by index (fastest):

```javascript
// Create index
db.users.createIndex({ name: 1, age: 1 });

// Covered query (only name and age)
db.users.find(
  { name: "John" },
  { name: 1, age: 1, _id: 0 }
);
```

---

## Index Impact

**Pros:**
- ✅ Faster reads
- ✅ Better query performance
- ✅ Efficient sorting

**Cons:**
- ❌ Slower writes (index must be updated)
- ❌ More storage space
- ❌ Memory usage

**Rule:** Create indexes for read-heavy queries

---

## Common Patterns

### Equality + Sort

```javascript
// Query: { status: 'active' } + sort by createdAt
db.orders.createIndex({ status: 1, createdAt: -1 });
```

### Equality + Range

```javascript
// Query: { city: 'NYC', age: { $gt: 25 } }
db.users.createIndex({ city: 1, age: 1 });
```

### Multiple Equalities

```javascript
// Query: { status: 'active', type: 'premium' }
db.users.createIndex({ status: 1, type: 1 });
```

---

## Monitoring Performance

### Current Operations

```javascript
db.currentOp();
```

### Database Stats

```javascript
db.stats();
```

### Collection Stats

```javascript
db.users.stats();
```

### Index Stats

```javascript
db.users.aggregate([{ $indexStats: {} }]);
```

---

## Performance Tips

✅ **Index queries you run often**  
✅ **Use compound indexes** for multi-field queries  
✅ **Limit returned documents**  
✅ **Use projection** to exclude large fields  
✅ **Monitor with explain()**  
✅ **Drop unused indexes**  
❌ **Don't over-index** (slows writes)  
❌ **Don't index low-cardinality fields** (e.g., boolean)  

---

## Summary

**Indexes:**
- Speed up queries
- Created on fields
- Cost: slower writes, more storage

**Create Index:**
```javascript
db.collection.createIndex({ field: 1 });
db.collection.createIndex({ field1: 1, field2: -1 });
```

**Check Performance:**
```javascript
db.collection.find({}).explain("executionStats");
```

**Best Practice:**
- Index frequently queried fields
- Use explain() to verify
- Balance reads vs writes

**Next**: Learn Aggregation Framework!
