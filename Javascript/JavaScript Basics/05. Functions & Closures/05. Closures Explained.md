# Closures Explained

A closure is a function that has access to variables from its outer (enclosing) scope, even after the outer function has finished executing. Closures are one of JavaScript's most powerful features.

---

## Understanding Closures

### Basic Closure
```javascript
function outer() {
  const message = "Hello";
  
  function inner() {
    console.log(message);  // Accesses outer's variable
  }
  
  return inner;
}

const myFunction = outer();
myFunction();  // "Hello" - message is still accessible
```

### How It Works
```javascript
function createCounter() {
  let count = 0;  // Private variable
  
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3

// Each call remembers the previous count
```

---

## Closure Scope Chain

Closures have access to three scope levels:
1. Their own scope
2. Outer function's scope
3. Global scope

```javascript
const globalVar = "global";

function outer() {
  const outerVar = "outer";
  
  function inner() {
    const innerVar = "inner";
    
    console.log(innerVar);   // Own scope
    console.log(outerVar);   // Outer scope
    console.log(globalVar);  // Global scope
  }
  
  return inner;
}

const myFunc = outer();
myFunc();
// "inner"
// "outer"
// "global"
```

---

## Multiple Closures

Each closure maintains its own independent environment.

```javascript
function createCounter() {
  let count = 0;
  
  return function() {
    count++;
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1());  // 1
console.log(counter1());  // 2

console.log(counter2());  // 1 (independent)
console.log(counter2());  // 2

console.log(counter1());  // 3 (maintains its own count)
```

---

## Closures with Parameters

### Factory Functions
```javascript
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

### Configuration Functions
```javascript
function createGreeter(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

console.log(sayHello("John"));  // "Hello, John!"
console.log(sayHi("Jane"));     // "Hi, Jane!"
```

---

## Private Variables and Methods

Closures enable true private variables in JavaScript.

### Basic Private Variable
```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance;  // Private
  
  return {
    deposit(amount) {
      if (amount > 0) {
        balance += amount;
        return balance;
      }
      throw new Error("Amount must be positive");
    },
    
    withdraw(amount) {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        return balance;
      }
      throw new Error("Invalid amount");
    },
    
    getBalance() {
      return balance;
    }
  };
}

const account = createBankAccount(100);
console.log(account.deposit(50));      // 150
console.log(account.withdraw(30));     // 120
console.log(account.getBalance());     // 120
console.log(account.balance);          // undefined (private)
```

### Multiple Private Variables
```javascript
function createUser(username, password) {
  let loginAttempts = 0;
  let isLocked = false;
  const MAX_ATTEMPTS = 3;
  
  // Private method
  function resetAttempts() {
    loginAttempts = 0;
    isLocked = false;
  }
  
  return {
    login(inputPassword) {
      if (isLocked) {
        return "Account locked. Try again later.";
      }
      
      if (inputPassword === password) {
        resetAttempts();
        return `Welcome, ${username}!`;
      }
      
      loginAttempts++;
      
      if (loginAttempts >= MAX_ATTEMPTS) {
        isLocked = true;
        return "Account locked due to too many failed attempts";
      }
      
      return `Incorrect password. ${MAX_ATTEMPTS - loginAttempts} attempts remaining`;
    },
    
    getUsername() {
      return username;
    },
    
    changePassword(oldPassword, newPassword) {
      if (oldPassword === password) {
        password = newPassword;
        return "Password changed successfully";
      }
      return "Incorrect old password";
    }
  };
}

const user = createUser("john", "secret123");
console.log(user.login("wrong"));      // "Incorrect password. 2 attempts remaining"
console.log(user.login("wrong"));      // "Incorrect password. 1 attempts remaining"
console.log(user.login("wrong"));      // "Account locked..."
console.log(user.login("secret123"));  // "Account locked..."
```

---

## Common Closure Patterns

### 1. Counter Pattern
```javascript
function createCounter(initialValue = 0) {
  let count = initialValue;
  
  return {
    increment() {
      return ++count;
    },
    
    decrement() {
      return --count;
    },
    
    reset() {
      count = initialValue;
      return count;
    },
    
    getValue() {
      return count;
    }
  };
}

const counter = createCounter(5);
console.log(counter.increment());  // 6
console.log(counter.decrement());  // 5
console.log(counter.reset());      // 5
```

### 2. Module Pattern
```javascript
const calculator = (function() {
  // Private state
  let result = 0;
  
  // Private helper
  function log(operation, value) {
    console.log(`${operation}: ${value}`);
  }
  
  // Public API
  return {
    add(n) {
      result += n;
      log("Added", n);
      return this;
    },
    
    subtract(n) {
      result -= n;
      log("Subtracted", n);
      return this;
    },
    
    multiply(n) {
      result *= n;
      log("Multiplied", n);
      return this;
    },
    
    getResult() {
      return result;
    },
    
    clear() {
      result = 0;
      return this;
    }
  };
})();

calculator.add(5).multiply(2).subtract(3);
console.log(calculator.getResult());  // 7
```

### 3. Event Handler with Closure
```javascript
function setupButton(buttonId) {
  let clickCount = 0;
  
  const button = document.getElementById(buttonId);
  
  button.addEventListener("click", function() {
    clickCount++;
    button.textContent = `Clicked ${clickCount} times`;
  });
  
  return {
    getClickCount() {
      return clickCount;
    },
    
    reset() {
      clickCount = 0;
      button.textContent = "Click me";
    }
  };
}

const btnController = setupButton("myButton");
// After clicking 3 times
console.log(btnController.getClickCount());  // 3
btnController.reset();
```

### 4. Memoization
```javascript
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      console.log("From cache");
      return cache[key];
    }
    
    console.log("Computing...");
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(40));  // Computing... (slow first time)
console.log(memoizedFib(40));  // From cache (instant)
```

### 5. Once Function
```javascript
function once(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn(...args);
    }
    return result;
  };
}

const initialize = once(() => {
  console.log("Initializing...");
  return { initialized: true };
});

initialize();  // "Initializing..."
initialize();  // Returns cached result, doesn't log
initialize();  // Returns cached result, doesn't log
```

---

## Closures in Loops

### Classic Problem with var
```javascript
// ✗ Problem - all buttons show "5"
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);  // Always logs 5
  }, 1000);
}
```

### Solution 1: IIFE
```javascript
// ✓ Solution - create new scope with IIFE
for (var i = 0; i < 5; i++) {
  (function(index) {
    setTimeout(function() {
      console.log(index);  // Logs 0, 1, 2, 3, 4
    }, 1000);
  })(i);
}
```

### Solution 2: let (ES6)
```javascript
// ✓ Modern solution - let creates block scope
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);  // Logs 0, 1, 2, 3, 4
  }, 1000);
}
```

### Solution 3: forEach
```javascript
// ✓ Alternative - forEach creates function scope
[0, 1, 2, 3, 4].forEach(function(i) {
  setTimeout(function() {
    console.log(i);  // Logs 0, 1, 2, 3, 4
  }, 1000);
});
```

---

## Practical Examples

### 1. API Client with Configuration
```javascript
function createApiClient(baseUrl, apiKey) {
  // Private configuration
  const defaultHeaders = {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${apiKey}`
  };
  
  async function request(endpoint, options = {}) {
    const url = `${baseUrl}${endpoint}`;
    const config = {
      ...options,
      headers: {
        ...defaultHeaders,
        ...options.headers
      }
    };
    
    const response = await fetch(url, config);
    return response.json();
  }
  
  return {
    get(endpoint) {
      return request(endpoint, { method: "GET" });
    },
    
    post(endpoint, data) {
      return request(endpoint, {
        method: "POST",
        body: JSON.stringify(data)
      });
    },
    
    put(endpoint, data) {
      return request(endpoint, {
        method: "PUT",
        body: JSON.stringify(data)
      });
    },
    
    delete(endpoint) {
      return request(endpoint, { method: "DELETE" });
    }
  };
}

const api = createApiClient("https://api.example.com", "secret-key");
api.get("/users").then(users => console.log(users));
```

### 2. Rate Limiter
```javascript
function createRateLimiter(maxCalls, timeWindow) {
  const calls = [];
  
  return function(fn) {
    return function(...args) {
      const now = Date.now();
      
      // Remove old calls outside time window
      while (calls.length && calls[0] < now - timeWindow) {
        calls.shift();
      }
      
      if (calls.length < maxCalls) {
        calls.push(now);
        return fn(...args);
      }
      
      throw new Error("Rate limit exceeded");
    };
  };
}

const limiter = createRateLimiter(3, 1000);  // 3 calls per second

const limitedFunction = limiter(() => {
  console.log("Function executed");
});

limitedFunction();  // Works
limitedFunction();  // Works
limitedFunction();  // Works
// limitedFunction();  // Error: Rate limit exceeded
```

### 3. Cache with Expiration
```javascript
function createCache(expirationTime = 5000) {
  const cache = new Map();
  
  function isExpired(timestamp) {
    return Date.now() - timestamp > expirationTime;
  }
  
  return {
    set(key, value) {
      cache.set(key, {
        value,
        timestamp: Date.now()
      });
    },
    
    get(key) {
      const item = cache.get(key);
      
      if (!item) return null;
      
      if (isExpired(item.timestamp)) {
        cache.delete(key);
        return null;
      }
      
      return item.value;
    },
    
    has(key) {
      return this.get(key) !== null;
    },
    
    clear() {
      cache.clear();
    },
    
    size() {
      // Clean expired items
      for (const [key, item] of cache.entries()) {
        if (isExpired(item.timestamp)) {
          cache.delete(key);
        }
      }
      return cache.size;
    }
  };
}

const cache = createCache(3000);  // 3 seconds expiration
cache.set("user", { name: "John" });

console.log(cache.get("user"));  // { name: "John" }

setTimeout(() => {
  console.log(cache.get("user"));  // null (expired)
}, 4000);
```

### 4. Debounce
```javascript
function debounce(fn, delay) {
  let timerId;
  
  return function(...args) {
    clearTimeout(timerId);
    
    timerId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

const handleSearch = debounce((query) => {
  console.log("Searching for:", query);
}, 500);

// Only the last call executes after 500ms
handleSearch("a");
handleSearch("ab");
handleSearch("abc");  // Only this executes
```

### 5. Throttle
```javascript
function throttle(fn, limit) {
  let inThrottle;
  
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

const handleScroll = throttle(() => {
  console.log("Scroll event");
}, 1000);

window.addEventListener("scroll", handleScroll);
// Executes at most once per second
```

---

## Memory Considerations

### Memory Leak Example
```javascript
// ✗ Memory leak - huge array retained in closure
function createHandler() {
  const hugeArray = new Array(1000000).fill("data");
  
  return function() {
    console.log("Handler called");
    // hugeArray is kept in memory even if not used
  };
}
```

### Fixed Version
```javascript
// ✓ Better - only keep what you need
function createHandler() {
  const hugeArray = new Array(1000000).fill("data");
  const neededData = hugeArray[0];  // Extract only what's needed
  
  return function() {
    console.log("Handler called", neededData);
    // Only neededData is kept in memory
  };
}
```

---

## Best Practices

### 1. Minimize Closure Scope
```javascript
// ✓ Good - only close over what you need
function createCounter(step) {
  let count = 0;
  return () => (count += step);
}

// ✗ Bad - closes over unnecessary variables
function createCounter(step, x, y, z) {
  let count = 0;
  return () => (count += step);  // x, y, z still in closure
}
```

### 2. Avoid Accidental Closures
```javascript
// ✗ Bad - unintentional closure
for (var i = 0; i < items.length; i++) {
  items[i].onclick = function() {
    console.log(i);  // Closes over i
  };
}

// ✓ Good - use let or explicit parameter
for (let i = 0; i < items.length; i++) {
  items[i].onclick = function() {
    console.log(i);
  };
}
```

---

## Key Takeaways

- Closures allow functions to access outer scope variables
- Created when a function is defined, not when executed
- Each closure has independent scope
- Enable private variables and data encapsulation
- Foundation for many JavaScript patterns (module, factory, etc.)
- Used in callbacks, event handlers, and async operations
- Can cause memory leaks if not careful
- Essential for functional programming in JavaScript
- Persist outer scope even after outer function returns
- Powerful but must be used thoughtfully for memory efficiency
