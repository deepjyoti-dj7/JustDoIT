# Function Declarations & Expressions

JavaScript has multiple ways to define functions, each with different characteristics and use cases.

---

## Function Declaration

### Basic Syntax
```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

console.log(greet("John"));  // "Hello, John!"
```

### Characteristics
- **Hoisted**: Can be called before declaration
- **Named**: Has a name in the current scope
- **this binding**: Dynamic (depends on how it's called)

### Hoisting Example
```javascript
// ✓ Works - function is hoisted
console.log(greet("John"));

function greet(name) {
  return `Hello, ${name}!`;
}
```

---

## Function Expression

### Basic Syntax
```javascript
const greet = function(name) {
  return `Hello, ${name}!`;
};

console.log(greet("John"));  // "Hello, John!"
```

### Characteristics
- **Not hoisted**: Cannot be called before assignment
- **Anonymous or named**: Can have optional name
- **Assigned to variable**: Like any other value

### Hoisting Difference
```javascript
// ✗ Error - function expression not hoisted
console.log(greet("John"));  // ReferenceError

const greet = function(name) {
  return `Hello, ${name}!`;
};
```

---

## Named Function Expression

```javascript
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1);  // Recursive call using name
};

console.log(factorial(5));  // 120

// Name only available inside function
console.log(fact);  // ReferenceError (outside scope)
```

### Benefits of Named Expressions
```javascript
// Better stack traces
const calculate = function calculateTotal(items) {
  // Error stack will show "calculateTotal" not "anonymous"
  return items.reduce((sum, item) => sum + item.price, 0);
};

// Recursion
const countdown = function count(n) {
  if (n <= 0) return;
  console.log(n);
  count(n - 1);  // Recursive call
};
```

---

## Arrow Functions (ES6+)

### Basic Syntax
```javascript
const greet = (name) => {
  return `Hello, ${name}!`;
};

// Implicit return (single expression)
const greet = name => `Hello, ${name}!`;

console.log(greet("John"));  // "Hello, John!"
```

### Characteristics
- **Not hoisted**: Like function expressions
- **Lexical this**: Inherits this from parent scope
- **Cannot be constructor**: No new keyword
- **No arguments object**: Use rest parameters instead

---

## Comparing Declaration vs Expression

### Function Declaration
```javascript
function add(a, b) {
  return a + b;
}

// Hoisted
sayHello();  // Works

function sayHello() {
  console.log("Hello!");
}
```

### Function Expression
```javascript
const add = function(a, b) {
  return a + b;
};

// Not hoisted
sayHello();  // Error

const sayHello = function() {
  console.log("Hello!");
};
```

---

## Use Cases

### 1. Function Declaration for Top-Level Functions
```javascript
// Main application functions
function initializeApp() {
  setupEventListeners();
  loadData();
}

function setupEventListeners() {
  // ...
}

function loadData() {
  // ...
}

// Can call before declaration
initializeApp();
```

### 2. Function Expression for Conditional Functions
```javascript
let operation;

if (userPreference === "add") {
  operation = function(a, b) {
    return a + b;
  };
} else {
  operation = function(a, b) {
    return a - b;
  };
}

console.log(operation(5, 3));
```

### 3. Function Expression for Callbacks
```javascript
const numbers = [1, 2, 3, 4, 5];

// Anonymous function expression
const doubled = numbers.map(function(num) {
  return num * 2;
});

// Arrow function (preferred for callbacks)
const tripled = numbers.map(num => num * 3);
```

### 4. Named Expression for Recursion
```javascript
const fibonacci = function fib(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
};

console.log(fibonacci(7));  // 13
```

---

## Parameters and Arguments

### Default Parameters
```javascript
function greet(name = "Guest", message = "Hello") {
  return `${message}, ${name}!`;
}

console.log(greet());              // "Hello, Guest!"
console.log(greet("John"));        // "Hello, John!"
console.log(greet("John", "Hi"));  // "Hi, John!"
```

### Rest Parameters
```javascript
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15
```

### Arguments Object (Only Regular Functions)
```javascript
function oldStyle() {
  console.log(arguments);  // Array-like object
  console.log(arguments[0]);
  console.log(arguments.length);
}

oldStyle(1, 2, 3);
// { '0': 1, '1': 2, '2': 3 }
// 1
// 3

// ✗ Arrow functions don't have arguments
const arrowFunc = () => {
  console.log(arguments);  // ReferenceError
};
```

---

## Return Values

### Explicit Return
```javascript
function add(a, b) {
  return a + b;
}

const result = add(5, 3);  // 8
```

### Implicit Return (Arrow Functions)
```javascript
const add = (a, b) => a + b;

// For objects, wrap in parentheses
const makePerson = (name, age) => ({ name, age });
```

### No Return (undefined)
```javascript
function greet(name) {
  console.log(`Hello, ${name}`);
  // No return statement
}

const result = greet("John");  // undefined
```

---

## Practical Examples

### 1. Factory Functions
```javascript
function createUser(name, role = "user") {
  return {
    name,
    role,
    login() {
      console.log(`${this.name} logged in`);
    },
    logout() {
      console.log(`${this.name} logged out`);
    }
  };
}

const user = createUser("John", "admin");
user.login();  // "John logged in"
```

### 2. Higher-Order Functions
```javascript
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

### 3. Function as Config
```javascript
const config = {
  api: "https://api.example.com",
  
  getUrl: function(endpoint) {
    return `${this.api}${endpoint}`;
  },
  
  // Method shorthand (ES6)
  formatResponse(data) {
    return {
      status: "success",
      data: data,
      timestamp: Date.now()
    };
  }
};

console.log(config.getUrl("/users"));
```

### 4. Event Handlers
```javascript
// Function declaration for named handler
function handleClick(event) {
  console.log("Button clicked at:", event.clientX, event.clientY);
}

button.addEventListener("click", handleClick);

// Function expression for inline handler
button.addEventListener("click", function(event) {
  console.log("Inline handler");
});

// Arrow function (lexical this)
class Component {
  constructor() {
    this.count = 0;
    
    button.addEventListener("click", () => {
      this.count++;  // 'this' refers to Component instance
      console.log(this.count);
    });
  }
}
```

---

## Best Practices

### 1. Use Function Declarations for Main Functions
```javascript
// ✓ Good - hoisted, clear intent
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### 2. Use Arrow Functions for Callbacks
```javascript
// ✓ Good - concise, preserves this
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
```

### 3. Use Named Expressions for Recursion
```javascript
// ✓ Good - name helps with debugging
const factorial = function fact(n) {
  return n <= 1 ? 1 : n * fact(n - 1);
};
```

### 4. Use const for Function Expressions
```javascript
// ✓ Good - prevents reassignment
const calculate = function(a, b) {
  return a + b;
};

// ✗ Avoid
let calculate = function(a, b) {  // Can be reassigned
  return a + b;
};
```

### 5. Meaningful Function Names
```javascript
// ✓ Good
function getUserById(id) { }
function calculateTotalPrice(items) { }

// ✗ Avoid
function get(id) { }
function calc(items) { }
```

---

## Common Pitfalls

### 1. Hoisting Confusion
```javascript
// ✗ Error - function expression
console.log(greet("John"));

const greet = function(name) {
  return `Hello, ${name}`;
};
```

### 2. Arrow Functions as Methods
```javascript
// ✗ Bad - arrow function loses this
const obj = {
  name: "Object",
  greet: () => {
    console.log(this.name);  // undefined
  }
};

// ✓ Good - regular method
const obj = {
  name: "Object",
  greet() {
    console.log(this.name);  // "Object"
  }
};
```

### 3. Reassigning Function Declarations
```javascript
function doSomething() {
  console.log("Original");
}

// ✗ Can be reassigned (but shouldn't)
doSomething = function() {
  console.log("Modified");
};
```

---

## Key Takeaways

- **Function declarations** are hoisted and can be called before definition
- **Function expressions** are not hoisted, assigned to variables
- **Named function expressions** help with debugging and recursion
- **Arrow functions** have lexical this and implicit return
- Use declarations for main functions, expressions for callbacks
- const prevents accidental function reassignment
- Choose the right syntax based on use case
- Function declarations are hoisted, expressions are not
- Arrow functions cannot be used as constructors
- Regular functions have arguments object, arrows don't
