# Practical Use Cases

This guide demonstrates real-world applications of functions and closures in JavaScript, showing how these concepts solve common programming problems.

---

## 1. Data Privacy and Encapsulation

### Private Counter
```javascript
function createSecureCounter() {
  let count = 0;
  let maxValue = 100;
  
  return {
    increment() {
      if (count < maxValue) {
        count++;
        return count;
      }
      throw new Error(`Maximum value ${maxValue} reached`);
    },
    
    decrement() {
      if (count > 0) {
        count--;
        return count;
      }
      throw new Error("Cannot decrement below 0");
    },
    
    getValue() {
      return count;
    },
    
    setMaxValue(newMax) {
      if (newMax > count) {
        maxValue = newMax;
        return true;
      }
      return false;
    }
  };
}

const counter = createSecureCounter();
console.log(counter.increment());  // 1
console.log(counter.getValue());   // 1
console.log(counter.count);        // undefined (private)
```

### Private Banking System
```javascript
function createBankAccount(accountNumber, initialBalance) {
  let balance = initialBalance;
  const transactions = [];
  
  function addTransaction(type, amount) {
    transactions.push({
      type,
      amount,
      balance,
      timestamp: new Date()
    });
  }
  
  return {
    deposit(amount) {
      if (amount <= 0) {
        throw new Error("Deposit amount must be positive");
      }
      balance += amount;
      addTransaction("deposit", amount);
      return balance;
    },
    
    withdraw(amount) {
      if (amount <= 0) {
        throw new Error("Withdrawal amount must be positive");
      }
      if (amount > balance) {
        throw new Error("Insufficient funds");
      }
      balance -= amount;
      addTransaction("withdrawal", amount);
      return balance;
    },
    
    getBalance() {
      return balance;
    },
    
    getAccountNumber() {
      return accountNumber;
    },
    
    getTransactionHistory() {
      return [...transactions];  // Return copy
    }
  };
}

const account = createBankAccount("ACC001", 1000);
account.deposit(500);
account.withdraw(200);
console.log(account.getBalance());           // 1300
console.log(account.getTransactionHistory());
```

---

## 2. Memoization and Caching

### Basic Memoization
```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log("Cache hit");
      return cache.get(key);
    }
    
    console.log("Computing...");
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// Expensive operation
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(40));  // Computing... (slow)
console.log(memoizedFib(40));  // Cache hit (instant)
```

### Cache with TTL (Time To Live)
```javascript
function createCache(ttl = 5000) {
  const cache = new Map();
  
  return {
    set(key, value) {
      const expiresAt = Date.now() + ttl;
      cache.set(key, { value, expiresAt });
    },
    
    get(key) {
      const item = cache.get(key);
      
      if (!item) return null;
      
      if (Date.now() > item.expiresAt) {
        cache.delete(key);
        return null;
      }
      
      return item.value;
    },
    
    has(key) {
      return this.get(key) !== null;
    },
    
    clear() {
      cache.clear();
    },
    
    size() {
      // Clean expired items
      for (const [key, item] of cache.entries()) {
        if (Date.now() > item.expiresAt) {
          cache.delete(key);
        }
      }
      return cache.size;
    }
  };
}

const cache = createCache(3000);  // 3 seconds TTL
cache.set("user", { name: "John" });

console.log(cache.get("user"));  // { name: "John" }

setTimeout(() => {
  console.log(cache.get("user"));  // null (expired)
}, 4000);
```

---

## 3. Event Handling and DOM Manipulation

### Event Emitter Pattern
```javascript
function createEventEmitter() {
  const events = {};
  
  return {
    on(event, handler) {
      if (!events[event]) {
        events[event] = [];
      }
      events[event].push(handler);
      
      // Return unsubscribe function
      return () => {
        events[event] = events[event].filter(h => h !== handler);
      };
    },
    
    emit(event, data) {
      if (events[event]) {
        events[event].forEach(handler => handler(data));
      }
    },
    
    once(event, handler) {
      const wrappedHandler = (data) => {
        handler(data);
        this.off(event, wrappedHandler);
      };
      this.on(event, wrappedHandler);
    },
    
    off(event, handler) {
      if (events[event]) {
        events[event] = events[event].filter(h => h !== handler);
      }
    },
    
    removeAllListeners(event) {
      if (event) {
        delete events[event];
      } else {
        Object.keys(events).forEach(key => delete events[key]);
      }
    }
  };
}

const emitter = createEventEmitter();

const unsubscribe = emitter.on("data", (data) => {
  console.log("Data received:", data);
});

emitter.emit("data", { message: "Hello" });  // Logs data
unsubscribe();  // Unsubscribe
emitter.emit("data", { message: "World" });  // Nothing logged
```

### Button Click Counter
```javascript
function setupClickCounter(buttonId) {
  let clickCount = 0;
  let lastClickTime = null;
  const clickTimestamps = [];
  
  const button = document.getElementById(buttonId);
  
  function updateDisplay() {
    button.textContent = `Clicked ${clickCount} times`;
  }
  
  button.addEventListener("click", function() {
    const now = Date.now();
    clickCount++;
    clickTimestamps.push(now);
    lastClickTime = now;
    updateDisplay();
  });
  
  return {
    getCount() {
      return clickCount;
    },
    
    getLastClickTime() {
      return lastClickTime ? new Date(lastClickTime) : null;
    },
    
    getClickRate() {
      if (clickTimestamps.length < 2) return 0;
      
      const timeRange = clickTimestamps[clickTimestamps.length - 1] - clickTimestamps[0];
      return (clickTimestamps.length / timeRange) * 1000;  // Clicks per second
    },
    
    reset() {
      clickCount = 0;
      clickTimestamps.length = 0;
      lastClickTime = null;
      updateDisplay();
    }
  };
}

const btnController = setupClickCounter("myButton");
```

---

## 4. Debounce and Throttle

### Debounce (Wait for Pause)
```javascript
function debounce(fn, delay) {
  let timerId;
  
  return function(...args) {
    const context = this;
    
    clearTimeout(timerId);
    
    timerId = setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  };
}

// Search input handler
const handleSearch = debounce((query) => {
  console.log("Searching for:", query);
  // API call here
}, 500);

searchInput.addEventListener("input", (e) => {
  handleSearch(e.target.value);
});
// Only searches 500ms after user stops typing
```

### Throttle (Rate Limit)
```javascript
function throttle(fn, limit) {
  let inThrottle;
  let lastResult;
  
  return function(...args) {
    const context = this;
    
    if (!inThrottle) {
      lastResult = fn.apply(context, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
    
    return lastResult;
  };
}

// Scroll handler
const handleScroll = throttle(() => {
  const scrollTop = window.pageYOffset;
  console.log("Scroll position:", scrollTop);
}, 1000);

window.addEventListener("scroll", handleScroll);
// Executes at most once per second
```

### Debounce with Immediate Option
```javascript
function debounce(fn, delay, immediate = false) {
  let timerId;
  
  return function(...args) {
    const context = this;
    const callNow = immediate && !timerId;
    
    clearTimeout(timerId);
    
    timerId = setTimeout(() => {
      timerId = null;
      if (!immediate) {
        fn.apply(context, args);
      }
    }, delay);
    
    if (callNow) {
      fn.apply(context, args);
    }
  };
}

const handleClick = debounce(() => {
  console.log("Button clicked");
}, 1000, true);  // Executes immediately on first click
```

---

## 5. Configuration and Settings

### Application Config
```javascript
function createConfig(environment) {
  const configs = {
    development: {
      apiUrl: "http://localhost:3000",
      debug: true,
      logLevel: "verbose",
      cacheEnabled: false
    },
    staging: {
      apiUrl: "https://api.staging.com",
      debug: true,
      logLevel: "info",
      cacheEnabled: true
    },
    production: {
      apiUrl: "https://api.production.com",
      debug: false,
      logLevel: "error",
      cacheEnabled: true
    }
  };
  
  const config = configs[environment] || configs.development;
  const overrides = {};
  
  return {
    get(key) {
      return overrides[key] !== undefined ? overrides[key] : config[key];
    },
    
    set(key, value) {
      if (key in config) {
        overrides[key] = value;
        return true;
      }
      return false;
    },
    
    getAll() {
      return { ...config, ...overrides };
    },
    
    reset() {
      Object.keys(overrides).forEach(key => delete overrides[key]);
    },
    
    getEnvironment() {
      return environment;
    }
  };
}

const config = createConfig("production");
console.log(config.get("apiUrl"));
config.set("debug", true);  // Override for testing
console.log(config.getAll());
```

### Feature Flags
```javascript
function createFeatureFlags(initialFlags = {}) {
  const flags = { ...initialFlags };
  const listeners = [];
  
  function notifyChange(flag, value) {
    listeners.forEach(listener => listener(flag, value));
  }
  
  return {
    isEnabled(flag) {
      return flags[flag] === true;
    },
    
    enable(flag) {
      flags[flag] = true;
      notifyChange(flag, true);
    },
    
    disable(flag) {
      flags[flag] = false;
      notifyChange(flag, false);
    },
    
    toggle(flag) {
      flags[flag] = !flags[flag];
      notifyChange(flag, flags[flag]);
    },
    
    getAll() {
      return { ...flags };
    },
    
    onChange(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
      };
    }
  };
}

const features = createFeatureFlags({
  newUI: false,
  betaFeature: true,
  analytics: true
});

features.onChange((flag, value) => {
  console.log(`Feature ${flag} is now ${value ? "enabled" : "disabled"}`);
});

console.log(features.isEnabled("newUI"));  // false
features.enable("newUI");                  // Triggers onChange
```

---

## 6. API Client and Request Management

### HTTP Client with Interceptors
```javascript
function createHttpClient(baseUrl, defaultOptions = {}) {
  const requestInterceptors = [];
  const responseInterceptors = [];
  
  async function request(endpoint, options = {}) {
    let url = `${baseUrl}${endpoint}`;
    let config = { ...defaultOptions, ...options };
    
    // Apply request interceptors
    for (const interceptor of requestInterceptors) {
      const result = await interceptor({ url, config });
      url = result.url;
      config = result.config;
    }
    
    // Make request
    let response = await fetch(url, config);
    
    // Apply response interceptors
    for (const interceptor of responseInterceptors) {
      response = await interceptor(response);
    }
    
    return response;
  }
  
  return {
    get(endpoint, options = {}) {
      return request(endpoint, { ...options, method: "GET" });
    },
    
    post(endpoint, data, options = {}) {
      return request(endpoint, {
        ...options,
        method: "POST",
        body: JSON.stringify(data),
        headers: {
          "Content-Type": "application/json",
          ...options.headers
        }
      });
    },
    
    put(endpoint, data, options = {}) {
      return request(endpoint, {
        ...options,
        method: "PUT",
        body: JSON.stringify(data),
        headers: {
          "Content-Type": "application/json",
          ...options.headers
        }
      });
    },
    
    delete(endpoint, options = {}) {
      return request(endpoint, { ...options, method: "DELETE" });
    },
    
    addRequestInterceptor(interceptor) {
      requestInterceptors.push(interceptor);
    },
    
    addResponseInterceptor(interceptor) {
      responseInterceptors.push(interceptor);
    }
  };
}

const api = createHttpClient("https://api.example.com");

// Add auth header
api.addRequestInterceptor(({ url, config }) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers = {
      ...config.headers,
      Authorization: `Bearer ${token}`
    };
  }
  return { url, config };
});

// Handle errors
api.addResponseInterceptor(async (response) => {
  if (!response.ok) {
    throw new Error(`HTTP Error: ${response.status}`);
  }
  return response.json();
});

// Usage
api.get("/users").then(users => console.log(users));
```

---

## 7. State Management

### Simple State Manager
```javascript
function createStore(initialState = {}) {
  let state = { ...initialState };
  const listeners = [];
  
  function notify() {
    listeners.forEach(listener => listener(state));
  }
  
  return {
    getState() {
      return { ...state };  // Return copy
    },
    
    setState(updates) {
      state = { ...state, ...updates };
      notify();
    },
    
    subscribe(listener) {
      listeners.push(listener);
      
      // Return unsubscribe function
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    },
    
    reset() {
      state = { ...initialState };
      notify();
    }
  };
}

const store = createStore({ count: 0, user: null });

const unsubscribe = store.subscribe((state) => {
  console.log("State changed:", state);
});

store.setState({ count: 1 });
store.setState({ user: { name: "John" } });
```

---

## 8. Retry and Error Handling

### Retry with Exponential Backoff
```javascript
function createRetry(maxAttempts = 3, baseDelay = 1000) {
  return async function retry(fn, ...args) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await fn(...args);
      } catch (error) {
        lastError = error;
        
        if (attempt === maxAttempts) {
          throw new Error(`Failed after ${maxAttempts} attempts: ${error.message}`);
        }
        
        const delay = baseDelay * Math.pow(2, attempt - 1);
        console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
        
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  };
}

const retryFetch = createRetry(3, 1000);

async function fetchData(url) {
  const response = await fetch(url);
  if (!response.ok) throw new Error("Failed to fetch");
  return response.json();
}

retryFetch(fetchData, "https://api.example.com/data")
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

---

## 9. Rate Limiting

### Rate Limiter
```javascript
function createRateLimiter(maxCalls, timeWindow) {
  const queue = [];
  
  return function(fn) {
    return function(...args) {
      const now = Date.now();
      
      // Remove old calls outside time window
      while (queue.length && queue[0] < now - timeWindow) {
        queue.shift();
      }
      
      if (queue.length < maxCalls) {
        queue.push(now);
        return fn(...args);
      }
      
      throw new Error("Rate limit exceeded");
    };
  };
}

const limiter = createRateLimiter(5, 1000);  // 5 calls per second

const limitedApiCall = limiter((endpoint) => {
  console.log("Calling:", endpoint);
  return fetch(endpoint);
});

// Can call 5 times per second
for (let i = 0; i < 5; i++) {
  limitedApiCall("/api/data");
}
```

---

## 10. Function Once

### Execute Once
```javascript
function once(fn) {
  let called = false;
  let result;
  
  return function(...args) {
    if (!called) {
      called = true;
      result = fn.apply(this, args);
    }
    return result;
  };
}

const initialize = once(() => {
  console.log("Initializing application...");
  return { initialized: true, timestamp: Date.now() };
});

console.log(initialize());  // Logs and returns result
console.log(initialize());  // Returns cached result, doesn't log
console.log(initialize());  // Returns cached result, doesn't log
```

---

## Key Takeaways

- Closures enable data privacy and encapsulation
- Memoization improves performance for expensive operations
- Event emitters provide flexible pub/sub patterns
- Debounce and throttle optimize event handlers
- Configuration objects centralize application settings
- Factory functions create multiple independent instances
- State management patterns enable reactive applications
- Retry logic improves reliability with external services
- Rate limiting prevents API abuse
- Once pattern ensures single execution for initialization
- These patterns are fundamental to modern JavaScript applications
