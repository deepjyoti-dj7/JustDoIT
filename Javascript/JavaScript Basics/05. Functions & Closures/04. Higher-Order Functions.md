# Higher-Order Functions

Higher-order functions are functions that either take other functions as arguments, return functions, or both. They're fundamental to functional programming in JavaScript.

---

## Functions as Arguments

Functions can be passed as arguments to other functions.

### Basic Example
```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

function processUser(name, callback) {
  const result = callback(name);
  console.log(result);
}

processUser("John", greet);  // "Hello, John!"
```

### Multiple Callbacks
```javascript
function calculate(a, b, operation) {
  return operation(a, b);
}

const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

console.log(calculate(5, 3, add));       // 8
console.log(calculate(5, 3, multiply));  // 15
```

---

## Functions Returning Functions

Functions can create and return other functions.

### Basic Factory
```javascript
function createGreeter(greeting) {
  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

console.log(sayHello("John"));  // "Hello, John!"
console.log(sayHi("Jane"));     // "Hi, Jane!"
```

### With Arrow Functions
```javascript
const createMultiplier = (factor) => (number) => number * factor;

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

---

## Built-in Higher-Order Functions

JavaScript arrays have many built-in higher-order functions.

### map() - Transform Elements
```javascript
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

const squared = numbers.map(n => n * n);
console.log(squared);  // [1, 4, 9, 16, 25]
```

### filter() - Select Elements
```javascript
const numbers = [1, 2, 3, 4, 5, 6];

const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4, 6]

const greaterThan3 = numbers.filter(n => n > 3);
console.log(greaterThan3);  // [4, 5, 6]
```

### reduce() - Accumulate Values
```javascript
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120
```

### forEach() - Iterate with Side Effects
```javascript
const numbers = [1, 2, 3];

numbers.forEach((n, index) => {
  console.log(`Index ${index}: ${n}`);
});
// Index 0: 1
// Index 1: 2
// Index 2: 3
```

### find() - Find Element
```javascript
const users = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
  { id: 3, name: "Bob" }
];

const user = users.find(u => u.id === 2);
console.log(user);  // { id: 2, name: "Jane" }
```

### some() and every()
```javascript
const numbers = [1, 2, 3, 4, 5];

const hasEven = numbers.some(n => n % 2 === 0);
console.log(hasEven);  // true

const allPositive = numbers.every(n => n > 0);
console.log(allPositive);  // true

const allEven = numbers.every(n => n % 2 === 0);
console.log(allEven);  // false
```

---

## Function Composition

Combining multiple functions to create new functionality.

### Manual Composition
```javascript
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

// Nested calls
const result = square(double(addOne(3)));
console.log(result);  // 64 -> (3+1)*2 = 8, 8*8 = 64
```

### Compose Function
```javascript
function compose(...functions) {
  return function(x) {
    return functions.reduceRight((acc, fn) => fn(acc), x);
  };
}

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const transform = compose(square, double, addOne);
console.log(transform(3));  // 64
```

### Pipe Function (Left to Right)
```javascript
function pipe(...functions) {
  return function(x) {
    return functions.reduce((acc, fn) => fn(acc), x);
  };
}

const transform = pipe(addOne, double, square);
console.log(transform(3));  // 64
```

---

## Currying

Transforming a function with multiple arguments into a sequence of functions.

### Manual Currying
```javascript
// Regular function
function add(a, b, c) {
  return a + b + c;
}

// Curried version
function curriedAdd(a) {
  return function(b) {
    return function(c) {
      return a + b + c;
    };
  };
}

console.log(curriedAdd(1)(2)(3));  // 6

// With arrow functions
const curriedAdd = a => b => c => a + b + c;
console.log(curriedAdd(1)(2)(3));  // 6
```

### Generic Curry Function
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return function(...nextArgs) {
      return curried.apply(this, args.concat(nextArgs));
    };
  };
}

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3));     // 6
console.log(curriedAdd(1, 2)(3));     // 6
console.log(curriedAdd(1)(2, 3));     // 6
console.log(curriedAdd(1, 2, 3));     // 6
```

---

## Partial Application

Fixing some arguments of a function to create a new function.

### Using bind()
```javascript
function multiply(a, b) {
  return a * b;
}

const double = multiply.bind(null, 2);
const triple = multiply.bind(null, 3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

### Custom Partial Function
```javascript
function partial(fn, ...fixedArgs) {
  return function(...remainingArgs) {
    return fn(...fixedArgs, ...remainingArgs);
  };
}

function greet(greeting, name, punctuation) {
  return `${greeting}, ${name}${punctuation}`;
}

const sayHello = partial(greet, "Hello");
const sayHelloJohn = partial(greet, "Hello", "John");

console.log(sayHello("Alice", "!"));     // "Hello, Alice!"
console.log(sayHelloJohn("!"));          // "Hello, John!"
```

---

## Practical Examples

### 1. Array Transformation Pipeline
```javascript
const users = [
  { name: "John", age: 30, active: true },
  { name: "Jane", age: 25, active: false },
  { name: "Bob", age: 35, active: true },
  { name: "Alice", age: 28, active: true }
];

const result = users
  .filter(user => user.active)
  .map(user => user.name)
  .map(name => name.toUpperCase());

console.log(result);  // ["JOHN", "BOB", "ALICE"]
```

### 2. Event Handler Factory
```javascript
function createClickHandler(elementId, action) {
  return function(event) {
    const element = document.getElementById(elementId);
    action(element, event);
  };
}

const handler1 = createClickHandler("button1", (el, e) => {
  el.style.backgroundColor = "red";
});

const handler2 = createClickHandler("button2", (el, e) => {
  el.textContent = "Clicked!";
});

document.getElementById("button1").addEventListener("click", handler1);
document.getElementById("button2").addEventListener("click", handler2);
```

### 3. Validation Pipeline
```javascript
const validators = {
  required: (value) => value.trim() !== "",
  minLength: (min) => (value) => value.length >= min,
  maxLength: (max) => (value) => value.length <= max,
  pattern: (regex) => (value) => regex.test(value)
};

function validate(value, ...validationFns) {
  return validationFns.every(fn => fn(value));
}

const username = "john_doe";

const isValid = validate(
  username,
  validators.required,
  validators.minLength(3),
  validators.maxLength(20),
  validators.pattern(/^[a-z_]+$/)
);

console.log(isValid);  // true
```

### 4. Memoization
```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      console.log("From cache");
      return cache.get(key);
    }
    
    console.log("Computing...");
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);

console.log(memoizedFib(40));  // Computing... (takes time)
console.log(memoizedFib(40));  // From cache (instant)
```

### 5. Debounce
```javascript
function debounce(fn, delay) {
  let timerId;
  
  return function(...args) {
    clearTimeout(timerId);
    
    timerId = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

const handleInput = debounce((value) => {
  console.log("Searching for:", value);
}, 500);

// Usage
input.addEventListener("input", (e) => {
  handleInput(e.target.value);
});
```

### 6. Throttle
```javascript
function throttle(fn, limit) {
  let inThrottle;
  
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

const handleScroll = throttle(() => {
  console.log("Scrolling...");
}, 1000);

window.addEventListener("scroll", handleScroll);
```

### 7. Retry Logic
```javascript
function retry(fn, maxAttempts, delay) {
  return async function(...args) {
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        return await fn(...args);
      } catch (error) {
        if (attempt === maxAttempts) {
          throw error;
        }
        
        console.log(`Attempt ${attempt} failed, retrying...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  };
}

async function fetchData(url) {
  const response = await fetch(url);
  if (!response.ok) throw new Error("Failed");
  return response.json();
}

const retryFetch = retry(fetchData, 3, 1000);

retryFetch("https://api.example.com/data")
  .then(data => console.log(data))
  .catch(error => console.error("Failed after retries:", error));
```

### 8. Function Pipeline
```javascript
function pipeline(...fns) {
  return function(input) {
    return fns.reduce((acc, fn) => fn(acc), input);
  };
}

const trim = str => str.trim();
const toLowerCase = str => str.toLowerCase();
const capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);

const normalizeText = pipeline(trim, toLowerCase, capitalize);

console.log(normalizeText("  HELLO WORLD  "));  // "Hello world"
```

---

## Best Practices

### 1. Keep Functions Pure
```javascript
// ✓ Good - pure function
const double = (n) => n * 2;

// ✗ Bad - modifies external state
let count = 0;
const increment = () => count++;
```

### 2. Use Descriptive Names
```javascript
// ✓ Good
const filterActiveUsers = users => users.filter(u => u.active);

// ✗ Bad
const f = users => users.filter(u => u.active);
```

### 3. Compose Small Functions
```javascript
// ✓ Good - small, focused functions
const isEven = n => n % 2 === 0;
const square = n => n * n;

numbers.filter(isEven).map(square);

// ✗ Bad - doing too much
numbers.filter(n => n % 2 === 0).map(n => n * n);  // OK for simple cases
```

---

## Common Pitfalls

### 1. Losing this Context
```javascript
const obj = {
  name: "Object",
  greet() {
    setTimeout(function() {
      console.log(this.name);  // ✗ undefined
    }, 1000);
  }
};

// ✓ Use arrow function
const obj = {
  name: "Object",
  greet() {
    setTimeout(() => {
      console.log(this.name);  // "Object"
    }, 1000);
  }
};
```

### 2. Overusing Composition
```javascript
// ✗ Too complex
const result = pipe(fn1, fn2, fn3, fn4, fn5, fn6)(input);

// ✓ Break into steps
const step1 = pipe(fn1, fn2, fn3)(input);
const step2 = pipe(fn4, fn5, fn6)(step1);
```

---

## Key Takeaways

- Higher-order functions take functions as arguments or return functions
- Enable functional programming patterns
- Built-in array methods (map, filter, reduce) are higher-order functions
- Function composition combines multiple functions
- Currying transforms multi-argument functions into single-argument chains
- Partial application fixes some arguments to create specialized functions
- Useful for creating reusable, modular code
- Power patterns: memoization, debounce, throttle, retry
- Keep functions pure and small for better composition
- Essential for modern JavaScript development
