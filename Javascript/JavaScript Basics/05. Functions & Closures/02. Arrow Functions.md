# Arrow Functions (Closures Aspect)

Arrow functions have unique characteristics regarding closures and lexical scoping that make them powerful for certain use cases.

---

## Lexical this Binding

Arrow functions don't have their own `this` - they capture it from the surrounding scope.

### Problem with Regular Functions
```javascript
const counter = {
  count: 0,
  increment() {
    setTimeout(function() {
      this.count++;  // ✗ 'this' is undefined or window
      console.log(this.count);
    }, 1000);
  }
};

counter.increment();  // NaN or error
```

### Solution with Arrow Functions
```javascript
const counter = {
  count: 0,
  increment() {
    setTimeout(() => {
      this.count++;  // ✓ 'this' refers to counter
      console.log(this.count);
    }, 1000);
  }
};

counter.increment();  // 1 (after 1 second)
```

---

## Closures with Arrow Functions

Arrow functions create closures over their lexical scope.

### Capturing Variables
```javascript
function createCounter() {
  let count = 0;
  
  // Arrow function closes over 'count'
  return {
    increment: () => ++count,
    decrement: () => --count,
    getValue: () => count
  };
}

const counter = createCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getValue());   // 2
```

### Multiple Closures
```javascript
function makeMultiplier(factor) {
  // Each arrow function closes over 'factor'
  return {
    multiply: (n) => n * factor,
    square: () => factor * factor,
    getFactor: () => factor
  };
}

const times3 = makeMultiplier(3);
console.log(times3.multiply(10));  // 30
console.log(times3.square());      // 9
console.log(times3.getFactor());   // 3
```

---

## this in Nested Functions

### Regular Functions Lose this
```javascript
const user = {
  name: "John",
  hobbies: ["reading", "coding"],
  
  showHobbies() {
    this.hobbies.forEach(function(hobby) {
      // ✗ 'this' is undefined
      console.log(`${this.name} likes ${hobby}`);
    });
  }
};

user.showHobbies();  // "undefined likes reading..."
```

### Arrow Functions Preserve this
```javascript
const user = {
  name: "John",
  hobbies: ["reading", "coding"],
  
  showHobbies() {
    this.hobbies.forEach((hobby) => {
      // ✓ 'this' refers to user
      console.log(`${this.name} likes ${hobby}`);
    });
  }
};

user.showHobbies();
// "John likes reading"
// "John likes coding"
```

---

## Closures in Event Handlers

### Class Methods with Arrow Functions
```javascript
class Button {
  constructor(label) {
    this.label = label;
    this.clickCount = 0;
  }
  
  // Arrow function in constructor preserves 'this'
  setupHandler() {
    this.handleClick = () => {
      this.clickCount++;
      console.log(`${this.label} clicked ${this.clickCount} times`);
    };
    
    button.addEventListener("click", this.handleClick);
  }
  
  cleanup() {
    button.removeEventListener("click", this.handleClick);
  }
}

const btn = new Button("Submit");
btn.setupHandler();
```

### Factory Pattern
```javascript
function createClickHandler(elementId) {
  let clickCount = 0;
  
  // Arrow function closes over clickCount
  return () => {
    clickCount++;
    const element = document.getElementById(elementId);
    element.textContent = `Clicked ${clickCount} times`;
  };
}

const handler = createClickHandler("myButton");
button.addEventListener("click", handler);
```

---

## Array Methods and Closures

### map with Closure
```javascript
function createMapper(multiplier) {
  // Arrow function closes over multiplier
  return (array) => array.map(n => n * multiplier);
}

const double = createMapper(2);
const triple = createMapper(3);

console.log(double([1, 2, 3]));  // [2, 4, 6]
console.log(triple([1, 2, 3]));  // [3, 6, 9]
```

### filter with Closure
```javascript
function createFilter(threshold) {
  return (array) => array.filter(n => n > threshold);
}

const filterAbove10 = createFilter(10);
const filterAbove5 = createFilter(5);

console.log(filterAbove10([3, 8, 15, 20]));  // [15, 20]
console.log(filterAbove5([3, 8, 15, 20]));   // [8, 15, 20]
```

---

## Practical Examples

### 1. Private State with Arrow Functions
```javascript
function createAccount(initialBalance) {
  let balance = initialBalance;
  
  return {
    deposit: (amount) => {
      if (amount > 0) {
        balance += amount;
        return balance;
      }
      throw new Error("Amount must be positive");
    },
    
    withdraw: (amount) => {
      if (amount > 0 && amount <= balance) {
        balance -= amount;
        return balance;
      }
      throw new Error("Invalid amount");
    },
    
    getBalance: () => balance
  };
}

const account = createAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
account.withdraw(30);
console.log(account.getBalance());  // 120
console.log(account.balance);       // undefined (private)
```

### 2. Configuration Objects
```javascript
function createConfig(environment) {
  const configs = {
    development: {
      apiUrl: "http://localhost:3000",
      debug: true
    },
    production: {
      apiUrl: "https://api.example.com",
      debug: false
    }
  };
  
  const config = configs[environment];
  
  return {
    getApiUrl: () => config.apiUrl,
    isDebug: () => config.debug,
    getFullUrl: (endpoint) => `${config.apiUrl}${endpoint}`
  };
}

const devConfig = createConfig("development");
console.log(devConfig.getApiUrl());         // "http://localhost:3000"
console.log(devConfig.getFullUrl("/users")); // "http://localhost:3000/users"
```

### 3. Event Emitter with Closures
```javascript
function createEmitter() {
  const events = {};
  
  return {
    on: (event, handler) => {
      if (!events[event]) events[event] = [];
      events[event].push(handler);
    },
    
    emit: (event, data) => {
      if (events[event]) {
        events[event].forEach(handler => handler(data));
      }
    },
    
    off: (event, handler) => {
      if (events[event]) {
        events[event] = events[event].filter(h => h !== handler);
      }
    },
    
    getEventCount: () => Object.keys(events).length
  };
}

const emitter = createEmitter();
emitter.on("data", (data) => console.log("Data:", data));
emitter.emit("data", { message: "Hello" });
```

### 4. Memoization
```javascript
function memoize(fn) {
  const cache = {};
  
  return (...args) => {
    const key = JSON.stringify(args);
    
    if (key in cache) {
      console.log("From cache");
      return cache[key];
    }
    
    console.log("Computing...");
    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

const expensiveOperation = memoize((n) => {
  return n * n;
});

console.log(expensiveOperation(5));  // "Computing..." then 25
console.log(expensiveOperation(5));  // "From cache" then 25
```

### 5. Debounce with Arrow Function
```javascript
function debounce(fn, delay) {
  let timerId;
  
  return (...args) => {
    clearTimeout(timerId);
    timerId = setTimeout(() => fn(...args), delay);
  };
}

const handleInput = debounce((value) => {
  console.log("Searching for:", value);
}, 500);

// Usage in input handler
input.addEventListener("input", (e) => {
  handleInput(e.target.value);
});
```

---

## Closure Chain

Arrow functions can access variables from multiple parent scopes.

```javascript
function outer(x) {
  return function middle(y) {
    return (z) => {
      // Arrow function accesses x, y, and z
      return x + y + z;
    };
  };
}

const step1 = outer(1);
const step2 = step1(2);
const result = step2(3);

console.log(result);  // 6
```

---

## Lexical Arguments

Arrow functions don't have their own `arguments` object.

```javascript
function outer() {
  const arrow = () => {
    console.log(arguments);  // Accesses outer's arguments
  };
  
  arrow();
}

outer(1, 2, 3);  // [1, 2, 3]

// Use rest parameters instead
const arrow = (...args) => {
  console.log(args);  // [arguments passed to arrow]
};
```

---

## Best Practices

### 1. Use Arrow Functions for Callbacks
```javascript
// ✓ Good - preserves this
setTimeout(() => {
  this.update();
}, 1000);

array.forEach((item) => {
  this.process(item);
});
```

### 2. Don't Use Arrow Functions as Methods
```javascript
// ✗ Bad - loses this binding
const obj = {
  name: "Object",
  greet: () => {
    console.log(this.name);  // undefined
  }
};

// ✓ Good - use regular method
const obj = {
  name: "Object",
  greet() {
    console.log(this.name);  // "Object"
  }
};
```

### 3. Use for Function Factories
```javascript
// ✓ Good - clean closure syntax
const createAdder = (x) => (y) => x + y;

const add5 = createAdder(5);
console.log(add5(3));  // 8
```

### 4. Combine with Destructuring
```javascript
const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 }
];

// ✓ Good - concise and clear
const names = users.map(({ name }) => name);
console.log(names);  // ["John", "Jane"]
```

---

## Common Pitfalls

### 1. Cannot Use as Constructor
```javascript
// ✗ Error
const Person = (name) => {
  this.name = name;
};

new Person("John");  // TypeError: Person is not a constructor
```

### 2. Cannot Use with call/apply/bind for this
```javascript
const obj = { name: "Object" };

const arrow = () => console.log(this.name);

arrow.call(obj);   // Still uses lexical this
arrow.apply(obj);  // Still uses lexical this
arrow.bind(obj)(); // Still uses lexical this
```

### 3. Implicit Return with Objects
```javascript
// ✗ Syntax error - looks like function body
const makeObj = (name) => { name: name };

// ✓ Wrap in parentheses
const makeObj = (name) => ({ name: name });
```

---

## Key Takeaways

- Arrow functions capture `this` from surrounding scope (lexical this)
- Perfect for callbacks, array methods, and event handlers
- Create closures over parent scope variables
- Don't have their own `arguments` object - use rest parameters
- Cannot be used as constructors
- Implicit return for single expressions
- More concise syntax for function expressions
- `this` cannot be changed with call/apply/bind
- Ideal for functional programming patterns
- Use regular functions when you need dynamic `this` binding
