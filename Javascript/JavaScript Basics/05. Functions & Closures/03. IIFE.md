# Immediately Invoked Function Expressions (IIFE)

An IIFE is a function that runs immediately after it's defined. It's a powerful pattern for creating private scope and avoiding global namespace pollution.

---

## Basic Syntax

### Standard IIFE
```javascript
// Wrap function in parentheses and immediately invoke
(function() {
  console.log("This runs immediately!");
})();

// Alternative syntax
(function() {
  console.log("This also works!");
}());
```

### With Arrow Functions
```javascript
(() => {
  console.log("Arrow IIFE!");
})();
```

### Named IIFE
```javascript
(function myIIFE() {
  console.log("Named IIFE");
  // Name is only available inside the function
})();

// myIIFE();  // ✗ ReferenceError
```

---

## Passing Arguments

IIFEs can accept parameters just like regular functions.

```javascript
(function(name, age) {
  console.log(`${name} is ${age} years old`);
})("John", 30);
// "John is 30 years old"

// With arrow function
((x, y) => {
  console.log(x + y);
})(5, 3);  // 8
```

---

## Return Values

IIFEs can return values that can be assigned to variables.

```javascript
const result = (function() {
  const a = 10;
  const b = 20;
  return a + b;
})();

console.log(result);  // 30
```

### Creating Objects
```javascript
const calculator = (function() {
  return {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b
  };
})();

console.log(calculator.add(5, 3));       // 8
console.log(calculator.multiply(4, 2));  // 8
```

---

## Private Variables and Encapsulation

IIFEs create private scope that cannot be accessed from outside.

### Basic Private Variables
```javascript
const counter = (function() {
  let count = 0;  // Private variable
  
  return {
    increment() {
      count++;
      return count;
    },
    
    decrement() {
      count--;
      return count;
    },
    
    getCount() {
      return count;
    }
  };
})();

console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getCount());   // 2
console.log(counter.count);        // undefined (private)
```

### Multiple Private Variables
```javascript
const user = (function() {
  let username = "john_doe";
  let password = "secret123";
  let loginAttempts = 0;
  
  return {
    login(inputPassword) {
      loginAttempts++;
      
      if (inputPassword === password) {
        console.log(`Welcome, ${username}!`);
        loginAttempts = 0;
        return true;
      }
      
      console.log(`Failed attempt ${loginAttempts}`);
      return false;
    },
    
    getUsername() {
      return username;
    },
    
    changePassword(oldPassword, newPassword) {
      if (oldPassword === password) {
        password = newPassword;
        return true;
      }
      return false;
    }
  };
})();

user.login("wrong");      // "Failed attempt 1"
user.login("secret123");  // "Welcome, john_doe!"
console.log(user.password);  // undefined
```

---

## Module Pattern

IIFE is the foundation of the module pattern, used before ES6 modules.

### Basic Module
```javascript
const mathModule = (function() {
  // Private helper function
  function isValidNumber(n) {
    return typeof n === "number" && !isNaN(n);
  }
  
  // Public API
  return {
    square(n) {
      if (!isValidNumber(n)) {
        throw new Error("Invalid number");
      }
      return n * n;
    },
    
    cube(n) {
      if (!isValidNumber(n)) {
        throw new Error("Invalid number");
      }
      return n * n * n;
    }
  };
})();

console.log(mathModule.square(5));      // 25
console.log(mathModule.cube(3));        // 27
// mathModule.isValidNumber(5);         // ✗ Error - private
```

### Module with Dependencies
```javascript
const appModule = (function($, _) {
  // Private variables
  const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000
  };
  
  // Private function
  function log(message) {
    console.log(`[APP] ${message}`);
  }
  
  // Public API
  return {
    init() {
      log("Application initialized");
      // Use jQuery and Lodash
      $("body").addClass("app-ready");
      const data = _.defaults({}, { name: "App" });
      return data;
    },
    
    fetchData(endpoint) {
      log(`Fetching: ${config.apiUrl}${endpoint}`);
      // Fetch logic here
    }
  };
})(jQuery, _);

appModule.init();
```

---

## Avoiding Global Scope Pollution

### Without IIFE (Pollutes Global Scope)
```javascript
var x = 10;
var y = 20;
var result = x + y;

console.log(window.x);       // 10 (global)
console.log(window.y);       // 20 (global)
console.log(window.result);  // 30 (global)
```

### With IIFE (Clean Global Scope)
```javascript
(function() {
  var x = 10;
  var y = 20;
  var result = x + y;
  
  console.log(result);  // 30
})();

console.log(window.x);       // undefined
console.log(window.y);       // undefined
console.log(window.result);  // undefined
```

---

## Classic Use Cases

### 1. Loop with var (Closure Issue)
```javascript
// ✗ Problem - all buttons show "5"
for (var i = 0; i < 5; i++) {
  document.querySelectorAll("button")[i].addEventListener("click", function() {
    console.log(i);  // Always 5
  });
}

// ✓ Solution - IIFE creates new scope
for (var i = 0; i < 5; i++) {
  (function(index) {
    document.querySelectorAll("button")[index].addEventListener("click", function() {
      console.log(index);  // Correct value (0-4)
    });
  })(i);
}

// ✓ Modern solution - use let
for (let i = 0; i < 5; i++) {
  document.querySelectorAll("button")[i].addEventListener("click", function() {
    console.log(i);  // Correct value (0-4)
  });
}
```

### 2. Initialize and Configure
```javascript
const app = (function() {
  // Initialization code
  const version = "1.0.0";
  const startTime = Date.now();
  
  console.log("App starting...");
  console.log(`Version: ${version}`);
  
  // Return public interface
  return {
    getVersion() {
      return version;
    },
    
    getUptime() {
      return Date.now() - startTime;
    }
  };
})();

console.log(app.getVersion());  // "1.0.0"
setTimeout(() => {
  console.log(app.getUptime());  // Time since creation
}, 1000);
```

### 3. Singleton Pattern
```javascript
const database = (function() {
  let instance;
  
  function createInstance() {
    const connection = {
      host: "localhost",
      port: 5432,
      connected: true
    };
    
    return {
      query(sql) {
        console.log(`Executing: ${sql}`);
        return connection;
      },
      
      getConnection() {
        return connection;
      }
    };
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const db1 = database.getInstance();
const db2 = database.getInstance();

console.log(db1 === db2);  // true (same instance)
```

### 4. Configuration Object
```javascript
const config = (function() {
  const env = process.env.NODE_ENV || "development";
  
  const settings = {
    development: {
      apiUrl: "http://localhost:3000",
      debug: true,
      logLevel: "verbose"
    },
    production: {
      apiUrl: "https://api.production.com",
      debug: false,
      logLevel: "error"
    }
  };
  
  const current = settings[env];
  
  return {
    get(key) {
      return current[key];
    },
    
    getAll() {
      return { ...current };
    },
    
    getEnv() {
      return env;
    }
  };
})();

console.log(config.get("apiUrl"));
console.log(config.getEnv());
```

### 5. Feature Detection
```javascript
const features = (function() {
  const hasLocalStorage = (function() {
    try {
      localStorage.setItem("test", "test");
      localStorage.removeItem("test");
      return true;
    } catch (e) {
      return false;
    }
  })();
  
  const hasGeolocation = "geolocation" in navigator;
  const hasWebGL = (function() {
    try {
      const canvas = document.createElement("canvas");
      return !!(canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
    } catch (e) {
      return false;
    }
  })();
  
  return {
    localStorage: hasLocalStorage,
    geolocation: hasGeolocation,
    webgl: hasWebGL
  };
})();

console.log(features.localStorage);  // true/false
console.log(features.geolocation);   // true/false
```

---

## IIFE with Promises

```javascript
(async function() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
})();
```

---

## Chaining IIFEs

```javascript
const result = (function(x) {
  return (function(y) {
    return (function(z) {
      return x + y + z;
    })(3);
  })(2);
})(1);

console.log(result);  // 6
```

---

## Best Practices

### 1. Use for One-Time Initialization
```javascript
// ✓ Good
(function() {
  document.addEventListener("DOMContentLoaded", function() {
    console.log("DOM ready");
  });
})();
```

### 2. Create Private Scope in Scripts
```javascript
// ✓ Good - prevents variable leakage
(function() {
  const apiKey = "secret-key-123";
  
  function init() {
    // Use apiKey
  }
  
  init();
})();
```

### 3. Avoid for Modern Code
```javascript
// ✗ Old way - IIFE for modules
const module = (function() {
  return { /* exports */ };
})();

// ✓ Modern - ES6 modules
export const module = { /* exports */ };
```

---

## Common Pitfalls

### 1. Missing Parentheses
```javascript
// ✗ Syntax error
function() {
  console.log("Error");
}();

// ✓ Correct - wrap in parentheses
(function() {
  console.log("Works");
})();
```

### 2. Semicolon Issues
```javascript
const a = 1

// ✗ Error - interpreted as a(function(){}())
(function() {
  console.log("IIFE");
})();

// ✓ Add semicolon
const a = 1;

(function() {
  console.log("IIFE");
})();
```

### 3. Async/Await without async
```javascript
// ✗ Error
(function() {
  await fetch("/api");  // SyntaxError
})();

// ✓ Correct
(async function() {
  await fetch("/api");
})();
```

---

## Key Takeaways

- IIFE runs immediately after definition
- Creates private scope and encapsulation
- Prevents global namespace pollution
- Foundation of the module pattern (pre-ES6)
- Useful for initialization code
- Can return values and create closures
- Solves closure issues in loops (with var)
- Less common in modern ES6+ code (use modules instead)
- Wrap function in parentheses: `(function() {})()`
- Can accept parameters: `(function(x) {})(value)`
- Works with both regular and arrow functions
- Still useful for one-time setup and feature detection
