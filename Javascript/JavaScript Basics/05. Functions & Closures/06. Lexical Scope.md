# Lexical Scope

Lexical scope (also called static scope) means that a variable's scope is determined by its position in the source code. JavaScript uses lexical scoping to resolve variable names.

---

## Understanding Lexical Scope

### Basic Example
```javascript
const globalVar = "global";

function outer() {
  const outerVar = "outer";
  
  function inner() {
    const innerVar = "inner";
    
    console.log(innerVar);   // ✓ Own scope
    console.log(outerVar);   // ✓ Parent scope
    console.log(globalVar);  // ✓ Global scope
  }
  
  inner();
  console.log(innerVar);  // ✗ ReferenceError - not in scope
}

outer();
console.log(outerVar);  // ✗ ReferenceError - not in scope
```

### Scope Chain
JavaScript looks up variables through the scope chain from inner to outer.

```javascript
const a = "global a";

function outer() {
  const b = "outer b";
  
  function middle() {
    const c = "middle c";
    
    function inner() {
      const d = "inner d";
      
      // Scope chain: inner → middle → outer → global
      console.log(d);  // inner scope
      console.log(c);  // middle scope
      console.log(b);  // outer scope
      console.log(a);  // global scope
    }
    
    inner();
  }
  
  middle();
}

outer();
```

---

## Lexical vs Dynamic Scope

JavaScript uses lexical scope - scope is determined by code structure, not runtime.

```javascript
const name = "Global";

function outer() {
  const name = "Outer";
  
  function inner() {
    console.log(name);  // Uses lexical scope
  }
  
  return inner;
}

function other() {
  const name = "Other";
  const fn = outer();
  fn();  // Logs "Outer", not "Other"
         // Lexical scope determined at definition time
}

other();
```

---

## Block Scope vs Function Scope

### var - Function Scope
```javascript
function example() {
  if (true) {
    var x = 10;
  }
  
  console.log(x);  // 10 - var is function-scoped
}

example();
```

### let and const - Block Scope
```javascript
function example() {
  if (true) {
    let x = 10;
    const y = 20;
  }
  
  console.log(x);  // ✗ ReferenceError
  console.log(y);  // ✗ ReferenceError
}

example();
```

### Practical Example
```javascript
// ✗ Problem with var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Logs: 3, 3, 3

// ✓ Solution with let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Logs: 0, 1, 2
```

---

## Nested Scopes

### Multiple Nesting Levels
```javascript
const level1 = "L1";

function outer() {
  const level2 = "L2";
  
  function middle() {
    const level3 = "L3";
    
    function inner() {
      const level4 = "L4";
      
      console.log(level1);  // ✓ Accessible
      console.log(level2);  // ✓ Accessible
      console.log(level3);  // ✓ Accessible
      console.log(level4);  // ✓ Accessible
    }
    
    inner();
    console.log(level4);  // ✗ Error - not in scope
  }
  
  middle();
}

outer();
```

### Shadowing Variables
```javascript
const name = "Global";

function outer() {
  const name = "Outer";  // Shadows global
  
  function inner() {
    const name = "Inner";  // Shadows outer
    console.log(name);     // "Inner"
  }
  
  inner();
  console.log(name);  // "Outer"
}

outer();
console.log(name);  // "Global"
```

---

## Closures and Lexical Scope

Closures capture variables from their lexical scope.

### Basic Closure
```javascript
function createCounter() {
  let count = 0;  // Captured by lexical scope
  
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter());  // 1
console.log(counter());  // 2
```

### Multiple Closures Share Scope
```javascript
function createCounter() {
  let count = 0;
  
  return {
    increment() {
      count++;
      return count;
    },
    
    decrement() {
      count--;
      return count;
    },
    
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
counter.increment();
console.log(counter.getCount());  // 2
counter.decrement();
console.log(counter.getCount());  // 1
```

---

## Scope Lookup Rules

### 1. Current Scope First
```javascript
function test() {
  const x = 10;
  
  if (true) {
    const x = 20;  // Different x in block scope
    console.log(x);  // 20 - uses nearest scope
  }
  
  console.log(x);  // 10 - uses function scope
}

test();
```

### 2. Walk Up Scope Chain
```javascript
const a = 1;

function outer() {
  const b = 2;
  
  function inner() {
    const c = 3;
    
    // Lookup order: inner → outer → global
    console.log(c);  // Found in inner
    console.log(b);  // Found in outer
    console.log(a);  // Found in global
  }
  
  inner();
}

outer();
```

### 3. Stop at First Match
```javascript
const value = "global";

function outer() {
  const value = "outer";
  
  function inner() {
    // Stops at first 'value' found
    console.log(value);  // "outer"
  }
  
  inner();
}

outer();
```

---

## Hoisting and Scope

### var Hoisting
```javascript
function test() {
  console.log(x);  // undefined (hoisted)
  var x = 10;
  console.log(x);  // 10
}

// Equivalent to:
function test() {
  var x;  // Declaration hoisted
  console.log(x);  // undefined
  x = 10;
  console.log(x);  // 10
}

test();
```

### let/const - Temporal Dead Zone
```javascript
function test() {
  // console.log(x);  // ✗ ReferenceError - TDZ
  let x = 10;
  console.log(x);  // 10
}

test();
```

### Function Hoisting
```javascript
// Function declarations are hoisted
greet();  // Works - "Hello!"

function greet() {
  console.log("Hello!");
}

// Function expressions are not
// sayHi();  // ✗ TypeError

const sayHi = function() {
  console.log("Hi!");
};
```

---

## Practical Examples

### 1. Module Pattern with Lexical Scope
```javascript
const calculator = (function() {
  // Private variables (lexical scope)
  let result = 0;
  const history = [];
  
  // Private function
  function log(operation) {
    history.push({ operation, result, timestamp: Date.now() });
  }
  
  // Public API
  return {
    add(n) {
      result += n;
      log(`add(${n})`);
      return this;
    },
    
    subtract(n) {
      result -= n;
      log(`subtract(${n})`);
      return this;
    },
    
    multiply(n) {
      result *= n;
      log(`multiply(${n})`);
      return this;
    },
    
    getResult() {
      return result;
    },
    
    getHistory() {
      return [...history];  // Return copy
    },
    
    clear() {
      result = 0;
      history.length = 0;
      return this;
    }
  };
})();

calculator.add(5).multiply(2).subtract(3);
console.log(calculator.getResult());  // 7
console.log(calculator.getHistory());
```

### 2. Factory with Private State
```javascript
function createUser(name, email) {
  // Private variables in lexical scope
  let password;
  let loginAttempts = 0;
  const createdAt = Date.now();
  
  // Private method
  function validatePassword(input) {
    return input && input.length >= 8;
  }
  
  return {
    getName() {
      return name;
    },
    
    getEmail() {
      return email;
    },
    
    setPassword(newPassword) {
      if (validatePassword(newPassword)) {
        password = newPassword;
        return true;
      }
      return false;
    },
    
    login(inputPassword) {
      if (inputPassword === password) {
        loginAttempts = 0;
        return true;
      }
      loginAttempts++;
      return false;
    },
    
    getLoginAttempts() {
      return loginAttempts;
    },
    
    getAge() {
      return Date.now() - createdAt;
    }
  };
}

const user = createUser("John", "john@example.com");
user.setPassword("secret123");
console.log(user.getName());  // "John"
console.log(user.password);   // undefined (private)
```

### 3. Event Handler with Scope
```javascript
function setupButtons() {
  const buttons = document.querySelectorAll(".button");
  
  buttons.forEach((button, index) => {
    // Each iteration creates new lexical scope
    let clickCount = 0;
    
    button.addEventListener("click", function() {
      clickCount++;
      this.textContent = `Button ${index}: ${clickCount} clicks`;
    });
  });
}

setupButtons();
```

### 4. Configuration with Scope
```javascript
function createConfig(environment) {
  // Private configuration based on environment
  const configs = {
    development: {
      apiUrl: "http://localhost:3000",
      debug: true,
      logLevel: "verbose"
    },
    production: {
      apiUrl: "https://api.production.com",
      debug: false,
      logLevel: "error"
    }
  };
  
  const config = configs[environment];
  
  // Private helper
  function log(message) {
    if (config.debug) {
      console.log(`[${environment}] ${message}`);
    }
  }
  
  return {
    get(key) {
      log(`Getting config: ${key}`);
      return config[key];
    },
    
    getFullUrl(endpoint) {
      return `${config.apiUrl}${endpoint}`;
    },
    
    isDebug() {
      return config.debug;
    }
  };
}

const devConfig = createConfig("development");
console.log(devConfig.get("apiUrl"));
console.log(devConfig.getFullUrl("/users"));
```

### 5. Iterator with Lexical Scope
```javascript
function createIterator(array) {
  let index = 0;  // Private state
  
  return {
    next() {
      if (index < array.length) {
        return {
          value: array[index++],
          done: false
        };
      }
      return { done: true };
    },
    
    hasNext() {
      return index < array.length;
    },
    
    reset() {
      index = 0;
    },
    
    getPosition() {
      return index;
    }
  };
}

const iterator = createIterator([1, 2, 3, 4, 5]);

console.log(iterator.next());  // { value: 1, done: false }
console.log(iterator.next());  // { value: 2, done: false }
console.log(iterator.getPosition());  // 2
iterator.reset();
console.log(iterator.next());  // { value: 1, done: false }
```

---

## Global Scope

Variables declared outside any function are in global scope.

```javascript
// Global scope
const globalVar = "global";
var alsoGlobal = "also global";

function test() {
  console.log(globalVar);  // Accessible
  console.log(alsoGlobal); // Accessible
  
  // Creates global variable (without var/let/const)
  implicitGlobal = "oops";  // ✗ Bad practice
}

test();
console.log(implicitGlobal);  // "oops" - now global
```

### Avoid Polluting Global Scope
```javascript
// ✗ Bad - pollutes global scope
var config = {};
var utils = {};
var helpers = {};

// ✓ Good - use namespace
const App = {
  config: {},
  utils: {},
  helpers: {}
};

// ✓ Better - use modules (ES6)
export const config = {};
export const utils = {};
export const helpers = {};
```

---

## Scope Best Practices

### 1. Use Block Scope with let/const
```javascript
// ✓ Good
if (condition) {
  let temp = computeValue();
  doSomething(temp);
}
// temp not accessible here

// ✗ Bad
if (condition) {
  var temp = computeValue();
  doSomething(temp);
}
// temp still accessible here
```

### 2. Minimize Global Variables
```javascript
// ✗ Bad
var data = [];
var config = {};
var utils = {};

// ✓ Good
const App = (function() {
  const data = [];
  const config = {};
  const utils = {};
  
  return {
    // Public API
  };
})();
```

### 3. Declare Variables at Appropriate Scope
```javascript
// ✗ Bad - wider scope than needed
function process() {
  let temp;
  
  if (condition) {
    temp = getValue();
    use(temp);
  }
}

// ✓ Good - narrow scope
function process() {
  if (condition) {
    let temp = getValue();
    use(temp);
  }
}
```

---

## Common Pitfalls

### 1. Accidental Globals
```javascript
function test() {
  x = 10;  // ✗ Creates global variable
}

test();
console.log(x);  // 10 (global)

// ✓ Always use let/const/var
function test() {
  let x = 10;  // ✓ Local variable
}
```

### 2. Loop Variable Scope
```javascript
// ✗ Problem with var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Logs: 3, 3, 3

// ✓ Fix with let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Logs: 0, 1, 2
```

### 3. Variable Shadowing Confusion
```javascript
const value = "outer";

function test() {
  if (true) {
    const value = "inner";
    console.log(value);  // "inner"
  }
  console.log(value);  // "outer" - different variable
}

test();
```

---

## Key Takeaways

- Lexical scope is determined by code structure (where code is written)
- Scope chain: inner → outer → global
- JavaScript looks up variables from current scope outward
- `var` is function-scoped, `let`/`const` are block-scoped
- Closures capture variables from lexical scope
- Hoisting moves declarations to top of scope
- Avoid global variables and scope pollution
- Use `let`/`const` for better scope control
- Scope is created at definition time, not runtime
- Understanding scope is essential for closures and memory management
