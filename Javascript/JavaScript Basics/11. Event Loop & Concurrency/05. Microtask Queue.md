# Microtask Queue

The microtask queue (also called job queue) stores high-priority asynchronous tasks that execute before the next macrotask.

---

## What is the Microtask Queue?

A queue for microtasks that have higher priority than macrotasks. All microtasks execute before the event loop continues to the next macrotask.

```javascript
console.log('1');

setTimeout(() => {
  console.log('2: Macrotask');
}, 0);

Promise.resolve().then(() => {
  console.log('3: Microtask');
});

console.log('4');

// Output: 1, 4, 3, 2
// All microtasks (3) execute before macrotasks (2)
```

---

## Microtask Sources

### Promises

```javascript
Promise.resolve().then(() => {
  console.log('Promise microtask');
});

new Promise((resolve) => {
  console.log('Promise executor (sync)');
  resolve();
}).then(() => {
  console.log('Promise then (microtask)');
});

// Output:
// Promise executor (sync)
// Promise microtask
// Promise then (microtask)
```

### queueMicrotask()

```javascript
queueMicrotask(() => {
  console.log('Explicit microtask');
});

Promise.resolve().then(() => {
  console.log('Promise microtask');
});

// Both are microtasks, execute in queue order
```

### MutationObserver

```javascript
const observer = new MutationObserver((mutations) => {
  console.log('DOM changed (microtask)');
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});

document.body.appendChild(document.createElement('div'));

// Callback executes as microtask
```

### process.nextTick (Node.js)

```javascript
// Node.js only - higher priority than Promise microtasks
process.nextTick(() => {
  console.log('nextTick');
});

Promise.resolve().then(() => {
  console.log('Promise');
});

// Output: nextTick, Promise
```

---

## Microtask Priority

All microtasks execute before the next macrotask.

```javascript
console.log('Start');

setTimeout(() => {
  console.log('Macro 1');
}, 0);

Promise.resolve().then(() => {
  console.log('Micro 1');
});

Promise.resolve().then(() => {
  console.log('Micro 2');
});

setTimeout(() => {
  console.log('Macro 2');
}, 0);

Promise.resolve().then(() => {
  console.log('Micro 3');
});

console.log('End');

// Output: Start, End, Micro 1, Micro 2, Micro 3, Macro 1, Macro 2
```

---

## Execution Flow

```javascript
// 1. Synchronous code
console.log('1: Sync');

// 2. Schedule macrotask
setTimeout(() => {
  console.log('2: Macro');
}, 0);

// 3. Schedule microtask
Promise.resolve().then(() => {
  console.log('3: Micro');
});

// 4. More synchronous code
console.log('4: Sync');

// Output: 1, 4, 3, 2

// Flow:
// Execute sync (1, 4)
// Empty microtask queue (3)
// Execute one macrotask (2)
```

---

## Chained Microtasks

Microtasks can create more microtasks.

```javascript
Promise.resolve().then(() => {
  console.log('Micro 1');
  
  Promise.resolve().then(() => {
    console.log('Micro 2');
    
    Promise.resolve().then(() => {
      console.log('Micro 3');
    });
  });
});

setTimeout(() => {
  console.log('Macro');
}, 0);

// Output: Micro 1, Micro 2, Micro 3, Macro
// All microtasks complete before macrotask
```

---

## Microtasks vs Macrotasks

### Example Comparison

```javascript
console.log('Script start');

setTimeout(() => {
  console.log('setTimeout 1');
  
  Promise.resolve().then(() => {
    console.log('Promise in setTimeout');
  });
}, 0);

Promise.resolve()
  .then(() => {
    console.log('Promise 1');
    
    setTimeout(() => {
      console.log('setTimeout in Promise');
    }, 0);
  })
  .then(() => {
    console.log('Promise 2');
  });

setTimeout(() => {
  console.log('setTimeout 2');
}, 0);

console.log('Script end');

// Output:
// Script start
// Script end
// Promise 1
// Promise 2
// setTimeout 1
// Promise in setTimeout
// setTimeout 2
// setTimeout in Promise
```

---

## async/await and Microtasks

`await` creates microtasks.

```javascript
async function example() {
  console.log('1');
  
  await Promise.resolve();
  
  console.log('2');  // Microtask
}

console.log('Start');
example();
console.log('End');

// Output: Start, 1, End, 2
```

### Multiple awaits

```javascript
async function multiple() {
  console.log('1');
  
  await Promise.resolve();
  console.log('2');  // First microtask
  
  await Promise.resolve();
  console.log('3');  // Second microtask
}

console.log('Start');
multiple();
console.log('End');

// Output: Start, 1, End, 2, 3
```

---

## Practical Examples

### Batching Updates

```javascript
let pendingUpdates = [];

function scheduleUpdate(data) {
  pendingUpdates.push(data);
  
  if (pendingUpdates.length === 1) {
    queueMicrotask(flushUpdates);
  }
}

function flushUpdates() {
  const updates = pendingUpdates.slice();
  pendingUpdates = [];
  
  console.log('Processing updates:', updates);
  updates.forEach(processUpdate);
}

scheduleUpdate('A');
scheduleUpdate('B');
scheduleUpdate('C');

console.log('Scheduled');

// Output:
// Scheduled
// Processing updates: ['A', 'B', 'C']
```

### Ensure Order

```javascript
function processInOrder(items) {
  return items.reduce((promise, item) => {
    return promise.then(() => {
      console.log('Processing:', item);
      return Promise.resolve();
    });
  }, Promise.resolve());
}

processInOrder(['A', 'B', 'C']);

// Output:
// Processing: A
// Processing: B
// Processing: C
```

### State Consistency

```javascript
let state = { count: 0 };

function updateState(newState) {
  state = { ...state, ...newState };
  
  queueMicrotask(() => {
    // Guaranteed to run with latest state
    console.log('State updated:', state);
    notifyObservers(state);
  });
}

updateState({ count: 1 });
updateState({ count: 2 });
updateState({ count: 3 });

// Only one notification with final state
// Output: State updated: { count: 3 }
```

---

## Infinite Microtasks

Microtasks can starve macrotasks.

```javascript
function infiniteMicrotasks() {
  Promise.resolve().then(() => {
    console.log('Microtask');
    infiniteMicrotasks();
  });
}

setTimeout(() => {
  console.log('This never runs!');
}, 0);

// infiniteMicrotasks();  // Don't run this!
// Creates infinite microtasks, macrotask never executes
```

### Safe Recursive Microtasks

```javascript
function recursiveMicrotask(count, max = 10) {
  if (count >= max) {
    console.log('Done');
    return;
  }
  
  Promise.resolve().then(() => {
    console.log('Microtask', count);
    recursiveMicrotask(count + 1, max);
  });
}

recursiveMicrotask(1);
// Executes 10 times then stops
```

---

## Error Handling

### Unhandled Rejections

```javascript
Promise.reject('Error').then(() => {
  // Never executes
});

// Unhandled rejection - browser/Node.js will warn

window.addEventListener('unhandledrejection', (event) => {
  console.log('Unhandled rejection:', event.reason);
  event.preventDefault();  // Prevent default logging
});
```

### Catching Errors

```javascript
Promise.resolve()
  .then(() => {
    throw new Error('Microtask error');
  })
  .catch((error) => {
    console.log('Caught:', error.message);
  });

// Error caught in microtask queue
```

---

## Performance Implications

### Too Many Microtasks

```javascript
// Bad - creates 10000 microtasks at once
for (let i = 0; i < 10000; i++) {
  Promise.resolve().then(() => {
    console.log(i);
  });
}

// Better - use macrotasks for large batches
for (let i = 0; i < 10000; i++) {
  setTimeout(() => {
    console.log(i);
  }, 0);
}
```

### Batching vs Individual

```javascript
// Inefficient - many microtasks
function updateMultipleTimes(items) {
  items.forEach(item => {
    Promise.resolve().then(() => {
      updateDOM(item);
    });
  });
}

// Efficient - single microtask
function updateOnce(items) {
  queueMicrotask(() => {
    items.forEach(updateDOM);
  });
}
```

---

## Debugging Microtasks

### Track Execution

```javascript
let microtaskCount = 0;

const originalThen = Promise.prototype.then;
Promise.prototype.then = function(...args) {
  microtaskCount++;
  console.log('Microtask scheduled, total:', microtaskCount);
  return originalThen.apply(this, args);
};

Promise.resolve().then(() => {
  console.log('Microtask 1');
});

Promise.resolve().then(() => {
  console.log('Microtask 2');
});

// Restore original
Promise.prototype.then = originalThen;
```

### Log Timing

```javascript
function logMicrotask(label, fn) {
  const start = performance.now();
  
  queueMicrotask(() => {
    fn();
    const duration = performance.now() - start;
    console.log(`${label} executed in ${duration}ms`);
  });
}

logMicrotask('Task 1', () => {
  // Do work
});
```

---

## Browser vs Node.js

### Browser

```javascript
// Browser microtasks:
Promise.resolve().then(callback);
queueMicrotask(callback);
MutationObserver callback;

// All have same priority
```

### Node.js

```javascript
// Node.js microtasks:
process.nextTick(callback);  // Highest priority
Promise.resolve().then(callback);
queueMicrotask(callback);

// nextTick executes first
process.nextTick(() => console.log('nextTick'));
Promise.resolve().then(() => console.log('Promise'));
queueMicrotask(() => console.log('queueMicrotask'));

// Output: nextTick, Promise, queueMicrotask
// or: nextTick, queueMicrotask, Promise
```

---

## Common Patterns

### Defer to Microtask

```javascript
function deferToMicrotask(fn) {
  queueMicrotask(fn);
}

// Or with Promise
function deferToMicrotask(fn) {
  Promise.resolve().then(fn);
}

deferToMicrotask(() => {
  console.log('Runs as microtask');
});
```

### Wait for DOM Update

```javascript
function updateAndNotify(element, value) {
  element.textContent = value;
  
  queueMicrotask(() => {
    // DOM updated, but not rendered yet
    console.log('Text set to:', element.textContent);
  });
}
```

### Collect and Process

```javascript
class BatchProcessor {
  constructor() {
    this.pending = [];
    this.scheduled = false;
  }
  
  add(item) {
    this.pending.push(item);
    this.schedule();
  }
  
  schedule() {
    if (!this.scheduled) {
      this.scheduled = true;
      queueMicrotask(() => this.process());
    }
  }
  
  process() {
    const items = this.pending.slice();
    this.pending = [];
    this.scheduled = false;
    
    console.log('Processing batch:', items);
  }
}

const processor = new BatchProcessor();
processor.add('A');
processor.add('B');
processor.add('C');

// Output: Processing batch: ['A', 'B', 'C']
```

---

## Best Practices

```javascript
// 1. Use for state synchronization
queueMicrotask(() => {
  syncState();
});

// 2. Batch DOM updates
const updates = [];
function scheduleUpdate(update) {
  updates.push(update);
  if (updates.length === 1) {
    queueMicrotask(flushUpdates);
  }
}

// 3. Don't create infinite microtasks
function safeMicrotask(condition) {
  if (!condition) return;
  queueMicrotask(() => {
    // Work
    safeMicrotask(newCondition);  // With exit condition
  });
}

// 4. Handle errors
Promise.resolve()
  .then(riskyOperation)
  .catch(handleError);

// 5. Prefer queueMicrotask over Promise for clarity
queueMicrotask(() => {
  // Clearly a microtask
});
```

---

## Key Takeaways

- **Microtask Queue**: High-priority task queue
- **Sources**: Promises, queueMicrotask, MutationObserver
- **Priority**: Execute before next macrotask
- **All microtasks**: Run before any macrotask
- **Chaining**: Microtasks can create microtasks
- **async/await**: Creates microtasks
- **Starvation**: Can prevent macrotasks from running
- **Node.js**: process.nextTick has highest priority
- Use for state synchronization
- Batch operations for performance
- Handle errors to avoid unhandled rejections
- Don't create infinite microtask loops
