# Execution Order

Understanding the precise order of JavaScript code execution is crucial for writing predictable asynchronous code.

---

## Basic Execution Order

JavaScript executes code in this order:
1. Synchronous code
2. Microtasks
3. Macrotasks (one per iteration)
4. Repeat from step 2

```javascript
console.log('1: Sync');

setTimeout(() => console.log('2: Macro'), 0);

Promise.resolve().then(() => console.log('3: Micro'));

console.log('4: Sync');

// Output: 1, 4, 3, 2
```

---

## Synchronous Execution

Synchronous code executes immediately, top to bottom.

```javascript
function first() {
  console.log('First');
}

function second() {
  console.log('Second');
}

console.log('Start');
first();
second();
console.log('End');

// Output: Start, First, Second, End
// Executes in order, no surprises
```

---

## Promise Execution Order

Promise executors run synchronously, `.then()` callbacks run as microtasks.

```javascript
console.log('1');

new Promise((resolve) => {
  console.log('2');  // Executor runs synchronously
  resolve();
}).then(() => {
  console.log('3');  // Microtask
});

console.log('4');

// Output: 1, 2, 4, 3
```

### Multiple Promises

```javascript
console.log('Start');

Promise.resolve().then(() => {
  console.log('Promise 1');
});

Promise.resolve().then(() => {
  console.log('Promise 2');
});

console.log('End');

// Output: Start, End, Promise 1, Promise 2
// Promises queued in order, execute after sync code
```

---

## async/await Execution

`await` pauses function execution and schedules continuation as microtask.

```javascript
async function example() {
  console.log('1');
  
  await Promise.resolve();
  
  console.log('2');  // Continues as microtask
}

console.log('Start');
example();
console.log('End');

// Output: Start, 1, End, 2
```

### Multiple awaits

```javascript
async function multiple() {
  console.log('A');
  
  await Promise.resolve();
  console.log('B');
  
  await Promise.resolve();
  console.log('C');
}

console.log('Start');
multiple();
console.log('End');

// Output: Start, A, End, B, C
// Each await creates new microtask
```

---

## setTimeout Execution Order

setTimeout schedules macrotasks.

```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);
setTimeout(() => console.log('3'), 0);

console.log('4');

// Output: 1, 4, 2, 3
// Timeouts execute in queue order, after sync code
```

### setTimeout with Different Delays

```javascript
console.log('Start');

setTimeout(() => console.log('100ms'), 100);
setTimeout(() => console.log('0ms'), 0);
setTimeout(() => console.log('50ms'), 50);

console.log('End');

// Output: Start, End, 0ms, 50ms, 100ms
// Execute in order of timeout completion
```

---

## Mixed Async Operations

```javascript
console.log('1: Sync');

setTimeout(() => {
  console.log('2: Macro');
}, 0);

Promise.resolve().then(() => {
  console.log('3: Micro');
});

setTimeout(() => {
  console.log('4: Macro');
}, 0);

Promise.resolve().then(() => {
  console.log('5: Micro');
});

console.log('6: Sync');

// Output: 1, 6, 3, 5, 2, 4

// Breakdown:
// Sync: 1, 6
// All microtasks: 3, 5
// First macrotask: 2
// Second macrotask: 4
```

---

## Nested Async Operations

### Microtask in Macrotask

```javascript
console.log('Start');

setTimeout(() => {
  console.log('Macro 1');
  
  Promise.resolve().then(() => {
    console.log('Micro in Macro');
  });
}, 0);

setTimeout(() => {
  console.log('Macro 2');
}, 0);

console.log('End');

// Output: Start, End, Macro 1, Micro in Macro, Macro 2
// Microtask executes between macrotasks
```

### Macrotask in Microtask

```javascript
console.log('Start');

Promise.resolve().then(() => {
  console.log('Micro 1');
  
  setTimeout(() => {
    console.log('Macro in Micro');
  }, 0);
});

Promise.resolve().then(() => {
  console.log('Micro 2');
});

console.log('End');

// Output: Start, End, Micro 1, Micro 2, Macro in Micro
```

---

## Complex Example

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => console.log('3'));
}, 0);

Promise.resolve()
  .then(() => {
    console.log('4');
    setTimeout(() => console.log('5'), 0);
  })
  .then(() => console.log('6'));

setTimeout(() => console.log('7'), 0);

Promise.resolve().then(() => console.log('8'));

console.log('9');

// Output: 1, 9, 4, 8, 6, 2, 3, 7, 5

// Detailed breakdown:
// Sync: 1, 9
// Microtasks: 4 (schedules setTimeout 5), 8, 6
// Macrotask 1: 2 (schedules Promise 3)
// Microtask from Macro 1: 3
// Macrotask 2: 7
// Macrotask 3: 5
```

---

## requestAnimationFrame

RAF callbacks execute before next repaint, between microtasks and next macrotask.

```javascript
console.log('Start');

setTimeout(() => console.log('Timeout'), 0);

requestAnimationFrame(() => console.log('RAF'));

Promise.resolve().then(() => console.log('Promise'));

console.log('End');

// Output (typical): Start, End, Promise, RAF, Timeout
// Microtasks → RAF → Macrotasks
```

---

## Event Handlers

Event callbacks are macrotasks.

```javascript
button.addEventListener('click', () => {
  console.log('Click handler');
  
  Promise.resolve().then(() => {
    console.log('Promise in handler');
  });
});

// When clicked:
// Click handler (macrotask)
// Promise in handler (microtask before next macrotask)
```

---

## Execution Order Quiz

```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1();

new Promise((resolve) => {
  console.log('promise1');
  resolve();
}).then(() => {
  console.log('promise2');
});

console.log('script end');

// Output:
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

### Breakdown

```
Synchronous:
  script start
  async1 start
  async2 (executor runs sync)
  promise1 (executor runs sync)
  script end

Microtasks:
  async1 end (await continuation)
  promise2

Macrotasks:
  setTimeout
```

---

## Practical Examples

### Data Loading Sequence

```javascript
async function loadData() {
  console.log('1: Start loading');
  
  const users = await fetchUsers();  // Microtask
  console.log('2: Users loaded');
  
  const posts = await fetchPosts();  // Another microtask
  console.log('3: Posts loaded');
  
  setTimeout(() => {
    console.log('4: Deferred operation');
  }, 0);
  
  return { users, posts };
}

console.log('Start');
loadData();
console.log('End');

// Output:
// Start
// 1: Start loading
// End
// 2: Users loaded
// 3: Posts loaded
// 4: Deferred operation
```

### State Update Batching

```javascript
let state = { count: 0 };
let updates = [];

function setState(newState) {
  state = { ...state, ...newState };
  updates.push(newState);
  
  if (updates.length === 1) {
    queueMicrotask(() => {
      console.log('Applying', updates.length, 'updates');
      console.log('Final state:', state);
      updates = [];
    });
  }
}

console.log('Start');
setState({ count: 1 });
setState({ count: 2 });
setState({ count: 3 });
console.log('End');

// Output:
// Start
// End
// Applying 3 updates
// Final state: { count: 3 }
```

---

## Event Loop Visualization

```javascript
console.log('1');                    // Call Stack

setTimeout(() => {                    
  console.log('2');                  // Callback Queue
}, 0);

Promise.resolve().then(() => {       
  console.log('3');                  // Microtask Queue
});

console.log('4');                    // Call Stack

/*
Call Stack:     [1, 4]
Microtask:      [3]
Callback:       [2]

Execution:
1. Call Stack: 1, 4
2. Empty Microtask Queue: 3
3. Process one Callback: 2
*/
```

---

## Node.js Specific

### process.nextTick

```javascript
console.log('Start');

process.nextTick(() => console.log('nextTick 1'));

Promise.resolve().then(() => console.log('Promise'));

process.nextTick(() => console.log('nextTick 2'));

console.log('End');

// Output: Start, End, nextTick 1, nextTick 2, Promise
// nextTick has highest priority
```

### setImmediate vs setTimeout

```javascript
setTimeout(() => console.log('setTimeout'), 0);
setImmediate(() => console.log('setImmediate'));

// Order may vary depending on system load
// Inside I/O cycle, setImmediate executes first
```

---

## Common Mistakes

### Assuming Immediate Execution

```javascript
// Wrong assumption
setTimeout(() => {
  console.log('This runs immediately!');
}, 0);

// Actually runs after:
// 1. All synchronous code
// 2. All microtasks
// 3. Previous macrotasks
```

### Ignoring Microtask Priority

```javascript
setTimeout(() => console.log('Macro'), 0);
Promise.resolve().then(() => console.log('Micro'));

// Common mistake: thinking setTimeout runs first
// Correct: Micro, Macro
```

### Promise Executor Confusion

```javascript
new Promise((resolve) => {
  console.log('When does this run?');  // Immediately!
  resolve();
});

// Executor runs synchronously
```

---

## Debugging Execution Order

```javascript
let sequence = [];

function log(msg, type) {
  const entry = { msg, type, time: performance.now() };
  sequence.push(entry);
  console.log(`[${type}] ${msg}`);
}

log('Start', 'sync');

setTimeout(() => log('Timeout', 'macro'), 0);

Promise.resolve().then(() => log('Promise', 'micro'));

log('End', 'sync');

// Check execution order
setTimeout(() => {
  console.table(sequence);
}, 100);
```

---

## Best Practices

```javascript
// 1. Understand execution order
// Sync → Microtasks → Macrotask → Repeat

// 2. Use appropriate async primitive
queueMicrotask(() => {
  // Runs before next macrotask
});

setTimeout(() => {
  // Runs in next event loop iteration
}, 0);

// 3. Chain promises for ordered execution
async function ordered() {
  await step1();
  await step2();
  await step3();
}

// 4. Batch synchronous updates
const updates = [];
function batchUpdate(data) {
  updates.push(data);
  if (updates.length === 1) {
    queueMicrotask(processUpdates);
  }
}

// 5. Document complex async flows
// Add comments explaining execution order
```

---

## Performance Implications

```javascript
// Too many microtasks block macrotasks
for (let i = 0; i < 10000; i++) {
  Promise.resolve().then(() => {
    // 10000 microtasks must complete
    // before any macrotask runs
  });
}

// Better: spread work across macrotasks
for (let i = 0; i < 10000; i++) {
  setTimeout(() => {
    // Allows other macrotasks to interleave
  }, 0);
}
```

---

## Key Takeaways

- **Execution Order**: Sync → Microtasks → Macrotask → Repeat
- **Synchronous**: Executes immediately
- **Microtasks**: Promises, queueMicrotask (high priority)
- **Macrotasks**: setTimeout, setInterval (low priority)
- **Promise executor**: Runs synchronously
- **await**: Creates microtask for continuation
- **All microtasks**: Execute before next macrotask
- **RAF**: Between microtasks and macrotasks (browser)
- **Node.js**: process.nextTick has highest priority
- Understand order to avoid bugs
- Use correct async primitive for use case
- Don't assume immediate execution
- Batch updates for performance
