# Event Loop Mechanism

The event loop is JavaScript's runtime model that handles asynchronous operations, coordinating between the call stack, callback queue, and microtask queue.

---

## What is the Event Loop?

A continuously running process that monitors the call stack and task queues, moving tasks to the call stack when it's empty.

```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
}, 0);

Promise.resolve().then(() => {
  console.log('3');
});

console.log('4');

// Output: 1, 4, 3, 2

// Event Loop Process:
// 1. Execute synchronous code (1, 4)
// 2. Check microtask queue (3)
// 3. Check callback queue (2)
// 4. Repeat
```

---

## Event Loop Phases

### 1. Execute Synchronous Code

```javascript
console.log('Start');  // Executed immediately

function sync() {
  console.log('Sync function');
}

sync();  // Executed immediately

console.log('End');  // Executed immediately

// Output: Start, Sync function, End
```

### 2. Process Microtasks

```javascript
Promise.resolve().then(() => {
  console.log('Microtask 1');
});

Promise.resolve().then(() => {
  console.log('Microtask 2');
});

// Both microtasks execute before next macrotask
// Output: Microtask 1, Microtask 2
```

### 3. Process One Macrotask

```javascript
setTimeout(() => {
  console.log('Macrotask 1');
}, 0);

setTimeout(() => {
  console.log('Macrotask 2');
}, 0);

// Event loop processes one macrotask per iteration
// Then checks microtasks again before next macrotask
```

### 4. Render (if needed)

```javascript
// Browser may render between macrotasks
requestAnimationFrame(() => {
  console.log('Animation frame');
});

// Rendering happens after microtasks but before next macrotask
```

---

## Complete Event Loop Cycle

```javascript
console.log('1: Sync');

setTimeout(() => {
  console.log('2: Macro');
  
  Promise.resolve().then(() => {
    console.log('3: Micro from Macro');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4: Micro');
  
  setTimeout(() => {
    console.log('5: Macro from Micro');
  }, 0);
});

setTimeout(() => {
  console.log('6: Macro');
}, 0);

Promise.resolve().then(() => {
  console.log('7: Micro');
});

console.log('8: Sync');

// Output: 1, 8, 4, 7, 2, 3, 6, 5

// Detailed execution:
// Sync: 1, 8
// Microtasks: 4 (schedules macro 5), 7
// Macrotask: 2 (schedules micro 3)
// Microtask: 3
// Macrotask: 6
// Macrotask: 5
```

---

## Visual Representation

```
┌───────────────────────────┐
│   Call Stack Empty?       │
└───────────┬───────────────┘
            │
            ├──NO──► Execute current function
            │
            └──YES─┐
                   │
         ┌─────────▼──────────┐
         │ Microtask Queue    │
         │ Empty?             │
         └─────────┬──────────┘
                   │
                   ├──NO──► Execute all microtasks
                   │
                   └──YES─┐
                          │
                ┌─────────▼──────────┐
                │ Callback Queue     │
                │ Empty?             │
                └─────────┬──────────┘
                          │
                          ├──NO──► Execute one macrotask
                          │
                          └──YES─► Wait for tasks
```

---

## Microtasks vs Macrotasks

### Microtasks (High Priority)

```javascript
// Microtask sources:
Promise.resolve().then(callback);
queueMicrotask(callback);
MutationObserver callback;

// All microtasks execute before next macrotask
Promise.resolve().then(() => console.log('Micro 1'));
Promise.resolve().then(() => console.log('Micro 2'));
setTimeout(() => console.log('Macro'), 0);

// Output: Micro 1, Micro 2, Macro
```

### Macrotasks (Lower Priority)

```javascript
// Macrotask sources:
setTimeout(callback, delay);
setInterval(callback, delay);
setImmediate(callback);  // Node.js
I/O operations;
UI rendering;

// One macrotask per event loop iteration
setTimeout(() => console.log('Macro 1'), 0);
setTimeout(() => console.log('Macro 2'), 0);

// Output: Macro 1, Macro 2 (separate iterations)
```

---

## Nested Tasks

### Microtask Creates Microtask

```javascript
Promise.resolve().then(() => {
  console.log('Micro 1');
  
  Promise.resolve().then(() => {
    console.log('Micro 2');
    
    Promise.resolve().then(() => {
      console.log('Micro 3');
    });
  });
});

setTimeout(() => {
  console.log('Macro');
}, 0);

// Output: Micro 1, Micro 2, Micro 3, Macro
// All microtasks complete before macrotask
```

### Macrotask Creates Microtask

```javascript
setTimeout(() => {
  console.log('Macro 1');
  
  Promise.resolve().then(() => {
    console.log('Micro from Macro 1');
  });
}, 0);

setTimeout(() => {
  console.log('Macro 2');
}, 0);

// Output: Macro 1, Micro from Macro 1, Macro 2
// Microtasks execute between macrotasks
```

---

## Practical Examples

### Order of Execution

```javascript
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}

async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async1();

new Promise((resolve) => {
  console.log('promise1');
  resolve();
}).then(() => {
  console.log('promise2');
});

console.log('script end');

// Output:
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

### Rendering Coordination

```javascript
console.log('Start');

// Update DOM
document.getElementById('box').style.width = '100px';

// Schedule animation
requestAnimationFrame(() => {
  console.log('Animation frame');
  document.getElementById('box').style.width = '200px';
});

setTimeout(() => {
  console.log('Timeout');
}, 0);

console.log('End');

// Output:
// Start
// End
// Animation frame (before next paint)
// Timeout
```

---

## Long-Running Tasks

### Blocking the Event Loop

```javascript
console.log('Start');

// Bad - blocks event loop
for (let i = 0; i < 1000000000; i++) {
  // Long computation
}

console.log('End');

// UI freezes until loop completes
```

### Breaking Up Work

```javascript
function processLargeDataset(data) {
  let index = 0;
  const chunkSize = 1000;
  
  function processChunk() {
    const end = Math.min(index + chunkSize, data.length);
    
    for (let i = index; i < end; i++) {
      // Process item
      heavyComputation(data[i]);
    }
    
    index = end;
    
    if (index < data.length) {
      // Let event loop handle other tasks
      setTimeout(processChunk, 0);
    } else {
      console.log('Processing complete');
    }
  }
  
  processChunk();
}
```

---

## queueMicrotask

Explicitly queue a microtask.

```javascript
console.log('Start');

queueMicrotask(() => {
  console.log('Microtask');
});

Promise.resolve().then(() => {
  console.log('Promise');
});

console.log('End');

// Output: Start, End, Microtask, Promise
// or: Start, End, Promise, Microtask
// (both are microtasks, order may vary)
```

### Use Cases

```javascript
// Defer work until after DOM updates
function updateUI() {
  element.textContent = 'Updated';
  
  queueMicrotask(() => {
    // Guaranteed to run before next render
    console.log('Content:', element.textContent);
  });
}

// Batching operations
let pendingUpdates = [];

function scheduleUpdate(data) {
  pendingUpdates.push(data);
  
  if (pendingUpdates.length === 1) {
    queueMicrotask(flushUpdates);
  }
}

function flushUpdates() {
  const updates = pendingUpdates.slice();
  pendingUpdates = [];
  
  // Process all updates at once
  updates.forEach(processUpdate);
}
```

---

## Event Loop in Different Environments

### Browser

```javascript
// Browser has additional rendering phase
console.log('1');

setTimeout(() => console.log('2'), 0);

requestAnimationFrame(() => console.log('3'));

Promise.resolve().then(() => console.log('4'));

// Output: 1, 4, 3, 2
// Microtasks → Animation frames → Macrotasks
```

### Node.js

```javascript
// Node.js has different phases
setTimeout(() => console.log('setTimeout'), 0);
setImmediate(() => console.log('setImmediate'));
process.nextTick(() => console.log('nextTick'));
Promise.resolve().then(() => console.log('Promise'));

// Output (typical):
// nextTick
// Promise
// setTimeout (or setImmediate, order varies)
// setImmediate (or setTimeout)
```

---

## Debugging Event Loop

### Track Execution Order

```javascript
const log = [];

function track(message) {
  log.push(message);
  console.log(message);
}

track('Sync 1');

setTimeout(() => track('Macro 1'), 0);

Promise.resolve().then(() => track('Micro 1'));

setTimeout(() => track('Macro 2'), 0);

Promise.resolve().then(() => track('Micro 2'));

track('Sync 2');

// Check log array later
setTimeout(() => {
  console.log('Execution order:', log);
}, 100);
```

### Performance Monitoring

```javascript
function measureEventLoop() {
  let lastTime = performance.now();
  
  setInterval(() => {
    const currentTime = performance.now();
    const delay = currentTime - lastTime;
    
    if (delay > 100) {
      console.warn('Event loop blocked for', delay, 'ms');
    }
    
    lastTime = currentTime;
  }, 50);
}

measureEventLoop();
```

---

## Common Pitfalls

### Infinite Microtasks

```javascript
// Bad - starves macrotasks
function infiniteMicrotasks() {
  Promise.resolve().then(() => {
    console.log('Microtask');
    infiniteMicrotasks();
  });
}

// infiniteMicrotasks();  // Don't run!
// Macrotasks never execute
```

### Assuming Immediate Execution

```javascript
// Common misconception
setTimeout(() => {
  console.log('This is NOT immediate');
}, 0);

// Still waits for:
// 1. Current synchronous code
// 2. All microtasks
// 3. Previous macrotasks
```

### Promise Execution Timing

```javascript
console.log('1');

new Promise((resolve) => {
  console.log('2');  // Synchronous!
  resolve();
}).then(() => {
  console.log('3');  // Microtask
});

console.log('4');

// Output: 1, 2, 4, 3
// Promise executor is synchronous
```

---

## Best Practices

```javascript
// 1. Don't block the event loop
// Bad
for (let i = 0; i < 1000000000; i++) {}

// Good
function processInChunks(data) {
  const chunkSize = 1000;
  let index = 0;
  
  function next() {
    const end = Math.min(index + chunkSize, data.length);
    for (let i = index; i < end; i++) {
      process(data[i]);
    }
    index = end;
    if (index < data.length) setTimeout(next, 0);
  }
  
  next();
}

// 2. Use microtasks for immediate scheduling
queueMicrotask(() => {
  // Runs before next macrotask
});

// 3. Understand execution order
// Sync → Microtasks → Macrotask → Repeat

// 4. Use Web Workers for heavy computation
const worker = new Worker('heavy-task.js');
worker.postMessage(data);

// 5. Batch DOM updates
let updates = [];
queueMicrotask(() => {
  updates.forEach(applyUpdate);
  updates = [];
});
```

---

## Performance Tips

```javascript
// 1. Minimize work in each task
function efficientTask() {
  // Keep tasks small
  doMinimalWork();
  
  if (moreWork) {
    queueMicrotask(efficientTask);
  }
}

// 2. Use requestAnimationFrame for animations
requestAnimationFrame(animate);  // Not setTimeout

// 3. Debounce rapid events
const debounced = debounce(handler, 100);

// 4. Use passive listeners for scrolling
window.addEventListener('scroll', handler, { passive: true });

// 5. Profile event loop
console.time('task');
// ... work ...
console.timeEnd('task');
```

---

## Key Takeaways

- **Event Loop**: Coordinates call stack and task queues
- **Execution Order**: Sync → Microtasks → Macrotask → Repeat
- **Microtasks**: Promises, queueMicrotask (high priority)
- **Macrotasks**: setTimeout, setInterval (low priority)
- **One macrotask per iteration**: Then all microtasks
- **Rendering**: Between macrotasks (browsers)
- **Non-blocking**: Break up long tasks
- **queueMicrotask**: Explicit microtask scheduling
- Don't block the event loop with heavy computation
- Microtasks can starve macrotasks
- Understanding timing prevents bugs
- Use profiling to identify bottlenecks
