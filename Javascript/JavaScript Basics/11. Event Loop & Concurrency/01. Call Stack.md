# Call Stack

The call stack is a mechanism for JavaScript to keep track of function calls and execution context.

---

## What is the Call Stack?

A data structure that records where in the program we are. When we call a function, we push it onto the stack. When we return from a function, we pop it off the stack.

```javascript
function first() {
  console.log('First');
}

function second() {
  first();
  console.log('Second');
}

function third() {
  second();
  console.log('Third');
}

third();

// Call Stack:
// 1. third() pushed
// 2. second() pushed
// 3. first() pushed
// 4. first() pops (logs 'First')
// 5. second() pops (logs 'Second')
// 6. third() pops (logs 'Third')
```

---

## How It Works

### LIFO (Last In, First Out)

```javascript
function multiply(a, b) {
  return a * b;
}

function square(n) {
  return multiply(n, n);
}

function printSquare(n) {
  const result = square(n);
  console.log(result);
}

printSquare(5);

// Call Stack Visualization:
// Step 1: printSquare(5)
// Step 2: printSquare(5) -> square(5)
// Step 3: printSquare(5) -> square(5) -> multiply(5, 5)
// Step 4: printSquare(5) -> square(5)  [multiply returns]
// Step 5: printSquare(5)  [square returns]
// Step 6: [empty]  [printSquare returns]
```

---

## Stack Frames

Each function call creates a stack frame containing:
- Function arguments
- Local variables
- Return address

```javascript
function add(x, y) {
  const sum = x + y;  // Local variable
  return sum;
}

function calculate() {
  const a = 5;        // Local variable
  const b = 10;       // Local variable
  const result = add(a, b);  // add() creates new frame
  return result;
}

calculate();

// Stack Frame for calculate():
// - a: 5
// - b: 10
// - result: undefined (then 15)

// Stack Frame for add(5, 10):
// - x: 5
// - y: 10
// - sum: 15
```

---

## Execution Context

### Global Execution Context

```javascript
const globalVar = 'Global';  // Global context

function outer() {
  const outerVar = 'Outer';  // outer() context
  
  function inner() {
    const innerVar = 'Inner';  // inner() context
    console.log(globalVar, outerVar, innerVar);
  }
  
  inner();
}

outer();

// Execution contexts:
// 1. Global (globalVar, outer function)
// 2. outer() (outerVar, inner function)
// 3. inner() (innerVar)
```

### Function Execution Context

```javascript
function greet(name) {
  const message = `Hello, ${name}`;
  
  function sayHello() {
    console.log(message);  // Access parent scope
  }
  
  sayHello();
}

greet('John');

// greet() creates execution context with:
// - name: 'John'
// - message: 'Hello, John'
// - sayHello: function
```

---

## Visualizing the Call Stack

```javascript
function first() {
  console.log('First function');
  second();
  console.log('First function end');
}

function second() {
  console.log('Second function');
  third();
  console.log('Second function end');
}

function third() {
  console.log('Third function');
}

first();

// Output:
// First function
// Second function
// Third function
// Second function end
// First function end

// Stack Visualization:
// [first]
// [first, second]
// [first, second, third]
// [first, second]           (third returns)
// [first]                   (second returns)
// []                        (first returns)
```

---

## Stack Overflow

Occurs when the call stack exceeds its limit (usually from infinite recursion).

```javascript
// Infinite recursion - causes stack overflow
function recurse() {
  recurse();  // Calls itself forever
}

// recurse();  // Uncaught RangeError: Maximum call stack size exceeded
```

### Common Causes

```javascript
// 1. Missing base case
function factorial(n) {
  return n * factorial(n - 1);  // No base case!
}

// factorial(5);  // Stack overflow

// Fixed version
function factorial(n) {
  if (n <= 1) return 1;  // Base case
  return n * factorial(n - 1);
}

// 2. Incorrect recursion logic
function countdown(n) {
  console.log(n);
  countdown(n - 1);  // Never reaches base case if n is negative
}

// countdown(5);  // Stack overflow

// Fixed version
function countdown(n) {
  if (n < 0) return;  // Base case
  console.log(n);
  countdown(n - 1);
}
```

---

## Stack Size Limits

```javascript
// Find stack size limit (approximately)
function getStackSize() {
  let size = 0;
  
  function recurse() {
    size++;
    recurse();
  }
  
  try {
    recurse();
  } catch (e) {
    return size;
  }
}

console.log('Stack size:', getStackSize());
// Chrome: ~10,000-15,000 frames
// Firefox: ~50,000-100,000 frames
// Node.js: ~10,000-15,000 frames
```

---

## Recursion vs Iteration

### Recursive Approach (Uses Stack)

```javascript
function sumRecursive(n) {
  if (n <= 0) return 0;
  return n + sumRecursive(n - 1);
}

console.log(sumRecursive(5));  // 15
// Stack: [sum(5), sum(4), sum(3), sum(2), sum(1), sum(0)]
```

### Iterative Approach (No Stack Growth)

```javascript
function sumIterative(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

console.log(sumIterative(5));  // 15
// Stack: [sumIterative] (constant)
```

---

## Tail Call Optimization (TCO)

Some JavaScript engines optimize tail-recursive functions (currently limited support).

```javascript
// Not tail-recursive (does work after recursive call)
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);  // Multiplication after return
}

// Tail-recursive (recursive call is last operation)
function factorialTCO(n, acc = 1) {
  if (n <= 1) return acc;
  return factorialTCO(n - 1, n * acc);  // Nothing after recursive call
}

console.log(factorial(5));     // 120
console.log(factorialTCO(5));  // 120
```

### TCO Examples

```javascript
// Regular recursion
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);  // Multiple operations
}

// Tail-recursive version
function fibonacciTCO(n, a = 0, b = 1) {
  if (n === 0) return a;
  if (n === 1) return b;
  return fibonacciTCO(n - 1, b, a + b);  // Tail call
}

console.log(fibonacci(10));     // 55
console.log(fibonacciTCO(10));  // 55
```

---

## Debugging the Call Stack

### console.trace()

```javascript
function a() {
  b();
}

function b() {
  c();
}

function c() {
  console.trace('Call stack trace');
}

a();

// Output shows:
// c
// b
// a
// (anonymous) [global]
```

### Error Stack Traces

```javascript
function first() {
  second();
}

function second() {
  third();
}

function third() {
  throw new Error('Something went wrong');
}

try {
  first();
} catch (e) {
  console.log(e.stack);
  // Error: Something went wrong
  //     at third (...)
  //     at second (...)
  //     at first (...)
}
```

---

## Practical Examples

### Deep Object Access

```javascript
function getNestedValue(obj, path) {
  const keys = path.split('.');
  
  function recurse(obj, index) {
    if (index >= keys.length) return obj;
    if (!obj || typeof obj !== 'object') return undefined;
    return recurse(obj[keys[index]], index + 1);
  }
  
  return recurse(obj, 0);
}

const data = {
  user: {
    profile: {
      name: 'John',
      age: 30
    }
  }
};

console.log(getNestedValue(data, 'user.profile.name'));  // 'John'
```

### Tree Traversal

```javascript
const tree = {
  value: 1,
  children: [
    {
      value: 2,
      children: [
        { value: 4, children: [] },
        { value: 5, children: [] }
      ]
    },
    {
      value: 3,
      children: [
        { value: 6, children: [] }
      ]
    }
  ]
};

function traverseTree(node) {
  console.log(node.value);  // Process current node
  
  node.children.forEach(child => {
    traverseTree(child);  // Recursive call for each child
  });
}

traverseTree(tree);
// Output: 1, 2, 4, 5, 3, 6
```

### Calculate Expression

```javascript
function calculate(expression) {
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => a / b
  };
  
  function evaluate(tokens) {
    if (typeof tokens === 'number') {
      return tokens;
    }
    
    const [operator, ...operands] = tokens;
    const values = operands.map(evaluate);  // Recursive evaluation
    
    return values.reduce(operators[operator]);
  }
  
  return evaluate(expression);
}

const expr = ['+', 1, ['*', 2, 3], ['-', 10, 5]];
console.log(calculate(expr));  // 1 + (2 * 3) + (10 - 5) = 12
```

---

## Call Stack in Async Code

Synchronous code uses the call stack directly:

```javascript
function sync() {
  console.log('1');
  console.log('2');
  console.log('3');
}

sync();
// Stack: [sync] throughout execution
```

Asynchronous code doesn't block the stack:

```javascript
function async() {
  console.log('1');
  setTimeout(() => {
    console.log('2');  // Runs later, new call stack
  }, 0);
  console.log('3');
}

async();
// Output: 1, 3, 2

// Initial stack: [async]
// Later stack: [setTimeout callback]
```

---

## Performance Considerations

### Avoid Deep Recursion

```javascript
// Bad - deep recursion for large arrays
function sumArrayRecursive(arr, index = 0) {
  if (index >= arr.length) return 0;
  return arr[index] + sumArrayRecursive(arr, index + 1);
}

// Good - iterative approach
function sumArrayIterative(arr) {
  return arr.reduce((sum, num) => sum + num, 0);
}

const largeArray = Array.from({ length: 100000 }, (_, i) => i);
console.log(sumArrayIterative(largeArray));  // Works fine
// sumArrayRecursive(largeArray);  // Stack overflow!
```

### Convert Recursion to Iteration

```javascript
// Recursive
function reverseStringRecursive(str) {
  if (str === '') return '';
  return reverseStringRecursive(str.slice(1)) + str[0];
}

// Iterative
function reverseStringIterative(str) {
  let reversed = '';
  for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
  }
  return reversed;
}

console.log(reverseStringRecursive('hello'));  // 'olleh'
console.log(reverseStringIterative('hello'));  // 'olleh'
```

---

## Common Pitfalls

```javascript
// 1. Forgetting base case
function infiniteRecursion(n) {
  return infiniteRecursion(n - 1);  // No base case!
}

// 2. Incorrect base case
function badFibonacci(n) {
  if (n === 0) return 0;  // Missing n === 1 case
  return badFibonacci(n - 1) + badFibonacci(n - 2);
}

// 3. Stack overflow with large inputs
function countDownRecursive(n) {
  if (n === 0) return;
  console.log(n);
  countDownRecursive(n - 1);
}

// countDownRecursive(100000);  // Stack overflow!

// Better: Use iteration
function countDownIterative(n) {
  while (n > 0) {
    console.log(n);
    n--;
  }
}
```

---

## Best Practices

```javascript
// 1. Always include base case in recursion
function fibonacci(n) {
  if (n <= 1) return n;  // Base case
  return fibonacci(n - 1) + fibonacci(n - 2);
}

// 2. Use iteration for simple loops
// Prefer iteration over recursion for performance

// 3. Limit recursion depth
function safeRecursion(n, maxDepth = 1000) {
  if (n <= 0 || maxDepth <= 0) return;
  safeRecursion(n - 1, maxDepth - 1);
}

// 4. Use tail recursion when possible
function tailRecursive(n, acc = 0) {
  if (n <= 0) return acc;
  return tailRecursive(n - 1, acc + n);
}

// 5. Cache recursive results (memoization)
const cache = {};
function fibMemo(n) {
  if (n <= 1) return n;
  if (cache[n]) return cache[n];
  cache[n] = fibMemo(n - 1) + fibMemo(n - 2);
  return cache[n];
}
```

---

## Key Takeaways

- **Call stack**: LIFO structure tracking function calls
- **Stack frame**: Contains arguments, locals, return address
- **Stack overflow**: Too many function calls (usually recursion)
- **Execution context**: Created for each function call
- **Base case**: Essential for recursive functions
- **TCO**: Tail call optimization (limited support)
- Recursion uses stack, iteration doesn't
- Stack size is limited (~10,000-15,000 frames)
- Use `console.trace()` to debug call stack
- Prefer iteration for performance-critical code
- Always include base cases in recursive functions
- Consider memoization for recursive functions
