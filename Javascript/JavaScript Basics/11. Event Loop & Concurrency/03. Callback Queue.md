# Callback Queue

The callback queue (also called task queue or macrotask queue) holds callbacks from asynchronous operations waiting to be executed.

---

## What is the Callback Queue?

A queue that stores callbacks from Web APIs (setTimeout, DOM events, etc.) until the call stack is empty.

```javascript
console.log('Start');

setTimeout(() => {
  console.log('Timeout callback');
}, 0);

console.log('End');

// Output: Start, End, Timeout callback

// Execution flow:
// 1. 'Start' logged (call stack)
// 2. setTimeout sends callback to Web API
// 3. 'End' logged (call stack)
// 4. Call stack empty, event loop moves callback from queue to stack
// 5. 'Timeout callback' logged
```

---

## How It Works

### FIFO (First In, First Out)

```javascript
setTimeout(() => console.log('First'), 0);
setTimeout(() => console.log('Second'), 0);
setTimeout(() => console.log('Third'), 0);

// Output: First, Second, Third
// Callbacks execute in order they were queued
```

---

## Types of Tasks

### Macrotasks (Callback Queue)

- `setTimeout`
- `setInterval`
- `setImmediate` (Node.js)
- I/O operations
- UI rendering
- DOM events

```javascript
// All macrotasks
setTimeout(() => console.log('setTimeout'), 0);

setInterval(() => {
  console.log('setInterval');
  clearInterval(this);
}, 0);

document.addEventListener('click', () => {
  console.log('Click event');
});
```

---

## Event Loop Processing

```javascript
console.log('1');  // Synchronous

setTimeout(() => {
  console.log('2');  // Macrotask
}, 0);

Promise.resolve().then(() => {
  console.log('3');  // Microtask
});

console.log('4');  // Synchronous

// Output: 1, 4, 3, 2

// Order:
// 1. Execute all synchronous code (1, 4)
// 2. Execute all microtasks (3)
// 3. Execute one macrotask (2)
// 4. Repeat
```

---

## setTimeout Delay

Even with 0ms delay, callback waits for call stack to be empty.

```javascript
console.log('Start');

setTimeout(() => {
  console.log('Timeout');
}, 0);

for (let i = 0; i < 1000000000; i++) {
  // Long-running operation
}

console.log('End');

// Output: Start, End, Timeout
// setTimeout callback waits for loop to finish
```

### Minimum Delay

```javascript
// Browsers enforce minimum delay (~4ms after nested timers)
let start = Date.now();

setTimeout(() => {
  console.log('Actual delay:', Date.now() - start, 'ms');
}, 0);

// Usually logs: "Actual delay: 4-10 ms"
```

---

## setInterval Behavior

```javascript
let count = 0;

const intervalId = setInterval(() => {
  console.log('Interval', ++count);
  
  if (count === 5) {
    clearInterval(intervalId);
  }
}, 100);

// Callbacks added to queue every 100ms
// If callback takes longer than interval, callbacks stack up
```

### setInterval Drift

```javascript
// setInterval can drift if callbacks take too long
let startTime = Date.now();
let count = 0;

setInterval(() => {
  count++;
  console.log(`Interval ${count}, elapsed:`, Date.now() - startTime);
  
  // Simulate long task
  for (let i = 0; i < 100000000; i++) {}
}, 100);

// Intervals may not be exactly 100ms apart
```

### Recursive setTimeout (Better Control)

```javascript
let count = 0;

function repeatedTimeout() {
  console.log('Timeout', ++count);
  
  if (count < 5) {
    setTimeout(repeatedTimeout, 100);
  }
}

setTimeout(repeatedTimeout, 100);

// Ensures 100ms gap between end of one callback and start of next
```

---

## DOM Event Callbacks

```javascript
const button = document.getElementById('button');

button.addEventListener('click', () => {
  console.log('Click callback 1');
});

button.addEventListener('click', () => {
  console.log('Click callback 2');
});

// When button clicked:
// Both callbacks added to queue in order
// Output: Click callback 1, Click callback 2
```

---

## Callback Queue vs Microtask Queue

```javascript
console.log('1: Synchronous');

setTimeout(() => {
  console.log('2: Macrotask (setTimeout)');
}, 0);

Promise.resolve().then(() => {
  console.log('3: Microtask (Promise)');
});

setTimeout(() => {
  console.log('4: Macrotask (setTimeout)');
}, 0);

Promise.resolve().then(() => {
  console.log('5: Microtask (Promise)');
});

console.log('6: Synchronous');

// Output: 1, 6, 3, 5, 2, 4

// Execution order:
// 1. All synchronous code (1, 6)
// 2. All microtasks (3, 5)
// 3. One macrotask (2)
// 4. Check microtasks (empty)
// 5. Next macrotask (4)
```

---

## Practical Examples

### Defer Execution

```javascript
// Execute after current call stack clears
function deferExecution(callback) {
  setTimeout(callback, 0);
}

console.log('Before');

deferExecution(() => {
  console.log('Deferred');
});

console.log('After');

// Output: Before, After, Deferred
```

### Break Up Long Tasks

```javascript
function processLargeArray(array) {
  let index = 0;
  const chunkSize = 100;
  
  function processChunk() {
    const end = Math.min(index + chunkSize, array.length);
    
    for (let i = index; i < end; i++) {
      // Process item
      heavyOperation(array[i]);
    }
    
    index = end;
    
    if (index < array.length) {
      // Schedule next chunk
      setTimeout(processChunk, 0);
    } else {
      console.log('Processing complete');
    }
  }
  
  processChunk();
}

// Prevents UI from freezing
processLargeArray(largeArray);
```

### Debouncing

```javascript
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    // Clear previous timeout
    clearTimeout(timeoutId);
    
    // Schedule new timeout
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

const debouncedSearch = debounce((query) => {
  console.log('Searching for:', query);
}, 300);

// Multiple rapid calls only execute once after 300ms
debouncedSearch('a');
debouncedSearch('ab');
debouncedSearch('abc');
// Only logs: "Searching for: abc" (after 300ms)
```

### Throttling

```javascript
function throttle(func, limit) {
  let inThrottle;
  
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      
      setTimeout(() => {
        inThrottle = false;
      }, limit);
    }
  };
}

const throttledScroll = throttle(() => {
  console.log('Scroll event');
}, 100);

window.addEventListener('scroll', throttledScroll);
// Executes at most once per 100ms
```

---

## Animation with setTimeout

```javascript
function animate() {
  const element = document.getElementById('box');
  let position = 0;
  
  function move() {
    position += 1;
    element.style.left = position + 'px';
    
    if (position < 300) {
      setTimeout(move, 16);  // ~60fps
    }
  }
  
  move();
}

// Better: use requestAnimationFrame
function animateRAF() {
  const element = document.getElementById('box');
  let position = 0;
  
  function move() {
    position += 1;
    element.style.left = position + 'px';
    
    if (position < 300) {
      requestAnimationFrame(move);
    }
  }
  
  requestAnimationFrame(move);
}
```

---

## Queue Management

### Clear Pending Timeouts

```javascript
const timeouts = [];

function scheduleTask(callback, delay) {
  const id = setTimeout(callback, delay);
  timeouts.push(id);
  return id;
}

function clearAllTimeouts() {
  timeouts.forEach(id => clearTimeout(id));
  timeouts.length = 0;
}

// Schedule tasks
scheduleTask(() => console.log('Task 1'), 1000);
scheduleTask(() => console.log('Task 2'), 2000);
scheduleTask(() => console.log('Task 3'), 3000);

// Cancel all
clearAllTimeouts();
```

---

## Callback Queue in Different Environments

### Browser

```javascript
// Macrotasks in browser:
setTimeout(callback, 0);
setInterval(callback, 100);
requestAnimationFrame(callback);

document.addEventListener('click', callback);

// UI rendering happens between macrotasks
```

### Node.js

```javascript
// Additional macrotasks in Node.js:
setImmediate(callback);  // Executes after I/O events

fs.readFile('file.txt', callback);  // I/O operation

// setImmediate vs setTimeout
setTimeout(() => console.log('setTimeout'), 0);
setImmediate(() => console.log('setImmediate'));

// Order may vary, but setImmediate usually first
```

---

## Starvation Prevention

Event loop ensures callback queue doesn't starve.

```javascript
// Microtasks can starve macrotasks
function infiniteMicrotasks() {
  Promise.resolve().then(() => {
    console.log('Microtask');
    infiniteMicrotasks();  // Creates infinite microtasks
  });
}

setTimeout(() => {
  console.log('This may never run!');
}, 0);

// infiniteMicrotasks();  // Don't run this!
// Macrotask never executes because microtask queue never empties
```

---

## Common Patterns

### Delayed Execution

```javascript
// Execute after all synchronous code
setTimeout(() => {
  console.log('Runs last');
}, 0);
```

### Polling

```javascript
function pollForElement(selector, callback, maxAttempts = 10) {
  let attempts = 0;
  
  const interval = setInterval(() => {
    const element = document.querySelector(selector);
    
    if (element) {
      clearInterval(interval);
      callback(element);
    } else if (++attempts >= maxAttempts) {
      clearInterval(interval);
      console.log('Element not found');
    }
  }, 100);
}

pollForElement('#dynamic-element', (element) => {
  console.log('Found element:', element);
});
```

### Batch Processing

```javascript
function batchProcess(items, batchSize, processItem) {
  let index = 0;
  
  function processBatch() {
    const end = Math.min(index + batchSize, items.length);
    
    for (let i = index; i < end; i++) {
      processItem(items[i]);
    }
    
    index = end;
    
    if (index < items.length) {
      setTimeout(processBatch, 0);
    }
  }
  
  processBatch();
}

batchProcess(largeArray, 1000, item => {
  // Process each item
});
```

---

## Performance Considerations

```javascript
// Avoid excessive setTimeout(0) calls
// Bad
for (let i = 0; i < 10000; i++) {
  setTimeout(() => console.log(i), 0);
}

// Better - batch operations
const items = Array.from({ length: 10000 }, (_, i) => i);
batchProcess(items, 100, item => console.log(item));

// Use requestAnimationFrame for animations
// Not setTimeout
```

---

## Debugging Callback Queue

```javascript
// Log when callbacks execute
function loggedSetTimeout(callback, delay, label) {
  console.log(`Scheduling: ${label}`);
  
  setTimeout(() => {
    console.log(`Executing: ${label}`);
    callback();
  }, delay);
}

loggedSetTimeout(() => {
  console.log('Task 1');
}, 100, 'Task 1');

loggedSetTimeout(() => {
  console.log('Task 2');
}, 50, 'Task 2');

// Output:
// Scheduling: Task 1
// Scheduling: Task 2
// Executing: Task 2
// Task 2
// Executing: Task 1
// Task 1
```

---

## Best Practices

```javascript
// 1. Always clear timers when done
const timerId = setTimeout(callback, 1000);
clearTimeout(timerId);

// 2. Use setTimeout for delay between executions
function repeatedTask() {
  doWork();
  setTimeout(repeatedTask, 1000);
}

// 3. Batch heavy operations
function processHeavyTask(items) {
  const batchSize = 100;
  let index = 0;
  
  function processBatch() {
    const end = Math.min(index + batchSize, items.length);
    for (let i = index; i < end; i++) {
      heavyOperation(items[i]);
    }
    index = end;
    if (index < items.length) {
      setTimeout(processBatch, 0);
    }
  }
  
  processBatch();
}

// 4. Prefer requestAnimationFrame for animations
requestAnimationFrame(animateFrame);

// 5. Debounce/throttle rapid events
const debouncedFn = debounce(expensiveFn, 300);
```

---

## Key Takeaways

- **Callback Queue**: FIFO queue for macrotask callbacks
- **Macrotasks**: setTimeout, setInterval, DOM events, I/O
- **Execution**: After call stack empties and microtasks complete
- **Minimum delay**: ~4ms for nested setTimeout
- **setInterval drift**: Can accumulate delays
- **Recursive setTimeout**: Better control than setInterval
- **setTimeout(fn, 0)**: Defers execution, not immediate
- Event loop processes one macrotask per iteration
- Microtasks have priority over macrotasks
- Clear timers to prevent memory leaks
- Batch heavy operations to avoid blocking
- Use debounce/throttle for rapid events
