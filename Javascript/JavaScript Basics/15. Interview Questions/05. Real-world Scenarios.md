# Real-world Scenarios

Practical JavaScript interview questions based on real-world applications.

---

## Scenario 1: Auto-save Feature

**Problem:** Implement an auto-save feature that saves user input after they stop typing for 500ms.

```javascript
class AutoSave {
  constructor(saveCallback, delay = 500) {
    this.saveCallback = saveCallback;
    this.delay = delay;
    this.timeoutId = null;
  }
  
  handleInput(value) {
    // Clear previous timeout
    clearTimeout(this.timeoutId);
    
    // Set new timeout
    this.timeoutId = setTimeout(() => {
      this.saveCallback(value);
    }, this.delay);
  }
  
  saveNow(value) {
    clearTimeout(this.timeoutId);
    this.saveCallback(value);
  }
  
  cancel() {
    clearTimeout(this.timeoutId);
  }
}

// Usage
const autoSave = new AutoSave((value) => {
  console.log('Saving:', value);
  // API call to save
  fetch('/api/save', {
    method: 'POST',
    body: JSON.stringify({ content: value })
  });
}, 500);

const textarea = document.getElementById('editor');
textarea.addEventListener('input', (e) => {
  autoSave.handleInput(e.target.value);
});

// Save immediately on blur
textarea.addEventListener('blur', (e) => {
  autoSave.saveNow(e.target.value);
});
```

---

## Scenario 2: Infinite Scroll

**Problem:** Implement infinite scroll that loads more items when user reaches bottom.

```javascript
class InfiniteScroll {
  constructor(loadMoreCallback, threshold = 100) {
    this.loadMoreCallback = loadMoreCallback;
    this.threshold = threshold;
    this.loading = false;
    this.hasMore = true;
    
    this.handleScroll = this.throttle(this.checkScroll.bind(this), 200);
    window.addEventListener('scroll', this.handleScroll);
  }
  
  checkScroll() {
    if (this.loading || !this.hasMore) return;
    
    const scrollTop = window.scrollY;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    
    const distanceFromBottom = documentHeight - (scrollTop + windowHeight);
    
    if (distanceFromBottom < this.threshold) {
      this.loadMore();
    }
  }
  
  async loadMore() {
    this.loading = true;
    
    try {
      const hasMore = await this.loadMoreCallback();
      this.hasMore = hasMore;
    } catch (error) {
      console.error('Failed to load more:', error);
    } finally {
      this.loading = false;
    }
  }
  
  throttle(func, interval) {
    let lastTime = 0;
    return function(...args) {
      const now = Date.now();
      if (now - lastTime >= interval) {
        lastTime = now;
        func.apply(this, args);
      }
    };
  }
  
  destroy() {
    window.removeEventListener('scroll', this.handleScroll);
  }
}

// Usage
let page = 1;
const infiniteScroll = new InfiniteScroll(async () => {
  const response = await fetch(`/api/items?page=${page}`);
  const data = await response.json();
  
  // Append items to DOM
  data.items.forEach(item => {
    const element = createItemElement(item);
    document.getElementById('items-container').appendChild(element);
  });
  
  page++;
  
  return data.hasMore;  // Return whether there are more items
});
```

---

## Scenario 3: Form Validation

**Problem:** Implement a reusable form validation system.

```javascript
class FormValidator {
  constructor(form) {
    this.form = form;
    this.errors = {};
    this.rules = {};
  }
  
  addRule(fieldName, validators) {
    this.rules[fieldName] = validators;
    return this;
  }
  
  validate() {
    this.errors = {};
    
    for (const [fieldName, validators] of Object.entries(this.rules)) {
      const field = this.form.elements[fieldName];
      const value = field ? field.value : '';
      
      for (const validator of validators) {
        const error = validator(value, this.form);
        if (error) {
          if (!this.errors[fieldName]) {
            this.errors[fieldName] = [];
          }
          this.errors[fieldName].push(error);
        }
      }
    }
    
    return Object.keys(this.errors).length === 0;
  }
  
  getErrors() {
    return this.errors;
  }
  
  displayErrors() {
    // Clear previous errors
    this.form.querySelectorAll('.error-message').forEach(el => el.remove());
    this.form.querySelectorAll('.error').forEach(el => el.classList.remove('error'));
    
    // Display new errors
    for (const [fieldName, errors] of Object.entries(this.errors)) {
      const field = this.form.elements[fieldName];
      if (!field) continue;
      
      field.classList.add('error');
      
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.textContent = errors[0];  // Show first error
      field.parentNode.insertBefore(errorDiv, field.nextSibling);
    }
  }
}

// Validator functions
const validators = {
  required: (message = 'This field is required') => {
    return (value) => {
      return value.trim() === '' ? message : null;
    };
  },
  
  minLength: (min, message) => {
    return (value) => {
      return value.length < min 
        ? message || `Minimum ${min} characters required`
        : null;
    };
  },
  
  maxLength: (max, message) => {
    return (value) => {
      return value.length > max
        ? message || `Maximum ${max} characters allowed`
        : null;
    };
  },
  
  email: (message = 'Invalid email address') => {
    return (value) => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return !emailRegex.test(value) ? message : null;
    };
  },
  
  pattern: (regex, message = 'Invalid format') => {
    return (value) => {
      return !regex.test(value) ? message : null;
    };
  },
  
  matchField: (otherFieldName, message = 'Fields do not match') => {
    return (value, form) => {
      const otherField = form.elements[otherFieldName];
      return value !== otherField.value ? message : null;
    };
  }
};

// Usage
const form = document.getElementById('signup-form');
const validator = new FormValidator(form);

validator
  .addRule('email', [
    validators.required(),
    validators.email()
  ])
  .addRule('password', [
    validators.required(),
    validators.minLength(8, 'Password must be at least 8 characters')
  ])
  .addRule('confirmPassword', [
    validators.required(),
    validators.matchField('password', 'Passwords do not match')
  ]);

form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  if (validator.validate()) {
    console.log('Form is valid');
    // Submit form
  } else {
    validator.displayErrors();
  }
});
```

---

## Scenario 4: Search with Autocomplete

**Problem:** Implement a search input with autocomplete suggestions.

```javascript
class Autocomplete {
  constructor(input, searchCallback, options = {}) {
    this.input = input;
    this.searchCallback = searchCallback;
    this.debounceDelay = options.debounceDelay || 300;
    this.minChars = options.minChars || 2;
    this.maxResults = options.maxResults || 10;
    
    this.resultsContainer = null;
    this.selectedIndex = -1;
    
    this.init();
  }
  
  init() {
    // Create results container
    this.resultsContainer = document.createElement('div');
    this.resultsContainer.className = 'autocomplete-results';
    this.input.parentNode.appendChild(this.resultsContainer);
    
    // Event listeners
    this.input.addEventListener('input', this.debounce(this.handleInput.bind(this), this.debounceDelay));
    this.input.addEventListener('keydown', this.handleKeydown.bind(this));
    document.addEventListener('click', this.handleClickOutside.bind(this));
  }
  
  async handleInput(e) {
    const query = e.target.value.trim();
    
    if (query.length < this.minChars) {
      this.hideResults();
      return;
    }
    
    try {
      const results = await this.searchCallback(query);
      this.showResults(results.slice(0, this.maxResults));
    } catch (error) {
      console.error('Search error:', error);
      this.hideResults();
    }
  }
  
  showResults(results) {
    if (results.length === 0) {
      this.hideResults();
      return;
    }
    
    this.resultsContainer.innerHTML = '';
    this.selectedIndex = -1;
    
    results.forEach((result, index) => {
      const item = document.createElement('div');
      item.className = 'autocomplete-item';
      item.textContent = result.text || result;
      item.dataset.index = index;
      
      item.addEventListener('click', () => {
        this.selectResult(result);
      });
      
      this.resultsContainer.appendChild(item);
    });
    
    this.resultsContainer.style.display = 'block';
  }
  
  hideResults() {
    this.resultsContainer.style.display = 'none';
    this.resultsContainer.innerHTML = '';
    this.selectedIndex = -1;
  }
  
  handleKeydown(e) {
    const items = this.resultsContainer.querySelectorAll('.autocomplete-item');
    
    if (items.length === 0) return;
    
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectedIndex = Math.min(this.selectedIndex + 1, items.length - 1);
        this.updateSelection(items);
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
        this.updateSelection(items);
        break;
        
      case 'Enter':
        e.preventDefault();
        if (this.selectedIndex >= 0) {
          items[this.selectedIndex].click();
        }
        break;
        
      case 'Escape':
        this.hideResults();
        break;
    }
  }
  
  updateSelection(items) {
    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add('selected');
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove('selected');
      }
    });
  }
  
  selectResult(result) {
    this.input.value = result.text || result;
    this.hideResults();
    this.input.dispatchEvent(new CustomEvent('select', { detail: result }));
  }
  
  handleClickOutside(e) {
    if (!this.input.contains(e.target) && !this.resultsContainer.contains(e.target)) {
      this.hideResults();
    }
  }
  
  debounce(func, delay) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
  }
}

// Usage
const searchInput = document.getElementById('search');
const autocomplete = new Autocomplete(searchInput, async (query) => {
  const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
  const data = await response.json();
  return data.results;
}, {
  debounceDelay: 300,
  minChars: 2,
  maxResults: 10
});

searchInput.addEventListener('select', (e) => {
  console.log('Selected:', e.detail);
  // Navigate or perform action
});
```

---

## Scenario 5: Rate Limiting API Calls

**Problem:** Implement a rate limiter that prevents exceeding API call limits.

```javascript
class RateLimiter {
  constructor(maxRequests, timeWindow) {
    this.maxRequests = maxRequests;  // e.g., 10
    this.timeWindow = timeWindow;    // e.g., 1000ms
    this.requests = [];
  }
  
  async execute(fn) {
    await this.waitForSlot();
    
    try {
      return await fn();
    } finally {
      this.requests.push(Date.now());
    }
  }
  
  async waitForSlot() {
    this.cleanup();
    
    if (this.requests.length >= this.maxRequests) {
      const oldestRequest = this.requests[0];
      const timeToWait = this.timeWindow - (Date.now() - oldestRequest);
      
      if (timeToWait > 0) {
        await this.sleep(timeToWait);
        this.cleanup();
      }
    }
  }
  
  cleanup() {
    const now = Date.now();
    this.requests = this.requests.filter(
      timestamp => now - timestamp < this.timeWindow
    );
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  getRemainingRequests() {
    this.cleanup();
    return this.maxRequests - this.requests.length;
  }
}

// Usage
const limiter = new RateLimiter(10, 1000);  // 10 requests per second

async function fetchData(id) {
  return limiter.execute(async () => {
    const response = await fetch(`/api/data/${id}`);
    return response.json();
  });
}

// Make multiple requests
const ids = Array.from({ length: 50 }, (_, i) => i);
const results = await Promise.all(ids.map(id => fetchData(id)));
// Automatically rate-limited to 10 requests per second
```

---

## Scenario 6: Undo/Redo Functionality

**Problem:** Implement undo/redo for a text editor.

```javascript
class UndoRedoManager {
  constructor(maxHistorySize = 50) {
    this.history = [];
    this.currentIndex = -1;
    this.maxHistorySize = maxHistorySize;
  }
  
  execute(command) {
    // Remove any future history when new command is executed
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    // Add new command
    this.history.push(command);
    
    // Limit history size
    if (this.history.length > this.maxHistorySize) {
      this.history.shift();
    } else {
      this.currentIndex++;
    }
    
    // Execute command
    command.execute();
  }
  
  undo() {
    if (!this.canUndo()) return;
    
    const command = this.history[this.currentIndex];
    command.undo();
    this.currentIndex--;
  }
  
  redo() {
    if (!this.canRedo()) return;
    
    this.currentIndex++;
    const command = this.history[this.currentIndex];
    command.execute();
  }
  
  canUndo() {
    return this.currentIndex >= 0;
  }
  
  canRedo() {
    return this.currentIndex < this.history.length - 1;
  }
  
  clear() {
    this.history = [];
    this.currentIndex = -1;
  }
}

// Command pattern
class TextCommand {
  constructor(editor, newValue, oldValue) {
    this.editor = editor;
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
  
  execute() {
    this.editor.value = this.newValue;
  }
  
  undo() {
    this.editor.value = this.oldValue;
  }
}

// Usage
const editor = document.getElementById('editor');
const undoRedoManager = new UndoRedoManager();

let lastValue = editor.value;

// Debounce input to avoid recording every keystroke
const debounceDelay = 500;
let inputTimeout;

editor.addEventListener('input', () => {
  clearTimeout(inputTimeout);
  
  inputTimeout = setTimeout(() => {
    const newValue = editor.value;
    
    if (newValue !== lastValue) {
      const command = new TextCommand(editor, newValue, lastValue);
      undoRedoManager.execute(command);
      lastValue = newValue;
    }
  }, debounceDelay);
});

// Undo/Redo keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    if (e.key === 'z' && !e.shiftKey) {
      e.preventDefault();
      undoRedoManager.undo();
      lastValue = editor.value;
    } else if ((e.key === 'z' && e.shiftKey) || e.key === 'y') {
      e.preventDefault();
      undoRedoManager.redo();
      lastValue = editor.value;
    }
  }
});
```

---

## Scenario 7: Lazy Loading Images

**Problem:** Implement lazy loading for images using Intersection Observer.

```javascript
class LazyImageLoader {
  constructor(options = {}) {
    this.rootMargin = options.rootMargin || '50px';
    this.threshold = options.threshold || 0.01;
    this.onLoad = options.onLoad || (() => {});
    this.onError = options.onError || (() => {});
    
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: this.rootMargin,
        threshold: this.threshold
      }
    );
    
    this.images = new Set();
  }
  
  observe(img) {
    if (!img || this.images.has(img)) return;
    
    this.images.add(img);
    this.observer.observe(img);
  }
  
  observeAll(selector = 'img[data-src]') {
    const images = document.querySelectorAll(selector);
    images.forEach(img => this.observe(img));
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        this.loadImage(img);
        this.observer.unobserve(img);
        this.images.delete(img);
      }
    });
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    const srcset = img.dataset.srcset;
    
    if (!src) return;
    
    // Create temp image to preload
    const tempImg = new Image();
    
    tempImg.onload = () => {
      img.src = src;
      if (srcset) img.srcset = srcset;
      img.classList.add('loaded');
      this.onLoad(img);
    };
    
    tempImg.onerror = () => {
      img.classList.add('error');
      this.onError(img);
    };
    
    tempImg.src = src;
    if (srcset) tempImg.srcset = srcset;
  }
  
  disconnect() {
    this.observer.disconnect();
    this.images.clear();
  }
}

// Usage
const lazyLoader = new LazyImageLoader({
  rootMargin: '100px',
  onLoad: (img) => {
    console.log('Loaded:', img.dataset.src);
  },
  onError: (img) => {
    console.error('Failed to load:', img.dataset.src);
    img.src = '/images/placeholder.jpg';  // Fallback
  }
});

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  lazyLoader.observeAll('img[data-src]');
});

// Observe new images added dynamically
function addImage(src) {
  const img = document.createElement('img');
  img.dataset.src = src;
  img.alt = 'Lazy loaded image';
  document.getElementById('gallery').appendChild(img);
  
  lazyLoader.observe(img);
}
```

---

## Scenario 8: Shopping Cart

**Problem:** Implement a shopping cart with add/remove items and total calculation.

```javascript
class ShoppingCart {
  constructor() {
    this.items = new Map();
    this.listeners = [];
  }
  
  addItem(product, quantity = 1) {
    const existingItem = this.items.get(product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.items.set(product.id, {
        product,
        quantity
      });
    }
    
    this.notifyListeners();
  }
  
  removeItem(productId) {
    this.items.delete(productId);
    this.notifyListeners();
  }
  
  updateQuantity(productId, quantity) {
    if (quantity <= 0) {
      this.removeItem(productId);
      return;
    }
    
    const item = this.items.get(productId);
    if (item) {
      item.quantity = quantity;
      this.notifyListeners();
    }
  }
  
  getItem(productId) {
    return this.items.get(productId);
  }
  
  getAllItems() {
    return Array.from(this.items.values());
  }
  
  getItemCount() {
    return Array.from(this.items.values())
      .reduce((total, item) => total + item.quantity, 0);
  }
  
  getSubtotal() {
    return Array.from(this.items.values())
      .reduce((total, item) => {
        return total + (item.product.price * item.quantity);
      }, 0);
  }
  
  getTax(taxRate = 0.1) {
    return this.getSubtotal() * taxRate;
  }
  
  getTotal(taxRate = 0.1) {
    return this.getSubtotal() + this.getTax(taxRate);
  }
  
  clear() {
    this.items.clear();
    this.notifyListeners();
  }
  
  isEmpty() {
    return this.items.size === 0;
  }
  
  // Observer pattern
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  notifyListeners() {
    const state = {
      items: this.getAllItems(),
      itemCount: this.getItemCount(),
      subtotal: this.getSubtotal(),
      total: this.getTotal()
    };
    
    this.listeners.forEach(listener => listener(state));
  }
  
  // Persistence
  saveToLocalStorage() {
    const data = {
      items: Array.from(this.items.entries())
    };
    localStorage.setItem('shopping-cart', JSON.stringify(data));
  }
  
  loadFromLocalStorage() {
    const data = localStorage.getItem('shopping-cart');
    if (data) {
      const parsed = JSON.parse(data);
      this.items = new Map(parsed.items);
      this.notifyListeners();
    }
  }
}

// Usage
const cart = new ShoppingCart();

// Subscribe to changes
cart.subscribe((state) => {
  console.log('Cart updated:', state);
  updateCartUI(state);
  cart.saveToLocalStorage();
});

// Add items
cart.addItem({ id: 1, name: 'Laptop', price: 999 }, 1);
cart.addItem({ id: 2, name: 'Mouse', price: 25 }, 2);

// Update quantity
cart.updateQuantity(2, 3);

// Get totals
console.log('Subtotal:', cart.getSubtotal());  // 1049
console.log('Total:', cart.getTotal());        // 1153.90

// Load from storage on page load
cart.loadFromLocalStorage();
```

---

## Key Takeaways

- **Debouncing**: Essential for search, auto-save
- **Throttling**: Important for scroll, resize events
- **Observer pattern**: Notify listeners of state changes
- **Command pattern**: Useful for undo/redo
- **Intersection Observer**: Efficient lazy loading
- **Rate limiting**: Prevent API abuse
- **Validation**: Reusable validator functions
- **Persistence**: localStorage for client-side storage
- **Event delegation**: Efficient event handling
- **State management**: Centralized data flow
- Real-world scenarios test practical skills
- Consider performance and UX
- Handle edge cases and errors gracefully
