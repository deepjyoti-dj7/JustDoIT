# Output-based Questions

Predict the output of JavaScript code snippets.

---

## Question 1: Variable Hoisting

**What is the output?**

```javascript
console.log(a);
var a = 10;
console.log(a);
```

**Answer:**
```
undefined
10
```

**Explanation:**
`var` declarations are hoisted to the top but initialized as `undefined`. The code is interpreted as:
```javascript
var a;
console.log(a);  // undefined
a = 10;
console.log(a);  // 10
```

---

## Question 2: Function Hoisting

**What is the output?**

```javascript
greet();

function greet() {
  console.log('Hello');
}

hello();

var hello = function() {
  console.log('Hi');
};
```

**Answer:**
```
Hello
TypeError: hello is not a function
```

**Explanation:**
Function declarations are fully hoisted, but function expressions are not. The code is interpreted as:
```javascript
function greet() {
  console.log('Hello');
}
var hello;

greet();  // "Hello"
hello();  // TypeError (hello is undefined)

hello = function() {
  console.log('Hi');
};
```

---

## Question 3: Closure

**What is the output?**

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
```

**Answer:**
```
3
3
3
```

**Explanation:**
`var` is function-scoped. All setTimeout callbacks reference the same `i` variable, which is 3 after the loop completes.

**Fix with let:**
```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// Output: 0, 1, 2
```

---

## Question 4: Event Loop

**What is the output?**

```javascript
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');
```

**Answer:**
```
1
4
3
2
```

**Explanation:**
1. Synchronous code executes first: `1`, `4`
2. Microtasks (Promises) execute next: `3`
3. Macrotasks (setTimeout) execute last: `2`

---

## Question 5: this Binding

**What is the output?**

```javascript
const obj = {
  name: 'John',
  greet: function() {
    console.log(this.name);
  }
};

obj.greet();
const greetFunc = obj.greet;
greetFunc();
```

**Answer:**
```
John
undefined
```

**Explanation:**
- `obj.greet()`: `this` is `obj`
- `greetFunc()`: `this` is `window` (or `undefined` in strict mode), which doesn't have a `name` property

---

## Question 6: Arrow Functions and this

**What is the output?**

```javascript
const obj = {
  name: 'John',
  greet: () => {
    console.log(this.name);
  }
};

obj.greet();
```

**Answer:**
```
undefined
```

**Explanation:**
Arrow functions don't have their own `this`. They inherit `this` from the enclosing scope (global/window in this case), not from `obj`.

---

## Question 7: Type Coercion

**What is the output?**

```javascript
console.log(1 + '2' + 3);
console.log(1 + 2 + '3');
console.log('1' - 1);
console.log('5' * 2);
console.log(true + false);
console.log([] + []);
console.log([] + {});
console.log({} + []);
```

**Answer:**
```
"123"
"33"
0
10
1
""
"[object Object]"
"[object Object]"
```

**Explanation:**
- `+` with string: concatenation
- `-`, `*`: converts to numbers
- `true` = 1, `false` = 0
- `[]` converts to empty string
- `{}` converts to "[object Object]"

---

## Question 8: Equality Comparison

**What is the output?**

```javascript
console.log(0 == false);
console.log(0 === false);
console.log('' == false);
console.log('' === false);
console.log(null == undefined);
console.log(null === undefined);
console.log(NaN == NaN);
console.log(NaN === NaN);
```

**Answer:**
```
true
false
true
false
true
false
false
false
```

**Explanation:**
- `==` performs type coercion
- `===` checks type and value
- `null == undefined` is true by spec
- `NaN` is never equal to anything, including itself

---

## Question 9: Array Methods

**What is the output?**

```javascript
const arr = [1, 2, 3];
const result = arr.map(num => {
  if (num === 2) return;
  return num * 2;
});

console.log(result);
```

**Answer:**
```
[2, undefined, 6]
```

**Explanation:**
When `return` is used without a value, it returns `undefined`. The condition `num === 2` returns `undefined`, not skipping the element.

---

## Question 10: Object Reference

**What is the output?**

```javascript
const obj1 = { a: 1 };
const obj2 = obj1;
obj2.a = 2;

console.log(obj1.a);
console.log(obj2.a);
```

**Answer:**
```
2
2
```

**Explanation:**
Objects are passed by reference. `obj2` points to the same object as `obj1`, so modifying `obj2` affects `obj1`.

---

## Question 11: Array Mutation

**What is the output?**

```javascript
const arr = [1, 2, 3];
const sorted = arr.sort((a, b) => b - a);

console.log(arr);
console.log(sorted);
console.log(arr === sorted);
```

**Answer:**
```
[3, 2, 1]
[3, 2, 1]
true
```

**Explanation:**
`sort()` mutates the original array and returns a reference to it. Both `arr` and `sorted` point to the same array.

---

## Question 12: Temporal Dead Zone

**What is the output?**

```javascript
console.log(a);
let a = 10;
```

**Answer:**
```
ReferenceError: Cannot access 'a' before initialization
```

**Explanation:**
`let` and `const` are hoisted but not initialized. Accessing them before declaration causes a ReferenceError (Temporal Dead Zone).

---

## Question 13: Spread Operator

**What is the output?**

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];

arr1.push(0);
console.log(combined);
```

**Answer:**
```
[1, 2, 3, 4, 5, 6]
```

**Explanation:**
Spread operator creates a shallow copy. Changes to `arr1` after spreading don't affect `combined`.

---

## Question 14: Default Parameters

**What is the output?**

```javascript
function greet(name = 'Guest') {
  console.log(`Hello, ${name}`);
}

greet('John');
greet();
greet(undefined);
greet(null);
greet('');
```

**Answer:**
```
Hello, John
Hello, Guest
Hello, Guest
Hello, null
Hello,
```

**Explanation:**
Default parameter is used only when argument is `undefined`. `null` and `''` are valid values.

---

## Question 15: Promise Execution

**What is the output?**

```javascript
const promise = new Promise((resolve, reject) => {
  console.log('1');
  resolve('2');
  console.log('3');
});

promise.then(result => console.log(result));

console.log('4');
```

**Answer:**
```
1
3
4
2
```

**Explanation:**
1. Promise executor runs synchronously: `1`, `3`
2. Synchronous code continues: `4`
3. Promise resolution (microtask): `2`

---

## Question 16: Destructuring

**What is the output?**

```javascript
const { a, b, c } = { a: 1, b: 2 };
console.log(a, b, c);
```

**Answer:**
```
1 2 undefined
```

**Explanation:**
Destructuring non-existent properties results in `undefined`.

---

## Question 17: setTimeout Order

**What is the output?**

```javascript
setTimeout(() => console.log('1'), 0);
setTimeout(() => console.log('2'), 10);
setTimeout(() => console.log('3'), 0);

console.log('4');
```

**Answer:**
```
4
1
3
2
```

**Explanation:**
1. Synchronous code first: `4`
2. setTimeout callbacks in order registered (0ms): `1`, `3`
3. Then 10ms timeout: `2`

---

## Question 18: Object Property Shorthand

**What is the output?**

```javascript
const name = 'John';
const age = 30;

const person = { name, age, name: 'Jane' };

console.log(person);
```

**Answer:**
```
{ name: 'Jane', age: 30 }
```

**Explanation:**
Duplicate keys: last one wins. `name: 'Jane'` overwrites the shorthand `name`.

---

## Question 19: Array Length

**What is the output?**

```javascript
const arr = [1, 2, 3];
arr.length = 0;

console.log(arr);
```

**Answer:**
```
[]
```

**Explanation:**
Setting `length` to 0 empties the array. This is a way to clear an array.

---

## Question 20: Immediately Invoked Function

**What is the output?**

```javascript
(function() {
  var a = b = 5;
})();

console.log(typeof a);
console.log(typeof b);
```

**Answer:**
```
undefined
number
```

**Explanation:**
`var a = b = 5` is interpreted as `b = 5; var a = b;`
- `a` is local (var scoped to function)
- `b` is global (no var/let/const)

---

## Question 21: String Methods

**What is the output?**

```javascript
const str = 'hello';
str[0] = 'H';

console.log(str);
```

**Answer:**
```
hello
```

**Explanation:**
Strings are immutable in JavaScript. Attempting to modify individual characters has no effect.

---

## Question 22: Array indexOf

**What is the output?**

```javascript
const arr = [1, 2, NaN, 3];

console.log(arr.indexOf(NaN));
console.log(arr.includes(NaN));
```

**Answer:**
```
-1
true
```

**Explanation:**
- `indexOf` uses strict equality (`===`), and `NaN !== NaN`
- `includes` uses SameValueZero algorithm, which handles `NaN` correctly

---

## Question 23: Truthy/Falsy

**What is the output?**

```javascript
console.log(Boolean(''));
console.log(Boolean('0'));
console.log(Boolean(0));
console.log(Boolean([]));
console.log(Boolean({}));
console.log(Boolean(null));
console.log(Boolean(undefined));
```

**Answer:**
```
false
true
false
true
true
false
false
```

**Explanation:**
Falsy values: `false`, `0`, `''`, `null`, `undefined`, `NaN`
Everything else is truthy (including `[]` and `{}`).

---

## Question 24: Array Filter

**What is the output?**

```javascript
const arr = [1, 2, 3, 4, 5];
const filtered = arr.filter(num => num > 2);

arr.push(6);
console.log(filtered);
```

**Answer:**
```
[3, 4, 5]
```

**Explanation:**
`filter` creates a new array. Changes to the original array after filtering don't affect the filtered array.

---

## Question 25: Async/Await

**What is the output?**

```javascript
async function test() {
  console.log('1');
  
  await Promise.resolve();
  
  console.log('2');
}

test();
console.log('3');
```

**Answer:**
```
1
3
2
```

**Explanation:**
1. `test()` starts, logs `1`
2. `await` pauses function, returns control
3. Synchronous code continues: `3`
4. Promise resolves, function resumes: `2`

---

## Question 26: Object.assign

**What is the output?**

```javascript
const obj = { a: 1, b: { c: 2 } };
const copy = Object.assign({}, obj);

copy.b.c = 3;

console.log(obj.b.c);
console.log(copy.b.c);
```

**Answer:**
```
3
3
```

**Explanation:**
`Object.assign` creates a shallow copy. Nested objects are still referenced, not copied.

---

## Question 27: Rest Parameters

**What is the output?**

```javascript
function sum(...args) {
  console.log(args);
  console.log(arguments);
}

sum(1, 2, 3);
```

**Answer:**
```
[1, 2, 3]
ReferenceError: arguments is not defined (if arrow function)
// Or [1, 2, 3] (if regular function)
```

**Explanation:**
- Rest parameters create a real array
- `arguments` object exists in regular functions but not arrow functions

---

## Question 28: Optional Chaining

**What is the output?**

```javascript
const obj = {
  user: {
    name: 'John'
  }
};

console.log(obj.user?.name);
console.log(obj.address?.city);
console.log(obj.address.city);
```

**Answer:**
```
John
undefined
TypeError: Cannot read property 'city' of undefined
```

**Explanation:**
Optional chaining (`?.`) returns `undefined` for null/undefined, preventing errors. Without it, accessing nested properties on undefined throws TypeError.

---

## Question 29: Logical Operators

**What is the output?**

```javascript
console.log(0 || 1);
console.log(0 && 1);
console.log(1 || 2);
console.log(1 && 2);
console.log(null ?? 0);
console.log('' ?? 'default');
```

**Answer:**
```
1
0
1
2
0
""
```

**Explanation:**
- `||` returns first truthy value
- `&&` returns first falsy value or last value
- `??` (nullish coalescing) only checks for null/undefined

---

## Question 30: parseInt Quirks

**What is the output?**

```javascript
console.log(parseInt('10', 2));
console.log(parseInt('10', 8));
console.log(parseInt('10', 10));
console.log(parseInt('10', 16));
console.log(['1', '2', '3'].map(parseInt));
```

**Answer:**
```
2
8
10
16
[1, NaN, NaN]
```

**Explanation:**
`parseInt(string, radix)` takes two parameters. When used with `map`, it receives `(element, index, array)`:
- `parseInt('1', 0)` → 1 (radix 0 defaults to 10)
- `parseInt('2', 1)` → NaN (radix 1 is invalid)
- `parseInt('3', 2)` → NaN ('3' is invalid in binary)

---

## Key Takeaways

- **Understand hoisting**: var vs let/const behavior
- **Event loop**: Sync → Microtasks → Macrotasks
- **this binding**: Context matters
- **Type coercion**: == vs === differences
- **Reference vs value**: Objects and primitives
- **Array mutations**: Which methods mutate
- **Closure scope**: Variable access in nested functions
- **Promise execution**: Executor runs immediately
- **Shallow vs deep copy**: Object.assign, spread operator
- **Truthy/falsy**: Know all falsy values
- Practice output prediction
- Understand the "why" behind outputs
- Read code carefully, step by step
