# Problem-solving Patterns

Common patterns and techniques for solving JavaScript interview problems.

---

## Pattern 1: Two Pointers

**When to use:** Array problems requiring comparison of elements at different positions.

**Common scenarios:**
- Palindrome checking
- Pair sum problems
- Removing duplicates from sorted array
- Merging sorted arrays

```javascript
// Example 1: Check if palindrome
function isPalindrome(str) {
  let left = 0;
  let right = str.length - 1;
  
  while (left < right) {
    if (str[left] !== str[right]) {
      return false;
    }
    left++;
    right--;
  }
  
  return true;
}

// Example 2: Two sum (sorted array)
function twoSumSorted(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  
  while (left < right) {
    const sum = arr[left] + arr[right];
    
    if (sum === target) {
      return [left, right];
    } else if (sum < target) {
      left++;
    } else {
      right--;
    }
  }
  
  return null;
}

// Example 3: Remove duplicates from sorted array
function removeDuplicates(arr) {
  if (arr.length === 0) return 0;
  
  let i = 0;  // Slow pointer
  
  for (let j = 1; j < arr.length; j++) {  // Fast pointer
    if (arr[j] !== arr[i]) {
      i++;
      arr[i] = arr[j];
    }
  }
  
  return i + 1;  // New length
}

// Test
console.log(isPalindrome('racecar'));  // true
console.log(twoSumSorted([1, 2, 3, 4, 6], 6));  // [1, 3]
const arr = [1, 1, 2, 2, 3, 4, 4];
console.log(removeDuplicates(arr));  // 4, arr is [1, 2, 3, 4, ...]
```

---

## Pattern 2: Sliding Window

**When to use:** Subarray/substring problems with consecutive elements.

**Common scenarios:**
- Maximum/minimum subarray sum
- Longest substring without repeating characters
- Anagrams in string

```javascript
// Example 1: Maximum sum of subarray of size k
function maxSubarraySum(arr, k) {
  if (arr.length < k) return null;
  
  let maxSum = 0;
  let windowSum = 0;
  
  // Initial window
  for (let i = 0; i < k; i++) {
    windowSum += arr[i];
  }
  maxSum = windowSum;
  
  // Slide window
  for (let i = k; i < arr.length; i++) {
    windowSum = windowSum - arr[i - k] + arr[i];
    maxSum = Math.max(maxSum, windowSum);
  }
  
  return maxSum;
}

// Example 2: Longest substring without repeating characters
function lengthOfLongestSubstring(s) {
  const seen = new Set();
  let left = 0;
  let maxLength = 0;
  
  for (let right = 0; right < s.length; right++) {
    while (seen.has(s[right])) {
      seen.delete(s[left]);
      left++;
    }
    
    seen.add(s[right]);
    maxLength = Math.max(maxLength, right - left + 1);
  }
  
  return maxLength;
}

// Example 3: Find all anagrams
function findAnagrams(s, p) {
  const result = [];
  const pCount = {};
  const windowCount = {};
  
  // Count characters in p
  for (const char of p) {
    pCount[char] = (pCount[char] || 0) + 1;
  }
  
  let left = 0;
  let right = 0;
  let matches = 0;
  
  while (right < s.length) {
    const rightChar = s[right];
    
    if (rightChar in pCount) {
      windowCount[rightChar] = (windowCount[rightChar] || 0) + 1;
      if (windowCount[rightChar] === pCount[rightChar]) {
        matches++;
      }
    }
    
    // Window size exceeds p.length
    if (right - left + 1 > p.length) {
      const leftChar = s[left];
      if (leftChar in pCount) {
        if (windowCount[leftChar] === pCount[leftChar]) {
          matches--;
        }
        windowCount[leftChar]--;
      }
      left++;
    }
    
    // Found anagram
    if (matches === Object.keys(pCount).length) {
      result.push(left);
    }
    
    right++;
  }
  
  return result;
}

// Test
console.log(maxSubarraySum([2, 1, 5, 1, 3, 2], 3));  // 9
console.log(lengthOfLongestSubstring('abcabcbb'));  // 3 ('abc')
console.log(findAnagrams('cbaebabacd', 'abc'));  // [0, 6]
```

---

## Pattern 3: Hash Map/Set

**When to use:** Fast lookup, counting, detecting duplicates.

**Common scenarios:**
- Two sum problem
- Counting frequencies
- Checking for duplicates
- Grouping elements

```javascript
// Example 1: Two sum
function twoSum(arr, target) {
  const map = new Map();
  
  for (let i = 0; i < arr.length; i++) {
    const complement = target - arr[i];
    
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    map.set(arr[i], i);
  }
  
  return null;
}

// Example 2: First non-repeating character
function firstNonRepeating(str) {
  const count = new Map();
  
  // Count occurrences
  for (const char of str) {
    count.set(char, (count.get(char) || 0) + 1);
  }
  
  // Find first with count 1
  for (const char of str) {
    if (count.get(char) === 1) {
      return char;
    }
  }
  
  return null;
}

// Example 3: Group anagrams
function groupAnagrams(words) {
  const groups = new Map();
  
  for (const word of words) {
    const sorted = word.split('').sort().join('');
    
    if (!groups.has(sorted)) {
      groups.set(sorted, []);
    }
    
    groups.get(sorted).push(word);
  }
  
  return Array.from(groups.values());
}

// Example 4: Longest consecutive sequence
function longestConsecutive(nums) {
  const numSet = new Set(nums);
  let maxLength = 0;
  
  for (const num of numSet) {
    // Only start counting if it's the beginning of a sequence
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;
      
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }
      
      maxLength = Math.max(maxLength, currentLength);
    }
  }
  
  return maxLength;
}

// Test
console.log(twoSum([2, 7, 11, 15], 9));  // [0, 1]
console.log(firstNonRepeating('leetcode'));  // 'l'
console.log(groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']));
// [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
console.log(longestConsecutive([100, 4, 200, 1, 3, 2]));  // 4
```

---

## Pattern 4: Stack

**When to use:** Last-in-first-out (LIFO) operations, matching pairs, evaluation.

**Common scenarios:**
- Valid parentheses
- Next greater element
- Expression evaluation
- Backtracking problems

```javascript
// Example 1: Valid parentheses
function isValidParentheses(s) {
  const stack = [];
  const pairs = {
    ')': '(',
    '}': '{',
    ']': '['
  };
  
  for (const char of s) {
    if (char in pairs) {
      if (stack.pop() !== pairs[char]) {
        return false;
      }
    } else {
      stack.push(char);
    }
  }
  
  return stack.length === 0;
}

// Example 2: Next greater element
function nextGreaterElement(arr) {
  const result = new Array(arr.length).fill(-1);
  const stack = [];
  
  for (let i = 0; i < arr.length; i++) {
    while (stack.length > 0 && arr[i] > arr[stack[stack.length - 1]]) {
      const index = stack.pop();
      result[index] = arr[i];
    }
    stack.push(i);
  }
  
  return result;
}

// Example 3: Evaluate reverse Polish notation
function evalRPN(tokens) {
  const stack = [];
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => Math.trunc(a / b)
  };
  
  for (const token of tokens) {
    if (token in operators) {
      const b = stack.pop();
      const a = stack.pop();
      stack.push(operators[token](a, b));
    } else {
      stack.push(Number(token));
    }
  }
  
  return stack[0];
}

// Test
console.log(isValidParentheses('()[]{}'));  // true
console.log(isValidParentheses('([)]'));    // false
console.log(nextGreaterElement([4, 5, 2, 10, 8]));  // [5, 10, 10, -1, -1]
console.log(evalRPN(['2', '1', '+', '3', '*']));  // 9
```

---

## Pattern 5: Recursion

**When to use:** Problems with self-similar subproblems.

**Common scenarios:**
- Tree/graph traversal
- Permutations/combinations
- Divide and conquer
- Dynamic programming

```javascript
// Example 1: Factorial
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1);
}

// Example 2: Generate permutations
function permute(arr) {
  const result = [];
  
  function backtrack(current, remaining) {
    if (remaining.length === 0) {
      result.push([...current]);
      return;
    }
    
    for (let i = 0; i < remaining.length; i++) {
      current.push(remaining[i]);
      backtrack(current, [...remaining.slice(0, i), ...remaining.slice(i + 1)]);
      current.pop();
    }
  }
  
  backtrack([], arr);
  return result;
}

// Example 3: Binary search (recursive)
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
  if (left > right) return -1;
  
  const mid = Math.floor((left + right) / 2);
  
  if (arr[mid] === target) return mid;
  if (arr[mid] > target) return binarySearch(arr, target, left, mid - 1);
  return binarySearch(arr, target, mid + 1, right);
}

// Example 4: Generate all subsets
function subsets(nums) {
  const result = [];
  
  function backtrack(index, current) {
    result.push([...current]);
    
    for (let i = index; i < nums.length; i++) {
      current.push(nums[i]);
      backtrack(i + 1, current);
      current.pop();
    }
  }
  
  backtrack(0, []);
  return result;
}

// Test
console.log(factorial(5));  // 120
console.log(permute([1, 2, 3]));  // All permutations
console.log(binarySearch([1, 2, 3, 4, 5], 3));  // 2
console.log(subsets([1, 2, 3]));  // All subsets
```

---

## Pattern 6: Dynamic Programming

**When to use:** Optimization problems with overlapping subproblems.

**Common scenarios:**
- Fibonacci sequence
- Coin change problem
- Longest common subsequence
- Knapsack problem

```javascript
// Example 1: Fibonacci (memoization)
function fibonacci(n, memo = {}) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}

// Example 2: Coin change (minimum coins)
function coinChange(coins, amount) {
  const dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;
  
  for (let i = 1; i <= amount; i++) {
    for (const coin of coins) {
      if (i >= coin) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }
  
  return dp[amount] === Infinity ? -1 : dp[amount];
}

// Example 3: Longest increasing subsequence
function lengthOfLIS(nums) {
  if (nums.length === 0) return 0;
  
  const dp = new Array(nums.length).fill(1);
  
  for (let i = 1; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
  }
  
  return Math.max(...dp);
}

// Example 4: 0/1 Knapsack
function knapsack(weights, values, capacity) {
  const n = weights.length;
  const dp = Array(n + 1).fill(0).map(() => Array(capacity + 1).fill(0));
  
  for (let i = 1; i <= n; i++) {
    for (let w = 1; w <= capacity; w++) {
      if (weights[i - 1] <= w) {
        dp[i][w] = Math.max(
          values[i - 1] + dp[i - 1][w - weights[i - 1]],
          dp[i - 1][w]
        );
      } else {
        dp[i][w] = dp[i - 1][w];
      }
    }
  }
  
  return dp[n][capacity];
}

// Test
console.log(fibonacci(10));  // 55
console.log(coinChange([1, 2, 5], 11));  // 3 (5+5+1)
console.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]));  // 4
console.log(knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7));  // 9
```

---

## Pattern 7: BFS/DFS (Breadth/Depth First Search)

**When to use:** Tree or graph traversal problems.

**Common scenarios:**
- Level-order traversal
- Shortest path
- Connected components
- Topological sorting

```javascript
// Example 1: BFS (level-order traversal)
function bfs(root) {
  if (!root) return [];
  
  const result = [];
  const queue = [root];
  
  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node.value);
    
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
  
  return result;
}

// Example 2: DFS (in-order traversal)
function dfs(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    
    traverse(node.left);
    result.push(node.value);
    traverse(node.right);
  }
  
  traverse(root);
  return result;
}

// Example 3: Find path in graph (BFS)
function findPath(graph, start, end) {
  const queue = [[start]];
  const visited = new Set([start]);
  
  while (queue.length > 0) {
    const path = queue.shift();
    const node = path[path.length - 1];
    
    if (node === end) {
      return path;
    }
    
    for (const neighbor of graph[node] || []) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push([...path, neighbor]);
      }
    }
  }
  
  return null;
}

// Example 4: Number of islands (DFS)
function numIslands(grid) {
  if (!grid || grid.length === 0) return 0;
  
  let count = 0;
  
  function dfsIsland(i, j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
      return;
    }
    
    if (grid[i][j] === '0') return;
    
    grid[i][j] = '0';  // Mark as visited
    
    dfsIsland(i + 1, j);
    dfsIsland(i - 1, j);
    dfsIsland(i, j + 1);
    dfsIsland(i, j - 1);
  }
  
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[0].length; j++) {
      if (grid[i][j] === '1') {
        count++;
        dfsIsland(i, j);
      }
    }
  }
  
  return count;
}

// Test
const graph = {
  A: ['B', 'C'],
  B: ['A', 'D', 'E'],
  C: ['A', 'F'],
  D: ['B'],
  E: ['B', 'F'],
  F: ['C', 'E']
};
console.log(findPath(graph, 'A', 'F'));  // ['A', 'C', 'F'] or ['A', 'B', 'E', 'F']

const grid = [
  ['1', '1', '0', '0', '0'],
  ['1', '1', '0', '0', '0'],
  ['0', '0', '1', '0', '0'],
  ['0', '0', '0', '1', '1']
];
console.log(numIslands(grid));  // 3
```

---

## Pattern 8: Greedy Algorithm

**When to use:** Optimization problems where local optimum leads to global optimum.

**Common scenarios:**
- Activity selection
- Huffman coding
- Minimum spanning tree
- Job scheduling

```javascript
// Example 1: Activity selection
function maxActivities(start, end) {
  const activities = start.map((s, i) => ({ start: s, end: end[i] }));
  
  // Sort by end time
  activities.sort((a, b) => a.end - b.end);
  
  const selected = [activities[0]];
  let lastEnd = activities[0].end;
  
  for (let i = 1; i < activities.length; i++) {
    if (activities[i].start >= lastEnd) {
      selected.push(activities[i]);
      lastEnd = activities[i].end;
    }
  }
  
  return selected.length;
}

// Example 2: Jump game
function canJump(nums) {
  let maxReach = 0;
  
  for (let i = 0; i < nums.length; i++) {
    if (i > maxReach) return false;
    maxReach = Math.max(maxReach, i + nums[i]);
    if (maxReach >= nums.length - 1) return true;
  }
  
  return true;
}

// Example 3: Container with most water
function maxArea(height) {
  let left = 0;
  let right = height.length - 1;
  let maxArea = 0;
  
  while (left < right) {
    const width = right - left;
    const h = Math.min(height[left], height[right]);
    maxArea = Math.max(maxArea, width * h);
    
    // Move pointer with smaller height
    if (height[left] < height[right]) {
      left++;
    } else {
      right--;
    }
  }
  
  return maxArea;
}

// Test
console.log(maxActivities([1, 3, 0, 5, 8, 5], [2, 4, 6, 7, 9, 9]));  // 4
console.log(canJump([2, 3, 1, 1, 4]));  // true
console.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]));  // 49
```

---

## Key Takeaways

- **Two pointers**: Array problems, palindromes, pair sums
- **Sliding window**: Subarray/substring problems
- **Hash map/set**: Fast lookup, counting, duplicates
- **Stack**: LIFO operations, matching, evaluation
- **Recursion**: Self-similar subproblems, backtracking
- **Dynamic programming**: Overlapping subproblems, optimization
- **BFS/DFS**: Tree/graph traversal, shortest paths
- **Greedy**: Local optimum â†’ global optimum
- Recognize patterns in problem statements
- Practice identifying which pattern to use
- Understand time/space complexity
- Start with brute force, then optimize
- Test with edge cases
- Explain your approach before coding
