# Coding Challenges

Common JavaScript coding interview challenges with solutions.

---

## Reverse a String

**Problem:** Write a function to reverse a string.

```javascript
// Solution 1: Built-in methods
function reverseString1(str) {
  return str.split('').reverse().join('');
}

// Solution 2: Loop
function reverseString2(str) {
  let reversed = '';
  for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
  }
  return reversed;
}

// Solution 3: Reduce
function reverseString3(str) {
  return str.split('').reduce((acc, char) => char + acc, '');
}

// Solution 4: Recursion
function reverseString4(str) {
  if (str === '') return '';
  return reverseString4(str.substr(1)) + str[0];
}

// Test
console.log(reverseString1('hello'));  // "olleh"
```

---

## Check if String is Palindrome

**Problem:** Determine if a string reads the same forwards and backwards.

```javascript
function isPalindrome(str) {
  // Remove non-alphanumeric and convert to lowercase
  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  // Compare with reversed
  const reversed = cleaned.split('').reverse().join('');
  return cleaned === reversed;
}

// Alternative: Two pointers
function isPalindrome2(str) {
  const cleaned = str.toLowerCase().replace(/[^a-z0-9]/g, '');
  let left = 0;
  let right = cleaned.length - 1;
  
  while (left < right) {
    if (cleaned[left] !== cleaned[right]) {
      return false;
    }
    left++;
    right--;
  }
  
  return true;
}

// Test
console.log(isPalindrome('A man, a plan, a canal: Panama'));  // true
console.log(isPalindrome('race a car'));  // false
```

---

## FizzBuzz

**Problem:** Print numbers 1-100. For multiples of 3 print "Fizz", for multiples of 5 print "Buzz", for multiples of both print "FizzBuzz".

```javascript
function fizzBuzz(n) {
  const result = [];
  
  for (let i = 1; i <= n; i++) {
    if (i % 15 === 0) {
      result.push('FizzBuzz');
    } else if (i % 3 === 0) {
      result.push('Fizz');
    } else if (i % 5 === 0) {
      result.push('Buzz');
    } else {
      result.push(i);
    }
  }
  
  return result;
}

// Alternative: Shorter
function fizzBuzz2(n) {
  return Array.from({ length: n }, (_, i) => {
    i++;
    return (i % 3 === 0 ? 'Fizz' : '') + (i % 5 === 0 ? 'Buzz' : '') || i;
  });
}

// Test
console.log(fizzBuzz(15));
// [1, 2, "Fizz", 4, "Buzz", "Fizz", 7, 8, "Fizz", "Buzz", 11, "Fizz", 13, 14, "FizzBuzz"]
```

---

## Find Largest Number in Array

**Problem:** Find the maximum value in an array of numbers.

```javascript
// Solution 1: Math.max with spread
function findMax1(arr) {
  return Math.max(...arr);
}

// Solution 2: reduce
function findMax2(arr) {
  return arr.reduce((max, num) => num > max ? num : max, arr[0]);
}

// Solution 3: Loop
function findMax3(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}

// Solution 4: sort
function findMax4(arr) {
  return [...arr].sort((a, b) => b - a)[0];
}

// Test
const numbers = [3, 7, 2, 9, 1, 5];
console.log(findMax1(numbers));  // 9
```

---

## Remove Duplicates from Array

**Problem:** Remove duplicate values from an array.

```javascript
// Solution 1: Set
function removeDuplicates1(arr) {
  return [...new Set(arr)];
}

// Solution 2: filter
function removeDuplicates2(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

// Solution 3: reduce
function removeDuplicates3(arr) {
  return arr.reduce((acc, item) => {
    if (!acc.includes(item)) {
      acc.push(item);
    }
    return acc;
  }, []);
}

// Solution 4: For objects (by property)
function removeDuplicates4(arr, key) {
  const seen = new Set();
  return arr.filter(item => {
    const value = item[key];
    if (seen.has(value)) {
      return false;
    }
    seen.add(value);
    return true;
  });
}

// Test
console.log(removeDuplicates1([1, 2, 2, 3, 4, 4, 5]));  // [1, 2, 3, 4, 5]

const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 1, name: 'John' }
];
console.log(removeDuplicates4(users, 'id'));  // First two users
```

---

## Flatten Nested Array

**Problem:** Flatten a multi-dimensional array.

```javascript
// Solution 1: flat()
function flatten1(arr, depth = Infinity) {
  return arr.flat(depth);
}

// Solution 2: Recursion
function flatten2(arr) {
  const result = [];
  
  arr.forEach(item => {
    if (Array.isArray(item)) {
      result.push(...flatten2(item));
    } else {
      result.push(item);
    }
  });
  
  return result;
}

// Solution 3: reduce
function flatten3(arr) {
  return arr.reduce((acc, item) => {
    return acc.concat(Array.isArray(item) ? flatten3(item) : item);
  }, []);
}

// Solution 4: Stack (iterative)
function flatten4(arr) {
  const stack = [...arr];
  const result = [];
  
  while (stack.length) {
    const item = stack.pop();
    
    if (Array.isArray(item)) {
      stack.push(...item);
    } else {
      result.unshift(item);
    }
  }
  
  return result;
}

// Test
const nested = [1, [2, [3, [4]], 5]];
console.log(flatten1(nested));  // [1, 2, 3, 4, 5]
console.log(flatten1(nested, 1));  // [1, 2, [3, [4]], 5]
```

---

## Find Factorial

**Problem:** Calculate factorial of a number (n! = n × (n-1) × ... × 1).

```javascript
// Solution 1: Recursion
function factorial1(n) {
  if (n <= 1) return 1;
  return n * factorial1(n - 1);
}

// Solution 2: Loop
function factorial2(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// Solution 3: reduce
function factorial3(n) {
  return Array.from({ length: n }, (_, i) => i + 1)
    .reduce((acc, num) => acc * num, 1);
}

// Test
console.log(factorial1(5));  // 120
console.log(factorial1(0));  // 1
```

---

## Fibonacci Sequence

**Problem:** Generate nth Fibonacci number (0, 1, 1, 2, 3, 5, 8, 13...).

```javascript
// Solution 1: Recursion (slow)
function fibonacci1(n) {
  if (n <= 1) return n;
  return fibonacci1(n - 1) + fibonacci1(n - 2);
}

// Solution 2: Iteration (fast)
function fibonacci2(n) {
  if (n <= 1) return n;
  
  let prev = 0;
  let curr = 1;
  
  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }
  
  return curr;
}

// Solution 3: Memoization
function fibonacci3() {
  const cache = {};
  
  return function fib(n) {
    if (n <= 1) return n;
    
    if (cache[n]) {
      return cache[n];
    }
    
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  };
}

const fib = fibonacci3();

// Solution 4: Array of first n numbers
function fibonacciSequence(n) {
  const sequence = [0, 1];
  
  for (let i = 2; i < n; i++) {
    sequence[i] = sequence[i - 1] + sequence[i - 2];
  }
  
  return sequence;
}

// Test
console.log(fibonacci2(10));  // 55
console.log(fibonacciSequence(10));  // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

---

## Check if Two Strings are Anagrams

**Problem:** Determine if two strings contain the same characters in different order.

```javascript
// Solution 1: Sort and compare
function isAnagram1(str1, str2) {
  const clean1 = str1.toLowerCase().replace(/[^a-z]/g, '');
  const clean2 = str2.toLowerCase().replace(/[^a-z]/g, '');
  
  return clean1.split('').sort().join('') === clean2.split('').sort().join('');
}

// Solution 2: Character count
function isAnagram2(str1, str2) {
  const clean1 = str1.toLowerCase().replace(/[^a-z]/g, '');
  const clean2 = str2.toLowerCase().replace(/[^a-z]/g, '');
  
  if (clean1.length !== clean2.length) return false;
  
  const count = {};
  
  for (const char of clean1) {
    count[char] = (count[char] || 0) + 1;
  }
  
  for (const char of clean2) {
    if (!count[char]) return false;
    count[char]--;
  }
  
  return true;
}

// Test
console.log(isAnagram1('listen', 'silent'));  // true
console.log(isAnagram1('hello', 'world'));  // false
```

---

## Find Missing Number

**Problem:** Find the missing number in an array of 1 to n.

```javascript
// Solution 1: Math formula (sum)
function findMissing1(arr) {
  const n = arr.length + 1;
  const expectedSum = (n * (n + 1)) / 2;
  const actualSum = arr.reduce((sum, num) => sum + num, 0);
  return expectedSum - actualSum;
}

// Solution 2: XOR
function findMissing2(arr) {
  const n = arr.length + 1;
  let xor = 0;
  
  // XOR all numbers from 1 to n
  for (let i = 1; i <= n; i++) {
    xor ^= i;
  }
  
  // XOR with array elements
  for (const num of arr) {
    xor ^= num;
  }
  
  return xor;
}

// Test
console.log(findMissing1([1, 2, 4, 5, 6]));  // 3
```

---

## Two Sum Problem

**Problem:** Find two numbers in an array that add up to a target.

```javascript
// Solution 1: Brute force O(n²)
function twoSum1(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] + arr[j] === target) {
        return [i, j];
      }
    }
  }
  return null;
}

// Solution 2: Hash map O(n)
function twoSum2(arr, target) {
  const map = new Map();
  
  for (let i = 0; i < arr.length; i++) {
    const complement = target - arr[i];
    
    if (map.has(complement)) {
      return [map.get(complement), i];
    }
    
    map.set(arr[i], i);
  }
  
  return null;
}

// Test
console.log(twoSum2([2, 7, 11, 15], 9));  // [0, 1]
console.log(twoSum2([3, 2, 4], 6));  // [1, 2]
```

---

## Implement debounce

**Problem:** Create a debounce function that delays execution.

```javascript
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    // Clear previous timeout
    clearTimeout(timeoutId);
    
    // Set new timeout
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Usage
const handleSearch = debounce((query) => {
  console.log('Searching for:', query);
  // API call
}, 300);

// User types: h-e-l-l-o
// Only searches once after 300ms of no typing
input.addEventListener('input', (e) => {
  handleSearch(e.target.value);
});
```

---

## Implement throttle

**Problem:** Create a throttle function that limits execution frequency.

```javascript
function throttle(func, interval) {
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastTime >= interval) {
      lastTime = now;
      func.apply(this, args);
    }
  };
}

// Alternative: Leading and trailing execution
function throttle2(func, interval) {
  let timeoutId;
  let lastTime = 0;
  
  return function(...args) {
    const now = Date.now();
    const remaining = interval - (now - lastTime);
    
    clearTimeout(timeoutId);
    
    if (remaining <= 0) {
      lastTime = now;
      func.apply(this, args);
    } else {
      timeoutId = setTimeout(() => {
        lastTime = Date.now();
        func.apply(this, args);
      }, remaining);
    }
  };
}

// Usage
const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 100);

window.addEventListener('scroll', handleScroll);
```

---

## Deep Clone Object

**Problem:** Create a deep copy of an object.

```javascript
// Solution 1: JSON (simple objects only)
function deepClone1(obj) {
  return JSON.parse(JSON.stringify(obj));
  // Limitations: loses functions, Date, RegExp, undefined
}

// Solution 2: Recursion
function deepClone2(obj) {
  // Handle primitive types
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // Handle Date
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // Handle Array
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone2(item));
  }
  
  // Handle Object
  const cloned = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone2(obj[key]);
    }
  }
  
  return cloned;
}

// Solution 3: structuredClone (modern browsers)
function deepClone3(obj) {
  return structuredClone(obj);
}

// Test
const original = {
  name: 'John',
  address: {
    city: 'NYC',
    zip: '10001'
  },
  hobbies: ['reading', 'coding']
};

const cloned = deepClone2(original);
cloned.address.city = 'LA';
console.log(original.address.city);  // "NYC" (unchanged)
```

---

## Implement Promise.all

**Problem:** Create your own Promise.all implementation.

```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = [];
    let completed = 0;
    
    if (promises.length === 0) {
      resolve(results);
      return;
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(result => {
          results[index] = result;
          completed++;
          
          if (completed === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
}

// Test
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

promiseAll([p1, p2, p3]).then(results => {
  console.log(results);  // [1, 2, 3]
});
```

---

## Chunk Array

**Problem:** Split array into chunks of specified size.

```javascript
function chunkArray(arr, size) {
  const chunks = [];
  
  for (let i = 0; i < arr.length; i += size) {
    chunks.push(arr.slice(i, i + size));
  }
  
  return chunks;
}

// Alternative: reduce
function chunkArray2(arr, size) {
  return arr.reduce((chunks, item, index) => {
    const chunkIndex = Math.floor(index / size);
    
    if (!chunks[chunkIndex]) {
      chunks[chunkIndex] = [];
    }
    
    chunks[chunkIndex].push(item);
    return chunks;
  }, []);
}

// Test
console.log(chunkArray([1, 2, 3, 4, 5, 6, 7, 8], 3));
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

---

## Key Takeaways

- **Practice regularly**: Solve problems daily
- **Understand time complexity**: Big O notation
- **Multiple solutions**: Know different approaches
- **Built-in methods**: Leverage array/string methods
- **Edge cases**: Empty arrays, null, undefined
- **Optimization**: Start with working solution, then optimize
- **Common patterns**: Two pointers, sliding window, hash maps
- **Recursion vs iteration**: Know when to use each
- **Memoization**: Cache expensive calculations
- **Test thoroughly**: Cover edge cases
- Explain your thinking process
- Write clean, readable code
- Ask clarifying questions
