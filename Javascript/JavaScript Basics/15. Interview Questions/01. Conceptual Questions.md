# Conceptual Questions

Common JavaScript conceptual interview questions with detailed answers.

---

## What is JavaScript?

**Answer:**
JavaScript is a high-level, interpreted programming language primarily used for web development. It's a multi-paradigm language supporting object-oriented, functional, and imperative programming styles.

**Key Characteristics:**
- Dynamically typed
- Prototype-based inheritance
- First-class functions
- Event-driven and asynchronous
- Runs in browsers and servers (Node.js)

```javascript
// JavaScript supports multiple paradigms

// Object-Oriented
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    return `Hello, I'm ${this.name}`;
  }
}

// Functional
const double = x => x * 2;
const numbers = [1, 2, 3].map(double);

// Event-driven
button.addEventListener('click', handleClick);
```

---

## What is the difference between var, let, and const?

**Answer:**

| Feature | var | let | const |
|---------|-----|-----|-------|
| Scope | Function | Block | Block |
| Hoisting | Yes (initialized as undefined) | Yes (TDZ) | Yes (TDZ) |
| Reassignment | Yes | Yes | No |
| Redeclaration | Yes | No | No |

```javascript
// var - function scoped
function testVar() {
  var x = 1;
  if (true) {
    var x = 2;  // Same variable
    console.log(x);  // 2
  }
  console.log(x);  // 2
}

// let - block scoped
function testLet() {
  let x = 1;
  if (true) {
    let x = 2;  // Different variable
    console.log(x);  // 2
  }
  console.log(x);  // 1
}

// const - block scoped, can't reassign
const PI = 3.14159;
// PI = 3.14;  // Error

// But objects can be mutated
const obj = { name: 'John' };
obj.name = 'Jane';  // Allowed
// obj = {};  // Error
```

---

## What is hoisting?

**Answer:**
Hoisting is JavaScript's behavior of moving declarations to the top of their scope during compilation. Variables and functions are hoisted differently.

```javascript
// Function hoisting
greet();  // Works! "Hello"
function greet() {
  console.log('Hello');
}

// var hoisting
console.log(x);  // undefined (not ReferenceError)
var x = 5;

// What JavaScript sees:
var x;
console.log(x);
x = 5;

// let/const hoisting (Temporal Dead Zone)
console.log(y);  // ReferenceError
let y = 5;

// Function expressions are not hoisted
hello();  // TypeError
var hello = function() {
  console.log('Hello');
};
```

---

## What is the difference between == and ===?

**Answer:**
- `==` (loose equality): Compares values after type coercion
- `===` (strict equality): Compares both value and type

```javascript
// == performs type coercion
console.log(5 == '5');      // true
console.log(0 == false);    // true
console.log(null == undefined);  // true

// === does not perform type coercion
console.log(5 === '5');     // false
console.log(0 === false);   // false
console.log(null === undefined);  // false

// Always use === unless you specifically need coercion
const value = getUserInput();
if (value === '') {  // Correct
  console.log('Empty string');
}
```

---

## What is closure?

**Answer:**
A closure is a function that has access to variables in its outer (enclosing) lexical scope, even after the outer function has returned.

```javascript
// Basic closure
function outer() {
  const message = 'Hello';
  
  function inner() {
    console.log(message);  // Access outer variable
  }
  
  return inner;
}

const myFunction = outer();
myFunction();  // "Hello" - still has access to message

// Practical use: Private variables
function createCounter() {
  let count = 0;  // Private variable
  
  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.count);  // undefined (private)

// Practical use: Function factory
function makeMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15
```

---

## What is the event loop?

**Answer:**
The event loop is JavaScript's mechanism for handling asynchronous operations. It continuously checks the call stack and task queues, executing tasks when the stack is empty.

**Components:**
1. **Call Stack**: Executes synchronous code
2. **Web APIs**: Handle async operations (setTimeout, fetch, etc.)
3. **Task Queue (Macrotasks)**: setTimeout, setInterval, I/O
4. **Microtask Queue**: Promises, queueMicrotask
5. **Event Loop**: Orchestrates execution

```javascript
console.log('1');  // Synchronous

setTimeout(() => {
  console.log('2');  // Macrotask
}, 0);

Promise.resolve().then(() => {
  console.log('3');  // Microtask
});

console.log('4');  // Synchronous

// Output: 1, 4, 3, 2
// Microtasks run before macrotasks

// Execution order:
// 1. Sync code: 1, 4
// 2. Microtasks: 3
// 3. Macrotasks: 2
```

---

## What is the difference between call, apply, and bind?

**Answer:**
All three methods control the `this` context, but differ in how they're used.

```javascript
const person = {
  name: 'John',
  greet: function(greeting, punctuation) {
    return `${greeting}, I'm ${this.name}${punctuation}`;
  }
};

const anotherPerson = { name: 'Jane' };

// call - invoke immediately, args individually
console.log(person.greet.call(anotherPerson, 'Hi', '!'));
// "Hi, I'm Jane!"

// apply - invoke immediately, args as array
console.log(person.greet.apply(anotherPerson, ['Hello', '.']));
// "Hello, I'm Jane."

// bind - return new function, doesn't invoke
const boundGreet = person.greet.bind(anotherPerson, 'Hey');
console.log(boundGreet('?'));
// "Hey, I'm Jane?"

// Practical use: Borrowing methods
const numbers = [5, 6, 2, 3, 7];
const max = Math.max.apply(null, numbers);
// Or: const max = Math.max(...numbers);

// Practical use: Partial application
function multiply(a, b) {
  return a * b;
}

const double = multiply.bind(null, 2);
console.log(double(5));  // 10
```

---

## What is prototypal inheritance?

**Answer:**
JavaScript uses prototype-based inheritance where objects inherit directly from other objects.

```javascript
// Every object has a prototype
const obj = {};
console.log(obj.__proto__ === Object.prototype);  // true

// Prototype chain
const animal = {
  eat() {
    console.log('Eating...');
  }
};

const dog = Object.create(animal);
dog.bark = function() {
  console.log('Woof!');
};

dog.eat();   // "Eating..." (inherited from animal)
dog.bark();  // "Woof!" (own method)

// Constructor functions
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

const john = new Person('John');
console.log(john.greet());  // "Hello, I'm John"

// ES6 classes (syntactic sugar over prototypes)
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} makes a sound`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks`);
  }
}

const dog = new Dog('Rex');
dog.speak();  // "Rex barks"
```

---

## What are Promises?

**Answer:**
Promises represent the eventual completion or failure of an asynchronous operation.

**States:**
- Pending: Initial state
- Fulfilled: Operation completed successfully
- Rejected: Operation failed

```javascript
// Creating a Promise
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    
    if (success) {
      resolve('Success!');
    } else {
      reject(new Error('Failed!'));
    }
  }, 1000);
});

// Consuming a Promise
promise
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => console.log('Done'));

// Promise chaining
fetch('/api/user')
  .then(response => response.json())
  .then(user => fetch(`/api/posts/${user.id}`))
  .then(response => response.json())
  .then(posts => console.log(posts))
  .catch(error => console.error(error));

// Promise methods
Promise.all([promise1, promise2, promise3])  // All must succeed
  .then(results => console.log(results));

Promise.race([promise1, promise2])  // First to complete
  .then(result => console.log(result));

Promise.allSettled([promise1, promise2])  // All results
  .then(results => console.log(results));

Promise.any([promise1, promise2])  // First to succeed
  .then(result => console.log(result));
```

---

## What is async/await?

**Answer:**
Async/await is syntactic sugar over Promises, making asynchronous code look synchronous.

```javascript
// async function always returns a Promise
async function fetchData() {
  return 'Data';  // Wrapped in Promise.resolve()
}

fetchData().then(data => console.log(data));  // "Data"

// await pauses execution until Promise resolves
async function getData() {
  const response = await fetch('/api/data');
  const data = await response.json();
  return data;
}

// Error handling with try-catch
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/user/${id}`);
    
    if (!response.ok) {
      throw new Error('User not found');
    }
    
    const user = await response.json();
    return user;
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}

// Parallel execution
async function fetchAll() {
  // Sequential (slow)
  const user = await fetchUser(1);
  const posts = await fetchPosts(1);
  
  // Parallel (fast)
  const [user, posts] = await Promise.all([
    fetchUser(1),
    fetchPosts(1)
  ]);
  
  return { user, posts };
}
```

---

## What is the difference between null and undefined?

**Answer:**
- `undefined`: Variable declared but not assigned
- `null`: Intentional absence of value

```javascript
// undefined - not assigned
let x;
console.log(x);  // undefined
console.log(typeof x);  // "undefined"

// null - intentional absence
let y = null;
console.log(y);  // null
console.log(typeof y);  // "object" (JavaScript bug)

// Function with no return
function test() {
  // No return statement
}
console.log(test());  // undefined

// Object property doesn't exist
const obj = { a: 1 };
console.log(obj.b);  // undefined

// Common checks
if (x == null) {  // true for both null and undefined
  console.log('Nullish');
}

if (x === undefined) {  // Only undefined
  console.log('Undefined');
}

// Nullish coalescing
const value = x ?? 'default';  // Use default if null or undefined
```

---

## What is the difference between synchronous and asynchronous code?

**Answer:**
- **Synchronous**: Executes line by line, blocking
- **Asynchronous**: Non-blocking, executes later

```javascript
// Synchronous
console.log('1');
console.log('2');
console.log('3');
// Output: 1, 2, 3 (in order)

// Asynchronous
console.log('1');

setTimeout(() => {
  console.log('2');
}, 0);

console.log('3');
// Output: 1, 3, 2

// Async operations
// - setTimeout, setInterval
// - fetch, XMLHttpRequest
// - Promises, async/await
// - Event listeners
// - File I/O (Node.js)

// Example: Blocking vs Non-blocking
// Blocking (synchronous)
const data = fs.readFileSync('file.txt');  // Waits
console.log(data);

// Non-blocking (asynchronous)
fs.readFile('file.txt', (err, data) => {  // Continues immediately
  if (err) throw err;
  console.log(data);
});
console.log('This runs first');
```

---

## What are arrow functions and how do they differ from regular functions?

**Answer:**

**Differences:**
1. **Syntax**: More concise
2. **this binding**: Lexically bound
3. **arguments object**: Not available
4. **constructor**: Can't use with `new`
5. **prototype**: No prototype property

```javascript
// Regular function
function regular(x) {
  return x * 2;
}

// Arrow function
const arrow = x => x * 2;

// this binding
const obj = {
  value: 42,
  
  regularFunc: function() {
    console.log(this.value);  // 42
  },
  
  arrowFunc: () => {
    console.log(this.value);  // undefined (this is from outer scope)
  }
};

// Practical use: Callbacks
const numbers = [1, 2, 3];

// Regular function - verbose
numbers.map(function(n) {
  return n * 2;
});

// Arrow function - concise
numbers.map(n => n * 2);

// this in event listeners
class Button {
  constructor() {
    this.count = 0;
    
    // Arrow function preserves this
    document.getElementById('btn').addEventListener('click', () => {
      this.count++;  // 'this' is Button instance
      console.log(this.count);
    });
  }
}

// arguments object
function regular() {
  console.log(arguments);  // Available
}

const arrow = () => {
  console.log(arguments);  // ReferenceError
  // Use rest parameters instead: (...args) => args
};
```

---

## What is event delegation?

**Answer:**
Event delegation is attaching a single event listener to a parent element to handle events for multiple children, using event bubbling.

**Benefits:**
- Better performance
- Works for dynamically added elements
- Less memory usage

```javascript
// Without delegation (inefficient)
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});

// With delegation (efficient)
document.getElementById('list').addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    handleClick(e);
  }
});

// Example: Todo list
const todoList = document.getElementById('todo-list');

todoList.addEventListener('click', (e) => {
  // Delete button
  if (e.target.matches('.delete-btn')) {
    e.target.closest('.todo-item').remove();
  }
  
  // Checkbox
  if (e.target.matches('.todo-checkbox')) {
    const item = e.target.closest('.todo-item');
    item.classList.toggle('completed');
  }
  
  // Edit button
  if (e.target.matches('.edit-btn')) {
    const item = e.target.closest('.todo-item');
    editTodo(item);
  }
});

// Works for dynamically added items
function addTodo(text) {
  const item = document.createElement('div');
  item.className = 'todo-item';
  item.innerHTML = `
    <input type="checkbox" class="todo-checkbox">
    <span>${text}</span>
    <button class="edit-btn">Edit</button>
    <button class="delete-btn">Delete</button>
  `;
  todoList.appendChild(item);
  // Event delegation handles this automatically!
}
```

---

## What is the difference between map, filter, and reduce?

**Answer:**

| Method | Purpose | Returns | Mutates |
|--------|---------|---------|---------|
| map | Transform each element | New array (same length) | No |
| filter | Select elements | New array (subset) | No |
| reduce | Aggregate to single value | Any type | No |

```javascript
const numbers = [1, 2, 3, 4, 5];

// map - transform each element
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8, 10]

// filter - select elements
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4]

// reduce - aggregate
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 15

// Chaining
const result = numbers
  .filter(n => n % 2 === 0)  // [2, 4]
  .map(n => n * 2)           // [4, 8]
  .reduce((acc, n) => acc + n, 0);  // 12

// Practical examples
const users = [
  { name: 'John', age: 25, active: true },
  { name: 'Jane', age: 30, active: false },
  { name: 'Bob', age: 35, active: true }
];

// Get names of active users
const activeNames = users
  .filter(user => user.active)
  .map(user => user.name);
// ['John', 'Bob']

// Calculate average age
const avgAge = users.reduce((sum, user) => sum + user.age, 0) / users.length;
// 30

// Group by property
const grouped = users.reduce((acc, user) => {
  const key = user.active ? 'active' : 'inactive';
  acc[key] = acc[key] || [];
  acc[key].push(user);
  return acc;
}, {});
```

---

## Key Takeaways

- **JavaScript basics**: High-level, multi-paradigm, prototype-based
- **Variable declarations**: Prefer const/let over var
- **Equality**: Use === for strict comparison
- **Closures**: Functions accessing outer scope
- **Event loop**: Handles async operations
- **this binding**: call/apply/bind control context
- **Promises**: Handle async operations elegantly
- **async/await**: Syntactic sugar for Promises
- **Arrow functions**: Lexical this, concise syntax
- **Event delegation**: Single listener on parent
- **Array methods**: map (transform), filter (select), reduce (aggregate)
- Understanding these concepts is crucial for interviews
- Practice explaining concepts clearly
- Provide code examples when possible
