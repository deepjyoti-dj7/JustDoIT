# Tricky Questions

JavaScript interview questions with non-obvious answers and edge cases.

---

## Question 1: typeof null

**What is the output and why?**

```javascript
console.log(typeof null);
console.log(typeof undefined);
console.log(null == undefined);
console.log(null === undefined);
```

**Answer:**
```
"object"
"undefined"
true
false
```

**Explanation:**
`typeof null` returning `"object"` is a famous JavaScript bug from the early days. It's never been fixed for backward compatibility. Despite this, `null` is a primitive value, not an object.

---

## Question 2: The Banana Bracket

**What is the output?**

```javascript
('b' + 'a' + + 'a' + 'a').toLowerCase();
```

**Answer:**
```
"banana"
```

**Explanation:**
- `'b' + 'a'` → `"ba"`
- `+ 'a'` → Unary plus converts `'a'` to `NaN`
- `"ba" + NaN` → `"baNaN"`
- `"baNaN" + 'a'` → `"baNaNa"`
- `.toLowerCase()` → `"banana"`

---

## Question 3: Array Comparison

**What is the output?**

```javascript
console.log([] == []);
console.log([] === []);
console.log([1] == 1);
console.log([1] === 1);
```

**Answer:**
```
false
false
true
false
```

**Explanation:**
- Arrays are objects, compared by reference
- Each `[]` creates a new array (different references)
- `[1] == 1`: Array converts to `"1"`, then to `1`
- `[1] === 1`: Different types, no coercion

---

## Question 4: Function Name Property

**What is the output?**

```javascript
function foo() {}
const bar = function baz() {};

console.log(foo.name);
console.log(bar.name);
console.log(baz.name);
```

**Answer:**
```
"foo"
"baz"
ReferenceError: baz is not defined
```

**Explanation:**
- Function declarations: name is the function name
- Named function expressions: name is the internal name
- `baz` is only accessible inside the function, not outside

---

## Question 5: The Floating Point Trap

**What is the output?**

```javascript
console.log(0.1 + 0.2);
console.log(0.1 + 0.2 === 0.3);
console.log(0.3 - 0.2);
console.log(0.3 - 0.2 === 0.1);
```

**Answer:**
```
0.30000000000000004
false
0.09999999999999998
false
```

**Explanation:**
JavaScript uses IEEE 754 floating-point arithmetic, which can't precisely represent some decimal numbers. This causes rounding errors.

**Solution:**
```javascript
function areClose(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

console.log(areClose(0.1 + 0.2, 0.3));  // true
```

---

## Question 6: min vs max

**What is the output?**

```javascript
console.log(Math.min());
console.log(Math.max());
console.log(Math.min() > Math.max());
```

**Answer:**
```
Infinity
-Infinity
true
```

**Explanation:**
- `Math.min()` with no arguments returns `Infinity` (any number is less than this)
- `Math.max()` with no arguments returns `-Infinity` (any number is greater than this)
- Therefore `Infinity > -Infinity` is `true`

---

## Question 7: Array Sort Gotcha

**What is the output?**

```javascript
const numbers = [1, 2, 10, 21];
console.log(numbers.sort());
```

**Answer:**
```
[1, 10, 2, 21]
```

**Explanation:**
By default, `sort()` converts elements to strings and sorts lexicographically. "10" comes before "2" in string comparison.

**Fix:**
```javascript
numbers.sort((a, b) => a - b);  // [1, 2, 10, 21]
```

---

## Question 8: The Delete Operator

**What is the output?**

```javascript
const obj = { a: 1, b: 2, c: 3 };
delete obj.b;

console.log(obj);
console.log('b' in obj);

const arr = [1, 2, 3, 4, 5];
delete arr[2];

console.log(arr);
console.log(arr.length);
```

**Answer:**
```
{ a: 1, c: 3 }
false
[1, 2, <1 empty item>, 4, 5]
5
```

**Explanation:**
- `delete` removes object properties
- `delete` on arrays creates holes (empty items) but doesn't change length
- Use `splice()` to actually remove array elements

---

## Question 9: Number Constructor

**What is the output?**

```javascript
console.log(Number('1'));
console.log(Number('abc'));
console.log(Number(''));
console.log(Number(null));
console.log(Number(undefined));
console.log(Number(true));
console.log(Number(false));
```

**Answer:**
```
1
NaN
0
0
NaN
1
0
```

**Explanation:**
- Valid numeric string → number
- Invalid string → `NaN`
- Empty string → `0`
- `null` → `0`
- `undefined` → `NaN`
- Boolean → `1` or `0`

---

## Question 10: Function Arguments

**What is the output?**

```javascript
function test(a, a) {
  console.log(a);
}

test(1, 2);
```

**Answer:**
```
2
```

**Explanation:**
In non-strict mode, duplicate parameter names are allowed. The last value wins. In strict mode, this would be a SyntaxError.

---

## Question 11: The Comma Operator

**What is the output?**

```javascript
const x = (1, 2, 3);
console.log(x);

let a = 1;
const y = (a++, a++, a++);
console.log(y);
console.log(a);
```

**Answer:**
```
3
3
4
```

**Explanation:**
The comma operator evaluates each expression and returns the last one.
- `x = (1, 2, 3)`: returns `3`
- Each `a++` increments `a`, final `a++` returns `3` (before incrementing to `4`)

---

## Question 12: Array Constructor

**What is the output?**

```javascript
console.log(new Array(3));
console.log(new Array(3, 4));
console.log(Array.of(3));
console.log(Array.of(3, 4));
```

**Answer:**
```
[<3 empty items>]
[3, 4]
[3]
[3, 4]
```

**Explanation:**
- `new Array(n)`: Creates array with `n` empty slots
- `new Array(a, b)`: Creates array with elements `[a, b]`
- `Array.of(n)`: Always creates array with `n` as element
- Use `Array.of()` to avoid confusion

---

## Question 13: String Addition

**What is the output?**

```javascript
console.log(1 + '1' - 1);
console.log(1 + '1' + 1);
console.log('1' + 1 + 1);
console.log('1' - 1 + 1);
```

**Answer:**
```
10
"111"
"111"
1
```

**Explanation:**
- `+` with string: concatenation
- `-` always converts to numbers
- `1 + '1'` → `"11"`, then `"11" - 1` → `10`
- Left-to-right evaluation for `+`

---

## Question 14: Object Key Coercion

**What is the output?**

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
console.log(a);
```

**Answer:**
```
456
{ '[object Object]': 456 }
```

**Explanation:**
Object keys are converted to strings. Both `b` and `c` convert to `"[object Object]"`, so they overwrite each other.

**Use Map for object keys:**
```javascript
const map = new Map();
map.set(b, 123);
map.set(c, 456);
console.log(map.get(b));  // 123
console.log(map.get(c));  // 456
```

---

## Question 15: Implicit Return

**What is the output?**

```javascript
const func1 = () => { return { a: 1 }; };
const func2 = () => { a: 1 };
const func3 = () => ({ a: 1 });

console.log(func1());
console.log(func2());
console.log(func3());
```

**Answer:**
```
{ a: 1 }
undefined
{ a: 1 }
```

**Explanation:**
- `func1`: Explicit return works
- `func2`: `{ a: 1 }` is interpreted as a code block with label `a:`, returns `undefined`
- `func3`: Parentheses make it an object literal, implicit return works

---

## Question 16: Set Math

**What is the output?**

```javascript
const set = new Set([1, 2, 3, 4]);

console.log(set.add(5));
console.log(set.add(5));
console.log(set.size);
```

**Answer:**
```
Set(5) { 1, 2, 3, 4, 5 }
Set(5) { 1, 2, 3, 4, 5 }
5
```

**Explanation:**
- `add()` returns the Set itself (for chaining)
- Adding duplicate values has no effect
- Set maintains unique values only

---

## Question 17: String Replace

**What is the output?**

```javascript
const str = 'hello hello hello';

console.log(str.replace('hello', 'hi'));
console.log(str.replace(/hello/, 'hi'));
console.log(str.replace(/hello/g, 'hi'));
```

**Answer:**
```
"hi hello hello"
"hi hello hello"
"hi hi hi"
```

**Explanation:**
- Without `g` flag: replaces only first occurrence
- With `g` flag: replaces all occurrences
- String pattern and regex without `g` behave the same

---

## Question 18: Array Length Manipulation

**What is the output?**

```javascript
const arr = [1, 2, 3];
arr[10] = 10;

console.log(arr.length);
console.log(arr);
console.log(arr[5]);
```

**Answer:**
```
11
[1, 2, 3, <7 empty items>, 10]
undefined
```

**Explanation:**
Setting an index beyond current length creates a sparse array with empty slots. Array length is the highest index + 1.

---

## Question 19: Constructor Return

**What is the output?**

```javascript
function Person(name) {
  this.name = name;
  return { age: 30 };
}

const person = new Person('John');

console.log(person.name);
console.log(person.age);
```

**Answer:**
```
undefined
30
```

**Explanation:**
When a constructor explicitly returns an object, that object is returned instead of the newly created instance. Returning primitives is ignored.

---

## Question 20: isNaN vs Number.isNaN

**What is the output?**

```javascript
console.log(isNaN('hello'));
console.log(Number.isNaN('hello'));
console.log(isNaN(NaN));
console.log(Number.isNaN(NaN));
```

**Answer:**
```
true
false
true
true
```

**Explanation:**
- `isNaN()`: Coerces to number first (`'hello'` → `NaN`)
- `Number.isNaN()`: Strict check, only `NaN` returns true
- Always use `Number.isNaN()` for accurate NaN checking

---

## Question 21: Object.is

**What is the output?**

```javascript
console.log(Object.is(NaN, NaN));
console.log(Object.is(+0, -0));
console.log(+0 === -0);
console.log(Object.is(0, -0));
```

**Answer:**
```
true
false
true
false
```

**Explanation:**
`Object.is()` is similar to `===` but with two differences:
- `Object.is(NaN, NaN)` is `true` (unlike `NaN === NaN`)
- `Object.is(+0, -0)` is `false` (unlike `+0 === -0`)

---

## Question 22: Getter Setter Trap

**What is the output?**

```javascript
const obj = {
  _value: 0,
  get value() {
    return this._value++;
  }
};

console.log(obj.value);
console.log(obj.value);
console.log(obj.value);
```

**Answer:**
```
0
1
2
```

**Explanation:**
Each access to `obj.value` calls the getter, which increments `_value` after returning it. Getters can have side effects!

---

## Question 23: Tagged Template Literal

**What is the output?**

```javascript
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

const a = 'hello';
const b = 'world';

tag`${a} ${b}`;
```

**Answer:**
```
["", " ", ""]
["hello", "world"]
```

**Explanation:**
Tagged template literals pass:
- `strings`: Array of string parts (split by interpolations)
- `values`: Array of interpolated values

---

## Question 24: Promise Race

**What is the output?**

```javascript
Promise.race([
  new Promise((resolve) => setTimeout(() => resolve(1), 100)),
  new Promise((resolve) => setTimeout(() => resolve(2), 50)),
  new Promise((resolve) => setTimeout(() => resolve(3), 150))
]).then(console.log);
```

**Answer:**
```
2
```

**Explanation:**
`Promise.race()` resolves/rejects with the first settled promise. The 50ms timeout completes first with value `2`.

---

## Question 25: Generator Function

**What is the output?**

```javascript
function* gen() {
  yield 1;
  yield 2;
  return 3;
}

const g = gen();

console.log(g.next());
console.log(g.next());
console.log(g.next());
console.log(g.next());
```

**Answer:**
```
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: true }
{ value: undefined, done: true }
```

**Explanation:**
- `yield` pauses execution and returns value
- `return` ends generator with final value
- After completion, `next()` returns `{ value: undefined, done: true }`

---

## Question 26: Proxy Trap

**What is the output?**

```javascript
const obj = { a: 1 };
const proxy = new Proxy(obj, {
  get(target, prop) {
    return prop in target ? target[prop] : 'default';
  }
});

console.log(proxy.a);
console.log(proxy.b);
console.log(obj.b);
```

**Answer:**
```
1
"default"
undefined
```

**Explanation:**
Proxy intercepts property access. The `get` trap returns `'default'` for non-existent properties. Original object is unaffected.

---

## Question 27: Class Static

**What is the output?**

```javascript
class MyClass {
  static value = 10;
  
  getValue() {
    return this.value;
  }
}

const instance = new MyClass();

console.log(MyClass.value);
console.log(instance.value);
console.log(instance.getValue());
```

**Answer:**
```
10
undefined
undefined
```

**Explanation:**
Static properties belong to the class, not instances. `this.value` in instance method refers to instance property (which doesn't exist).

---

## Question 28: Array Destructuring

**What is the output?**

```javascript
const [a, b] = [1];
const [c, d = 2] = [3];
const [e, ...f] = [4, 5, 6];

console.log(a, b);
console.log(c, d);
console.log(e, f);
```

**Answer:**
```
1 undefined
3 2
4 [5, 6]
```

**Explanation:**
- Missing elements: `undefined`
- Default values: Used when `undefined`
- Rest operator: Collects remaining elements into array

---

## Question 29: WeakMap Behavior

**What happens?**

```javascript
let obj = { name: 'John' };
const weakMap = new WeakMap();
weakMap.set(obj, 'value');

console.log(weakMap.get(obj));

obj = null;

// After garbage collection
console.log(weakMap.get(obj));
```

**Answer:**
```
"value"
undefined
```

**Explanation:**
WeakMap holds weak references. When `obj` is set to `null` and there are no other references, it can be garbage collected. The WeakMap entry is automatically removed.

---

## Question 30: Bitwise NOT

**What is the output?**

```javascript
console.log(~5);
console.log(~~5.95);
console.log(~~-5.95);
console.log(Math.floor(5.95));
```

**Answer:**
```
-6
5
-5
5
```

**Explanation:**
- `~n` (bitwise NOT) equals `-(n+1)`
- `~~` (double NOT) truncates decimals (works like `Math.trunc` for positive numbers)
- For negative numbers, `~~` truncates toward zero, while `Math.floor()` rounds down

---

## Key Takeaways

- **typeof null**: Returns "object" (JavaScript bug)
- **Array comparison**: Always by reference
- **Floating point**: Precision issues (0.1 + 0.2 ≠ 0.3)
- **Array sort**: Default is lexicographic
- **delete operator**: Creates holes in arrays
- **Comma operator**: Returns last expression
- **Object keys**: Always strings (or Symbols)
- **Set add**: Returns Set for chaining
- **isNaN vs Number.isNaN**: Coercion difference
- **Object.is**: Handles NaN and ±0 correctly
- **WeakMap**: Allows garbage collection
- **Double bitwise NOT**: Truncates decimals
- Edge cases matter in interviews
- Understand JavaScript quirks
- Test assumptions with examples
