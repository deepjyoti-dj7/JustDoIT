# Optional Chaining

Optional chaining (`?.`) allows you to safely access nested object properties without worrying about `null` or `undefined` values in the chain.

---

## The Problem It Solves

### Before Optional Chaining
```javascript
const user = {
  name: "John",
  address: {
    street: "123 Main St",
    city: "New York"
  }
};

// Without optional chaining - lots of checks needed
const city = user && user.address && user.address.city;

// Or with if statements
let zipCode;
if (user && user.address && user.address.zipCode) {
  zipCode = user.address.zipCode;
}

// If any part is null/undefined, this throws an error
const zipCode = user.address.zipCode;  // Works for this user
const zip2 = userWithoutAddress.address.zipCode;  // ✗ Error!
```

### With Optional Chaining
```javascript
const city = user?.address?.city;  // "New York"
const zipCode = user?.address?.zipCode;  // undefined (no error!)
const noUser = null;
const data = noUser?.address?.city;  // undefined (no error!)
```

---

## Basic Syntax

### Property Access
```javascript
const user = {
  name: "John",
  profile: {
    email: "john@example.com"
  }
};

// Regular access
user.profile.email;  // "john@example.com"

// Optional chaining
user?.profile?.email;  // "john@example.com"
user?.profile?.phone;  // undefined
user?.settings?.theme; // undefined (no error!)

// With null/undefined
const noUser = null;
noUser?.profile?.email;  // undefined (no error!)
```

### Array Access
```javascript
const users = [
  { name: "John" },
  { name: "Jane" }
];

users?.[0]?.name;   // "John"
users?.[10]?.name;  // undefined
users?.[0]?.email;  // undefined

const noArray = null;
noArray?.[0];       // undefined
```

### Function Calls
```javascript
const user = {
  getName: function() {
    return "John";
  }
};

user.getName?.();        // "John"
user.getEmail?.();       // undefined (method doesn't exist)

const noUser = null;
noUser.getName?.();      // undefined (no error!)
```

---

## Combining with Different Access Methods

```javascript
const data = {
  users: [
    { 
      name: "John", 
      getInfo: () => "User info" 
    }
  ],
  getUser: function(id) {
    return this.users[id];
  }
};

// Property + bracket + method
data?.users?.[0]?.getInfo?.();  // "User info"

// Method + bracket + property
data?.getUser?.(0)?.name;  // "John"

// Deep nesting
data?.users?.[0]?.profile?.settings?.theme;  // undefined
```

---

## Practical Use Cases

### 1. API Responses
```javascript
function displayUser(response) {
  const userName = response?.data?.user?.name ?? "Unknown";
  const email = response?.data?.user?.contact?.email ?? "No email";
  const city = response?.data?.user?.address?.city ?? "No city";
  
  console.log(`${userName} - ${email} from ${city}`);
}

displayUser({ data: { user: { name: "John" } } });
// "John - No email from No city"

displayUser(null);
// "Unknown - No email from No city"
```

### 2. Event Handling
```javascript
function handleClick(event) {
  const elementId = event?.target?.id;
  const className = event?.target?.classList?.[0];
  const parentText = event?.target?.parentElement?.textContent;
  
  console.log({ elementId, className, parentText });
}

// Safe even if event structure varies
button.addEventListener('click', handleClick);
```

### 3. Configuration Objects
```javascript
function initializeApp(config) {
  const apiUrl = config?.api?.baseUrl ?? "http://localhost:3000";
  const timeout = config?.api?.timeout ?? 5000;
  const theme = config?.ui?.theme ?? "light";
  const debug = config?.debug?.enabled ?? false;
  
  console.log({ apiUrl, timeout, theme, debug });
}

initializeApp({});  // All defaults
initializeApp({ api: { baseUrl: "https://api.com" } });  // Custom API
```

### 4. Nested Array Access
```javascript
const data = {
  results: [
    {
      items: [
        { name: "Item 1" },
        { name: "Item 2" }
      ]
    }
  ]
};

const firstItem = data?.results?.[0]?.items?.[0]?.name;
// "Item 1"

const noData = {};
const item = noData?.results?.[0]?.items?.[0]?.name;
// undefined (no error!)
```

### 5. Dynamic Property Access
```javascript
function getNestedValue(obj, path) {
  return path.split('.').reduce((current, prop) => {
    return current?.[prop];
  }, obj);
}

const user = {
  profile: {
    settings: {
      notifications: {
        email: true
      }
    }
  }
};

getNestedValue(user, "profile.settings.notifications.email");  // true
getNestedValue(user, "profile.settings.theme.color");  // undefined
```

---

## Optional Chaining with Function Calls

### Method Calls
```javascript
const user = {
  name: "John",
  greet() {
    return `Hello, ${this.name}`;
  }
};

user.greet?.();  // "Hello, John"
user.sayBye?.(); // undefined (method doesn't exist)

const noUser = null;
noUser.greet?.();  // undefined (no error!)
```

### Callback Functions
```javascript
function processData(data, callback) {
  const result = data.map(item => item * 2);
  callback?.(result);  // Only call if callback exists
}

processData([1, 2, 3], console.log);  // Logs [2, 4, 6]
processData([1, 2, 3]);               // No error, callback not called
```

### Constructor Calls (NOT Supported)
```javascript
// ✗ Cannot use optional chaining with 'new'
new User?.();  // SyntaxError

// Use regular checks instead
if (User) {
  new User();
}
```

---

## Combining with Nullish Coalescing

Optional chaining works great with nullish coalescing (`??`).

```javascript
const user = {
  name: "John",
  settings: {
    theme: "dark"
  }
};

// Optional chaining returns undefined if property missing
// Nullish coalescing provides default for null/undefined
const theme = user?.settings?.theme ?? "light";  // "dark"
const language = user?.settings?.language ?? "en";  // "en"

// Comparison with OR operator
const count = user?.stats?.count ?? 0;  // 0 (good)
const countOr = user?.stats?.count || 0; // 0 (same result)

// But with falsy values:
user.stats = { count: 0 };
const count1 = user?.stats?.count ?? 10;  // 0 ✓
const count2 = user?.stats?.count || 10;  // 10 ✗ (0 is falsy)
```

---

## Common Pitfalls

### 1. Short-Circuiting
```javascript
let called = false;

function doSomething() {
  called = true;
  return "done";
}

const obj = null;
obj?.property?.doSomething();

console.log(called);  // false - function never called
```

### 2. Not a Replacement for All Checks
```javascript
// ✓ Good for nested access
const value = user?.profile?.name;

// ✗ Don't use for all undefined checks
const result = someFunction?.() ?? defaultValue;
// Better:
const result = (typeof someFunction === 'function') 
  ? someFunction() 
  : defaultValue;
```

### 3. Cannot Use with Assignment
```javascript
// ✗ SyntaxError
user?.profile?.name = "Jane";

// ✓ Check explicitly
if (user?.profile) {
  user.profile.name = "Jane";
}
```

### 4. Template Literals
```javascript
const user = { name: "John" };

// ✓ Works
console.log(`Hello, ${user?.name}`);  // "Hello, John"

// ✓ Works with missing property
console.log(`Hello, ${user?.email ?? "Guest"}`);  // "Hello, Guest"
```

---

## Best Practices

1. **Use for uncertain nested data**
   ```javascript
   // ✓ Good - API response may vary
   const email = response?.data?.user?.email;
   
   // ✗ Unnecessary - you know the structure
   const name = user?.name;  // If user always has name
   ```

2. **Combine with nullish coalescing for defaults**
   ```javascript
   const theme = config?.ui?.theme ?? "light";
   ```

3. **Don't overuse - makes debugging harder**
   ```javascript
   // ✗ Too much optional chaining
   const value = a?.b?.c?.d?.e?.f?.g;
   
   // ✓ Better - validate at appropriate levels
   if (!a?.b) return null;
   const value = a.b.c.d;
   ```

4. **Use for external data sources**
   ```javascript
   // API responses
   const userData = apiResponse?.data?.user;
   
   // User input
   const files = event?.target?.files;
   
   // Third-party libraries
   const map = window?.google?.maps;
   ```

5. **Document why optional chaining is needed**
   ```javascript
   // User might not have a profile yet (new users)
   const avatar = user?.profile?.avatar ?? defaultAvatar;
   ```

---

## Browser Support & Alternatives

### Polyfill Alternative
```javascript
// For older browsers without optional chaining support
function get(obj, path, defaultValue) {
  const result = path
    .split('.')
    .reduce((acc, part) => acc && acc[part], obj);
  return result !== undefined ? result : defaultValue;
}

const email = get(user, 'profile.contact.email', 'none');
```

---

## Key Takeaways

- Optional chaining (`?.`) safely accesses nested properties
- Returns `undefined` instead of throwing an error
- Works with properties (`?.`), arrays (`?.[index]`), and functions (`?.()`)
- Stops evaluation (short-circuits) when encountering `null` or `undefined`
- Combine with nullish coalescing (`??`) for default values
- Cannot be used with assignment or `new` operator
- Best for uncertain data structures (API responses, user input)
- Don't overuse - makes code harder to debug and reason about
- Simplifies code that previously required multiple `&&` checks
