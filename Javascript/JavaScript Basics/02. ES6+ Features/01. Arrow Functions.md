# Arrow Functions

Arrow functions provide a shorter syntax for writing functions and handle `this` differently than regular functions.

---

## Basic Syntax

```javascript
// Regular function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => {
  return a + b;
};

// Implicit return (single expression)
const add = (a, b) => a + b;
```

---

## Syntax Variations

### No Parameters
```javascript
const greet = () => "Hello!";
greet();  // "Hello!"
```

### Single Parameter (parentheses optional)
```javascript
const square = x => x * x;
const double = (x) => x * 2;  // parentheses optional but recommended
```

### Multiple Parameters
```javascript
const add = (a, b) => a + b;
const sum = (a, b, c) => a + b + c;
```

### Multiline Body
```javascript
const processUser = (user) => {
  const name = user.name.toUpperCase();
  const age = user.age + 1;
  return { name, age };
};
```

### Returning Objects (wrap in parentheses)
```javascript
const makePerson = (name, age) => ({ name: name, age: age });
const makePerson = (name, age) => ({ name, age });  // shorthand
```

---

## Implicit vs Explicit Return

```javascript
// Implicit return (no curly braces)
const multiply = (a, b) => a * b;

// Explicit return (with curly braces)
const multiply = (a, b) => {
  return a * b;
};

// Object return needs parentheses
const getUser = () => ({ name: "John", age: 30 });
```

---

## Lexical `this` Binding

Arrow functions don't have their own `this` - they inherit from parent scope.

### Regular Function `this`
```javascript
const person = {
  name: "John",
  hobbies: ["reading", "coding"],
  showHobbies: function() {
    this.hobbies.forEach(function(hobby) {
      console.log(this.name + " likes " + hobby);
      // Error: this.name is undefined (this refers to global/undefined)
    });
  }
};

// Fix with bind/self/arrow
showHobbies: function() {
  const self = this;  // Old way
  this.hobbies.forEach(function(hobby) {
    console.log(self.name + " likes " + hobby);
  }.bind(this));
}
```

### Arrow Function `this`
```javascript
const person = {
  name: "John",
  hobbies: ["reading", "coding"],
  showHobbies: function() {
    this.hobbies.forEach((hobby) => {
      console.log(this.name + " likes " + hobby);  // ✓ Works! this = person
    });
  }
};
```

---

## Use Cases

### Array Methods
```javascript
const numbers = [1, 2, 3, 4, 5];

// map
const doubled = numbers.map(n => n * 2);

// filter
const evens = numbers.filter(n => n % 2 === 0);

// reduce
const sum = numbers.reduce((acc, n) => acc + n, 0);

// sort
const sorted = numbers.sort((a, b) => a - b);
```

### Callbacks
```javascript
setTimeout(() => console.log("Done!"), 1000);

button.addEventListener('click', () => {
  console.log("Clicked!");
});

fetch(url)
  .then(response => response.json())
  .then(data => console.log(data));
```

### Function Composition
```javascript
const add5 = x => x + 5;
const multiply2 = x => x * 2;
const subtract3 = x => x - 3;

const result = subtract3(multiply2(add5(10)));  // 27
```

---

## When NOT to Use Arrow Functions

### 1. Object Methods
```javascript
// ✗ Avoid - this doesn't refer to object
const person = {
  name: "John",
  greet: () => {
    console.log("Hi, I'm " + this.name);  // undefined
  }
};

// ✓ Use regular function
const person = {
  name: "John",
  greet() {
    console.log("Hi, I'm " + this.name);  // Works
  }
};
```

### 2. Constructors
```javascript
// ✗ Error - cannot use as constructor
const Person = (name) => {
  this.name = name;
};
new Person("John");  // TypeError

// ✓ Use regular function or class
function Person(name) {
  this.name = name;
}
```

### 3. Dynamic Context
```javascript
// ✗ Event handler with arrow function
button.addEventListener('click', () => {
  this.classList.toggle('active');  // this is not the button
});

// ✓ Use regular function
button.addEventListener('click', function() {
  this.classList.toggle('active');  // this = button
});
```

### 4. Prototype Methods
```javascript
// ✗ Avoid
Person.prototype.greet = () => {
  console.log(this.name);  // this is not the instance
};

// ✓ Use regular function
Person.prototype.greet = function() {
  console.log(this.name);  // Works
};
```

---

## Key Differences: Arrow vs Regular

| Feature | Arrow Function | Regular Function |
|---------|---------------|------------------|
| Syntax | Shorter `=>` | `function` keyword |
| `this` binding | Lexical (inherited) | Dynamic (call-site) |
| `arguments` object | No | Yes |
| Constructor | Cannot use `new` | Can use `new` |
| Implicit return | Yes (single expression) | No |
| Method definition | Not recommended | Recommended |

---

## Best Practices

1. **Use for callbacks and array methods**
   ```javascript
   array.map(x => x * 2)
   setTimeout(() => doSomething(), 1000)
   ```

2. **Use regular functions for object methods**
   ```javascript
   const obj = {
     method() { }  // Not: method: () => { }
   }
   ```

3. **Parenthesize object returns**
   ```javascript
   const getObj = () => ({ key: 'value' })
   ```

4. **Keep them short and focused**
   ```javascript
   // ✓ Good
   const double = x => x * 2;
   
   // ✗ Too long - use regular function
   const complex = (a, b, c) => {
     // 20 lines of code
   };
   ```

---

## Key Takeaways

- **Shorter syntax** for function expressions
- **Implicit return** for single expressions
- **Lexical `this`** - inherits from parent scope
- **No `arguments`** object
- **Cannot be constructors**
- Perfect for **callbacks and array methods**
- Avoid for **object methods** and **dynamic context**