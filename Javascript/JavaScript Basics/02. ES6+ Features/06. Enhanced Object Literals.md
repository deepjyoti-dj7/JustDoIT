# Enhanced Object Literals

ES6 introduced several enhancements to object literal syntax, making object creation more concise and powerful.

---

## Property Shorthand

When the property name matches the variable name, you can omit the value.

### Before ES6
```javascript
const name = "John";
const age = 30;

const person = {
  name: name,
  age: age
};
```

### ES6+ Shorthand
```javascript
const name = "John";
const age = 30;

const person = {
  name,
  age
};
// { name: "John", age: 30 }
```

### Practical Example
```javascript
function createUser(username, email, role) {
  return {
    username,
    email,
    role,
    createdAt: new Date(),
    isActive: true
  };
}

const user = createUser("john_doe", "john@example.com", "admin");
// { username: "john_doe", email: "john@example.com", role: "admin", ... }
```

---

## Method Shorthand

Concise syntax for defining methods in objects.

### Before ES6
```javascript
const calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};
```

### ES6+ Shorthand
```javascript
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

calculator.add(5, 3);      // 8
calculator.subtract(5, 3); // 2
```

### With Arrow Functions (Different this binding)
```javascript
const person = {
  name: "John",
  
  // Method shorthand (has this binding)
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  },
  
  // Arrow function (no this binding)
  greetArrow: () => {
    console.log(`Hi, I'm ${this.name}`);  // undefined
  }
};

person.greet();       // "Hi, I'm John"
person.greetArrow();  // "Hi, I'm undefined"
```

---

## Computed Property Names

Use expressions as property names using square brackets `[]`.

### Dynamic Property Names
```javascript
const propName = "age";

const person = {
  name: "John",
  [propName]: 30
};
// { name: "John", age: 30 }
```

### Using Expressions
```javascript
const prefix = "user";

const data = {
  [prefix + "Name"]: "John",
  [prefix + "Age"]: 30,
  [prefix + "Role"]: "admin"
};
// { userName: "John", userAge: 30, userRole: "admin" }
```

### With Function Calls
```javascript
function getKey() {
  return "dynamicKey";
}

const obj = {
  [getKey()]: "value"
};
// { dynamicKey: "value" }
```

### Creating Dynamic Objects
```javascript
function createObject(key, value) {
  return {
    [key]: value
  };
}

createObject("name", "John");  // { name: "John" }
createObject("age", 30);       // { age: 30 }
```

---

## Combining All Features

```javascript
const field = "email";
const value = "john@example.com";

const user = {
  // Property shorthand
  name,
  age,
  
  // Computed property
  [field]: value,
  [`is${field.charAt(0).toUpperCase() + field.slice(1)}Verified`]: true,
  
  // Method shorthand
  getInfo() {
    return `${this.name} (${this.age})`;
  },
  
  updateAge(newAge) {
    this.age = newAge;
  }
};
```

---

## Practical Use Cases

### 1. API Response Mapping
```javascript
function mapUserResponse(id, firstName, lastName, emailAddress) {
  return {
    id,
    name: `${firstName} ${lastName}`,
    email: emailAddress,
    
    getFullName() {
      return `${firstName} ${lastName}`;
    },
    
    getInitials() {
      return `${firstName[0]}${lastName[0]}`.toUpperCase();
    }
  };
}
```

### 2. Dynamic Form Data
```javascript
function buildFormData(fields) {
  const formData = {};
  
  fields.forEach(({ name, value }) => {
    formData[name] = value;
  });
  
  return formData;
}

// Or using reduce with computed properties
function buildFormData(fields) {
  return fields.reduce((acc, { name, value }) => ({
    ...acc,
    [name]: value
  }), {});
}
```

### 3. State Management
```javascript
function createStore(initialState) {
  let state = initialState;
  
  return {
    getState() {
      return { ...state };
    },
    
    setState(updates) {
      state = { ...state, ...updates };
    },
    
    updateField(fieldName, value) {
      state = {
        ...state,
        [fieldName]: value
      };
    }
  };
}

const store = createStore({ count: 0, user: null });
store.updateField("count", 5);
store.updateField("user", { name: "John" });
```

### 4. Event Handling
```javascript
function createEventEmitter() {
  const events = {};
  
  return {
    on(event, handler) {
      if (!events[event]) events[event] = [];
      events[event].push(handler);
    },
    
    emit(event, data) {
      if (events[event]) {
        events[event].forEach(handler => handler(data));
      }
    },
    
    off(event, handler) {
      if (events[event]) {
        events[event] = events[event].filter(h => h !== handler);
      }
    }
  };
}
```

### 5. Building Query Objects
```javascript
function buildQuery(filters) {
  const query = {};
  
  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && value !== "") {
      query[key] = value;
    }
  });
  
  return query;
}

buildQuery({ name: "John", age: 30, city: "" });
// { name: "John", age: 30 }
```

---

## Advanced Patterns

### Computed Methods
```javascript
const operations = {
  add: "Addition",
  subtract: "Subtraction",
  multiply: "Multiplication"
};

const calculator = {
  [`perform${operations.add}`](a, b) {
    return a + b;
  },
  [`perform${operations.subtract}`](a, b) {
    return a - b;
  }
};

calculator.performAddition(5, 3);      // 8
calculator.performSubtraction(5, 3);   // 2
```

### Symbol Properties
```javascript
const idSymbol = Symbol("id");
const metaSymbol = Symbol("metadata");

const user = {
  name: "John",
  [idSymbol]: 12345,
  [metaSymbol]: {
    createdAt: new Date(),
    version: 1
  },
  
  getId() {
    return this[idSymbol];
  }
};

user.name;          // "John"
user[idSymbol];     // 12345
user.getId();       // 12345
```

### Nested Computed Properties
```javascript
const config = {
  api: {
    ["base" + "URL"]: "https://api.example.com",
    ["timeout".toUpperCase()]: 5000,
    [["endpoints", "users"].join("_")]: "/users"
  }
};
// { api: { baseURL: "...", TIMEOUT: 5000, endpoints_users: "/users" } }
```

---

## Common Pitfalls

### 1. Arrow Functions in Methods
```javascript
// ✗ Avoid - loses this context
const person = {
  name: "John",
  greet: () => console.log(this.name)  // undefined
};

// ✓ Use method shorthand
const person = {
  name: "John",
  greet() {
    console.log(this.name);  // "John"
  }
};
```

### 2. Computed Property Evaluation
```javascript
let counter = 0;

const obj = {
  [counter++]: "first",
  [counter++]: "second"
};
// { 0: "first", 1: "second" }
// counter is now 2
```

### 3. Property Shorthand with Different Values
```javascript
const x = 10;

// This creates { x: 20 }, not { 10: 20 }
const obj = { x: 20 };

// To use variable name as key, use computed property
const obj2 = { [x]: 20 };  // { 10: 20 }
```

---

## Best Practices

1. **Use property shorthand for cleaner code**
   ```javascript
   // ✓ Good
   const user = { name, age, email };
   
   // ✗ Verbose
   const user = { name: name, age: age, email: email };
   ```

2. **Use method shorthand for object methods**
   ```javascript
   // ✓ Good
   const obj = {
     doSomething() {}
   };
   
   // ✗ Verbose
   const obj = {
     doSomething: function() {}
   };
   ```

3. **Use computed properties for dynamic keys**
   ```javascript
   // ✓ Good
   const obj = { [dynamicKey]: value };
   
   // ✗ Less readable
   const obj = {};
   obj[dynamicKey] = value;
   ```

4. **Combine features for maximum conciseness**
   ```javascript
   function createUser(name, age) {
     return {
       name,
       age,
       getInfo() {
         return `${this.name} is ${this.age}`;
       }
     };
   }
   ```

5. **Be mindful of method vs arrow function**
   ```javascript
   // Use method shorthand when you need 'this'
   // Use arrow functions for callbacks or when you don't need 'this'
   ```

---

## Key Takeaways

- **Property shorthand**: Omit value when property name equals variable name
- **Method shorthand**: Omit `function` keyword for cleaner method definitions
- **Computed properties**: Use `[expression]` for dynamic property names
- All features work together to create more concise and readable code
- Method shorthand creates proper methods with `this` binding
- Arrow functions as properties don't have `this` binding
- Computed properties are evaluated at object creation time
- Enhanced object literals reduce boilerplate and improve code clarity
