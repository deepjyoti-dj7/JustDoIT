# Event Loop Basics

The Event Loop is the mechanism that allows JavaScript to perform non-blocking operations despite being single-threaded.

---

## JavaScript is Single-Threaded

JavaScript has **one call stack** and can execute **one thing at a time**.

```javascript
console.log("First");
console.log("Second");
console.log("Third");

// Output (in order):
// "First"
// "Second"
// "Third"
```

But how does JavaScript handle asynchronous operations?

---

## The Event Loop

The Event Loop continuously checks if the call stack is empty, and if so, takes the first task from the task queue and pushes it onto the call stack.

### Components

1. **Call Stack**: Where code execution happens
2. **Web APIs**: Browser-provided APIs (setTimeout, fetch, DOM events)
3. **Callback Queue (Task Queue)**: Queue for callbacks from async operations
4. **Event Loop**: Monitors call stack and callback queue

---

## How It Works

### Visualizing the Flow
```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

console.log("End");

// Output:
// "Start"
// "End"
// "Timeout"
```

### Step-by-Step Execution

1. `console.log("Start")` → Executes immediately
2. `setTimeout(...)` → Sent to Web API, not blocking
3. `console.log("End")` → Executes immediately
4. Call stack is empty
5. Event Loop checks callback queue
6. Callback from setTimeout executes → "Timeout"

---

## Call Stack

The call stack tracks function execution.

```javascript
function third() {
  console.log("Third");
}

function second() {
  third();
  console.log("Second");
}

function first() {
  second();
  console.log("First");
}

first();

// Call Stack Visualization:
// 1. first() pushed
// 2. second() pushed
// 3. third() pushed
// 4. third() logs "Third", pops
// 5. second() logs "Second", pops
// 6. first() logs "First", pops

// Output:
// "Third"
// "Second"
// "First"
```

---

## Callback Queue (Task Queue)

Holds callbacks ready to execute.

```javascript
console.log("A");

setTimeout(() => console.log("B"), 0);
setTimeout(() => console.log("C"), 0);

console.log("D");

// Execution:
// 1. "A" executes (call stack)
// 2. setTimeout callbacks go to queue
// 3. "D" executes (call stack)
// 4. Call stack empty
// 5. Event loop moves "B" callback to stack
// 6. Event loop moves "C" callback to stack

// Output:
// "A"
// "D"
// "B"
// "C"
```

---

## Blocking vs Non-Blocking

### Blocking Code
```javascript
console.log("Start");

// Blocking operation
for (let i = 0; i < 3000000000; i++) {
  // Long-running loop blocks everything
}

console.log("End");
// UI freezes until loop completes
```

### Non-Blocking Code
```javascript
console.log("Start");

// Non-blocking - delegated to Web API
setTimeout(() => {
  console.log("Timeout");
}, 2000);

console.log("End");
// UI remains responsive

// Output:
// "Start"
// "End"
// "Timeout" (after 2 seconds)
```

---

## Practical Examples

### 1. Multiple Timeouts
```javascript
console.log("1");

setTimeout(() => console.log("2"), 1000);
setTimeout(() => console.log("3"), 0);
setTimeout(() => console.log("4"), 0);

console.log("5");

// Output:
// "1"
// "5"
// "3"
// "4"
// "2" (after 1 second)
```

### 2. setTimeout with Zero Delay
```javascript
console.log("A");

setTimeout(() => {
  console.log("B");
}, 0);

Promise.resolve().then(() => {
  console.log("C");
});

console.log("D");

// Output:
// "A"
// "D"
// "C"  (Promises are microtasks - higher priority)
// "B"  (setTimeout is macrotask)
```

### 3. Event Handlers
```javascript
console.log("Script start");

button.addEventListener("click", () => {
  console.log("Button clicked");
  
  setTimeout(() => {
    console.log("Timeout in handler");
  }, 0);
});

console.log("Script end");

// Initial output:
// "Script start"
// "Script end"

// When button clicked:
// "Button clicked"
// "Timeout in handler" (goes to queue)
```

### 4. AJAX Request
```javascript
console.log("Start");

fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => {
    console.log("Data:", data);
  });

console.log("End");

// Output:
// "Start"
// "End"
// "Data: ..." (when response arrives)
```

---

## Why Event Loop Matters

### Example: Responsive UI
```javascript
// ✗ Bad: Blocks UI
function processLargeArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    // Heavy processing
    process(arr[i]);
  }
}

processLargeArray(hugeArray);
// UI freezes!

// ✓ Good: Non-blocking
function processLargeArrayAsync(arr, callback) {
  let i = 0;
  
  function processChunk() {
    const chunk = arr.slice(i, i + 1000);
    chunk.forEach(process);
    i += 1000;
    
    if (i < arr.length) {
      setTimeout(processChunk, 0);  // Give browser time to breathe
    } else {
      callback();
    }
  }
  
  processChunk();
}

processLargeArrayAsync(hugeArray, () => {
  console.log("Done");
});
// UI remains responsive
```

---

## Event Loop Phases (Simplified)

```javascript
// 1. Execute all synchronous code
console.log("Sync 1");
console.log("Sync 2");

// 2. Process microtasks (Promises)
Promise.resolve().then(() => console.log("Microtask"));

// 3. Process macrotasks (setTimeout, setInterval)
setTimeout(() => console.log("Macrotask"), 0);

console.log("Sync 3");

// Output:
// "Sync 1"
// "Sync 2"
// "Sync 3"
// "Microtask"
// "Macrotask"
```

---

## Common Patterns

### 1. Deferring Execution
```javascript
// Run after current execution context
setTimeout(() => {
  console.log("Deferred");
}, 0);

console.log("Immediate");

// "Immediate"
// "Deferred"
```

### 2. Animation Loop
```javascript
function animate() {
  updatePosition();
  render();
  
  requestAnimationFrame(animate);
  // Runs before next repaint (optimized by browser)
}

animate();
```

### 3. Breaking Long Tasks
```javascript
function processInChunks(data, chunkSize, callback) {
  let index = 0;
  
  function processNextChunk() {
    const chunk = data.slice(index, index + chunkSize);
    processChunk(chunk);
    index += chunkSize;
    
    if (index < data.length) {
      setTimeout(processNextChunk, 0);
    } else {
      callback();
    }
  }
  
  processNextChunk();
}
```

---

## Debugging Event Loop

### Stack Overflow
```javascript
function recursiveFunction() {
  recursiveFunction();  // No base case
}

recursiveFunction();
// RangeError: Maximum call stack size exceeded
```

### Infinite Loop vs Infinite Callback
```javascript
// ✗ Blocks everything (infinite synchronous loop)
while (true) {
  console.log("Blocked");
}

// ✓ Non-blocking (each iteration queued)
function infiniteTimeout() {
  console.log("Running");
  setTimeout(infiniteTimeout, 0);
}
infiniteTimeout();
// Still infinite, but doesn't freeze UI
```

---

## Visual Example

```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

Promise.resolve().then(() => {
  console.log("3");
});

console.log("4");

// Execution Order:
// Call Stack: console.log("1") → "1"
// Call Stack: Promise.resolve() → queued to microtask queue
// Call Stack: setTimeout → queued to macrotask queue
// Call Stack: console.log("4") → "4"
// Call Stack: Empty
// Microtask Queue: Promise callback → "3"
// Macrotask Queue: setTimeout callback → "2"

// Output:
// "1"
// "4"
// "3"
// "2"
```

---

## Key Concepts

### 1. Single-Threaded
- JavaScript executes one thing at a time
- Call stack can only hold one execution context at the top

### 2. Non-Blocking
- Async operations delegated to Web APIs
- Callbacks queued when operations complete
- UI remains responsive

### 3. Event Loop
- Continuously monitors call stack
- Moves callbacks from queue to stack when empty
- Prioritizes microtasks over macrotasks

---

## Best Practices

1. **Don't block the event loop**
   ```javascript
   // ✗ Bad
   while (Date.now() < Date.now() + 5000) {}
   
   // ✓ Good
   setTimeout(() => {}, 5000);
   ```

2. **Break up long-running tasks**
   ```javascript
   function processLarge(data) {
     data.forEach((item, i) => {
       if (i % 1000 === 0) {
         setTimeout(() => process(item), 0);
       } else {
         process(item);
       }
     });
   }
   ```

3. **Understand async timing**
   ```javascript
   // Code won't run in order written
   setTimeout(() => console.log("A"), 0);
   console.log("B");
   // Output: "B", "A"
   ```

---

## Key Takeaways

- JavaScript is single-threaded but can handle async operations
- Event Loop manages the execution of callbacks
- Call Stack executes code, one frame at a time
- Callback Queue holds callbacks waiting to execute
- Web APIs handle async operations (timers, fetch, events)
- `setTimeout(..., 0)` doesn't execute immediately - goes to queue
- Event loop only processes queue when call stack is empty
- Microtasks (Promises) have higher priority than macrotasks (setTimeout)
- Understanding event loop is crucial for async programming
- Avoid blocking operations to keep UI responsive
