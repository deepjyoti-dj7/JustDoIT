# Callbacks

A callback is a function passed as an argument to another function, to be executed later (usually after some operation completes).

---

## Basic Concept

### Simple Callback
```javascript
function greet(name, callback) {
  console.log(`Hello, ${name}!`);
  callback();
}

function sayGoodbye() {
  console.log("Goodbye!");
}

greet("John", sayGoodbye);
// "Hello, John!"
// "Goodbye!"
```

### Anonymous Callback
```javascript
greet("John", function() {
  console.log("Goodbye!");
});

// Or with arrow function
greet("John", () => {
  console.log("Goodbye!");
});
```

---

## Callbacks with Parameters

```javascript
function processUser(userId, callback) {
  // Simulate fetching user
  const user = { id: userId, name: "John Doe" };
  callback(user);
}

processUser(123, (user) => {
  console.log(`Processing: ${user.name}`);
});
// "Processing: John Doe"
```

### Error-First Callbacks (Node.js Convention)
```javascript
function readFile(filename, callback) {
  // Simulate file reading
  const error = null;
  const data = "File contents";
  
  if (error) {
    callback(error, null);
  } else {
    callback(null, data);
  }
}

readFile("data.txt", (error, data) => {
  if (error) {
    console.error("Error:", error);
    return;
  }
  console.log("Data:", data);
});
```

---

## Synchronous vs Asynchronous Callbacks

### Synchronous Callbacks
Execute immediately.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Array methods use synchronous callbacks
numbers.forEach((num) => {
  console.log(num);
});
// Logs 1, 2, 3, 4, 5 immediately

const doubled = numbers.map((num) => num * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

const evens = numbers.filter((num) => num % 2 === 0);
console.log(evens);  // [2, 4]
```

### Asynchronous Callbacks
Execute later (after some operation).

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout callback");
}, 1000);

console.log("End");

// Output:
// "Start"
// "End"
// "Timeout callback" (after 1 second)
```

---

## Common Callback Patterns

### 1. Event Handlers
```javascript
const button = document.querySelector("button");

button.addEventListener("click", () => {
  console.log("Button clicked!");
});

button.addEventListener("mouseover", (event) => {
  console.log("Mouse over at:", event.clientX, event.clientY);
});
```

### 2. Timer Functions
```javascript
// setTimeout - run once after delay
setTimeout(() => {
  console.log("Executed after 2 seconds");
}, 2000);

// setInterval - run repeatedly
const intervalId = setInterval(() => {
  console.log("Repeated every second");
}, 1000);

// Stop interval after 5 seconds
setTimeout(() => {
  clearInterval(intervalId);
}, 5000);
```

### 3. Array Methods
```javascript
const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
  { name: "Bob", age: 35 }
];

// forEach
users.forEach((user) => {
  console.log(`${user.name} is ${user.age} years old`);
});

// map
const names = users.map((user) => user.name);
// ["John", "Jane", "Bob"]

// filter
const adults = users.filter((user) => user.age >= 30);
// [{ name: "John", age: 30 }, { name: "Bob", age: 35 }]

// find
const jane = users.find((user) => user.name === "Jane");
// { name: "Jane", age: 25 }

// reduce
const totalAge = users.reduce((sum, user) => sum + user.age, 0);
// 90
```

---

## Practical Examples

### 1. Data Processing
```javascript
function fetchUserData(userId, callback) {
  // Simulate API call
  setTimeout(() => {
    const user = {
      id: userId,
      name: "John Doe",
      email: "john@example.com"
    };
    callback(user);
  }, 1000);
}

function processUser(user) {
  console.log("Processing user:", user.name);
  console.log("Email:", user.email);
}

fetchUserData(123, processUser);
// After 1 second:
// "Processing user: John Doe"
// "Email: john@example.com"
```

### 2. File Operations (Node.js Style)
```javascript
function readFileAsync(filename, callback) {
  setTimeout(() => {
    const success = Math.random() > 0.2;
    
    if (success) {
      callback(null, `Contents of ${filename}`);
    } else {
      callback(new Error("File not found"), null);
    }
  }, 500);
}

readFileAsync("data.txt", (error, content) => {
  if (error) {
    console.error("Error reading file:", error.message);
    return;
  }
  console.log("File content:", content);
});
```

### 3. Custom Event System
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => {
        callback(data);
      });
    }
  }
  
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

const emitter = new EventEmitter();

emitter.on("user-login", (user) => {
  console.log(`${user.name} logged in`);
});

emitter.on("user-login", (user) => {
  console.log(`Welcome back, ${user.name}!`);
});

emitter.emit("user-login", { name: "John" });
// "John logged in"
// "Welcome back, John!"
```

### 4. Chaining Operations
```javascript
function step1(data, callback) {
  setTimeout(() => {
    console.log("Step 1: Processing", data);
    callback(data + " -> Step1");
  }, 500);
}

function step2(data, callback) {
  setTimeout(() => {
    console.log("Step 2: Processing", data);
    callback(data + " -> Step2");
  }, 500);
}

function step3(data, callback) {
  setTimeout(() => {
    console.log("Step 3: Processing", data);
    callback(data + " -> Step3");
  }, 500);
}

step1("Start", (result1) => {
  step2(result1, (result2) => {
    step3(result2, (result3) => {
      console.log("Final result:", result3);
    });
  });
});
```

### 5. Retry Logic
```javascript
function fetchWithRetry(url, maxRetries, callback) {
  let attempts = 0;
  
  function attempt() {
    attempts++;
    console.log(`Attempt ${attempts} of ${maxRetries}`);
    
    // Simulate fetch
    setTimeout(() => {
      const success = Math.random() > 0.6;
      
      if (success) {
        callback(null, { data: "Success data" });
      } else if (attempts < maxRetries) {
        console.log("Failed, retrying...");
        attempt();
      } else {
        callback(new Error("Max retries reached"), null);
      }
    }, 1000);
  }
  
  attempt();
}

fetchWithRetry("api/users", 3, (error, data) => {
  if (error) {
    console.error("Failed:", error.message);
  } else {
    console.log("Success:", data);
  }
});
```

---

## Error Handling

### Try-Catch with Callbacks
```javascript
function riskyOperation(callback) {
  try {
    // Potentially failing operation
    const result = Math.random();
    if (result < 0.5) {
      throw new Error("Operation failed");
    }
    callback(null, result);
  } catch (error) {
    callback(error, null);
  }
}

riskyOperation((error, result) => {
  if (error) {
    console.error("Error:", error.message);
  } else {
    console.log("Result:", result);
  }
});
```

### Multiple Error Scenarios
```javascript
function validateAndProcess(data, callback) {
  if (!data) {
    return callback(new Error("Data is required"));
  }
  
  if (typeof data !== "object") {
    return callback(new Error("Data must be an object"));
  }
  
  if (!data.name) {
    return callback(new Error("Name is required"));
  }
  
  // Process valid data
  setTimeout(() => {
    callback(null, { ...data, processed: true });
  }, 500);
}

validateAndProcess({ name: "John" }, (error, result) => {
  if (error) {
    console.error("Validation error:", error.message);
    return;
  }
  console.log("Processed:", result);
});
```

---

## Callback Best Practices

### 1. Named Functions for Clarity
```javascript
// ✗ Harder to read
fetchData(123, (data) => {
  processData(data, (result) => {
    saveData(result, () => {
      console.log("Done");
    });
  });
});

// ✓ More readable
function handleFetchedData(data) {
  processData(data, handleProcessedData);
}

function handleProcessedData(result) {
  saveData(result, handleSavedData);
}

function handleSavedData() {
  console.log("Done");
}

fetchData(123, handleFetchedData);
```

### 2. Error-First Convention
```javascript
// ✓ Good: Error first
function operation(callback) {
  callback(error, result);
}

operation((error, result) => {
  if (error) {
    // Handle error
    return;
  }
  // Use result
});
```

### 3. Return Early on Errors
```javascript
function process(data, callback) {
  if (!data) {
    return callback(new Error("No data"));  // Return early
  }
  
  // Continue processing
  callback(null, processedData);
}
```

### 4. Don't Call Callback Twice
```javascript
// ✗ Bad
function bad(callback) {
  callback(null, "first");
  callback(null, "second");  // Don't do this!
}

// ✓ Good
function good(callback) {
  if (error) {
    return callback(error);
  }
  return callback(null, result);
}
```

---

## Common Pitfalls

### 1. Callback Not Being a Function
```javascript
function doSomething(callback) {
  if (typeof callback !== "function") {
    throw new Error("Callback must be a function");
  }
  callback();
}
```

### 2. Forgetting to Handle Errors
```javascript
// ✗ Bad: Ignoring errors
fetchData((error, data) => {
  console.log(data.name);  // Will crash if error exists
});

// ✓ Good: Handle errors
fetchData((error, data) => {
  if (error) {
    console.error(error);
    return;
  }
  console.log(data.name);
});
```

### 3. Lost Context (this)
```javascript
class Counter {
  constructor() {
    this.count = 0;
  }
  
  increment() {
    this.count++;
  }
  
  delayedIncrement() {
    // ✗ Lost context
    setTimeout(this.increment, 1000);  // 'this' will be undefined
    
    // ✓ Fix with arrow function
    setTimeout(() => this.increment(), 1000);
    
    // ✓ Or with bind
    setTimeout(this.increment.bind(this), 1000);
  }
}
```

---

## Key Takeaways

- Callbacks are functions passed as arguments to other functions
- Can be synchronous (executed immediately) or asynchronous (executed later)
- Error-first callback pattern: `callback(error, result)`
- Used extensively in: events, timers, array methods, async operations
- Can lead to callback hell with deep nesting (solved by Promises)
- Always handle errors in callbacks
- Be careful with `this` context in callbacks
- Don't call the same callback multiple times
- Modern JavaScript prefers Promises/async-await over callbacks
