# setTimeout & setInterval

`setTimeout` and `setInterval` are timer functions that allow you to execute code after a delay or at regular intervals.

---

## setTimeout

Executes code once after a specified delay.

### Basic Syntax
```javascript
setTimeout(callback, delay);
setTimeout(callback, delay, arg1, arg2, ...);
```

### Simple Example
```javascript
console.log("Start");

setTimeout(() => {
  console.log("Executed after 2 seconds");
}, 2000);

console.log("End");

// Output:
// "Start"
// "End"
// "Executed after 2 seconds" (after 2000ms)
```

### With Parameters
```javascript
function greet(name, message) {
  console.log(`${message}, ${name}!`);
}

setTimeout(greet, 1000, "John", "Hello");
// After 1 second: "Hello, John!"
```

### Returning a Timer ID
```javascript
const timerId = setTimeout(() => {
  console.log("This will execute");
}, 3000);

console.log("Timer ID:", timerId);  // Number (e.g., 123)
```

---

## clearTimeout

Cancel a scheduled timeout.

```javascript
const timerId = setTimeout(() => {
  console.log("This will NOT execute");
}, 3000);

// Cancel before it executes
clearTimeout(timerId);
```

### Conditional Cancellation
```javascript
let timerId = setTimeout(() => {
  console.log("Processing...");
}, 5000);

// Cancel if user clicks button
button.addEventListener("click", () => {
  clearTimeout(timerId);
  console.log("Timeout cancelled");
});
```

---

## setInterval

Executes code repeatedly at specified intervals.

### Basic Syntax
```javascript
setInterval(callback, delay);
setInterval(callback, delay, arg1, arg2, ...);
```

### Simple Example
```javascript
let count = 0;

const intervalId = setInterval(() => {
  count++;
  console.log(`Count: ${count}`);
}, 1000);

// Logs every second:
// "Count: 1"
// "Count: 2"
// "Count: 3"
// ...
```

### With Parameters
```javascript
function printMessage(message, index) {
  console.log(`${index}: ${message}`);
}

let index = 0;
setInterval(printMessage, 1000, "Hello", ++index);
```

---

## clearInterval

Stop a repeating interval.

```javascript
let count = 0;

const intervalId = setInterval(() => {
  count++;
  console.log(`Count: ${count}`);
  
  if (count === 5) {
    clearInterval(intervalId);
    console.log("Interval stopped");
  }
}, 1000);

// Output:
// "Count: 1"
// "Count: 2"
// "Count: 3"
// "Count: 4"
// "Count: 5"
// "Interval stopped"
```

---

## Practical Examples

### 1. Countdown Timer
```javascript
function countdown(seconds) {
  let remaining = seconds;
  
  console.log(remaining);
  
  const intervalId = setInterval(() => {
    remaining--;
    console.log(remaining);
    
    if (remaining === 0) {
      clearInterval(intervalId);
      console.log("Time's up!");
    }
  }, 1000);
  
  return intervalId;
}

countdown(5);
// 5
// 4
// 3
// 2
// 1
// 0
// "Time's up!"
```

### 2. Clock
```javascript
function displayClock() {
  function updateTime() {
    const now = new Date();
    const time = now.toLocaleTimeString();
    console.log(time);
  }
  
  updateTime();  // Show immediately
  setInterval(updateTime, 1000);  // Update every second
}

displayClock();
// "10:30:45 AM"
// "10:30:46 AM"
// "10:30:47 AM"
// ...
```

### 3. Auto-Save
```javascript
class Editor {
  constructor() {
    this.content = "";
    this.autoSaveId = null;
  }
  
  startAutoSave() {
    this.autoSaveId = setInterval(() => {
      this.save();
    }, 30000);  // Save every 30 seconds
  }
  
  stopAutoSave() {
    if (this.autoSaveId) {
      clearInterval(this.autoSaveId);
      this.autoSaveId = null;
    }
  }
  
  save() {
    console.log("Saving content:", this.content);
    // Save to server/localStorage
  }
  
  updateContent(newContent) {
    this.content = newContent;
  }
}

const editor = new Editor();
editor.startAutoSave();
```

### 4. Delayed Debounce
```javascript
function debounce(func, delay) {
  let timerId;
  
  return function(...args) {
    clearTimeout(timerId);
    timerId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// Usage: Search as user types
const searchInput = document.querySelector("#search");

const performSearch = debounce((query) => {
  console.log("Searching for:", query);
  // API call here
}, 500);

searchInput.addEventListener("input", (e) => {
  performSearch(e.target.value);
});
// Only searches 500ms after user stops typing
```

### 5. Polling
```javascript
function pollServer(url, interval = 5000) {
  function fetchData() {
    fetch(url)
      .then(response => response.json())
      .then(data => {
        console.log("Fetched data:", data);
        processData(data);
      })
      .catch(error => {
        console.error("Fetch error:", error);
      });
  }
  
  fetchData();  // Fetch immediately
  return setInterval(fetchData, interval);
}

const pollingId = pollServer("/api/status", 10000);

// Stop polling when needed
// clearInterval(pollingId);
```

### 6. Animation
```javascript
function animateProgress(duration) {
  const progressBar = document.querySelector("#progress");
  let progress = 0;
  const increment = 100 / (duration / 10);
  
  const intervalId = setInterval(() => {
    progress += increment;
    progressBar.style.width = `${progress}%`;
    
    if (progress >= 100) {
      clearInterval(intervalId);
      console.log("Animation complete");
    }
  }, 10);
}

animateProgress(3000);  // Animate over 3 seconds
```

---

## Delayed Execution Patterns

### Chaining Timeouts
```javascript
setTimeout(() => {
  console.log("Step 1");
  
  setTimeout(() => {
    console.log("Step 2");
    
    setTimeout(() => {
      console.log("Step 3");
    }, 1000);
  }, 1000);
}, 1000);

// Output (1 second apart):
// "Step 1"
// "Step 2"
// "Step 3"
```

### Sequential Delays
```javascript
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function sequence() {
  console.log("Start");
  await delay(1000);
  console.log("After 1 second");
  await delay(1000);
  console.log("After 2 seconds");
  await delay(1000);
  console.log("After 3 seconds");
}

sequence();
```

---

## setInterval vs Recursive setTimeout

### setInterval (Fixed Intervals)
```javascript
setInterval(() => {
  console.log("Every 1 second");
}, 1000);

// Time: 0s -> 1s -> 2s -> 3s
// Doesn't wait for function to complete
```

### Recursive setTimeout (Guaranteed Delay)
```javascript
function repeatWithDelay() {
  console.log("Every 1 second (after completion)");
  
  setTimeout(repeatWithDelay, 1000);
}

repeatWithDelay();

// Waits for function to complete before scheduling next call
```

### When to Use Each
```javascript
// setInterval: Fixed interval regardless of execution time
setInterval(() => {
  // Quick operation
  updateClock();
}, 1000);

// setTimeout: Ensure delay between operations
function fetchData() {
  fetch("/api/data")
    .then(response => response.json())
    .then(data => {
      processData(data);
      // Wait 5 seconds AFTER completion
      setTimeout(fetchData, 5000);
    });
}
fetchData();
```

---

## Common Pitfalls

### 1. this Context
```javascript
class Timer {
  constructor() {
    this.count = 0;
  }
  
  start() {
    // ✗ 'this' will be undefined/window
    setInterval(this.increment, 1000);
    
    // ✓ Use arrow function
    setInterval(() => this.increment(), 1000);
    
    // ✓ Or bind
    setInterval(this.increment.bind(this), 1000);
  }
  
  increment() {
    this.count++;
    console.log(this.count);
  }
}
```

### 2. Memory Leaks
```javascript
// ✗ Bad: Interval never cleared
function startCounter() {
  let count = 0;
  setInterval(() => {
    count++;
    console.log(count);
  }, 1000);
  // Runs forever!
}

// ✓ Good: Store and clear
let intervalId;

function startCounter() {
  let count = 0;
  intervalId = setInterval(() => {
    count++;
    console.log(count);
  }, 1000);
}

function stopCounter() {
  clearInterval(intervalId);
}
```

### 3. Minimum Delay
```javascript
// Delay of 0 doesn't mean immediate
setTimeout(() => {
  console.log("Not immediate");
}, 0);

console.log("Runs first");

// Output:
// "Runs first"
// "Not immediate"
```

### 4. Nested Intervals
```javascript
// ✗ Bad: Creates multiple intervals
function bad() {
  setInterval(() => {
    setInterval(() => {
      console.log("Multiple intervals!");
    }, 1000);
  }, 1000);
  // Creates exponentially more intervals!
}

// ✓ Good: Use one interval
function good() {
  let count = 0;
  setInterval(() => {
    count++;
    if (count % 2 === 0) {
      console.log("Every 2 seconds");
    }
  }, 1000);
}
```

---

## Best Practices

1. **Always store timer IDs for clearing**
   ```javascript
   const timerId = setTimeout(...);
   const intervalId = setInterval(...);
   ```

2. **Clear timers when done**
   ```javascript
   clearTimeout(timerId);
   clearInterval(intervalId);
   ```

3. **Clear timers in cleanup (React/Vue)**
   ```javascript
   useEffect(() => {
     const id = setInterval(...);
     return () => clearInterval(id);  // Cleanup
   }, []);
   ```

4. **Use arrow functions to preserve context**
   ```javascript
   setInterval(() => this.method(), 1000);
   ```

5. **Prefer setTimeout for guaranteed delays**
   ```javascript
   function repeat() {
     doSomething();
     setTimeout(repeat, 1000);  // Waits for completion
   }
   ```

---

## Key Takeaways

- `setTimeout`: Execute once after delay
- `setInterval`: Execute repeatedly at intervals
- `clearTimeout`/`clearInterval`: Cancel timers
- Timers return IDs that can be used to cancel them
- Minimum delay is ~4ms in browsers
- `setTimeout(fn, 0)` defers execution but doesn't run immediately
- Always clear intervals to prevent memory leaks
- Use arrow functions or bind to preserve `this` context
- Recursive `setTimeout` ensures delay after completion
- `setInterval` may overlap if function takes longer than interval
