# Microtasks vs Macrotasks

JavaScript's event loop has two types of task queues: Microtasks and Macrotasks. Understanding the difference is crucial for predicting async execution order.

---

## Overview

### Macrotasks (Task Queue)
- setTimeout
- setInterval
- setImmediate (Node.js)
- I/O operations
- UI rendering

### Microtasks (Job Queue)
- Promise callbacks (.then, .catch, .finally)
- queueMicrotask()
- MutationObserver
- process.nextTick (Node.js)

---

## Execution Priority

**Microtasks always execute before macrotasks!**

```javascript
console.log("1: Sync");

setTimeout(() => {
  console.log("2: Macrotask (setTimeout)");
}, 0);

Promise.resolve().then(() => {
  console.log("3: Microtask (Promise)");
});

console.log("4: Sync");

// Output:
// "1: Sync"
// "4: Sync"
// "3: Microtask (Promise)"
// "2: Macrotask (setTimeout)"
```

---

## Event Loop Cycle

1. Execute all synchronous code
2. **Process ALL microtasks** (microtask queue)
3. Render UI (if needed)
4. Process **ONE macrotask** (macrotask queue)
5. Repeat from step 2

```javascript
console.log("Script start");

setTimeout(() => console.log("Timeout 1"), 0);
setTimeout(() => console.log("Timeout 2"), 0);

Promise.resolve()
  .then(() => console.log("Promise 1"))
  .then(() => console.log("Promise 2"));

console.log("Script end");

// Output:
// "Script start"
// "Script end"
// "Promise 1"
// "Promise 2"
// "Timeout 1"
// "Timeout 2"
```

---

## Microtask Queue

### Characteristics
- Higher priority than macrotasks
- All microtasks execute before next macrotask
- Can starve macrotask queue if new microtasks keep being added

### Promise Chains
```javascript
Promise.resolve()
  .then(() => {
    console.log("Then 1");
    return Promise.resolve();
  })
  .then(() => {
    console.log("Then 2");
  });

setTimeout(() => {
  console.log("Timeout");
}, 0);

console.log("Sync");

// Output:
// "Sync"
// "Then 1"
// "Then 2"
// "Timeout"
```

### queueMicrotask()
```javascript
console.log("Start");

queueMicrotask(() => {
  console.log("Microtask 1");
});

queueMicrotask(() => {
  console.log("Microtask 2");
});

setTimeout(() => {
  console.log("Timeout");
}, 0);

console.log("End");

// Output:
// "Start"
// "End"
// "Microtask 1"
// "Microtask 2"
// "Timeout"
```

---

## Macrotask Queue

### Characteristics
- Lower priority than microtasks
- Only one macrotask executes per cycle
- Gives browser chance to render between tasks

### Multiple setTimeout
```javascript
setTimeout(() => console.log("Timeout 1"), 0);
setTimeout(() => console.log("Timeout 2"), 0);
setTimeout(() => console.log("Timeout 3"), 0);

Promise.resolve().then(() => console.log("Promise"));

// Output:
// "Promise"
// "Timeout 1"
// "Timeout 2"
// "Timeout 3"
```

---

## Mixing Microtasks and Macrotasks

### Complex Example
```javascript
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
}, 0);

Promise.resolve()
  .then(() => {
    console.log("4");
    setTimeout(() => console.log("5"), 0);
  })
  .then(() => console.log("6"));

console.log("7");

// Step-by-step:
// 1. Sync: "1"
// 2. setTimeout queued (macrotask)
// 3. Promise queued (microtask)
// 4. Sync: "7"
// 5. Microtask: "4" (setTimeout queued inside)
// 6. Microtask: "6"
// 7. Macrotask: "2" (Promise queued inside)
// 8. Microtask: "3"
// 9. Macrotask: "5"

// Output:
// "1"
// "7"
// "4"
// "6"
// "2"
// "3"
// "5"
```

### Nested Promises and Timeouts
```javascript
setTimeout(() => {
  console.log("Timeout 1");
  
  Promise.resolve().then(() => {
    console.log("Promise in Timeout 1");
  });
}, 0);

Promise.resolve().then(() => {
  console.log("Promise 1");
  
  setTimeout(() => {
    console.log("Timeout in Promise 1");
  }, 0);
});

// Output:
// "Promise 1"
// "Timeout 1"
// "Promise in Timeout 1"
// "Timeout in Promise 1"
```

---

## Practical Examples

### 1. Microtask Starvation
```javascript
// ✗ Dangerous: Infinite microtasks block macrotasks
function infiniteMicrotasks() {
  Promise.resolve().then(() => {
    console.log("Microtask");
    infiniteMicrotasks();  // Creates new microtask
  });
}

infiniteMicrotasks();

setTimeout(() => {
  console.log("This will never run!");
}, 0);

// Macrotasks never execute because microtask queue never empties
```

### 2. Ensuring Execution Order
```javascript
function processData(data) {
  // Ensure this runs before any timers
  return Promise.resolve().then(() => {
    console.log("Processing:", data);
    return transformData(data);
  });
}

setTimeout(() => {
  console.log("Timer callback");
}, 0);

processData("Important data");

// "Processing: Important data" (microtask)
// "Timer callback" (macrotask)
```

### 3. Batching Updates
```javascript
class UIUpdater {
  constructor() {
    this.pendingUpdates = [];
    this.updateScheduled = false;
  }
  
  scheduleUpdate(update) {
    this.pendingUpdates.push(update);
    
    if (!this.updateScheduled) {
      this.updateScheduled = true;
      
      // Use microtask for immediate batching
      queueMicrotask(() => {
        this.flushUpdates();
      });
    }
  }
  
  flushUpdates() {
    console.log("Applying", this.pendingUpdates.length, "updates");
    this.pendingUpdates.forEach(update => this.applyUpdate(update));
    this.pendingUpdates = [];
    this.updateScheduled = false;
  }
  
  applyUpdate(update) {
    console.log("Update:", update);
  }
}

const updater = new UIUpdater();
updater.scheduleUpdate("A");
updater.scheduleUpdate("B");
updater.scheduleUpdate("C");

console.log("Scheduled all updates");

// Output:
// "Scheduled all updates"
// "Applying 3 updates"
// "Update: A"
// "Update: B"
// "Update: C"
```

---

## async/await and Microtasks

### await Creates Microtasks
```javascript
async function example() {
  console.log("1");
  
  await Promise.resolve();  // Microtask boundary
  
  console.log("2");
}

console.log("Start");
example();
console.log("End");

// Output:
// "Start"
// "1"
// "End"
// "2" (after microtask queue)
```

### Multiple awaits
```javascript
async function multipleAwaits() {
  console.log("1");
  await Promise.resolve();
  console.log("2");
  await Promise.resolve();
  console.log("3");
}

multipleAwaits();
console.log("4");

// Output:
// "1"
// "4"
// "2"
// "3"
```

---

## Rendering and Tasks

### Macrotasks Allow Rendering
```javascript
// UI can update between macrotasks
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(`Timeout ${i}`);
    updateUI();  // UI updates between each timeout
  }, 0);
}
```

### Microtasks Block Rendering
```javascript
// UI cannot update until all microtasks complete
Promise.resolve()
  .then(() => console.log("1"))
  .then(() => console.log("2"))
  .then(() => console.log("3"))
  .then(() => console.log("4"));
// No rendering until all done
```

---

## Node.js Specifics

### process.nextTick
```javascript
// process.nextTick has highest priority (Node.js only)
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

process.nextTick(() => console.log("nextTick"));

console.log("End");

// Output:
// "Start"
// "End"
// "nextTick" (highest priority)
// "Promise"
// "Timeout"
```

### setImmediate
```javascript
// setImmediate is a macrotask (Node.js only)
setTimeout(() => console.log("Timeout"), 0);
setImmediate(() => console.log("Immediate"));
Promise.resolve().then(() => console.log("Promise"));

// Output (may vary):
// "Promise"
// "Timeout" or "Immediate"
// "Immediate" or "Timeout"
```

---

## Common Patterns

### 1. Defer Until After Render
```javascript
// Use macrotask to allow rendering
function deferAfterRender(callback) {
  setTimeout(callback, 0);
}

deferAfterRender(() => {
  console.log("After render");
});
```

### 2. Immediate Execution (Higher Priority)
```javascript
// Use microtask for immediate execution
function immediate(callback) {
  Promise.resolve().then(callback);
  // or queueMicrotask(callback);
}

immediate(() => {
  console.log("Runs before setTimeout");
});
```

### 3. Break Long Tasks
```javascript
async function processLargeArray(array) {
  for (let i = 0; i < array.length; i += 100) {
    // Process chunk
    processChunk(array.slice(i, i + 100));
    
    // Yield to browser every 100 items
    await new Promise(resolve => setTimeout(resolve, 0));
  }
}
```

---

## Debugging Tips

### Visualizing Execution
```javascript
function log(msg, type) {
  console.log(`[${type}] ${msg}`);
}

log("Start", "SYNC");

setTimeout(() => log("Timeout 1", "MACRO"), 0);

Promise.resolve().then(() => log("Promise 1", "MICRO"));

setTimeout(() => {
  log("Timeout 2", "MACRO");
  Promise.resolve().then(() => log("Promise in Timeout", "MICRO"));
}, 0);

Promise.resolve().then(() => {
  log("Promise 2", "MICRO");
  setTimeout(() => log("Timeout in Promise", "MACRO"), 0);
});

log("End", "SYNC");
```

---

## Best Practices

1. **Use microtasks for critical operations**
   ```javascript
   Promise.resolve().then(() => {
     // Runs before any timers
   });
   ```

2. **Use macrotasks for deferring work**
   ```javascript
   setTimeout(() => {
     // Allows rendering between calls
   }, 0);
   ```

3. **Avoid microtask starvation**
   ```javascript
   // ✗ Bad
   function loop() {
     Promise.resolve().then(loop);
   }
   
   // ✓ Good
   function loop() {
     setTimeout(loop, 0);
   }
   ```

4. **Be aware of async/await microtasks**
   ```javascript
   async function example() {
     await something();  // Microtask boundary
     // Rest runs in next microtask
   }
   ```

---

## Key Takeaways

- **Microtasks** have higher priority than **macrotasks**
- ALL microtasks execute before the next macrotask
- Promises create microtasks
- setTimeout/setInterval create macrotasks
- Event loop processes all microtasks, then one macrotask, repeat
- Microtasks can block rendering if queue never empties
- Macrotasks allow browser to render between tasks
- `await` creates a microtask boundary
- Understanding this is crucial for predictable async behavior
- Use microtasks for immediate priority, macrotasks for deferred work
