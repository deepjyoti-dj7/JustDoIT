# ES2015 (ES6)

Major update to JavaScript with significant new features that modernized the language.

---

## Let and Const

Block-scoped variable declarations.

### let - Block Scope

```javascript
// var is function-scoped
if (true) {
  var x = 10;
}
console.log(x);  // 10 (accessible outside block)

// let is block-scoped
if (true) {
  let y = 10;
}
console.log(y);  // ReferenceError: y is not defined

// Temporal Dead Zone
console.log(z);  // ReferenceError (not hoisted)
let z = 5;
```

### const - Block Scope + Immutable Binding

```javascript
const PI = 3.14159;
PI = 3.14;  // TypeError: Assignment to constant variable

// const with objects - binding is immutable, not the value
const person = { name: 'John' };
person.name = 'Jane';  // OK - modifying property
person.age = 30;       // OK - adding property
person = {};           // TypeError - can't reassign

// const with arrays
const numbers = [1, 2, 3];
numbers.push(4);       // OK - modifying array
numbers = [];          // TypeError - can't reassign

// Best practice: Use const by default
const config = { api: 'url' };
const users = [];
```

---

## Arrow Functions

Concise function syntax with lexical `this` binding.

### Syntax

```javascript
// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b;

// Single parameter - no parentheses needed
const square = x => x * x;

// No parameters - parentheses required
const getRandom = () => Math.random();

// Multiple statements - use block
const greet = name => {
  const message = `Hello, ${name}!`;
  return message;
};

// Return object literal - wrap in parentheses
const createPerson = (name, age) => ({ name, age });
```

### Lexical this

```javascript
// Traditional function - dynamic this
function Timer() {
  this.seconds = 0;
  
  setInterval(function() {
    this.seconds++;  // 'this' is window, not Timer!
    console.log(this.seconds);  // NaN
  }, 1000);
}

// Arrow function - lexical this
function Timer() {
  this.seconds = 0;
  
  setInterval(() => {
    this.seconds++;  // 'this' is Timer instance
    console.log(this.seconds);  // 1, 2, 3...
  }, 1000);
}

// Practical example
const person = {
  name: 'John',
  hobbies: ['reading', 'coding'],
  
  // Arrow function inherits 'this' from parent scope
  showHobbies() {
    this.hobbies.forEach(hobby => {
      console.log(`${this.name} likes ${hobby}`);
      // 'this' refers to person object
    });
  }
};

person.showHobbies();
// John likes reading
// John likes coding
```

### When NOT to Use Arrow Functions

```javascript
// Don't use as methods
const person = {
  name: 'John',
  greet: () => {
    console.log(`Hello, ${this.name}`);  // 'this' is undefined/window
  }
};

// Don't use as constructors
const Person = (name) => {
  this.name = name;
};
new Person('John');  // TypeError: Person is not a constructor

// Don't use when you need 'arguments'
const sum = () => {
  console.log(arguments);  // ReferenceError
};

// Use regular function instead
function sum() {
  return Array.from(arguments).reduce((a, b) => a + b);
}
```

---

## Template Literals

String interpolation and multi-line strings.

### String Interpolation

```javascript
// Old way
const name = 'John';
const age = 30;
const message = 'My name is ' + name + ' and I am ' + age + ' years old.';

// Template literals
const message = `My name is ${name} and I am ${age} years old.`;

// Expressions
const total = `Total: ${5 + 3}`;  // 'Total: 8'
const status = `User is ${age >= 18 ? 'adult' : 'minor'}`;

// Function calls
const greeting = `Hello, ${getName().toUpperCase()}!`;
```

### Multi-line Strings

```javascript
// Old way
const html = '<div>\n' +
             '  <h1>Title</h1>\n' +
             '  <p>Content</p>\n' +
             '</div>';

// Template literals
const html = `
  <div>
    <h1>Title</h1>
    <p>Content</p>
  </div>
`;
```

### Tagged Templates

```javascript
function highlight(strings, ...values) {
  return strings.reduce((result, str, i) => {
    const value = values[i] ? `<strong>${values[i]}</strong>` : '';
    return result + str + value;
  }, '');
}

const name = 'John';
const age = 30;
const message = highlight`My name is ${name} and I am ${age} years old.`;
// My name is <strong>John</strong> and I am <strong>30</strong> years old.

// SQL query builder
function sql(strings, ...values) {
  return {
    text: strings.join('?'),
    values: values
  };
}

const userId = 123;
const query = sql`SELECT * FROM users WHERE id = ${userId}`;
// { text: 'SELECT * FROM users WHERE id = ?', values: [123] }
```

---

## Destructuring

Extract values from arrays or objects into variables.

### Array Destructuring

```javascript
// Basic
const [a, b] = [1, 2];
console.log(a, b);  // 1 2

// Skip elements
const [first, , third] = [1, 2, 3];
console.log(first, third);  // 1 3

// Rest operator
const [head, ...tail] = [1, 2, 3, 4];
console.log(head);  // 1
console.log(tail);  // [2, 3, 4]

// Default values
const [x = 0, y = 0] = [10];
console.log(x, y);  // 10 0

// Swapping variables
let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b);  // 2 1

// Function return values
function getCoords() {
  return [10, 20];
}
const [x, y] = getCoords();
```

### Object Destructuring

```javascript
// Basic
const person = { name: 'John', age: 30 };
const { name, age } = person;
console.log(name, age);  // 'John' 30

// Rename variables
const { name: fullName, age: years } = person;
console.log(fullName, years);  // 'John' 30

// Default values
const { name, age, city = 'Unknown' } = person;
console.log(city);  // 'Unknown'

// Nested destructuring
const user = {
  id: 1,
  profile: {
    name: 'John',
    address: {
      city: 'NYC',
      zip: '10001'
    }
  }
};

const {
  profile: {
    name,
    address: { city, zip }
  }
} = user;

console.log(name, city, zip);  // 'John' 'NYC' '10001'

// Rest operator
const { name, ...rest } = person;
console.log(rest);  // { age: 30 }

// Function parameters
function greet({ name, age }) {
  console.log(`${name} is ${age} years old`);
}

greet(person);  // 'John is 30 years old'
```

---

## Default Parameters

Default values for function parameters.

```javascript
// Old way
function greet(name) {
  name = name || 'Guest';
  console.log(`Hello, ${name}!`);
}

// ES6 way
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}

greet();        // 'Hello, Guest!'
greet('John');  // 'Hello, John!'

// With multiple parameters
function createUser(name, age = 18, role = 'user') {
  return { name, age, role };
}

createUser('John');                    // { name: 'John', age: 18, role: 'user' }
createUser('Jane', 25);                // { name: 'Jane', age: 25, role: 'user' }
createUser('Admin', 30, 'admin');      // { name: 'Admin', age: 30, role: 'admin' }

// Default value can be expression
function getDefaultName() {
  return 'Guest';
}

function greet(name = getDefaultName()) {
  console.log(`Hello, ${name}!`);
}

// Using previous parameters
function createRange(start, end = start + 10) {
  return { start, end };
}

createRange(5);  // { start: 5, end: 15 }

// Destructuring with defaults
function configure({ host = 'localhost', port = 8080 } = {}) {
  console.log(`${host}:${port}`);
}

configure();                      // 'localhost:8080'
configure({ host: 'example.com' }); // 'example.com:8080'
```

---

## Rest and Spread Operators

### Rest Operator (...)

Collect remaining elements into an array.

```javascript
// Function parameters
function sum(...numbers) {
  return numbers.reduce((total, n) => total + n, 0);
}

sum(1, 2, 3, 4, 5);  // 15

// Must be last parameter
function logAll(first, second, ...rest) {
  console.log(first);   // 1
  console.log(second);  // 2
  console.log(rest);    // [3, 4, 5]
}

logAll(1, 2, 3, 4, 5);

// Array destructuring
const [first, ...rest] = [1, 2, 3, 4];
console.log(first);  // 1
console.log(rest);   // [2, 3, 4]

// Object destructuring
const { name, ...details } = { name: 'John', age: 30, city: 'NYC' };
console.log(name);     // 'John'
console.log(details);  // { age: 30, city: 'NYC' }
```

### Spread Operator (...)

Expand iterable into individual elements.

```javascript
// Array spread
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Copy array
const original = [1, 2, 3];
const copy = [...original];

// Array concatenation
const merged = [...arr1, 0, ...arr2];
console.log(merged);  // [1, 2, 3, 0, 4, 5, 6]

// Object spread
const person = { name: 'John', age: 30 };
const employee = { ...person, role: 'developer' };
console.log(employee);  // { name: 'John', age: 30, role: 'developer' }

// Copy object
const copy = { ...person };

// Override properties
const updated = { ...person, age: 31 };
console.log(updated);  // { name: 'John', age: 31 }

// Function arguments
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
console.log(sum(...numbers));  // 6

// Math operations
const nums = [5, 1, 9, 3];
console.log(Math.max(...nums));  // 9
console.log(Math.min(...nums));  // 1
```

---

## Enhanced Object Literals

Shorthand syntax for object properties and methods.

### Property Shorthand

```javascript
const name = 'John';
const age = 30;

// Old way
const person = {
  name: name,
  age: age
};

// ES6 shorthand
const person = { name, age };
```

### Method Shorthand

```javascript
// Old way
const person = {
  name: 'John',
  greet: function() {
    console.log(`Hello, ${this.name}`);
  }
};

// ES6 shorthand
const person = {
  name: 'John',
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};
```

### Computed Property Names

```javascript
const propName = 'age';

const person = {
  name: 'John',
  [propName]: 30,
  [`is${capitalize('adult')}`]: true
};

console.log(person);  // { name: 'John', age: 30, isAdult: true }

// Dynamic methods
const prefix = 'get';

const obj = {
  [`${prefix}Name`]() {
    return this.name;
  },
  [`${prefix}Age`]() {
    return this.age;
  }
};
```

---

## Classes

Syntactic sugar over prototype-based inheritance.

### Basic Class

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, I'm ${this.name}`);
  }
  
  isAdult() {
    return this.age >= 18;
  }
}

const person = new Person('John', 30);
person.greet();  // "Hello, I'm John"
```

### Inheritance

```javascript
class Employee extends Person {
  constructor(name, age, role) {
    super(name, age);  // Call parent constructor
    this.role = role;
  }
  
  greet() {
    super.greet();  // Call parent method
    console.log(`I work as a ${this.role}`);
  }
}

const emp = new Employee('Jane', 25, 'developer');
emp.greet();
// "Hello, I'm Jane"
// "I work as a developer"
```

### Static Methods

```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }
  
  static PI = 3.14159;
}

console.log(MathUtils.add(5, 3));  // 8
console.log(MathUtils.PI);         // 3.14159
```

### Getters and Setters

```javascript
class Circle {
  constructor(radius) {
    this._radius = radius;
  }
  
  get radius() {
    return this._radius;
  }
  
  set radius(value) {
    if (value < 0) {
      throw new Error('Radius must be positive');
    }
    this._radius = value;
  }
  
  get area() {
    return Math.PI * this._radius ** 2;
  }
}

const circle = new Circle(5);
console.log(circle.radius);  // 5
console.log(circle.area);    // 78.54

circle.radius = 10;
console.log(circle.area);    // 314.16
```

---

## Promises

Handle asynchronous operations.

### Basic Promise

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    
    if (success) {
      resolve('Operation successful');
    } else {
      reject('Operation failed');
    }
  }, 1000);
});

promise
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

### Promise Chaining

```javascript
fetch('/api/user')
  .then(response => response.json())
  .then(user => fetch(`/api/posts/${user.id}`))
  .then(response => response.json())
  .then(posts => console.log(posts))
  .catch(error => console.error(error));
```

### Promise Methods

```javascript
// Promise.all - wait for all
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise(resolve => setTimeout(() => resolve('done'), 100));

Promise.all([promise1, promise2, promise3])
  .then(values => console.log(values));  // [3, 42, 'done']

// Promise.race - first to complete
Promise.race([promise1, promise3])
  .then(value => console.log(value));  // 3
```

---

## Modules

Import and export functionality between files.

### Named Exports

```javascript
// math.js
export const PI = 3.14159;

export function add(a, b) {
  return a + b;
}

export function multiply(a, b) {
  return a * b;
}

// Or export all at once
const PI = 3.14159;
function add(a, b) { return a + b; }
function multiply(a, b) { return a * b; }

export { PI, add, multiply };
```

### Named Imports

```javascript
// app.js
import { PI, add, multiply } from './math.js';

console.log(PI);           // 3.14159
console.log(add(2, 3));    // 5

// Rename on import
import { add as sum } from './math.js';

// Import all
import * as Math from './math.js';
console.log(Math.PI);
console.log(Math.add(2, 3));
```

### Default Exports

```javascript
// person.js
export default class Person {
  constructor(name) {
    this.name = name;
  }
}

// Or
class Person {
  constructor(name) {
    this.name = name;
  }
}

export default Person;
```

### Default Imports

```javascript
// app.js
import Person from './person.js';

const person = new Person('John');

// Can rename default import
import MyPerson from './person.js';
```

### Mixed Exports

```javascript
// utils.js
export default function main() {
  console.log('Main function');
}

export const helper = () => console.log('Helper');
export const VERSION = '1.0.0';

// app.js
import main, { helper, VERSION } from './utils.js';
```

---

## Symbols

Unique and immutable primitive values.

```javascript
// Create unique symbol
const sym1 = Symbol();
const sym2 = Symbol();

console.log(sym1 === sym2);  // false

// With description
const sym = Symbol('my symbol');
console.log(sym.description);  // 'my symbol'

// As object property keys
const SECRET = Symbol('secret');

const obj = {
  public: 'visible',
  [SECRET]: 'hidden'
};

console.log(obj.public);    // 'visible'
console.log(obj[SECRET]);   // 'hidden'
console.log(Object.keys(obj));  // ['public'] - symbol not enumerable

// Well-known symbols
const obj = {
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        value: i++,
        done: i > 3
      })
    };
  }
};

for (const val of obj) {
  console.log(val);  // 0, 1, 2
}
```

---

## Iterators and Generators

### Iterators

```javascript
const iterable = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    const data = this.data;
    
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const value of iterable) {
  console.log(value);  // 1, 2, 3
}
```

### Generators

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next());  // { value: 1, done: false }
console.log(gen.next());  // { value: 2, done: false }
console.log(gen.next());  // { value: 3, done: false }
console.log(gen.next());  // { value: undefined, done: true }

// Using in for...of
for (const num of numberGenerator()) {
  console.log(num);  // 1, 2, 3
}

// Infinite sequence
function* fibonacci() {
  let [a, b] = [0, 1];
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacci();
console.log(fib.next().value);  // 0
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 1
console.log(fib.next().value);  // 2
```

---

## Map and Set

### Map

```javascript
const map = new Map();

// Set values
map.set('name', 'John');
map.set('age', 30);
map.set(true, 'boolean key');

// Get values
console.log(map.get('name'));  // 'John'

// Check existence
console.log(map.has('age'));  // true

// Size
console.log(map.size);  // 3

// Delete
map.delete('age');

// Iterate
for (const [key, value] of map) {
  console.log(`${key}: ${value}`);
}

// Clear
map.clear();
```

### Set

```javascript
const set = new Set();

// Add values
set.add(1);
set.add(2);
set.add(2);  // Duplicate ignored

console.log(set.size);  // 2

// Check existence
console.log(set.has(1));  // true

// Delete
set.delete(2);

// Iterate
for (const value of set) {
  console.log(value);
}

// Array to Set (remove duplicates)
const arr = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(arr)];
console.log(unique);  // [1, 2, 3]
```

---

## Key Takeaways

- **let/const**: Block-scoped variables, prefer const
- **Arrow functions**: Concise syntax, lexical this
- **Template literals**: String interpolation, multi-line strings
- **Destructuring**: Extract values from arrays/objects
- **Default parameters**: Function parameter defaults
- **Rest/Spread**: Collect/expand elements
- **Object literals**: Property/method shorthand, computed names
- **Classes**: Syntactic sugar for prototypes
- **Promises**: Handle async operations
- **Modules**: Import/export between files
- **Symbols**: Unique property keys
- **Generators**: Pausable functions
- **Map/Set**: New collection types
