# ES2016-ES2017

New features introduced in ECMAScript 2016 and 2017.

---

## ES2016 Features

### Array.prototype.includes()

Check if an array contains a value.

```javascript
// Old way
const numbers = [1, 2, 3, 4, 5];

console.log(numbers.indexOf(3) !== -1);  // true
console.log(numbers.indexOf(6) !== -1);  // false

// ES2016 way
console.log(numbers.includes(3));  // true
console.log(numbers.includes(6));  // false

// With start index
console.log(numbers.includes(3, 3));  // false (start from index 3)

// Works with NaN
const values = [1, 2, NaN, 4];
console.log(values.indexOf(NaN));     // -1 (indexOf can't find NaN)
console.log(values.includes(NaN));    // true (includes can find NaN)

// Case sensitive for strings
const fruits = ['apple', 'banana', 'orange'];
console.log(fruits.includes('Apple'));   // false
console.log(fruits.includes('banana'));  // true

// Practical examples
function validateInput(value, allowedValues) {
  if (!allowedValues.includes(value)) {
    throw new Error(`Invalid value: ${value}`);
  }
  return true;
}

const roles = ['admin', 'user', 'guest'];
validateInput('admin', roles);  // OK
// validateInput('superadmin', roles);  // Error

// Filter with includes
const validUsers = users.filter(user => 
  ['active', 'pending'].includes(user.status)
);
```

### Exponentiation Operator (**)

Mathematical exponentiation.

```javascript
// Old way
console.log(Math.pow(2, 3));  // 8

// ES2016 way
console.log(2 ** 3);  // 8

// More examples
console.log(5 ** 2);   // 25
console.log(10 ** 3);  // 1000
console.log(2 ** 10);  // 1024

// Negative exponents
console.log(2 ** -1);  // 0.5
console.log(10 ** -2); // 0.01

// Fractional exponents (roots)
console.log(9 ** 0.5);   // 3 (square root)
console.log(27 ** (1/3)); // 3 (cube root)

// Assignment operator
let num = 2;
num **= 3;
console.log(num);  // 8

// Precedence - right to left
console.log(2 ** 3 ** 2);  // 512 (2 ** (3 ** 2) = 2 ** 9)

// Practical examples
function calculateCompoundInterest(principal, rate, years) {
  return principal * (1 + rate) ** years;
}

console.log(calculateCompoundInterest(1000, 0.05, 10));  // 1628.89

function distance(x1, y1, x2, y2) {
  return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
}

console.log(distance(0, 0, 3, 4));  // 5
```

---

## ES2017 Features

### Object.values()

Get array of object's own property values.

```javascript
const person = {
  name: 'John',
  age: 30,
  city: 'NYC'
};

console.log(Object.values(person));
// ['John', 30, 'NYC']

// Compare with Object.keys()
console.log(Object.keys(person));
// ['name', 'age', 'city']

// Iteration
Object.values(person).forEach(value => {
  console.log(value);
});

// With arrays (returns array values by index)
const arr = ['a', 'b', 'c'];
console.log(Object.values(arr));  // ['a', 'b', 'c']

// Practical examples
const scores = {
  math: 85,
  english: 90,
  science: 88
};

const average = Object.values(scores).reduce((sum, score) => sum + score, 0) 
                / Object.values(scores).length;
console.log(average);  // 87.67

// Count occurrences
const inventory = {
  apples: 50,
  oranges: 30,
  bananas: 45
};

const totalItems = Object.values(inventory).reduce((sum, qty) => sum + qty, 0);
console.log(totalItems);  // 125

// Filter values
const settings = {
  notifications: true,
  darkMode: false,
  autoSave: true
};

const enabledCount = Object.values(settings).filter(Boolean).length;
console.log(enabledCount);  // 2
```

### Object.entries()

Get array of object's own [key, value] pairs.

```javascript
const person = {
  name: 'John',
  age: 30,
  city: 'NYC'
};

console.log(Object.entries(person));
// [['name', 'John'], ['age', 30], ['city', 'NYC']]

// Convert to Map
const map = new Map(Object.entries(person));
console.log(map.get('name'));  // 'John'

// Destructuring in loop
for (const [key, value] of Object.entries(person)) {
  console.log(`${key}: ${value}`);
}
// name: John
// age: 30
// city: NYC

// Filter entries
const filtered = Object.entries(person)
  .filter(([key, value]) => typeof value === 'number')
  .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});
console.log(filtered);  // { age: 30 }

// Transform object
const scores = { math: 85, english: 90, science: 88 };

const graded = Object.entries(scores)
  .map(([subject, score]) => [subject, score >= 90 ? 'A' : 'B'])
  .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});

console.log(graded);  // { math: 'B', english: 'A', science: 'B' }

// Swap keys and values
const original = { a: 1, b: 2, c: 3 };

const swapped = Object.entries(original)
  .reduce((obj, [key, value]) => ({ ...obj, [value]: key }), {});

console.log(swapped);  // { 1: 'a', 2: 'b', 3: 'c' }

// Sort object by values
const unsorted = { apple: 5, banana: 2, cherry: 8 };

const sorted = Object.entries(unsorted)
  .sort(([, a], [, b]) => b - a)
  .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});

console.log(sorted);  // { cherry: 8, apple: 5, banana: 2 }
```

### Object.getOwnPropertyDescriptors()

Get all own property descriptors of an object.

```javascript
const obj = {
  name: 'John',
  age: 30
};

console.log(Object.getOwnPropertyDescriptors(obj));
/*
{
  name: {
    value: 'John',
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: true,
    enumerable: true,
    configurable: true
  }
}
*/

// Copy with getters/setters
const source = {
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
};

// Shallow copy loses getter
const copy1 = { ...source };
console.log(copy1.fullName);  // undefined

// Proper copy with descriptors
const copy2 = Object.defineProperties(
  {},
  Object.getOwnPropertyDescriptors(source)
);
// Getter preserved

// Clone with all properties
function clone(obj) {
  return Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj)
  );
}
```

### String Padding

Pad strings to a certain length.

#### String.prototype.padStart()

```javascript
// Basic usage
'5'.padStart(3, '0');      // '005'
'hello'.padStart(10);      // '     hello' (default is space)
'abc'.padStart(10, '123'); // '1231231abc'

// Practical examples
// Format numbers
const orderNumber = '42';
console.log(orderNumber.padStart(6, '0'));  // '000042'

// Align text
const items = ['apple', 'banana', 'cherry'];
items.forEach(item => {
  console.log(item.padStart(10) + ' - in stock');
});
/*
     apple - in stock
    banana - in stock
    cherry - in stock
*/

// Credit card masking
function maskCard(cardNumber) {
  const last4 = cardNumber.slice(-4);
  return last4.padStart(cardNumber.length, '*');
}

console.log(maskCard('1234567890123456'));  // '************3456'

// Time formatting
function formatTime(hours, minutes) {
  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}

console.log(formatTime(9, 5));   // '09:05'
console.log(formatTime(14, 30)); // '14:30'

// Binary representation
const num = 5;
console.log(num.toString(2).padStart(8, '0'));  // '00000101'
```

#### String.prototype.padEnd()

```javascript
// Basic usage
'5'.padEnd(3, '0');      // '500'
'hello'.padEnd(10);      // 'hello     '
'abc'.padEnd(10, '123'); // 'abc1231231'

// Practical examples
// Align columns
const data = [
  ['Name', 'Age', 'City'],
  ['John', '30', 'NYC'],
  ['Jane', '25', 'LA']
];

data.forEach(row => {
  console.log(
    row[0].padEnd(10) + 
    row[1].padEnd(5) + 
    row[2]
  );
});
/*
Name      Age  City
John      30   NYC
Jane      25   LA
*/

// Progress bar
function progressBar(percent, width = 20) {
  const filled = Math.floor(width * percent / 100);
  return '█'.repeat(filled).padEnd(width, '░') + ` ${percent}%`;
}

console.log(progressBar(0));    // '░░░░░░░░░░░░░░░░░░░░ 0%'
console.log(progressBar(50));   // '██████████░░░░░░░░░░ 50%'
console.log(progressBar(100));  // '████████████████████ 100%'

// Format file listing
const files = [
  { name: 'index.js', size: 1234 },
  { name: 'config.json', size: 567 },
  { name: 'README.md', size: 89 }
];

files.forEach(({ name, size }) => {
  console.log(`${name.padEnd(15)} ${size.toString().padStart(6)} bytes`);
});
/*
index.js           1234 bytes
config.json         567 bytes
README.md            89 bytes
*/
```

### Async/Await

Syntactic sugar for Promises.

#### async Function

```javascript
// Returns a Promise
async function fetchUser() {
  return { id: 1, name: 'John' };
}

fetchUser().then(user => console.log(user));
// { id: 1, name: 'John' }

// Equivalent to
function fetchUser() {
  return Promise.resolve({ id: 1, name: 'John' });
}
```

#### await Keyword

```javascript
async function getUser() {
  const response = await fetch('/api/user');
  const user = await response.json();
  return user;
}

// Error handling with try/catch
async function getUser() {
  try {
    const response = await fetch('/api/user');
    const user = await response.json();
    return user;
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw error;
  }
}

// Sequential vs Parallel
// Sequential (slower)
async function sequential() {
  const user = await fetchUser();      // Wait 1s
  const posts = await fetchPosts();    // Wait 1s
  return { user, posts };               // Total: 2s
}

// Parallel (faster)
async function parallel() {
  const [user, posts] = await Promise.all([
    fetchUser(),    // Start both
    fetchPosts()    // at same time
  ]);
  return { user, posts };  // Total: 1s
}

// Practical examples
async function loadData() {
  try {
    // Fetch data
    const response = await fetch('/api/data');
    
    // Check response
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Parse JSON
    const data = await response.json();
    
    // Process data
    const processed = data.map(item => ({
      ...item,
      timestamp: new Date(item.timestamp)
    }));
    
    return processed;
  } catch (error) {
    console.error('Error loading data:', error);
    return [];
  }
}

// Multiple async operations
async function getUserWithPosts(userId) {
  const user = await fetchUser(userId);
  const posts = await fetchUserPosts(user.id);
  const comments = await Promise.all(
    posts.map(post => fetchComments(post.id))
  );
  
  return {
    user,
    posts: posts.map((post, i) => ({
      ...post,
      comments: comments[i]
    }))
  };
}

// Loop with await
async function processItems(items) {
  const results = [];
  
  for (const item of items) {
    const result = await processItem(item);  // Sequential
    results.push(result);
  }
  
  return results;
}

// Or parallel processing
async function processItems(items) {
  return await Promise.all(items.map(item => processItem(item)));
}
```

#### Top-level await (ES2022, but conceptually related)

```javascript
// In modules, can await at top level
const response = await fetch('/api/config');
const config = await response.json();

export default config;
```

### Trailing Commas in Function Parameters

```javascript
// Allowed in ES2017
function foo(
  param1,
  param2,  // trailing comma
) {
  // function body
}

foo(
  'arg1',
  'arg2',  // trailing comma
);

// Useful for version control
const obj = {
  a: 1,
  b: 2,
  c: 3,  // Easy to add/remove lines
};
```

### Shared Memory and Atomics

Low-level primitives for concurrent programming (advanced).

```javascript
// SharedArrayBuffer for shared memory
const buffer = new SharedArrayBuffer(1024);

// Atomics for thread-safe operations
const arr = new Int32Array(buffer);

Atomics.add(arr, 0, 5);   // Atomic add
Atomics.sub(arr, 0, 2);   // Atomic subtract
Atomics.load(arr, 0);     // Atomic read
Atomics.store(arr, 0, 10); // Atomic write

// Used with Web Workers for concurrent programming
```

---

## Practical Examples

### Async API Client

```javascript
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }
  
  async get(endpoint) {
    return this.request(endpoint);
  }
  
  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}

const api = new APIClient('https://api.example.com');

async function loadUser(id) {
  const user = await api.get(`/users/${id}`);
  return user;
}
```

### Data Processing Pipeline

```javascript
async function processData(items) {
  // Filter valid items
  const valid = items.filter(item => item.id && item.value);
  
  // Process in parallel
  const processed = await Promise.all(
    valid.map(async item => {
      const enriched = await enrichData(item);
      const validated = await validate(enriched);
      return validated;
    })
  );
  
  // Aggregate results
  const summary = Object.entries(
    processed.reduce((acc, item) => {
      acc[item.category] = (acc[item.category] || 0) + 1;
      return acc;
    }, {})
  ).map(([category, count]) => ({ category, count }));
  
  return { processed, summary };
}
```

---

## Key Takeaways

### ES2016
- **Array.includes()**: Check array membership, handles NaN
- **Exponentiation (\*\*)**: Cleaner syntax for Math.pow()

### ES2017
- **Object.values()**: Get array of object values
- **Object.entries()**: Get array of [key, value] pairs
- **Object.getOwnPropertyDescriptors()**: Clone with getters/setters
- **String padding**: padStart() and padEnd() for formatting
- **async/await**: Cleaner syntax for Promises
- **Trailing commas**: Allowed in function parameters
- Use async/await over Promise chains
- Combine with Promise.all() for parallel operations
- Always handle errors with try/catch
- Object.entries() great for transforming objects
