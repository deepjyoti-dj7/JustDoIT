# ES2024

Latest features introduced in ECMAScript 2024.

---

## Promise.withResolvers()

Create a promise with externally accessible resolve/reject functions.

### Basic Usage

```javascript
// Old way - awkward pattern
let resolve, reject;
const promise = new Promise((res, rej) => {
  resolve = res;
  reject = rej;
});

// Later, from anywhere
resolve('Success');

// ES2024 - Promise.withResolvers()
const { promise, resolve, reject } = Promise.withResolvers();

// Later, from anywhere
resolve('Success');

console.log(await promise);  // 'Success'
```

### Practical Examples

#### Deferred Promise

```javascript
class Deferred {
  constructor() {
    const { promise, resolve, reject } = Promise.withResolvers();
    this.promise = promise;
    this.resolve = resolve;
    this.reject = reject;
  }
}

const deferred = new Deferred();

// Resolve from elsewhere
setTimeout(() => {
  deferred.resolve('Done');
}, 1000);

await deferred.promise;  // 'Done'
```

#### Event-Based Resolution

```javascript
function waitForEvent(element, eventName) {
  const { promise, resolve } = Promise.withResolvers();
  
  element.addEventListener(eventName, resolve, { once: true });
  
  return promise;
}

const button = document.querySelector('#myButton');
await waitForEvent(button, 'click');
console.log('Button was clicked');
```

#### Manual Control Flow

```javascript
class Queue {
  #queue = [];
  #processing = false;
  #current = null;
  
  async enqueue(task) {
    const { promise, resolve, reject } = Promise.withResolvers();
    
    this.#queue.push({
      task,
      resolve,
      reject
    });
    
    this.#process();
    return promise;
  }
  
  async #process() {
    if (this.#processing || this.#queue.length === 0) return;
    
    this.#processing = true;
    this.#current = this.#queue.shift();
    
    try {
      const result = await this.#current.task();
      this.#current.resolve(result);
    } catch (error) {
      this.#current.reject(error);
    } finally {
      this.#processing = false;
      this.#process();
    }
  }
}

const queue = new Queue();

const result = await queue.enqueue(async () => {
  // Long running task
  await delay(1000);
  return 'Complete';
});

console.log(result);  // 'Complete'
```

#### Timeout Pattern

```javascript
function withTimeout(promise, ms) {
  const { promise: timeoutPromise, reject } = Promise.withResolvers();
  
  const timeout = setTimeout(() => {
    reject(new Error(`Timeout after ${ms}ms`));
  }, ms);
  
  return Promise.race([
    promise.finally(() => clearTimeout(timeout)),
    timeoutPromise
  ]);
}

// Usage
try {
  const result = await withTimeout(
    fetch('/api/data'),
    5000
  );
} catch (error) {
  console.error('Request timed out or failed');
}
```

#### Polling with Cancellation

```javascript
class Poll {
  #stopped = false;
  #deferred = null;
  
  start(fn, interval) {
    const { promise, resolve, reject } = Promise.withResolvers();
    this.#deferred = { resolve, reject };
    
    const poll = async () => {
      if (this.#stopped) return;
      
      try {
        const result = await fn();
        if (result) {
          this.#deferred.resolve(result);
          return;
        }
      } catch (error) {
        this.#deferred.reject(error);
        return;
      }
      
      setTimeout(poll, interval);
    };
    
    poll();
    return promise;
  }
  
  stop() {
    this.#stopped = true;
    this.#deferred?.reject(new Error('Polling stopped'));
  }
}

const poll = new Poll();

const result = await poll.start(
  async () => {
    const response = await fetch('/api/status');
    const data = await response.json();
    return data.ready ? data : null;
  },
  1000
);

// Later: poll.stop();
```

---

## Object.groupBy()

Group array elements by a key function.

### Basic Usage

```javascript
const users = [
  { name: 'John', role: 'admin' },
  { name: 'Jane', role: 'user' },
  { name: 'Bob', role: 'admin' },
  { name: 'Alice', role: 'user' }
];

// Old way
const grouped = users.reduce((acc, user) => {
  const key = user.role;
  if (!acc[key]) acc[key] = [];
  acc[key].push(user);
  return acc;
}, {});

// ES2024 - Object.groupBy()
const grouped = Object.groupBy(users, user => user.role);

console.log(grouped);
/*
{
  admin: [
    { name: 'John', role: 'admin' },
    { name: 'Bob', role: 'admin' }
  ],
  user: [
    { name: 'Jane', role: 'user' },
    { name: 'Alice', role: 'user' }
  ]
}
*/
```

### Practical Examples

#### Group by Property

```javascript
const products = [
  { id: 1, name: 'Laptop', category: 'Electronics' },
  { id: 2, name: 'Shirt', category: 'Clothing' },
  { id: 3, name: 'Phone', category: 'Electronics' },
  { id: 4, name: 'Pants', category: 'Clothing' }
];

const byCategory = Object.groupBy(products, p => p.category);

console.log(byCategory.Electronics);  // [Laptop, Phone]
console.log(byCategory.Clothing);     // [Shirt, Pants]
```

#### Group by Computed Value

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const evenOdd = Object.groupBy(numbers, n => 
  n % 2 === 0 ? 'even' : 'odd'
);

console.log(evenOdd.even);  // [2, 4, 6, 8, 10]
console.log(evenOdd.odd);   // [1, 3, 5, 7, 9]
```

#### Group by Range

```javascript
const ages = [15, 22, 35, 47, 18, 55, 28, 65];

const ageGroups = Object.groupBy(ages, age => {
  if (age < 18) return 'minor';
  if (age < 30) return 'young';
  if (age < 60) return 'adult';
  return 'senior';
});

console.log(ageGroups.young);  // [22, 18, 28]
console.log(ageGroups.adult);  // [35, 47, 55]
```

#### Group by Multiple Criteria

```javascript
const students = [
  { name: 'John', grade: 85, passed: true },
  { name: 'Jane', grade: 92, passed: true },
  { name: 'Bob', grade: 58, passed: false },
  { name: 'Alice', grade: 76, passed: true }
];

const byStatus = Object.groupBy(students, s => 
  s.passed ? 'passed' : 'failed'
);

const byGrade = Object.groupBy(students, s => {
  if (s.grade >= 90) return 'A';
  if (s.grade >= 80) return 'B';
  if (s.grade >= 70) return 'C';
  return 'F';
});

console.log(byGrade.A);  // [Jane]
console.log(byGrade.B);  // [John]
console.log(byGrade.C);  // [Alice]
console.log(byGrade.F);  // [Bob]
```

#### Group by Date

```javascript
const events = [
  { title: 'Meeting', date: '2024-01-15' },
  { title: 'Call', date: '2024-01-15' },
  { title: 'Review', date: '2024-01-16' },
  { title: 'Presentation', date: '2024-01-16' }
];

const byDate = Object.groupBy(events, e => e.date);

console.log(byDate['2024-01-15']);  // [Meeting, Call]
console.log(byDate['2024-01-16']);  // [Review, Presentation]
```

---

## Map.groupBy()

Group into a Map instead of an object.

### Basic Usage

```javascript
const users = [
  { name: 'John', role: 'admin' },
  { name: 'Jane', role: 'user' },
  { name: 'Bob', role: 'admin' }
];

// Returns Map
const grouped = Map.groupBy(users, user => user.role);

console.log(grouped.get('admin'));  // [John, Bob]
console.log(grouped.get('user'));   // [Jane]

// Iterate
for (const [role, users] of grouped) {
  console.log(`${role}:`, users.length);
}
```

### When to Use Map.groupBy vs Object.groupBy

```javascript
// Use Object.groupBy for string keys
const byName = Object.groupBy(users, u => u.name);

// Use Map.groupBy for non-string keys
const numbers = [1, 2, 3, 4, 5];
const byParity = Map.groupBy(numbers, n => n % 2);

console.log(byParity.get(0));  // [2, 4]
console.log(byParity.get(1));  // [1, 3, 5]

// Object keys
const products = [
  { id: 1, category: { name: 'Electronics' } },
  { id: 2, category: { name: 'Clothing' } },
  { id: 3, category: { name: 'Electronics' } }
];

const byCategory = Map.groupBy(products, p => p.category);
// Keys are actual category objects, not strings
```

### Practical Examples

#### Group by Custom Object

```javascript
class Status {
  constructor(value) {
    this.value = value;
  }
}

const ACTIVE = new Status('active');
const INACTIVE = new Status('inactive');

const users = [
  { name: 'John', status: ACTIVE },
  { name: 'Jane', status: INACTIVE },
  { name: 'Bob', status: ACTIVE }
];

const byStatus = Map.groupBy(users, u => u.status);

console.log(byStatus.get(ACTIVE));    // [John, Bob]
console.log(byStatus.get(INACTIVE));  // [Jane]
```

#### Statistics from Groups

```javascript
const sales = [
  { product: 'A', amount: 100 },
  { product: 'B', amount: 150 },
  { product: 'A', amount: 200 },
  { product: 'B', amount: 175 }
];

const byProduct = Map.groupBy(sales, s => s.product);

const totals = new Map();
for (const [product, sales] of byProduct) {
  const total = sales.reduce((sum, s) => sum + s.amount, 0);
  totals.set(product, total);
}

console.log(totals.get('A'));  // 300
console.log(totals.get('B'));  // 325
```

---

## ArrayBuffer Transfer

Transfer ownership of ArrayBuffer.

### Basic Usage

```javascript
// Create ArrayBuffer
const buffer = new ArrayBuffer(1024);

// Transfer to new buffer
const transferred = buffer.transfer();

console.log(buffer.byteLength);        // 0 (detached)
console.log(transferred.byteLength);   // 1024

// Cannot use original after transfer
try {
  new Uint8Array(buffer);
} catch (error) {
  console.log('Buffer detached!');
}
```

### Transfer with Resize

```javascript
const buffer = new ArrayBuffer(1024);

// Transfer and resize
const larger = buffer.transfer(2048);

console.log(buffer.byteLength);   // 0 (detached)
console.log(larger.byteLength);   // 2048

// Shrink
const smaller = larger.transfer(512);
console.log(smaller.byteLength);  // 512
```

### Practical Examples

#### Web Worker Communication

```javascript
// Main thread
const buffer = new ArrayBuffer(1024);
const view = new Uint8Array(buffer);
view[0] = 42;

// Transfer to worker (zero-copy)
worker.postMessage(buffer, [buffer]);

console.log(buffer.byteLength);  // 0 (transferred)

// Worker thread
self.onmessage = (e) => {
  const buffer = e.data;
  const view = new Uint8Array(buffer);
  console.log(view[0]);  // 42
};
```

#### Efficient Buffer Management

```javascript
class BufferPool {
  #buffers = [];
  
  acquire(size) {
    const buffer = this.#buffers.find(b => 
      b.byteLength >= size
    );
    
    if (buffer) {
      const index = this.#buffers.indexOf(buffer);
      this.#buffers.splice(index, 1);
      return buffer.transfer(size);
    }
    
    return new ArrayBuffer(size);
  }
  
  release(buffer) {
    if (buffer.byteLength > 0) {
      this.#buffers.push(buffer);
    }
  }
}

const pool = new BufferPool();

const buffer = pool.acquire(1024);
// Use buffer...
pool.release(buffer);
```

---

## Resizable ArrayBuffer

Create ArrayBuffers that can be resized.

### Basic Usage

```javascript
// Create resizable buffer
const buffer = new ArrayBuffer(1024, { maxByteLength: 2048 });

console.log(buffer.byteLength);     // 1024
console.log(buffer.maxByteLength);  // 2048
console.log(buffer.resizable);      // true

// Resize
buffer.resize(1536);
console.log(buffer.byteLength);     // 1536

// Cannot exceed maxByteLength
try {
  buffer.resize(3000);
} catch (error) {
  console.log('Cannot exceed maxByteLength');
}
```

### Practical Examples

#### Dynamic Buffer

```javascript
class DynamicBuffer {
  #buffer;
  #view;
  #offset = 0;
  
  constructor(initialSize, maxSize) {
    this.#buffer = new ArrayBuffer(initialSize, {
      maxByteLength: maxSize
    });
    this.#view = new Uint8Array(this.#buffer);
  }
  
  write(data) {
    const needed = this.#offset + data.length;
    
    if (needed > this.#buffer.byteLength) {
      // Resize if needed
      const newSize = Math.min(
        needed * 2,
        this.#buffer.maxByteLength
      );
      this.#buffer.resize(newSize);
      this.#view = new Uint8Array(this.#buffer);
    }
    
    this.#view.set(data, this.#offset);
    this.#offset += data.length;
  }
  
  getData() {
    return this.#view.slice(0, this.#offset);
  }
}

const buf = new DynamicBuffer(1024, 10240);
buf.write(new Uint8Array([1, 2, 3]));
buf.write(new Uint8Array([4, 5, 6]));
```

---

## Atomics.waitAsync()

Non-blocking wait for shared memory changes.

### Basic Usage

```javascript
// SharedArrayBuffer
const sab = new SharedArrayBuffer(1024);
const int32 = new Int32Array(sab);

// Wait asynchronously
const result = Atomics.waitAsync(int32, 0, 0);

if (result.async) {
  result.value.then(status => {
    console.log('Woken up:', status);
  });
}

// In another thread/worker
Atomics.store(int32, 0, 1);
Atomics.notify(int32, 0);
```

### Practical Example

```javascript
// Coordination between threads
class SharedCounter {
  #sab;
  #view;
  
  constructor() {
    this.#sab = new SharedArrayBuffer(4);
    this.#view = new Int32Array(this.#sab);
  }
  
  async waitForValue(value) {
    while (true) {
      const current = Atomics.load(this.#view, 0);
      
      if (current === value) return;
      
      const result = Atomics.waitAsync(this.#view, 0, current);
      
      if (result.async) {
        await result.value;
      }
    }
  }
  
  setValue(value) {
    Atomics.store(this.#view, 0, value);
    Atomics.notify(this.#view, 0);
  }
  
  getBuffer() {
    return this.#sab;
  }
}

const counter = new SharedCounter();

// Thread 1
await counter.waitForValue(5);
console.log('Counter reached 5');

// Thread 2
counter.setValue(5);
```

---

## Regular Expression v Flag

Enhanced Unicode support in regex.

### Basic Usage

```javascript
// Better Unicode property support
const regex = /\p{RGI_Emoji}/v;

console.log(regex.test('ðŸ˜€'));  // true
console.log(regex.test('ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦'));  // true (family emoji)

// Set notation
const digitOrSpace = /[\p{Decimal_Number}\s]/v;
console.log(digitOrSpace.test('5'));  // true
console.log(digitOrSpace.test(' '));  // true
```

### String Properties

```javascript
// Match strings, not just single characters
const emoji = /\p{RGI_Emoji_Flag_Sequence}/v;

console.log(emoji.test('ðŸ‡ºðŸ‡¸'));  // true (US flag)
console.log(emoji.test('ðŸ‡¬ðŸ‡§'));  // true (UK flag)
```

---

## Practical Complete Example

### Advanced Task Queue

```javascript
class TaskQueue {
  #tasks = [];
  #processing = false;
  #concurrent = 0;
  #maxConcurrent = 3;
  
  async add(task, priority = 0) {
    const { promise, resolve, reject } = Promise.withResolvers();
    
    this.#tasks.push({
      task,
      priority,
      resolve,
      reject
    });
    
    // Sort by priority
    this.#tasks.sort((a, b) => b.priority - a.priority);
    
    this.#process();
    return promise;
  }
  
  async #process() {
    if (this.#concurrent >= this.#maxConcurrent || this.#tasks.length === 0) {
      return;
    }
    
    const item = this.#tasks.shift();
    this.#concurrent++;
    
    try {
      const result = await item.task();
      item.resolve(result);
    } catch (error) {
      item.reject(error);
    } finally {
      this.#concurrent--;
      this.#process();
    }
  }
  
  getStats() {
    const byPriority = Object.groupBy(
      this.#tasks,
      t => t.priority
    );
    
    return {
      pending: this.#tasks.length,
      processing: this.#concurrent,
      byPriority
    };
  }
}

const queue = new TaskQueue();

// Add tasks with priority
await queue.add(async () => {
  // High priority task
}, 10);

await queue.add(async () => {
  // Normal priority task
}, 5);

console.log(queue.getStats());
```

---

## Key Takeaways

- **Promise.withResolvers()**: External resolve/reject control
- **Object.groupBy()**: Group array by key function
- **Map.groupBy()**: Group into Map with any key type
- **ArrayBuffer.transfer()**: Transfer buffer ownership
- **Resizable ArrayBuffer**: Dynamic buffer sizing
- **Atomics.waitAsync()**: Non-blocking shared memory wait
- **RegExp v flag**: Enhanced Unicode support
- Use Promise.withResolvers for deferred promises
- Object.groupBy for simple grouping with string keys
- Map.groupBy when keys are objects or non-strings
- ArrayBuffer transfer for efficient worker communication
- Resizable buffers for dynamic memory needs
