# ES2020-ES2021

New features introduced in ECMAScript 2020 and 2021.

---

## ES2020 Features

### Optional Chaining (?.)

Safely access nested properties without checking each level.

```javascript
// Old way - manual checks
const user = { name: 'John', address: { city: 'NYC' } };

const city = user && user.address && user.address.city;
console.log(city);  // 'NYC'

// ES2020 - optional chaining
const city = user?.address?.city;
console.log(city);  // 'NYC'

// With undefined
const user2 = { name: 'Jane' };
console.log(user2?.address?.city);  // undefined (no error)

// With null
const user3 = null;
console.log(user3?.address?.city);  // undefined (no error)

// Array access
const users = [{ name: 'John' }, { name: 'Jane' }];
console.log(users?.[0]?.name);  // 'John'
console.log(users?.[5]?.name);  // undefined

// Function calls
const obj = {
  method: () => 'Hello'
};

console.log(obj.method?.());     // 'Hello'
console.log(obj.missing?.());    // undefined (no error)

// Practical examples
// API response
function getUserCity(response) {
  return response?.data?.user?.address?.city ?? 'Unknown';
}

// DOM manipulation
const element = document.querySelector('#myElement');
const width = element?.getBoundingClientRect()?.width;

// Event handlers
button?.addEventListener('click', handleClick);

// Nested object access
const config = {
  api: {
    endpoints: {
      users: '/api/users'
    }
  }
};

const endpoint = config?.api?.endpoints?.users ?? '/default';

// Dynamic property access
const user = { id: 1, profile: { age: 30 } };
const prop = 'profile';
const age = user?.[prop]?.age;  // 30
```

### Nullish Coalescing (??)

Return right operand when left is null or undefined.

```javascript
// Old way - logical OR has issues
const count = 0;
const value1 = count || 10;
console.log(value1);  // 10 (0 is falsy, so 10 is used)

// ES2020 - nullish coalescing
const value2 = count ?? 10;
console.log(value2);  // 0 (only null/undefined trigger default)

// Comparison
console.log('' || 'default');   // 'default' (empty string is falsy)
console.log('' ?? 'default');   // '' (empty string is not nullish)

console.log(0 || 100);          // 100 (0 is falsy)
console.log(0 ?? 100);          // 0 (0 is not nullish)

console.log(false || true);     // true (false is falsy)
console.log(false ?? true);     // false (false is not nullish)

console.log(null || 'default'); // 'default'
console.log(null ?? 'default'); // 'default'

console.log(undefined || 'default'); // 'default'
console.log(undefined ?? 'default'); // 'default'

// Practical examples
// Configuration with defaults
function createConfig(options) {
  return {
    timeout: options?.timeout ?? 5000,
    retries: options?.retries ?? 3,
    cache: options?.cache ?? true
  };
}

createConfig({ timeout: 0 });
// { timeout: 0, retries: 3, cache: true }
// timeout is 0, not 5000!

// User preferences
const userTheme = user?.preferences?.theme ?? 'light';

// API pagination
const page = query?.page ?? 1;
const limit = query?.limit ?? 10;

// Combined with optional chaining
const city = user?.address?.city ?? 'Unknown';
```

### BigInt

Arbitrary precision integers.

```javascript
// Create BigInt
const big1 = 123n;                    // Literal
const big2 = BigInt(123);             // Constructor
const big3 = BigInt('999999999999999999999');

// Large numbers
const huge = 9007199254740991n;       // Max safe integer + 1
console.log(huge);                    // 9007199254740991n

// Arithmetic
console.log(10n + 20n);               // 30n
console.log(50n - 30n);               // 20n
console.log(5n * 10n);                // 50n
console.log(20n / 3n);                // 6n (truncates)
console.log(20n % 3n);                // 2n
console.log(2n ** 100n);              // Very large number

// Cannot mix BigInt with Number
console.log(10n + 20);                // TypeError!
console.log(10n + BigInt(20));        // 30n (convert first)

// Comparisons work
console.log(10n > 5);                 // true
console.log(10n === 10);              // false (different types)
console.log(10n == 10);               // true (loose equality)

// Practical examples
// Precise calculations
function calculateTotal(prices) {
  return prices.reduce((sum, price) => sum + BigInt(price * 100), 0n);
}

const total = calculateTotal([10.99, 20.50, 5.25]);
console.log(Number(total) / 100);  // 36.74

// Large IDs
const userId = 9007199254740992n;  // Beyond Number.MAX_SAFE_INTEGER

// Bitwise operations
console.log(5n & 3n);   // 1n
console.log(5n | 3n);   // 7n
console.log(5n ^ 3n);   // 6n
console.log(5n << 2n);  // 20n
console.log(20n >> 2n); // 5n

// Conversion
console.log(Number(100n));        // 100
console.log(String(100n));        // '100'
console.log(Boolean(0n));         // false
console.log(Boolean(1n));         // true
```

### Promise.allSettled()

Wait for all promises to settle (fulfilled or rejected).

```javascript
// Promise.all fails fast
const promises1 = [
  Promise.resolve(1),
  Promise.reject('Error'),
  Promise.resolve(3)
];

Promise.all(promises1)
  .then(results => console.log(results))
  .catch(error => console.log('Failed:', error));
// Failed: Error (stops at first rejection)

// Promise.allSettled waits for all
const promises2 = [
  Promise.resolve(1),
  Promise.reject('Error'),
  Promise.resolve(3)
];

Promise.allSettled(promises2)
  .then(results => {
    console.log(results);
    /*
    [
      { status: 'fulfilled', value: 1 },
      { status: 'rejected', reason: 'Error' },
      { status: 'fulfilled', value: 3 }
    ]
    */
  });

// Practical examples
// Fetch multiple resources
async function fetchMultiple(urls) {
  const promises = urls.map(url => fetch(url).then(r => r.json()));
  const results = await Promise.allSettled(promises);
  
  const successful = results
    .filter(r => r.status === 'fulfilled')
    .map(r => r.value);
  
  const failed = results
    .filter(r => r.status === 'rejected')
    .map(r => r.reason);
  
  return { successful, failed };
}

const { successful, failed } = await fetchMultiple([
  '/api/users',
  '/api/posts',
  '/api/comments'
]);

// Batch operations with partial success
async function batchUpdate(items) {
  const results = await Promise.allSettled(
    items.map(item => updateItem(item))
  );
  
  const updated = results.filter(r => r.status === 'fulfilled').length;
  const failed = results.filter(r => r.status === 'rejected').length;
  
  return { updated, failed };
}

// Aggregate results
async function loadAllData() {
  const [users, posts, comments] = await Promise.allSettled([
    fetchUsers(),
    fetchPosts(),
    fetchComments()
  ]);
  
  return {
    users: users.status === 'fulfilled' ? users.value : [],
    posts: posts.status === 'fulfilled' ? posts.value : [],
    comments: comments.status === 'fulfilled' ? comments.value : []
  };
}
```

### String.prototype.matchAll()

Get all matches including capture groups.

```javascript
// Old way - loop with exec
const str = 'test1 test2 test3';
const regex = /test(\d)/g;
let match;

while ((match = regex.exec(str)) !== null) {
  console.log(match[0], match[1]);
}
// test1 1
// test2 2
// test3 3

// ES2020 - matchAll
const str = 'test1 test2 test3';
const regex = /test(\d)/g;
const matches = [...str.matchAll(regex)];

matches.forEach(match => {
  console.log(match[0], match[1]);
});
// test1 1
// test2 2
// test3 3

// With named groups
const text = 'John: 30, Jane: 25';
const regex = /(?<name>\w+): (?<age>\d+)/g;
const matches = [...text.matchAll(regex)];

matches.forEach(match => {
  console.log(match.groups.name, match.groups.age);
});
// John 30
// Jane 25

// Practical examples
// Parse log entries
const log = `
  [2024-12-23 10:00] INFO: User logged in
  [2024-12-23 10:05] ERROR: Connection failed
  [2024-12-23 10:10] INFO: User logged out
`;

const regex = /\[(?<date>[\d-]+) (?<time>[\d:]+)\] (?<level>\w+): (?<message>.+)/g;
const entries = [...log.matchAll(regex)].map(match => match.groups);

console.log(entries);
/*
[
  { date: '2024-12-23', time: '10:00', level: 'INFO', message: 'User logged in' },
  { date: '2024-12-23', time: '10:05', level: 'ERROR', message: 'Connection failed' },
  { date: '2024-12-23', time: '10:10', level: 'INFO', message: 'User logged out' }
]
*/

// Extract URLs
const text = 'Visit https://example.com or http://test.com';
const urlRegex = /https?:\/\/[^\s]+/g;
const urls = [...text.matchAll(urlRegex)].map(match => match[0]);
console.log(urls);  // ['https://example.com', 'http://test.com']

// Parse structured data
const csv = 'John,30,NYC\nJane,25,LA';
const regex = /(\w+),(\d+),(\w+)/g;
const rows = [...csv.matchAll(regex)].map(([, name, age, city]) => ({
  name,
  age: parseInt(age),
  city
}));
```

### globalThis

Universal global object.

```javascript
// Old way - different in different environments
// Browser: window
// Node.js: global
// Web Worker: self

const globalObj = typeof window !== 'undefined' ? window
                : typeof global !== 'undefined' ? global
                : self;

// ES2020 - works everywhere
console.log(globalThis);  // Global object in any environment

// Practical examples
// Set global variable
globalThis.APP_VERSION = '1.0.0';

// Check if feature exists globally
if (globalThis.fetch) {
  // fetch is available
}

// Polyfill pattern
if (!globalThis.customFeature) {
  globalThis.customFeature = function() {
    // Implementation
  };
}

// Framework initialization
globalThis.myApp = {
  config: {},
  initialize() {
    // Setup
  }
};
```

### import.meta

Metadata about the current module.

```javascript
// URL of current module
console.log(import.meta.url);
// file:///path/to/module.js

// Load resource relative to module
const data = await fetch(new URL('./data.json', import.meta.url));

// Check environment
if (import.meta.url.includes('node_modules')) {
  console.log('Running from node_modules');
}

// Practical example
// Load config file next to module
async function loadConfig() {
  const configUrl = new URL('./config.json', import.meta.url);
  const response = await fetch(configUrl);
  return response.json();
}
```

### Dynamic import()

Load modules dynamically.

```javascript
// Static import - always loaded
import { helper } from './utils.js';

// Dynamic import - load on demand
async function loadUtils() {
  const module = await import('./utils.js');
  module.helper();
}

// Conditional loading
if (condition) {
  const module = await import('./feature.js');
  module.initialize();
}

// Practical examples
// Lazy loading
async function showChart(data) {
  const { Chart } = await import('./chart-library.js');
  const chart = new Chart(data);
  chart.render();
}

// Code splitting
button.addEventListener('click', async () => {
  const { handleClick } = await import('./handlers.js');
  handleClick();
});

// Load based on environment
const config = await import(
  process.env.NODE_ENV === 'production'
    ? './config.prod.js'
    : './config.dev.js'
);

// Dynamic plugin loading
async function loadPlugin(name) {
  try {
    const plugin = await import(`./plugins/${name}.js`);
    return plugin.default;
  } catch (error) {
    console.error(`Failed to load plugin: ${name}`);
    return null;
  }
}

// Parallel loading
const [module1, module2, module3] = await Promise.all([
  import('./module1.js'),
  import('./module2.js'),
  import('./module3.js')
]);
```

---

## ES2021 Features

### String.prototype.replaceAll()

Replace all occurrences of a string.

```javascript
// Old way - regex with g flag
const str = 'hello hello hello';
console.log(str.replace(/hello/g, 'hi'));  // 'hi hi hi'

// ES2021 - replaceAll
console.log(str.replaceAll('hello', 'hi'));  // 'hi hi hi'

// With regex
console.log(str.replaceAll(/hello/g, 'hi'));  // 'hi hi hi'
// Note: regex must have g flag or error is thrown

// Practical examples
// Remove all spaces
const text = 'hello world how are you';
console.log(text.replaceAll(' ', '-'));  // 'hello-world-how-are-you'

// Sanitize input
function sanitize(input) {
  return input
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;');
}

// Replace with function
const str = 'I have 2 apples and 3 oranges';
const result = str.replaceAll(/\d+/g, (match) => parseInt(match) * 2);
console.log(result);  // 'I have 4 apples and 6 oranges'

// Case-insensitive replace
const text = 'Hello hello HELLO';
console.log(text.replaceAll(/hello/gi, 'hi'));  // 'hi hi hi'
```

### Promise.any()

Resolve when any promise fulfills.

```javascript
// Resolves with first successful promise
const promises = [
  Promise.reject('Error 1'),
  Promise.resolve('Success'),
  Promise.reject('Error 2')
];

Promise.any(promises)
  .then(result => console.log(result))  // 'Success'
  .catch(error => console.log(error));

// All rejected - AggregateError
const allFailed = [
  Promise.reject('Error 1'),
  Promise.reject('Error 2'),
  Promise.reject('Error 3')
];

Promise.any(allFailed)
  .catch(error => {
    console.log(error);  // AggregateError
    console.log(error.errors);  // ['Error 1', 'Error 2', 'Error 3']
  });

// Practical examples
// Fetch from fastest mirror
async function fetchFromMirrors(resource) {
  const mirrors = [
    'https://mirror1.com',
    'https://mirror2.com',
    'https://mirror3.com'
  ];
  
  const promises = mirrors.map(mirror => 
    fetch(`${mirror}/${resource}`).then(r => r.json())
  );
  
  return Promise.any(promises);
}

// Retry with multiple strategies
async function fetchWithFallbacks(url) {
  return Promise.any([
    fetch(url),
    fetch(`${url}?cache=false`),
    fetch(`${url}?retry=1`)
  ]);
}

// Load from multiple sources
async function loadConfig() {
  return Promise.any([
    fetch('/api/config').then(r => r.json()),
    fetch('/fallback-config.json').then(r => r.json()),
    Promise.resolve(defaultConfig)
  ]);
}
```

### Logical Assignment Operators

Combine logical operators with assignment.

#### &&= (AND assignment)

```javascript
// Old way
if (obj.prop) {
  obj.prop = newValue;
}

// ES2021
obj.prop &&= newValue;

// Examples
let x = 1;
x &&= 2;
console.log(x);  // 2 (truthy, so assigned)

let y = 0;
y &&= 2;
console.log(y);  // 0 (falsy, not assigned)

// Practical use
const user = { name: 'John', admin: true };
user.admin &&= { permissions: ['read', 'write'] };
// Only update if admin is truthy
```

#### ||= (OR assignment)

```javascript
// Old way
if (!obj.prop) {
  obj.prop = defaultValue;
}

// ES2021
obj.prop ||= defaultValue;

// Examples
let x = 0;
x ||= 10;
console.log(x);  // 10 (falsy, so assigned)

let y = 5;
y ||= 10;
console.log(y);  // 5 (truthy, not assigned)

// Practical use
const config = {};
config.timeout ||= 5000;
config.retries ||= 3;
```

#### ??= (Nullish assignment)

```javascript
// Old way
if (obj.prop === null || obj.prop === undefined) {
  obj.prop = defaultValue;
}

// ES2021
obj.prop ??= defaultValue;

// Examples
let x = null;
x ??= 10;
console.log(x);  // 10 (nullish, so assigned)

let y = 0;
y ??= 10;
console.log(y);  // 0 (not nullish, not assigned)

// Practical use
function createConfig(options) {
  options ??= {};
  options.timeout ??= 5000;
  options.retries ??= 3;
  return options;
}

createConfig({ timeout: 0 });
// { timeout: 0, retries: 3 }
// timeout stays 0!
```

### Numeric Separators

Use underscores for readability.

```javascript
// Large numbers
const billion = 1_000_000_000;
const trillion = 1_000_000_000_000;

// Grouping
const bytes = 0b1111_1111;         // Binary
const hex = 0xFF_FF_FF;            // Hexadecimal
const decimal = 1_234_567.89;      // Decimal

// BigInt
const bigNum = 1_000_000_000_000n;

// Practical examples
const budgetUSD = 1_500_000;
const populationChina = 1_400_000_000;
const distanceToMoon = 384_400; // km

// Binary masks
const READ = 0b0001;
const WRITE = 0b0010;
const EXECUTE = 0b0100;
const permissions = 0b0111;

// File sizes
const KB = 1_024;
const MB = 1_024 * KB;
const GB = 1_024 * MB;
```

### WeakRef and FinalizationRegistry

Advanced memory management (use with caution).

#### WeakRef

```javascript
// Create weak reference to object
let target = { data: 'important' };
const weakRef = new WeakRef(target);

// Access object
const obj = weakRef.deref();
if (obj) {
  console.log(obj.data);  // 'important'
} else {
  console.log('Object was garbage collected');
}

// After target is collected
target = null;
// ... later, after GC ...
console.log(weakRef.deref());  // undefined
```

#### FinalizationRegistry

```javascript
// Register cleanup callback
const registry = new FinalizationRegistry((heldValue) => {
  console.log(`Cleaning up: ${heldValue}`);
});

let obj = { id: 1 };
registry.register(obj, 'object-1');

// When obj is garbage collected
obj = null;
// Eventually: "Cleaning up: object-1"

// Practical example - cleanup external resources
const resourceRegistry = new FinalizationRegistry((resource) => {
  resource.close();
});

function createResource(id) {
  const resource = openExternalResource(id);
  const wrapper = { id, resource };
  resourceRegistry.register(wrapper, resource);
  return wrapper;
}
```

---

## Practical Examples

### Robust API Client

```javascript
class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.timeout = options?.timeout ?? 5000;
    this.retries = options?.retries ?? 3;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    const results = await Promise.allSettled(
      Array(this.retries).fill().map((_, i) => 
        this.#attemptRequest(url, options, i)
      )
    );
    
    const successful = results.find(r => r.status === 'fulfilled');
    if (successful) {
      return successful.value;
    }
    
    throw new Error('All retries failed');
  }
  
  async #attemptRequest(url, options, attempt) {
    await new Promise(resolve => setTimeout(resolve, attempt * 1000));
    
    const response = await fetch(url, {
      ...options,
      signal: AbortSignal.timeout(this.timeout)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return response.json();
  }
}

const api = new APIClient('https://api.example.com', {
  timeout: 3000,
  retries: 3
});
```

---

## Key Takeaways

### ES2020
- **Optional chaining (?.)**: Safe property access
- **Nullish coalescing (??)**: Default for null/undefined only
- **BigInt**: Arbitrary precision integers
- **Promise.allSettled()**: Wait for all promises
- **matchAll()**: Get all regex matches
- **globalThis**: Universal global object
- **import.meta**: Module metadata
- **Dynamic import()**: Load modules on demand

### ES2021
- **replaceAll()**: Replace all occurrences
- **Promise.any()**: First successful promise
- **Logical assignment**: &&=, ||=, ??=
- **Numeric separators**: Underscores for readability
- **WeakRef**: Weak references to objects
- Combine ?. and ?? for robust code
- Use Promise.allSettled for partial success scenarios
- BigInt for precise large number calculations
