# ES2018-ES2019

New features introduced in ECMAScript 2018 and 2019.

---

## ES2018 Features

### Rest/Spread Properties for Objects

Object rest and spread operators.

#### Object Spread

```javascript
// Clone object
const person = { name: 'John', age: 30 };
const clone = { ...person };
console.log(clone);  // { name: 'John', age: 30 }

// Merge objects
const defaults = { theme: 'light', lang: 'en' };
const userSettings = { theme: 'dark' };
const settings = { ...defaults, ...userSettings };
console.log(settings);  // { theme: 'dark', lang: 'en' }

// Add properties
const user = { name: 'John' };
const employee = { ...user, role: 'developer', id: 123 };
console.log(employee);  // { name: 'John', role: 'developer', id: 123 }

// Override properties
const original = { a: 1, b: 2, c: 3 };
const updated = { ...original, b: 20, d: 4 };
console.log(updated);  // { a: 1, b: 20, c: 3, d: 4 }

// Conditional properties
const includeEmail = true;
const user = {
  name: 'John',
  age: 30,
  ...(includeEmail && { email: 'john@example.com' })
};
console.log(user);  // { name: 'John', age: 30, email: 'john@example.com' }

// Shallow copy warning
const nested = { a: { b: 1 } };
const copy = { ...nested };
copy.a.b = 2;
console.log(nested.a.b);  // 2 (nested objects not copied)

// Practical example
function createUser({ name, email, ...options }) {
  return {
    id: generateId(),
    name,
    email,
    createdAt: new Date(),
    ...options  // role, department, etc.
  };
}

const user = createUser({
  name: 'John',
  email: 'john@example.com',
  role: 'admin',
  department: 'IT'
});
```

#### Object Rest

```javascript
// Extract and collect remaining properties
const person = {
  name: 'John',
  age: 30,
  city: 'NYC',
  country: 'USA'
};

const { name, age, ...location } = person;
console.log(name);      // 'John'
console.log(age);       // 30
console.log(location);  // { city: 'NYC', country: 'USA' }

// Function parameters
function processUser({ id, name, ...details }) {
  console.log(`User ${id}: ${name}`);
  console.log('Additional details:', details);
}

processUser({
  id: 1,
  name: 'John',
  age: 30,
  email: 'john@example.com'
});
// User 1: John
// Additional details: { age: 30, email: 'john@example.com' }

// Remove properties
const user = {
  id: 1,
  name: 'John',
  password: 'secret',
  email: 'john@example.com'
};

const { password, ...publicUser } = user;
console.log(publicUser);  // { id: 1, name: 'John', email: 'john@example.com' }

// Practical example - API response sanitization
function sanitizeUser(user) {
  const { password, ssn, privateKey, ...safeUser } = user;
  return safeUser;
}

const dbUser = {
  id: 1,
  name: 'John',
  email: 'john@example.com',
  password: 'hashed_password',
  ssn: '123-45-6789'
};

const apiResponse = sanitizeUser(dbUser);
// { id: 1, name: 'John', email: 'john@example.com' }
```

### Async Iteration

Iterate over asynchronous data sources.

#### for await...of Loop

```javascript
// Async generator
async function* asyncGenerator() {
  yield await Promise.resolve(1);
  yield await Promise.resolve(2);
  yield await Promise.resolve(3);
}

async function process() {
  for await (const num of asyncGenerator()) {
    console.log(num);  // 1, 2, 3
  }
}

process();

// Practical example - paginated API
async function* fetchPages(url) {
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const response = await fetch(`${url}?page=${page}`);
    const data = await response.json();
    
    yield data.items;
    
    hasMore = data.hasMore;
    page++;
  }
}

async function processAllData() {
  for await (const items of fetchPages('/api/data')) {
    items.forEach(item => console.log(item));
  }
}

// Stream processing
async function* readLines(filePath) {
  const stream = createReadStream(filePath);
  let buffer = '';
  
  for await (const chunk of stream) {
    buffer += chunk;
    const lines = buffer.split('\n');
    buffer = lines.pop();
    
    for (const line of lines) {
      yield line;
    }
  }
  
  if (buffer) yield buffer;
}

// Process large file line by line
async function processFile(filePath) {
  for await (const line of readLines(filePath)) {
    console.log(line);
  }
}
```

### Promise.finally()

Execute code after Promise settles (fulfilled or rejected).

```javascript
// Basic usage
fetch('/api/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error))
  .finally(() => {
    console.log('Request completed');
    // Cleanup code runs regardless of success/failure
  });

// Async/await version
async function loadData() {
  let loading = true;
  
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to load data:', error);
    throw error;
  } finally {
    loading = false;  // Always runs
    console.log('Loading finished');
  }
}

// Practical examples
// Show/hide loading spinner
async function fetchUser(id) {
  showLoadingSpinner();
  
  try {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    displayUser(user);
    return user;
  } catch (error) {
    showError(error.message);
    throw error;
  } finally {
    hideLoadingSpinner();  // Always hide spinner
  }
}

// Close resources
async function processFile(path) {
  const file = await open(path);
  
  try {
    const data = await file.read();
    return processData(data);
  } finally {
    await file.close();  // Always close file
  }
}

// Unlock mutex
async function criticalSection() {
  await lock.acquire();
  
  try {
    // Critical code
    await performOperation();
  } finally {
    lock.release();  // Always release lock
  }
}
```

### RegExp Improvements

#### Named Capture Groups

```javascript
// Old way - positional groups
const dateRegex = /(\d{4})-(\d{2})-(\d{2})/;
const match = '2024-12-23'.match(dateRegex);
console.log(match[1]);  // '2024'
console.log(match[2]);  // '12'
console.log(match[3]);  // '23'

// ES2018 - named groups
const dateRegex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const match = '2024-12-23'.match(dateRegex);
console.log(match.groups.year);   // '2024'
console.log(match.groups.month);  // '12'
console.log(match.groups.day);    // '23'

// Destructuring
const { year, month, day } = match.groups;

// Practical example - parse URL
const urlRegex = /(?<protocol>https?):\/\/(?<domain>[^\/]+)(?<path>\/.*)?/;
const url = 'https://example.com/api/users';
const { protocol, domain, path } = url.match(urlRegex).groups;
console.log(protocol);  // 'https'
console.log(domain);    // 'example.com'
console.log(path);      // '/api/users'

// Replace with named groups
const text = 'John Doe';
const result = text.replace(
  /(?<first>\w+) (?<last>\w+)/,
  '$<last>, $<first>'
);
console.log(result);  // 'Doe, John'
```

#### s (dotAll) Flag

```javascript
// Old way - dot doesn't match newlines
const regex = /foo.bar/;
console.log(regex.test('foo\nbar'));  // false

// ES2018 - s flag makes dot match newlines
const regex = /foo.bar/s;
console.log(regex.test('foo\nbar'));  // true

// Practical example
const html = `
  <div>
    <h1>Title</h1>
  </div>
`;

const content = html.match(/<div>(.*)<\/div>/s)[1].trim();
console.log(content);  // '<h1>Title</h1>'
```

#### Lookbehind Assertions

```javascript
// Positive lookbehind (?<=...)
const price = '$100';
const amount = price.match(/(?<=\$)\d+/);
console.log(amount[0]);  // '100'

// Negative lookbehind (?<!...)
const text = 'foo bar baz';
const matches = text.match(/(?<!ba)\w+/g);
console.log(matches);  // ['foo', 'ba'] (excludes 'r' and 'z')

// Practical examples
// Extract price without currency symbol
const prices = ['$100', 'â‚¬200', 'Â¥300'];
prices.forEach(price => {
  const amount = price.match(/(?<=[$â‚¬Â¥])\d+/)[0];
  console.log(amount);  // 100, 200, 300
});

// Match words not preceded by @
const text = 'hello @john world @jane';
const words = text.match(/(?<!@)\b\w+\b/g);
console.log(words);  // ['hello', 'world']
```

#### Unicode Property Escapes

```javascript
// Match any letter from any language
const regex = /\p{L}+/u;
console.log(regex.test('hello'));   // true
console.log(regex.test('ä½ å¥½'));     // true
console.log(regex.test('Ù…Ø±Ø­Ø¨Ø§'));   // true

// Match currency symbols
const currencyRegex = /\p{Sc}/u;
console.log(currencyRegex.test('$'));  // true
console.log(currencyRegex.test('â‚¬'));  // true
console.log(currencyRegex.test('Â¥'));  // true

// Match emojis
const emojiRegex = /\p{Emoji}/u;
console.log(emojiRegex.test('ðŸ˜€'));  // true

// Practical example
function containsOnlyLetters(str) {
  return /^\p{L}+$/u.test(str);
}

console.log(containsOnlyLetters('hello'));    // true
console.log(containsOnlyLetters('hello123')); // false
console.log(containsOnlyLetters('ä½ å¥½'));      // true
```

---

## ES2019 Features

### Array.prototype.flat()

Flatten nested arrays.

```javascript
// Basic usage
const arr = [1, 2, [3, 4]];
console.log(arr.flat());  // [1, 2, 3, 4]

// Nested arrays - specify depth
const nested = [1, [2, [3, [4]]]];
console.log(nested.flat());     // [1, 2, [3, [4]]]
console.log(nested.flat(2));    // [1, 2, 3, [4]]
console.log(nested.flat(3));    // [1, 2, 3, 4]
console.log(nested.flat(Infinity)); // [1, 2, 3, 4] (flatten all)

// Remove empty slots
const sparse = [1, 2, , 4, 5];
console.log(sparse.flat());  // [1, 2, 4, 5]

// Practical examples
// Flatten array of arrays
const users = [
  [{ name: 'John' }, { name: 'Jane' }],
  [{ name: 'Bob' }, { name: 'Alice' }]
];
const allUsers = users.flat();

// Combine results
const results = await Promise.all([
  fetchUsers('dept1'),
  fetchUsers('dept2'),
  fetchUsers('dept3')
]);
const allResults = results.flat();

// Process nested data
const categories = [
  { name: 'Electronics', items: ['Phone', 'Laptop'] },
  { name: 'Books', items: ['Fiction', 'Non-fiction'] }
];
const allItems = categories.map(cat => cat.items).flat();
console.log(allItems);  // ['Phone', 'Laptop', 'Fiction', 'Non-fiction']
```

### Array.prototype.flatMap()

Map and flatten in one operation.

```javascript
// Equivalent to map().flat()
const arr = [1, 2, 3];
console.log(arr.map(x => [x, x * 2]).flat());  // [1, 2, 2, 4, 3, 6]
console.log(arr.flatMap(x => [x, x * 2]));     // [1, 2, 2, 4, 3, 6]

// Return different number of elements
const words = ['hello world', 'how are you'];
const allWords = words.flatMap(phrase => phrase.split(' '));
console.log(allWords);  // ['hello', 'world', 'how', 'are', 'you']

// Filter and transform
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.flatMap(n => n % 2 === 0 ? [n * 2] : []);
console.log(doubled);  // [4, 8]

// Practical examples
// Expand ranges
const ranges = [
  { start: 1, end: 3 },
  { start: 5, end: 7 }
];

const expanded = ranges.flatMap(({ start, end }) => {
  const result = [];
  for (let i = start; i <= end; i++) {
    result.push(i);
  }
  return result;
});
console.log(expanded);  // [1, 2, 3, 5, 6, 7]

// Process nested data
const orders = [
  { id: 1, items: ['apple', 'banana'] },
  { id: 2, items: ['orange'] }
];

const allItems = orders.flatMap(order => 
  order.items.map(item => ({ orderId: order.id, item }))
);
// [
//   { orderId: 1, item: 'apple' },
//   { orderId: 1, item: 'banana' },
//   { orderId: 2, item: 'orange' }
// ]

// Duplicate removal with transformation
const tags = ['javascript, react', 'vue, angular'];
const uniqueTags = [...new Set(
  tags.flatMap(tag => tag.split(', ').map(t => t.trim()))
)];
console.log(uniqueTags);  // ['javascript', 'react', 'vue', 'angular']
```

### Object.fromEntries()

Convert key-value pairs to object.

```javascript
// From array of entries
const entries = [['name', 'John'], ['age', 30]];
const obj = Object.fromEntries(entries);
console.log(obj);  // { name: 'John', age: 30 }

// Inverse of Object.entries()
const person = { name: 'John', age: 30 };
const entries = Object.entries(person);
const copy = Object.fromEntries(entries);

// From Map
const map = new Map([
  ['name', 'John'],
  ['age', 30]
]);
const obj = Object.fromEntries(map);
console.log(obj);  // { name: 'John', age: 30 }

// Practical examples
// Transform object values
const scores = { math: 85, english: 90, science: 88 };

const graded = Object.fromEntries(
  Object.entries(scores).map(([subject, score]) => [
    subject,
    score >= 90 ? 'A' : 'B'
  ])
);
console.log(graded);  // { math: 'B', english: 'A', science: 'B' }

// Filter object properties
const user = {
  id: 1,
  name: 'John',
  password: 'secret',
  email: 'john@example.com'
};

const publicUser = Object.fromEntries(
  Object.entries(user).filter(([key]) => key !== 'password')
);
console.log(publicUser);  // { id: 1, name: 'John', email: 'john@example.com' }

// Parse query string
const searchParams = new URLSearchParams('name=John&age=30');
const params = Object.fromEntries(searchParams);
console.log(params);  // { name: 'John', age: '30' }

// Invert object keys/values
const original = { a: 1, b: 2, c: 3 };
const inverted = Object.fromEntries(
  Object.entries(original).map(([key, value]) => [value, key])
);
console.log(inverted);  // { 1: 'a', 2: 'b', 3: 'c' }
```

### String.prototype.trimStart() / trimEnd()

Trim whitespace from start or end.

```javascript
// trimStart() - remove leading whitespace
const str = '   hello   ';
console.log(str.trimStart());  // 'hello   '
console.log(str.trimLeft());   // 'hello   ' (alias)

// trimEnd() - remove trailing whitespace
console.log(str.trimEnd());    // '   hello'
console.log(str.trimRight());  // '   hello' (alias)

// trim() - remove both
console.log(str.trim());       // 'hello'

// Practical examples
// Parse user input
function parseInput(input) {
  return input.trimStart().trimEnd();
}

// Format code indentation
const code = `
  function hello() {
    console.log('Hello');
  }
`.trimStart();

// Clean CSV data
const csvLine = '  John  ,  30  ,  NYC  ';
const fields = csvLine.split(',').map(field => field.trim());
console.log(fields);  // ['John', '30', 'NYC']
```

### Optional Catch Binding

Omit catch parameter if not needed.

```javascript
// Old way - must specify parameter
try {
  JSON.parse('invalid');
} catch (error) {  // error not used
  console.log('Parse failed');
}

// ES2019 - optional parameter
try {
  JSON.parse('invalid');
} catch {  // No parameter
  console.log('Parse failed');
}

// Practical example
function attemptParse(str) {
  try {
    return JSON.parse(str);
  } catch {
    return null;  // Don't care about error details
  }
}

// Feature detection
let hasLocalStorage = false;
try {
  localStorage.setItem('test', 'test');
  localStorage.removeItem('test');
  hasLocalStorage = true;
} catch {
  hasLocalStorage = false;
}
```

### Symbol.prototype.description

Get symbol description.

```javascript
// Old way
const sym = Symbol('my symbol');
console.log(sym.toString());  // 'Symbol(my symbol)'
console.log(String(sym));     // 'Symbol(my symbol)'

// ES2019 - direct access to description
console.log(sym.description);  // 'my symbol'

// Practical example
const symbols = [
  Symbol('cache'),
  Symbol('config'),
  Symbol('state')
];

symbols.forEach(sym => {
  console.log(`Symbol: ${sym.description}`);
});
```

---

## Practical Examples

### Data Processing Pipeline

```javascript
async function* fetchAllPages(baseUrl) {
  let page = 1;
  
  while (true) {
    const response = await fetch(`${baseUrl}?page=${page}`);
    const data = await response.json();
    
    if (data.items.length === 0) break;
    
    yield data.items;
    page++;
  }
}

async function processAllData(url) {
  const allItems = [];
  
  try {
    for await (const items of fetchAllPages(url)) {
      const processed = items
        .flatMap(item => item.tags || [])
        .map(tag => tag.trim());
      
      allItems.push(...processed);
    }
    
    return [...new Set(allItems)];
  } catch (error) {
    console.error('Processing failed:', error);
    throw error;
  } finally {
    console.log('Processing completed');
  }
}
```

### Configuration Merger

```javascript
function mergeConfigs(...configs) {
  return configs.reduce((merged, config) => ({
    ...merged,
    ...config,
    // Deep merge nested objects
    ...Object.fromEntries(
      Object.entries(config)
        .filter(([, value]) => typeof value === 'object')
        .map(([key, value]) => [key, { ...merged[key], ...value }])
    )
  }), {});
}

const defaults = { theme: 'light', lang: 'en', features: { beta: false } };
const user = { theme: 'dark', features: { beta: true, experimental: true } };
const final = mergeConfigs(defaults, user);
// { theme: 'dark', lang: 'en', features: { beta: true, experimental: true } }
```

---

## Key Takeaways

### ES2018
- **Object rest/spread**: Clone, merge, extract properties
- **Async iteration**: for await...of for async data sources
- **Promise.finally()**: Cleanup code that always runs
- **Named capture groups**: Readable regex matches
- **Lookbehind**: Match based on what comes before
- **s flag**: Dot matches newlines

### ES2019
- **Array.flat()**: Flatten nested arrays
- **Array.flatMap()**: Map and flatten in one step
- **Object.fromEntries()**: Convert entries to object
- **String trim**: trimStart() and trimEnd()
- **Optional catch**: Omit catch parameter if not needed
- **Symbol.description**: Direct access to symbol description
