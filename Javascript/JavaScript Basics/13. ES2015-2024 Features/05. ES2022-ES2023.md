# ES2022-ES2023

New features introduced in ECMAScript 2022 and 2023.

---

## ES2022 Features

### Class Fields

Public and private instance fields.

#### Public Fields

```javascript
// Old way - in constructor
class Counter {
  constructor() {
    this.count = 0;
  }
}

// ES2022 - class fields
class Counter {
  count = 0;  // Public field
  
  increment() {
    this.count++;
  }
}

const counter = new Counter();
console.log(counter.count);  // 0
counter.increment();
console.log(counter.count);  // 1

// With initial values
class User {
  role = 'guest';
  createdAt = new Date();
  permissions = [];
  
  constructor(name) {
    this.name = name;
  }
}

const user = new User('John');
console.log(user.role);        // 'guest'
console.log(user.permissions); // []
```

#### Private Fields

```javascript
// Private fields start with #
class BankAccount {
  #balance = 0;  // Private field
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      return amount;
    }
    return 0;
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance());  // 100
console.log(account.#balance);      // SyntaxError: Private field

// Multiple private fields
class Person {
  #name;
  #age;
  #ssn;
  
  constructor(name, age, ssn) {
    this.#name = name;
    this.#age = age;
    this.#ssn = ssn;
  }
  
  getName() {
    return this.#name;
  }
  
  // Private fields completely encapsulated
  getInfo() {
    return `${this.#name}, ${this.#age}`;
  }
}

const person = new Person('John', 30, '123-45-6789');
console.log(person.getName());  // 'John'
console.log(person.#name);      // SyntaxError
```

### Private Methods

```javascript
class DataProcessor {
  #data = [];
  
  // Private method
  #validate(item) {
    return item && typeof item === 'object';
  }
  
  // Private getter
  get #dataSize() {
    return this.#data.length;
  }
  
  // Public method using private method
  add(item) {
    if (this.#validate(item)) {
      this.#data.push(item);
      return true;
    }
    return false;
  }
  
  get size() {
    return this.#dataSize;
  }
}

const processor = new DataProcessor();
processor.add({ id: 1 });
console.log(processor.size);  // 1
console.log(processor.#validate({ id: 2 }));  // SyntaxError
```

### Static Class Fields

```javascript
class MathUtils {
  // Static public field
  static PI = 3.14159;
  static E = 2.71828;
  
  // Static private field
  static #instances = 0;
  
  constructor() {
    MathUtils.#instances++;
  }
  
  static getInstanceCount() {
    return MathUtils.#instances;
  }
  
  static circleArea(radius) {
    return MathUtils.PI * radius ** 2;
  }
}

console.log(MathUtils.PI);  // 3.14159
console.log(MathUtils.circleArea(5));  // 78.54

const m1 = new MathUtils();
const m2 = new MathUtils();
console.log(MathUtils.getInstanceCount());  // 2
```

### Static Initialization Blocks

```javascript
class Config {
  static #config;
  
  // Static initialization block
  static {
    // Complex initialization logic
    try {
      const data = localStorage.getItem('config');
      this.#config = data ? JSON.parse(data) : {};
    } catch {
      this.#config = {};
    }
    
    // Set defaults
    this.#config.theme ??= 'light';
    this.#config.lang ??= 'en';
  }
  
  static get(key) {
    return this.#config[key];
  }
  
  static set(key, value) {
    this.#config[key] = value;
    localStorage.setItem('config', JSON.stringify(this.#config));
  }
}

console.log(Config.get('theme'));  // 'light'
Config.set('theme', 'dark');

// Multiple static blocks
class Logger {
  static #level;
  static #handlers = [];
  
  static {
    // Initialize log level
    this.#level = process.env.LOG_LEVEL || 'info';
  }
  
  static {
    // Initialize handlers
    if (typeof console !== 'undefined') {
      this.#handlers.push(console.log);
    }
  }
}
```

### Top-Level await

Use await at the top level of modules.

```javascript
// config.js - load config before module exports
const response = await fetch('/api/config');
const config = await response.json();

export default config;

// db.js - connect to database
const connection = await connectToDatabase();

export { connection };

// main.js - use modules
import config from './config.js';
import { connection } from './db.js';

console.log(config.apiUrl);
await connection.query('SELECT * FROM users');

// Conditional imports
const locale = await detectLocale();
const messages = await import(`./i18n/${locale}.js`);

// Dynamic configuration
const env = process.env.NODE_ENV;
const config = await import(`./config.${env}.js`);

// Error handling
let db;
try {
  db = await connectToDatabase();
} catch (error) {
  console.error('Failed to connect to database');
  db = await connectToFallbackDatabase();
}

export { db };
```

### at() Method

Access array/string elements with negative indices.

```javascript
// Arrays
const arr = [1, 2, 3, 4, 5];

// Old way
console.log(arr[arr.length - 1]);  // 5 (last element)
console.log(arr[arr.length - 2]);  // 4 (second to last)

// ES2022 - at() method
console.log(arr.at(-1));   // 5 (last element)
console.log(arr.at(-2));   // 4 (second to last)
console.log(arr.at(0));    // 1 (first element)
console.log(arr.at(2));    // 3 (third element)
console.log(arr.at(10));   // undefined (out of bounds)

// Strings
const str = 'hello';
console.log(str.at(-1));   // 'o'
console.log(str.at(-2));   // 'l'
console.log(str.at(0));    // 'h'

// TypedArray
const bytes = new Uint8Array([1, 2, 3, 4]);
console.log(bytes.at(-1)); // 4

// Practical examples
function getLast(arr) {
  return arr.at(-1);
}

function getSecondToLast(arr) {
  return arr.at(-2);
}

// Navigate from end
const logs = ['log1', 'log2', 'log3', 'log4'];
console.log(logs.at(-1));  // Most recent: 'log4'
console.log(logs.at(-2));  // Previous: 'log3'

// Chain with other methods
const result = [1, 2, 3, 4, 5]
  .filter(x => x % 2 === 0)
  .at(-1);
console.log(result);  // 4 (last even number)
```

### Object.hasOwn()

Safer alternative to hasOwnProperty.

```javascript
// Old way - can be overridden
const obj = { name: 'John' };
console.log(obj.hasOwnProperty('name'));  // true

// Problem with hasOwnProperty
const obj2 = Object.create(null);
obj2.name = 'Jane';
console.log(obj2.hasOwnProperty('name'));  // TypeError!

// ES2022 - Object.hasOwn()
console.log(Object.hasOwn(obj, 'name'));    // true
console.log(Object.hasOwn(obj2, 'name'));   // true (works!)

// Safer property checks
const obj = {
  hasOwnProperty: 'custom value'  // Overridden!
};

console.log(obj.hasOwnProperty('name'));    // Error
console.log(Object.hasOwn(obj, 'name'));    // false (works!)

// Practical examples
function hasProperty(obj, prop) {
  return Object.hasOwn(obj, prop);
}

// Check before accessing
if (Object.hasOwn(config, 'timeout')) {
  console.log(config.timeout);
}

// Filter object properties
function filterOwnProps(obj, keys) {
  return keys.filter(key => Object.hasOwn(obj, key));
}

// Safe property iteration
for (const key in obj) {
  if (Object.hasOwn(obj, key)) {
    console.log(key, obj[key]);
  }
}
```

### Error.cause

Chain error contexts.

```javascript
// Old way
try {
  await fetchData();
} catch (error) {
  throw new Error('Failed to load data: ' + error.message);
}

// ES2022 - preserve original error
try {
  await fetchData();
} catch (error) {
  throw new Error('Failed to load data', { cause: error });
}

// Access cause
try {
  await processUser();
} catch (error) {
  console.log(error.message);        // 'Failed to load data'
  console.log(error.cause.message);  // Original error message
  console.log(error.cause.stack);    // Original stack trace
}

// Practical examples
// Nested error handling
async function loadUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    throw new Error(`Failed to load user ${userId}`, { cause: error });
  }
}

async function processUser(userId) {
  try {
    const user = await loadUserData(userId);
    return processData(user);
  } catch (error) {
    throw new Error('User processing failed', { cause: error });
  }
}

// Detailed error logging
try {
  await processUser(123);
} catch (error) {
  console.error(error.message);  // 'User processing failed'
  
  let cause = error.cause;
  while (cause) {
    console.error('  Caused by:', cause.message);
    cause = cause.cause;
  }
}

// Custom error classes
class ValidationError extends Error {
  constructor(message, field, { cause } = {}) {
    super(message, { cause });
    this.name = 'ValidationError';
    this.field = field;
  }
}

throw new ValidationError('Invalid email', 'email', {
  cause: new Error('Missing @ symbol')
});
```

### RegExp Match Indices

Get start/end positions of matches.

```javascript
// Enable with d flag
const regex = /test(\d+)/d;
const str = 'foo test123 bar';
const match = str.match(regex);

console.log(match.indices);
/*
[
  [4, 11],    // Full match: 'test123'
  [8, 11]     // Group 1: '123'
]
*/

console.log(match.indices[0]);  // [4, 11]
console.log(str.slice(4, 11));  // 'test123'

// With named groups
const regex = /(?<word>\w+):(?<num>\d+)/d;
const match = 'test:123'.match(regex);

console.log(match.indices.groups.word);  // [0, 4]
console.log(match.indices.groups.num);   // [5, 8]

// Practical example - syntax highlighting
function highlight(code) {
  const regex = /(?<keyword>function|const|let)\s+(?<name>\w+)/dg;
  const matches = [...code.matchAll(regex)];
  
  let highlighted = code;
  matches.reverse().forEach(match => {
    const { keyword, name } = match.indices.groups;
    
    // Replace keyword
    const [kStart, kEnd] = keyword;
    highlighted = 
      highlighted.slice(0, kStart) +
      `<span class="keyword">${code.slice(kStart, kEnd)}</span>` +
      highlighted.slice(kEnd);
  });
  
  return highlighted;
}
```

---

## ES2023 Features

### Array Find from Last

Find elements searching from the end.

#### findLast()

```javascript
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// find - searches from start
console.log(numbers.find(n => n > 3));  // 4 (first match)

// findLast - searches from end
console.log(numbers.findLast(n => n > 3));  // 4 (last match)

// Practical examples
// Get most recent item
const logs = [
  { level: 'info', msg: 'Start' },
  { level: 'error', msg: 'Failed' },
  { level: 'info', msg: 'Retry' },
  { level: 'error', msg: 'Failed again' }
];

const lastError = logs.findLast(log => log.level === 'error');
console.log(lastError);  // { level: 'error', msg: 'Failed again' }

// Get latest version
const versions = [
  { version: '1.0.0', stable: true },
  { version: '1.1.0', stable: false },
  { version: '1.0.1', stable: true }
];

const latestStable = versions.findLast(v => v.stable);
console.log(latestStable);  // { version: '1.0.1', stable: true }
```

#### findLastIndex()

```javascript
const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];

// findIndex - searches from start
console.log(numbers.findIndex(n => n > 3));  // 3

// findLastIndex - searches from end
console.log(numbers.findLastIndex(n => n > 3));  // 5

// Practical example
const users = ['admin', 'user', 'guest', 'admin', 'user'];
const lastAdminIndex = users.findLastIndex(u => u === 'admin');
console.log(lastAdminIndex);  // 3

// Remove all after last match
const lastErrorIndex = logs.findLastIndex(log => log.level === 'error');
const recentLogs = logs.slice(lastErrorIndex);
```

### toSorted(), toReversed(), toSpliced()

Array methods that return new arrays (non-mutating).

#### toSorted()

```javascript
const numbers = [3, 1, 4, 1, 5];

// sort - mutates original
const sorted1 = numbers.sort();
console.log(sorted1);   // [1, 1, 3, 4, 5]
console.log(numbers);   // [1, 1, 3, 4, 5] (mutated!)

// toSorted - returns new array
const original = [3, 1, 4, 1, 5];
const sorted2 = original.toSorted();
console.log(sorted2);   // [1, 1, 3, 4, 5]
console.log(original);  // [3, 1, 4, 1, 5] (unchanged!)

// With comparator
const users = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 },
  { name: 'Bob', age: 35 }
];

const byAge = users.toSorted((a, b) => a.age - b.age);
// users unchanged, byAge is sorted copy
```

#### toReversed()

```javascript
const numbers = [1, 2, 3, 4, 5];

// reverse - mutates
const reversed1 = numbers.reverse();
console.log(reversed1);  // [5, 4, 3, 2, 1]
console.log(numbers);    // [5, 4, 3, 2, 1] (mutated!)

// toReversed - returns new
const original = [1, 2, 3, 4, 5];
const reversed2 = original.toReversed();
console.log(reversed2);  // [5, 4, 3, 2, 1]
console.log(original);   // [1, 2, 3, 4, 5] (unchanged!)
```

#### toSpliced()

```javascript
const numbers = [1, 2, 3, 4, 5];

// splice - mutates
const removed1 = numbers.splice(2, 1, 99);
console.log(numbers);  // [1, 2, 99, 4, 5] (mutated!)

// toSpliced - returns new
const original = [1, 2, 3, 4, 5];
const modified = original.toSpliced(2, 1, 99);
console.log(modified);  // [1, 2, 99, 4, 5]
console.log(original);  // [1, 2, 3, 4, 5] (unchanged!)

// Remove elements
const arr = [1, 2, 3, 4, 5];
const removed = arr.toSpliced(2, 2);  // Remove 2 elements at index 2
console.log(removed);  // [1, 2, 5]

// Insert elements
const inserted = arr.toSpliced(2, 0, 99, 100);  // Insert at index 2
console.log(inserted);  // [1, 2, 99, 100, 3, 4, 5]
```

### with() Method

Copy array with one element changed.

```javascript
const numbers = [1, 2, 3, 4, 5];

// Old way - mutating
numbers[2] = 99;
console.log(numbers);  // [1, 2, 99, 4, 5]

// ES2023 - immutable
const original = [1, 2, 3, 4, 5];
const modified = original.with(2, 99);
console.log(modified);  // [1, 2, 99, 4, 5]
console.log(original);  // [1, 2, 3, 4, 5] (unchanged!)

// Negative indices
const arr = [1, 2, 3, 4, 5];
const updated = arr.with(-1, 99);  // Last element
console.log(updated);  // [1, 2, 3, 4, 99]

// Practical examples
// Update state immutably
const todos = [
  { id: 1, text: 'Task 1', done: false },
  { id: 2, text: 'Task 2', done: false },
  { id: 3, text: 'Task 3', done: false }
];

// Toggle todo at index 1
const updatedTodos = todos.with(1, { ...todos[1], done: true });

// Chain with other methods
const result = [1, 2, 3, 4, 5]
  .with(2, 99)
  .toReversed()
  .toSorted();
```

### Hashbang Comments

Shebang for JavaScript files.

```javascript
#!/usr/bin/env node

// Rest of the file
console.log('This is a Node.js script');

// Makes file executable
// chmod +x script.js
// ./script.js
```

### Symbols as WeakMap Keys

Use symbols in WeakMaps.

```javascript
// ES2023 - symbols allowed
const weak = new WeakMap();

const sym = Symbol('key');
const obj = {};

weak.set(sym, 'value');
console.log(weak.get(sym));  // 'value'

// Useful for symbol-based metadata
const metadata = new WeakMap();

const PRIVATE_DATA = Symbol('private');

class User {
  constructor(name) {
    this.name = name;
    metadata.set(PRIVATE_DATA, { ssn: '123-45-6789' });
  }
}
```

---

## Practical Examples

### Immutable State Management

```javascript
class Store {
  #state = [];
  
  add(item) {
    this.#state = [...this.#state, item];
  }
  
  removeAt(index) {
    this.#state = this.#state.toSpliced(index, 1);
  }
  
  updateAt(index, item) {
    this.#state = this.#state.with(index, item);
  }
  
  sort(comparator) {
    this.#state = this.#state.toSorted(comparator);
  }
  
  getState() {
    return this.#state;
  }
}

const store = new Store();
store.add({ id: 1, name: 'Item 1' });
store.add({ id: 2, name: 'Item 2' });
store.updateAt(0, { id: 1, name: 'Updated' });
```

### Advanced Error Handling

```javascript
class AppError extends Error {
  #context = {};
  
  constructor(message, { cause, context } = {}) {
    super(message, { cause });
    this.name = 'AppError';
    this.#context = context || {};
  }
  
  get context() {
    return this.#context;
  }
  
  static wrap(error, message, context) {
    return new AppError(message, {
      cause: error,
      context
    });
  }
}

async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    return await response.json();
  } catch (error) {
    throw AppError.wrap(error, 'Failed to fetch user', { userId: id });
  }
}
```

---

## Key Takeaways

### ES2022
- **Class fields**: Public and private instance fields
- **Private methods**: # prefix for private members
- **Static fields/blocks**: Static class initialization
- **Top-level await**: await at module top level
- **at() method**: Negative indices for arrays/strings
- **Object.hasOwn()**: Safer property checks
- **Error.cause**: Chain error contexts
- **Match indices**: Regex match positions

### ES2023
- **findLast/findLastIndex()**: Search from array end
- **toSorted/toReversed/toSpliced()**: Immutable array methods
- **with()**: Immutable element update
- **Hashbang**: #!/usr/bin/env node support
- **Symbols in WeakMap**: Symbol keys allowed
- Use private fields for true encapsulation
- Prefer immutable array methods for state management
- Use Error.cause for error context chaining
