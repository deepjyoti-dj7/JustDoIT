# Quantifiers

Quantifiers specify how many times a pattern should match.

---

## Basic Quantifiers

### * (Zero or More)

```javascript
const regex = /ab*/;

console.log(regex.test('a'));      // true (zero b's)
console.log(regex.test('ab'));     // true (one b)
console.log(regex.test('abbb'));   // true (multiple b's)
console.log(regex.test('b'));      // false (needs 'a')

// Match any number of digits
const digits = /\d*/;
console.log(''.match(digits));     // [''] (zero digits)
console.log('123'.match(digits));  // ['123']
```

### + (One or More)

```javascript
const regex = /ab+/;

console.log(regex.test('a'));      // false (needs at least one b)
console.log(regex.test('ab'));     // true
console.log(regex.test('abbb'));   // true

// Match one or more digits
const numbers = '42 cats and 7 dogs'.match(/\d+/g);
console.log(numbers);  // ['42', '7']
```

### ? (Zero or One)

```javascript
const regex = /colou?r/;

console.log(regex.test('color'));   // true (zero u)
console.log(regex.test('colour'));  // true (one u)
console.log(regex.test('colouur')); // false (more than one u)

// Optional 's'
const plural = /cats?/;
console.log(plural.test('cat'));    // true
console.log(plural.test('cats'));   // true
```

---

## Specific Quantifiers {n,m}

### Exact Count {n}

```javascript
const regex = /\d{3}/;

console.log(regex.test('12'));     // false
console.log(regex.test('123'));    // true
console.log(regex.test('1234'));   // true (contains 123)

// Phone number area code
const areaCode = /\d{3}-\d{3}-\d{4}/;
console.log(areaCode.test('123-456-7890'));  // true
```

### Range {n,m}

```javascript
const regex = /\d{2,4}/;

console.log(regex.test('1'));      // false
console.log(regex.test('12'));     // true (2 digits)
console.log(regex.test('123'));    // true (3 digits)
console.log(regex.test('1234'));   // true (4 digits)
console.log(regex.test('12345'));  // true (contains 1234)

// Password: 8-20 characters
const password = /^.{8,20}$/;
console.log(password.test('short'));        // false
console.log(password.test('validpass'));    // true
```

### Minimum {n,}

```javascript
const regex = /\d{3,}/;

console.log(regex.test('12'));     // false
console.log(regex.test('123'));    // true
console.log(regex.test('1234'));   // true (more than 3)

// At least 8 characters
const minLength = /^.{8,}$/;
console.log(minLength.test('short'));    // false
console.log(minLength.test('longenough'));  // true
```

---

## Greedy vs Lazy

### Greedy (Default)

Matches as much as possible.

```javascript
const regex = /<.+>/;

const text = '<div>Hello</div>';
console.log(text.match(regex));
// ['<div>Hello</div>'] - matches entire string!

const multiple = '<a>link</a> <b>bold</b>';
console.log(multiple.match(regex));
// ['<a>link</a> <b>bold</b>'] - greedy!
```

### Lazy (Non-greedy) ?

Add `?` after quantifier to make it lazy.

```javascript
const regex = /<.+?>/;

const text = '<div>Hello</div>';
console.log(text.match(regex));
// ['<div>'] - stops at first >

const multiple = '<a>link</a> <b>bold</b>';
console.log(multiple.match(regex)[0]);
// '<a>' - matches minimally

// Get all tags
console.log(multiple.match(/<.+?>/g));
// ['<a>', '</a>', '<b>', '</b>']
```

---

## Lazy Quantifiers

```javascript
// Lazy versions
*?   // Zero or more (lazy)
+?   // One or more (lazy)
??   // Zero or one (lazy)
{n,m}?  // Range (lazy)
{n,}?   // Minimum (lazy)
```

### Examples

```javascript
// Extract text between quotes
const text = '"hello" and "world"';

// Greedy
console.log(text.match(/".*"/));
// ['"hello" and "world"'] - too much!

// Lazy
console.log(text.match(/".*?"/g));
// ['"hello"', '"world"'] - correct!
```

---

## Practical Examples

### Phone Number

```javascript
// Exactly 10 digits
const phone1 = /^\d{10}$/;
console.log(phone1.test('1234567890'));  // true

// With dashes
const phone2 = /^\d{3}-\d{3}-\d{4}$/;
console.log(phone2.test('123-456-7890'));  // true

// Flexible format
const phone3 = /^\d{3}-?\d{3}-?\d{4}$/;
console.log(phone3.test('1234567890'));      // true
console.log(phone3.test('123-456-7890'));    // true
```

### Zip Code

```javascript
// 5 digits or 5+4
const zip = /^\d{5}(-\d{4})?$/;

console.log(zip.test('12345'));       // true
console.log(zip.test('12345-6789'));  // true
console.log(zip.test('1234'));        // false
```

### Credit Card

```javascript
// 16 digits with optional spaces/dashes
const card = /^\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}$/;

console.log(card.test('1234567890123456'));         // true
console.log(card.test('1234-5678-9012-3456'));      // true
console.log(card.test('1234 5678 9012 3456'));      // true
```

### Password Validation

```javascript
// 8-20 characters
const length = /^.{8,20}$/;

// At least one digit
const hasDigit = /\d+/;

// At least one uppercase
const hasUpper = /[A-Z]+/;

// At least one lowercase
const hasLower = /[a-z]+/;

function validatePassword(pass) {
  return length.test(pass) &&
         hasDigit.test(pass) &&
         hasUpper.test(pass) &&
         hasLower.test(pass);
}

console.log(validatePassword('Short1'));        // false
console.log(validatePassword('ValidPass123'));  // true
```

### Extract Repeated Words

```javascript
const text = 'The the cat sat sat on the mat';
const repeated = /\b(\w+)\s+\1\b/gi;

console.log(text.match(repeated));
// ['The the', 'sat sat']
```

### HTML Comments

```javascript
// Greedy (wrong)
const greedy = /<!--.*-->/;
const html = '<!--comment1-->text<!--comment2-->';
console.log(html.match(greedy));
// ['<!--comment1-->text<!--comment2-->']

// Lazy (correct)
const lazy = /<!--.*?-->/g;
console.log(html.match(lazy));
// ['<!--comment1-->', '<!--comment2-->']
```

---

## Word Boundaries with Quantifiers

```javascript
// Match whole words of 3+ letters
const words = /\b\w{3,}\b/g;

const text = 'I am a developer with 10+ years of experience';
console.log(text.match(words));
// ['developer', 'with', '10', 'years', 'experience']
```

---

## Combining Quantifiers

```javascript
// URL pattern (simplified)
const url = /^https?:\/\/[\w.-]+\.\w{2,}(\/\S*)?$/;

console.log(url.test('https://example.com'));          // true
console.log(url.test('http://sub.example.com/path'));  // true

// Email (simplified)
const email = /^[\w.-]+@[\w.-]+\.\w{2,}$/;
console.log(email.test('user@example.com'));  // true
```

---

## Possessive Quantifiers

Not available in JavaScript, but understanding the concept:

```javascript
// JavaScript regex can backtrack
const regex = /\d+5/;
const text = '12345';

// Tries: 12345, then backtracks to 1234, finds 5
console.log(regex.test(text));  // true

// In some languages, possessive ++ prevents backtracking
// /\d++5/ would fail because \d++ consumes all digits
```

---

## Common Pitfalls

### Greedy by Default

```javascript
// ✗ Matches too much
const greedy = /<div>.*<\/div>/;
const html = '<div>1</div><div>2</div>';
console.log(html.match(greedy)[0]);
// '<div>1</div><div>2</div>'

// ✓ Use lazy
const lazy = /<div>.*?<\/div>/g;
console.log(html.match(lazy));
// ['<div>1</div>', '<div>2</div>']
```

### Forgetting Anchors

```javascript
// ✗ Matches partial strings
const partial = /\d{3}/;
console.log(partial.test('12345'));  // true (contains 3 digits)

// ✓ Use anchors for exact match
const exact = /^\d{3}$/;
console.log(exact.test('12345'));    // false
console.log(exact.test('123'));      // true
```

---

## Performance Considerations

### Catastrophic Backtracking

```javascript
// ✗ Can be very slow with long input
const bad = /(a+)+b/;

// ✓ Better
const good = /a+b/;
```

### Be Specific

```javascript
// ✗ Too general
const slow = /.*/;

// ✓ More specific
const fast = /\w+/;
```

---

## Best Practices

1. **Use lazy quantifiers for precision**
   ```javascript
   /".*?"/ instead of /".*"/
   ```

2. **Anchor patterns when possible**
   ```javascript
   /^\d{5}$/ for exact zip code
   ```

3. **Be specific about ranges**
   ```javascript
   /\w{3,10}/ instead of /\w+/
   ```

4. **Avoid nested quantifiers**
   ```javascript
   /(a+)+/ can cause performance issues
   ```

5. **Test with edge cases**
   ```javascript
   // Empty strings, very long strings, etc.
   ```

---

## Summary Table

| Quantifier | Meaning | Example |
|------------|---------|---------|
| `*` | 0 or more | `/ab*/` matches a, ab, abbb |
| `+` | 1 or more | `/ab+/` matches ab, abbb |
| `?` | 0 or 1 | `/colou?r/` matches color, colour |
| `{n}` | Exactly n | `/\d{3}/` matches 123 |
| `{n,}` | n or more | `/\d{3,}/` matches 123, 1234 |
| `{n,m}` | Between n and m | `/\d{2,4}/` matches 12, 123, 1234 |
| `*?` | Lazy 0 or more | `/<.*?>/` matches `<a>` not `<a>...<b>` |
| `+?` | Lazy 1 or more | Minimal match |
| `??` | Lazy 0 or 1 | Minimal match |

---

## Key Takeaways

- **`*`** = zero or more
- **`+`** = one or more
- **`?`** = zero or one
- **`{n}`** = exactly n times
- **`{n,m}`** = between n and m times
- **Greedy by default** - matches as much as possible
- **Add `?`** after quantifier for lazy matching
- **Use lazy** for HTML/XML parsing
- **Anchor patterns** for exact matches
- **Avoid nested quantifiers** for performance
- **Test edge cases** thoroughly
