# String Methods with Regex

JavaScript string methods that work with regular expressions for powerful text manipulation.

---

## test() - RegExp Method

Tests if a pattern matches a string. Returns `true` or `false`.

```javascript
const pattern = /hello/i;

console.log(pattern.test('Hello World'));  // true
console.log(pattern.test('Hi there'));     // false

// Useful for validation
const isEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test('user@example.com');
console.log(isEmail);  // true
```

---

## exec() - RegExp Method

Executes a search and returns an array of match information or `null`.

```javascript
const pattern = /(\w+)@(\w+)\.(\w+)/;
const result = pattern.exec('user@example.com');

console.log(result[0]);  // 'user@example.com' (full match)
console.log(result[1]);  // 'user' (first group)
console.log(result[2]);  // 'example' (second group)
console.log(result[3]);  // 'com' (third group)
console.log(result.index);  // 0 (match position)
```

### Global Flag Behavior

```javascript
const pattern = /\d+/g;
const text = '10 apples, 20 oranges';

console.log(pattern.exec(text));  // ['10']
console.log(pattern.exec(text));  // ['20']
console.log(pattern.exec(text));  // null (no more matches)

// Pattern remembers position via lastIndex
console.log(pattern.lastIndex);  // 0 (reset after null)
```

### Loop Through All Matches

```javascript
const pattern = /\b\w+\b/g;
const text = 'Hello world';
let match;

while ((match = pattern.exec(text)) !== null) {
  console.log(`Found "${match[0]}" at index ${match.index}`);
}
// Found "Hello" at index 0
// Found "world" at index 6
```

---

## match() - String Method

Retrieves matches when matching a string against a regex.

### Without Global Flag

```javascript
const text = 'The year is 2024';
const pattern = /\d+/;

const result = text.match(pattern);
console.log(result[0]);     // '2024'
console.log(result.index);  // 12
console.log(result.input);  // 'The year is 2024'
```

### With Global Flag

```javascript
const text = '10 apples, 20 oranges, 30 bananas';
const pattern = /\d+/g;

const numbers = text.match(pattern);
console.log(numbers);  // ['10', '20', '30']
```

### With Capturing Groups

```javascript
const email = 'Contact: john@example.com';
const pattern = /(\w+)@(\w+)\.(\w+)/;

const [full, user, domain, tld] = email.match(pattern);
console.log(user);    // 'john'
console.log(domain);  // 'example'
console.log(tld);     // 'com'
```

### Practical Example - Extract URLs

```javascript
const text = 'Visit https://example.com and http://test.org';
const pattern = /https?:\/\/[\w.]+/g;

const urls = text.match(pattern);
console.log(urls);  // ['https://example.com', 'http://test.org']
```

---

## matchAll() - String Method

Returns an iterator of all matches including capturing groups.

```javascript
const text = 'john@example.com, jane@test.org';
const pattern = /(\w+)@(\w+)\.(\w+)/g;

const matches = text.matchAll(pattern);

for (const match of matches) {
  console.log(`Email: ${match[0]}`);
  console.log(`User: ${match[1]}`);
  console.log(`Domain: ${match[2]}.${match[3]}`);
}
// Email: john@example.com
// User: john
// Domain: example.com
// Email: jane@test.org
// User: jane
// Domain: test.org
```

### Convert to Array

```javascript
const text = 'Price: $10, $20, $30';
const pattern = /\$(\d+)/g;

const prices = [...text.matchAll(pattern)].map(match => match[1]);
console.log(prices);  // ['10', '20', '30']
```

---

## search() - String Method

Returns the index of the first match, or `-1` if not found.

```javascript
const text = 'The year is 2024';

console.log(text.search(/\d+/));      // 12
console.log(text.search(/[a-z]+/i));  // 0
console.log(text.search(/xyz/));      // -1
```

### Case-Insensitive Search

```javascript
const text = 'Hello World';

console.log(text.search(/world/));   // -1 (case-sensitive)
console.log(text.search(/world/i));  // 6 (case-insensitive)
```

### Find Position of Pattern

```javascript
function findPosition(text, pattern) {
  const index = text.search(pattern);
  return index === -1 ? 'Not found' : `Found at index ${index}`;
}

console.log(findPosition('abc123', /\d/));  // 'Found at index 3'
console.log(findPosition('abc', /\d/));     // 'Not found'
```

---

## replace() - String Method

Replaces matches with a new substring or the result of a function.

### Simple Replacement

```javascript
const text = 'Hello World';

console.log(text.replace(/World/, 'JavaScript'));  // 'Hello JavaScript'
console.log(text.replace(/hello/i, 'Hi'));         // 'Hi World'
```

### Global Replacement

```javascript
const text = 'foo bar foo baz';

console.log(text.replace(/foo/, 'qux'));   // 'qux bar foo baz' (first only)
console.log(text.replace(/foo/g, 'qux'));  // 'qux bar qux baz' (all)
```

### Using Capturing Groups

```javascript
const text = 'John Doe';

// $1, $2 refer to capturing groups
const reversed = text.replace(/(\w+) (\w+)/, '$2, $1');
console.log(reversed);  // 'Doe, John'
```

### Replacement Function

```javascript
const text = 'I have 2 apples and 5 oranges';

const result = text.replace(/\d+/g, (match) => {
  return parseInt(match) * 2;
});

console.log(result);  // 'I have 4 apples and 10 oranges'
```

### Named Capturing Groups

```javascript
const text = '2024-01-31';

const result = text.replace(
  /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/,
  '$<month>/$<day>/$<year>'
);

console.log(result);  // '01/31/2024'
```

### Practical Examples

```javascript
// Remove HTML tags
const html = '<p>Hello <b>World</b></p>';
const clean = html.replace(/<[^>]*>/g, '');
console.log(clean);  // 'Hello World'

// Mask credit card
const cc = '1234-5678-9012-3456';
const masked = cc.replace(/\d(?=\d{4})/g, '*');
console.log(masked);  // '****-****-****-3456'

// Format phone number
const phone = '1234567890';
const formatted = phone.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
console.log(formatted);  // '(123) 456-7890'

// Capitalize words
const text = 'hello world';
const capitalized = text.replace(/\b\w/g, char => char.toUpperCase());
console.log(capitalized);  // 'Hello World'
```

---

## replaceAll() - String Method

Replaces all matches without needing the global flag.

```javascript
const text = 'foo bar foo baz';

console.log(text.replaceAll('foo', 'qux'));  // 'qux bar qux baz'
console.log(text.replaceAll(/foo/g, 'qux')); // 'qux bar qux baz'

// Note: regex MUST have global flag for replaceAll()
// text.replaceAll(/foo/, 'qux');  // Error!
```

### With Function

```javascript
const text = 'Price: $10, $20, $30';

const result = text.replaceAll(/\$(\d+)/g, (match, price) => {
  return `$${parseInt(price) * 1.1}`;
});

console.log(result);  // 'Price: $11, $22, $33'
```

---

## split() - String Method

Splits a string into an array using a regex as delimiter.

### Basic Split

```javascript
const text = 'apple,banana;orange|grape';

const fruits = text.split(/[,;|]/);
console.log(fruits);  // ['apple', 'banana', 'orange', 'grape']
```

### With Whitespace

```javascript
const text = 'one   two    three';

const words = text.split(/\s+/);
console.log(words);  // ['one', 'two', 'three']
```

### Limit Results

```javascript
const text = 'a-b-c-d-e';

const parts = text.split(/-/, 3);
console.log(parts);  // ['a', 'b', 'c']
```

### Capturing Groups

```javascript
const text = 'hello world';

// Without capturing group
console.log(text.split(/\s/));   // ['hello', 'world']

// With capturing group (includes delimiter)
console.log(text.split(/(\s)/)); // ['hello', ' ', 'world']
```

### Practical Examples

```javascript
// Split by multiple delimiters
const csv = 'name,age;city|country';
const fields = csv.split(/[,;|]/);
console.log(fields);  // ['name', 'age', 'city', 'country']

// Split camelCase
const camel = 'camelCaseString';
const words = camel.split(/(?=[A-Z])/);
console.log(words);  // ['camel', 'Case', 'String']

// Split sentences
const text = 'First. Second! Third? Fourth.';
const sentences = text.split(/[.!?]\s*/);
console.log(sentences);  // ['First', 'Second', 'Third', 'Fourth', '']
```

---

## Combining Methods

### Validation and Extraction

```javascript
function parseEmail(email) {
  const pattern = /^([^@]+)@([^@]+)$/;
  
  if (!pattern.test(email)) {
    return null;
  }
  
  const [, username, domain] = email.match(pattern);
  return { username, domain };
}

console.log(parseEmail('john@example.com'));
// { username: 'john', domain: 'example.com' }
```

### Clean and Format

```javascript
function formatPhone(phone) {
  // Remove all non-digits
  const cleaned = phone.replace(/\D/g, '');
  
  // Format as (XXX) XXX-XXXX
  return cleaned.replace(/(\d{3})(\d{3})(\d{4})/, '($1) $2-$3');
}

console.log(formatPhone('1234567890'));       // '(123) 456-7890'
console.log(formatPhone('(123) 456-7890'));   // '(123) 456-7890'
console.log(formatPhone('123.456.7890'));     // '(123) 456-7890'
```

### Search and Replace

```javascript
function highlightWords(text, search) {
  const pattern = new RegExp(`\\b${search}\\b`, 'gi');
  
  return text.replace(pattern, match => `<mark>${match}</mark>`);
}

const text = 'JavaScript is great. I love JavaScript!';
console.log(highlightWords(text, 'JavaScript'));
// '<mark>JavaScript</mark> is great. I love <mark>JavaScript</mark>!'
```

---

## Performance Considerations

### Cache Regex Patterns

```javascript
// Bad - creates new regex each time
function validate(text) {
  return /^[a-z]+$/.test(text);
}

// Good - reuse regex
const pattern = /^[a-z]+$/;
function validate(text) {
  return pattern.test(text);
}
```

### Reset lastIndex for Global Patterns

```javascript
const pattern = /\d+/g;

console.log(pattern.test('123'));  // true
console.log(pattern.lastIndex);    // 3

// Reset before reuse
pattern.lastIndex = 0;
console.log(pattern.test('456'));  // true
```

---

## Common Pitfalls

### Global Flag State

```javascript
const pattern = /\d+/g;

console.log(pattern.test('123'));  // true
console.log(pattern.test('123'));  // false (lastIndex moved!)

// Solution: reset or create new regex
pattern.lastIndex = 0;
```

### Escaping Special Characters

```javascript
// User input might contain special regex characters
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

const userInput = 'example.com';
const pattern = new RegExp(escapeRegex(userInput));

console.log(pattern.test('example.com'));   // true
console.log(pattern.test('exampleXcom'));   // false
```

### replaceAll Requires Global Flag

```javascript
const text = 'foo bar foo';

// Works
text.replaceAll(/foo/g, 'baz');

// Throws error
// text.replaceAll(/foo/, 'baz');
```

---

## Best Practices

```javascript
// 1. Use test() for simple checks
if (/^\d+$/.test(input)) {
  // input is all digits
}

// 2. Use match() for extraction
const numbers = text.match(/\d+/g) || [];

// 3. Use replace() for transformation
const cleaned = text.replace(/\s+/g, ' ').trim();

// 4. Use split() for parsing
const fields = csv.split(/,(?=(?:[^"]*"[^"]*")*[^"]*$)/);

// 5. Combine for complex operations
function extractEmails(text) {
  const pattern = /\b[^\s@]+@[^\s@]+\.[^\s@]+\b/g;
  return text.match(pattern) || [];
}
```

---

## Key Takeaways

- **test()**: Boolean check, fast for validation
- **exec()**: Detailed match info, good for iteration
- **match()**: Extract matches, simple for arrays
- **matchAll()**: Iterator for all matches with groups
- **search()**: Find position of first match
- **replace()**: Transform text, supports functions
- **replaceAll()**: Replace all without global flag (but regex needs it)
- **split()**: Parse strings with complex delimiters
- Cache patterns for better performance
- Reset `lastIndex` for global patterns
- Escape user input when using in regex
