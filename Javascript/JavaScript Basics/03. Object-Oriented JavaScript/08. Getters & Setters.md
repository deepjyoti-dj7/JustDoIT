# Getters & Setters

Getters and setters are special methods that provide controlled access to object properties. They allow you to run code when getting or setting a property value.

---

## Basic Syntax

### Defining Getters
```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  // Getter - accessed like a property
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}

const person = new Person("John", "Doe");
console.log(person.fullName);  // "John Doe" (no parentheses!)
```

### Defining Setters
```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  // Setter - set like a property
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
}

const person = new Person("John", "Doe");
console.log(person.fullName);  // "John Doe"

person.fullName = "Jane Smith";  // Uses setter
console.log(person.firstName);   // "Jane"
console.log(person.lastName);    // "Smith"
```

---

## Object Literal Syntax

```javascript
const user = {
  firstName: "John",
  lastName: "Doe",
  
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },
  
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
};

console.log(user.fullName);  // "John Doe"
user.fullName = "Jane Smith";
console.log(user.firstName);  // "Jane"
```

---

## Computed Properties

### Read-Only Computed Values
```javascript
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  
  get area() {
    return this.width * this.height;
  }
  
  get perimeter() {
    return 2 * (this.width + this.height);
  }
  
  get diagonal() {
    return Math.sqrt(this.width ** 2 + this.height ** 2);
  }
}

const rect = new Rectangle(10, 5);
console.log(rect.area);       // 50
console.log(rect.perimeter);  // 30
console.log(rect.diagonal);   // 11.18

rect.width = 20;
console.log(rect.area);       // 100 (auto-updated!)
```

### Cached Computed Values
```javascript
class Circle {
  constructor(radius) {
    this._radius = radius;
    this._areaCache = null;
  }
  
  get radius() {
    return this._radius;
  }
  
  set radius(value) {
    this._radius = value;
    this._areaCache = null;  // Invalidate cache
  }
  
  get area() {
    if (this._areaCache === null) {
      console.log("Computing area...");
      this._areaCache = Math.PI * this._radius ** 2;
    }
    return this._areaCache;
  }
}

const circle = new Circle(5);
console.log(circle.area);  // "Computing area..." then 78.54
console.log(circle.area);  // 78.54 (cached, no computation)

circle.radius = 10;
console.log(circle.area);  // "Computing area..." then 314.16
```

---

## Validation with Setters

### Input Validation
```javascript
class User {
  #age;
  #email;
  
  constructor(name, age, email) {
    this.name = name;
    this.age = age;      // Uses setter
    this.email = email;  // Uses setter
  }
  
  get age() {
    return this.#age;
  }
  
  set age(value) {
    if (value < 0 || value > 150) {
      throw new Error("Invalid age: must be between 0 and 150");
    }
    this.#age = value;
  }
  
  get email() {
    return this.#email;
  }
  
  set email(value) {
    if (!value.includes('@')) {
      throw new Error("Invalid email format");
    }
    this.#email = value.toLowerCase();
  }
}

const user = new User("John", 30, "JOHN@EXAMPLE.COM");
console.log(user.email);  // "john@example.com" (normalized)

user.age = 31;    // ✓ Valid
user.age = -5;    // ✗ Error: Invalid age
user.email = "invalid";  // ✗ Error: Invalid email format
```

### Range Validation
```javascript
class Temperature {
  #celsius;
  
  constructor(celsius = 0) {
    this.celsius = celsius;  // Uses setter
  }
  
  get celsius() {
    return this.#celsius;
  }
  
  set celsius(value) {
    if (value < -273.15) {
      throw new Error("Temperature below absolute zero");
    }
    this.#celsius = value;
  }
  
  get fahrenheit() {
    return (this.#celsius * 9/5) + 32;
  }
  
  set fahrenheit(value) {
    this.celsius = (value - 32) * 5/9;
  }
  
  get kelvin() {
    return this.#celsius + 273.15;
  }
  
  set kelvin(value) {
    this.celsius = value - 273.15;
  }
}

const temp = new Temperature(25);
console.log(temp.celsius);     // 25
console.log(temp.fahrenheit);  // 77

temp.fahrenheit = 32;
console.log(temp.celsius);     // 0

temp.celsius = -300;  // Error: Temperature below absolute zero
```

---

## Data Transformation

### Formatting
```javascript
class PhoneNumber {
  #number;
  
  get number() {
    return this.#number;
  }
  
  set number(value) {
    // Remove all non-digits
    const cleaned = value.replace(/\D/g, '');
    if (cleaned.length !== 10) {
      throw new Error("Phone number must be 10 digits");
    }
    this.#number = cleaned;
  }
  
  get formatted() {
    return `(${this.#number.slice(0,3)}) ${this.#number.slice(3,6)}-${this.#number.slice(6)}`;
  }
  
  get international() {
    return `+1-${this.#number.slice(0,3)}-${this.#number.slice(3,6)}-${this.#number.slice(6)}`;
  }
}

const phone = new PhoneNumber();
phone.number = "123-456-7890";
console.log(phone.formatted);       // "(123) 456-7890"
console.log(phone.international);   // "+1-123-456-7890"
```

### Type Conversion
```javascript
class Product {
  #price;
  
  get price() {
    return this.#price;
  }
  
  set price(value) {
    // Convert to number and validate
    const numValue = Number(value);
    if (isNaN(numValue) || numValue < 0) {
      throw new Error("Price must be a positive number");
    }
    this.#price = numValue;
  }
  
  get priceFormatted() {
    return `$${this.#price.toFixed(2)}`;
  }
}

const product = new Product();
product.price = "19.99";  // String converted to number
console.log(product.price);          // 19.99
console.log(product.priceFormatted); // "$19.99"
```

---

## Practical Examples

### 1. User Account with Status
```javascript
class Account {
  #balance = 0;
  #isActive = true;
  
  get balance() {
    if (!this.#isActive) {
      throw new Error("Account is inactive");
    }
    return this.#balance;
  }
  
  set balance(value) {
    if (!this.#isActive) {
      throw new Error("Account is inactive");
    }
    if (value < 0) {
      throw new Error("Balance cannot be negative");
    }
    this.#balance = value;
  }
  
  get isActive() {
    return this.#isActive;
  }
  
  get status() {
    return this.#isActive ? "Active" : "Inactive";
  }
  
  activate() {
    this.#isActive = true;
  }
  
  deactivate() {
    this.#isActive = false;
  }
  
  get balanceFormatted() {
    return `$${this.balance.toFixed(2)}`;
  }
}

const account = new Account();
account.balance = 1000;
console.log(account.balanceFormatted);  // "$1000.00"

account.deactivate();
console.log(account.balance);  // Error: Account is inactive
```

### 2. Date Range Validator
```javascript
class DateRange {
  #startDate;
  #endDate;
  
  get startDate() {
    return this.#startDate;
  }
  
  set startDate(value) {
    const date = new Date(value);
    if (this.#endDate && date > this.#endDate) {
      throw new Error("Start date must be before end date");
    }
    this.#startDate = date;
  }
  
  get endDate() {
    return this.#endDate;
  }
  
  set endDate(value) {
    const date = new Date(value);
    if (this.#startDate && date < this.#startDate) {
      throw new Error("End date must be after start date");
    }
    this.#endDate = date;
  }
  
  get duration() {
    if (!this.#startDate || !this.#endDate) return null;
    return this.#endDate - this.#startDate;
  }
  
  get durationDays() {
    if (!this.duration) return null;
    return Math.floor(this.duration / (1000 * 60 * 60 * 24));
  }
}

const range = new DateRange();
range.startDate = "2025-01-01";
range.endDate = "2025-01-10";
console.log(range.durationDays);  // 9

range.endDate = "2024-12-01";  // Error: End date must be after start date
```

### 3. Shopping Cart with Auto-Calculation
```javascript
class ShoppingCart {
  #items = [];
  #taxRate = 0.08;
  
  addItem(product, quantity, price) {
    this.#items.push({ product, quantity, price });
  }
  
  get items() {
    return [...this.#items];  // Return copy
  }
  
  get itemCount() {
    return this.#items.reduce((count, item) => count + item.quantity, 0);
  }
  
  get subtotal() {
    return this.#items.reduce((sum, item) => {
      return sum + (item.price * item.quantity);
    }, 0);
  }
  
  get tax() {
    return this.subtotal * this.#taxRate;
  }
  
  get total() {
    return this.subtotal + this.tax;
  }
  
  get taxRate() {
    return this.#taxRate;
  }
  
  set taxRate(value) {
    if (value < 0 || value > 1) {
      throw new Error("Tax rate must be between 0 and 1");
    }
    this.#taxRate = value;
  }
  
  getSummary() {
    return {
      itemCount: this.itemCount,
      subtotal: `$${this.subtotal.toFixed(2)}`,
      tax: `$${this.tax.toFixed(2)}`,
      total: `$${this.total.toFixed(2)}`
    };
  }
}

const cart = new ShoppingCart();
cart.addItem("Laptop", 1, 999.99);
cart.addItem("Mouse", 2, 29.99);

console.log(cart.getSummary());
// {
//   itemCount: 3,
//   subtotal: "$1059.97",
//   tax: "$84.80",
//   total: "$1144.77"
// }
```

---

## Lazy Loading

```javascript
class ExpensiveResource {
  #data = null;
  
  get data() {
    if (this.#data === null) {
      console.log("Loading expensive resource...");
      // Simulate expensive operation
      this.#data = Array(1000).fill(0).map((_, i) => i);
    }
    return this.#data;
  }
  
  clearCache() {
    this.#data = null;
  }
}

const resource = new ExpensiveResource();
// No loading yet

console.log(resource.data.length);  // "Loading..." then 1000
console.log(resource.data.length);  // 1000 (no loading, cached)

resource.clearCache();
console.log(resource.data.length);  // "Loading..." then 1000 (reloaded)
```

---

## Private Properties with Getters/Setters

```javascript
class Person {
  #firstName;
  #lastName;
  #age;
  
  constructor(firstName, lastName, age) {
    this.#firstName = firstName;
    this.#lastName = lastName;
    this.#age = age;
  }
  
  // Read-only properties
  get firstName() {
    return this.#firstName;
  }
  
  get lastName() {
    return this.#lastName;
  }
  
  // Read-write property with validation
  get age() {
    return this.#age;
  }
  
  set age(value) {
    if (value < 0 || value > 150) {
      throw new Error("Invalid age");
    }
    this.#age = value;
  }
  
  // Computed property
  get fullName() {
    return `${this.#firstName} ${this.#lastName}`;
  }
  
  get initials() {
    return `${this.#firstName[0]}${this.#lastName[0]}`;
  }
}

const person = new Person("John", "Doe", 30);
console.log(person.fullName);  // "John Doe"
console.log(person.initials);  // "JD"

person.#firstName = "Jane";  // SyntaxError: Private field
person.age = 31;             // ✓ Works through setter
```

---

## Best Practices

1. **Use getters for computed/derived values**
   ```javascript
   get fullName() {
     return `${this.firstName} ${this.lastName}`;
   }
   ```

2. **Validate in setters**
   ```javascript
   set age(value) {
     if (value < 0) throw new Error("Invalid age");
     this.#age = value;
   }
   ```

3. **Keep getters simple and fast**
   ```javascript
   // ✓ Good: Simple calculation
   get area() {
     return this.width * this.height;
   }
   
   // ✗ Avoid: Heavy computation
   get expensiveValue() {
     return this.heavyCalculation();  // Consider caching
   }
   ```

4. **Don't cause side effects in getters**
   ```javascript
   // ✗ Bad: Side effect
   get value() {
     this.counter++;  // Don't modify state
     return this.#value;
   }
   
   // ✓ Good: Pure getter
   get value() {
     return this.#value;
   }
   ```

5. **Use setters for validation and normalization**
   ```javascript
   set email(value) {
     if (!value.includes('@')) throw new Error("Invalid email");
     this.#email = value.toLowerCase();
   }
   ```

---

## Common Pitfalls

### 1. Infinite Recursion
```javascript
// ✗ Bad: Infinite loop
class Bad {
  get value() {
    return this.value;  // Calls itself!
  }
}

// ✓ Good: Use private field
class Good {
  #value;
  
  get value() {
    return this.#value;
  }
}
```

### 2. Heavy Computation Without Caching
```javascript
// ✗ Inefficient
get expensiveValue() {
  return this.items.reduce(...);  // Computed every time
}

// ✓ Better: Cache result
#cachedValue = null;

get expensiveValue() {
  if (this.#cachedValue === null) {
    this.#cachedValue = this.items.reduce(...);
  }
  return this.#cachedValue;
}
```

---

## Key Takeaways

- Getters provide controlled read access to properties
- Setters provide controlled write access with validation
- Access getters/setters like regular properties (no parentheses)
- Use getters for computed/derived values
- Use setters to validate and transform input
- Combine with private fields for true encapsulation
- Keep getters fast - cache expensive computations
- Don't cause side effects in getters
- Setters accept exactly one parameter
- Perfect for data validation, formatting, and lazy loading
