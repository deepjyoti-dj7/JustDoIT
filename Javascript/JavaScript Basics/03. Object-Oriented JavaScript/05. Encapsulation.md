# Encapsulation

Encapsulation is the bundling of data and methods that operate on that data within a single unit (object/class), while hiding internal implementation details and restricting direct access to some components.

---

## Why Encapsulation?

**Benefits:**
- **Data Protection**: Prevent unauthorized access and modification
- **Maintainability**: Change internal implementation without affecting external code
- **Validation**: Control how properties are set and retrieved
- **Abstraction**: Hide complexity, expose simple interface

---

## Public Properties (Default)

By default, all properties and methods are public.

```javascript
class User {
  constructor(name, age) {
    this.name = name;  // Public property
    this.age = age;    // Public property
  }
  
  greet() {  // Public method
    console.log(`Hi, I'm ${this.name}`);
  }
}

const user = new User("John", 30);
console.log(user.name);  // "John" - Direct access
user.age = -5;           // No protection!
console.log(user.age);   // -5
```

---

## Encapsulation with Closures (Pre-ES2022)

### Using Constructor Functions
```javascript
function BankAccount(initialBalance) {
  // Private variable (in closure)
  let balance = initialBalance;
  
  // Public methods (have access to private variable)
  this.deposit = function(amount) {
    if (amount > 0) {
      balance += amount;
      return true;
    }
    return false;
  };
  
  this.withdraw = function(amount) {
    if (amount > 0 && amount <= balance) {
      balance -= amount;
      return true;
    }
    return false;
  };
  
  this.getBalance = function() {
    return balance;
  };
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.balance);       // undefined - Private!

// Cannot directly modify balance
account.balance = 1000000;
console.log(account.getBalance());  // Still 150
```

### Using WeakMaps
```javascript
const _balance = new WeakMap();

class BankAccount {
  constructor(initialBalance) {
    _balance.set(this, initialBalance);
  }
  
  deposit(amount) {
    if (amount > 0) {
      const current = _balance.get(this);
      _balance.set(this, current + amount);
      return true;
    }
    return false;
  }
  
  getBalance() {
    return _balance.get(this);
  }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account._balance);      // undefined
```

---

## Private Fields (ES2022)

Modern JavaScript supports true private fields using `#`.

### Private Properties
```javascript
class BankAccount {
  #balance = 0;  // Private field
  
  constructor(initialBalance) {
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
      return true;
    }
    return false;
  }
  
  withdraw(amount) {
    if (amount > 0 && amount <= this.#balance) {
      this.#balance -= amount;
      return true;
    }
    return false;
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.#balance);      // SyntaxError: Private field
```

### Private Methods
```javascript
class User {
  #password;
  
  constructor(username, password) {
    this.username = username;
    this.#password = this.#hashPassword(password);
  }
  
  // Private method
  #hashPassword(password) {
    // Simple hash simulation
    return password.split('').reverse().join('') + "_hashed";
  }
  
  // Private validation method
  #validatePassword(password) {
    return this.#hashPassword(password) === this.#password;
  }
  
  // Public method using private methods
  login(password) {
    if (this.#validatePassword(password)) {
      console.log("Login successful");
      return true;
    }
    console.log("Invalid password");
    return false;
  }
  
  changePassword(oldPassword, newPassword) {
    if (this.#validatePassword(oldPassword)) {
      this.#password = this.#hashPassword(newPassword);
      return true;
    }
    return false;
  }
}

const user = new User("john", "secret123");
user.login("secret123");      // "Login successful"
console.log(user.#password);  // SyntaxError
console.log(user.#hashPassword("test"));  // SyntaxError
```

---

## Getters and Setters

Control access to properties with validation and computed values.

### Basic Getters/Setters
```javascript
class Person {
  #age;
  
  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }
  
  // Getter - read access
  get age() {
    return this.#age;
  }
  
  // Setter - write access with validation
  set age(value) {
    if (value < 0 || value > 150) {
      throw new Error("Invalid age");
    }
    this.#age = value;
  }
}

const person = new Person("John", 30);
console.log(person.age);  // 30 (uses getter)
person.age = 31;          // Uses setter
person.age = -5;          // Error: Invalid age
```

### Computed Properties
```javascript
class Rectangle {
  #width;
  #height;
  
  constructor(width, height) {
    this.#width = width;
    this.#height = height;
  }
  
  get width() {
    return this.#width;
  }
  
  set width(value) {
    if (value <= 0) throw new Error("Width must be positive");
    this.#width = value;
  }
  
  get height() {
    return this.#height;
  }
  
  set height(value) {
    if (value <= 0) throw new Error("Height must be positive");
    this.#height = value;
  }
  
  // Computed property (read-only)
  get area() {
    return this.#width * this.#height;
  }
  
  get perimeter() {
    return 2 * (this.#width + this.#height);
  }
}

const rect = new Rectangle(10, 5);
console.log(rect.area);       // 50 (computed)
console.log(rect.perimeter);  // 30 (computed)
rect.width = 20;
console.log(rect.area);       // 100 (auto-updated)
```

---

## Practical Examples

### 1. User Profile with Validation
```javascript
class UserProfile {
  #email;
  #age;
  #phoneNumber;
  
  constructor(name, email, age) {
    this.name = name;
    this.email = email;  // Uses setter
    this.age = age;      // Uses setter
  }
  
  get email() {
    return this.#email;
  }
  
  set email(value) {
    if (!value.includes('@')) {
      throw new Error("Invalid email format");
    }
    this.#email = value.toLowerCase();
  }
  
  get age() {
    return this.#age;
  }
  
  set age(value) {
    if (value < 0 || value > 150) {
      throw new Error("Invalid age");
    }
    this.#age = value;
  }
  
  get phoneNumber() {
    return this.#phoneNumber;
  }
  
  set phoneNumber(value) {
    // Remove non-digits
    const cleaned = value.replace(/\D/g, '');
    if (cleaned.length !== 10) {
      throw new Error("Phone number must be 10 digits");
    }
    this.#phoneNumber = cleaned;
  }
  
  // Format for display
  get formattedPhone() {
    if (!this.#phoneNumber) return null;
    return `(${this.#phoneNumber.slice(0,3)}) ${this.#phoneNumber.slice(3,6)}-${this.#phoneNumber.slice(6)}`;
  }
}

const profile = new UserProfile("John Doe", "JOHN@EXAMPLE.COM", 30);
console.log(profile.email);  // "john@example.com" (lowercased)
profile.phoneNumber = "123-456-7890";
console.log(profile.formattedPhone);  // "(123) 456-7890"
```

### 2. Temperature Converter
```javascript
class Temperature {
  #celsius;
  
  constructor(celsius) {
    this.#celsius = celsius;
  }
  
  get celsius() {
    return this.#celsius;
  }
  
  set celsius(value) {
    if (value < -273.15) {
      throw new Error("Temperature below absolute zero");
    }
    this.#celsius = value;
  }
  
  get fahrenheit() {
    return (this.#celsius * 9/5) + 32;
  }
  
  set fahrenheit(value) {
    this.celsius = (value - 32) * 5/9;  // Uses celsius setter for validation
  }
  
  get kelvin() {
    return this.#celsius + 273.15;
  }
  
  set kelvin(value) {
    this.celsius = value - 273.15;
  }
}

const temp = new Temperature(0);
console.log(temp.celsius);     // 0
console.log(temp.fahrenheit);  // 32
console.log(temp.kelvin);      // 273.15

temp.fahrenheit = 212;
console.log(temp.celsius);     // 100
```

### 3. Shopping Cart with Inventory
```javascript
class Product {
  #inventory;
  #price;
  
  constructor(name, price, inventory) {
    this.name = name;
    this.#price = price;
    this.#inventory = inventory;
  }
  
  get price() {
    return this.#price;
  }
  
  get inventory() {
    return this.#inventory;
  }
  
  get isInStock() {
    return this.#inventory > 0;
  }
  
  // Private method
  #reduceInventory(quantity) {
    if (quantity > this.#inventory) {
      throw new Error("Insufficient inventory");
    }
    this.#inventory -= quantity;
  }
  
  // Public interface
  purchase(quantity) {
    if (!this.isInStock) {
      throw new Error("Product out of stock");
    }
    this.#reduceInventory(quantity);
    return this.#price * quantity;
  }
}

class ShoppingCart {
  #items = [];
  #discountRate = 0;
  
  addItem(product, quantity) {
    this.#items.push({ product, quantity });
  }
  
  get total() {
    const subtotal = this.#items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
    return subtotal * (1 - this.#discountRate);
  }
  
  applyDiscount(rate) {
    if (rate < 0 || rate > 1) {
      throw new Error("Discount rate must be between 0 and 1");
    }
    this.#discountRate = rate;
  }
  
  checkout() {
    const total = this.total;
    
    // Process each purchase
    this.#items.forEach(({ product, quantity }) => {
      product.purchase(quantity);
    });
    
    this.#items = [];
    this.#discountRate = 0;
    
    return total;
  }
}
```

---

## Information Hiding Patterns

### 1. Revealing Module Pattern
```javascript
class Counter {
  #count = 0;
  #maxCount;
  
  constructor(maxCount = Infinity) {
    this.#maxCount = maxCount;
  }
  
  // Private helper
  #canIncrement() {
    return this.#count < this.#maxCount;
  }
  
  // Public interface
  increment() {
    if (this.#canIncrement()) {
      this.#count++;
      return true;
    }
    return false;
  }
  
  decrement() {
    if (this.#count > 0) {
      this.#count--;
      return true;
    }
    return false;
  }
  
  getValue() {
    return this.#count;
  }
  
  reset() {
    this.#count = 0;
  }
}
```

### 2. Read-Only Properties
```javascript
class Config {
  #apiKey;
  #createdAt;
  
  constructor(apiKey) {
    this.#apiKey = apiKey;
    this.#createdAt = new Date();
  }
  
  // Getter only - no setter (read-only)
  get apiKey() {
    return this.#apiKey;
  }
  
  get createdAt() {
    return new Date(this.#createdAt);  // Return copy to prevent modification
  }
}

const config = new Config("secret123");
console.log(config.apiKey);    // "secret123"
config.apiKey = "new";         // No effect (no setter)
console.log(config.apiKey);    // Still "secret123"
```

---

## Best Practices

1. **Make fields private by default**
   ```javascript
   class MyClass {
     #privateData;  // Private by default
     
     // Expose only through controlled methods
     getData() {
       return this.#privateData;
     }
   }
   ```

2. **Validate in setters**
   ```javascript
   set age(value) {
     if (value < 0) throw new Error("Invalid age");
     this.#age = value;
   }
   ```

3. **Use getters for computed properties**
   ```javascript
   get fullName() {
     return `${this.firstName} ${this.lastName}`;
   }
   ```

4. **Return copies of internal state**
   ```javascript
   getItems() {
     return [...this.#items];  // Return copy, not reference
   }
   ```

5. **Document public API**
   ```javascript
   /**
    * Deposits money into the account
    * @param {number} amount - Amount to deposit
    * @returns {boolean} Success status
    */
   deposit(amount) {
     // ...
   }
   ```

---

## Common Pitfalls

### 1. Forgetting # for Private Fields
```javascript
class Bad {
  balance = 0;  // ⚠️ Public, not private!
}

class Good {
  #balance = 0;  // ✓ Private
}
```

### 2. Returning Mutable Objects
```javascript
class Bad {
  #data = [1, 2, 3];
  
  getData() {
    return this.#data;  // ⚠️ External code can modify!
  }
}

class Good {
  #data = [1, 2, 3];
  
  getData() {
    return [...this.#data];  // ✓ Returns copy
  }
}
```

### 3. Over-Encapsulation
```javascript
// ✗ Too much encapsulation
class Point {
  #x; #y;
  getX() { return this.#x; }
  setX(v) { this.#x = v; }
  getY() { return this.#y; }
  setY(v) { this.#y = v; }
}

// ✓ Simple data structures can be public
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
```

---

## Key Takeaways

- Encapsulation hides internal implementation details
- Use `#` prefix for private fields and methods (ES2022+)
- Getters and setters provide controlled property access
- Validate data in setters to maintain consistency
- Use getters for computed/derived properties
- Return copies of internal state to prevent external modification
- Private fields cannot be accessed outside the class
- Encapsulation improves maintainability and reduces bugs
