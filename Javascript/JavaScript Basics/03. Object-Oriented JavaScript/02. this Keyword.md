# this Keyword

The `this` keyword refers to the context in which a function is called. Its value depends on HOW the function is invoked, not where it's defined.

---

## Global Context

### In Browser (Non-strict Mode)
```javascript
console.log(this);  // Window object

function show() {
  console.log(this);  // Window object
}
show();
```

### In Browser (Strict Mode)
```javascript
"use strict";

console.log(this);  // Window object

function show() {
  console.log(this);  // undefined
}
show();
```

### In Node.js
```javascript
console.log(this);  // {} (empty object in module scope)

function show() {
  console.log(this);  // global object
}
show();
```

---

## Object Methods

When a function is called as a method of an object, `this` refers to that object.

```javascript
const user = {
  name: "John",
  age: 30,
  
  greet() {
    console.log(`Hi, I'm ${this.name}`);
    console.log(this);  // user object
  }
};

user.greet();
// "Hi, I'm John"
// { name: "John", age: 30, greet: [Function] }
```

### Losing this Context
```javascript
const user = {
  name: "John",
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  }
};

user.greet();         // "Hi, I'm John" ✓

const greet = user.greet;
greet();              // "Hi, I'm undefined" ⚠️
// this is now global/undefined, not user
```

---

## Constructor Functions

In constructor functions, `this` refers to the newly created object.

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  
  this.greet = function() {
    console.log(`Hi, I'm ${this.name}`);
  };
}

const john = new Person("John", 30);
john.greet();  // "Hi, I'm John"
console.log(john.name);  // "John"
```

### What Happens with `new`
```javascript
function Person(name) {
  // 1. this = {} (new empty object created)
  // 2. this.__proto__ = Person.prototype
  this.name = name;
  // 3. return this (implicit)
}

const person = new Person("John");
```

### Forgetting `new` Keyword
```javascript
function Person(name) {
  this.name = name;  // this = global object ⚠️
}

const person = Person("John");  // Forgot 'new'
console.log(person);       // undefined
console.log(window.name);  // "John" (in browser) ⚠️
```

---

## Classes

In ES6 classes, `this` works similarly to constructor functions.

```javascript
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hi, I'm ${this.name}`);
  }
  
  birthday() {
    this.age++;
    console.log(`Now I'm ${this.age}`);
  }
}

const user = new User("John", 30);
user.greet();     // "Hi, I'm John"
user.birthday();  // "Now I'm 31"
```

---

## Arrow Functions

Arrow functions don't have their own `this` - they inherit from the enclosing scope (lexical `this`).

### Regular vs Arrow Functions
```javascript
const user = {
  name: "John",
  
  regularGreet: function() {
    console.log(this.name);  // "John"
  },
  
  arrowGreet: () => {
    console.log(this.name);  // undefined
    // 'this' is from outer scope, not user object
  }
};

user.regularGreet();  // "John"
user.arrowGreet();    // undefined
```

### Callbacks - Where Arrow Functions Shine
```javascript
const user = {
  name: "John",
  hobbies: ["reading", "coding"],
  
  // ✗ Problem with regular function
  showHobbiesWrong() {
    this.hobbies.forEach(function(hobby) {
      console.log(`${this.name} likes ${hobby}`);
      // this.name is undefined - this refers to global
    });
  },
  
  // ✓ Solution 1: Arrow function
  showHobbies() {
    this.hobbies.forEach((hobby) => {
      console.log(`${this.name} likes ${hobby}`);
      // Arrow function inherits 'this' from showHobbies
    });
  },
  
  // ✓ Solution 2: Save this reference
  showHobbiesOld() {
    const self = this;
    this.hobbies.forEach(function(hobby) {
      console.log(`${self.name} likes ${hobby}`);
    });
  }
};

user.showHobbies();
// "John likes reading"
// "John likes coding"
```

---

## Explicit Binding

You can explicitly set `this` using `call()`, `apply()`, or `bind()`.

### call()
```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}

const user = { name: "John" };

greet.call(user, "Hello", "!");
// "Hello, I'm John!"
```

### apply()
```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, I'm ${this.name}${punctuation}`);
}

const user = { name: "John" };

greet.apply(user, ["Hello", "!"]);
// "Hello, I'm John!"
// Same as call, but arguments as array
```

### bind()
```javascript
function greet(greeting) {
  console.log(`${greeting}, I'm ${this.name}`);
}

const user = { name: "John" };

const boundGreet = greet.bind(user);
boundGreet("Hello");  // "Hello, I'm John"

// Can also bind arguments
const boundHello = greet.bind(user, "Hello");
boundHello();  // "Hello, I'm John"
```

---

## Event Handlers

### Regular Function in Event Handler
```javascript
const button = document.querySelector("button");

button.addEventListener("click", function() {
  console.log(this);  // button element
  this.classList.toggle("active");  // ✓ Works
});
```

### Arrow Function in Event Handler
```javascript
button.addEventListener("click", () => {
  console.log(this);  // Window or outer scope
  this.classList.toggle("active");  // ✗ Error
});
```

### Using Arrow Function with Correct Context
```javascript
class ButtonHandler {
  constructor(element) {
    this.element = element;
    this.clickCount = 0;
    
    // Arrow function preserves class instance as 'this'
    this.element.addEventListener("click", () => {
      this.clickCount++;
      console.log(`Clicked ${this.clickCount} times`);
    });
  }
}

const handler = new ButtonHandler(button);
```

---

## Common Patterns & Solutions

### 1. Method as Callback
```javascript
class Timer {
  constructor() {
    this.seconds = 0;
  }
  
  start() {
    // ✗ Problem: 'this' will be undefined in setInterval
    // setInterval(this.tick, 1000);
    
    // ✓ Solution 1: Arrow function
    setInterval(() => this.tick(), 1000);
    
    // ✓ Solution 2: bind
    // setInterval(this.tick.bind(this), 1000);
  }
  
  tick() {
    this.seconds++;
    console.log(this.seconds);
  }
}
```

### 2. forEach/map with this
```javascript
const processor = {
  prefix: "Processed: ",
  
  process(items) {
    // ✓ Arrow function inherits 'this'
    return items.map(item => this.prefix + item);
    
    // ✗ Regular function needs bind
    // return items.map(function(item) {
    //   return this.prefix + item;
    // }.bind(this));
  }
};

processor.process(["A", "B", "C"]);
// ["Processed: A", "Processed: B", "Processed: C"]
```

### 3. Event Handler in Class
```javascript
class Counter {
  constructor() {
    this.count = 0;
    
    // ✓ Arrow function method preserves 'this'
    this.increment = () => {
      this.count++;
      this.render();
    };
  }
  
  render() {
    console.log(`Count: ${this.count}`);
  }
}

const counter = new Counter();
button.addEventListener("click", counter.increment);  // ✓ Works
```

---

## this in Different Contexts

### Nested Functions
```javascript
const obj = {
  name: "Object",
  
  outer() {
    console.log(this.name);  // "Object"
    
    function inner() {
      console.log(this.name);  // undefined (this is global)
    }
    inner();
    
    // ✓ Arrow function solution
    const innerArrow = () => {
      console.log(this.name);  // "Object"
    };
    innerArrow();
  }
};
```

### setTimeout/setInterval
```javascript
const user = {
  name: "John",
  
  greet() {
    // ✗ Regular function - loses 'this'
    setTimeout(function() {
      console.log(this.name);  // undefined
    }, 1000);
    
    // ✓ Arrow function - preserves 'this'
    setTimeout(() => {
      console.log(this.name);  // "John"
    }, 1000);
  }
};
```

---

## Determining this Value

The value of `this` follows these rules (in order of precedence):

1. **Arrow function**: Lexical `this` (from outer scope)
2. **new keyword**: New object being constructed
3. **call/apply/bind**: Explicitly set value
4. **Method call**: Object before the dot
5. **Regular function**: Global object (or undefined in strict mode)

```javascript
// 1. Arrow function
const arrow = () => console.log(this);  // Outer scope

// 2. new keyword
function Constructor() { console.log(this); }
new Constructor();  // New object

// 3. call/apply/bind
function fn() { console.log(this); }
fn.call({ x: 1 });  // { x: 1 }

// 4. Method call
const obj = { 
  fn() { console.log(this); }
};
obj.fn();  // obj

// 5. Regular function
function regular() { console.log(this); }
regular();  // Window/global/undefined
```

---

## Best Practices

1. **Use arrow functions for callbacks**
   ```javascript
   setTimeout(() => this.method(), 1000);
   array.map(item => this.process(item));
   ```

2. **Use regular methods for object methods**
   ```javascript
   const obj = {
     method() {  // ✓ Not arrow function
       console.log(this);
     }
   };
   ```

3. **Bind in constructor for event handlers**
   ```javascript
   class Component {
     constructor() {
       this.handleClick = this.handleClick.bind(this);
     }
   }
   ```

4. **Be explicit with bind when passing methods**
   ```javascript
   button.addEventListener("click", obj.method.bind(obj));
   ```

5. **Use strict mode to catch this bugs**
   ```javascript
   "use strict";
   // this will be undefined instead of global
   ```

---

## Key Takeaways

- `this` value depends on HOW a function is called, not WHERE it's defined
- Arrow functions don't have `this` - they use lexical scoping
- Method calls: `this` = object before the dot
- Constructor calls: `this` = newly created object
- Regular function calls: `this` = global object (or undefined in strict mode)
- Use `call`, `apply`, `bind` to explicitly set `this`
- Use arrow functions to preserve `this` in callbacks
- Be careful when extracting methods - they lose their context
