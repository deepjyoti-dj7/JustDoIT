# Inheritance

Inheritance allows classes to inherit properties and methods from other classes, promoting code reuse and establishing hierarchical relationships.

---

## Prototype-Based Inheritance (Pre-ES6)

### Constructor Function Inheritance
```javascript
// Parent constructor
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(`${this.name} is eating`);
};

// Child constructor
function Dog(name, breed) {
  Animal.call(this, name);  // Call parent constructor
  this.breed = breed;
}

// Set up prototype chain
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Add child methods
Dog.prototype.bark = function() {
  console.log(`${this.name} says woof!`);
};

const dog = new Dog("Buddy", "Golden Retriever");
dog.eat();   // "Buddy is eating" (inherited)
dog.bark();  // "Buddy says woof!"
```

---

## ES6 Class Inheritance

### Basic Inheritance with `extends`
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat() {
    console.log(`${this.name} is eating`);
  }
  
  sleep() {
    console.log(`${this.name} is sleeping`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);  // Call parent constructor
    this.breed = breed;
  }
  
  bark() {
    console.log(`${this.name} says woof!`);
  }
}

const dog = new Dog("Buddy", "Golden Retriever");
dog.eat();   // "Buddy is eating" (inherited)
dog.sleep(); // "Buddy is sleeping" (inherited)
dog.bark();  // "Buddy says woof!" (own method)
```

---

## The `super` Keyword

### Calling Parent Constructor
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

class Employee extends Person {
  constructor(name, age, jobTitle, salary) {
    super(name, age);  // Must call super before using 'this'
    this.jobTitle = jobTitle;
    this.salary = salary;
  }
}

const emp = new Employee("John", 30, "Developer", 75000);
console.log(emp.name);      // "John"
console.log(emp.jobTitle);  // "Developer"
```

### Calling Parent Methods
```javascript
class Animal {
  speak() {
    console.log("Animal makes a sound");
  }
}

class Dog extends Animal {
  speak() {
    super.speak();  // Call parent method
    console.log("Dog barks");
  }
}

const dog = new Dog();
dog.speak();
// "Animal makes a sound"
// "Dog barks"
```

---

## Method Overriding

Child classes can override parent methods.

```javascript
class Shape {
  constructor(color) {
    this.color = color;
  }
  
  getArea() {
    return 0;
  }
  
  describe() {
    return `A ${this.color} shape`;
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }
  
  // Override parent method
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  // Override and extend
  describe() {
    return `${super.describe()} with radius ${this.radius}`;
  }
}

const circle = new Circle("red", 5);
console.log(circle.getArea());    // 78.53981633974483
console.log(circle.describe());   // "A red shape with radius 5"
```

---

## Multi-Level Inheritance

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  breathe() {
    console.log(`${this.name} is breathing`);
  }
}

class Mammal extends Animal {
  constructor(name, furColor) {
    super(name);
    this.furColor = furColor;
  }
  
  feedMilk() {
    console.log(`${this.name} is feeding milk to babies`);
  }
}

class Dog extends Mammal {
  constructor(name, furColor, breed) {
    super(name, furColor);
    this.breed = breed;
  }
  
  bark() {
    console.log(`${this.name} barks!`);
  }
}

const dog = new Dog("Buddy", "golden", "Golden Retriever");
dog.breathe();   // From Animal
dog.feedMilk();  // From Mammal
dog.bark();      // From Dog
```

---

## Practical Examples

### 1. User Hierarchy
```javascript
class User {
  constructor(username, email) {
    this.username = username;
    this.email = email;
    this.createdAt = new Date();
  }
  
  login() {
    console.log(`${this.username} logged in`);
  }
  
  logout() {
    console.log(`${this.username} logged out`);
  }
}

class Admin extends User {
  constructor(username, email, permissions) {
    super(username, email);
    this.permissions = permissions;
    this.role = "admin";
  }
  
  deleteUser(user) {
    console.log(`Admin ${this.username} deleted user ${user.username}`);
  }
  
  grantPermission(user, permission) {
    console.log(`Granted ${permission} to ${user.username}`);
  }
}

class Moderator extends User {
  constructor(username, email, sections) {
    super(username, email);
    this.sections = sections;
    this.role = "moderator";
  }
  
  moderateContent(content) {
    console.log(`${this.username} is moderating content`);
  }
}

const admin = new Admin("admin1", "admin@example.com", ["all"]);
const mod = new Moderator("mod1", "mod@example.com", ["posts", "comments"]);

admin.login();        // Inherited from User
admin.deleteUser(mod); // Admin-specific method
```

### 2. Vehicle Hierarchy
```javascript
class Vehicle {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.isRunning = false;
  }
  
  start() {
    this.isRunning = true;
    console.log(`${this.make} ${this.model} started`);
  }
  
  stop() {
    this.isRunning = false;
    console.log(`${this.make} ${this.model} stopped`);
  }
  
  getInfo() {
    return `${this.year} ${this.make} ${this.model}`;
  }
}

class Car extends Vehicle {
  constructor(make, model, year, doors) {
    super(make, model, year);
    this.doors = doors;
    this.type = "car";
  }
  
  honk() {
    console.log("Beep beep!");
  }
}

class Motorcycle extends Vehicle {
  constructor(make, model, year, engineSize) {
    super(make, model, year);
    this.engineSize = engineSize;
    this.type = "motorcycle";
  }
  
  wheelie() {
    console.log("Doing a wheelie!");
  }
}

const car = new Car("Toyota", "Camry", 2023, 4);
const bike = new Motorcycle("Harley", "Sportster", 2023, 883);

car.start();     // Inherited
car.honk();      // Car-specific
bike.start();    // Inherited
bike.wheelie();  // Motorcycle-specific
```

### 3. Shape Hierarchy
```javascript
class Shape {
  constructor(color) {
    this.color = color;
  }
  
  getArea() {
    throw new Error("getArea must be implemented by subclass");
  }
  
  getPerimeter() {
    throw new Error("getPerimeter must be implemented by subclass");
  }
  
  describe() {
    return `A ${this.color} shape with area ${this.getArea().toFixed(2)}`;
  }
}

class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
  
  getPerimeter() {
    return 2 * (this.width + this.height);
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

class Square extends Rectangle {
  constructor(color, side) {
    super(color, side, side);
  }
}

const rect = new Rectangle("blue", 10, 5);
const circle = new Circle("red", 7);
const square = new Square("green", 5);

console.log(rect.describe());    // "A blue shape with area 50.00"
console.log(circle.describe());  // "A red shape with area 153.94"
console.log(square.describe());  // "A green shape with area 25.00"
```

---

## Static Method Inheritance

```javascript
class Animal {
  static kingdom = "Animalia";
  
  static getKingdom() {
    return this.kingdom;
  }
  
  static classify() {
    return "This is an animal";
  }
}

class Dog extends Animal {
  static classify() {
    return `${super.classify()} - specifically a dog`;
  }
}

console.log(Animal.getKingdom());  // "Animalia"
console.log(Dog.getKingdom());     // "Animalia" (inherited)
console.log(Animal.classify());    // "This is an animal"
console.log(Dog.classify());       // "This is an animal - specifically a dog"
```

---

## Checking Inheritance

### instanceof
```javascript
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

const dog = new Dog();

console.log(dog instanceof Dog);      // true
console.log(dog instanceof Animal);   // true
console.log(dog instanceof Cat);      // false
console.log(dog instanceof Object);   // true (everything inherits from Object)
```

### isPrototypeOf
```javascript
console.log(Animal.prototype.isPrototypeOf(dog));  // true
console.log(Dog.prototype.isPrototypeOf(dog));     // true
console.log(Cat.prototype.isPrototypeOf(dog));     // false
```

---

## Abstract-Like Patterns

JavaScript doesn't have true abstract classes, but you can simulate them.

```javascript
class AbstractShape {
  constructor() {
    if (new.target === AbstractShape) {
      throw new Error("Cannot instantiate abstract class");
    }
  }
  
  getArea() {
    throw new Error("Method 'getArea' must be implemented");
  }
  
  getPerimeter() {
    throw new Error("Method 'getPerimeter' must be implemented");
  }
}

class Circle extends AbstractShape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

// const shape = new AbstractShape();  // Error: Cannot instantiate
const circle = new Circle(5);          // ✓ Works
```

---

## Common Pitfalls

### 1. Forgetting `super()` in Constructor
```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }
}

class Child extends Parent {
  constructor(name, age) {
    // ✗ Must call super() before using 'this'
    this.age = age;  // ReferenceError
    super(name);
  }
}
```

### 2. Calling `super()` After Using `this`
```javascript
class Child extends Parent {
  constructor(name, age) {
    this.age = age;  // ✗ ReferenceError
    super(name);     // Must call super first
  }
}
```

### 3. Not Calling `super()` at All
```javascript
class Child extends Parent {
  constructor(name, age) {
    // If constructor exists in child, must call super
    this.age = age;  // ✗ ReferenceError: Must call super
  }
}

// ✓ Solution: Call super
class Child extends Parent {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}

// ✓ Or remove constructor if not needed
class Child extends Parent {
  // Automatically calls super with all arguments
}
```

---

## Best Practices

1. **Call super() first in constructor**
   ```javascript
   constructor(name, age) {
     super(name);  // Always first
     this.age = age;
   }
   ```

2. **Override methods intentionally**
   ```javascript
   // Document why you're overriding
   getArea() {
     // Circle-specific area calculation
     return Math.PI * this.radius ** 2;
   }
   ```

3. **Use super to extend parent methods**
   ```javascript
   describe() {
     return `${super.describe()} - Enhanced description`;
   }
   ```

4. **Keep inheritance hierarchies shallow**
   ```javascript
   // ✓ Good: 2-3 levels
   Animal -> Mammal -> Dog
   
   // ✗ Avoid: Deep hierarchies
   Animal -> Vertebrate -> Mammal -> Carnivore -> Canine -> Dog
   ```

5. **Favor composition over inheritance when appropriate**
   ```javascript
   // Instead of deep inheritance, use composition
   class Dog {
     constructor() {
       this.eater = new Eater();
       this.sleeper = new Sleeper();
     }
   }
   ```

---

## Key Takeaways

- Use `extends` keyword to create subclasses
- `super()` calls the parent constructor - must be called before using `this`
- `super.methodName()` calls parent methods
- Child classes inherit all parent properties and methods
- Child classes can override parent methods
- Use `instanceof` to check inheritance relationships
- Static methods are also inherited
- JavaScript uses prototypal inheritance under the hood
- Keep inheritance hierarchies simple and logical
