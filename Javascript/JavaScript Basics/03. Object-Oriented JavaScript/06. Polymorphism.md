# Polymorphism

Polymorphism means "many forms" - the ability of different objects to respond to the same method call in their own way. It allows objects of different classes to be treated as objects of a common parent class.

---

## Types of Polymorphism

### 1. Method Overriding (Runtime Polymorphism)
Child classes provide specific implementations of parent methods.

```javascript
class Animal {
  speak() {
    return "Animal makes a sound";
  }
  
  move() {
    return "Animal moves";
  }
}

class Dog extends Animal {
  speak() {
    return "Woof!";
  }
  
  move() {
    return "Dog runs";
  }
}

class Cat extends Animal {
  speak() {
    return "Meow!";
  }
  
  move() {
    return "Cat walks gracefully";
  }
}

class Bird extends Animal {
  speak() {
    return "Tweet!";
  }
  
  move() {
    return "Bird flies";
  }
}

// Same method call, different behavior
const animals = [new Dog(), new Cat(), new Bird()];

animals.forEach(animal => {
  console.log(animal.speak());
  console.log(animal.move());
});
// "Woof!" "Dog runs"
// "Meow!" "Cat walks gracefully"
// "Tweet!" "Bird flies"
```

---

## Polymorphic Behavior

### Different Objects, Same Interface
```javascript
class Shape {
  getArea() {
    throw new Error("getArea must be implemented");
  }
  
  getPerimeter() {
    throw new Error("getPerimeter must be implemented");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }
  
  getArea() {
    return Math.PI * this.radius ** 2;
  }
  
  getPerimeter() {
    return 2 * Math.PI * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }
  
  getArea() {
    return this.width * this.height;
  }
  
  getPerimeter() {
    return 2 * (this.width + this.height);
  }
}

class Triangle extends Shape {
  constructor(a, b, c) {
    super();
    this.a = a;
    this.b = b;
    this.c = c;
  }
  
  getArea() {
    const s = (this.a + this.b + this.c) / 2;
    return Math.sqrt(s * (s - this.a) * (s - this.b) * (s - this.c));
  }
  
  getPerimeter() {
    return this.a + this.b + this.c;
  }
}

// Polymorphic function - works with any Shape
function printShapeInfo(shape) {
  console.log(`Area: ${shape.getArea().toFixed(2)}`);
  console.log(`Perimeter: ${shape.getPerimeter().toFixed(2)}`);
}

const shapes = [
  new Circle(5),
  new Rectangle(10, 5),
  new Triangle(3, 4, 5)
];

shapes.forEach(shape => {
  printShapeInfo(shape);  // Same function, different behavior
});
```

---

## Duck Typing

JavaScript uses duck typing: "If it walks like a duck and quacks like a duck, it's a duck."

```javascript
// No need for inheritance - just implement the interface
class Duck {
  quack() {
    return "Quack!";
  }
  
  fly() {
    return "Duck flies";
  }
}

class Person {
  quack() {
    return "Person imitates: Quack!";
  }
  
  fly() {
    return "Person can't fly";
  }
}

class Robot {
  quack() {
    return "Robot: Quack! Quack!";
  }
  
  fly() {
    return "Robot flies with propellers";
  }
}

// Function that works with anything that has quack() and fly()
function makeItQuackAndFly(thing) {
  console.log(thing.quack());
  console.log(thing.fly());
}

makeItQuackAndFly(new Duck());
makeItQuackAndFly(new Person());
makeItQuackAndFly(new Robot());
// All work! No inheritance needed
```

---

## Method Overloading Simulation

JavaScript doesn't support true method overloading, but we can simulate it.

```javascript
class Calculator {
  // Simulate overloading with default parameters and type checking
  add(...args) {
    if (args.length === 0) {
      return 0;
    }
    
    if (args.length === 1) {
      return args[0];
    }
    
    // Check if all arguments are numbers
    if (args.every(arg => typeof arg === 'number')) {
      return args.reduce((sum, num) => sum + num, 0);
    }
    
    // Check if all arguments are strings
    if (args.every(arg => typeof arg === 'string')) {
      return args.join('');
    }
    
    // Check if all arguments are arrays
    if (args.every(arg => Array.isArray(arg))) {
      return args.flat();
    }
    
    throw new Error("Unsupported argument types");
  }
}

const calc = new Calculator();
console.log(calc.add());                    // 0
console.log(calc.add(5));                   // 5
console.log(calc.add(1, 2, 3));            // 6
console.log(calc.add("Hello", " ", "World")); // "Hello World"
console.log(calc.add([1, 2], [3, 4]));     // [1, 2, 3, 4]
```

---

## Practical Examples

### 1. Payment Processing
```javascript
class PaymentProcessor {
  processPayment(amount) {
    throw new Error("processPayment must be implemented");
  }
  
  refund(transactionId) {
    throw new Error("refund must be implemented");
  }
}

class CreditCardProcessor extends PaymentProcessor {
  processPayment(amount) {
    console.log(`Processing $${amount} via Credit Card`);
    // Credit card specific logic
    return { success: true, method: "credit_card" };
  }
  
  refund(transactionId) {
    console.log(`Refunding credit card transaction ${transactionId}`);
    return { success: true };
  }
}

class PayPalProcessor extends PaymentProcessor {
  processPayment(amount) {
    console.log(`Processing $${amount} via PayPal`);
    // PayPal specific logic
    return { success: true, method: "paypal" };
  }
  
  refund(transactionId) {
    console.log(`Refunding PayPal transaction ${transactionId}`);
    return { success: true };
  }
}

class CryptoProcessor extends PaymentProcessor {
  processPayment(amount) {
    console.log(`Processing $${amount} via Cryptocurrency`);
    // Crypto specific logic
    return { success: true, method: "crypto" };
  }
  
  refund(transactionId) {
    console.log(`Refunding crypto transaction ${transactionId}`);
    return { success: true };
  }
}

// Polymorphic checkout function
function checkout(processor, amount) {
  const result = processor.processPayment(amount);
  console.log(`Payment successful via ${result.method}`);
  return result;
}

checkout(new CreditCardProcessor(), 100);
checkout(new PayPalProcessor(), 50);
checkout(new CryptoProcessor(), 200);
```

### 2. Notification System
```javascript
class Notifier {
  send(message, recipient) {
    throw new Error("send must be implemented");
  }
}

class EmailNotifier extends Notifier {
  send(message, recipient) {
    console.log(`Sending email to ${recipient}`);
    console.log(`Subject: ${message.subject}`);
    console.log(`Body: ${message.body}`);
    return { sent: true, method: "email" };
  }
}

class SMSNotifier extends Notifier {
  send(message, recipient) {
    console.log(`Sending SMS to ${recipient}`);
    console.log(`Message: ${message.text}`);
    return { sent: true, method: "sms" };
  }
}

class PushNotifier extends Notifier {
  send(message, recipient) {
    console.log(`Sending push notification to ${recipient}`);
    console.log(`Title: ${message.title}`);
    console.log(`Body: ${message.body}`);
    return { sent: true, method: "push" };
  }
}

class NotificationService {
  #notifiers = [];
  
  addNotifier(notifier) {
    this.#notifiers.push(notifier);
  }
  
  notifyAll(message, recipient) {
    this.#notifiers.forEach(notifier => {
      notifier.send(message, recipient);
    });
  }
}

const service = new NotificationService();
service.addNotifier(new EmailNotifier());
service.addNotifier(new SMSNotifier());
service.addNotifier(new PushNotifier());

service.notifyAll(
  { subject: "Alert", body: "Important message", title: "Alert", text: "Important" },
  "user@example.com"
);
```

### 3. Data Export System
```javascript
class Exporter {
  export(data) {
    throw new Error("export must be implemented");
  }
}

class CSVExporter extends Exporter {
  export(data) {
    const headers = Object.keys(data[0]).join(',');
    const rows = data.map(row => 
      Object.values(row).join(',')
    ).join('\n');
    return `${headers}\n${rows}`;
  }
}

class JSONExporter extends Exporter {
  export(data) {
    return JSON.stringify(data, null, 2);
  }
}

class XMLExporter extends Exporter {
  export(data) {
    let xml = '<?xml version="1.0"?>\n<data>\n';
    data.forEach(item => {
      xml += '  <item>\n';
      Object.entries(item).forEach(([key, value]) => {
        xml += `    <${key}>${value}</${key}>\n`;
      });
      xml += '  </item>\n';
    });
    xml += '</data>';
    return xml;
  }
}

// Polymorphic export function
function exportData(exporter, data) {
  return exporter.export(data);
}

const data = [
  { id: 1, name: "John", age: 30 },
  { id: 2, name: "Jane", age: 25 }
];

console.log("CSV:");
console.log(exportData(new CSVExporter(), data));

console.log("\nJSON:");
console.log(exportData(new JSONExporter(), data));

console.log("\nXML:");
console.log(exportData(new XMLExporter(), data));
```

---

## Strategy Pattern (Polymorphism in Action)

```javascript
class CompressionStrategy {
  compress(data) {
    throw new Error("compress must be implemented");
  }
}

class ZipCompression extends CompressionStrategy {
  compress(data) {
    console.log("Compressing with ZIP algorithm");
    return `[ZIP]${data}[/ZIP]`;
  }
}

class RarCompression extends CompressionStrategy {
  compress(data) {
    console.log("Compressing with RAR algorithm");
    return `[RAR]${data}[/RAR]`;
  }
}

class GzipCompression extends CompressionStrategy {
  compress(data) {
    console.log("Compressing with GZIP algorithm");
    return `[GZIP]${data}[/GZIP]`;
  }
}

class FileCompressor {
  #strategy;
  
  constructor(strategy) {
    this.#strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.#strategy = strategy;
  }
  
  compressFile(data) {
    return this.#strategy.compress(data);
  }
}

const compressor = new FileCompressor(new ZipCompression());
console.log(compressor.compressFile("Hello World"));

compressor.setStrategy(new GzipCompression());
console.log(compressor.compressFile("Hello World"));
```

---

## Interface-Like Patterns

```javascript
// Define expected interface as a base class
class Database {
  connect() { throw new Error("connect not implemented"); }
  query(sql) { throw new Error("query not implemented"); }
  disconnect() { throw new Error("disconnect not implemented"); }
}

class MySQLDatabase extends Database {
  connect() {
    console.log("Connecting to MySQL");
  }
  
  query(sql) {
    console.log(`MySQL Query: ${sql}`);
    return [];
  }
  
  disconnect() {
    console.log("Disconnecting from MySQL");
  }
}

class PostgreSQLDatabase extends Database {
  connect() {
    console.log("Connecting to PostgreSQL");
  }
  
  query(sql) {
    console.log(`PostgreSQL Query: ${sql}`);
    return [];
  }
  
  disconnect() {
    console.log("Disconnecting from PostgreSQL");
  }
}

class MongoDBDatabase extends Database {
  connect() {
    console.log("Connecting to MongoDB");
  }
  
  query(queryObj) {
    console.log(`MongoDB Query: ${JSON.stringify(queryObj)}`);
    return [];
  }
  
  disconnect() {
    console.log("Disconnecting from MongoDB");
  }
}

// Function that works with any database
function executeQuery(database, query) {
  database.connect();
  const results = database.query(query);
  database.disconnect();
  return results;
}

executeQuery(new MySQLDatabase(), "SELECT * FROM users");
executeQuery(new PostgreSQLDatabase(), "SELECT * FROM users");
executeQuery(new MongoDBDatabase(), { collection: "users" });
```

---

## Benefits of Polymorphism

1. **Flexibility**: Easy to add new types without changing existing code
2. **Maintainability**: Changes to one class don't affect others
3. **Reusability**: Same function works with different object types
4. **Extensibility**: Easy to extend functionality by adding new classes

---

## Best Practices

1. **Define clear interfaces/base classes**
   ```javascript
   class Plugin {
     initialize() { throw new Error("Must implement"); }
     execute() { throw new Error("Must implement"); }
   }
   ```

2. **Use consistent method signatures**
   ```javascript
   // All implementations should have same parameters
   process(data) { /* ... */ }
   ```

3. **Document expected behavior**
   ```javascript
   /**
    * Process payment
    * @param {number} amount - Amount to process
    * @returns {Object} Result with success status
    */
   processPayment(amount) { }
   ```

4. **Favor composition over complex inheritance**
   ```javascript
   class Order {
     constructor(paymentProcessor) {
       this.processor = paymentProcessor;  // Inject dependency
     }
   }
   ```

5. **Use duck typing wisely**
   ```javascript
   // Check for method existence
   if (typeof obj.method === 'function') {
     obj.method();
   }
   ```

---

## Common Pitfalls

### 1. Breaking LSP (Liskov Substitution Principle)
```javascript
// ✗ Child changes parent behavior unexpectedly
class Bird {
  fly() { return "Flying"; }
}

class Penguin extends Bird {
  fly() { throw new Error("Can't fly"); }  // Breaks expectation
}
```

### 2. Inconsistent Method Signatures
```javascript
// ✗ Bad: Different signatures
class A {
  process(data) { }
}

class B extends A {
  process(data, options, callback) { }  // Different signature
}
```

---

## Key Takeaways

- Polymorphism allows objects to respond to same methods differently
- JavaScript uses duck typing - objects don't need common parent
- Method overriding provides runtime polymorphism
- Same interface, different implementations = polymorphic behavior
- Enables writing flexible, extensible code
- Strategy pattern is a practical application of polymorphism
- Base classes can define expected interface
- Keep method signatures consistent across implementations
