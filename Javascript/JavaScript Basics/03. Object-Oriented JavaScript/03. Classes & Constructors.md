# Classes & Constructors

ES6 introduced the `class` syntax as a cleaner way to create objects and implement object-oriented programming in JavaScript.

---

## Constructor Functions (Pre-ES6)

### Basic Constructor
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hi, I'm ${this.name}`;
};

const john = new Person("John", 30);
console.log(john.greet());  // "Hi, I'm John"
```

### What Happens with `new`
```javascript
function Person(name) {
  // 1. Create new empty object: this = {}
  // 2. Set prototype: this.__proto__ = Person.prototype
  this.name = name;
  // 3. Return this (implicit)
}

const person = new Person("John");
```

---

## ES6 Class Syntax

### Basic Class
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    return `Hi, I'm ${this.name}`;
  }
  
  getAge() {
    return this.age;
  }
}

const john = new Person("John", 30);
console.log(john.greet());   // "Hi, I'm John"
console.log(john.getAge());  // 30
```

### Class vs Constructor Function
```javascript
// Constructor function
function PersonOld(name) {
  this.name = name;
}
PersonOld.prototype.greet = function() {
  return `Hi, I'm ${this.name}`;
};

// Equivalent ES6 class
class PersonNew {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hi, I'm ${this.name}`;
  }
}

// Both create objects the same way
const person1 = new PersonOld("John");
const person2 = new PersonNew("Jane");
```

---

## Constructor Method

The `constructor` method is called when creating a new instance.

```javascript
class User {
  constructor(username, email) {
    // Initialize instance properties
    this.username = username;
    this.email = email;
    this.createdAt = new Date();
    this.isActive = true;
    
    console.log("New user created!");
  }
}

const user = new User("john_doe", "john@example.com");
// Logs: "New user created!"
```

### Constructor with Validation
```javascript
class User {
  constructor(username, email) {
    if (!username || !email) {
      throw new Error("Username and email are required");
    }
    
    if (!email.includes("@")) {
      throw new Error("Invalid email format");
    }
    
    this.username = username;
    this.email = email;
  }
}

const user = new User("john", "invalid");  // Error: Invalid email format
```

### Optional Constructor
```javascript
// Constructor is optional if no initialization needed
class Empty {
  // No constructor - uses default
}

// Equivalent to:
class Empty {
  constructor() {
    // Empty default constructor
  }
}
```

---

## Instance Methods

Methods defined in the class are added to the prototype.

```javascript
class Calculator {
  constructor() {
    this.result = 0;
  }
  
  add(num) {
    this.result += num;
    return this;  // Enable method chaining
  }
  
  subtract(num) {
    this.result -= num;
    return this;
  }
  
  multiply(num) {
    this.result *= num;
    return this;
  }
  
  getResult() {
    return this.result;
  }
}

const calc = new Calculator();
calc.add(10).subtract(3).multiply(2);
console.log(calc.getResult());  // 14
```

---

## Class Properties

### Instance Properties (in constructor)
```javascript
class Person {
  constructor(name, age) {
    // Instance properties
    this.name = name;
    this.age = age;
  }
}
```

### Public Class Fields (ES2022)
```javascript
class Person {
  // Public class fields (defined outside constructor)
  species = "Homo sapiens";
  
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const person = new Person("John", 30);
console.log(person.species);  // "Homo sapiens"
```

### Private Fields (ES2022)
```javascript
class BankAccount {
  #balance = 0;  // Private field (starts with #)
  
  constructor(initialBalance) {
    this.#balance = initialBalance;
  }
  
  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }
  
  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.#balance);      // SyntaxError: Private field
```

---

## Static Methods & Properties

Static members belong to the class itself, not instances.

### Static Methods
```javascript
class MathHelper {
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static PI = 3.14159;
}

// Call on class, not instance
console.log(MathHelper.add(5, 3));      // 8
console.log(MathHelper.multiply(4, 2)); // 8
console.log(MathHelper.PI);             // 3.14159

const helper = new MathHelper();
console.log(helper.add(5, 3));  // TypeError: helper.add is not a function
```

### Static vs Instance
```javascript
class User {
  static userCount = 0;
  
  constructor(name) {
    this.name = name;
    User.userCount++;  // Access static property via class name
  }
  
  static getTotalUsers() {
    return User.userCount;
  }
  
  getUserInfo() {
    return `${this.name} is one of ${User.userCount} users`;
  }
}

const user1 = new User("John");
const user2 = new User("Jane");

console.log(User.getTotalUsers());     // 2 (static method)
console.log(user1.getUserInfo());      // "John is one of 2 users"
```

---

## Getters and Setters

```javascript
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  
  // Getter - accessed like a property
  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  }
  
  // Setter - set like a property
  set fullName(value) {
    const parts = value.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
  
  get initials() {
    return `${this.firstName[0]}${this.lastName[0]}`;
  }
}

const person = new Person("John", "Doe");
console.log(person.fullName);  // "John Doe" (getter)
console.log(person.initials);  // "JD" (getter)

person.fullName = "Jane Smith";  // (setter)
console.log(person.firstName);   // "Jane"
console.log(person.lastName);    // "Smith"
```

---

## Practical Examples

### 1. User Model
```javascript
class User {
  static #nextId = 1;
  
  constructor(username, email, role = "user") {
    this.id = User.#nextId++;
    this.username = username;
    this.email = email;
    this.role = role;
    this.createdAt = new Date();
    this.isActive = true;
  }
  
  activate() {
    this.isActive = true;
  }
  
  deactivate() {
    this.isActive = false;
  }
  
  updateEmail(newEmail) {
    if (!newEmail.includes("@")) {
      throw new Error("Invalid email");
    }
    this.email = newEmail;
  }
  
  toJSON() {
    return {
      id: this.id,
      username: this.username,
      email: this.email,
      role: this.role,
      isActive: this.isActive
    };
  }
}
```

### 2. Shopping Cart
```javascript
class ShoppingCart {
  #items = [];
  
  addItem(product, quantity = 1) {
    const existingItem = this.#items.find(item => item.product.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      this.#items.push({ product, quantity });
    }
  }
  
  removeItem(productId) {
    this.#items = this.#items.filter(item => item.product.id !== productId);
  }
  
  updateQuantity(productId, quantity) {
    const item = this.#items.find(item => item.product.id === productId);
    if (item) {
      item.quantity = quantity;
    }
  }
  
  get total() {
    return this.#items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
  }
  
  get itemCount() {
    return this.#items.reduce((count, item) => count + item.quantity, 0);
  }
  
  clear() {
    this.#items = [];
  }
}
```

### 3. Task Manager
```javascript
class Task {
  constructor(title, description, priority = "medium") {
    this.id = Date.now().toString();
    this.title = title;
    this.description = description;
    this.priority = priority;
    this.completed = false;
    this.createdAt = new Date();
  }
  
  complete() {
    this.completed = true;
    this.completedAt = new Date();
  }
  
  uncomplete() {
    this.completed = false;
    delete this.completedAt;
  }
}

class TaskManager {
  #tasks = [];
  
  addTask(title, description, priority) {
    const task = new Task(title, description, priority);
    this.#tasks.push(task);
    return task;
  }
  
  getTask(id) {
    return this.#tasks.find(task => task.id === id);
  }
  
  getAllTasks() {
    return [...this.#tasks];
  }
  
  getCompletedTasks() {
    return this.#tasks.filter(task => task.completed);
  }
  
  getPendingTasks() {
    return this.#tasks.filter(task => !task.completed);
  }
  
  deleteTask(id) {
    this.#tasks = this.#tasks.filter(task => task.id !== id);
  }
}
```

---

## Class Expressions

Classes can be defined as expressions.

```javascript
// Named class expression
const Person = class PersonClass {
  constructor(name) {
    this.name = name;
  }
};

// Anonymous class expression
const Animal = class {
  constructor(type) {
    this.type = type;
  }
};

// Immediately invoked
const instance = new (class {
  constructor() {
    this.value = 42;
  }
})();
```

---

## Common Pitfalls

### 1. Forgetting `new` Keyword
```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const person = Person("John");  // TypeError: Class constructor cannot be invoked without 'new'
```

### 2. Arrow Functions in Classes
```javascript
class Counter {
  count = 0;
  
  // ✗ Arrow function as method (creates new function per instance)
  incrementArrow = () => {
    this.count++;
  };
  
  // ✓ Regular method (shared on prototype)
  increment() {
    this.count++;
  }
}
```

### 3. Accessing Before Declaration
```javascript
const instance = new MyClass();  // ReferenceError

class MyClass {
  // Class declarations are not hoisted
}
```

---

## Best Practices

1. **Use PascalCase for class names**
   ```javascript
   class UserAccount { }
   class ShoppingCart { }
   ```

2. **Validate in constructor**
   ```javascript
   constructor(email) {
     if (!email.includes("@")) throw new Error("Invalid email");
     this.email = email;
   }
   ```

3. **Use private fields for internal state**
   ```javascript
   class Counter {
     #count = 0;  // Private
     
     increment() {
       this.#count++;
     }
   }
   ```

4. **Return `this` for method chaining**
   ```javascript
   add(num) {
     this.value += num;
     return this;
   }
   ```

5. **Use static methods for utilities**
   ```javascript
   static createFromJSON(json) {
     const data = JSON.parse(json);
     return new this(data.name, data.age);
   }
   ```

---

## Key Takeaways

- Classes are syntactic sugar over constructor functions and prototypes
- Use `constructor` method to initialize instances
- Instance methods are added to the prototype
- Static methods/properties belong to the class, not instances
- Private fields (#) prevent external access
- Classes are not hoisted - must be declared before use
- Must use `new` keyword to create instances
- Getters/setters provide controlled property access
