# Static Methods

Static methods belong to the class itself, not to instances. They're called on the class, not on objects created from the class.

---

## Basic Static Methods

### Defining Static Methods
```javascript
class MathHelper {
  static add(a, b) {
    return a + b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static square(n) {
    return n * n;
  }
}

// Call on class, not instance
console.log(MathHelper.add(5, 3));       // 8
console.log(MathHelper.multiply(4, 2));  // 8
console.log(MathHelper.square(5));       // 25

// ✗ Cannot call on instance
const helper = new MathHelper();
console.log(helper.add(5, 3));  // TypeError: helper.add is not a function
```

### Static vs Instance Methods
```javascript
class User {
  constructor(name) {
    this.name = name;
  }
  
  // Instance method - requires instance
  greet() {
    return `Hi, I'm ${this.name}`;
  }
  
  // Static method - works without instance
  static createAnonymous() {
    return new User("Anonymous");
  }
  
  static isValidName(name) {
    return typeof name === 'string' && name.length > 0;
  }
}

// Static method
const anon = User.createAnonymous();
console.log(anon.greet());  // "Hi, I'm Anonymous"

console.log(User.isValidName("John"));  // true
console.log(User.isValidName(""));      // false

// Instance method
const user = new User("John");
console.log(user.greet());  // "Hi, I'm John"
```

---

## Static Properties

### ES2022 Static Fields
```javascript
class Config {
  static API_URL = "https://api.example.com";
  static MAX_RETRIES = 3;
  static TIMEOUT = 5000;
  
  static getFullUrl(endpoint) {
    return `${this.API_URL}${endpoint}`;
  }
}

console.log(Config.API_URL);              // "https://api.example.com"
console.log(Config.getFullUrl("/users")); // "https://api.example.com/users"
```

### Pre-ES2022 (Using Constructor)
```javascript
class Constants {
  static get PI() {
    return 3.14159;
  }
  
  static get E() {
    return 2.71828;
  }
}

// Or assign after class definition
Constants.VERSION = "1.0.0";
```

---

## Common Use Cases

### 1. Factory Methods
```javascript
class User {
  constructor(name, email, role) {
    this.name = name;
    this.email = email;
    this.role = role;
  }
  
  static createAdmin(name, email) {
    return new User(name, email, "admin");
  }
  
  static createModerator(name, email) {
    return new User(name, email, "moderator");
  }
  
  static createGuest() {
    return new User("Guest", "guest@example.com", "guest");
  }
  
  static fromJSON(json) {
    const data = JSON.parse(json);
    return new User(data.name, data.email, data.role);
  }
}

const admin = User.createAdmin("John", "john@example.com");
const guest = User.createGuest();
const restored = User.fromJSON('{"name":"Jane","email":"jane@example.com","role":"user"}');
```

### 2. Validation & Utility Functions
```javascript
class Validator {
  static isEmail(str) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str);
  }
  
  static isPhone(str) {
    return /^\d{10}$/.test(str.replace(/\D/g, ''));
  }
  
  static isURL(str) {
    try {
      new URL(str);
      return true;
    } catch {
      return false;
    }
  }
  
  static isEmpty(value) {
    return value === null || 
           value === undefined || 
           value === '' ||
           (Array.isArray(value) && value.length === 0);
  }
}

console.log(Validator.isEmail("test@example.com"));  // true
console.log(Validator.isPhone("123-456-7890"));      // true
console.log(Validator.isURL("https://example.com")); // true
console.log(Validator.isEmpty([]));                  // true
```

### 3. Counter/Tracker
```javascript
class Database {
  static #connectionCount = 0;
  static #connections = [];
  
  constructor(host) {
    this.host = host;
    this.id = Database.#connectionCount++;
    Database.#connections.push(this);
  }
  
  static getTotalConnections() {
    return Database.#connectionCount;
  }
  
  static getActiveConnections() {
    return Database.#connections.length;
  }
  
  static closeAllConnections() {
    Database.#connections.forEach(conn => conn.close());
    Database.#connections = [];
  }
  
  close() {
    const index = Database.#connections.indexOf(this);
    if (index > -1) {
      Database.#connections.splice(index, 1);
    }
    console.log(`Connection ${this.id} closed`);
  }
}

const db1 = new Database("localhost");
const db2 = new Database("127.0.0.1");
const db3 = new Database("192.168.1.1");

console.log(Database.getTotalConnections());   // 3
console.log(Database.getActiveConnections());  // 3

db1.close();
console.log(Database.getActiveConnections());  // 2
```

### 4. Configuration Management
```javascript
class AppConfig {
  static #config = {
    env: "development",
    debug: true,
    apiUrl: "http://localhost:3000"
  };
  
  static get(key) {
    return this.#config[key];
  }
  
  static set(key, value) {
    this.#config[key] = value;
  }
  
  static setMultiple(configs) {
    this.#config = { ...this.#config, ...configs };
  }
  
  static reset() {
    this.#config = {
      env: "development",
      debug: true,
      apiUrl: "http://localhost:3000"
    };
  }
  
  static getAll() {
    return { ...this.#config };
  }
}

AppConfig.set("debug", false);
console.log(AppConfig.get("debug"));  // false

AppConfig.setMultiple({
  env: "production",
  apiUrl: "https://api.example.com"
});

console.log(AppConfig.getAll());
```

### 5. Comparison Methods
```javascript
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  
  static distance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx ** 2 + dy ** 2);
  }
  
  static midpoint(point1, point2) {
    return new Point(
      (point1.x + point2.x) / 2,
      (point1.y + point2.y) / 2
    );
  }
  
  static areCollinear(p1, p2, p3) {
    // Check if three points are on the same line
    return (p2.y - p1.y) * (p3.x - p2.x) === (p3.y - p2.y) * (p2.x - p1.x);
  }
}

const p1 = new Point(0, 0);
const p2 = new Point(3, 4);
const p3 = new Point(6, 8);

console.log(Point.distance(p1, p2));      // 5
const mid = Point.midpoint(p1, p2);
console.log(mid);                         // Point { x: 1.5, y: 2 }
console.log(Point.areCollinear(p1, p2, p3)); // true
```

---

## Static Methods in Inheritance

### Inherited Static Methods
```javascript
class Animal {
  static kingdom = "Animalia";
  
  static getKingdom() {
    return this.kingdom;
  }
  
  static classify() {
    return "Animal classification";
  }
}

class Dog extends Animal {
  static breed = "Canis familiaris";
  
  static classify() {
    return `${super.classify()} - Dog`;
  }
}

console.log(Animal.getKingdom());  // "Animalia"
console.log(Dog.getKingdom());     // "Animalia" (inherited)
console.log(Dog.classify());       // "Animal classification - Dog"
```

### Calling Parent Static Methods
```javascript
class Shape {
  static count = 0;
  
  constructor() {
    this.constructor.count++;
  }
  
  static getCount() {
    return this.count;
  }
  
  static resetCount() {
    this.count = 0;
  }
}

class Circle extends Shape {
  static count = 0;
  
  static getTotalShapes() {
    return super.getCount();
  }
}

const c1 = new Circle();
const c2 = new Circle();

console.log(Circle.getCount());        // 2
console.log(Circle.getTotalShapes());  // 0 (calls Shape.count)
```

---

## Practical Patterns

### 1. Singleton Pattern
```javascript
class Database {
  static #instance = null;
  
  constructor() {
    if (Database.#instance) {
      return Database.#instance;
    }
    
    this.connection = this.#connect();
    Database.#instance = this;
  }
  
  #connect() {
    console.log("Connecting to database...");
    return { connected: true };
  }
  
  static getInstance() {
    if (!Database.#instance) {
      Database.#instance = new Database();
    }
    return Database.#instance;
  }
  
  query(sql) {
    console.log(`Executing: ${sql}`);
  }
}

const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2);  // true (same instance)
```

### 2. Builder Pattern
```javascript
class QueryBuilder {
  constructor() {
    this.query = {};
  }
  
  static select(...fields) {
    const builder = new QueryBuilder();
    builder.query.select = fields;
    return builder;
  }
  
  from(table) {
    this.query.from = table;
    return this;
  }
  
  where(condition) {
    this.query.where = condition;
    return this;
  }
  
  build() {
    return this.query;
  }
}

const query = QueryBuilder
  .select("name", "email")
  .from("users")
  .where({ active: true })
  .build();

console.log(query);
// { select: ["name", "email"], from: "users", where: { active: true } }
```

### 3. Registry Pattern
```javascript
class Plugin {
  static #plugins = new Map();
  
  static register(name, pluginClass) {
    this.#plugins.set(name, pluginClass);
  }
  
  static get(name) {
    return this.#plugins.get(name);
  }
  
  static has(name) {
    return this.#plugins.has(name);
  }
  
  static getAll() {
    return Array.from(this.#plugins.keys());
  }
  
  static create(name, ...args) {
    const PluginClass = this.#plugins.get(name);
    if (!PluginClass) {
      throw new Error(`Plugin ${name} not found`);
    }
    return new PluginClass(...args);
  }
}

class LoggerPlugin {
  log(message) {
    console.log(`[LOG] ${message}`);
  }
}

class CachePlugin {
  constructor(size) {
    this.size = size;
  }
}

Plugin.register("logger", LoggerPlugin);
Plugin.register("cache", CachePlugin);

console.log(Plugin.getAll());     // ["logger", "cache"]
const logger = Plugin.create("logger");
const cache = Plugin.create("cache", 100);
```

---

## this in Static Methods

```javascript
class MyClass {
  static className = "MyClass";
  
  static getClassName() {
    return this.className;  // 'this' refers to the class
  }
  
  static create() {
    return new this();  // 'this' refers to the class constructor
  }
}

class MySubClass extends MyClass {
  static className = "MySubClass";
}

console.log(MyClass.getClassName());    // "MyClass"
console.log(MySubClass.getClassName()); // "MySubClass"

const instance1 = MyClass.create();
const instance2 = MySubClass.create();

console.log(instance1 instanceof MyClass);    // true
console.log(instance2 instanceof MySubClass); // true
```

---

## Best Practices

1. **Use for utility functions that don't need instance state**
   ```javascript
   class StringHelper {
     static capitalize(str) {
       return str.charAt(0).toUpperCase() + str.slice(1);
     }
   }
   ```

2. **Use for factory methods**
   ```javascript
   static createDefault() {
     return new this(defaultValues);
   }
   ```

3. **Use for constants and configuration**
   ```javascript
   static MAX_SIZE = 100;
   static DEFAULT_TIMEOUT = 5000;
   ```

4. **Don't access instance properties from static methods**
   ```javascript
   // ✗ Can't access instance properties
   static badMethod() {
     return this.name;  // undefined or error
   }
   ```

5. **Use for class-level operations**
   ```javascript
   static resetAll() {
     this.instances = [];
   }
   ```

---

## Key Takeaways

- Static methods belong to the class, not instances
- Called on the class: `ClassName.method()`
- Cannot access instance properties (no `this` context)
- Useful for utility functions, factories, and class-level operations
- Can be inherited by subclasses
- `this` in static methods refers to the class itself
- Static properties hold class-level data
- Perfect for singleton pattern, factory methods, and helpers
