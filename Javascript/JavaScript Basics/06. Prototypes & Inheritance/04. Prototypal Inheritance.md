# Prototypal Inheritance

Prototypal inheritance is JavaScript's mechanism for objects to inherit properties and methods from other objects through the prototype chain.

---

## Basic Concept

In JavaScript, objects inherit directly from other objects (not from classes).

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Animal walking");
  }
};

const rabbit = {
  jumps: true
};

// Set up inheritance
rabbit.__proto__ = animal;  // rabbit inherits from animal

console.log(rabbit.jumps);  // true (own property)
console.log(rabbit.eats);   // true (inherited)
rabbit.walk();               // "Animal walking" (inherited)
```

---

## Setting Up Inheritance

### Using Object.setPrototypeOf()
```javascript
const animal = {
  eats: true
};

const rabbit = {
  jumps: true
};

Object.setPrototypeOf(rabbit, animal);

console.log(rabbit.eats);  // true
```

### Using Object.create()
```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Walking");
  }
};

const rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.eats);   // true
console.log(rabbit.jumps);  // true
```

### In Object Literal (modern)
```javascript
const animal = {
  eats: true
};

const rabbit = {
  __proto__: animal,  // Set prototype
  jumps: true
};

console.log(rabbit.eats);  // true
```

---

## Constructor Function Inheritance

### Parent Constructor
```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  return `${this.name} is eating`;
};
```

### Child Constructor
```javascript
function Dog(name, breed) {
  // Call parent constructor
  Animal.call(this, name);
  this.breed = breed;
}

// Set up prototype chain
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Add child methods
Dog.prototype.bark = function() {
  return "Woof!";
};

const dog = new Dog("Buddy", "Labrador");
console.log(dog.name);    // "Buddy"
console.log(dog.breed);   // "Labrador"
console.log(dog.eat());   // "Buddy is eating"
console.log(dog.bark());  // "Woof!"
```

---

## Inheritance Chain

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  return `${this.name} eats`;
};

function Mammal(name) {
  Animal.call(this, name);
}

Mammal.prototype = Object.create(Animal.prototype);
Mammal.prototype.constructor = Mammal;

Mammal.prototype.breathe = function() {
  return `${this.name} breathes`;
};

function Dog(name, breed) {
  Mammal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Mammal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  return "Woof!";
};

const dog = new Dog("Buddy", "Labrador");

// Chain: dog → Dog.prototype → Mammal.prototype → Animal.prototype → Object.prototype → null

console.log(dog.bark());    // "Woof!" (from Dog)
console.log(dog.breathe()); // "Buddy breathes" (from Mammal)
console.log(dog.eat());     // "Buddy eats" (from Animal)
console.log(dog.toString());// "[object Object]" (from Object)
```

---

## Method Overriding

```javascript
const animal = {
  eat() {
    return "Animal eats";
  }
};

const rabbit = {
  __proto__: animal,
  eat() {
    return "Rabbit eats carrots";
  }
};

console.log(rabbit.eat());  // "Rabbit eats carrots" (own method)
console.log(animal.eat());  // "Animal eats" (parent unchanged)
```

### Calling Parent Method
```javascript
const animal = {
  eat() {
    return "Animal eats";
  }
};

const rabbit = {
  __proto__: animal,
  eat() {
    const parentResult = animal.eat.call(this);
    return `${parentResult} and Rabbit eats carrots`;
  }
};

console.log(rabbit.eat());
// "Animal eats and Rabbit eats carrots"
```

---

## Class-based Inheritance (Modern)

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  eat() {
    return `${this.name} eats`;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);  // Call parent constructor
    this.breed = breed;
  }
  
  bark() {
    return "Woof!";
  }
  
  // Override parent method
  eat() {
    return `${super.eat()} dog food`;
  }
}

const dog = new Dog("Buddy", "Labrador");
console.log(dog.eat());   // "Buddy eats dog food"
console.log(dog.bark());  // "Woof!"
```

---

## Practical Examples

### Shape Hierarchy
```javascript
function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
};

function Circle(radius) {
  Shape.call(this);
  this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

Circle.prototype.area = function() {
  return Math.PI * this.radius * this.radius;
};

const circle = new Circle(5);
circle.move(10, 20);
console.log(circle.x, circle.y);  // 10 20
console.log(circle.area());        // 78.54...
```

### Employee Hierarchy
```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.introduce = function() {
  return `Hi, I'm ${this.name}`;
};

function Employee(name, title) {
  Person.call(this, name);
  this.title = title;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

Employee.prototype.work = function() {
  return `${this.name} is working as ${this.title}`;
};

const emp = new Employee("John", "Developer");
console.log(emp.introduce());  // "Hi, I'm John"
console.log(emp.work());       // "John is working as Developer"
```

---

## Multiple Inheritance (Mixins)

JavaScript doesn't support multiple inheritance, but you can use mixins:

```javascript
const canEat = {
  eat() {
    console.log(`${this.name} is eating`);
  }
};

const canWalk = {
  walk() {
    console.log(`${this.name} is walking`);
  }
};

const canSwim = {
  swim() {
    console.log(`${this.name} is swimming`);
  }
};

// Create object with multiple behaviors
const person = {
  name: "John"
};

Object.assign(person, canEat, canWalk, canSwim);

person.eat();   // "John is eating"
person.walk();  // "John is walking"
person.swim();  // "John is swimming"
```

---

## Common Patterns

### Factory Pattern
```javascript
function createAnimal(name) {
  return Object.create(animalMethods, {
    name: { value: name, writable: true, enumerable: true }
  });
}

const animalMethods = {
  eat() {
    return `${this.name} is eating`;
  }
};

const cat = createAnimal("Whiskers");
console.log(cat.eat());  // "Whiskers is eating"
```

### Composition over Inheritance
```javascript
// Instead of deep inheritance, use composition
const hasEngine = {
  start() { console.log("Engine started"); }
};

const hasWheels = {
  roll() { console.log("Rolling"); }
};

const car = Object.assign({}, hasEngine, hasWheels, {
  brand: "Toyota"
});

car.start();  // "Engine started"
car.roll();   // "Rolling"
```

---

## Best Practices

1. **Prefer composition over deep inheritance**
   ```javascript
   // ✗ Deep inheritance chain
   A → B → C → D → E
   
   // ✓ Flat with composition
   Object.assign({}, trait1, trait2, trait3)
   ```

2. **Use classes for clarity (modern)**
   ```javascript
   class Child extends Parent { }
   ```

3. **Keep inheritance shallow**
   ```javascript
   // ✓ 2-3 levels max
   // ✗ Avoid 5+ levels
   ```

4. **Always set constructor property**
   ```javascript
   Child.prototype.constructor = Child;
   ```

5. **Call parent constructor in child**
   ```javascript
   function Child() {
     Parent.call(this);
   }
   ```

---

## Key Takeaways

- **Prototypal inheritance**: Objects inherit from objects
- **Prototype chain**: Property lookup walks up the chain
- **`Object.create()`**: Set prototype directly
- **Constructor inheritance**: Use `Object.create()` for prototype
- **Classes**: Modern syntax for inheritance (`extends`, `super`)
- **Method overriding**: Child can override parent methods
- **Mixins**: Simulate multiple inheritance
- **Best practice**: Prefer composition over deep inheritance
