# Constructor Functions

Constructor functions are the pre-ES6 way to create objects with shared methods using prototypes. They act as blueprints for creating multiple objects.

---

## Basic Syntax

```javascript
// Constructor function (capitalized by convention)
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// Create instances with 'new'
const person1 = new Person("John", 30);
const person2 = new Person("Jane", 25);

console.log(person1.name);  // "John"
console.log(person2.age);   // 25
```

**Convention:** Constructor function names start with capital letter.

---

## The `new` Keyword

When calling a function with `new`, JavaScript:
1. Creates a new empty object
2. Sets the prototype of the object
3. Binds `this` to the new object
4. Executes the constructor code
5. Returns the object (unless explicitly returning another object)

```javascript
function Person(name) {
  // 1. this = {} (implicitly)
  // 2. this.__proto__ = Person.prototype (implicitly)
  
  this.name = name;  // 3. Add properties
  
  // 4. return this (implicitly)
}

const person = new Person("John");
```

---

## Without `new` Keyword

```javascript
function Person(name) {
  this.name = name;
}

// ✗ Forgot 'new' - this refers to global object!
const person = Person("John");

console.log(person);        // undefined
console.log(window.name);   // "John" (in browsers)
```

### Protection Against Missing `new`

```javascript
function Person(name) {
  // Check if called with 'new'
  if (!(this instanceof Person)) {
    return new Person(name);
  }
  
  this.name = name;
}

// Works with or without 'new'
const person1 = new Person("John");
const person2 = Person("Jane");  // Automatically calls with 'new'
```

---

## Adding Methods

### Instance Methods (Inefficient)
```javascript
function Person(name) {
  this.name = name;
  
  // ✗ Creates new function for each instance
  this.greet = function() {
    return `Hello, ${this.name}`;
  };
}

const p1 = new Person("John");
const p2 = new Person("Jane");

console.log(p1.greet === p2.greet);  // false (different functions!)
```

### Prototype Methods (Efficient)
```javascript
function Person(name) {
  this.name = name;
}

// ✓ Shared method on prototype
Person.prototype.greet = function() {
  return `Hello, ${this.name}`;
};

const p1 = new Person("John");
const p2 = new Person("Jane");

console.log(p1.greet === p2.greet);  // true (same function!)

p1.greet();  // "Hello, John"
p2.greet();  // "Hello, Jane"
```

---

## Properties vs Methods

```javascript
function Person(name, age) {
  // Instance properties (unique to each object)
  this.name = name;
  this.age = age;
}

// Shared methods (on prototype)
Person.prototype.greet = function() {
  return `Hi, I'm ${this.name}`;
};

Person.prototype.getAge = function() {
  return this.age;
};

const person = new Person("John", 30);
console.log(person.name);      // Instance property
console.log(person.greet());   // Prototype method
```

---

## Constructor Property

Every prototype has a `constructor` property pointing back to the constructor function.

```javascript
function Person(name) {
  this.name = name;
}

console.log(Person.prototype.constructor === Person);  // true

const person = new Person("John");
console.log(person.constructor === Person);  // true

// Can create new instance from existing
const person2 = new person.constructor("Jane");
```

---

## Inheritance with Constructors

```javascript
// Parent constructor
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  return `${this.name} is eating`;
};

// Child constructor
function Dog(name, breed) {
  Animal.call(this, name);  // Call parent constructor
  this.breed = breed;
}

// Set up inheritance
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;  // Fix constructor

// Add child methods
Dog.prototype.bark = function() {
  return "Woof!";
};

const dog = new Dog("Buddy", "Labrador");
console.log(dog.name);    // "Buddy"
console.log(dog.breed);   // "Labrador"
console.log(dog.eat());   // "Buddy is eating"
console.log(dog.bark());  // "Woof!"
```

---

## Return Values

Constructors normally don't have explicit returns, but they can:

```javascript
function Person(name) {
  this.name = name;
  
  // Returning primitive - ignored
  return 42;
}

const p1 = new Person("John");
console.log(p1);  // Person { name: "John" } (return ignored)

function Person2(name) {
  this.name = name;
  
  // Returning object - used instead
  return { custom: true };
}

const p2 = new Person2("John");
console.log(p2);  // { custom: true } (return used)
```

---

## Practical Examples

### Counter
```javascript
function Counter(initial = 0) {
  this.count = initial;
}

Counter.prototype.increment = function() {
  this.count++;
  return this.count;
};

Counter.prototype.decrement = function() {
  this.count--;
  return this.count;
};

Counter.prototype.reset = function() {
  this.count = 0;
};

const counter = new Counter(10);
counter.increment();  // 11
counter.increment();  // 12
counter.decrement();  // 11
```

### User
```javascript
function User(name, email) {
  this.name = name;
  this.email = email;
  this.createdAt = new Date();
}

User.prototype.getProfile = function() {
  return {
    name: this.name,
    email: this.email,
    memberSince: this.createdAt
  };
};

User.prototype.updateEmail = function(newEmail) {
  this.email = newEmail;
};

const user = new User("John", "john@example.com");
console.log(user.getProfile());
```

---

## Static Methods

Methods on the constructor itself, not on instances.

```javascript
function Person(name) {
  this.name = name;
}

// Static method
Person.create = function(name) {
  return new Person(name);
};

Person.isValid = function(obj) {
  return obj instanceof Person;
};

// Call on constructor, not instance
const person = Person.create("John");
console.log(Person.isValid(person));  // true

// ✗ Not available on instances
person.create();  // Error
```

---

## Checking Instance Type

```javascript
function Person(name) {
  this.name = name;
}

const person = new Person("John");

console.log(person instanceof Person);           // true
console.log(person instanceof Object);           // true
console.log(person.constructor === Person);      // true
console.log(Object.getPrototypeOf(person) === Person.prototype);  // true
```

---

## Constructor vs Class

```javascript
// Constructor function (ES5)
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hello, ${this.name}`;
};

// Class (ES6) - syntactic sugar over constructors
class Person {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}`;
  }
}

// Both work the same way!
```

---

## Common Pitfalls

### Forgetting `new`
```javascript
function Person(name) {
  this.name = name;
}

const person = Person("John");  // ✗ this = window/global
console.log(person);            // undefined
```

### Overwriting Prototype
```javascript
function Person(name) {
  this.name = name;
}

// ✗ Loses constructor property
Person.prototype = {
  greet() { return "Hi"; }
};

// ✓ Maintain constructor
Person.prototype = {
  constructor: Person,
  greet() { return "Hi"; }
};

// ✓ Or add methods individually
Person.prototype.greet = function() { return "Hi"; };
```

### Instance Methods in Constructor
```javascript
// ✗ Memory inefficient
function Person(name) {
  this.greet = function() {
    return `Hi, ${this.name}`;
  };
}

// ✓ Use prototype
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return `Hi, ${this.name}`;
};
```

---

## Best Practices

1. **Use capital letter for constructors**
   ```javascript
   function Person() { }  // ✓
   function person() { }  // ✗
   ```

2. **Add methods to prototype**
   ```javascript
   Person.prototype.method = function() { };
   ```

3. **Always use `new`**
   ```javascript
   const p = new Person("John");
   ```

4. **Consider using classes (modern)**
   ```javascript
   class Person { }  // Cleaner syntax
   ```

5. **Validate `new` usage**
   ```javascript
   if (!(this instanceof Person)) {
     throw new Error("Must use 'new'");
   }
   ```

---

## Key Takeaways

- **Constructor functions** create objects with `new` keyword
- **Capitalize** constructor names by convention
- **`new`** creates object, sets prototype, binds `this`
- **Add methods to prototype** for memory efficiency
- **Prototype methods** are shared across instances
- **Instance properties** are unique to each object
- **Classes** are modern alternative (syntactic sugar)
- **Always use `new`** or add protection
- Returning objects overrides default return behavior
