# Object.create()

`Object.create()` creates a new object with a specified prototype, providing direct control over the prototype chain without using constructor functions.

---

## Basic Syntax

```javascript
const obj = Object.create(proto);
const obj = Object.create(proto, propertiesObject);
```

**Parameters:**
- `proto`: The object to use as prototype (or `null`)
- `propertiesObject`: Optional property descriptors

---

## Simple Usage

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Animal walks");
  }
};

// Create object with animal as prototype
const rabbit = Object.create(animal);

rabbit.jumps = true;

console.log(rabbit.eats);   // true (inherited)
console.log(rabbit.jumps);  // true (own property)
rabbit.walk();               // "Animal walks"
```

---

## Creating with null Prototype

```javascript
// Create object with no prototype
const dict = Object.create(null);

dict.name = "John";
dict.age = 30;

console.log(dict.toString);  // undefined (no inherited methods)
console.log(dict.hasOwnProperty);  // undefined

// Useful for pure dictionaries/maps
// No inherited properties to conflict with keys
```

---

## With Property Descriptors

```javascript
const person = Object.create(Object.prototype, {
  name: {
    value: "John",
    writable: true,
    enumerable: true,
    configurable: true
  },
  age: {
    value: 30,
    writable: false,  // Read-only
    enumerable: true
  }
});

person.name = "Jane";  // ✓ Works (writable: true)
person.age = 31;       // ✗ Fails silently (writable: false)
```

---

## Prototypal Inheritance Pattern

```javascript
// Parent object
const animal = {
  eats: true,
  walk() {
    console.log(`${this.name} walks`);
  }
};

// Child object
const rabbit = Object.create(animal);
rabbit.name = "Rabbit";
rabbit.jumps = true;

// Grandchild
const longEar = Object.create(rabbit);
longEar.name = "Long Ear";
longEar.earLength = 10;

longEar.walk();  // "Long Ear walks"
console.log(longEar.eats);   // true (from animal)
console.log(longEar.jumps);  // true (from rabbit)
```

---

## vs Constructor Functions

### Constructor Function Approach
```javascript
function Animal() {
  this.eats = true;
}

Animal.prototype.walk = function() {
  console.log("Walking");
};

const rabbit = new Animal();
```

### Object.create() Approach
```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Walking");
  }
};

const rabbit = Object.create(animal);
```

**Differences:**
- `Object.create()`: Direct prototype specification
- Constructor: Indirect via `Constructor.prototype`
- `Object.create()`: No constructor function needed
- Constructor: Better for creating multiple instances

---

## Implementing Inheritance

### Old Way (Before Object.create)
```javascript
function Parent() {}
function Child() {}

Child.prototype = new Parent();  // ✗ Creates unnecessary instance
Child.prototype.constructor = Child;
```

### Modern Way (With Object.create)
```javascript
function Parent() {}
function Child() {}

Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```

---

## Practical Use Cases

### 1. Pure Dictionary/Map
```javascript
const map = Object.create(null);

map["toString"] = "safe";  // No conflict with Object.prototype
map["hasOwnProperty"] = "works";

console.log(map.toString);  // "safe" (not a function)
```

### 2. Delegation Pattern
```javascript
const tasks = {
  add(task) {
    this.tasks.push(task);
  },
  list() {
    return this.tasks;
  }
};

const myTasks = Object.create(tasks);
myTasks.tasks = [];

myTasks.add("Learn JS");
myTasks.add("Build app");
console.log(myTasks.list());  // ["Learn JS", "Build app"]
```

---

## Best Practices

1. **Use for delegation patterns**
   ```javascript
   const delegate = Object.create(proto);
   ```

2. **null prototype for dictionaries**
   ```javascript
   const dict = Object.create(null);  // No inherited properties
   ```

3. **Prefer classes for complex hierarchies**
   ```javascript
   // Simple delegation: Object.create()
   // Complex inheritance: class extends
   ```

---

## Key Takeaways

- **Creates object** with specified prototype
- **Direct control** over prototype chain
- **`null` prototype** creates object with no inheritance
- **Property descriptors** for fine-grained control
- **Simpler than constructors** for delegation
- **Use for** pure dictionaries and delegation patterns
- **Modern alternative**: ES6 classes for most cases
