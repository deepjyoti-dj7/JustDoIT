# Prototype Chain

Every JavaScript object has a hidden link to another object called its prototype. This chain of prototypes is how JavaScript implements inheritance.

---

## Understanding Prototypes

```javascript
const person = {
  name: "John",
  greet() {
    return `Hello, ${this.name}`;
  }
};

console.log(person.name);     // "John" (own property)
console.log(person.toString()); // "[object Object]" (inherited from Object.prototype)
```

When accessing a property:
1. Check the object itself
2. If not found, check its prototype
3. Continue up the chain until found or reach `null`

---

## The Prototype Chain

```javascript
const obj = { a: 1 };

// Chain: obj → Object.prototype → null

console.log(obj.a);              // 1 (own property)
console.log(obj.toString());     // [object Object] (from Object.prototype)
console.log(obj.hasOwnProperty); // function (from Object.prototype)
```

### Visualizing the Chain

```javascript
const animal = { eats: true };
const rabbit = { jumps: true };

// Set rabbit's prototype to animal
Object.setPrototypeOf(rabbit, animal);

console.log(rabbit.jumps);  // true (own property)
console.log(rabbit.eats);   // true (from animal prototype)

// Chain: rabbit → animal → Object.prototype → null
```

---

## Accessing Prototypes

### Object.getPrototypeOf()
```javascript
const obj = {};
const proto = Object.getPrototypeOf(obj);

console.log(proto === Object.prototype);  // true
```

### __proto__ (Deprecated)
```javascript
const obj = {};
console.log(obj.__proto__ === Object.prototype);  // true

// Can set prototype (not recommended)
obj.__proto__ = { custom: true };
```

### Object.setPrototypeOf()
```javascript
const animal = { eats: true };
const rabbit = { jumps: true };

Object.setPrototypeOf(rabbit, animal);
console.log(rabbit.eats);  // true
```

---

## Property Lookup

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Animal walks");
  }
};

const rabbit = {
  jumps: true,
  __proto__: animal
};

const longEar = {
  earLength: 10,
  __proto__: rabbit
};

// Property lookup
console.log(longEar.earLength);  // 10 (own property)
console.log(longEar.jumps);      // true (from rabbit)
console.log(longEar.eats);       // true (from animal)
longEar.walk();                  // "Animal walks"

// Chain: longEar → rabbit → animal → Object.prototype → null
```

---

## Writing Properties

Setting properties only affects the object itself, not the prototype.

```javascript
const animal = { eats: true };
const rabbit = {
  __proto__: animal
};

rabbit.eats = false;  // Creates own property

console.log(rabbit.eats);  // false (own property)
console.log(animal.eats);  // true (prototype unchanged)

delete rabbit.eats;
console.log(rabbit.eats);  // true (now reads from prototype)
```

---

## this in Prototypes

`this` always refers to the object before the dot, not the prototype.

```javascript
const animal = {
  walk() {
    console.log(`${this.name} walks`);
  }
};

const rabbit = {
  name: "Rabbit",
  __proto__: animal
};

const bird = {
  name: "Bird",
  __proto__: animal
};

rabbit.walk();  // "Rabbit walks" (this = rabbit)
bird.walk();    // "Bird walks" (this = bird)
```

---

## Object.create()

Creates object with specified prototype.

```javascript
const animal = {
  eats: true,
  walk() {
    console.log("Walking");
  }
};

// Create object with animal as prototype
const rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.eats);   // true (from prototype)
console.log(rabbit.jumps);  // true (own property)

// Create object with null prototype (no inheritance)
const dict = Object.create(null);
dict.toString();  // Error: toString is not defined
```

---

## Checking Properties

### hasOwnProperty()
```javascript
const animal = { eats: true };
const rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.hasOwnProperty('jumps'));  // true
console.log(rabbit.hasOwnProperty('eats'));   // false (inherited)
```

### in Operator
```javascript
console.log('jumps' in rabbit);  // true (own property)
console.log('eats' in rabbit);   // true (inherited)
```

### Object.keys() vs for...in
```javascript
const animal = { eats: true };
const rabbit = Object.create(animal);
rabbit.jumps = true;

// Only own properties
console.log(Object.keys(rabbit));  // ['jumps']

// Own + inherited enumerable properties
for (let key in rabbit) {
  console.log(key);  // 'jumps', 'eats'
}

// Filter to own properties only
for (let key in rabbit) {
  if (rabbit.hasOwnProperty(key)) {
    console.log(key);  // 'jumps'
  }
}
```

---

## Array Prototype Chain

```javascript
const arr = [1, 2, 3];

// Chain: arr → Array.prototype → Object.prototype → null

arr.push(4);           // From Array.prototype
arr.toString();        // From Array.prototype (overrides Object.prototype.toString)
arr.hasOwnProperty(0); // From Object.prototype
```

---

## Function Prototype Chain

```javascript
function greet() {
  return "Hello";
}

// Chain: greet → Function.prototype → Object.prototype → null

greet.call();          // From Function.prototype
greet.apply();         // From Function.prototype
greet.toString();      // From Function.prototype
```

---

## Performance Considerations

```javascript
const animal = { eats: true };
const rabbit = Object.create(animal);

// Own property - fast lookup
rabbit.jumps = true;
console.log(rabbit.jumps);  // Fast

// Inherited property - slower (walks up chain)
console.log(rabbit.eats);  // Slower

// Not found - slowest (walks entire chain)
console.log(rabbit.flies);  // Slowest
```

**Optimization tip:** Keep frequently accessed properties on the object itself.

---

## Common Patterns

### Extending Built-ins (Not Recommended)
```javascript
// ✗ Avoid modifying built-in prototypes
Array.prototype.first = function() {
  return this[0];
};

[1, 2, 3].first();  // 1

// Problems: conflicts, unexpected behavior in for...in loops
```

### Safe Property Check
```javascript
// Check if property exists anywhere in chain
if ('toString' in obj) { }

// Check if property is own property
if (obj.hasOwnProperty('toString')) { }

// Modern alternative
if (Object.hasOwn(obj, 'toString')) { }
```

---

## Prototype Chain Diagram

```
longEar object
  ↓ [[Prototype]]
rabbit object
  ↓ [[Prototype]]
animal object
  ↓ [[Prototype]]
Object.prototype
  ↓ [[Prototype]]
null
```

---

## Best Practices

1. **Use Object.create() for prototypal inheritance**
   ```javascript
   const child = Object.create(parent);
   ```

2. **Don't modify built-in prototypes**
   ```javascript
   // ✗ Avoid
   Array.prototype.myMethod = function() { };
   ```

3. **Use hasOwnProperty() when iterating**
   ```javascript
   for (let key in obj) {
     if (obj.hasOwnProperty(key)) {
       // Use key
     }
   }
   ```

4. **Prefer classes for inheritance (modern)**
   ```javascript
   class Child extends Parent { }
   ```

5. **Be aware of prototype chain performance**
   - Own properties: fastest
   - Prototype properties: slower
   - Missing properties: slowest

---

## Key Takeaways

- **Every object has a prototype** (except objects created with `Object.create(null)`)
- **Prototype chain** enables inheritance
- **Property lookup** walks up the chain until found or reaches `null`
- **Writing properties** only affects the object, not prototype
- **`this` binding** always points to the object before the dot
- **Use `hasOwnProperty()`** to check own properties
- **Performance**: Own properties faster than inherited
- **Modern approach**: Use classes instead of manual prototype manipulation