# __proto__ vs prototype

Understanding the difference between `__proto__` and `prototype` is crucial for mastering JavaScript's prototypal inheritance.

---

## The Difference

**`prototype`**: Property of constructor functions
**`__proto__`**: Property of objects (points to their prototype)

```javascript
function Person(name) {
  this.name = name;
}

// prototype: on constructor
console.log(typeof Person.prototype);  // "object"

const person = new Person("John");

// __proto__: on instance
console.log(person.__proto__ === Person.prototype);  // true
```

---

## prototype Property

Only **functions** have a `prototype` property (except arrow functions).

```javascript
function Person() {}

console.log(Person.prototype);  // { constructor: Person }
console.log(Person.prototype.constructor === Person);  // true

// Add methods to prototype
Person.prototype.greet = function() {
  return "Hello";
};

const person = new Person();
person.greet();  // "Hello" (inherited from Person.prototype)
```

### What is prototype?

The `prototype` property is an object that becomes the `__proto__` of instances created by that constructor.

```javascript
function Dog(name) {
  this.name = name;
}

Dog.prototype.bark = function() {
  return "Woof!";
};

const dog = new Dog("Buddy");

// The connection:
console.log(dog.__proto__ === Dog.prototype);  // true
```

---

## __proto__ Property

Every **object** has a `__proto__` property (internal `[[Prototype]]`).

```javascript
const obj = {};

console.log(obj.__proto__);  // Object.prototype
console.log(obj.__proto__ === Object.prototype);  // true
```

### What is __proto__?

`__proto__` is the actual object used in the prototype chain for property lookup.

```javascript
const animal = { eats: true };
const rabbit = { jumps: true };

rabbit.__proto__ = animal;

console.log(rabbit.eats);   // true (from prototype)
console.log(rabbit.jumps);  // true (own property)
```

---

## The Relationship

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hi, I'm ${this.name}`;
};

const person = new Person("John");

// The connection:
// person.__proto__ === Person.prototype

console.log(person.__proto__ === Person.prototype);  // true
console.log(Object.getPrototypeOf(person) === Person.prototype);  // true
```

### Visual Representation

```
Person (constructor function)
  |
  | .prototype property
  ↓
Person.prototype (object)
  ↑
  | .__proto__ property
  |
person (instance)
```

---

## Complete Example

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  return `${this.name} is eating`;
};

const dog = new Animal("Buddy");

// Properties on instance
console.log(dog.name);  // "Buddy"

// Methods on prototype
console.log(dog.eat());  // "Buddy is eating"

// The connections
console.log(dog.__proto__ === Animal.prototype);  // true
console.log(dog.constructor === Animal);  // true
console.log(Animal.prototype.constructor === Animal);  // true
```

---

## Functions and prototype

```javascript
function myFunction() {}

// Functions have BOTH __proto__ and prototype

// prototype: for instances created with 'new'
console.log(myFunction.prototype);  // {}

// __proto__: function's own prototype (Function.prototype)
console.log(myFunction.__proto__ === Function.prototype);  // true
```

---

## Objects and __proto__

```javascript
const obj = {};

// Objects have __proto__ but NOT prototype

console.log(obj.__proto__);  // Object.prototype
console.log(obj.prototype);  // undefined

// Only functions have prototype property
```

---

## Arrow Functions Exception

Arrow functions don't have `prototype` property.

```javascript
const arrowFunc = () => {};

console.log(arrowFunc.prototype);  // undefined

// Can't be used as constructor
// new arrowFunc();  // TypeError

// But has __proto__
console.log(arrowFunc.__proto__ === Function.prototype);  // true
```

---

## Modern Alternative: Object.getPrototypeOf()

`__proto__` is deprecated. Use `Object.getPrototypeOf()` instead.

```javascript
const obj = {};

// ✗ Deprecated
console.log(obj.__proto__);

// ✓ Modern approach
console.log(Object.getPrototypeOf(obj));

// Both point to same object
console.log(obj.__proto__ === Object.getPrototypeOf(obj));  // true
```

### Setting Prototypes

```javascript
const animal = { eats: true };
const rabbit = { jumps: true };

// ✗ Deprecated
rabbit.__proto__ = animal;

// ✓ Modern approach
Object.setPrototypeOf(rabbit, animal);

// ✓ At creation
const rabbit2 = Object.create(animal);
rabbit2.jumps = true;
```

---

## Practical Examples

### Constructor Pattern

```javascript
function Car(brand) {
  this.brand = brand;
}

// Add method to prototype (shared by all instances)
Car.prototype.drive = function() {
  return `${this.brand} is driving`;
};

const car1 = new Car("Toyota");
const car2 = new Car("Honda");

// Both share same method (memory efficient)
console.log(car1.drive === car2.drive);  // true

// The connection
console.log(car1.__proto__ === Car.prototype);  // true
console.log(car2.__proto__ === Car.prototype);  // true
```

### Inheritance Chain

```javascript
function Animal() {}
Animal.prototype.eat = function() {
  console.log("Eating");
};

function Dog() {}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function() {
  console.log("Barking");
};

const dog = new Dog();

// Chain visualization:
// dog.__proto__ === Dog.prototype
// Dog.prototype.__proto__ === Animal.prototype
// Animal.prototype.__proto__ === Object.prototype
// Object.prototype.__proto__ === null

console.log(dog.__proto__ === Dog.prototype);  // true
console.log(Dog.prototype.__proto__ === Animal.prototype);  // true
console.log(Animal.prototype.__proto__ === Object.prototype);  // true
console.log(Object.prototype.__proto__);  // null (end of chain)
```

---

## Common Mistakes

### Confusing the Two

```javascript
function Person() {}

const person = new Person();

// ✗ Wrong
console.log(person.prototype);  // undefined (objects don't have prototype)

// ✓ Correct
console.log(person.__proto__);  // Person.prototype
console.log(Person.prototype);  // The prototype object
```

### Modifying __proto__

```javascript
// ✗ Don't do this (performance issues)
obj.__proto__ = newProto;

// ✓ Use these instead
Object.setPrototypeOf(obj, newProto);  // For existing objects
const obj = Object.create(newProto);    // For new objects
```

---

## Quick Reference Table

| Feature | `prototype` | `__proto__` |
|---------|------------|-------------|
| **Exists on** | Functions (constructors) | All objects |
| **Points to** | Object that will be prototype of instances | Object's actual prototype |
| **Purpose** | Template for new objects | Link in prototype chain |
| **Set by** | You manually | `new` keyword or `Object.create()` |
| **Modern alternative** | N/A (still used) | `Object.getPrototypeOf()` / `Object.setPrototypeOf()` |

---

## Checking Relationships

```javascript
function Person() {}
const person = new Person();

// Check prototype relationship
console.log(person.__proto__ === Person.prototype);  // true
console.log(Object.getPrototypeOf(person) === Person.prototype);  // true

// Check if object is in prototype chain
console.log(Person.prototype.isPrototypeOf(person));  // true

// Check instance
console.log(person instanceof Person);  // true
```

---

## Best Practices

1. **Don't use `__proto__` directly**
   ```javascript
   // ✗ Avoid
   obj.__proto__ = proto;
   
   // ✓ Use
   Object.setPrototypeOf(obj, proto);
   Object.getPrototypeOf(obj);
   ```

2. **Use `prototype` for constructor methods**
   ```javascript
   function Person() {}
   Person.prototype.greet = function() {};
   ```

3. **Use `Object.create()` for inheritance**
   ```javascript
   Child.prototype = Object.create(Parent.prototype);
   ```

4. **Prefer classes (modern)**
   ```javascript
   class Child extends Parent {}
   ```

5. **Understand the relationship**
   ```javascript
   instance.__proto__ === Constructor.prototype
   ```

---

## Key Takeaways

- **`prototype`** is a property of **constructor functions**
- **`__proto__`** is a property of **all objects**
- **`instance.__proto__`** points to **`Constructor.prototype`**
- **`__proto__`** is deprecated - use `Object.getPrototypeOf()`
- **Arrow functions** don't have `prototype`
- **Only functions** have `prototype` property
- **All objects** have `__proto__` (or `[[Prototype]]`)
- **Prototype chain**: `obj.__proto__.__proto__...` → `null`
- **Modern approach**: Use `Object.getPrototypeOf()` and `Object.setPrototypeOf()`
