# Common Pitfalls

Common mistakes and how to avoid them.

---

## Type Coercion Gotchas

JavaScript's type coercion can be surprising.

```javascript
// Equality comparisons
console.log(0 == '0');        // true (type coercion)
console.log(0 === '0');       // false (strict equality)
console.log('' == false);     // true
console.log('' === false);    // false

// Always use === and !== instead of == and !=

// Truthy/falsy surprises
console.log(Boolean('0'));         // true (non-empty string)
console.log(Boolean('false'));     // true (non-empty string)
console.log(Boolean([]));          // true (empty array is truthy!)
console.log(Boolean({}));          // true (empty object is truthy!)

// Checking for empty array/object
const arr = [];
if (arr.length === 0) { }  // Correct

const obj = {};
if (Object.keys(obj).length === 0) { }  // Correct

// Addition vs concatenation
console.log(1 + 2);           // 3 (addition)
console.log(1 + '2');         // "12" (concatenation)
console.log('1' + 2);         // "12" (concatenation)
console.log('1' + 2 + 3);     // "123"
console.log(1 + 2 + '3');     // "33"

// Use explicit conversion
const num = Number('42');     // 42
const str = String(42);       // "42"

// NaN comparisons
console.log(NaN === NaN);     // false
console.log(NaN == NaN);      // false
console.log(Number.isNaN(NaN));  // true (correct way)

// Null and undefined
console.log(null == undefined);   // true
console.log(null === undefined);  // false
console.log(typeof null);         // "object" (JavaScript bug)
console.log(typeof undefined);    // "undefined"
```

---

## The 'this' Keyword

Understanding 'this' context.

```javascript
// Problem: Lost 'this' context
const person = {
  name: 'John',
  greet: function() {
    console.log(`Hello, ${this.name}`);
  }
};

person.greet();           // "Hello, John"
const greet = person.greet;
greet();                  // "Hello, undefined" (this is window/global)

// Solution 1: Use bind
const boundGreet = person.greet.bind(person);
boundGreet();             // "Hello, John"

// Solution 2: Use arrow function
const person2 = {
  name: 'Jane',
  greet: function() {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`);  // 'this' is lexically bound
    }, 1000);
  }
};

// Problem: 'this' in callbacks
class Counter {
  constructor() {
    this.count = 0;
  }
  
  // Bad - loses 'this'
  increment() {
    setTimeout(function() {
      this.count++;  // 'this' is undefined or window
    }, 1000);
  }
  
  // Good - arrow function
  incrementCorrect() {
    setTimeout(() => {
      this.count++;  // 'this' is Counter instance
    }, 1000);
  }
  
  // Good - bind
  incrementBind() {
    setTimeout(function() {
      this.count++;
    }.bind(this), 1000);
  }
}

// Problem: 'this' in event listeners
class Button {
  constructor(element) {
    this.element = element;
    this.clickCount = 0;
    
    // Bad - loses 'this'
    this.element.addEventListener('click', this.handleClick);
    
    // Good - arrow function
    this.element.addEventListener('click', () => this.handleClick());
    
    // Good - bind
    this.element.addEventListener('click', this.handleClick.bind(this));
  }
  
  handleClick() {
    this.clickCount++;
  }
}
```

---

## Closures and Loops

Variables in closures can behave unexpectedly.

```javascript
// Problem: var in loops
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // Prints "3" three times
  }, 1000);
}

// Solution 1: Use let
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);  // Prints 0, 1, 2
  }, 1000);
}

// Solution 2: IIFE (Immediately Invoked Function Expression)
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);  // Prints 0, 1, 2
    }, 1000);
  })(i);
}

// Problem: Creating functions in loops
const functions = [];
for (var i = 0; i < 3; i++) {
  functions.push(function() {
    return i;
  });
}
console.log(functions[0]());  // 3 (not 0!)

// Solution: Use let or closures
const functionsFixed = [];
for (let i = 0; i < 3; i++) {
  functionsFixed.push(function() {
    return i;
  });
}
console.log(functionsFixed[0]());  // 0
```

---

## Asynchronous Code Mistakes

Common async/await and Promise pitfalls.

```javascript
// Problem: Forgetting await
async function getData() {
  const data = fetch('/api/data');  // Missing await!
  console.log(data);  // Logs Promise, not data
}

// Solution: Use await
async function getDataCorrect() {
  const response = await fetch('/api/data');
  const data = await response.json();
  console.log(data);
}

// Problem: Not handling errors
async function riskyOperation() {
  const data = await fetch('/api/data');  // What if this fails?
  return data.json();
}

// Solution: Use try-catch
async function safeOperation() {
  try {
    const response = await fetch('/api/data');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch data:', error);
    throw error;
  }
}

// Problem: Sequential when parallel is possible
async function slowFetch() {
  const user = await fetchUser();        // Wait 1 second
  const posts = await fetchPosts();      // Wait another 1 second
  const comments = await fetchComments();  // Wait another 1 second
  // Total: 3 seconds
}

// Solution: Use Promise.all for parallel operations
async function fastFetch() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ]);
  // Total: 1 second (parallel)
}

// Problem: Not returning in async function
async function getData() {
  fetch('/api/data')  // Not awaited, not returned!
    .then(res => res.json());
}

// Solution: Return the Promise or await
async function getDataCorrect() {
  return fetch('/api/data')
    .then(res => res.json());
  
  // Or
  const response = await fetch('/api/data');
  return response.json();
}

// Problem: Mixing async/await with .then
async functionæ··ed() {
  const data = await fetch('/api/data')
    .then(res => res.json());  // Mixing patterns
  return data;
}

// Solution: Choose one pattern
async function consistent() {
  const response = await fetch('/api/data');
  const data = await response.json();
  return data;
}
```

---

## Array and Object Mutations

Unintentional mutations can cause bugs.

```javascript
// Problem: Mutating original array
const numbers = [1, 2, 3];
const sorted = numbers.sort();  // Mutates original!
console.log(numbers);  // [1, 2, 3] (also sorted)

// Solution: Create a copy first
const numbersCopy = [...numbers];
const sortedCopy = numbersCopy.sort();

// Or use toSorted (ES2023)
const sortedNew = numbers.toSorted();

// Problem: Reference assignment
const obj1 = { name: 'John' };
const obj2 = obj1;  // Same reference!
obj2.name = 'Jane';
console.log(obj1.name);  // "Jane" (also changed)

// Solution: Create a copy
const obj3 = { ...obj1 };  // Shallow copy
const obj4 = JSON.parse(JSON.stringify(obj1));  // Deep copy (simple objects)
const obj5 = structuredClone(obj1);  // Deep copy (modern)

// Problem: Pushing to array in reduce
const result = items.reduce((acc, item) => {
  acc.push(item * 2);  // Mutating accumulator
  return acc;
}, []);

// Better: Use map for transformations
const result2 = items.map(item => item * 2);

// Problem: Mutating function parameters
function addItem(arr, item) {
  arr.push(item);  // Mutates original array
  return arr;
}

// Solution: Return new array
function addItemPure(arr, item) {
  return [...arr, item];
}

// Problem: forEach with mutations
const doubled = [];
numbers.forEach(num => {
  doubled.push(num * 2);  // Side effect
});

// Solution: Use map
const doubled2 = numbers.map(num => num * 2);
```

---

## Scope and Hoisting Issues

Understanding variable scope and hoisting.

```javascript
// Problem: var hoisting
console.log(x);  // undefined (not ReferenceError)
var x = 5;

// What JavaScript sees:
var x;
console.log(x);
x = 5;

// Solution: Use let/const (not hoisted in same way)
console.log(y);  // ReferenceError
let y = 5;

// Problem: Function hoisting
greet();  // Works!
function greet() {
  console.log('Hello');
}

// But function expressions don't hoist
hello();  // TypeError: hello is not a function
var hello = function() {
  console.log('Hello');
};

// Problem: Block scope with var
if (true) {
  var x = 10;
}
console.log(x);  // 10 (var is function-scoped, not block-scoped)

// Solution: Use let/const
if (true) {
  let y = 10;
}
console.log(y);  // ReferenceError

// Problem: Redeclaration with var
var name = 'John';
var name = 'Jane';  // No error!
console.log(name);  // "Jane"

// Solution: Use let/const (prevents redeclaration)
let name2 = 'John';
let name2 = 'Jane';  // SyntaxError
```

---

## Floating Point Precision

JavaScript uses IEEE 754 floating point.

```javascript
// Problem: Precision errors
console.log(0.1 + 0.2);  // 0.30000000000000004 (not 0.3!)
console.log(0.1 + 0.2 === 0.3);  // false

// Solution: Use toFixed or epsilon comparison
console.log((0.1 + 0.2).toFixed(2));  // "0.30"

function areEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

console.log(areEqual(0.1 + 0.2, 0.3));  // true

// For money, use integers (cents)
const price = 1050;  // $10.50 stored as cents
const display = `$${(price / 100).toFixed(2)}`;  // "$10.50"

// Or use a library like decimal.js for precise calculations
```

---

## String and Number Conversions

Unexpected type conversions.

```javascript
// Problem: Implicit conversion with +
console.log('5' + 3);    // "53" (concatenation)
console.log('5' - 3);    // 2 (subtraction)
console.log('5' * 3);    // 15 (multiplication)

// Solution: Explicit conversion
console.log(Number('5') + 3);  // 8
console.log('5' + String(3));  // "53"

// Problem: parseInt without radix
console.log(parseInt('08'));   // 8 (used to be 0 in old browsers!)
console.log(parseInt('0x10')); // 16 (hexadecimal)

// Solution: Always specify radix
console.log(parseInt('08', 10));   // 8
console.log(parseInt('10', 2));    // 2 (binary)

// Problem: Checking for number
console.log(typeof '5');    // "string"
console.log(typeof NaN);    // "number"
console.log(isNaN('hello')); // true (coerces to number first)

// Solution: Use proper checks
console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN('hello'));    // false
console.log(Number.isFinite(42));      // true
console.log(Number.isFinite(Infinity));  // false
```

---

## Array Methods Confusion

Understanding return values and mutations.

```javascript
// Methods that mutate
const arr1 = [1, 2, 3];
arr1.push(4);      // Returns new length (4), mutates
arr1.pop();        // Returns removed item (4), mutates
arr1.shift();      // Returns removed item (1), mutates
arr1.unshift(0);   // Returns new length, mutates
arr1.splice(1, 1); // Returns removed items, mutates
arr1.sort();       // Returns sorted array, mutates
arr1.reverse();    // Returns reversed array, mutates

// Methods that don't mutate
const arr2 = [1, 2, 3];
arr2.map(x => x * 2);     // Returns new array
arr2.filter(x => x > 1);  // Returns new array
arr2.slice(1, 2);         // Returns new array
arr2.concat([4, 5]);      // Returns new array
arr2.includes(2);         // Returns boolean
arr2.find(x => x > 1);    // Returns item or undefined
arr2.findIndex(x => x > 1); // Returns index or -1

// ES2023 immutable methods
arr2.toSorted();          // Returns new sorted array
arr2.toReversed();        // Returns new reversed array
arr2.toSpliced(1, 1, 4);  // Returns new array
arr2.with(0, 10);         // Returns new array

// Problem: Expecting return value
const numbers = [3, 1, 2];
const sorted = numbers.sort();  // Both are same reference!
console.log(numbers === sorted);  // true

// Solution: Copy first
const sortedCopy = [...numbers].sort();
```

---

## Object Property Access

Pitfalls with property access and keys.

```javascript
// Problem: Accessing nested properties
const user = { name: 'John' };
console.log(user.address.city);  // TypeError: Cannot read property 'city' of undefined

// Solution: Optional chaining
console.log(user.address?.city);  // undefined (no error)

// Problem: Dynamic property names
const key = 'name';
const obj = {};
obj.key = 'John';  // Sets property named "key", not "name"!
console.log(obj);  // { key: "John" }

// Solution: Use bracket notation
obj[key] = 'John';
console.log(obj);  // { name: "John" }

// Problem: Reserved words as keys
const obj2 = {
  class: 'A',  // "class" is reserved, but this works
  for: 'B'     // "for" is reserved, but this works
};
console.log(obj2.class);  // Works in modern JS

// But be careful with dot notation in old browsers
// Use brackets: obj2['class']

// Problem: Numeric keys
const obj3 = {
  1: 'one',
  2: 'two'
};
console.log(obj3.1);   // SyntaxError
console.log(obj3[1]);  // "one" (correct)

// Problem: Object.keys order
// While modern JS maintains insertion order,
// don't rely on it for critical logic
```

---

## Function Default Parameters

Understanding default parameter behavior.

```javascript
// Problem: Using falsy values
function greet(name = 'Guest') {
  console.log(`Hello, ${name}`);
}

greet('');       // "Hello, " (empty string is used!)
greet(null);     // "Hello, null" (null is used!)
greet(undefined); // "Hello, Guest" (default is used)

// Solution: Explicit check if needed
function greetFixed(name) {
  name = name || 'Guest';  // But watch out for '', 0, false
  console.log(`Hello, ${name}`);
}

// Better: Nullish coalescing
function greetBetter(name) {
  name = name ?? 'Guest';  // Only null/undefined trigger default
  console.log(`Hello, ${name}`);
}

// Problem: Default parameters with mutations
function addToArray(arr = []) {
  arr.push(1);
  return arr;
}

console.log(addToArray());  // [1]
console.log(addToArray());  // [1] (new array each time - this is correct)

// But with object mutation
const defaultConfig = { debug: false };
function setConfig(config = defaultConfig) {
  config.debug = true;  // Mutates shared object!
  return config;
}
```

---

## Regular Expression Pitfalls

Common regex mistakes.

```javascript
// Problem: Forgetting global flag
const text = 'hello hello';
const regex = /hello/;  // No 'g' flag
console.log(text.replace(regex, 'hi'));  // "hi hello" (only first match)

// Solution: Use global flag
const regexGlobal = /hello/g;
console.log(text.replace(regexGlobal, 'hi'));  // "hi hi"

// Problem: Stateful regex with global flag
const regex2 = /\d+/g;
console.log(regex2.test('123'));  // true
console.log(regex2.test('123'));  // false (lastIndex is not reset!)

// Solution: Reset lastIndex or create new regex
regex2.lastIndex = 0;

// Problem: Not escaping special characters
const userInput = 'user.name';
const regex3 = new RegExp(userInput);  // Matches any character, not just '.'

// Solution: Escape special characters
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

---

## Key Takeaways

- **Use strict equality (===)**: Avoid type coercion surprises
- **Understand 'this'**: Use arrow functions or bind
- **Use let/const**: Avoid var and hoisting issues
- **Handle async errors**: Always use try-catch with await
- **Avoid mutations**: Use spread operator, toSorted, etc.
- **Check for existence**: Use optional chaining (?.)
- **Explicit conversions**: Don't rely on implicit coercion
- **Array methods**: Know which mutate vs return new
- **Floating point**: Use epsilon comparison or integers
- **Default parameters**: Remember undefined triggers default
- **Copy objects/arrays**: Use spread or structuredClone
- **Regex flags**: Remember 'g' for replaceAll behavior
- Learn from errors
- Use ESLint to catch common mistakes
- Read documentation carefully
