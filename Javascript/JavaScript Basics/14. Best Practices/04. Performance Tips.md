# Performance Tips

Best practices for writing performant JavaScript code.

---

## Minimize DOM Access

DOM operations are expensive. Cache DOM references and minimize access.

```javascript
// Bad - multiple DOM queries
document.getElementById('title').textContent = 'Title';
document.getElementById('title').style.color = 'blue';
document.getElementById('title').classList.add('active');

// Good - cache reference
const title = document.getElementById('title');
title.textContent = 'Title';
title.style.color = 'blue';
title.classList.add('active');

// Bad - query in loop
for (let i = 0; i < items.length; i++) {
  document.querySelector('.container').appendChild(createItem(items[i]));
}

// Good - cache and use fragment
const container = document.querySelector('.container');
const fragment = document.createDocumentFragment();

for (let i = 0; i < items.length; i++) {
  fragment.appendChild(createItem(items[i]));
}

container.appendChild(fragment);
```

---

## Batch DOM Updates

Minimize reflows and repaints.

```javascript
// Bad - multiple reflows
element.style.width = '100px';
element.style.height = '100px';
element.style.color = 'blue';

// Good - single reflow
element.style.cssText = 'width: 100px; height: 100px; color: blue;';

// Or use class
element.className = 'styled-element';

// Bad - reading and writing alternately causes multiple reflows
const width = element.offsetWidth;
element.style.width = width + 10 + 'px';
const height = element.offsetHeight;
element.style.height = height + 10 + 'px';

// Good - batch reads, then writes
const width = element.offsetWidth;
const height = element.offsetHeight;
element.style.width = width + 10 + 'px';
element.style.height = height + 10 + 'px';
```

---

## Debounce and Throttle

Control execution frequency of expensive operations.

```javascript
// Debounce - execute after delay
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// Usage
const handleSearch = debounce((query) => {
  fetchSearchResults(query);
}, 300);

input.addEventListener('input', (e) => handleSearch(e.target.value));

// Throttle - execute at most once per interval
function throttle(func, interval) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      func.apply(this, args);
    }
  };
}

// Usage
const handleScroll = throttle(() => {
  console.log('Scroll position:', window.scrollY);
}, 100);

window.addEventListener('scroll', handleScroll);
```

---

## Use Event Delegation

Attach one listener to parent instead of many to children.

```javascript
// Bad - listener on each item
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});

// Good - single listener on parent
document.querySelector('.container').addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    handleClick(e);
  }
});
```

---

## Optimize Loops

Avoid expensive operations in loops.

```javascript
// Bad - recalculating length each iteration
for (let i = 0; i < array.length; i++) {
  process(array[i]);
}

// Good - cache length
const length = array.length;
for (let i = 0; i < length; i++) {
  process(array[i]);
}

// Better - use for...of
for (const item of array) {
  process(item);
}

// Best - use appropriate array method
array.forEach(process);

// Bad - DOM query in loop
for (let i = 0; i < items.length; i++) {
  document.getElementById('container').appendChild(items[i]);
}

// Good - query once
const container = document.getElementById('container');
for (const item of items) {
  container.appendChild(item);
}
```

---

## Avoid Memory Leaks

Clean up resources properly.

```javascript
// Remove event listeners
function setupListeners() {
  const button = document.getElementById('btn');
  
  const handleClick = () => console.log('Clicked');
  button.addEventListener('click', handleClick);
  
  return () => button.removeEventListener('click', handleClick);
}

const cleanup = setupListeners();
// Later: cleanup();

// Clear timers
const intervalId = setInterval(doSomething, 1000);
// Later: clearInterval(intervalId);

// Use WeakMap for private data
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { password: 'secret' });
    this.name = name;
  }
}
// When user is deleted, private data is auto-cleaned
```

---

## Lazy Loading

Load resources only when needed.

```javascript
// Lazy load images
const images = document.querySelectorAll('img[data-src]');

const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      imageObserver.unobserve(img);
    }
  });
});

images.forEach(img => imageObserver.observe(img));

// Dynamic imports
button.addEventListener('click', async () => {
  const { heavyFunction } = await import('./heavy-module.js');
  heavyFunction();
});
```

---

## Use Web Workers

Offload heavy computations to background threads.

```javascript
// worker.js
self.onmessage = (e) => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
};

// main.js
const worker = new Worker('worker.js');

worker.postMessage(data);

worker.onmessage = (e) => {
  console.log('Result:', e.data);
};
```

---

## Optimize Array Operations

Choose the right method for the task.

```javascript
// Finding single item
const user = users.find(u => u.id === 123);  // Stops at first match

// Check existence
const exists = users.some(u => u.id === 123);  // Stops at first match

// Filter then process
const activeUsers = users.filter(u => u.isActive);
activeUsers.forEach(process);

// Use map for transformations
const names = users.map(u => u.name);

// Use reduce for aggregation
const total = items.reduce((sum, item) => sum + item.price, 0);

// Avoid creating intermediate arrays
// Bad
const result = data
  .map(x => x * 2)
  .filter(x => x > 10)
  .map(x => x / 2);

// Better - combine operations
const result = data.reduce((acc, x) => {
  const doubled = x * 2;
  if (doubled > 10) {
    acc.push(doubled / 2);
  }
  return acc;
}, []);
```

---

## String Concatenation

Use appropriate method for string building.

```javascript
// Small strings - any method is fine
const str = 'Hello' + ' ' + 'World';
const str2 = `Hello ${'World'}`;

// Large strings or loops - use array join
const parts = [];
for (let i = 0; i < 1000; i++) {
  parts.push(`Item ${i}`);
}
const result = parts.join(', ');

// Template literals for readability
const html = `
  <div class="${className}">
    <h1>${title}</h1>
    <p>${content}</p>
  </div>
`;
```

---

## Object Creation

Use object literals and avoid unnecessary objects.

```javascript
// Good - object literal
const user = {
  name: 'John',
  age: 30
};

// Avoid unnecessary objects in loops
// Bad
const results = [];
for (let i = 0; i < 1000; i++) {
  results.push({ index: i, value: i * 2 });
}

// Better if you only need values
const values = new Array(1000);
for (let i = 0; i < 1000; i++) {
  values[i] = i * 2;
}
```

---

## Use Appropriate Data Structures

Choose the right structure for your use case.

```javascript
// Set for unique values
const uniqueIds = new Set();
uniqueIds.add(1);
uniqueIds.add(2);
uniqueIds.add(1);  // Ignored
console.log(uniqueIds.size);  // 2

// Map for key-value pairs
const cache = new Map();
cache.set(key, value);
const cached = cache.get(key);  // O(1) lookup

// Object for simple lookups
const lookup = {
  key1: 'value1',
  key2: 'value2'
};
```

---

## Avoid eval and Function Constructor

They prevent optimizations.

```javascript
// Bad - slow and insecure
eval('const x = 5 + 3');
const fn = new Function('a', 'b', 'return a + b');

// Good - use direct code
const x = 5 + 3;
const fn = (a, b) => a + b;
```

---

## Use requestAnimationFrame

For animations and visual updates.

```javascript
// Bad - setInterval for animations
setInterval(() => {
  element.style.left = position + 'px';
  position += 1;
}, 16);

// Good - requestAnimationFrame
function animate() {
  element.style.left = position + 'px';
  position += 1;
  
  if (position < 500) {
    requestAnimationFrame(animate);
  }
}

requestAnimationFrame(animate);
```

---

## Memoization

Cache expensive function results.

```javascript
function memoize(fn) {
  const cache = new Map();
  
  return function(...args) {
    const key = JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

const fibonacci = memoize((n) => {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(40));  // Much faster with memoization
```

---

## Avoid Forced Synchronous Layouts

Don't read layout properties after modifying them.

```javascript
// Bad - forced reflow
element.style.width = '100px';
const width = element.offsetWidth;  // Forces reflow
element.style.height = '100px';
const height = element.offsetHeight;  // Forces reflow

// Good - batch reads and writes
const width = element.offsetWidth;
const height = element.offsetHeight;
element.style.width = '100px';
element.style.height = '100px';
```

---

## Use CSS for Animations

CSS animations are hardware-accelerated.

```javascript
// Bad - JavaScript animation
function animate() {
  element.style.left = position + 'px';
  position += 1;
  requestAnimationFrame(animate);
}

// Good - CSS animation
element.classList.add('animate');

/* CSS */
.animate {
  animation: slide 1s ease-in-out;
}

@keyframes slide {
  from { left: 0; }
  to { left: 500px; }
}
```

---

## Key Takeaways

- **Minimize DOM access**: Cache references, use fragments
- **Batch updates**: Reduce reflows and repaints
- **Debounce/throttle**: Control execution frequency
- **Event delegation**: Single listener on parent
- **Optimize loops**: Cache length, use appropriate methods
- **Clean up**: Remove listeners, clear timers
- **Lazy load**: Load resources on demand
- **Web Workers**: Offload heavy computations
- **Right data structure**: Set, Map, Object appropriately
- **Memoize**: Cache expensive calculations
- **CSS animations**: Use GPU-accelerated CSS
- Use Chrome DevTools Performance tab
- Profile before optimizing
- Premature optimization is the root of all evil
