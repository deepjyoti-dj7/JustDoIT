# Security Considerations

Best practices for writing secure JavaScript code.

---

## Input Validation and Sanitization

Always validate and sanitize user input.

```javascript
// Validate email
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// Validate and sanitize string
function sanitizeString(input) {
  if (typeof input !== 'string') {
    throw new TypeError('Expected string');
  }
  
  // Remove HTML tags
  return input.replace(/<[^>]*>/g, '');
}

// Validate number range
function validateAge(age) {
  const num = parseInt(age, 10);
  
  if (isNaN(num)) {
    throw new Error('Age must be a number');
  }
  
  if (num < 0 || num > 150) {
    throw new Error('Invalid age range');
  }
  
  return num;
}

// Whitelist validation
function validateUserRole(role) {
  const validRoles = ['user', 'admin', 'moderator'];
  
  if (!validRoles.includes(role)) {
    throw new Error('Invalid role');
  }
  
  return role;
}
```

---

## Prevent XSS (Cross-Site Scripting)

Never insert untrusted data directly into the DOM.

```javascript
// Bad - vulnerable to XSS
const userInput = '<img src=x onerror=alert("XSS")>';
element.innerHTML = userInput;

// Good - use textContent
element.textContent = userInput;

// If HTML is needed, sanitize it
function sanitizeHTML(html) {
  const temp = document.createElement('div');
  temp.textContent = html;
  return temp.innerHTML;
}

// Or use a library like DOMPurify
import DOMPurify from 'dompurify';
element.innerHTML = DOMPurify.sanitize(userInput);

// Bad - dynamic script execution
eval(userInput);
new Function(userInput)();

// Good - avoid eval entirely, use safe alternatives
const data = JSON.parse(jsonString);

// Bad - XSS in attributes
element.setAttribute('href', userInput);

// Good - validate URLs
function isValidURL(url) {
  try {
    const parsed = new URL(url);
    return ['http:', 'https:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}

if (isValidURL(userInput)) {
  element.setAttribute('href', userInput);
}
```

---

## Prevent CSRF (Cross-Site Request Forgery)

Use CSRF tokens for state-changing operations.

```javascript
// Include CSRF token in requests
async function updateProfile(data) {
  const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
  
  const response = await fetch('/api/profile', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify(data)
  });
  
  return response.json();
}

// Verify token on server
// This is server-side code (Node.js example)
app.post('/api/profile', (req, res) => {
  const token = req.headers['x-csrf-token'];
  
  if (!isValidCSRFToken(token, req.session)) {
    return res.status(403).json({ error: 'Invalid CSRF token' });
  }
  
  // Process request
});
```

---

## Secure Authentication

Handle authentication securely.

```javascript
// Use HTTPS only
if (location.protocol !== 'https:') {
  location.href = 'https:' + window.location.href.substring(window.location.protocol.length);
}

// Never store passwords in plain text
// Hash passwords before sending (server should hash again)
async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Secure login function
async function login(email, password) {
  try {
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ email, password }),
      credentials: 'include'  // Include cookies
    });
    
    if (!response.ok) {
      throw new Error('Login failed');
    }
    
    // Don't store sensitive data in localStorage
    // Use httpOnly cookies for tokens (set by server)
    
    return await response.json();
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
}

// Implement rate limiting for login attempts
class RateLimiter {
  constructor(maxAttempts = 5, windowMs = 15 * 60 * 1000) {
    this.attempts = new Map();
    this.maxAttempts = maxAttempts;
    this.windowMs = windowMs;
  }
  
  checkLimit(identifier) {
    const now = Date.now();
    const userAttempts = this.attempts.get(identifier) || [];
    
    // Remove old attempts
    const recentAttempts = userAttempts.filter(time => now - time < this.windowMs);
    
    if (recentAttempts.length >= this.maxAttempts) {
      throw new Error('Too many login attempts. Please try again later.');
    }
    
    recentAttempts.push(now);
    this.attempts.set(identifier, recentAttempts);
  }
}

const loginLimiter = new RateLimiter();
```

---

## Secure Data Storage

Store sensitive data securely.

```javascript
// Bad - storing sensitive data in localStorage
localStorage.setItem('password', password);  // Never do this!
localStorage.setItem('creditCard', cardNumber);  // Never do this!

// Good - don't store sensitive data client-side
// If you must store data:

// Use sessionStorage for temporary data
sessionStorage.setItem('tempToken', token);

// Encrypt sensitive data before storing
async function encryptData(data, key) {
  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(data);
  
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv: crypto.getRandomValues(new Uint8Array(12)) },
    key,
    dataBuffer
  );
  
  return encrypted;
}

// Clear storage on logout
function logout() {
  sessionStorage.clear();
  localStorage.removeItem('non-sensitive-data');
  // Clear cookies via server endpoint
  fetch('/api/logout', { method: 'POST' });
}
```

---

## Prevent SQL Injection

Use parameterized queries (server-side).

```javascript
// This is server-side code (Node.js example)

// Bad - vulnerable to SQL injection
app.get('/users', (req, res) => {
  const { username } = req.query;
  const query = `SELECT * FROM users WHERE username = '${username}'`;
  db.query(query);  // Vulnerable!
});

// Good - use parameterized queries
app.get('/users', (req, res) => {
  const { username } = req.query;
  const query = 'SELECT * FROM users WHERE username = ?';
  db.query(query, [username]);  // Safe
});

// With async/await
app.get('/users', async (req, res) => {
  const { username } = req.query;
  
  try {
    const users = await db.query(
      'SELECT * FROM users WHERE username = ?',
      [username]
    );
    
    res.json(users);
  } catch (error) {
    res.status(500).json({ error: 'Database error' });
  }
});
```

---

## Content Security Policy (CSP)

Implement CSP headers to prevent XSS.

```javascript
// Server-side: Set CSP headers
// This is server-side code (Node.js/Express example)
app.use((req, res, next) => {
  res.setHeader(
    'Content-Security-Policy',
    "default-src 'self'; " +
    "script-src 'self' 'unsafe-inline'; " +
    "style-src 'self' 'unsafe-inline'; " +
    "img-src 'self' data: https:; " +
    "font-src 'self'; " +
    "connect-src 'self'"
  );
  next();
});

// Client-side: Check CSP violations
window.addEventListener('securitypolicyviolation', (e) => {
  console.error('CSP violation:', {
    blockedURI: e.blockedURI,
    violatedDirective: e.violatedDirective,
    originalPolicy: e.originalPolicy
  });
  
  // Report to server
  fetch('/api/csp-report', {
    method: 'POST',
    body: JSON.stringify({
      blockedURI: e.blockedURI,
      violatedDirective: e.violatedDirective
    })
  });
});
```

---

## Secure File Uploads

Validate file uploads carefully.

```javascript
// Validate file type
function validateFileType(file) {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  
  if (!allowedTypes.includes(file.type)) {
    throw new Error('Invalid file type');
  }
}

// Validate file size
function validateFileSize(file, maxSizeMB = 5) {
  const maxSize = maxSizeMB * 1024 * 1024;  // Convert to bytes
  
  if (file.size > maxSize) {
    throw new Error(`File too large. Maximum size: ${maxSizeMB}MB`);
  }
}

// Secure upload handler
async function uploadFile(file) {
  try {
    validateFileType(file);
    validateFileSize(file);
    
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Upload failed');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
}

// Read file securely
function readFileAsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(new Error('Failed to read file'));
    
    reader.readAsDataURL(file);
  });
}
```

---

## Prevent Clickjacking

Use frame-busting and X-Frame-Options.

```javascript
// Frame-busting code
if (top !== self) {
  top.location = self.location;
}

// Server-side: Set X-Frame-Options header
// This is server-side code
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');
  // Or: res.setHeader('X-Frame-Options', 'SAMEORIGIN');
  next();
});
```

---

## Secure Cookies

Set secure cookie attributes.

```javascript
// Server-side: Set secure cookies
// This is server-side code
res.cookie('session', sessionId, {
  httpOnly: true,      // Prevent JavaScript access
  secure: true,        // HTTPS only
  sameSite: 'strict',  // CSRF protection
  maxAge: 3600000      // 1 hour
});

// Client-side: Check if cookies are enabled
function cookiesEnabled() {
  try {
    document.cookie = 'test=1';
    const enabled = document.cookie.indexOf('test=') !== -1;
    document.cookie = 'test=1; expires=Thu, 01-Jan-1970 00:00:01 GMT';
    return enabled;
  } catch {
    return false;
  }
}
```

---

## Avoid Timing Attacks

Use constant-time comparison for sensitive data.

```javascript
// Bad - vulnerable to timing attacks
function compareTokens(userToken, validToken) {
  return userToken === validToken;
}

// Good - constant-time comparison
function constantTimeCompare(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  
  return result === 0;
}

// Use crypto.timingSafeEqual in Node.js
const crypto = require('crypto');

function compareTokens(userToken, validToken) {
  const userBuffer = Buffer.from(userToken);
  const validBuffer = Buffer.from(validToken);
  
  if (userBuffer.length !== validBuffer.length) {
    return false;
  }
  
  return crypto.timingSafeEqual(userBuffer, validBuffer);
}
```

---

## Secure Random Number Generation

Use cryptographically secure random numbers.

```javascript
// Bad - not cryptographically secure
const token = Math.random().toString(36).substr(2);

// Good - cryptographically secure
function generateSecureToken(length = 32) {
  const array = new Uint8Array(length);
  crypto.getRandomValues(array);
  
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

// Generate random UUID
function generateUUID() {
  return crypto.randomUUID();
}

// Generate random password
function generatePassword(length = 16) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
  const array = new Uint8Array(length);
  crypto.getRandomValues(array);
  
  return Array.from(array, byte => chars[byte % chars.length]).join('');
}
```

---

## Dependency Security

Keep dependencies updated and secure.

```javascript
// Check for vulnerabilities
// Run: npm audit
// Fix: npm audit fix

// Use package-lock.json to lock dependency versions
// Review dependencies before installing

// Avoid suspicious packages
// Check package reputation, download count, last update

// Use Snyk or similar tools for continuous monitoring

// Example package.json with fixed versions
{
  "dependencies": {
    "express": "4.18.2",      // Fixed version
    "lodash": "^4.17.21"      // Allow patch updates
  }
}
```

---

## Error Handling

Don't expose sensitive information in errors.

```javascript
// Bad - exposing internal details
app.get('/api/user/:id', async (req, res) => {
  try {
    const user = await db.query('SELECT * FROM users WHERE id = ?', [req.params.id]);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: error.message });  // Exposes DB structure!
  }
});

// Good - generic error messages
app.get('/api/user/:id', async (req, res) => {
  try {
    const user = await db.query('SELECT * FROM users WHERE id = ?', [req.params.id]);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json(user);
  } catch (error) {
    console.error('Database error:', error);  // Log internally
    res.status(500).json({ error: 'Internal server error' });  // Generic message
  }
});

// Client-side: Don't log sensitive data
// Bad
console.log('User password:', password);
console.log('Credit card:', creditCard);

// Good
console.log('Login attempt for user:', email);
console.log('Payment processing initiated');
```

---

## Prevent Prototype Pollution

Validate object keys before assignment.

```javascript
// Bad - vulnerable to prototype pollution
function merge(target, source) {
  for (const key in source) {
    target[key] = source[key];
  }
  return target;
}

// Attacker input
merge({}, JSON.parse('{"__proto__": {"isAdmin": true}}'));

// Good - check for dangerous keys
function safeMerge(target, source) {
  const dangerousKeys = ['__proto__', 'constructor', 'prototype'];
  
  for (const key in source) {
    if (dangerousKeys.includes(key)) {
      continue;
    }
    
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
  
  return target;
}

// Or use Object.create(null) for objects without prototype
const safeObject = Object.create(null);
safeObject.key = 'value';
```

---

## Key Takeaways

- **Validate input**: Always validate and sanitize user input
- **Prevent XSS**: Use textContent, sanitize HTML, avoid eval
- **CSRF protection**: Use tokens for state-changing operations
- **Secure auth**: Use HTTPS, httpOnly cookies, rate limiting
- **Don't store secrets**: Avoid localStorage for sensitive data
- **Parameterized queries**: Prevent SQL injection
- **CSP headers**: Implement Content Security Policy
- **Validate uploads**: Check file type and size
- **Secure cookies**: httpOnly, secure, sameSite
- **Constant-time comparison**: Prevent timing attacks
- **Crypto random**: Use crypto.getRandomValues
- **Update dependencies**: Run npm audit regularly
- **Generic errors**: Don't expose internal details
- **Prevent pollution**: Validate object keys
- Security is a process, not a product
- Follow OWASP guidelines
- Regular security audits
