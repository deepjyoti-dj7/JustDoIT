# Naming Conventions

Best practices for naming variables, functions, classes, and other identifiers in JavaScript.

---

## General Principles

### Be Descriptive

Choose names that clearly describe the purpose.

```javascript
// Good - descriptive names
const userAge = 25;
const totalPrice = 100;
const isAuthenticated = true;

function calculateTotalPrice(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// Bad - vague or cryptic names
const x = 25;
const tp = 100;
const flag = true;

function calc(items) {
  return items.reduce((s, i) => s + i.p, 0);
}
```

### Avoid Abbreviations

Use full words unless abbreviation is well-known.

```javascript
// Good
const button = document.querySelector('.btn');
const message = 'Hello';
const configuration = loadConfig();

// Good - well-known abbreviations
const html = '<div></div>';
const url = 'https://example.com';
const id = 123;
const api = new APIClient();
const db = connectToDatabase();

// Bad - unclear abbreviations
const btn = document.querySelector('.btn');
const msg = 'Hello';
const cfg = loadConfig();
const usr = getUser();
```

### Be Consistent

Use the same terminology throughout your codebase.

```javascript
// Good - consistent terminology
function getUser(id) { /* ... */ }
function getUserById(id) { /* ... */ }
function getUserByEmail(email) { /* ... */ }

// Bad - inconsistent
function getUser(id) { /* ... */ }
function fetchUser(id) { /* ... */ }
function retrieveUser(id) { /* ... */ }
```

---

## Variables

### Use camelCase

```javascript
// Good
const firstName = 'John';
const lastName = 'Doe';
const emailAddress = 'john@example.com';
const phoneNumber = '555-1234';

// Bad
const first_name = 'John';      // snake_case
const LastName = 'Doe';         // PascalCase
const email_address = 'john@example.com';
```

### Boolean Variables

Use is, has, can, should prefixes.

```javascript
// Good - clear boolean intent
const isActive = true;
const isValid = false;
const hasPermission = true;
const hasError = false;
const canEdit = true;
const canDelete = false;
const shouldUpdate = true;
const shouldRefresh = false;

// Good - for status checks
const isLoading = false;
const isDisabled = true;
const isVisible = false;

// Bad - ambiguous
const active = true;
const permission = true;
const edit = true;
const loading = false;
```

### Collections

Use plural nouns for arrays and collections.

```javascript
// Good - plural for collections
const users = ['John', 'Jane', 'Bob'];
const products = [{ id: 1 }, { id: 2 }];
const errors = [];
const items = new Set();

// Good - singular for single items
const user = { name: 'John' };
const product = { id: 1 };
const error = new Error('Failed');
const item = items[0];

// Bad - singular for collections
const user = ['John', 'Jane', 'Bob'];
const product = [{ id: 1 }, { id: 2 }];
```

### Avoid Magic Numbers

Use named constants for magic numbers.

```javascript
// Good - named constants
const MAX_RETRY_COUNT = 3;
const DEFAULT_TIMEOUT_MS = 5000;
const ITEMS_PER_PAGE = 10;
const HTTP_STATUS_OK = 200;

async function fetchWithRetry(url) {
  for (let i = 0; i < MAX_RETRY_COUNT; i++) {
    try {
      return await fetch(url, { timeout: DEFAULT_TIMEOUT_MS });
    } catch (error) {
      if (i === MAX_RETRY_COUNT - 1) throw error;
    }
  }
}

// Bad - magic numbers
async function fetchWithRetry(url) {
  for (let i = 0; i < 3; i++) {  // What is 3?
    try {
      return await fetch(url, { timeout: 5000 });  // What is 5000?
    } catch (error) {
      if (i === 2) throw error;  // Why 2?
    }
  }
}
```

---

## Functions

### Use camelCase

```javascript
// Good
function calculateTotal(items) { /* ... */ }
function getUserById(id) { /* ... */ }
function validateEmail(email) { /* ... */ }

// Bad
function CalculateTotal(items) { /* ... */ }
function get_user_by_id(id) { /* ... */ }
function ValidateEmail(email) { /* ... */ }
```

### Use Verbs

Start function names with verbs.

```javascript
// Good - action verbs
function getUser(id) { /* ... */ }
function setUser(user) { /* ... */ }
function createPost(data) { /* ... */ }
function deleteComment(id) { /* ... */ }
function updateProfile(data) { /* ... */ }
function fetchData(url) { /* ... */ }
function validateInput(input) { /* ... */ }
function calculateSum(numbers) { /* ... */ }
function processOrder(order) { /* ... */ }
function handleClick(event) { /* ... */ }

// Bad - nouns
function user(id) { /* ... */ }
function post(data) { /* ... */ }
function comment(id) { /* ... */ }
```

### Boolean-Returning Functions

Use is, has, can, should prefixes.

```javascript
// Good
function isValidEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

function hasPermission(user, permission) {
  return user.permissions.includes(permission);
}

function canEdit(user, document) {
  return user.id === document.ownerId || user.isAdmin;
}

function shouldRefresh(lastUpdate) {
  return Date.now() - lastUpdate > 60000;
}

// Bad
function validEmail(email) { /* ... */ }
function permission(user, perm) { /* ... */ }
function edit(user, doc) { /* ... */ }
```

### Event Handlers

Use handle or on prefix.

```javascript
// Good
function handleClick(event) {
  console.log('Clicked');
}

function handleSubmit(event) {
  event.preventDefault();
}

function onUserLogin(user) {
  console.log('User logged in:', user);
}

// In React/Vue
const MyComponent = () => {
  const handleButtonClick = () => { /* ... */ };
  const onFormSubmit = (event) => { /* ... */ };
  
  return <button onClick={handleButtonClick}>Click</button>;
};

// Bad
function click(event) { /* ... */ }
function submit(event) { /* ... */ }
function userLogin(user) { /* ... */ }
```

### Async Functions

Clearly indicate async operations.

```javascript
// Good - clear async intent
async function fetchUser(id) { /* ... */ }
async function loadData() { /* ... */ }
async function saveToDatabase(data) { /* ... */ }

// Alternative - explicit suffix
async function getUserAsync(id) { /* ... */ }
async function loadDataAsync() { /* ... */ }

// Good - promise-returning (without async)
function fetchUser(id) {
  return fetch(`/api/users/${id}`).then(r => r.json());
}

// Bad - unclear
function getUser(id) {  // Is this sync or async?
  return fetch(`/api/users/${id}`).then(r => r.json());
}
```

---

## Classes

### Use PascalCase

```javascript
// Good
class User {
  constructor(name) {
    this.name = name;
  }
}

class ShoppingCart {
  constructor() {
    this.items = [];
  }
}

class HTTPRequest {
  // ...
}

// Bad
class user { /* ... */ }
class shopping_cart { /* ... */ }
class httpRequest { /* ... */ }
```

### Noun for Class Names

Use nouns or noun phrases.

```javascript
// Good - nouns
class User { /* ... */ }
class Product { /* ... */ }
class OrderManager { /* ... */ }
class DataValidator { /* ... */ }
class EmailService { /* ... */ }

// Bad - verbs
class GetUser { /* ... */ }
class ValidateData { /* ... */ }
class SendEmail { /* ... */ }
```

### Descriptive Class Names

```javascript
// Good - descriptive
class ShoppingCartManager {
  addItem(item) { /* ... */ }
  removeItem(itemId) { /* ... */ }
  calculateTotal() { /* ... */ }
}

class UserAuthentication {
  login(credentials) { /* ... */ }
  logout() { /* ... */ }
  validateToken(token) { /* ... */ }
}

// Bad - vague
class Manager {
  add(item) { /* ... */ }
  remove(id) { /* ... */ }
}

class Auth {
  login(creds) { /* ... */ }
}
```

---

## Constants

### Use SCREAMING_SNAKE_CASE

For true constants (values that never change).

```javascript
// Good - true constants
const MAX_USERS = 100;
const API_BASE_URL = 'https://api.example.com';
const DEFAULT_TIMEOUT = 5000;
const HTTP_STATUS_OK = 200;
const HTTP_STATUS_NOT_FOUND = 404;

// Configuration constants
const DATABASE_CONFIG = {
  host: 'localhost',
  port: 5432
};

// Enum-like constants
const USER_ROLES = {
  ADMIN: 'admin',
  USER: 'user',
  GUEST: 'guest'
};

// Bad - not true constants
const MAX_USERS = 100;  // OK
let MAX_USERS = 100;    // Not a constant!
```

### Configuration Objects

Use camelCase for configuration object keys.

```javascript
// Good
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
  retryCount: 3,
  enableCache: true
};

// Bad
const config = {
  API_URL: 'https://api.example.com',
  TIMEOUT: 5000,
  retry_count: 3
};
```

---

## Private Members

### Use # for Private Fields

```javascript
class BankAccount {
  #balance = 0;  // Private field
  #transactions = [];  // Private field
  
  deposit(amount) {
    this.#balance += amount;
    this.#addTransaction('deposit', amount);
  }
  
  #addTransaction(type, amount) {  // Private method
    this.#transactions.push({ type, amount, date: new Date() });
  }
  
  getBalance() {
    return this.#balance;
  }
}
```

### Use _ Prefix (Legacy Convention)

Only when # is not available (older environments).

```javascript
// Older convention - not truly private
class User {
  constructor(name) {
    this._id = generateId();  // "Private" by convention
    this.name = name;
  }
  
  _validateName(name) {  // "Private" method
    return name && name.length > 0;
  }
}

// Note: Still accessible
const user = new User('John');
console.log(user._id);  // Works, but indicates "don't use this"
```

---

## Module and File Names

### Use kebab-case for Files

```
// Good file names
user-service.js
shopping-cart.js
api-client.js
date-utils.js

// Bad file names
UserService.js
shopping_cart.js
apiClient.js
```

### Match Class Name

For files with single class export.

```javascript
// user-profile.js
export default class UserProfile {
  // ...
}

// api-client.js
export default class APIClient {
  // ...
}
```

---

## Specific Contexts

### React Components

Use PascalCase for components.

```javascript
// Good
function UserProfile({ user }) {
  return <div>{user.name}</div>;
}

function ShoppingCart() {
  return <div>Cart</div>;
}

// Bad
function userProfile({ user }) {
  return <div>{user.name}</div>;
}
```

### React Hooks

Use use prefix for custom hooks.

```javascript
// Good
function useUser(id) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(id).then(setUser);
  }, [id]);
  
  return user;
}

function useLocalStorage(key, initialValue) {
  // Hook implementation
}

// Bad
function getUser(id) {  // Looks like regular function
  const [user, setUser] = useState(null);
  // ...
}
```

### Test Files

Use .test.js or .spec.js suffix.

```
// Good test file names
user-service.test.js
shopping-cart.spec.js
utils.test.js

// Bad test file names
test-user-service.js
user-service-tests.js
```

---

## Context-Specific Naming

### Loop Variables

Use meaningful names, not just i, j, k.

```javascript
// Good - meaningful names
const users = [/* ... */];
for (const user of users) {
  console.log(user.name);
}

users.forEach(user => {
  console.log(user.name);
});

// Acceptable for simple numeric loops
for (let i = 0; i < 10; i++) {
  console.log(i);
}

// Good - nested loops with meaningful names
const matrix = [[1, 2], [3, 4]];
for (let rowIndex = 0; rowIndex < matrix.length; rowIndex++) {
  for (let colIndex = 0; colIndex < matrix[rowIndex].length; colIndex++) {
    console.log(matrix[rowIndex][colIndex]);
  }
}

// Bad - unclear
for (const x of users) {
  console.log(x.name);
}

for (let i = 0; i < matrix.length; i++) {
  for (let j = 0; j < matrix[i].length; j++) {
    for (let k = 0; k < matrix[i][j].length; k++) {
      // What is k?
    }
  }
}
```

### Callback Parameters

Use descriptive parameter names.

```javascript
// Good
users.filter(user => user.isActive);
numbers.map(number => number * 2);
items.reduce((total, item) => total + item.price, 0);

// Bad
users.filter(x => x.isActive);
numbers.map(n => n * 2);
items.reduce((a, b) => a + b.price, 0);
```

---

## Avoid

### Single-Letter Names

Except for very short scopes.

```javascript
// Bad - unclear
const a = getUserById(123);
const b = a.name;
const c = calculateTotal(items);

// Good - except in very short scopes
const x = 5;  // Simple math
const result = (x) => x * 2;  // Short arrow function

// Good - in reduce
array.reduce((sum, n) => sum + n, 0);
```

### Redundant Names

Don't repeat context.

```javascript
// Bad - redundant
class User {
  constructor(userName, userAge, userEmail) {
    this.userName = userName;
    this.userAge = userAge;
    this.userEmail = userEmail;
  }
}

// Good - context is clear from class
class User {
  constructor(name, age, email) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
}

// Bad - redundant naming
const userObject = new User();
const arrayOfUsers = [user1, user2];

// Good
const user = new User();
const users = [user1, user2];
```

### Confusing Names

Avoid names that are too similar.

```javascript
// Bad - too similar
const user = getUser();
const users = getUsers();
const usersList = getAllUsers();

// Good - clearly different
const currentUser = getUser();
const allUsers = getUsers();
const activeUsers = getActiveUsers();
```

---

## Key Takeaways

- **Variables/Functions**: camelCase
- **Classes**: PascalCase
- **Constants**: SCREAMING_SNAKE_CASE
- **Private**: # prefix (or _ for legacy)
- **Files**: kebab-case
- **Be descriptive**: Name explains purpose
- **Be consistent**: Same terminology throughout
- **Use verbs**: For functions (get, set, create, delete)
- **Use prefixes**: is, has, can for booleans
- **Avoid abbreviations**: Unless well-known (API, URL, ID)
- **Plural for collections**: users not user
- **Event handlers**: handle or on prefix
- Choose names that make code self-documenting
- Avoid single-letter names except in short scopes
- Don't repeat context in names
- Use linters to enforce naming conventions
