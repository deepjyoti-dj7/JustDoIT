# WeakMap & WeakSet

Collections that hold **weak** references to objects, allowing garbage collection when no other references exist.

---

## WeakMap

Map-like collection where keys are **objects only** and references are **weak**.

### Basic Usage

```javascript
const weakMap = new WeakMap();

let obj = { name: 'John' };

weakMap.set(obj, 'some value');
console.log(weakMap.get(obj));  // 'some value'

// When obj is garbage collected, entry is automatically removed
obj = null;  // Entry removed from weakMap
```

### Key Characteristics

- **Keys must be objects** (not primitives)
- **Weak references** - doesn't prevent GC
- **Not enumerable** - cannot iterate
- **No size property**

```javascript
const wm = new WeakMap();

// Valid - object key
const key1 = {};
wm.set(key1, 'value');

// Invalid - primitive key
wm.set('string', 'value');  // TypeError!
wm.set(123, 'value');       // TypeError!

// Cannot iterate
wm.forEach();  // TypeError - no forEach
for (let key of wm) {}  // TypeError - not iterable

// No size
console.log(wm.size);  // undefined
```

---

## WeakMap Methods

### set(key, value)

```javascript
const wm = new WeakMap();
const key = {};

wm.set(key, 'value');
wm.set(key, 'new value');  // Overwrites

// Chaining
wm.set({}, 'a').set({}, 'b').set({}, 'c');
```

### get(key)

```javascript
const wm = new WeakMap();
const key = { id: 1 };

wm.set(key, 'value');
console.log(wm.get(key));  // 'value'
console.log(wm.get({}));   // undefined (different object)
```

### has(key)

```javascript
const wm = new WeakMap();
const key = {};

wm.set(key, 'value');
console.log(wm.has(key));  // true
console.log(wm.has({}));   // false (different object)
```

### delete(key)

```javascript
const wm = new WeakMap();
const key = {};

wm.set(key, 'value');
wm.delete(key);
console.log(wm.has(key));  // false
```

---

## WeakMap Use Cases

### 1. Private Data

Store private data without polluting the object.

```javascript
// Traditional approach (pollutes object)
class User {
  constructor(name) {
    this._secretData = 'private';  // Visible with Object.keys
  }
}

// WeakMap approach (truly private)
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, {
      password: 'secret',
      ssn: '123-45-6789'
    });
    
    this.name = name;
  }
  
  getPassword() {
    return privateData.get(this).password;
  }
}

const user = new User('John');
console.log(user.name);           // 'John'
console.log(user.getPassword());  // 'secret'
console.log(Object.keys(user));   // ['name'] - password hidden!

// When user is deleted, private data is automatically cleaned up
```

### 2. Caching/Memoization

Cache computed values without preventing GC.

```javascript
const cache = new WeakMap();

function expensiveOperation(obj) {
  // Check cache
  if (cache.has(obj)) {
    console.log('From cache');
    return cache.get(obj);
  }
  
  // Compute
  console.log('Computing...');
  const result = JSON.stringify(obj).length;
  
  // Store in cache
  cache.set(obj, result);
  return result;
}

let data = { foo: 'bar', baz: [1, 2, 3] };

console.log(expensiveOperation(data));  // Computing... 25
console.log(expensiveOperation(data));  // From cache 25

// When data is deleted, cache entry is automatically removed
data = null;
```

### 3. DOM Metadata

Associate metadata with DOM elements.

```javascript
const metadata = new WeakMap();

function addMetadata(element, data) {
  metadata.set(element, data);
}

function getMetadata(element) {
  return metadata.get(element);
}

const button = document.createElement('button');
addMetadata(button, {
  clickCount: 0,
  createdAt: Date.now()
});

button.addEventListener('click', () => {
  const data = getMetadata(button);
  data.clickCount++;
  console.log('Clicks:', data.clickCount);
});

// When button is removed from DOM and no other references exist,
// metadata is automatically cleaned up
```

### 4. Object Extension

Extend objects without modification.

```javascript
const extensions = new WeakMap();

function extend(obj, props) {
  extensions.set(obj, props);
}

function getExtension(obj, key) {
  const ext = extensions.get(obj);
  return ext ? ext[key] : undefined;
}

const user = { name: 'John' };

extend(user, {
  role: 'admin',
  permissions: ['read', 'write']
});

console.log(user.name);                    // 'John'
console.log(getExtension(user, 'role'));   // 'admin'
console.log(Object.keys(user));            // ['name'] - extended props hidden
```

### 5. Tracking Object State

Track state without modifying objects.

```javascript
const processed = new WeakMap();

function markAsProcessed(obj) {
  processed.set(obj, {
    timestamp: Date.now(),
    status: 'complete'
  });
}

function isProcessed(obj) {
  return processed.has(obj);
}

function getProcessInfo(obj) {
  return processed.get(obj);
}

const task = { id: 1, data: 'task data' };

markAsProcessed(task);
console.log(isProcessed(task));      // true
console.log(getProcessInfo(task));   // { timestamp: ..., status: 'complete' }
```

---

## WeakSet

Set-like collection where values are **objects only** and references are **weak**.

### Basic Usage

```javascript
const weakSet = new WeakSet();

let obj = { name: 'John' };

weakSet.add(obj);
console.log(weakSet.has(obj));  // true

// When obj is garbage collected, it's automatically removed
obj = null;  // Removed from weakSet
```

### Key Characteristics

- **Values must be objects** (not primitives)
- **Weak references** - doesn't prevent GC
- **Not enumerable** - cannot iterate
- **No size property**

```javascript
const ws = new WeakSet();

// Valid - object value
const obj = {};
ws.add(obj);

// Invalid - primitive value
ws.add('string');  // TypeError!
ws.add(123);       // TypeError!

// Cannot iterate
ws.forEach();  // TypeError - no forEach
for (let val of ws) {}  // TypeError - not iterable

// No size
console.log(ws.size);  // undefined
```

---

## WeakSet Methods

### add(value)

```javascript
const ws = new WeakSet();
const obj = {};

ws.add(obj);
ws.add(obj);  // No effect (already exists)

// Chaining
ws.add({}).add({}).add({});
```

### has(value)

```javascript
const ws = new WeakSet();
const obj = { id: 1 };

ws.add(obj);
console.log(ws.has(obj));  // true
console.log(ws.has({}));   // false (different object)
```

### delete(value)

```javascript
const ws = new WeakSet();
const obj = {};

ws.add(obj);
ws.delete(obj);
console.log(ws.has(obj));  // false
```

---

## WeakSet Use Cases

### 1. Tracking Objects

Mark objects without modifying them.

```javascript
const processedItems = new WeakSet();

function processItem(item) {
  if (processedItems.has(item)) {
    console.log('Already processed');
    return;
  }
  
  // Process item
  console.log('Processing:', item);
  
  // Mark as processed
  processedItems.add(item);
}

const item1 = { id: 1 };
const item2 = { id: 2 };

processItem(item1);  // Processing: { id: 1 }
processItem(item1);  // Already processed
processItem(item2);  // Processing: { id: 2 }
```

### 2. Preventing Duplicates

Ensure objects are unique without keeping them alive.

```javascript
const seen = new WeakSet();

function processUnique(obj) {
  if (seen.has(obj)) {
    throw new Error('Duplicate object');
  }
  
  seen.add(obj);
  // Process object...
}

const obj = {};
processUnique(obj);      // OK
processUnique(obj);      // Error: Duplicate object
```

### 3. Object Validation

Track validated objects.

```javascript
const validObjects = new WeakSet();

function validate(obj) {
  // Validation logic
  if (obj.name && obj.age > 0) {
    validObjects.add(obj);
    return true;
  }
  return false;
}

function isValid(obj) {
  return validObjects.has(obj);
}

const user = { name: 'John', age: 30 };
validate(user);

console.log(isValid(user));  // true

// Can safely use user knowing it's validated
```

### 4. Object Freezing Tracker

Track frozen objects.

```javascript
const frozenObjects = new WeakSet();

function deepFreeze(obj) {
  if (frozenObjects.has(obj)) {
    return obj;  // Already frozen
  }
  
  Object.freeze(obj);
  frozenObjects.add(obj);
  
  // Freeze nested objects
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  
  return obj;
}

function isFrozen(obj) {
  return frozenObjects.has(obj);
}

const data = {
  name: 'John',
  address: { city: 'NYC' }
};

deepFreeze(data);
console.log(isFrozen(data));           // true
console.log(isFrozen(data.address));   // true
```

### 5. Circular Reference Detection

Detect circular references during traversal.

```javascript
function stringify(obj) {
  const seen = new WeakSet();
  
  function recurse(obj) {
    if (typeof obj !== 'object' || obj === null) {
      return JSON.stringify(obj);
    }
    
    if (seen.has(obj)) {
      return '"[Circular]"';
    }
    
    seen.add(obj);
    
    if (Array.isArray(obj)) {
      return '[' + obj.map(recurse).join(',') + ']';
    }
    
    const props = Object.keys(obj).map(key =>
      `"${key}":${recurse(obj[key])}`
    );
    
    return '{' + props.join(',') + '}';
  }
  
  return recurse(obj);
}

const obj = { name: 'John' };
obj.self = obj;  // Circular reference

console.log(stringify(obj));
// {"name":"John","self":"[Circular]"}
```

---

## WeakMap vs Map

```javascript
// Map - strong references
const map = new Map();
let obj1 = { id: 1 };

map.set(obj1, 'value');
obj1 = null;  // Object NOT garbage collected (map still references it)

// WeakMap - weak references
const weakMap = new WeakMap();
let obj2 = { id: 2 };

weakMap.set(obj2, 'value');
obj2 = null;  // Object IS garbage collected (weak reference)
```

| Feature | Map | WeakMap |
|---------|-----|---------|
| Keys | Any type | Objects only |
| References | Strong | Weak |
| GC | Prevents GC | Allows GC |
| Iteration | Yes | No |
| Size | Yes | No |
| Use case | General mapping | Private data, caching |

---

## WeakSet vs Set

```javascript
// Set - strong references
const set = new Set();
let obj1 = { id: 1 };

set.add(obj1);
obj1 = null;  // Object NOT garbage collected

// WeakSet - weak references
const weakSet = new WeakSet();
let obj2 = { id: 2 };

weakSet.add(obj2);
obj2 = null;  // Object IS garbage collected
```

| Feature | Set | WeakSet |
|---------|-----|---------|
| Values | Any type | Objects only |
| References | Strong | Weak |
| GC | Prevents GC | Allows GC |
| Iteration | Yes | No |
| Size | Yes | No |
| Use case | General collection | Object tracking |

---

## Practical Examples

### Memoization with Auto-Cleanup

```javascript
function createMemoizer() {
  const cache = new WeakMap();
  
  return function memoize(fn) {
    return function(obj) {
      if (cache.has(obj)) {
        console.log('Cache hit');
        return cache.get(obj);
      }
      
      const result = fn(obj);
      cache.set(obj, result);
      return result;
    };
  };
}

const memoize = createMemoizer();

const expensiveCalc = memoize((obj) => {
  console.log('Computing...');
  return Object.keys(obj).length * 100;
});

let data = { a: 1, b: 2, c: 3 };

console.log(expensiveCalc(data));  // Computing... 300
console.log(expensiveCalc(data));  // Cache hit 300

data = null;  // Cache automatically cleared
```

### Component State Management

```javascript
const componentState = new WeakMap();

class Component {
  constructor() {
    componentState.set(this, {
      listeners: [],
      data: {}
    });
  }
  
  setState(data) {
    const state = componentState.get(this);
    Object.assign(state.data, data);
  }
  
  getState() {
    return componentState.get(this).data;
  }
  
  addEventListener(event, handler) {
    const state = componentState.get(this);
    state.listeners.push({ event, handler });
  }
  
  destroy() {
    const state = componentState.get(this);
    state.listeners = [];
    state.data = {};
    // Component state automatically cleaned up when instance deleted
  }
}

let component = new Component();
component.setState({ count: 0 });
console.log(component.getState());  // { count: 0 }

component = null;  // State automatically garbage collected
```

---

## Key Takeaways

- **WeakMap**: Object-keyed map with weak references
- **WeakSet**: Object-valued set with weak references
- **Weak references**: Don't prevent garbage collection
- **Keys/values**: Must be objects (not primitives)
- **Not enumerable**: Cannot iterate or get size
- **Use WeakMap for**: Private data, caching, metadata, object extension
- **Use WeakSet for**: Object tracking, validation, marking
- **Automatic cleanup**: Entries removed when objects are GC'd
- **Memory efficient**: No memory leaks from orphaned data
- Choose WeakMap/WeakSet when objects should be garbage collected
- Choose Map/Set when you need iteration or primitive keys/values
- WeakMap/WeakSet prevent memory leaks in long-running applications
