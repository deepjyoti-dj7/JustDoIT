# Primitive vs Reference Types

Understanding the difference between primitive and reference types is crucial for managing memory and avoiding bugs.

---

## Primitive Types

Seven primitive types in JavaScript:

```javascript
let num = 42;              // Number
let str = 'hello';         // String
let bool = true;           // Boolean
let nothing = null;        // Null
let undef = undefined;     // Undefined
let sym = Symbol('id');    // Symbol
let big = 100n;            // BigInt

// All stored by value
```

### Characteristics

- **Immutable**: Cannot be changed
- **Stored by value**: Variables hold actual value
- **Compared by value**: Same value → equal
- **Stack allocated**: Fast access

```javascript
let a = 10;
let b = a;  // Copy value

b = 20;  // Change b

console.log(a);  // 10 (unchanged)
console.log(b);  // 20
```

---

## Reference Types

Objects, arrays, functions, dates, etc.

```javascript
let obj = { name: 'John' };      // Object
let arr = [1, 2, 3];             // Array
let fn = () => {};               // Function
let date = new Date();           // Date
let regex = /pattern/;           // RegExp
let map = new Map();             // Map
let set = new Set();             // Set

// All stored by reference
```

### Characteristics

- **Mutable**: Can be changed
- **Stored by reference**: Variables hold pointer to memory
- **Compared by reference**: Same object → equal
- **Heap allocated**: Dynamic size

```javascript
let obj1 = { count: 0 };
let obj2 = obj1;  // Copy reference

obj2.count = 5;  // Modify object

console.log(obj1.count);  // 5 (same object!)
console.log(obj2.count);  // 5
```

---

## Immutability

### Primitives are Immutable

```javascript
let str = 'hello';
str[0] = 'H';  // No effect

console.log(str);  // 'hello' (unchanged)

// String methods return new strings
let upper = str.toUpperCase();
console.log(str);    // 'hello' (original unchanged)
console.log(upper);  // 'HELLO' (new string)
```

### Objects are Mutable

```javascript
const obj = { count: 0 };

obj.count = 5;  // Modifies object
obj.name = 'John';  // Adds property

console.log(obj);  // { count: 5, name: 'John' }

// const prevents reassignment, not mutation
// obj = {};  // Error: Assignment to constant variable
```

---

## Value vs Reference Assignment

### Primitive Assignment

```javascript
let x = 10;
let y = x;  // Copy value

y = 20;  // Independent change

console.log(x);  // 10
console.log(y);  // 20

// x and y are completely independent
```

### Reference Assignment

```javascript
let obj1 = { value: 10 };
let obj2 = obj1;  // Copy reference

obj2.value = 20;  // Affects both

console.log(obj1.value);  // 20
console.log(obj2.value);  // 20

// obj1 and obj2 point to same object
```

---

## Comparison

### Primitive Comparison

```javascript
console.log(5 === 5);              // true
console.log('hello' === 'hello');  // true
console.log(true === true);        // true
console.log(null === null);        // true

// Compare actual values
```

### Reference Comparison

```javascript
console.log({} === {});              // false (different objects)
console.log([] === []);              // false (different arrays)
console.log([1] === [1]);            // false (different arrays)

let obj1 = { a: 1 };
let obj2 = { a: 1 };
let obj3 = obj1;

console.log(obj1 === obj2);  // false (different references)
console.log(obj1 === obj3);  // true (same reference)

// Compare memory addresses, not content
```

---

## Passing to Functions

### Pass Primitives by Value

```javascript
function modify(num) {
  num = 100;
  console.log('Inside:', num);  // 100
}

let value = 50;
modify(value);
console.log('Outside:', value);  // 50 (unchanged)

// Copy of value passed to function
```

### Pass References

```javascript
function modify(obj) {
  obj.value = 100;
  console.log('Inside:', obj.value);  // 100
}

let myObj = { value: 50 };
modify(myObj);
console.log('Outside:', myObj.value);  // 100 (modified!)

// Reference passed, points to same object
```

### Reassignment vs Mutation

```javascript
function reassign(obj) {
  obj = { value: 100 };  // Creates new object, doesn't affect original
}

function mutate(obj) {
  obj.value = 100;  // Modifies original object
}

let original = { value: 50 };

reassign(original);
console.log(original.value);  // 50 (unchanged)

mutate(original);
console.log(original.value);  // 100 (changed)
```

---

## typeof Operator

```javascript
// Primitives
console.log(typeof 42);         // 'number'
console.log(typeof 'hello');    // 'string'
console.log(typeof true);       // 'boolean'
console.log(typeof undefined);  // 'undefined'
console.log(typeof Symbol());   // 'symbol'
console.log(typeof 100n);       // 'bigint'

// Special case
console.log(typeof null);       // 'object' (JavaScript bug!)

// References
console.log(typeof {});         // 'object'
console.log(typeof []);         // 'object'
console.log(typeof function(){}); // 'function'
console.log(typeof new Date()); // 'object'
```

---

## Checking Types

### Primitives

```javascript
function isPrimitive(value) {
  return value !== Object(value);
}

console.log(isPrimitive(42));       // true
console.log(isPrimitive('hello'));  // true
console.log(isPrimitive({}));       // false
console.log(isPrimitive([]));       // false
```

### Objects

```javascript
console.log({} instanceof Object);          // true
console.log([] instanceof Array);           // true
console.log(new Date() instanceof Date);    // true

// More reliable check
console.log(Array.isArray([]));            // true
console.log(Array.isArray({}));            // false
```

---

## Copying Values

### Primitives - Always Copy Value

```javascript
let a = 10;
let b = a;  // Automatic copy

b = 20;

console.log(a);  // 10
console.log(b);  // 20
```

### Objects - Need Explicit Copy

#### Shallow Copy

```javascript
const original = {
  name: 'John',
  address: {
    city: 'NYC'
  }
};

// Spread operator (shallow)
const copy1 = { ...original };

// Object.assign (shallow)
const copy2 = Object.assign({}, original);

// Top-level properties copied
copy1.name = 'Jane';
console.log(original.name);  // 'John' (unchanged)

// Nested objects still referenced
copy1.address.city = 'LA';
console.log(original.address.city);  // 'LA' (changed!)
```

#### Deep Copy

```javascript
const original = {
  name: 'John',
  address: {
    city: 'NYC'
  }
};

// JSON (simple objects only)
const deepCopy1 = JSON.parse(JSON.stringify(original));

// structuredClone (modern, better)
const deepCopy2 = structuredClone(original);

deepCopy1.address.city = 'LA';
console.log(original.address.city);  // 'NYC' (unchanged)
```

---

## Arrays

Arrays are reference types.

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1;  // Reference copy

arr2.push(4);

console.log(arr1);  // [1, 2, 3, 4]
console.log(arr2);  // [1, 2, 3, 4]

// Both point to same array
```

### Copying Arrays

```javascript
const original = [1, 2, 3, [4, 5]];

// Shallow copies
const copy1 = [...original];
const copy2 = original.slice();
const copy3 = Array.from(original);

// Nested arrays still referenced
copy1[3].push(6);
console.log(original[3]);  // [4, 5, 6]

// Deep copy
const deepCopy = JSON.parse(JSON.stringify(original));
deepCopy[3].push(7);
console.log(original[3]);  // [4, 5, 6] (unchanged)
```

---

## Practical Examples

### State Management

```javascript
// Bad - mutates state
function updateUser(user, newAge) {
  user.age = newAge;  // Mutates original
  return user;
}

// Good - returns new object
function updateUser(user, newAge) {
  return { ...user, age: newAge };  // New object
}

const user = { name: 'John', age: 30 };
const updated = updateUser(user, 31);

console.log(user.age);     // 30 (unchanged)
console.log(updated.age);  // 31
```

### Caching

```javascript
const cache = new Map();

function expensiveOperation(input) {
  // Primitives work well as keys
  if (cache.has(input)) {
    return cache.get(input);
  }
  
  const result = /* expensive computation */;
  cache.set(input, result);
  return result;
}

// Objects as keys problematic
const obj1 = { id: 1 };
const obj2 = { id: 1 };

cache.set(obj1, 'data');
console.log(cache.has(obj2));  // false (different reference)
```

### Preventing Mutations

```javascript
// Object.freeze (shallow)
const config = Object.freeze({
  apiUrl: 'https://api.example.com',
  timeout: 5000
});

// config.timeout = 10000;  // Error in strict mode, ignored otherwise
console.log(config.timeout);  // 5000

// Deep freeze
function deepFreeze(obj) {
  Object.freeze(obj);
  
  Object.values(obj).forEach(value => {
    if (typeof value === 'object' && value !== null) {
      deepFreeze(value);
    }
  });
  
  return obj;
}

const data = deepFreeze({
  user: {
    name: 'John',
    settings: {
      theme: 'dark'
    }
  }
});

// data.user.settings.theme = 'light';  // Error
```

---

## Memory Implications

### Primitives - Lightweight

```javascript
// Each variable holds actual value
let a = 10;  // 8 bytes
let b = 20;  // 8 bytes
let c = 30;  // 8 bytes

// Total: 24 bytes
```

### References - Shared Memory

```javascript
// Variables hold references, objects in heap
let obj1 = { data: new Array(1000) };  // ~8KB in heap
let obj2 = obj1;  // Just a reference (~8 bytes)
let obj3 = obj1;  // Just a reference (~8 bytes)

// Total: 8KB + 24 bytes (3 references)
// Much better than 3 separate copies!
```

---

## Common Pitfalls

```javascript
// 1. Assuming object assignment copies
let original = { count: 0 };
let copy = original;  // Not a copy!
copy.count = 5;
console.log(original.count);  // 5 (modified)

// 2. Comparing objects by value
console.log([1, 2] === [1, 2]);  // false
console.log({ a: 1 } === { a: 1 });  // false

// 3. Mutating function parameters
function addItem(arr, item) {
  arr.push(item);  // Mutates original!
}

const items = [1, 2, 3];
addItem(items, 4);
console.log(items);  // [1, 2, 3, 4] (modified)

// 4. Shallow copy gotcha
const obj = { nested: { value: 1 } };
const copy = { ...obj };
copy.nested.value = 2;
console.log(obj.nested.value);  // 2 (nested object shared)
```

---

## Best Practices

```javascript
// 1. Use const for references to prevent reassignment
const user = { name: 'John' };
// user = {};  // Error

// 2. Make defensive copies
function updateUser(user) {
  const copy = { ...user };
  copy.age = 31;
  return copy;
}

// 3. Use deep copy for nested objects
const deepCopy = structuredClone(original);

// 4. Freeze immutable data
const constants = Object.freeze({
  MAX_SIZE: 100,
  API_URL: 'https://api.example.com'
});

// 5. Document mutation
/**
 * Adds item to array (mutates array)
 * @param {Array} arr - Array to modify
 * @param {*} item - Item to add
 */
function addItem(arr, item) {
  arr.push(item);
}

// 6. Return new objects instead of mutating
function increment(counter) {
  return { ...counter, count: counter.count + 1 };
}
```

---

## Key Takeaways

- **Primitives**: number, string, boolean, null, undefined, symbol, bigint
- **References**: objects, arrays, functions, dates, etc.
- **Primitives**: Immutable, compared by value, copied by value
- **References**: Mutable, compared by reference, copied by reference
- **Assignment**: Primitives copy value, objects copy reference
- **Function params**: Same rules apply
- **Equality**: Primitives compare values, objects compare references
- **Shallow copy**: Top-level copy, nested references shared
- **Deep copy**: Fully independent copy
- Use `structuredClone()` or JSON for deep copies
- `Object.freeze()` prevents mutations (shallow)
- Be aware of shared references
- Document mutation in functions
