# Memory Leaks

Unintentional retention of memory that should be released, causing applications to consume increasing amounts of memory over time.

---

## What is a Memory Leak?

Memory that's allocated but never freed, even though it's no longer needed.

```javascript
// Memory leak example
const leakedData = [];

function addData() {
  // Continuously adds to array, never removes
  leakedData.push(new Array(10000));
}

setInterval(addData, 100);
// Memory usage grows indefinitely
```

---

## Common Causes

### 1. Accidental Global Variables

Forgetting `var`, `let`, or `const` creates global variables that never get garbage collected.

```javascript
function createLeak() {
  // Missing declaration - becomes global!
  leakedVariable = 'I will never be cleaned up';
}

createLeak();
console.log(window.leakedVariable);  // Accessible globally

// Fix: Use strict mode and proper declarations
'use strict';

function noLeak() {
  const properVariable = 'I will be cleaned up';
}

noLeak();
// properVariable is garbage collected
```

### 2. Forgotten Timers and Intervals

Timers keep references to their callbacks and any data in their closure.

```javascript
// Leak
function startTimer() {
  const largeData = new Array(1000000).fill('data');
  
  setInterval(() => {
    console.log(largeData.length);  // Keeps largeData in memory
  }, 1000);
}

startTimer();
// largeData never released while interval runs

// Fix
function startTimer() {
  const largeData = new Array(1000000).fill('data');
  
  const intervalId = setInterval(() => {
    console.log(largeData.length);
  }, 1000);
  
  // Clean up after 10 seconds
  setTimeout(() => {
    clearInterval(intervalId);
  }, 10000);
  
  // Or return cleanup function
  return () => clearInterval(intervalId);
}

const cleanup = startTimer();
// When done: cleanup();
```

### 3. Event Listeners Not Removed

Event listeners prevent garbage collection of referenced objects.

```javascript
// Leak
function attachListener() {
  const largeData = new Array(1000000).fill('data');
  const button = document.getElementById('myButton');
  
  button.addEventListener('click', () => {
    console.log(largeData.length);  // Keeps largeData in memory
  });
}

attachListener();
// largeData never released while listener exists

// Fix: Remove listener when done
function attachListener() {
  const largeData = new Array(1000000).fill('data');
  const button = document.getElementById('myButton');
  
  function handleClick() {
    console.log(largeData.length);
  }
  
  button.addEventListener('click', handleClick);
  
  // Return cleanup function
  return () => {
    button.removeEventListener('click', handleClick);
  };
}

const cleanup = attachListener();
// When done: cleanup();
```

### 4. Closures

Closures can unintentionally keep large objects in memory.

```javascript
// Leak
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  const smallData = 'small';
  
  return function() {
    // Only uses smallData, but closure keeps entire scope
    console.log(smallData);
  };
}

const fn = createClosure();
// largeData kept in memory even though unused

// Fix: Minimize closure scope
function createClosure() {
  const largeData = new Array(1000000).fill('data');
  const smallData = 'small';
  
  // Process and clear large data
  processData(largeData);
  
  // Only capture what's needed
  return function() {
    console.log(smallData);
  };
}
```

### 5. Detached DOM Nodes

DOM nodes removed from the DOM but still referenced in JavaScript.

```javascript
// Leak
const detachedNodes = [];

function createElements() {
  const div = document.createElement('div');
  div.innerHTML = '<p>Content</p>';
  
  document.body.appendChild(div);
  detachedNodes.push(div);  // Keep reference
}

createElements();

// Remove from DOM but still in array
document.body.removeChild(detachedNodes[0]);
// detachedNodes[0] not garbage collected!

// Fix: Remove references too
function cleanup() {
  detachedNodes.forEach(node => {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  });
  detachedNodes.length = 0;  // Clear array
}

cleanup();
```

### 6. Circular References (Old Browsers)

Modern engines handle circular references, but can still cause issues with DOM.

```javascript
// Potential issue in old browsers
function createCircular() {
  const div = document.createElement('div');
  
  div.onclick = function() {
    console.log('Clicked');
  };
  
  // Circular: div → onclick → div (via closure)
}

// Fix: Break reference when done
function createCircular() {
  const div = document.createElement('div');
  
  div.onclick = function() {
    console.log('Clicked');
  };
  
  // Later, when removing element
  function cleanup() {
    div.onclick = null;  // Break circular reference
    div.parentNode.removeChild(div);
  }
  
  return cleanup;
}
```

### 7. Out of DOM References

Keeping references to DOM elements in data structures.

```javascript
// Leak
const elements = {
  button: document.getElementById('button'),
  div: document.getElementById('div'),
  form: document.getElementById('form')
};

// If these elements are removed from DOM, they're still referenced

// Fix: Clear references
function clearReferences() {
  elements.button = null;
  elements.div = null;
  elements.form = null;
}
```

### 8. Large Caches Without Limits

Caches that grow unbounded.

```javascript
// Leak
const cache = {};

function cacheData(key, value) {
  cache[key] = value;  // Never removed
}

// Grows forever
for (let i = 0; i < 1000000; i++) {
  cacheData(i, new Array(1000));
}

// Fix: Implement size limit (LRU cache)
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  set(key, value) {
    // Remove oldest if at limit
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
  }
  
  get(key) {
    if (!this.cache.has(key)) return null;
    
    // Move to end (most recently used)
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
}

const limitedCache = new LRUCache(1000);
```

---

## Detecting Memory Leaks

### 1. Chrome DevTools Memory Profiler

```javascript
// Take heap snapshot before
// Run code
// Take heap snapshot after
// Compare snapshots

function suspectedLeak() {
  const leaks = [];
  
  for (let i = 0; i < 10000; i++) {
    leaks.push({
      data: new Array(1000),
      timestamp: Date.now()
    });
  }
  
  return leaks;
}

// Run and profile in DevTools
```

### 2. Performance.memory API

```javascript
function monitorMemory() {
  if (!performance.memory) {
    console.warn('performance.memory not available');
    return;
  }
  
  const baseline = performance.memory.usedJSHeapSize;
  
  // Run suspected code
  runSuspectedCode();
  
  // Force garbage collection (Chrome with --expose-gc flag)
  if (global.gc) global.gc();
  
  setTimeout(() => {
    const current = performance.memory.usedJSHeapSize;
    const increase = current - baseline;
    const percentIncrease = (increase / baseline) * 100;
    
    console.log('Memory increase:', (increase / 1048576).toFixed(2), 'MB');
    console.log('Percent increase:', percentIncrease.toFixed(2), '%');
    
    if (percentIncrease > 50) {
      console.warn('Possible memory leak detected!');
    }
  }, 1000);
}
```

### 3. Automated Leak Detection

```javascript
class LeakDetector {
  constructor() {
    this.snapshots = [];
  }
  
  takeSnapshot() {
    if (!performance.memory) return null;
    
    const snapshot = {
      timestamp: Date.now(),
      usedHeap: performance.memory.usedJSHeapSize,
      totalHeap: performance.memory.totalJSHeapSize
    };
    
    this.snapshots.push(snapshot);
    return snapshot;
  }
  
  analyze() {
    if (this.snapshots.length < 2) {
      return 'Need at least 2 snapshots';
    }
    
    const first = this.snapshots[0];
    const last = this.snapshots[this.snapshots.length - 1];
    
    const growth = last.usedHeap - first.usedHeap;
    const timeElapsed = last.timestamp - first.timestamp;
    const growthRate = growth / timeElapsed;  // bytes per ms
    
    return {
      totalGrowth: (growth / 1048576).toFixed(2) + ' MB',
      timeElapsed: (timeElapsed / 1000).toFixed(2) + ' seconds',
      growthRate: (growthRate * 1000).toFixed(2) + ' bytes/sec',
      isLeaking: growthRate > 1000  // > 1KB/sec
    };
  }
}

const detector = new LeakDetector();
detector.takeSnapshot();

// Run code for a while
setTimeout(() => {
  detector.takeSnapshot();
  console.log(detector.analyze());
}, 10000);
```

---

## Preventing Memory Leaks

### 1. Use Strict Mode

```javascript
'use strict';

function preventAccidentalGlobals() {
  // This will throw error instead of creating global
  accidentalGlobal = 'value';  // Error!
}
```

### 2. Clear Timers

```javascript
class Timer {
  constructor() {
    this.timers = new Set();
  }
  
  setTimeout(callback, delay) {
    const id = setTimeout(() => {
      this.timers.delete(id);
      callback();
    }, delay);
    
    this.timers.add(id);
    return id;
  }
  
  setInterval(callback, delay) {
    const id = setInterval(callback, delay);
    this.timers.add(id);
    return id;
  }
  
  clear(id) {
    clearTimeout(id);
    clearInterval(id);
    this.timers.delete(id);
  }
  
  clearAll() {
    this.timers.forEach(id => {
      clearTimeout(id);
      clearInterval(id);
    });
    this.timers.clear();
  }
}

const timer = new Timer();
timer.setInterval(() => console.log('Running'), 1000);

// Clean up all timers
timer.clearAll();
```

### 3. Remove Event Listeners

```javascript
class EventManager {
  constructor() {
    this.listeners = new Map();
  }
  
  addEventListener(element, event, handler, options) {
    const key = `${element}_${event}`;
    
    if (!this.listeners.has(key)) {
      this.listeners.set(key, []);
    }
    
    this.listeners.get(key).push({ element, event, handler, options });
    element.addEventListener(event, handler, options);
  }
  
  removeEventListener(element, event, handler) {
    const key = `${element}_${event}`;
    
    if (this.listeners.has(key)) {
      const handlers = this.listeners.get(key);
      const index = handlers.findIndex(h => h.handler === handler);
      
      if (index !== -1) {
        handlers.splice(index, 1);
        element.removeEventListener(event, handler);
      }
    }
  }
  
  removeAllListeners() {
    this.listeners.forEach((handlers, key) => {
      handlers.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
    });
    
    this.listeners.clear();
  }
}

const eventManager = new EventManager();
const button = document.getElementById('button');

eventManager.addEventListener(button, 'click', () => {
  console.log('Clicked');
});

// Clean up all listeners
eventManager.removeAllListeners();
```

### 4. Use WeakMap for Private Data

```javascript
// Leak: Private data kept even after object deleted
const privateData = new Map();

class User {
  constructor(name) {
    privateData.set(this, { name, secret: 'private' });
  }
  
  getName() {
    return privateData.get(this).name;
  }
}

let user = new User('John');
user = null;  // User deleted but privateData entry remains!

// Fix: Use WeakMap
const weakPrivateData = new WeakMap();

class User {
  constructor(name) {
    weakPrivateData.set(this, { name, secret: 'private' });
  }
  
  getName() {
    return weakPrivateData.get(this).name;
  }
}

let user2 = new User('Jane');
user2 = null;  // WeakMap entry automatically removed
```

### 5. Nullify Large Objects

```javascript
function processLargeData() {
  let largeData = new Array(1000000).fill('data');
  
  // Process data
  const result = compute(largeData);
  
  // Clear reference immediately
  largeData = null;
  
  return result;
}
```

### 6. Use Event Delegation

```javascript
// Leak: Listener on each item
function attachListeners() {
  const items = document.querySelectorAll('.item');
  
  items.forEach(item => {
    item.addEventListener('click', handleClick);  // Many listeners
  });
}

// Fix: Single listener on parent
function attachDelegatedListener() {
  const container = document.getElementById('container');
  
  container.addEventListener('click', (e) => {
    if (e.target.matches('.item')) {
      handleClick(e);
    }
  });
}
```

---

## Real-World Examples

### React Component Memory Leak

```javascript
// Leak
class LeakyComponent extends React.Component {
  componentDidMount() {
    this.interval = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }
  
  // Forgot to clear interval!
}

// Fix
class CleanComponent extends React.Component {
  componentDidMount() {
    this.interval = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }
  
  componentWillUnmount() {
    clearInterval(this.interval);  // Clean up
  }
}
```

### Observable Pattern

```javascript
class Observable {
  constructor() {
    this.observers = [];
  }
  
  subscribe(observer) {
    this.observers.push(observer);
    
    // Return unsubscribe function
    return () => {
      const index = this.observers.indexOf(observer);
      if (index !== -1) {
        this.observers.splice(index, 1);
      }
    };
  }
  
  notify(data) {
    this.observers.forEach(observer => observer(data));
  }
}

const observable = new Observable();
const unsubscribe = observable.subscribe((data) => {
  console.log('Received:', data);
});

// Clean up when done
unsubscribe();
```

---

## Key Takeaways

- **Memory leaks**: Unintentional memory retention
- **Common causes**: Globals, timers, listeners, closures, detached DOM, circular refs
- **Detection**: DevTools profiler, performance.memory API
- **Prevention**: Strict mode, clear timers, remove listeners, nullify references
- Use WeakMap/WeakSet for private data
- Implement size limits on caches
- Clean up resources in component lifecycle
- Use event delegation to reduce listeners
- Monitor memory usage in development
- Profile regularly to catch leaks early
- Return cleanup functions from setup code
- Minimize closure scope
