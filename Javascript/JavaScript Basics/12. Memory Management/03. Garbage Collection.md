# Garbage Collection

Automatic memory management in JavaScript that frees memory occupied by objects that are no longer reachable.

---

## What is Garbage Collection?

GC automatically identifies and removes objects that are no longer needed, freeing up memory.

```javascript
function createUser() {
  const user = { name: 'John', age: 30 };  // Allocated
  return user;
}

const user1 = createUser();  // user1 references object (kept)
// Function local 'user' no longer accessible (cleaned up)

user1 = null;  // No more references → eligible for GC
```

---

## Reachability

An object is **reachable** if it can be accessed from the root (global variables, current function scope, etc.).

```javascript
// Reachable - global variable
const globalUser = { name: 'John' };

function example() {
  // Reachable - local variable
  const localUser = { name: 'Jane' };
  
  // localUser unreachable after function ends
}

example();
// localUser object is now garbage
```

---

## Reference Counting (Old Approach)

Tracks number of references to each object. When count reaches zero, object is garbage collected.

### Problem: Circular References

```javascript
function createCircular() {
  const obj1 = {};
  const obj2 = {};
  
  obj1.ref = obj2;  // obj1 → obj2
  obj2.ref = obj1;  // obj2 → obj1
  
  return null;
}

createCircular();

// obj1 and obj2 have references to each other
// Reference count never reaches zero
// Memory leak in old browsers (IE < 9)
```

---

## Mark-and-Sweep (Modern Approach)

Modern JavaScript engines use mark-and-sweep algorithm.

### How It Works

1. **Mark**: Starting from roots, mark all reachable objects
2. **Sweep**: Remove unmarked objects

```javascript
let user = { name: 'John' };  // Reachable from global
let admin = user;             // admin also references it

user = null;  // Remove one reference

// Object still reachable via admin (not collected)

admin = null;  // No more references

// Object unreachable (will be collected)
```

---

## Generational Garbage Collection

Modern engines use generational GC for optimization.

### Generations

- **Young Generation**: Short-lived objects (frequent GC)
- **Old Generation**: Long-lived objects (infrequent GC)

```javascript
function createTemp() {
  const temp = { data: 'temporary' };
  // Short-lived, collected quickly
}

createTemp();

// Long-lived object
const persistent = { data: 'persistent' };
// Promoted to old generation, collected less frequently
```

---

## Triggering Garbage Collection

GC runs automatically when needed. Cannot manually trigger in most environments.

```javascript
// Cannot do this:
// collectGarbage();  // No such function

// Some environments (V8 with --expose-gc flag)
if (global.gc) {
  global.gc();  // Manual GC (development only)
}
```

---

## Memory Leaks

Objects that should be collected but remain referenced.

### Common Causes

#### 1. Global Variables

```javascript
function createLeak() {
  leakedVar = 'I am global!';  // Forgot var/let/const
}

createLeak();
// leakedVar remains in global scope forever
```

#### 2. Timers Not Cleared

```javascript
function setupTimer() {
  const largeData = new Array(1000000);
  
  setInterval(() => {
    console.log(largeData.length);  // Keeps largeData in memory
  }, 1000);
}

setupTimer();

// largeData never collected while interval runs
// Solution: clearInterval when done
```

#### 3. Event Listeners Not Removed

```javascript
function setupListener() {
  const largeData = new Array(1000000);
  
  document.getElementById('button').addEventListener('click', () => {
    console.log(largeData.length);  // Keeps largeData in memory
  });
}

setupListener();

// Solution: removeEventListener when done
```

#### 4. Closures

```javascript
function createClosure() {
  const largeData = new Array(1000000);
  
  return function() {
    // Even if not using largeData, closure keeps it in scope
    console.log('Hello');
  };
}

const fn = createClosure();
// largeData kept in memory because of closure
```

#### 5. Detached DOM Nodes

```javascript
const elements = [];

function addElement() {
  const div = document.createElement('div');
  document.body.appendChild(div);
  elements.push(div);  // Reference kept
}

addElement();

// Remove from DOM but still referenced in array
document.body.removeChild(elements[0]);
// elements[0] not garbage collected!

// Solution: remove from array too
elements.length = 0;
```

---

## Preventing Memory Leaks

### 1. Clear Timers

```javascript
function setupTimer() {
  const intervalId = setInterval(() => {
    console.log('Running');
  }, 1000);
  
  // Clear when done
  setTimeout(() => {
    clearInterval(intervalId);
  }, 10000);
}
```

### 2. Remove Event Listeners

```javascript
function setupListener() {
  const button = document.getElementById('button');
  
  function handleClick() {
    console.log('Clicked');
  }
  
  button.addEventListener('click', handleClick);
  
  // Clean up
  function cleanup() {
    button.removeEventListener('click', handleClick);
  }
  
  return cleanup;
}

const cleanup = setupListener();
// When done:
cleanup();
```

### 3. Avoid Global Variables

```javascript
// Bad
function process() {
  result = compute();  // Global
}

// Good
function process() {
  const result = compute();  // Local
  return result;
}
```

### 4. Break Circular References

```javascript
function createNodes() {
  const node1 = {};
  const node2 = {};
  
  node1.next = node2;
  node2.prev = node1;
  
  // Clean up circular references when done
  function cleanup() {
    node1.next = null;
    node2.prev = null;
  }
  
  return { node1, node2, cleanup };
}

const { cleanup } = createNodes();
cleanup();  // Break circles
```

### 5. Nullify Large Objects

```javascript
function processData() {
  let largeData = new Array(1000000);
  
  // Process data
  compute(largeData);
  
  // Clear reference when done
  largeData = null;
}
```

---

## WeakMap and WeakSet

Collections that don't prevent garbage collection.

### WeakMap

```javascript
const cache = new WeakMap();

function process(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  
  const result = expensiveComputation(obj);
  cache.set(obj, result);
  return result;
}

let user = { id: 1 };
process(user);

user = null;  // WeakMap entry automatically removed
```

### WeakSet

```javascript
const processed = new WeakSet();

function markAsProcessed(obj) {
  processed.add(obj);
}

let item = { id: 1 };
markAsProcessed(item);

item = null;  // Automatically removed from WeakSet
```

---

## Monitoring Memory Usage

### Performance API

```javascript
if (performance.memory) {
  console.log('Used JS Heap:', performance.memory.usedJSHeapSize);
  console.log('Total JS Heap:', performance.memory.totalJSHeapSize);
  console.log('Heap Limit:', performance.memory.jsHeapSizeLimit);
}
```

### Chrome DevTools

```javascript
// Take heap snapshot
// Chrome DevTools → Memory → Take snapshot

// Monitor allocations
function createObjects() {
  const objects = [];
  for (let i = 0; i < 100000; i++) {
    objects.push({ data: new Array(100) });
  }
  return objects;
}

const data = createObjects();
// Check memory in DevTools
```

---

## Best Practices

### 1. Minimize Scope

```javascript
// Bad - keeps data in scope
function process() {
  const data = loadLargeData();
  
  function helper() {
    // Closure keeps data in memory
    console.log('Helper');
  }
  
  return helper;
}

// Good - only keep what's needed
function process() {
  const data = loadLargeData();
  const summary = summarize(data);
  
  return function helper() {
    console.log('Summary:', summary);  // Only keeps summary
  };
}
```

### 2. Use Local Variables

```javascript
// Good - local scope
function calculate() {
  const result = 0;
  for (let i = 0; i < 1000; i++) {
    result += i;
  }
  return result;
}  // result and i eligible for GC
```

### 3. Clean Up Resources

```javascript
class ResourceManager {
  constructor() {
    this.resources = [];
  }
  
  addResource(resource) {
    this.resources.push(resource);
  }
  
  cleanup() {
    this.resources.forEach(r => r.dispose());
    this.resources = [];
  }
}

const manager = new ResourceManager();
// ... use manager ...
manager.cleanup();  // Clean up
```

### 4. Avoid Accidental Globals

```javascript
'use strict';

function process() {
  data = 'value';  // Error in strict mode
}

// Better
function process() {
  const data = 'value';
}
```

### 5. Profile and Monitor

```javascript
function monitorMemory() {
  setInterval(() => {
    if (performance.memory) {
      const used = performance.memory.usedJSHeapSize / 1048576;
      console.log(`Memory used: ${used.toFixed(2)} MB`);
    }
  }, 5000);
}

// monitorMemory();  // Monitor in development
```

---

## Practical Examples

### Object Pool

```javascript
class ObjectPool {
  constructor(createFn, resetFn) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.pool = [];
  }
  
  acquire() {
    return this.pool.length > 0
      ? this.pool.pop()
      : this.createFn();
  }
  
  release(obj) {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

const vectorPool = new ObjectPool(
  () => ({ x: 0, y: 0 }),
  (v) => { v.x = 0; v.y = 0; }
);

// Reuse objects instead of creating new ones
const v1 = vectorPool.acquire();
vectorPool.release(v1);
```

### Cache with Size Limit

```javascript
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) return null;
    
    // Move to end (most recently used)
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  set(key, value) {
    this.cache.delete(key);  // Remove if exists
    this.cache.set(key, value);
    
    // Remove oldest if over limit
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
}

const cache = new LRUCache(100);
// Automatically removes old entries
```

---

## Debugging Memory Leaks

### Finding Leaks

```javascript
// Take heap snapshot before
// Run suspicious code
// Take heap snapshot after
// Compare snapshots in DevTools

function suspectedLeak() {
  const leaks = [];
  
  setInterval(() => {
    leaks.push(new Array(10000));  // Growing array
  }, 100);
}

// suspectedLeak();  // Creates leak
```

### Detecting Growing Memory

```javascript
let baseline = 0;

function checkMemoryGrowth() {
  if (!performance.memory) return;
  
  const used = performance.memory.usedJSHeapSize;
  
  if (baseline === 0) {
    baseline = used;
  } else {
    const growth = used - baseline;
    const percent = (growth / baseline) * 100;
    
    if (percent > 50) {
      console.warn('Possible memory leak! Growth:', percent.toFixed(2), '%');
    }
  }
}

setInterval(checkMemoryGrowth, 10000);
```

---

## Key Takeaways

- **Garbage Collection**: Automatic memory management
- **Reachability**: Objects must be reachable to survive
- **Mark-and-Sweep**: Modern GC algorithm
- **Generational GC**: Optimizes for object lifetime
- **Memory leaks**: Unintentional retention of objects
- **Common leaks**: Globals, timers, listeners, closures, detached DOM
- **WeakMap/WeakSet**: Don't prevent GC
- **Clean up**: Clear timers, remove listeners, nullify references
- Minimize closure scope
- Use strict mode to prevent accidental globals
- Profile memory usage in DevTools
- Use object pools for frequently created objects
