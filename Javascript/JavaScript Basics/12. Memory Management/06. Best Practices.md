# Best Practices

Guidelines for efficient memory management and preventing memory leaks in JavaScript applications.

---

## Memory Management Principles

### 1. Minimize Memory Footprint

Keep only what's needed in memory.

```javascript
// Bad - keeps entire array in memory
function processLargeData() {
  const data = Array(1000000).fill({ value: 'data' });
  return data.filter(item => item.value === 'data').length;
}

// Good - process in chunks
function processLargeData() {
  let count = 0;
  const chunkSize = 1000;
  
  for (let i = 0; i < 1000000; i += chunkSize) {
    const chunk = Array(chunkSize).fill({ value: 'data' });
    count += chunk.filter(item => item.value === 'data').length;
    // chunk eligible for GC after each iteration
  }
  
  return count;
}
```

### 2. Clear References Early

Nullify references to large objects as soon as they're no longer needed.

```javascript
// Bad
function processData() {
  const largeData = loadLargeDataset();
  const summary = computeSummary(largeData);
  
  // largeData kept in memory until function ends
  
  return summary;
}

// Good
function processData() {
  let largeData = loadLargeDataset();
  const summary = computeSummary(largeData);
  
  largeData = null;  // Clear immediately
  
  return summary;
}
```

### 3. Avoid Global Variables

Global variables never get garbage collected.

```javascript
// Bad - global scope
var globalData = [];

function addData(item) {
  globalData.push(item);  // Grows forever
}

// Good - module scope with cleanup
const DataManager = (() => {
  let data = [];
  
  return {
    add(item) {
      data.push(item);
    },
    clear() {
      data = [];
    },
    getData() {
      return data;
    }
  };
})();

DataManager.add('item');
DataManager.clear();  // Can clean up when needed
```

---

## Timer and Interval Management

### Always Clear Timers

```javascript
// Bad
function startPolling() {
  setInterval(() => {
    fetchData();
  }, 1000);
  // Runs forever, can't be stopped
}

// Good
function startPolling() {
  const intervalId = setInterval(() => {
    fetchData();
  }, 1000);
  
  return () => clearInterval(intervalId);
}

const stopPolling = startPolling();
// Later: stopPolling();
```

### Use setTimeout for Recursive Delays

```javascript
// Bad - can stack up if operation takes longer than interval
setInterval(async () => {
  await longRunningOperation();  // Takes 5 seconds
}, 1000);  // Tries to run every second

// Good - waits for completion
function schedule() {
  setTimeout(async () => {
    await longRunningOperation();
    schedule();  // Reschedule after completion
  }, 1000);
}

schedule();
```

### Timer Cleanup Pattern

```javascript
class TimerManager {
  constructor() {
    this.timers = new Map();
  }
  
  setTimeout(callback, delay, id) {
    const timerId = setTimeout(() => {
      callback();
      this.timers.delete(id);
    }, delay);
    
    this.timers.set(id, timerId);
    return id;
  }
  
  clearTimeout(id) {
    if (this.timers.has(id)) {
      clearTimeout(this.timers.get(id));
      this.timers.delete(id);
    }
  }
  
  clearAll() {
    this.timers.forEach(timerId => clearTimeout(timerId));
    this.timers.clear();
  }
}

const timerManager = new TimerManager();
timerManager.setTimeout(() => console.log('Done'), 1000, 'task1');
// timerManager.clearAll();  // Clean up all timers
```

---

## Event Listener Management

### Remove Listeners When Done

```javascript
// Bad
function setupButton() {
  const button = document.getElementById('button');
  
  button.addEventListener('click', () => {
    console.log('Clicked');
  });
  // Listener never removed
}

// Good
function setupButton() {
  const button = document.getElementById('button');
  
  const handleClick = () => {
    console.log('Clicked');
  };
  
  button.addEventListener('click', handleClick);
  
  return () => {
    button.removeEventListener('click', handleClick);
  };
}

const cleanup = setupButton();
// Later: cleanup();
```

### Use Event Delegation

```javascript
// Bad - listener on each item
function setupItems() {
  const items = document.querySelectorAll('.item');
  
  items.forEach(item => {
    item.addEventListener('click', handleClick);  // 1000 listeners!
  });
}

// Good - single listener on parent
function setupItems() {
  const container = document.getElementById('container');
  
  container.addEventListener('click', (e) => {
    if (e.target.matches('.item')) {
      handleClick(e);
    }
  });
}
```

### AbortController for Cleanup

```javascript
// Modern approach using AbortController
function setupListeners() {
  const controller = new AbortController();
  const { signal } = controller;
  
  document.addEventListener('click', handleClick, { signal });
  document.addEventListener('keydown', handleKey, { signal });
  window.addEventListener('resize', handleResize, { signal });
  
  // Single cleanup for all listeners
  return () => controller.abort();
}

const cleanup = setupListeners();
// Later: cleanup();  // Removes all listeners
```

---

## Closure Best Practices

### Minimize Closure Scope

```javascript
// Bad - entire scope captured
function createHandler() {
  const largeData = new Array(1000000);
  const smallData = 'small';
  
  return function() {
    console.log(smallData);
    // Closure keeps largeData in memory even though unused
  };
}

// Good - only capture what's needed
function createHandler() {
  const largeData = new Array(1000000);
  const smallData = 'small';
  
  processData(largeData);  // Use it here
  
  return function() {
    console.log(smallData);  // Only smallData in closure
  };
}
```

### Use IIFE to Limit Scope

```javascript
// Bad
const config = loadConfig();
const processed = processConfig(config);
// config and processed remain in scope

// Good
const result = (() => {
  const config = loadConfig();
  const processed = processConfig(config);
  return processed.output;
  // config and processed eligible for GC
})();
```

---

## DOM Management

### Clear DOM References

```javascript
// Bad
const elements = {
  button: document.getElementById('button'),
  form: document.getElementById('form')
};

// If elements removed from DOM, still referenced here

// Good - clear references
function cleanup() {
  elements.button = null;
  elements.form = null;
}
```

### Detach Before Manipulation

```javascript
// Bad - slow and causes reflows
function updateList(items) {
  const list = document.getElementById('list');
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    list.appendChild(li);  // Reflow on each append
  });
}

// Good - detach, manipulate, reattach
function updateList(items) {
  const list = document.getElementById('list');
  const parent = list.parentNode;
  
  parent.removeChild(list);  // Detach
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    list.appendChild(li);
  });
  
  parent.appendChild(list);  // Reattach (single reflow)
}
```

### Use Document Fragments

```javascript
// Good - build in memory
function createList(items) {
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  
  document.getElementById('list').appendChild(fragment);
}
```

---

## Collection Management

### Implement Size Limits

```javascript
// Bad - unbounded growth
const cache = new Map();

function cacheData(key, value) {
  cache.set(key, value);  // Grows forever
}

// Good - LRU cache with limit
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) return undefined;
    
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);  // Move to end
    
    return value;
  }
  
  set(key, value) {
    this.cache.delete(key);
    this.cache.set(key, value);
    
    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
}

const cache = new LRUCache(100);
```

### Use WeakMap for Object-Keyed Data

```javascript
// Bad - prevents garbage collection
const metadata = new Map();

function setMetadata(obj, data) {
  metadata.set(obj, data);
}

let user = { name: 'John' };
setMetadata(user, { role: 'admin' });
user = null;  // metadata entry still exists!

// Good - allows garbage collection
const metadata = new WeakMap();

function setMetadata(obj, data) {
  metadata.set(obj, data);
}

let user2 = { name: 'Jane' };
setMetadata(user2, { role: 'admin' });
user2 = null;  // metadata entry automatically removed
```

---

## Async Operations

### Cancel Pending Operations

```javascript
// Bad - can't cancel
function loadData() {
  fetch('/api/data')
    .then(response => response.json())
    .then(data => process(data));
  // Continues even if no longer needed
}

// Good - cancellable
function loadData() {
  const controller = new AbortController();
  
  fetch('/api/data', { signal: controller.signal })
    .then(response => response.json())
    .then(data => process(data))
    .catch(err => {
      if (err.name === 'AbortError') {
        console.log('Cancelled');
      }
    });
  
  return () => controller.abort();
}

const cancel = loadData();
// Later: cancel();
```

### Clean Up Promise Chains

```javascript
// Bad - keeps references
const promises = [];

function addTask(task) {
  promises.push(task());
}

// Good - remove completed
const promises = new Set();

function addTask(task) {
  const promise = task().finally(() => {
    promises.delete(promise);
  });
  
  promises.add(promise);
}
```

---

## Component Lifecycle

### React/Vue Component Cleanup

```javascript
// React
class Component extends React.Component {
  componentDidMount() {
    // Setup
    this.subscription = subscribe(this.handleData);
    this.interval = setInterval(this.update, 1000);
    document.addEventListener('click', this.handleClick);
  }
  
  componentWillUnmount() {
    // Cleanup
    this.subscription.unsubscribe();
    clearInterval(this.interval);
    document.removeEventListener('click', this.handleClick);
  }
}

// React Hooks
function Component() {
  useEffect(() => {
    const subscription = subscribe(handleData);
    const interval = setInterval(update, 1000);
    document.addEventListener('click', handleClick);
    
    // Cleanup function
    return () => {
      subscription.unsubscribe();
      clearInterval(interval);
      document.removeEventListener('click', handleClick);
    };
  }, []);
}
```

---

## Object Reuse

### Object Pooling

```javascript
class ObjectPool {
  constructor(createFn, resetFn, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;
    this.available = [];
    this.inUse = new Set();
    
    // Pre-allocate
    for (let i = 0; i < initialSize; i++) {
      this.available.push(createFn());
    }
  }
  
  acquire() {
    let obj;
    
    if (this.available.length > 0) {
      obj = this.available.pop();
    } else {
      obj = this.createFn();
    }
    
    this.inUse.add(obj);
    return obj;
  }
  
  release(obj) {
    if (this.inUse.has(obj)) {
      this.inUse.delete(obj);
      this.resetFn(obj);
      this.available.push(obj);
    }
  }
  
  clear() {
    this.available = [];
    this.inUse.clear();
  }
}

// Usage
const vectorPool = new ObjectPool(
  () => ({ x: 0, y: 0, z: 0 }),
  (v) => { v.x = 0; v.y = 0; v.z = 0; }
);

const v1 = vectorPool.acquire();
v1.x = 10;
vectorPool.release(v1);  // Reuse instead of creating new
```

---

## Monitoring and Profiling

### Memory Usage Tracking

```javascript
class MemoryMonitor {
  constructor() {
    this.snapshots = [];
    this.enabled = typeof performance !== 'undefined' && performance.memory;
  }
  
  snapshot(label) {
    if (!this.enabled) return;
    
    this.snapshots.push({
      label,
      timestamp: Date.now(),
      usedHeap: performance.memory.usedJSHeapSize,
      totalHeap: performance.memory.totalJSHeapSize
    });
  }
  
  report() {
    if (this.snapshots.length < 2) return;
    
    console.table(this.snapshots.map((snap, i) => {
      const prev = i > 0 ? this.snapshots[i - 1] : snap;
      const delta = snap.usedHeap - prev.usedHeap;
      
      return {
        label: snap.label,
        usedMB: (snap.usedHeap / 1048576).toFixed(2),
        deltaMB: (delta / 1048576).toFixed(2),
        time: new Date(snap.timestamp).toLocaleTimeString()
      };
    }));
  }
  
  clear() {
    this.snapshots = [];
  }
}

const monitor = new MemoryMonitor();

monitor.snapshot('start');
// ... do work ...
monitor.snapshot('after processing');
monitor.report();
```

### Performance Marks

```javascript
function trackPerformance(name, fn) {
  performance.mark(`${name}-start`);
  
  const result = fn();
  
  performance.mark(`${name}-end`);
  performance.measure(name, `${name}-start`, `${name}-end`);
  
  const measure = performance.getEntriesByName(name)[0];
  console.log(`${name}: ${measure.duration.toFixed(2)}ms`);
  
  performance.clearMarks();
  performance.clearMeasures();
  
  return result;
}

const result = trackPerformance('data-processing', () => {
  return processLargeDataset();
});
```

---

## Common Pitfalls

### 1. Console.log in Production

```javascript
// Bad - keeps references
console.log(largeObject);  // Object can't be GC'd

// Good - only in development
if (process.env.NODE_ENV === 'development') {
  console.log(largeObject);
}
```

### 2. Forgotten Debugging Code

```javascript
// Bad
window.debugData = largeDataStructure;  // Forgot to remove

// Good - use proper debugging tools
// Remove debug code before production
```

### 3. Circular References in Objects

```javascript
// Bad
const obj1 = {};
const obj2 = {};
obj1.ref = obj2;
obj2.ref = obj1;  // Circular

// Good - break circles when done
obj1.ref = null;
obj2.ref = null;
```

---

## Best Practices Checklist

✅ **Memory Management**
- Clear references to large objects early
- Avoid global variables
- Minimize closure scope
- Use strict mode
- Nullify unused variables

✅ **Timers & Intervals**
- Always clear timers
- Return cleanup functions
- Use setTimeout for recursive delays
- Track all timers for cleanup

✅ **Event Listeners**
- Remove listeners when done
- Use event delegation
- Use AbortController
- Avoid anonymous functions (hard to remove)

✅ **DOM Management**
- Clear DOM references
- Use document fragments
- Detach before bulk updates
- Remove event listeners before removing elements

✅ **Collections**
- Implement size limits
- Use WeakMap for object keys
- Use WeakSet for object tracking
- Clear collections periodically

✅ **Async Operations**
- Cancel pending operations
- Remove completed promises
- Clean up subscriptions
- Use AbortController for fetch

✅ **Component Lifecycle**
- Clean up in unmount/destroy
- Cancel timers and intervals
- Remove event listeners
- Unsubscribe from observables

✅ **Monitoring**
- Profile memory usage
- Use Chrome DevTools
- Track performance metrics
- Monitor in development

---

## Key Takeaways

- **Clear early**: Nullify references as soon as possible
- **Clean up**: Always remove listeners, timers, subscriptions
- **Minimize scope**: Keep closures small
- **Size limits**: Prevent unbounded growth
- **Use weak references**: WeakMap/WeakSet for object data
- **Cancel operations**: Use AbortController
- **Monitor**: Profile and track memory usage
- **Object pools**: Reuse objects instead of creating new
- **Event delegation**: Reduce listener count
- **Component lifecycle**: Clean up in unmount/destroy hooks
- Avoid global variables and console.log in production
- Use strict mode to prevent accidental globals
- Profile regularly to catch leaks early
