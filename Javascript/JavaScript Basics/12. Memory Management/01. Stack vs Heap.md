# Stack vs Heap

JavaScript uses two memory structures: the stack for primitive values and execution contexts, and the heap for objects and reference types.

---

## The Stack

The stack stores primitive values and function call information.

### Characteristics

- **LIFO** (Last In, First Out)
- **Fixed size** (limited)
- **Fast access**
- **Automatic allocation/deallocation**
- Stores primitives and references to heap objects

```javascript
function example() {
  const a = 10;        // Stack: primitive value
  const b = 20;        // Stack: primitive value
  const sum = a + b;   // Stack: primitive value
  return sum;
}

example();
// After execution, stack frame is cleared automatically
```

---

## The Heap

The heap stores objects, arrays, and functions.

### Characteristics

- **Unordered** (dynamic allocation)
- **Large size** (flexible)
- **Slower access** than stack
- **Manual** deallocation (garbage collection)
- Stores reference types

```javascript
function example() {
  const obj = { name: 'John' };  // Heap: object
  const arr = [1, 2, 3];         // Heap: array
  const fn = () => {};           // Heap: function
}

// Objects remain in heap until garbage collected
```

---

## Primitive Types (Stack)

Stored directly in the stack.

```javascript
let num = 42;           // Stack: Number
let str = 'hello';      // Stack: String (*)
let bool = true;        // Stack: Boolean
let nothing = null;     // Stack: null
let undef = undefined;  // Stack: undefined
let sym = Symbol('id'); // Stack: Symbol
let big = 10n;          // Stack: BigInt

// * Small strings may be on stack, large strings on heap (implementation-specific)
```

### Copying Primitives

```javascript
let a = 10;
let b = a;  // Copy value

b = 20;

console.log(a);  // 10 (unchanged)
console.log(b);  // 20

// 'a' and 'b' are independent stack values
```

---

## Reference Types (Heap)

Objects stored in heap, variables hold references.

```javascript
let obj1 = { count: 0 };  // obj1 → Heap object
let arr1 = [1, 2, 3];     // arr1 → Heap array
let fn1 = () => {};       // fn1 → Heap function

// Variable holds reference (pointer) to heap location
```

### Copying References

```javascript
let obj1 = { count: 0 };
let obj2 = obj1;  // Copy reference, not object

obj2.count = 5;

console.log(obj1.count);  // 5 (same object!)
console.log(obj2.count);  // 5

// obj1 and obj2 point to same heap object
```

---

## Visual Representation

```
Stack                          Heap
┌──────────────┐              ┌─────────────────────┐
│ num: 42      │              │                     │
│ str: 'hi'    │              │  obj → {name:'John'}│
│ obj: [ref]───┼──────────────┤                     │
│ arr: [ref]───┼──────────┐   │  arr → [1, 2, 3]   │
└──────────────┘          └───┤                     │
                              └─────────────────────┘
```

---

## Memory Allocation

### Stack Allocation

```javascript
function calculate() {
  const x = 10;       // Stack: allocated
  const y = 20;       // Stack: allocated
  const sum = x + y;  // Stack: allocated
  return sum;
}  // Stack: all deallocated automatically

const result = calculate();
// Only 'result' remains on stack
```

### Heap Allocation

```javascript
function createUser(name) {
  const user = {       // Heap: allocated
    name: name,
    age: 30
  };
  return user;
}

const user1 = createUser('John');
const user2 = createUser('Jane');

// Objects remain in heap
// Garbage collected when no references remain
```

---

## Comparing Values

### Primitive Comparison

```javascript
let a = 10;
let b = 10;

console.log(a === b);  // true (compare values)

let str1 = 'hello';
let str2 = 'hello';

console.log(str1 === str2);  // true (compare values)
```

### Reference Comparison

```javascript
let obj1 = { count: 0 };
let obj2 = { count: 0 };

console.log(obj1 === obj2);  // false (different references)

let obj3 = obj1;
console.log(obj1 === obj3);  // true (same reference)

// Arrays
let arr1 = [1, 2, 3];
let arr2 = [1, 2, 3];

console.log(arr1 === arr2);  // false (different references)
```

---

## Passing to Functions

### Pass by Value (Primitives)

```javascript
function increment(num) {
  num = num + 1;
  console.log('Inside:', num);  // 11
}

let value = 10;
increment(value);
console.log('Outside:', value);  // 10 (unchanged)

// Primitive value copied to function parameter
```

### Pass by Reference (Objects)

```javascript
function updateUser(user) {
  user.age = 31;
}

const person = { name: 'John', age: 30 };
updateUser(person);

console.log(person.age);  // 31 (modified!)

// Reference copied, points to same object
```

### Reassignment vs Mutation

```javascript
function reassign(obj) {
  obj = { newProp: 'value' };  // Reassigns parameter
}

function mutate(obj) {
  obj.newProp = 'value';  // Modifies object
}

const original = { prop: 'original' };

reassign(original);
console.log(original);  // { prop: 'original' } (unchanged)

mutate(original);
console.log(original);  // { prop: 'original', newProp: 'value' } (modified)
```

---

## Deep vs Shallow Copy

### Shallow Copy

```javascript
const original = {
  name: 'John',
  address: {
    city: 'New York'
  }
};

// Shallow copy - nested objects still referenced
const copy1 = { ...original };
const copy2 = Object.assign({}, original);

copy1.name = 'Jane';              // Safe (primitive)
copy1.address.city = 'Boston';    // Affects original!

console.log(original.address.city);  // 'Boston'
```

### Deep Copy

```javascript
const original = {
  name: 'John',
  address: {
    city: 'New York'
  }
};

// Deep copy - completely independent
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.name = 'Jane';
deepCopy.address.city = 'Boston';

console.log(original.address.city);  // 'New York' (unchanged)

// Or use structuredClone (modern)
const deepCopy2 = structuredClone(original);
```

---

## Stack Overflow

Stack has limited size.

```javascript
function recurse() {
  recurse();  // No base case
}

// recurse();  // RangeError: Maximum call stack size exceeded

// Each call adds frame to stack
// Eventually runs out of memory
```

### Avoiding Stack Overflow

```javascript
// Use tail recursion or iteration
function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc);  // Tail recursive
}

// Or iterative
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}
```

---

## Memory Size Comparison

```javascript
// Stack (small, fast)
let num = 42;                    // ~8 bytes
let str = 'hello';               // ~10-20 bytes
let bool = true;                 // ~4 bytes

// Heap (large, slower)
let arr = new Array(1000000);    // ~8MB
let obj = { data: new Array(1000000) };  // ~8MB+

// Large data structures use heap
```

---

## Practical Examples

### Data Structures

```javascript
// Stack-based (primitives)
function sumNumbers(a, b, c) {
  const sum = a + b + c;  // All on stack
  return sum;
}

// Heap-based (objects)
function createMatrix(rows, cols) {
  const matrix = [];  // Heap: array
  for (let i = 0; i < rows; i++) {
    matrix[i] = [];  // Heap: nested array
    for (let j = 0; j < cols; j++) {
      matrix[i][j] = 0;
    }
  }
  return matrix;
}
```

### Closures

```javascript
function createCounter() {
  let count = 0;  // Stack variable
  
  return {  // Heap object
    increment() {
      count++;  // Access stack variable via closure
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
// count persists because closure references it
// Object on heap, count in closure scope
```

---

## Memory Implications

### Efficient Code

```javascript
// Good - reuse primitives
function calculate(n) {
  let sum = 0;  // Stack
  for (let i = 0; i < n; i++) {
    sum += i;  // Stack operation, fast
  }
  return sum;
}

// Avoid creating unnecessary objects
function process(data) {
  // Bad - creates new object each iteration
  for (let i = 0; i < 1000; i++) {
    const temp = { value: data[i] };  // Heap allocation
    doSomething(temp);
  }
  
  // Better - reuse object or use primitive
  for (let i = 0; i < 1000; i++) {
    doSomething(data[i]);
  }
}
```

---

## Garbage Collection

Stack memory automatically managed, heap requires GC.

```javascript
function createObjects() {
  const obj1 = { data: 'large' };  // Heap
  const obj2 = { data: 'large' };  // Heap
  
  return obj1;
}  // obj2 has no reference, eligible for GC

const result = createObjects();
// result references obj1 (kept)
// obj2 garbage collected
```

---

## Performance Tips

```javascript
// 1. Prefer primitives for simple data
let count = 0;  // Stack, fast
// Not: let count = { value: 0 };  // Heap, slower

// 2. Reuse objects instead of creating new ones
const reusable = { x: 0, y: 0 };
function updatePosition(x, y) {
  reusable.x = x;
  reusable.y = y;
  return reusable;
}

// 3. Use object pools for frequently created objects
class ObjectPool {
  constructor() {
    this.pool = [];
  }
  
  acquire() {
    return this.pool.pop() || { x: 0, y: 0 };
  }
  
  release(obj) {
    obj.x = 0;
    obj.y = 0;
    this.pool.push(obj);
  }
}

// 4. Clear references when done
let largeData = new Array(1000000);
// ... use data ...
largeData = null;  // Allow GC
```

---

## Common Pitfalls

```javascript
// 1. Thinking object assignment copies
let obj1 = { count: 0 };
let obj2 = obj1;  // Reference copy, not object copy!
obj2.count = 5;
console.log(obj1.count);  // 5 (same object)

// 2. Accidental global variables (heap)
function bad() {
  forgotten = 'oops';  // No var/let/const → global (heap)
}

// 3. Closures retaining references
function createLeak() {
  const largeData = new Array(1000000);
  
  return function() {
    // Closure keeps largeData in memory
    console.log(largeData.length);
  };
}

// 4. Not clearing timers/listeners
setInterval(() => {
  const data = fetchData();  // Creates objects each interval
}, 1000);
// Objects accumulate if not cleared
```

---

## Best Practices

```javascript
// 1. Understand value vs reference
const num = 10;  // Value
const obj = {};  // Reference

// 2. Use primitives when possible
let count = 0;  // Better than { value: 0 }

// 3. Make defensive copies when needed
function updateUser(user) {
  const copy = { ...user };
  copy.age = 31;
  return copy;
}

// 4. Clear large object references
let largeArray = new Array(1000000);
// ... use it ...
largeArray = null;  // Help GC

// 5. Be mindful of closures
function createHandler() {
  const smallData = { id: 1 };  // Keep it small
  return () => console.log(smallData.id);
}
```

---

## Key Takeaways

- **Stack**: Primitives, fixed size, fast, LIFO, auto-managed
- **Heap**: Objects/arrays/functions, flexible size, slower, GC-managed
- **Primitives**: Copied by value
- **Objects**: Copied by reference
- **Comparison**: Primitives compare values, objects compare references
- **Function params**: Primitives pass by value, objects pass by reference
- **Shallow copy**: Top level copied, nested references shared
- **Deep copy**: Fully independent copy
- Stack overflow from deep recursion
- Clear references to help garbage collection
- Prefer primitives for simple data
- Be aware of closure memory implications
