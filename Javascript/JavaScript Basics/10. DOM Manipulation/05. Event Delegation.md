# Event Delegation

Using a single event listener on a parent element to handle events from multiple children.

---

## What is Event Delegation?

Instead of attaching event listeners to individual elements, attach one listener to a common parent.

```javascript
// Without delegation (inefficient)
const buttons = document.querySelectorAll('.btn');
buttons.forEach(button => {
  button.addEventListener('click', () => {
    console.log('Button clicked');
  });
});

// With delegation (efficient)
document.querySelector('.container').addEventListener('click', (e) => {
  if (e.target.matches('.btn')) {
    console.log('Button clicked');
  }
});
```

---

## Why Use Event Delegation?

### 1. Better Performance

```javascript
// Bad - 1000 event listeners
const items = document.querySelectorAll('.item');  // 1000 items
items.forEach(item => {
  item.addEventListener('click', handleClick);
});

// Good - 1 event listener
document.querySelector('.list').addEventListener('click', (e) => {
  if (e.target.matches('.item')) {
    handleClick(e);
  }
});
```

### 2. Works with Dynamic Elements

```javascript
const list = document.querySelector('.todo-list');

// Event delegation - works for future items
list.addEventListener('click', (e) => {
  if (e.target.matches('.delete-btn')) {
    e.target.closest('li').remove();
  }
});

// Add new item later - listener still works!
const newItem = document.createElement('li');
newItem.innerHTML = '<button class="delete-btn">Delete</button>';
list.appendChild(newItem);
```

### 3. Simplified Code

```javascript
// One listener handles multiple event types
const form = document.querySelector('form');

form.addEventListener('click', (e) => {
  if (e.target.matches('.submit-btn')) {
    handleSubmit(e);
  }
  
  if (e.target.matches('.cancel-btn')) {
    handleCancel(e);
  }
  
  if (e.target.matches('.reset-btn')) {
    handleReset(e);
  }
});
```

---

## Event Bubbling

Event delegation relies on event bubbling.

```javascript
// HTML: <div id="parent"><button id="child">Click</button></div>

const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Click on child triggers both listeners
child.addEventListener('click', () => {
  console.log('Child clicked');
});

parent.addEventListener('click', () => {
  console.log('Parent clicked');
});

// Click child: Logs "Child clicked" then "Parent clicked"
```

### Event Flow

```
Window
  └─ Document
      └─ HTML
          └─ Body
              └─ Parent
                  └─ Child (clicked)

Capture Phase (top to bottom)
Target Phase (at child)
Bubble Phase (bottom to top) ← Event delegation uses this
```

---

## Target vs CurrentTarget

```javascript
const list = document.querySelector('ul');

list.addEventListener('click', (e) => {
  console.log('target:', e.target);            // Element that was clicked
  console.log('currentTarget:', e.currentTarget);  // Element with listener (ul)
});

// Click on <li>: target = li, currentTarget = ul
// Click on <button> inside <li>: target = button, currentTarget = ul
```

---

## Checking the Target

### matches()

```javascript
parent.addEventListener('click', (e) => {
  if (e.target.matches('.btn')) {
    console.log('Button clicked');
  }
});
```

### Tag Name

```javascript
list.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') {
    console.log('List item clicked');
  }
});
```

### Class Check

```javascript
container.addEventListener('click', (e) => {
  if (e.target.classList.contains('clickable')) {
    console.log('Clickable element');
  }
});
```

### Attribute Check

```javascript
parent.addEventListener('click', (e) => {
  if (e.target.hasAttribute('data-action')) {
    const action = e.target.getAttribute('data-action');
    handleAction(action);
  }
});
```

---

## closest() - Find Ancestor

Useful when event target might be nested inside the element you care about.

```javascript
const table = document.querySelector('table');

// HTML: <tr><td><button>Delete</button></td></tr>

table.addEventListener('click', (e) => {
  // e.target might be button, td, or tr
  const row = e.target.closest('tr');
  
  if (row && e.target.matches('.delete-btn')) {
    row.remove();
  }
});
```

### Practical Example

```javascript
// HTML: <div class="card"><h3>Title</h3><p>Text</p><button>Click</button></div>

const container = document.querySelector('.container');

container.addEventListener('click', (e) => {
  // Find the card, regardless of which child was clicked
  const card = e.target.closest('.card');
  
  if (card && e.target.matches('button')) {
    console.log('Button in card clicked:', card.querySelector('h3').textContent);
  }
});
```

---

## Practical Examples

### Todo List

```javascript
const todoList = document.querySelector('.todo-list');

todoList.addEventListener('click', (e) => {
  const item = e.target.closest('.todo-item');
  if (!item) return;
  
  // Toggle completion
  if (e.target.matches('.checkbox')) {
    item.classList.toggle('completed');
  }
  
  // Delete item
  if (e.target.matches('.delete-btn')) {
    item.remove();
  }
  
  // Edit item
  if (e.target.matches('.edit-btn')) {
    const text = item.querySelector('.todo-text');
    text.contentEditable = true;
    text.focus();
  }
});
```

### Tab Component

```javascript
const tabContainer = document.querySelector('.tabs');

tabContainer.addEventListener('click', (e) => {
  if (e.target.matches('.tab-button')) {
    // Remove active class from all tabs
    tabContainer.querySelectorAll('.tab-button').forEach(tab => {
      tab.classList.remove('active');
    });
    
    // Add active class to clicked tab
    e.target.classList.add('active');
    
    // Show corresponding content
    const tabId = e.target.dataset.tab;
    showTabContent(tabId);
  }
});
```

### Dropdown Menu

```javascript
const dropdown = document.querySelector('.dropdown');

dropdown.addEventListener('click', (e) => {
  if (e.target.matches('.dropdown-item')) {
    const value = e.target.dataset.value;
    const text = e.target.textContent;
    
    // Update selected value
    dropdown.querySelector('.dropdown-selected').textContent = text;
    dropdown.querySelector('.dropdown-menu').classList.remove('open');
    
    // Trigger change event
    const event = new CustomEvent('dropdownchange', {
      detail: { value, text }
    });
    dropdown.dispatchEvent(event);
  }
});
```

### Data Table

```javascript
const table = document.querySelector('table');

table.addEventListener('click', (e) => {
  const row = e.target.closest('tr');
  if (!row) return;
  
  // Sort by column
  if (e.target.matches('th')) {
    const columnIndex = Array.from(e.target.parentElement.children).indexOf(e.target);
    sortTableByColumn(table, columnIndex);
  }
  
  // Delete row
  if (e.target.matches('.delete-btn')) {
    row.remove();
  }
  
  // Edit row
  if (e.target.matches('.edit-btn')) {
    const cells = row.querySelectorAll('td');
    cells.forEach(cell => {
      cell.contentEditable = true;
    });
  }
  
  // Select row
  if (e.target.matches('.select-checkbox')) {
    row.classList.toggle('selected');
  }
});
```

### Image Gallery

```javascript
const gallery = document.querySelector('.gallery');

gallery.addEventListener('click', (e) => {
  if (e.target.matches('.thumbnail')) {
    const fullImageUrl = e.target.dataset.full;
    openLightbox(fullImageUrl);
  }
  
  if (e.target.matches('.download-btn')) {
    const image = e.target.closest('.gallery-item').querySelector('img');
    downloadImage(image.src);
  }
  
  if (e.target.matches('.favorite-btn')) {
    e.target.classList.toggle('active');
    const imageId = e.target.closest('.gallery-item').dataset.id;
    toggleFavorite(imageId);
  }
});
```

---

## Handling Multiple Event Types

```javascript
const form = document.querySelector('form');

// Handle all form events with delegation
form.addEventListener('input', (e) => {
  if (e.target.matches('[data-validate]')) {
    validateField(e.target);
  }
});

form.addEventListener('change', (e) => {
  if (e.target.matches('select')) {
    handleSelectChange(e.target);
  }
  
  if (e.target.type === 'checkbox') {
    handleCheckboxChange(e.target);
  }
});

form.addEventListener('submit', (e) => {
  e.preventDefault();
  if (validateForm()) {
    submitForm();
  }
});
```

---

## Data Attributes Pattern

```javascript
// HTML: <button data-action="save">Save</button>
//       <button data-action="delete">Delete</button>
//       <button data-action="cancel">Cancel</button>

const toolbar = document.querySelector('.toolbar');

const actions = {
  save: () => console.log('Saving...'),
  delete: () => console.log('Deleting...'),
  cancel: () => console.log('Canceling...')
};

toolbar.addEventListener('click', (e) => {
  const action = e.target.dataset.action;
  
  if (action && actions[action]) {
    actions[action]();
  }
});
```

### Advanced Data Attribute Pattern

```javascript
// HTML: <button data-cmd="edit" data-id="123">Edit</button>

const container = document.querySelector('.container');

container.addEventListener('click', (e) => {
  const button = e.target.closest('[data-cmd]');
  if (!button) return;
  
  const cmd = button.dataset.cmd;
  const id = button.dataset.id;
  
  switch (cmd) {
    case 'edit':
      editItem(id);
      break;
    case 'delete':
      deleteItem(id);
      break;
    case 'view':
      viewItem(id);
      break;
  }
});
```

---

## Preventing Unwanted Bubbling

### stopPropagation

```javascript
parent.addEventListener('click', (e) => {
  if (e.target.matches('.no-bubble')) {
    e.stopPropagation();
    return;
  }
  
  // Handle other clicks
  console.log('Parent clicked');
});
```

### Check Target Before Handling

```javascript
parent.addEventListener('click', (e) => {
  // Only handle if parent itself was clicked
  if (e.target === e.currentTarget) {
    console.log('Parent clicked directly');
  }
});
```

---

## Common Patterns

### Click Outside to Close

```javascript
const modal = document.querySelector('.modal');
const modalContent = modal.querySelector('.modal-content');

document.addEventListener('click', (e) => {
  // Close if clicked outside modal content
  if (modal.classList.contains('open') && 
      !modalContent.contains(e.target)) {
    modal.classList.remove('open');
  }
});
```

### Menu Navigation

```javascript
const nav = document.querySelector('nav');

nav.addEventListener('click', (e) => {
  const link = e.target.closest('a');
  if (!link) return;
  
  // Remove active from all
  nav.querySelectorAll('a').forEach(a => {
    a.classList.remove('active');
  });
  
  // Add active to clicked
  link.classList.add('active');
  
  // Smooth scroll to section
  if (link.hash) {
    e.preventDefault();
    document.querySelector(link.hash).scrollIntoView({
      behavior: 'smooth'
    });
  }
});
```

### Form Field Groups

```javascript
const formGroup = document.querySelector('.form-group');

formGroup.addEventListener('input', (e) => {
  if (e.target.matches('input, textarea')) {
    // Remove error on input
    const errorMsg = e.target.nextElementSibling;
    if (errorMsg && errorMsg.classList.contains('error')) {
      errorMsg.remove();
    }
    
    // Real-time validation
    validateField(e.target);
  }
});
```

---

## Performance Optimization

### Throttle Scroll Events

```javascript
let throttleTimeout;

window.addEventListener('scroll', (e) => {
  if (throttleTimeout) return;
  
  throttleTimeout = setTimeout(() => {
    // Handle scroll event
    handleScroll(e);
    throttleTimeout = null;
  }, 100);
});
```

### Debounce Input Events

```javascript
let debounceTimeout;

searchBox.addEventListener('input', (e) => {
  clearTimeout(debounceTimeout);
  
  debounceTimeout = setTimeout(() => {
    performSearch(e.target.value);
  }, 300);
});
```

---

## When NOT to Use Event Delegation

### Specific Element Behavior

```javascript
// Don't use delegation for unique elements
const submitButton = document.querySelector('#submit-btn');
submitButton.addEventListener('click', handleSubmit);

// Don't need delegation here
```

### Events That Don't Bubble

```javascript
// These events don't bubble
element.addEventListener('focus', handler);   // Doesn't bubble
element.addEventListener('blur', handler);    // Doesn't bubble
element.addEventListener('load', handler);    // Doesn't bubble
element.addEventListener('scroll', handler);  // Doesn't bubble

// Use focusin/focusout instead (they bubble)
parent.addEventListener('focusin', (e) => {
  if (e.target.matches('input')) {
    console.log('Input focused');
  }
});
```

### Performance-Critical Events

```javascript
// For very frequent events, direct listeners might be better
canvas.addEventListener('mousemove', drawLine);  // Direct is better
```

---

## Best Practices

```javascript
// 1. Check if element exists before handling
parent.addEventListener('click', (e) => {
  const target = e.target.closest('.item');
  if (!target) return;
  
  handleClick(target);
});

// 2. Use data attributes for actions
<button data-action="delete" data-id="123">Delete</button>

// 3. Use closest() for nested elements
const card = e.target.closest('.card');

// 4. Return early for non-matching events
if (!e.target.matches('.btn')) return;

// 5. Delegate to the closest common parent
// Not document (too broad), not each item (too specific)
const list = document.querySelector('.list');
list.addEventListener('click', handler);

// 6. Document clear event handling logic
function handleTableClick(e) {
  // Handle sort
  if (e.target.matches('th')) return handleSort(e);
  
  // Handle delete
  if (e.target.matches('.delete-btn')) return handleDelete(e);
  
  // Handle edit
  if (e.target.matches('.edit-btn')) return handleEdit(e);
}
```

---

## Key Takeaways

- **Event delegation**: One listener for many children
- **Benefits**: Performance, dynamic elements, simpler code
- **Relies on**: Event bubbling (bottom to top)
- **matches()**: Check if target matches selector
- **closest()**: Find ancestor element
- **target**: Element that was clicked
- **currentTarget**: Element with listener
- Use for lists, tables, grids, menus
- Don't use for events that don't bubble
- Check target exists before handling
- Use data attributes for configuration
- Return early for non-matching events
- Perfect for dynamic content
