# DOM Traversal

Methods for navigating and accessing related elements in the DOM tree.

---

## Parent Elements

### parentNode

Returns the parent node (can be any node type).

```javascript
const child = document.querySelector('.child');

console.log(child.parentNode);  // Parent element

// Navigate up multiple levels
const grandparent = child.parentNode.parentNode;
```

### parentElement

Returns the parent element (only Element nodes, not text/comment nodes).

```javascript
const element = document.querySelector('.item');

console.log(element.parentElement);  // Parent element

// Usually same as parentNode for elements
// Difference: document.documentElement.parentNode is Document
//             document.documentElement.parentElement is null
```

### closest()

Finds the nearest ancestor matching a selector (including self).

```javascript
const button = document.querySelector('.submit-btn');

// Find closest form
const form = button.closest('form');

// Find closest div with class
const container = button.closest('.container');

// Find closest element with attribute
const section = button.closest('[data-section]');
```

#### Practical Examples

```javascript
// Check if element is inside a specific parent
const listItem = document.querySelector('li');
if (listItem.closest('ul.todo-list')) {
  console.log('Inside todo list');
}

// Event delegation
document.addEventListener('click', (e) => {
  const card = e.target.closest('.card');
  if (card) {
    console.log('Clicked inside card');
  }
});

// Find parent with data attribute
const element = document.querySelector('.item');
const container = element.closest('[data-container-id]');
const id = container.dataset.containerId;
```

---

## Child Elements

### children

Returns a live HTMLCollection of child elements (excludes text/comment nodes).

```javascript
const parent = document.querySelector('.container');

console.log(parent.children);        // HTMLCollection of child elements
console.log(parent.children.length); // Number of children
console.log(parent.children[0]);     // First child element

// Iterate over children
Array.from(parent.children).forEach(child => {
  console.log(child.textContent);
});
```

### childNodes

Returns a live NodeList of all child nodes (includes text, comments, elements).

```javascript
const parent = document.querySelector('.container');

console.log(parent.childNodes);  // NodeList (includes text nodes)

// Filter for element nodes
const elementNodes = Array.from(parent.childNodes).filter(node => {
  return node.nodeType === Node.ELEMENT_NODE;
});
```

### firstChild / lastChild

```javascript
const list = document.querySelector('ul');

console.log(list.firstChild);  // First child node (might be text node)
console.log(list.lastChild);   // Last child node
```

### firstElementChild / lastElementChild

```javascript
const list = document.querySelector('ul');

console.log(list.firstElementChild);  // First child element (skips text nodes)
console.log(list.lastElementChild);   // Last child element
```

#### Practical Examples

```javascript
// Get first and last items
const list = document.querySelector('ul');
const firstItem = list.firstElementChild;
const lastItem = list.lastElementChild;

firstItem.classList.add('first');
lastItem.classList.add('last');

// Remove all children
const container = document.querySelector('.container');
while (container.firstChild) {
  container.removeChild(container.firstChild);
}

// Or simpler
container.innerHTML = '';
```

---

## Sibling Elements

### nextSibling / previousSibling

Returns next/previous node (includes text nodes).

```javascript
const element = document.querySelector('.item');

console.log(element.nextSibling);      // Might be text node
console.log(element.previousSibling);  // Might be text node
```

### nextElementSibling / previousElementSibling

Returns next/previous element (skips text nodes).

```javascript
const element = document.querySelector('.item');

const next = element.nextElementSibling;
const prev = element.previousElementSibling;

console.log(next);  // Next element
console.log(prev);  // Previous element
```

#### Practical Examples

```javascript
// Navigate through siblings
let current = list.firstElementChild;

while (current) {
  console.log(current.textContent);
  current = current.nextElementSibling;
}

// Highlight next item
function highlightNext(element) {
  const next = element.nextElementSibling;
  if (next) {
    element.classList.remove('highlight');
    next.classList.add('highlight');
  }
}

// Toggle siblings
function toggleSiblings(element) {
  let sibling = element.parentElement.firstElementChild;
  
  while (sibling) {
    if (sibling !== element) {
      sibling.classList.toggle('hidden');
    }
    sibling = sibling.nextElementSibling;
  }
}
```

---

## Node Type Checking

### nodeType

Identifies the type of node.

```javascript
const element = document.querySelector('div');

console.log(element.nodeType);  // 1 (ELEMENT_NODE)

// Common node types
Node.ELEMENT_NODE     // 1
Node.TEXT_NODE        // 3
Node.COMMENT_NODE     // 8
Node.DOCUMENT_NODE    // 9

// Check if element
if (node.nodeType === Node.ELEMENT_NODE) {
  console.log('This is an element');
}
```

### nodeName / tagName

```javascript
const element = document.querySelector('div');

console.log(element.nodeName);  // 'DIV'
console.log(element.tagName);   // 'DIV'

// tagName only for elements, nodeName for all nodes
const textNode = document.createTextNode('text');
console.log(textNode.nodeName);  // '#text'
```

---

## Practical Traversal Examples

### Find All Parents

```javascript
function getParents(element) {
  const parents = [];
  let current = element.parentElement;
  
  while (current) {
    parents.push(current);
    current = current.parentElement;
  }
  
  return parents;
}

const element = document.querySelector('.nested-item');
const parents = getParents(element);
console.log(parents);  // [parent, grandparent, ...]
```

### Get All Siblings

```javascript
function getSiblings(element) {
  const siblings = [];
  let sibling = element.parentElement.firstElementChild;
  
  while (sibling) {
    if (sibling !== element) {
      siblings.push(sibling);
    }
    sibling = sibling.nextElementSibling;
  }
  
  return siblings;
}

const element = document.querySelector('.item');
const siblings = getSiblings(element);
```

### Find All Descendants

```javascript
function getAllDescendants(element) {
  const descendants = [];
  
  function traverse(node) {
    for (const child of node.children) {
      descendants.push(child);
      traverse(child);
    }
  }
  
  traverse(element);
  return descendants;
}

const container = document.querySelector('.container');
const all = getAllDescendants(container);
```

### Breadcrumb Navigation

```javascript
function getBreadcrumb(element, selector) {
  const breadcrumb = [];
  let current = element;
  
  while (current) {
    if (current.matches(selector)) {
      breadcrumb.unshift(current);
    }
    current = current.parentElement;
  }
  
  return breadcrumb;
}

// Get all sections from current to root
const element = document.querySelector('.nested-content');
const sections = getBreadcrumb(element, 'section');
```

### Tree Walker

```javascript
function walkTree(element, callback) {
  callback(element);
  
  for (const child of element.children) {
    walkTree(child, callback);
  }
}

const container = document.querySelector('.container');

walkTree(container, (element) => {
  console.log(element.tagName, element.className);
});
```

---

## Accordion Component

```javascript
function setupAccordion() {
  const accordion = document.querySelector('.accordion');
  
  accordion.addEventListener('click', (e) => {
    const header = e.target.closest('.accordion-header');
    if (!header) return;
    
    // Get content (next sibling)
    const content = header.nextElementSibling;
    
    // Close all other sections
    const allHeaders = accordion.querySelectorAll('.accordion-header');
    allHeaders.forEach(h => {
      if (h !== header) {
        h.classList.remove('active');
        h.nextElementSibling.style.maxHeight = null;
      }
    });
    
    // Toggle current section
    header.classList.toggle('active');
    
    if (header.classList.contains('active')) {
      content.style.maxHeight = content.scrollHeight + 'px';
    } else {
      content.style.maxHeight = null;
    }
  });
}
```

---

## Tab Navigation

```javascript
function setupTabs() {
  const tabContainer = document.querySelector('.tabs');
  const tabButtons = tabContainer.querySelectorAll('.tab-btn');
  
  tabButtons.forEach((button, index) => {
    button.addEventListener('click', () => {
      // Remove active from all tabs
      tabButtons.forEach(btn => btn.classList.remove('active'));
      
      // Add active to clicked tab
      button.classList.add('active');
      
      // Hide all content panels
      const contentContainer = tabContainer.nextElementSibling;
      const panels = contentContainer.children;
      
      Array.from(panels).forEach(panel => {
        panel.classList.remove('active');
      });
      
      // Show corresponding panel
      panels[index].classList.add('active');
    });
  });
}
```

---

## Table Row Operations

```javascript
function setupTable() {
  const table = document.querySelector('table');
  
  table.addEventListener('click', (e) => {
    const row = e.target.closest('tr');
    if (!row) return;
    
    // Move row up
    if (e.target.matches('.move-up')) {
      const prevRow = row.previousElementSibling;
      if (prevRow) {
        row.parentElement.insertBefore(row, prevRow);
      }
    }
    
    // Move row down
    if (e.target.matches('.move-down')) {
      const nextRow = row.nextElementSibling;
      if (nextRow) {
        row.parentElement.insertBefore(nextRow, row);
      }
    }
    
    // Highlight row and siblings
    if (e.target.matches('.highlight-all')) {
      const tbody = row.parentElement;
      Array.from(tbody.children).forEach(r => {
        r.classList.add('highlight');
      });
    }
  });
}
```

---

## Form Navigation

```javascript
function setupFormNavigation() {
  const form = document.querySelector('form');
  
  form.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.target.matches('textarea')) {
      e.preventDefault();
      
      // Find next input
      const inputs = Array.from(form.querySelectorAll('input, select, textarea'));
      const currentIndex = inputs.indexOf(e.target);
      const nextInput = inputs[currentIndex + 1];
      
      if (nextInput) {
        nextInput.focus();
      }
    }
  });
}
```

---

## List Reordering

```javascript
function setupReorderableList() {
  const list = document.querySelector('.reorderable-list');
  
  list.addEventListener('click', (e) => {
    const item = e.target.closest('li');
    if (!item) return;
    
    // Move up
    if (e.target.matches('.move-up')) {
      const prev = item.previousElementSibling;
      if (prev) {
        item.parentElement.insertBefore(item, prev);
      }
    }
    
    // Move down
    if (e.target.matches('.move-down')) {
      const next = item.nextElementSibling;
      if (next) {
        item.parentElement.insertBefore(next, item);
      }
    }
    
    // Move to top
    if (e.target.matches('.move-top')) {
      const parent = item.parentElement;
      parent.insertBefore(item, parent.firstElementChild);
    }
    
    // Move to bottom
    if (e.target.matches('.move-bottom')) {
      item.parentElement.appendChild(item);
    }
  });
}
```

---

## Nested Menu Navigation

```javascript
function setupNestedMenu() {
  const menu = document.querySelector('.nested-menu');
  
  menu.addEventListener('click', (e) => {
    const menuItem = e.target.closest('.menu-item');
    if (!menuItem) return;
    
    // Find submenu (next sibling)
    const submenu = menuItem.nextElementSibling;
    
    if (submenu && submenu.classList.contains('submenu')) {
      // Close all siblings' submenus
      const parent = menuItem.parentElement;
      Array.from(parent.children).forEach(child => {
        if (child !== menuItem && child.nextElementSibling) {
          child.classList.remove('open');
          child.nextElementSibling.classList.remove('open');
        }
      });
      
      // Toggle current submenu
      menuItem.classList.toggle('open');
      submenu.classList.toggle('open');
    }
  });
}
```

---

## Performance Tips

### Cache References

```javascript
// Bad - queries DOM repeatedly
for (let i = 0; i < 100; i++) {
  element.parentElement.children[i].classList.add('highlight');
}

// Good - cache parent
const parent = element.parentElement;
for (let i = 0; i < 100; i++) {
  parent.children[i].classList.add('highlight');
}
```

### Use Efficient Selectors

```javascript
// Slower - traverses entire tree
const element = document.querySelector('.deep .nested .item');

// Faster - narrow scope
const container = document.querySelector('.container');
const element = container.querySelector('.item');
```

---

## Best Practices

```javascript
// 1. Use element-specific properties (skip text nodes)
const next = element.nextElementSibling;  // Good
const next = element.nextSibling;         // Might be text node

// 2. Cache parent references
const parent = element.parentElement;
parent.children[0].classList.add('first');
parent.children[1].classList.add('second');

// 3. Use closest() for ancestor search
const form = button.closest('form');

// 4. Check if sibling exists before using
const next = element.nextElementSibling;
if (next) {
  next.classList.add('active');
}

// 5. Use children instead of childNodes for elements
const items = list.children;  // Only elements

// 6. Convert HTMLCollection to array for methods
const items = Array.from(parent.children);
items.forEach(item => { /* ... */ });
```

---

## Common Pitfalls

```javascript
// 1. Text nodes between elements
<ul>
  <li>Item 1</li>  <!-- nextSibling is text node (whitespace) -->
  <li>Item 2</li>
</ul>

// Use nextElementSibling instead
const next = element.nextElementSibling;

// 2. Live collections
const children = parent.children;  // Live HTMLCollection
console.log(children.length);  // 3

parent.appendChild(newChild);
console.log(children.length);  // 4 (automatically updated)

// 3. Modifying while iterating
// Bad - can skip elements
for (let child of parent.children) {
  parent.removeChild(child);  // Modifies collection while iterating
}

// Good - convert to array first
Array.from(parent.children).forEach(child => {
  parent.removeChild(child);
});
```

---

## Key Takeaways

- **parentElement**: Direct parent
- **closest()**: Find ancestor by selector
- **children**: Child elements (no text nodes)
- **firstElementChild/lastElementChild**: First/last child
- **nextElementSibling/previousElementSibling**: Adjacent elements
- **nodeType**: Check node type (element, text, etc.)
- Use element-specific properties to skip text nodes
- Cache references for better performance
- closest() is powerful for finding ancestors
- HTMLCollections are live (automatically update)
- Convert to array when modifying during iteration
- Check existence before accessing siblings/children
