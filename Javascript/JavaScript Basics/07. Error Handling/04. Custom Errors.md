# Custom Errors

Creating custom error classes for domain-specific error handling in your applications.

---

## Why Custom Errors?

Custom errors provide:
- **Better semantics** - Clear error types for your domain
- **Additional context** - Extra properties for debugging
- **Specific handling** - Catch and handle different errors differently
- **Type safety** - Use `instanceof` checks

---

## Basic Custom Error

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomError";
  }
}

try {
  throw new CustomError("Something went wrong");
} catch (error) {
  console.log(error.name);     // "CustomError"
  console.log(error.message);  // "Something went wrong"
  console.log(error instanceof CustomError);  // true
  console.log(error instanceof Error);  // true
}
```

---

## Custom Error with Additional Properties

```javascript
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = "ValidationError";
    this.field = field;
  }
}

try {
  throw new ValidationError("Invalid email format", "email");
} catch (error) {
  console.log(error.message);  // "Invalid email format"
  console.log(error.field);    // "email"
}
```

---

## HTTP Error Example

```javascript
class HttpError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.name = "HttpError";
    this.statusCode = statusCode;
    this.timestamp = new Date();
  }
  
  isClientError() {
    return this.statusCode >= 400 && this.statusCode < 500;
  }
  
  isServerError() {
    return this.statusCode >= 500;
  }
}

// Specific HTTP errors
class NotFoundError extends HttpError {
  constructor(resource) {
    super(`${resource} not found`, 404);
    this.name = "NotFoundError";
    this.resource = resource;
  }
}

class UnauthorizedError extends HttpError {
  constructor(message = "Unauthorized") {
    super(message, 401);
    this.name = "UnauthorizedError";
  }
}

// Usage
try {
  throw new NotFoundError("User");
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log(`${error.resource} not found (${error.statusCode})`);
  }
}
```

---

## Validation Error with Multiple Fields

```javascript
class ValidationError extends Error {
  constructor(message, errors = {}) {
    super(message);
    this.name = "ValidationError";
    this.errors = errors;  // { field: errorMessage }
  }
  
  hasErrors() {
    return Object.keys(this.errors).length > 0;
  }
  
  getError(field) {
    return this.errors[field];
  }
}

// Usage
function validateUser(user) {
  const errors = {};
  
  if (!user.email) {
    errors.email = "Email is required";
  } else if (!user.email.includes("@")) {
    errors.email = "Invalid email format";
  }
  
  if (!user.password || user.password.length < 8) {
    errors.password = "Password must be at least 8 characters";
  }
  
  if (Object.keys(errors).length > 0) {
    throw new ValidationError("Validation failed", errors);
  }
  
  return true;
}

try {
  validateUser({ email: "invalid", password: "123" });
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(error.message);  // "Validation failed"
    console.log(error.errors);   // { email: "...", password: "..." }
  }
}
```

---

## Database Error

```javascript
class DatabaseError extends Error {
  constructor(message, query, originalError) {
    super(message);
    this.name = "DatabaseError";
    this.query = query;
    this.originalError = originalError;
    this.timestamp = new Date();
  }
}

// Specific database errors
class ConnectionError extends DatabaseError {
  constructor(message, originalError) {
    super(message, null, originalError);
    this.name = "ConnectionError";
  }
}

class QueryError extends DatabaseError {
  constructor(message, query, originalError) {
    super(message, query, originalError);
    this.name = "QueryError";
  }
}

// Usage
async function executeQuery(query) {
  try {
    // Execute database query
    const result = await db.execute(query);
    return result;
  } catch (error) {
    throw new QueryError(
      "Failed to execute query",
      query,
      error
    );
  }
}

try {
  await executeQuery("SELECT * FROM users");
} catch (error) {
  if (error instanceof QueryError) {
    console.log("Query:", error.query);
    console.log("Original error:", error.originalError.message);
  }
}
```

---

## Authentication Errors

```javascript
class AuthenticationError extends Error {
  constructor(message, reason) {
    super(message);
    this.name = "AuthenticationError";
    this.reason = reason;
  }
}

class PasswordMismatchError extends AuthenticationError {
  constructor() {
    super("Invalid password", "password_mismatch");
    this.name = "PasswordMismatchError";
  }
}

class AccountLockedError extends AuthenticationError {
  constructor(unlockTime) {
    super("Account is locked", "account_locked");
    this.name = "AccountLockedError";
    this.unlockTime = unlockTime;
  }
}

class TokenExpiredError extends AuthenticationError {
  constructor(expiredAt) {
    super("Token has expired", "token_expired");
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  }
}

// Usage
function login(username, password) {
  const user = findUser(username);
  
  if (user.locked) {
    throw new AccountLockedError(user.unlockTime);
  }
  
  if (!verifyPassword(password, user.passwordHash)) {
    throw new PasswordMismatchError();
  }
  
  return generateToken(user);
}

try {
  login("john", "wrong");
} catch (error) {
  if (error instanceof AccountLockedError) {
    console.log(`Account locked until ${error.unlockTime}`);
  } else if (error instanceof PasswordMismatchError) {
    console.log("Invalid credentials");
  }
}
```

---

## Business Logic Errors

```javascript
class BusinessError extends Error {
  constructor(message, code) {
    super(message);
    this.name = "BusinessError";
    this.code = code;
  }
}

class InsufficientFundsError extends BusinessError {
  constructor(required, available) {
    super("Insufficient funds", "INSUFFICIENT_FUNDS");
    this.name = "InsufficientFundsError";
    this.required = required;
    this.available = available;
  }
}

class InvalidOperationError extends BusinessError {
  constructor(operation, reason) {
    super(`Invalid operation: ${operation}`, "INVALID_OPERATION");
    this.name = "InvalidOperationError";
    this.operation = operation;
    this.reason = reason;
  }
}

// Usage
class BankAccount {
  constructor(balance) {
    this.balance = balance;
  }
  
  withdraw(amount) {
    if (amount > this.balance) {
      throw new InsufficientFundsError(amount, this.balance);
    }
    this.balance -= amount;
    return this.balance;
  }
}

try {
  const account = new BankAccount(100);
  account.withdraw(150);
} catch (error) {
  if (error instanceof InsufficientFundsError) {
    console.log(`Need ${error.required}, but have ${error.available}`);
  }
}
```

---

## Error Factory Pattern

```javascript
class ErrorFactory {
  static createError(type, ...args) {
    switch (type) {
      case 'validation':
        return new ValidationError(...args);
      case 'http':
        return new HttpError(...args);
      case 'database':
        return new DatabaseError(...args);
      default:
        return new Error(...args);
    }
  }
}

// Usage
throw ErrorFactory.createError('validation', 'Invalid input', {
  email: 'Email required'
});
```

---

## Error with Stack Manipulation

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomError";
    
    // Maintains proper stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }
  }
}
```

---

## Async Custom Errors

```javascript
class AsyncError extends Error {
  constructor(message, operation) {
    super(message);
    this.name = "AsyncError";
    this.operation = operation;
  }
}

async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new AsyncError(
        `Failed to fetch from ${url}`,
        'fetch'
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsyncError) {
      console.log(`Async operation ${error.operation} failed`);
    }
    throw error;
  }
}
```

---

## Error Hierarchy Example

```javascript
// Base application error
class AppError extends Error {
  constructor(message, code) {
    super(message);
    this.name = "AppError";
    this.code = code;
    this.timestamp = new Date();
  }
}

// Domain-specific errors
class UserError extends AppError {
  constructor(message, userId) {
    super(message, "USER_ERROR");
    this.name = "UserError";
    this.userId = userId;
  }
}

class PaymentError extends AppError {
  constructor(message, transactionId) {
    super(message, "PAYMENT_ERROR");
    this.name = "PaymentError";
    this.transactionId = transactionId;
  }
}

class ProductError extends AppError {
  constructor(message, productId) {
    super(message, "PRODUCT_ERROR");
    this.name = "ProductError";
    this.productId = productId;
  }
}

// Usage
try {
  throw new UserError("User not found", 123);
} catch (error) {
  if (error instanceof UserError) {
    console.log(`User error for ID ${error.userId}`);
  } else if (error instanceof AppError) {
    console.log(`App error: ${error.code}`);
  }
}
```

---

## Best Practices

1. **Always extend Error**
   ```javascript
   class MyError extends Error {
     constructor(message) {
       super(message);
       this.name = "MyError";
     }
   }
   ```

2. **Set the name property**
   ```javascript
   this.name = "CustomError";  // For better debugging
   ```

3. **Add meaningful context**
   ```javascript
   class ApiError extends Error {
     constructor(message, endpoint, status) {
       super(message);
       this.name = "ApiError";
       this.endpoint = endpoint;
       this.status = status;
     }
   }
   ```

4. **Use inheritance for related errors**
   ```javascript
   class BaseError extends Error { }
   class SpecificError extends BaseError { }
   ```

5. **Provide helper methods**
   ```javascript
   class ValidationError extends Error {
     hasError(field) {
       return field in this.errors;
     }
     
     getErrors() {
       return this.errors;
     }
   }
   ```

---

## Common Patterns

### Error with Metadata
```javascript
class MetadataError extends Error {
  constructor(message, metadata = {}) {
    super(message);
    this.name = "MetadataError";
    this.metadata = metadata;
  }
}
```

### Recoverable vs Fatal Errors
```javascript
class RecoverableError extends Error {
  constructor(message) {
    super(message);
    this.name = "RecoverableError";
    this.recoverable = true;
  }
}

class FatalError extends Error {
  constructor(message) {
    super(message);
    this.name = "FatalError";
    this.recoverable = false;
  }
}
```

### Error with Suggestions
```javascript
class SuggestiveError extends Error {
  constructor(message, suggestion) {
    super(message);
    this.name = "SuggestiveError";
    this.suggestion = suggestion;
  }
}

throw new SuggestiveError(
  "File not found",
  "Check if the file path is correct"
);
```

---

## Key Takeaways

- **Extend Error** for all custom errors
- **Set `name` property** to error class name
- **Add relevant properties** for context
- **Use inheritance** for related error types
- **Call `super(message)`** in constructor
- **Check with `instanceof`** for type-specific handling
- **Provide helper methods** for common operations
- **Include timestamp** for logging
- **Store original error** when wrapping
- **Use specific errors** for different scenarios
- **Create error hierarchies** for complex applications
- **Document expected errors** in function signatures
