# try-catch-finally

Error handling mechanism to catch and handle exceptions gracefully in JavaScript.

---

## Basic Syntax

```javascript
try {
  // Code that might throw an error
} catch (error) {
  // Handle the error
} finally {
  // Always executes (optional)
}
```

---

## try-catch

Catches and handles errors without crashing the program.

```javascript
try {
  const result = riskyOperation();
  console.log(result);
} catch (error) {
  console.log("An error occurred:", error.message);
}

console.log("Program continues...");
```

### Without Error Handling

```javascript
// This crashes the program
const obj = null;
console.log(obj.property);  // TypeError: Cannot read property of null
console.log("This never runs");  // Never executed
```

### With Error Handling

```javascript
try {
  const obj = null;
  console.log(obj.property);
} catch (error) {
  console.log("Error caught:", error.message);
}
console.log("Program continues");  // Executes normally
```

---

## The Error Object

```javascript
try {
  throw new Error("Something went wrong");
} catch (error) {
  console.log(error.name);     // "Error"
  console.log(error.message);  // "Something went wrong"
  console.log(error.stack);    // Stack trace
}
```

### Error Properties

```javascript
catch (error) {
  console.log(error.name);      // Type of error
  console.log(error.message);   // Error description
  console.log(error.stack);     // Stack trace (debugging)
  console.log(error.toString()); // "Error: message"
}
```

---

## finally Block

Executes regardless of whether an error occurred.

```javascript
try {
  console.log("Trying...");
  throw new Error("Oops!");
} catch (error) {
  console.log("Caught:", error.message);
} finally {
  console.log("Finally always runs");
}

// Output:
// Trying...
// Caught: Oops!
// Finally always runs
```

### Cleanup Operations

```javascript
let file;
try {
  file = openFile("data.txt");
  processFile(file);
} catch (error) {
  console.log("Error processing file:", error.message);
} finally {
  // Always close the file
  if (file) {
    file.close();
  }
}
```

---

## Multiple Catches (Error Types)

JavaScript doesn't support multiple catch blocks like other languages, but you can check error types:

```javascript
try {
  // Some code
  JSON.parse("invalid json");
} catch (error) {
  if (error instanceof SyntaxError) {
    console.log("JSON syntax error:", error.message);
  } else if (error instanceof ReferenceError) {
    console.log("Reference error:", error.message);
  } else {
    console.log("Unknown error:", error.message);
  }
}
```

---

## Nested try-catch

```javascript
try {
  try {
    throw new Error("Inner error");
  } catch (innerError) {
    console.log("Inner catch:", innerError.message);
    throw new Error("Outer error");
  }
} catch (outerError) {
  console.log("Outer catch:", outerError.message);
}

// Output:
// Inner catch: Inner error
// Outer catch: Outer error
```

---

## Practical Examples

### API Call

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to fetch user:", error.message);
    return null;
  } finally {
    console.log("Fetch attempt completed");
  }
}
```

### JSON Parsing

```javascript
function parseJSON(jsonString) {
  try {
    return JSON.parse(jsonString);
  } catch (error) {
    console.error("Invalid JSON:", error.message);
    return null;
  }
}

const data = parseJSON('{"name": "John"}');  // Success
const invalid = parseJSON('{invalid}');       // Returns null
```

### Division by Zero Check

```javascript
function divide(a, b) {
  try {
    if (b === 0) {
      throw new Error("Division by zero");
    }
    return a / b;
  } catch (error) {
    console.error("Math error:", error.message);
    return NaN;
  }
}

console.log(divide(10, 2));  // 5
console.log(divide(10, 0));  // NaN (error caught)
```

---

## Return in try-catch-finally

### finally Overrides return

```javascript
function test1() {
  try {
    return "from try";
  } finally {
    return "from finally";  // This wins
  }
}

console.log(test1());  // "from finally"
```

### finally Doesn't Override

```javascript
function test2() {
  try {
    return "from try";
  } finally {
    console.log("Cleanup");
    // No return here
  }
}

console.log(test2());  
// Output:
// Cleanup
// "from try"
```

---

## Error Rethrowing

```javascript
function processData(data) {
  try {
    if (!data) {
      throw new Error("No data provided");
    }
    // Process data
  } catch (error) {
    console.error("Error in processData:", error.message);
    throw error;  // Rethrow for caller to handle
  }
}

try {
  processData(null);
} catch (error) {
  console.log("Caught in caller:", error.message);
}
```

---

## Optional Catch Binding (ES2019)

You can omit the error parameter if you don't need it.

```javascript
// Old way
try {
  JSON.parse(data);
} catch (error) {
  // Don't use error
  console.log("Parse failed");
}

// Modern way (ES2019+)
try {
  JSON.parse(data);
} catch {
  console.log("Parse failed");
}
```

---

## Common Patterns

### Fallback Values

```javascript
function getConfig() {
  try {
    return JSON.parse(localStorage.getItem('config'));
  } catch {
    return { theme: 'light', language: 'en' };  // Default config
  }
}
```

### Resource Management

```javascript
class Database {
  connect() {
    try {
      // Connection logic
      console.log("Connected to database");
      return this;
    } catch (error) {
      console.error("Connection failed:", error.message);
      throw error;
    } finally {
      console.log("Connection attempt logged");
    }
  }
  
  disconnect() {
    console.log("Disconnected from database");
  }
}

let db;
try {
  db = new Database().connect();
  // Use database
} catch (error) {
  console.error("Database error:", error.message);
} finally {
  if (db) {
    db.disconnect();
  }
}
```

### Graceful Degradation

```javascript
function enhancedFeature() {
  try {
    // Try advanced feature
    return useNewAPI();
  } catch {
    // Fallback to basic feature
    console.log("Using fallback");
    return useOldAPI();
  }
}
```

---

## Best Practices

1. **Catch specific errors**
   ```javascript
   try {
     JSON.parse(data);
   } catch (error) {
     if (error instanceof SyntaxError) {
       // Handle parse error
     } else {
       throw error;  // Rethrow unexpected errors
     }
   }
   ```

2. **Don't catch everything silently**
   ```javascript
   // ✗ Bad
   try {
     doSomething();
   } catch (error) {
     // Silent fail - bad!
   }
   
   // ✓ Good
   try {
     doSomething();
   } catch (error) {
     console.error("Error:", error);
     // Handle or rethrow
   }
   ```

3. **Use finally for cleanup**
   ```javascript
   try {
     openResource();
     useResource();
   } finally {
     closeResource();  // Always runs
   }
   ```

4. **Keep try blocks small**
   ```javascript
   // ✓ Better - only wrap risky code
   const data = prepareData();
   let parsed;
   try {
     parsed = JSON.parse(data);
   } catch (error) {
     parsed = {};
   }
   processData(parsed);
   ```

5. **Log errors properly**
   ```javascript
   catch (error) {
     console.error("Error details:", {
       name: error.name,
       message: error.message,
       stack: error.stack
     });
   }
   ```

---

## Common Pitfalls

### Empty Catch Blocks

```javascript
// ✗ Swallows errors
try {
  riskyOperation();
} catch (e) {}

// ✓ At minimum, log it
try {
  riskyOperation();
} catch (e) {
  console.error("Operation failed:", e);
}
```

### Too Broad try Blocks

```javascript
// ✗ Too much code in try
try {
  const a = getValue1();
  const b = getValue2();
  const c = getValue3();
  const result = process(a, b, c);
  return result;
} catch (error) {
  // Which operation failed?
}

// ✓ Wrap only what can fail
const a = getValue1();
const b = getValue2();
let c;
try {
  c = getValue3();  // Only this can throw
} catch (error) {
  c = defaultValue;
}
```

### Ignoring Error Types

```javascript
// ✗ Treats all errors the same
try {
  operation();
} catch (error) {
  showGenericError();
}

// ✓ Handle different errors appropriately
try {
  operation();
} catch (error) {
  if (error instanceof NetworkError) {
    retryOperation();
  } else if (error instanceof ValidationError) {
    showValidationMessage();
  } else {
    throw error;
  }
}
```

---

## Key Takeaways

- **try-catch** prevents program crashes from errors
- **catch** receives error object with `name`, `message`, `stack`
- **finally** always executes (useful for cleanup)
- **finally return** overrides try/catch return values
- **Rethrow errors** you can't handle
- **Keep try blocks minimal** - only wrap risky code
- **Don't catch silently** - always log or handle errors
- **Check error types** for specific handling
- **ES2019** allows optional catch binding
- **Use for**: API calls, parsing, file operations, external resources
