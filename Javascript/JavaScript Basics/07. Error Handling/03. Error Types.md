# Error Types

JavaScript provides built-in error types for different kinds of errors, and you can create custom ones.

---

## Built-in Error Types

### 1. Error (Generic)

The base error type. All other errors inherit from it.

```javascript
throw new Error("Something went wrong");

try {
  throw new Error("Generic error");
} catch (e) {
  console.log(e.name);     // "Error"
  console.log(e.message);  // "Generic error"
}
```

---

### 2. SyntaxError

Occurs when parsing invalid code.

```javascript
// Runtime SyntaxError
try {
  JSON.parse("{invalid json}");
} catch (e) {
  console.log(e instanceof SyntaxError);  // true
  console.log(e.message);  // Unexpected token i in JSON
}

// eval with syntax error
try {
  eval("function {");
} catch (e) {
  console.log(e instanceof SyntaxError);  // true
}
```

**When it occurs:**
- Invalid JSON parsing
- Invalid code in `eval()`
- Malformed regular expressions

---

### 3. ReferenceError

Accessing undefined variables or properties.

```javascript
try {
  console.log(nonExistentVariable);
} catch (e) {
  console.log(e instanceof ReferenceError);  // true
  console.log(e.message);  // nonExistentVariable is not defined
}

// Calling undefined function
try {
  undefinedFunction();
} catch (e) {
  console.log(e instanceof ReferenceError);  // true
}
```

**When it occurs:**
- Using undeclared variables
- Accessing variables before declaration (TDZ)

---

### 4. TypeError

Operations on wrong type of values.

```javascript
try {
  null.property;
} catch (e) {
  console.log(e instanceof TypeError);  // true
  console.log(e.message);  // Cannot read property of null
}

// Calling non-function
try {
  const num = 42;
  num();
} catch (e) {
  console.log(e instanceof TypeError);  // true
  console.log(e.message);  // num is not a function
}

// Wrong constructor usage
try {
  const arrow = () => {};
  new arrow();
} catch (e) {
  console.log(e instanceof TypeError);  // true
  console.log(e.message);  // arrow is not a constructor
}
```

**When it occurs:**
- Calling non-functions
- Accessing properties of null/undefined
- Using value as wrong type

---

### 5. RangeError

Value not in valid range.

```javascript
// Invalid array length
try {
  const arr = new Array(-1);
} catch (e) {
  console.log(e instanceof RangeError);  // true
  console.log(e.message);  // Invalid array length
}

// Stack overflow (recursive call)
function recursive() {
  recursive();
}

try {
  recursive();
} catch (e) {
  console.log(e instanceof RangeError);  // true
  console.log(e.message);  // Maximum call stack size exceeded
}

// toFixed with invalid precision
try {
  (123).toFixed(101);
} catch (e) {
  console.log(e instanceof RangeError);  // true
}
```

**When it occurs:**
- Array length out of range
- Stack overflow
- Number methods with invalid parameters

---

### 6. URIError

Invalid URI encoding/decoding.

```javascript
try {
  decodeURIComponent('%');
} catch (e) {
  console.log(e instanceof URIError);  // true
  console.log(e.message);  // URI malformed
}

try {
  decodeURI('%E0%A4%A');
} catch (e) {
  console.log(e instanceof URIError);  // true
}
```

**When it occurs:**
- Invalid `encodeURI()` or `decodeURI()` usage
- Malformed URI components

---

### 7. EvalError

(Rarely used) Related to `eval()` function.

```javascript
// Modern JavaScript rarely throws EvalError
// Included for completeness
```

---

## Error Hierarchy

```
Error (base)
  ├── SyntaxError
  ├── ReferenceError
  ├── TypeError
  ├── RangeError
  ├── URIError
  └── EvalError
```

All error types inherit from `Error`.

```javascript
console.log(new TypeError() instanceof Error);       // true
console.log(new RangeError() instanceof Error);      // true
console.log(new SyntaxError() instanceof Error);     // true
```

---

## Catching Specific Errors

```javascript
try {
  JSON.parse("{invalid}");
} catch (error) {
  if (error instanceof SyntaxError) {
    console.log("JSON syntax error:", error.message);
  } else if (error instanceof TypeError) {
    console.log("Type error:", error.message);
  } else {
    console.log("Other error:", error.message);
  }
}
```

### Multiple Error Types

```javascript
function processData(data) {
  try {
    if (!data) {
      throw new ReferenceError("Data is required");
    }
    
    if (typeof data !== 'object') {
      throw new TypeError("Data must be an object");
    }
    
    if (data.age < 0 || data.age > 150) {
      throw new RangeError("Age must be between 0 and 150");
    }
    
    return data;
  } catch (error) {
    if (error instanceof ReferenceError) {
      console.log("Missing data");
    } else if (error instanceof TypeError) {
      console.log("Wrong type");
    } else if (error instanceof RangeError) {
      console.log("Invalid range");
    }
    throw error;
  }
}
```

---

## Creating Custom Errors

### Basic Custom Error

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

try {
  throw new ValidationError("Invalid email format");
} catch (error) {
  console.log(error.name);     // "ValidationError"
  console.log(error.message);  // "Invalid email format"
  console.log(error instanceof ValidationError);  // true
  console.log(error instanceof Error);  // true
}
```

### Custom Error with Additional Properties

```javascript
class HttpError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.name = "HttpError";
    this.statusCode = statusCode;
  }
}

try {
  throw new HttpError("Not Found", 404);
} catch (error) {
  console.log(error.message);     // "Not Found"
  console.log(error.statusCode);  // 404
  console.log(error.name);        // "HttpError"
}
```

### Multiple Custom Errors

```javascript
class DatabaseError extends Error {
  constructor(message, query) {
    super(message);
    this.name = "DatabaseError";
    this.query = query;
  }
}

class NetworkError extends Error {
  constructor(message, url) {
    super(message);
    this.name = "NetworkError";
    this.url = url;
  }
}

class AuthenticationError extends Error {
  constructor(message) {
    super(message);
    this.name = "AuthenticationError";
  }
}

// Usage
try {
  throw new DatabaseError("Query failed", "SELECT * FROM users");
} catch (error) {
  if (error instanceof DatabaseError) {
    console.log("DB Error:", error.message);
    console.log("Query:", error.query);
  } else if (error instanceof NetworkError) {
    console.log("Network Error:", error.url);
  } else if (error instanceof AuthenticationError) {
    console.log("Auth Error:", error.message);
  }
}
```

---

## Error Properties

### Standard Properties

```javascript
const error = new Error("Test error");

console.log(error.name);      // "Error"
console.log(error.message);   // "Test error"
console.log(error.stack);     // Stack trace

// toString
console.log(error.toString());  // "Error: Test error"
```

### Custom Properties

```javascript
class AppError extends Error {
  constructor(message, code, details) {
    super(message);
    this.name = "AppError";
    this.code = code;
    this.details = details;
    this.timestamp = new Date();
  }
}

const error = new AppError("Operation failed", "OP_001", {
  userId: 123,
  action: "delete"
});

console.log(error.code);       // "OP_001"
console.log(error.details);    // { userId: 123, action: "delete" }
console.log(error.timestamp);  // Date object
```

---

## Practical Examples

### API Error Handling

```javascript
class ApiError extends Error {
  constructor(message, status, endpoint) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.endpoint = endpoint;
  }
}

async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new ApiError(
        `Failed to fetch user`,
        response.status,
        `/api/users/${id}`
      );
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof ApiError) {
      console.log(`API Error ${error.status}: ${error.message}`);
      console.log(`Endpoint: ${error.endpoint}`);
    } else {
      console.log("Network error:", error.message);
    }
  }
}
```

### Form Validation

```javascript
class ValidationError extends Error {
  constructor(field, message) {
    super(message);
    this.name = "ValidationError";
    this.field = field;
  }
}

function validateUser(user) {
  if (!user.email) {
    throw new ValidationError("email", "Email is required");
  }
  
  if (!user.email.includes("@")) {
    throw new ValidationError("email", "Invalid email format");
  }
  
  if (!user.password || user.password.length < 8) {
    throw new ValidationError("password", "Password must be at least 8 characters");
  }
  
  return true;
}

try {
  validateUser({ email: "invalid", password: "123" });
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`${error.field}: ${error.message}`);
  }
}
```

---

## Checking Error Types

### instanceof Check

```javascript
try {
  // Some code
} catch (error) {
  if (error instanceof TypeError) {
    console.log("Type error");
  } else if (error instanceof RangeError) {
    console.log("Range error");
  }
}
```

### name Property Check

```javascript
try {
  // Some code
} catch (error) {
  switch (error.name) {
    case "TypeError":
      console.log("Type error");
      break;
    case "RangeError":
      console.log("Range error");
      break;
    default:
      console.log("Unknown error");
  }
}
```

---

## Best Practices

1. **Use specific error types**
   ```javascript
   // ✓ Specific
   throw new TypeError("Expected string");
   throw new RangeError("Value out of bounds");
   
   // ✗ Too generic
   throw new Error("Something wrong");
   ```

2. **Create custom errors for app logic**
   ```javascript
   class NotFoundError extends Error {
     constructor(resource) {
       super(`${resource} not found`);
       this.name = "NotFoundError";
     }
   }
   ```

3. **Include relevant context**
   ```javascript
   class DatabaseError extends Error {
     constructor(message, query, params) {
       super(message);
       this.name = "DatabaseError";
       this.query = query;
       this.params = params;
     }
   }
   ```

4. **Check error types properly**
   ```javascript
   // ✓ Good
   if (error instanceof ValidationError) { }
   
   // ✗ String comparison is fragile
   if (error.name === "ValidationError") { }
   ```

---

## Key Takeaways

- **Error**: Generic base error
- **SyntaxError**: Invalid syntax (parsing, JSON)
- **ReferenceError**: Undefined variable access
- **TypeError**: Wrong type operations
- **RangeError**: Value out of range
- **URIError**: Invalid URI operations
- **All inherit from Error**
- **Use `instanceof`** to check error types
- **Create custom errors** by extending Error
- **Add context** with custom properties
- **Be specific** - use appropriate error type
- **Custom errors** should extend Error and set name
