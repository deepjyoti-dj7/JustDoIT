# Error Handling Best Practices

Guidelines and patterns for effective error handling in JavaScript applications.

---

## General Principles

### 1. Fail Fast

Catch errors early before they cascade.

```javascript
// ✓ Good - validate early
function processUser(user) {
  if (!user) {
    throw new Error("User is required");
  }
  if (!user.email) {
    throw new Error("Email is required");
  }
  
  // Process user
  return saveUser(user);
}

// ✗ Bad - errors occur deep in code
function processUser(user) {
  const data = prepareData();
  const validated = validate(data);
  // Error only caught here when user.email accessed
  return saveUser(user.email);
}
```

---

### 2. Be Specific

Use specific error types and messages.

```javascript
// ✗ Generic
throw new Error("Error");

// ✓ Specific
throw new ValidationError("Email must contain @ symbol", "email");
throw new TypeError("Expected string, got number");
throw new RangeError("Age must be between 0 and 150");
```

---

### 3. Provide Context

Include relevant information in errors.

```javascript
// ✗ Lacks context
throw new Error("Invalid value");

// ✓ With context
throw new Error(`Invalid email format: ${email}`);
throw new DatabaseError("Query failed", query, params);
throw new ApiError("Request failed", 404, "/api/users/123");
```

---

## Try-Catch Best Practices

### Keep try Blocks Small

```javascript
// ✗ Too much in try
try {
  const data = fetchData();
  const processed = processData(data);
  const validated = validateData(processed);
  const saved = saveData(validated);
  return saved;
} catch (error) {
  // Which step failed?
}

// ✓ Only wrap risky operations
const data = fetchData();
const processed = processData(data);

try {
  validateData(processed);  // Only this can throw
} catch (error) {
  console.error("Validation failed:", error.message);
}

saveData(processed);
```

---

### Don't Swallow Errors

```javascript
// ✗ Silent failure
try {
  riskyOperation();
} catch (error) {
  // Nothing - error lost!
}

// ✓ At minimum, log it
try {
  riskyOperation();
} catch (error) {
  console.error("Operation failed:", error);
  throw error;  // Or handle appropriately
}
```

---

### Catch Specific Errors

```javascript
// ✗ Catches everything
try {
  operation();
} catch (error) {
  // Treats all errors the same
  showError();
}

// ✓ Handle different errors appropriately
try {
  operation();
} catch (error) {
  if (error instanceof ValidationError) {
    showValidationMessage(error.errors);
  } else if (error instanceof NetworkError) {
    retryOperation();
  } else {
    // Unknown error - log and rethrow
    console.error("Unexpected error:", error);
    throw error;
  }
}
```

---

## Async Error Handling

### Always Handle Promise Rejections

```javascript
// ✗ Unhandled rejection
fetch("/api/data")
  .then(response => response.json())
  .then(data => console.log(data));

// ✓ With error handling
fetch("/api/data")
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error("Failed:", error));
```

---

### Use try-catch with async/await

```javascript
// ✗ Missing error handling
async function fetchData() {
  const response = await fetch("/api/data");
  return await response.json();
}

// ✓ With try-catch
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error("Fetch failed:", error.message);
    throw error;
  }
}
```

---

### Don't Forget await

```javascript
// ✗ Missing await - error not caught
async function fetchUser() {
  try {
    fetch("/api/user");  // Missing await!
  } catch (error) {
    // Never catches the error
  }
}

// ✓ With await
async function fetchUser() {
  try {
    await fetch("/api/user");
  } catch (error) {
    console.error("Error:", error);
  }
}
```

---

## Custom Errors

### Extend Error Properly

```javascript
// ✓ Proper custom error
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = "ValidationError";
    this.field = field;
    
    // Maintains stack trace
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ValidationError);
    }
  }
}
```

---

### Add Meaningful Properties

```javascript
class ApiError extends Error {
  constructor(message, status, endpoint) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.endpoint = endpoint;
    this.timestamp = new Date();
  }
  
  isClientError() {
    return this.status >= 400 && this.status < 500;
  }
  
  isServerError() {
    return this.status >= 500;
  }
}
```

---

## Validation Patterns

### Input Validation

```javascript
function createUser(data) {
  // Validate at entry point
  if (!data) {
    throw new ValidationError("User data is required");
  }
  
  if (!data.email) {
    throw new ValidationError("Email is required", "email");
  }
  
  if (!data.email.includes("@")) {
    throw new ValidationError("Invalid email format", "email");
  }
  
  if (data.age !== undefined && (data.age < 0 || data.age > 150)) {
    throw new RangeError("Age must be between 0 and 150");
  }
  
  return saveUser(data);
}
```

---

### Cumulative Validation

```javascript
function validateUser(user) {
  const errors = {};
  
  if (!user.email) {
    errors.email = "Email is required";
  } else if (!user.email.includes("@")) {
    errors.email = "Invalid email format";
  }
  
  if (!user.password || user.password.length < 8) {
    errors.password = "Password must be at least 8 characters";
  }
  
  if (user.age < 18) {
    errors.age = "Must be 18 or older";
  }
  
  if (Object.keys(errors).length > 0) {
    throw new ValidationError("Validation failed", errors);
  }
  
  return true;
}
```

---

## Logging Best Practices

### Log with Context

```javascript
try {
  processOrder(order);
} catch (error) {
  console.error("Order processing failed:", {
    orderId: order.id,
    error: error.message,
    stack: error.stack,
    timestamp: new Date()
  });
  throw error;
}
```

---

### Different Log Levels

```javascript
function processData(data) {
  try {
    validateData(data);
    return transformData(data);
  } catch (error) {
    if (error instanceof ValidationError) {
      console.warn("Validation issue:", error.message);  // Warning
      return defaultData;
    } else {
      console.error("Critical error:", error);  // Error
      throw error;
    }
  }
}
```

---

## Error Recovery

### Retry with Backoff

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return await response.json();
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;  // Give up
      }
      
      const delay = Math.min(1000 * 2 ** (attempt - 1), 10000);
      console.log(`Retry ${attempt}/${maxRetries} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

---

### Fallback Values

```javascript
function getConfigValue(key) {
  try {
    const config = JSON.parse(localStorage.getItem("config"));
    return config[key];
  } catch (error) {
    console.warn("Using default config:", error.message);
    return DEFAULT_CONFIG[key];
  }
}
```

---

### Graceful Degradation

```javascript
async function loadUserData(userId) {
  let userData = {};
  
  try {
    userData.profile = await fetchProfile(userId);
  } catch (error) {
    console.warn("Profile unavailable, using defaults");
    userData.profile = { name: "Guest" };
  }
  
  try {
    userData.settings = await fetchSettings(userId);
  } catch (error) {
    console.warn("Settings unavailable, using defaults");
    userData.settings = DEFAULT_SETTINGS;
  }
  
  return userData;
}
```

---

## Documentation

### Document Expected Errors

```javascript
/**
 * Fetches user by ID
 * @param {number} id - User ID
 * @returns {Promise<User>} User object
 * @throws {ValidationError} If ID is invalid
 * @throws {NotFoundError} If user doesn't exist
 * @throws {ApiError} If API request fails
 */
async function fetchUser(id) {
  if (!id || typeof id !== 'number') {
    throw new ValidationError("Valid user ID required");
  }
  
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (response.status === 404) {
      throw new NotFoundError("User");
    }
    
    if (!response.ok) {
      throw new ApiError("Fetch failed", response.status);
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof NotFoundError || error instanceof ApiError) {
      throw error;
    }
    throw new ApiError("Network error", 0);
  }
}
```

---

## Production Considerations

### Error Reporting

```javascript
class ErrorReporter {
  static report(error, context = {}) {
    // Log locally
    console.error("Error:", error.message, context);
    
    // Send to error tracking service (Sentry, etc.)
    if (process.env.NODE_ENV === 'production') {
      this.sendToErrorService({
        message: error.message,
        stack: error.stack,
        name: error.name,
        context,
        timestamp: new Date(),
        userAgent: navigator.userAgent
      });
    }
  }
  
  static sendToErrorService(data) {
    // Implementation for external service
    fetch("/api/errors", {
      method: "POST",
      body: JSON.stringify(data)
    }).catch(err => console.error("Failed to report error:", err));
  }
}

// Usage
try {
  riskyOperation();
} catch (error) {
  ErrorReporter.report(error, { userId: currentUser.id });
}
```

---

### User-Friendly Messages

```javascript
function getUserMessage(error) {
  if (error instanceof ValidationError) {
    return "Please check your input and try again.";
  } else if (error instanceof NetworkError) {
    return "Network connection failed. Please check your internet.";
  } else if (error instanceof AuthenticationError) {
    return "Please log in again.";
  } else {
    return "Something went wrong. Please try again later.";
  }
}

try {
  await processRequest();
} catch (error) {
  console.error("Internal error:", error);  // For developers
  showToUser(getUserMessage(error));  // For users
}
```

---

## Anti-Patterns to Avoid

### 1. Empty Catch Blocks
```javascript
// ✗ Never do this
try {
  operation();
} catch (e) {}
```

### 2. Catching Without Rethrowing
```javascript
// ✗ Loses error information
try {
  operation();
} catch (error) {
  console.log("Error occurred");
  // Should rethrow if can't handle
}
```

### 3. Using Errors for Control Flow
```javascript
// ✗ Don't use errors for expected cases
try {
  const user = findUser(id);
} catch (error) {
  // User not found - expected case
}

// ✓ Return null/undefined for expected cases
const user = findUser(id);
if (!user) {
  // Handle not found
}
```

### 4. Too Generic Error Messages
```javascript
// ✗ Not helpful
throw new Error("Invalid");

// ✓ Descriptive
throw new ValidationError("Email must contain @ symbol", "email");
```

---

## Checklist

- ✓ Use specific error types
- ✓ Provide descriptive messages
- ✓ Include relevant context
- ✓ Keep try blocks minimal
- ✓ Always handle async errors
- ✓ Log errors with context
- ✓ Re-throw if can't handle
- ✓ Validate input early
- ✓ Implement retry logic where appropriate
- ✓ Use fallbacks for non-critical failures
- ✓ Document expected errors
- ✓ Report errors in production
- ✓ Show user-friendly messages
- ✗ Never swallow errors silently
- ✗ Don't use errors for control flow

---

## Key Takeaways

- **Fail fast** - catch errors early
- **Be specific** - use appropriate error types
- **Provide context** - include relevant details
- **Handle all async errors** - use .catch() or try-catch
- **Log appropriately** - different levels for different errors
- **Don't swallow errors** - always log or rethrow
- **Validate early** - check inputs at entry points
- **Retry transient failures** - with exponential backoff
- **Provide fallbacks** - for non-critical operations
- **Create custom errors** - for domain-specific issues
- **Document errors** - what errors functions can throw
- **Report in production** - use error tracking services
- **User-friendly messages** - don't expose internal errors
