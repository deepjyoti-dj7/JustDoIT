# Async Error Handling

Handling errors in asynchronous JavaScript code using Promises, async/await, and callbacks.

---

## Callback Error Handling

Traditional Node.js style error-first callbacks.

```javascript
function readFile(path, callback) {
  // Simulated async operation
  setTimeout(() => {
    if (!path) {
      callback(new Error("Path is required"), null);
    } else {
      callback(null, "file contents");
    }
  }, 100);
}

// Usage
readFile("file.txt", (error, data) => {
  if (error) {
    console.error("Error:", error.message);
    return;
  }
  console.log("Data:", data);
});
```

---

## Promise Error Handling

### Using .catch()

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(new Error("Failed to fetch"));
    }, 100);
  });
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.error("Error:", error.message));
```

### Chaining with Error Propagation

```javascript
fetch("/api/users")
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Failed:", error.message));
```

### Multiple .catch() Handlers

```javascript
Promise.reject(new Error("Initial error"))
  .catch(error => {
    console.log("First catch:", error.message);
    throw new Error("Second error");
  })
  .catch(error => {
    console.log("Second catch:", error.message);
  });
```

---

## async/await Error Handling

### Basic try-catch

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error fetching user:", error.message);
    throw error;
  }
}

// Usage
(async () => {
  try {
    const user = await fetchUser(123);
    console.log(user);
  } catch (error) {
    console.error("Failed:", error.message);
  }
})();
```

### Multiple async Operations

```javascript
async function loadData() {
  try {
    const user = await fetchUser(1);
    const posts = await fetchPosts(user.id);
    const comments = await fetchComments(posts[0].id);
    
    return { user, posts, comments };
  } catch (error) {
    console.error("Error loading data:", error.message);
    throw error;
  }
}
```

### Specific Error Handling

```javascript
async function processData() {
  try {
    const data = await fetchData();
    return processIt(data);
  } catch (error) {
    if (error instanceof TypeError) {
      console.error("Invalid data format");
    } else if (error instanceof NetworkError) {
      console.error("Network failed");
    } else {
      console.error("Unknown error:", error.message);
    }
  }
}
```

---

## Promise.all Error Handling

```javascript
async function fetchMultiple() {
  try {
    const results = await Promise.all([
      fetch("/api/users"),
      fetch("/api/posts"),
      fetch("/api/comments")
    ]);
    
    return results;
  } catch (error) {
    // Fails if ANY promise rejects
    console.error("One of the requests failed:", error.message);
  }
}
```

### Promise.allSettled (Better for Multiple)

```javascript
async function fetchMultiple() {
  const results = await Promise.allSettled([
    fetch("/api/users"),
    fetch("/api/posts"),
    fetch("/api/comments")
  ]);
  
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`Request ${index} succeeded:`, result.value);
    } else {
      console.error(`Request ${index} failed:`, result.reason.message);
    }
  });
}
```

---

## Custom Async Errors

```javascript
class ApiError extends Error {
  constructor(message, status, endpoint) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.endpoint = endpoint;
  }
}

async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new ApiError(
        "Failed to fetch user",
        response.status,
        `/api/users/${id}`
      );
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof ApiError) {
      console.error(`API Error ${error.status}: ${error.message}`);
    } else {
      console.error("Network error:", error.message);
    }
    throw error;
  }
}
```

---

## Error Recovery Patterns

### Retry Logic

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return await response.json();
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      console.log(`Attempt ${i + 1} failed:`, error.message);
      
      if (i === maxRetries - 1) {
        throw error;  // Last attempt, give up
      }
      
      // Wait before retry (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 2 ** i * 1000));
    }
  }
}

// Usage
try {
  const data = await fetchWithRetry("/api/data");
  console.log(data);
} catch (error) {
  console.error("All retries failed:", error.message);
}
```

### Fallback Values

```javascript
async function fetchUserWithFallback(id) {
  try {
    return await fetchUser(id);
  } catch (error) {
    console.warn("Using cached data:", error.message);
    return getCachedUser(id);
  }
}
```

### Circuit Breaker Pattern

```javascript
class CircuitBreaker {
  constructor(maxFailures = 3, resetTimeout = 60000) {
    this.failures = 0;
    this.maxFailures = maxFailures;
    this.resetTimeout = resetTimeout;
    this.state = 'CLOSED';  // CLOSED, OPEN, HALF_OPEN
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      throw new Error('Circuit breaker is OPEN');
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failures++;
    if (this.failures >= this.maxFailures) {
      this.state = 'OPEN';
      setTimeout(() => {
        this.state = 'HALF_OPEN';
        this.failures = 0;
      }, this.resetTimeout);
    }
  }
}

// Usage
const breaker = new CircuitBreaker(3, 60000);

async function fetchData() {
  try {
    return await breaker.execute(() => fetch("/api/data"));
  } catch (error) {
    console.error("Circuit breaker error:", error.message);
  }
}
```

---

## Timeout Handling

```javascript
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("Operation timed out")), ms);
  });
  
  return Promise.race([promise, timeout]);
}

// Usage
async function fetchWithTimeout(url) {
  try {
    const response = await withTimeout(fetch(url), 5000);
    return await response.json();
  } catch (error) {
    if (error.message === "Operation timed out") {
      console.error("Request timed out");
    } else {
      console.error("Request failed:", error.message);
    }
  }
}
```

---

## Parallel Error Handling

### Promise.all with Individual Handlers

```javascript
async function fetchAllWithHandling() {
  const requests = [
    fetch("/api/users").catch(err => ({ error: err, data: null })),
    fetch("/api/posts").catch(err => ({ error: err, data: null })),
    fetch("/api/comments").catch(err => ({ error: err, data: null }))
  ];
  
  const results = await Promise.all(requests);
  
  results.forEach((result, index) => {
    if (result.error) {
      console.error(`Request ${index} failed:`, result.error.message);
    } else {
      console.log(`Request ${index} succeeded`);
    }
  });
}
```

---

## Practical Examples

### API Client with Error Handling

```javascript
class ApiClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  async request(endpoint, options = {}) {
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, options);
      
      if (!response.ok) {
        throw new ApiError(
          `Request failed`,
          response.status,
          endpoint
        );
      }
      
      return await response.json();
    } catch (error) {
      this.handleError(error);
      throw error;
    }
  }
  
  handleError(error) {
    if (error instanceof ApiError) {
      if (error.status === 401) {
        console.log("Unauthorized - redirect to login");
      } else if (error.status === 404) {
        console.log("Resource not found");
      } else if (error.status >= 500) {
        console.log("Server error - retry later");
      }
    } else {
      console.error("Network error:", error.message);
    }
  }
  
  async get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }
  
  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }
}

// Usage
const api = new ApiClient("https://api.example.com");

try {
  const users = await api.get("/users");
  console.log(users);
} catch (error) {
  console.error("Failed to fetch users");
}
```

### Async Queue with Error Handling

```javascript
class AsyncQueue {
  constructor(concurrency = 1) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(fn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { fn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}

// Usage
const queue = new AsyncQueue(2);

async function fetchUser(id) {
  return queue.add(async () => {
    try {
      const response = await fetch(`/api/users/${id}`);
      return await response.json();
    } catch (error) {
      console.error(`Failed to fetch user ${id}:`, error.message);
      throw error;
    }
  });
}
```

---

## Best Practices

1. **Always handle Promise rejections**
   ```javascript
   // ✓ Good
   promise.catch(error => console.error(error));
   
   // ✗ Unhandled rejection (can crash Node.js)
   promise.then(data => console.log(data));
   ```

2. **Use try-catch with async/await**
   ```javascript
   async function fetchData() {
     try {
       const data = await fetch("/api/data");
       return data;
     } catch (error) {
       console.error("Error:", error);
     }
   }
   ```

3. **Re-throw after logging**
   ```javascript
   async function process() {
     try {
       return await doSomething();
     } catch (error) {
       console.error("Error in process:", error);
       throw error;  // Let caller handle it
     }
   }
   ```

4. **Use Promise.allSettled for parallel**
   ```javascript
   // Better than Promise.all when you want all results
   const results = await Promise.allSettled(promises);
   ```

5. **Implement timeouts**
   ```javascript
   const data = await withTimeout(fetchData(), 5000);
   ```

---

## Common Pitfalls

### Forgotten await
```javascript
// ✗ Error not caught
async function bad() {
  try {
    fetch("/api/data");  // Missing await!
  } catch (error) {
    // Never catches
  }
}

// ✓ Correct
async function good() {
  try {
    await fetch("/api/data");
  } catch (error) {
    console.error(error);
  }
}
```

### Silent Failures
```javascript
// ✗ Swallows errors
async function bad() {
  try {
    await operation();
  } catch (error) {
    // Silent!
  }
}

// ✓ At least log
async function good() {
  try {
    await operation();
  } catch (error) {
    console.error("Operation failed:", error);
    throw error;
  }
}
```

---

## Key Takeaways

- **Use try-catch with async/await**
- **Use .catch() with Promises**
- **Always handle rejections** (unhandled rejections can crash apps)
- **Promise.all fails fast** - one rejection fails all
- **Promise.allSettled** waits for all (better for parallel)
- **Implement retry logic** for transient failures
- **Add timeouts** to prevent hanging
- **Create custom async errors** with context
- **Re-throw errors** after logging for caller handling
- **Use circuit breakers** for failing external services
- **Don't forget await** in try-catch blocks
