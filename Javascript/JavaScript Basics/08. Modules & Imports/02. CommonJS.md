# CommonJS

The module system created for Node.js, using `require()` and `module.exports`.

---

## Basic Syntax

### Exporting

```javascript
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

// Export multiple
module.exports = {
  add,
  subtract
};
```

### Importing

```javascript
// app.js
const math = require('./math');

console.log(math.add(5, 3));      // 8
console.log(math.subtract(5, 3)); // 2
```

---

## module.exports vs exports

### module.exports (Recommended)

```javascript
// user.js
module.exports = {
  name: "John",
  age: 30,
  greet() {
    return `Hello, ${this.name}`;
  }
};
```

### exports (Shorthand)

```javascript
// user.js
exports.name = "John";
exports.age = 30;
exports.greet = function() {
  return `Hello, ${this.name}`;
};

// Both work the same when importing
const user = require('./user');
```

### Important Difference

```javascript
// ✗ This doesn't work
exports = {
  name: "John",
  age: 30
};
// exports is just a reference to module.exports
// Reassigning it breaks the reference

// ✓ This works
module.exports = {
  name: "John",
  age: 30
};
```

---

## Export Patterns

### Single Function Export

```javascript
// logger.js
module.exports = function log(message) {
  console.log(`[LOG] ${message}`);
};

// app.js
const log = require('./logger');
log("Hello World");  // [LOG] Hello World
```

### Single Class Export

```javascript
// User.js
class User {
  constructor(name) {
    this.name = name;
  }
  
  greet() {
    return `Hello, ${this.name}`;
  }
}

module.exports = User;

// app.js
const User = require('./User');
const user = new User("John");
console.log(user.greet());
```

### Multiple Exports

```javascript
// utils.js
const PI = 3.14159;

function circleArea(radius) {
  return PI * radius * radius;
}

function circleCircumference(radius) {
  return 2 * PI * radius;
}

module.exports = {
  PI,
  circleArea,
  circleCircumference
};

// app.js
const utils = require('./utils');
console.log(utils.circleArea(5));

// Or destructure
const { PI, circleArea } = require('./utils');
console.log(circleArea(5));
```

---

## Importing Patterns

### Entire Module

```javascript
const module = require('./module');
module.function1();
module.function2();
```

### Destructuring

```javascript
const { function1, function2 } = require('./module');
function1();
function2();
```

### Renaming

```javascript
const { function1: fn1, function2: fn2 } = require('./module');
fn1();
fn2();
```

### Combining

```javascript
const module = require('./module');
const { specificFunction } = require('./module');

module.function1();
specificFunction();
```

---

## Module Caching

Modules are cached after first load.

```javascript
// counter.js
let count = 0;

module.exports = {
  increment() {
    return ++count;
  },
  getCount() {
    return count;
  }
};

// app.js
const counter1 = require('./counter');
const counter2 = require('./counter');

counter1.increment();
counter1.increment();

console.log(counter2.getCount());  // 2 (same instance!)
console.log(counter1 === counter2); // true
```

### Cache Location

```javascript
// View the cache
console.log(require.cache);

// Clear cache (rarely needed)
delete require.cache[require.resolve('./module')];
```

---

## Module Paths

### Relative Paths

```javascript
require('./module');        // Same directory
require('../module');       // Parent directory
require('./lib/module');    // Subdirectory
```

### Absolute Paths

```javascript
require('/home/user/module');  // Absolute path (not recommended)
```

### Node Modules

```javascript
require('express');         // From node_modules
require('lodash');          // From node_modules
```

### Built-in Modules

```javascript
const fs = require('fs');
const http = require('http');
const path = require('path');
```

---

## Module Resolution

Node.js looks for modules in this order:

1. **Core modules** (fs, http, etc.)
2. **Exact file path** (./module.js)
3. **File without extension** (./module → ./module.js)
4. **Directory with index.js** (./module → ./module/index.js)
5. **node_modules** (up the directory tree)

```javascript
// Looking for 'myModule'
require('myModule');

// Checks:
// ./node_modules/myModule
// ../node_modules/myModule
// ../../node_modules/myModule
// ... up to root
```

---

## Circular Dependencies

CommonJS handles circular dependencies, but be careful.

```javascript
// a.js
const b = require('./b');
console.log('In a, b.done =', b.done);

exports.done = true;

// b.js
const a = require('./a');
console.log('In b, a.done =', a.done);

exports.done = true;

// app.js
require('./a');

// Output:
// In b, a.done = undefined
// In a, b.done = true
```

**Why?** Module `a` is not fully loaded when `b` requires it.

---

## Practical Examples

### Configuration Module

```javascript
// config.js
const config = {
  database: {
    host: 'localhost',
    port: 5432,
    name: 'mydb'
  },
  server: {
    port: 3000
  }
};

module.exports = config;

// app.js
const config = require('./config');
console.log(config.database.host);
```

### Utility Functions

```javascript
// stringUtils.js
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function reverse(str) {
  return str.split('').reverse().join('');
}

function truncate(str, length) {
  return str.length > length ? str.slice(0, length) + '...' : str;
}

module.exports = {
  capitalize,
  reverse,
  truncate
};

// app.js
const { capitalize, truncate } = require('./stringUtils');

console.log(capitalize("hello"));      // "Hello"
console.log(truncate("Hello World", 5)); // "Hello..."
```

### Database Connection

```javascript
// database.js
const mysql = require('mysql');

const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb'
});

connection.connect();

module.exports = connection;

// app.js
const db = require('./database');

db.query('SELECT * FROM users', (err, results) => {
  if (err) throw err;
  console.log(results);
});
```

### Class with Static Methods

```javascript
// Logger.js
class Logger {
  static info(message) {
    console.log(`[INFO] ${new Date().toISOString()} - ${message}`);
  }
  
  static error(message) {
    console.error(`[ERROR] ${new Date().toISOString()} - ${message}`);
  }
  
  static warn(message) {
    console.warn(`[WARN] ${new Date().toISOString()} - ${message}`);
  }
}

module.exports = Logger;

// app.js
const Logger = require('./Logger');

Logger.info("Application started");
Logger.error("Something went wrong");
```

---

## Advanced Patterns

### Factory Pattern

```javascript
// userFactory.js
function createUser(name, email) {
  return {
    name,
    email,
    createdAt: new Date(),
    greet() {
      return `Hello, I'm ${this.name}`;
    }
  };
}

module.exports = createUser;

// app.js
const createUser = require('./userFactory');

const user = createUser("John", "john@example.com");
console.log(user.greet());
```

### Singleton Pattern

```javascript
// database.js
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }
    
    this.connection = null;
    Database.instance = this;
  }
  
  connect() {
    this.connection = "Connected";
  }
}

module.exports = new Database();  // Export instance

// app.js
const db1 = require('./database');
const db2 = require('./database');

console.log(db1 === db2);  // true (same instance)
```

### Revealing Module Pattern

```javascript
// calculator.js
module.exports = (function() {
  // Private variables
  let history = [];
  
  // Private function
  function log(operation) {
    history.push(operation);
  }
  
  // Public API
  return {
    add(a, b) {
      const result = a + b;
      log(`${a} + ${b} = ${result}`);
      return result;
    },
    
    subtract(a, b) {
      const result = a - b;
      log(`${a} - ${b} = ${result}`);
      return result;
    },
    
    getHistory() {
      return [...history];
    }
  };
})();

// app.js
const calc = require('./calculator');

calc.add(5, 3);
calc.subtract(10, 4);
console.log(calc.getHistory());
```

---

## require.resolve()

Get the absolute path of a module.

```javascript
const modulePath = require.resolve('./module');
console.log(modulePath);  // /absolute/path/to/module.js

// Check if module exists
try {
  require.resolve('some-module');
  console.log('Module exists');
} catch (e) {
  console.log('Module not found');
}
```

---

## Conditional Require

```javascript
let config;

if (process.env.NODE_ENV === 'production') {
  config = require('./config.prod');
} else {
  config = require('./config.dev');
}

module.exports = config;
```

---

## Best Practices

1. **Use module.exports for clarity**
   ```javascript
   module.exports = { ... };  // Clear
   ```

2. **One module per file**
   ```javascript
   // user.js - only user-related code
   ```

3. **Keep modules focused**
   ```javascript
   // stringUtils.js - only string utilities
   ```

4. **Use descriptive names**
   ```javascript
   const userService = require('./userService');  // Good
   const us = require('./userService');  // Bad
   ```

5. **Avoid circular dependencies**
   ```javascript
   // Refactor to remove circular requires
   ```

6. **Cache appropriately**
   ```javascript
   // Let Node.js cache by default
   // Only clear cache if necessary
   ```

---

## Common Pitfalls

### Reassigning exports

```javascript
// ✗ Doesn't work
exports = { name: "John" };

// ✓ Works
module.exports = { name: "John" };
```

### Mutating Cached Modules

```javascript
// counter.js
module.exports = { count: 0 };

// app.js
const counter = require('./counter');
counter.count++;  // Mutates the cached module!
```

### Missing ./ for Relative Paths

```javascript
// ✗ Looks in node_modules
require('module');

// ✓ Relative path
require('./module');
```

---

## Key Takeaways

- **CommonJS** is Node.js's module system
- **`require()`** imports modules
- **`module.exports`** exports from modules
- **`exports`** is a shorthand (don't reassign it)
- **Modules are cached** after first load
- **Synchronous loading** - blocks until loaded
- **Supports circular dependencies** (partially)
- **Dynamic imports** - can require conditionally
- **Use relative paths** for local modules (`./`)
- **Still widely used** in Node.js ecosystem
- **ES6 modules** are the modern alternative
