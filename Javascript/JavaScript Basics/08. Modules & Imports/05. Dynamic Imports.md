# Dynamic Imports

Load modules dynamically at runtime using `import()` as a function.

---

## What are Dynamic Imports?

Unlike static imports (at the top of the file), dynamic imports allow loading modules on-demand at runtime.

### Static Import (Traditional)

```javascript
// Must be at top level
import { func } from './module.js';

// ✗ Can't do this
if (condition) {
  import { func } from './module.js';  // Error!
}
```

### Dynamic Import (import() function)

```javascript
// Can be anywhere
async function loadModule() {
  const module = await import('./module.js');
  module.func();
}

// Or in conditionals
if (condition) {
  const module = await import('./module.js');  // Works!
}
```

---

## Basic Syntax

### Promise-based

```javascript
import('./module.js')
  .then(module => {
    module.doSomething();
  })
  .catch(err => {
    console.error('Failed to load module:', err);
  });
```

### async/await

```javascript
async function loadModule() {
  try {
    const module = await import('./module.js');
    module.doSomething();
  } catch (error) {
    console.error('Failed to load module:', error);
  }
}
```

---

## Importing Different Types

### Default Export

```javascript
// module.js
export default function greet() {
  return "Hello!";
}

// app.js
const module = await import('./module.js');
const greet = module.default;  // Access via .default
console.log(greet());
```

### Named Exports

```javascript
// module.js
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}

// app.js
const module = await import('./module.js');
console.log(module.PI);
console.log(module.add(2, 3));

// Or destructure
const { PI, add } = await import('./module.js');
```

### Mixed Exports

```javascript
// module.js
export const VERSION = '1.0';
export default class MyClass {}

// app.js
const module = await import('./module.js');
const MyClass = module.default;
const VERSION = module.VERSION;

// Or
const { default: MyClass, VERSION } = await import('./module.js');
```

---

## Use Cases

### 1. Lazy Loading / Code Splitting

Load heavy modules only when needed.

```javascript
// Load chart library only when user clicks button
button.addEventListener('click', async () => {
  const { Chart } = await import('./chart-library.js');
  const chart = new Chart(data);
  chart.render();
});
```

### 2. Conditional Loading

Load different modules based on conditions.

```javascript
async function loadModule(environment) {
  let module;
  
  if (environment === 'production') {
    module = await import('./config.prod.js');
  } else {
    module = await import('./config.dev.js');
  }
  
  return module.default;
}

const config = await loadModule(process.env.NODE_ENV);
```

### 3. Feature Detection

```javascript
async function loadPolyfill() {
  if (!('fetch' in window)) {
    await import('./fetch-polyfill.js');
  }
}

await loadPolyfill();
// Now fetch is available
```

### 4. User Interaction

```javascript
// Load module on user action
async function showModal() {
  const { Modal } = await import('./Modal.js');
  const modal = new Modal();
  modal.show();
}

document.querySelector('#show-modal').addEventListener('click', showModal);
```

---

## Practical Examples

### Route-based Loading

```javascript
// Router with dynamic imports
const routes = {
  '/': () => import('./pages/Home.js'),
  '/about': () => import('./pages/About.js'),
  '/contact': () => import('./pages/Contact.js')
};

async function navigate(path) {
  const loadPage = routes[path];
  if (!loadPage) {
    console.error('Route not found');
    return;
  }
  
  const module = await loadPage();
  const Page = module.default;
  const page = new Page();
  page.render();
}

// Navigate to different routes
navigate('/about');
```

### Dynamic Language Loading

```javascript
async function loadLanguage(lang) {
  const translations = await import(`./i18n/${lang}.js`);
  return translations.default;
}

// Load translations dynamically
const userLang = navigator.language.split('-')[0];
const messages = await loadLanguage(userLang);

console.log(messages.welcome);  // Translated message
```

### Feature Modules

```javascript
class App {
  async enableDarkMode() {
    const { DarkMode } = await import('./features/DarkMode.js');
    this.darkMode = new DarkMode();
    this.darkMode.enable();
  }
  
  async enableNotifications() {
    const { Notifications } = await import('./features/Notifications.js');
    this.notifications = new Notifications();
    this.notifications.setup();
  }
}

const app = new App();

// Load features on demand
if (userPreferences.darkMode) {
  await app.enableDarkMode();
}

if (userPreferences.notifications) {
  await app.enableNotifications();
}
```

---

## Error Handling

### Basic Error Handling

```javascript
try {
  const module = await import('./module.js');
  module.doSomething();
} catch (error) {
  console.error('Failed to load module:', error);
  // Show user-friendly error or fallback
}
```

### Fallback Module

```javascript
async function loadWithFallback() {
  try {
    return await import('./advanced-feature.js');
  } catch (error) {
    console.warn('Loading fallback:', error);
    return await import('./basic-feature.js');
  }
}

const module = await loadWithFallback();
```

### Retry Logic

```javascript
async function importWithRetry(modulePath, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await import(modulePath);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      console.log(`Retry ${i + 1}/${maxRetries}`);
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

const module = await importWithRetry('./module.js');
```

---

## Performance Optimization

### Preloading

```javascript
// Preload module but don't execute yet
const modulePromise = import('./module.js');

// Later, when needed
const module = await modulePromise;
module.doSomething();
```

### Prefetching

```javascript
// Prefetch on hover (likely to be needed soon)
link.addEventListener('mouseenter', () => {
  import('./page.js');  // Start loading, don't wait
}, { once: true });

// Use when clicked
link.addEventListener('click', async () => {
  const module = await import('./page.js');  // Already loaded or loading
  module.renderPage();
});
```

### Parallel Loading

```javascript
// Load multiple modules in parallel
async function loadModules() {
  const [moduleA, moduleB, moduleC] = await Promise.all([
    import('./moduleA.js'),
    import('./moduleB.js'),
    import('./moduleC.js')
  ]);
  
  return { moduleA, moduleB, moduleC };
}

const modules = await loadModules();
```

---

## Dynamic Import Patterns

### Import with Variable Path

```javascript
async function loadTheme(themeName) {
  const theme = await import(`./themes/${themeName}.js`);
  return theme.default;
}

const theme = await loadTheme('dark');
theme.apply();
```

### Import from User Input

```javascript
async function loadPlugin(pluginName) {
  // Validate input first!
  const allowedPlugins = ['plugin1', 'plugin2', 'plugin3'];
  
  if (!allowedPlugins.includes(pluginName)) {
    throw new Error('Invalid plugin');
  }
  
  const plugin = await import(`./plugins/${pluginName}.js`);
  return plugin.default;
}
```

### Conditional Polyfills

```javascript
async function loadPolyfills() {
  const promises = [];
  
  if (!('IntersectionObserver' in window)) {
    promises.push(import('./polyfills/intersection-observer.js'));
  }
  
  if (!('fetch' in window)) {
    promises.push(import('./polyfills/fetch.js'));
  }
  
  await Promise.all(promises);
}

await loadPolyfills();
```

---

## Module Caching

Dynamic imports are cached like static imports.

```javascript
// First import - loads from network
const module1 = await import('./module.js');

// Second import - uses cached version
const module2 = await import('./module.js');

console.log(module1 === module2);  // true (same instance)
```

---

## Webpack Code Splitting

Dynamic imports create separate bundles in Webpack.

```javascript
// This creates a separate chunk
const module = await import('./heavy-module.js');

// With magic comments
const module = await import(
  /* webpackChunkName: "my-chunk" */
  /* webpackPrefetch: true */
  './module.js'
);
```

---

## Best Practices

### 1. Use for Large Dependencies

```javascript
// ✓ Good - load heavy library only when needed
button.addEventListener('click', async () => {
  const { createChart } = await import('./chart-library.js');
  createChart(data);
});

// ✗ Bad - loads heavy library on page load
import { createChart } from './chart-library.js';
```

### 2. Handle Errors Properly

```javascript
// ✓ Good - handles errors
try {
  const module = await import('./module.js');
  module.doSomething();
} catch (error) {
  console.error('Module load failed:', error);
  showErrorMessage();
}

// ✗ Bad - unhandled error
const module = await import('./module.js');
```

### 3. Validate Dynamic Paths

```javascript
// ✓ Good - validated input
const allowed = ['en', 'es', 'fr'];
if (allowed.includes(lang)) {
  await import(`./i18n/${lang}.js`);
}

// ✗ Bad - arbitrary file access
await import(`./i18n/${userInput}.js`);
```

### 4. Consider Loading States

```javascript
// ✓ Good - shows loading state
setLoading(true);
try {
  const module = await import('./module.js');
  module.render();
} finally {
  setLoading(false);
}
```

---

## Browser Support

Modern browsers support dynamic imports.

```javascript
// Check support
if (typeof import === 'function') {
  // Dynamic imports supported
  const module = await import('./module.js');
} else {
  // Fallback
  console.warn('Dynamic imports not supported');
}
```

---

## Node.js Usage

Works in Node.js (ES modules mode).

```javascript
// In ES module (.mjs or "type": "module")
async function loadConfig() {
  const config = await import('./config.js');
  return config.default;
}

// Dynamic import in CommonJS
async function loadESModule() {
  const module = await import('./es-module.mjs');
  return module;
}
```

---

## Common Pitfalls

### Forgetting .default

```javascript
// module.js
export default function greet() {}

// ✗ Wrong
const greet = await import('./module.js');
greet();  // Error!

// ✓ Correct
const module = await import('./module.js');
module.default();

// Or
const { default: greet } = await import('./module.js');
greet();
```

### Not Handling Promises

```javascript
// ✗ Wrong - import() returns a promise
const module = import('./module.js');
module.doSomething();  // Error!

// ✓ Correct
const module = await import('./module.js');
module.doSomething();
```

---

## Key Takeaways

- **Dynamic imports** use `import()` as a function
- **Returns Promise** that resolves to module object
- **Can be used anywhere** - not just top level
- **Enables code splitting** - creates separate bundles
- **Lazy loading** - load only when needed
- **Conditional loading** - based on runtime conditions
- **Default export** accessed via `.default`
- **Named exports** accessed directly from module object
- **Modules are cached** like static imports
- **Better performance** - smaller initial bundles
- **Handle errors** with try-catch or .catch()
- **Validate paths** when using variables
- **Show loading states** for better UX
