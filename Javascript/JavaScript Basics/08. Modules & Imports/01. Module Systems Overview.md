# Module Systems Overview

JavaScript has evolved through several module systems to organize and share code across files.

---

## Why Modules?

### Problems Without Modules

```javascript
// All in global scope
var userName = "John";
var userId = 123;

function getUser() {
  return { name: userName, id: userId };
}

// Risk of conflicts
var userName = "Jane";  // Overwrites!
```

**Issues:**
- Global namespace pollution
- No encapsulation
- Dependency management is manual
- No clear API boundaries

---

### Benefits of Modules

- **Encapsulation** - Private implementation details
- **Reusability** - Share code across projects
- **Maintainability** - Organized, modular code
- **Dependency Management** - Clear dependencies
- **Namespace** - Avoid naming conflicts

---

## Evolution of JavaScript Modules

### 1. IIFE Pattern (Pre-modules)

```javascript
// Immediately Invoked Function Expression
var myModule = (function() {
  // Private
  var privateVar = "secret";
  
  function privateFunction() {
    return privateVar;
  }
  
  // Public API
  return {
    publicMethod: function() {
      return privateFunction();
    }
  };
})();

myModule.publicMethod();  // Works
myModule.privateVar;       // undefined
```

---

### 2. CommonJS (2009)

Used in Node.js.

```javascript
// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = { add, subtract };

// app.js
const math = require('./math');
console.log(math.add(2, 3));  // 5
```

**Characteristics:**
- Synchronous loading
- Server-side (Node.js)
- `require()` and `module.exports`
- Loaded at runtime

---

### 3. AMD (Asynchronous Module Definition)

Used in browsers (RequireJS).

```javascript
// math.js
define(['dependency'], function(dependency) {
  return {
    add: function(a, b) {
      return a + b;
    }
  };
});

// app.js
require(['math'], function(math) {
  console.log(math.add(2, 3));
});
```

**Characteristics:**
- Asynchronous loading
- Browser-focused
- Complex syntax
- Less popular now

---

### 4. UMD (Universal Module Definition)

Works in both CommonJS and AMD.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['dependency'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('dependency'));
  } else {
    // Browser globals
    root.MyModule = factory(root.Dependency);
  }
}(typeof self !== 'undefined' ? self : this, function (dependency) {
  // Module code
  return {
    doSomething: function() {}
  };
}));
```

**Characteristics:**
- Works everywhere
- Complex boilerplate
- Mainly for library authors

---

### 5. ES6 Modules (2015) - Modern Standard

```javascript
// math.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// app.js
import { add, subtract } from './math.js';
console.log(add(2, 3));  // 5
```

**Characteristics:**
- Native JavaScript
- Static analysis
- Tree-shaking support
- Works in browsers and Node.js (with support)
- `import` and `export` keywords

---

## Comparison Table

| Feature | CommonJS | AMD | ES6 Modules |
|---------|----------|-----|-------------|
| **Syntax** | `require()`/`module.exports` | `define()`/`require()` | `import`/`export` |
| **Loading** | Synchronous | Asynchronous | Can be both |
| **Environment** | Node.js | Browser | Universal |
| **Static Analysis** | No | No | Yes |
| **Tree Shaking** | No | No | Yes |
| **Year** | 2009 | 2011 | 2015 |
| **Status** | Still used | Declining | Standard |

---

## CommonJS Deep Dive

### Basic Usage

```javascript
// user.js
const name = "John";
const age = 30;

function greet() {
  return `Hello, ${name}`;
}

module.exports = { name, age, greet };

// app.js
const user = require('./user');
console.log(user.greet());  // "Hello, John"
```

### Single Export

```javascript
// logger.js
function log(message) {
  console.log(`[LOG] ${message}`);
}

module.exports = log;

// app.js
const log = require('./logger');
log("Hello");  // [LOG] Hello
```

### Caching

```javascript
// counter.js
let count = 0;
module.exports = {
  increment: () => ++count,
  getCount: () => count
};

// app.js
const counter1 = require('./counter');
const counter2 = require('./counter');

counter1.increment();
console.log(counter2.getCount());  // 1 (same instance!)
```

---

## ES6 Modules Deep Dive

### Named Exports

```javascript
// math.js
export const PI = 3.14159;
export function add(a, b) {
  return a + b;
}
export class Calculator {
  multiply(a, b) {
    return a * b;
  }
}

// app.js
import { PI, add, Calculator } from './math.js';
```

### Default Export

```javascript
// logger.js
export default function log(message) {
  console.log(message);
}

// app.js
import log from './logger.js';
log("Hello");
```

### Mixed Exports

```javascript
// utils.js
export const VERSION = '1.0.0';
export function helper() {}
export default class Utils {}

// app.js
import Utils, { VERSION, helper } from './utils.js';
```

---

## Module Loading Differences

### CommonJS (Runtime)

```javascript
// Dynamic - decided at runtime
const moduleName = './module';
const myModule = require(moduleName);  // Works

if (condition) {
  const optionalModule = require('./optional');  // Works
}
```

### ES6 Modules (Static)

```javascript
// Static - must be at top level
import { func } from './module.js';  // Must be at top

// ✗ These don't work
if (condition) {
  import { func } from './module.js';  // Error!
}

const moduleName = './module.js';
import { func } from moduleName;  // Error!

// ✓ Use dynamic import for runtime loading
if (condition) {
  const module = await import('./module.js');  // Works
}
```

---

## Browser Support

### ES6 Modules in Browser

```html
<!-- type="module" required -->
<script type="module">
  import { add } from './math.js';
  console.log(add(2, 3));
</script>

<!-- Or external file -->
<script type="module" src="app.js"></script>
```

**Features:**
- Automatic strict mode
- Deferred by default
- Own scope (not global)
- CORS restrictions apply

---

### Module vs Regular Script

```html
<!-- Regular script -->
<script src="app.js"></script>
<!-- Global scope, immediate execution -->

<!-- Module script -->
<script type="module" src="app.js"></script>
<!-- Module scope, deferred execution -->
```

---

## Node.js Module Support

### CommonJS (Default)

```javascript
// package.json not needed for .js files
// user.js
module.exports = { name: "John" };

// app.js
const user = require('./user');
```

### ES6 Modules in Node.js

**Option 1: .mjs extension**
```javascript
// math.mjs
export const add = (a, b) => a + b;

// app.mjs
import { add } from './math.mjs';
```

**Option 2: package.json type**
```json
{
  "type": "module"
}
```

```javascript
// Now .js files are ES6 modules
// math.js
export const add = (a, b) => a + b;

// app.js
import { add } from './math.js';
```

---

## Choosing a Module System

### Use CommonJS When:
- Working in Node.js (legacy projects)
- Need synchronous loading
- Simple server-side scripts

### Use ES6 Modules When:
- Modern JavaScript projects
- Want tree-shaking
- Browser and Node.js compatibility
- Building with bundlers (Webpack, Rollup)
- **Recommended for new projects**

---

## Migration Path

### From CommonJS to ES6

```javascript
// Before (CommonJS)
const { add } = require('./math');
module.exports = { result: add(2, 3) };

// After (ES6)
import { add } from './math.js';
export const result = add(2, 3);
```

### Interoperability

```javascript
// ES6 importing CommonJS
import module from './commonjs-module';  // Default import
import * as module from './commonjs-module';  // Namespace import

// CommonJS importing ES6 (Node.js)
const module = await import('./es6-module.mjs');
```

---

## Best Practices

1. **Use ES6 modules for new projects**
   ```javascript
   import { func } from './module.js';
   ```

2. **One module per file**
   ```javascript
   // user.js - only user-related code
   // logger.js - only logging code
   ```

3. **Clear naming**
   ```javascript
   import { getUserById } from './users.js';  // Clear
   import { get } from './u.js';  // Unclear
   ```

4. **Export at bottom (optional convention)**
   ```javascript
   const func1 = () => {};
   const func2 = () => {};
   
   export { func1, func2 };
   ```

5. **Use named exports for multiple exports**
   ```javascript
   export const PI = 3.14;
   export function add() {}
   ```

---

## Key Takeaways

- **IIFE**: Pre-module pattern for encapsulation
- **CommonJS**: Node.js standard, synchronous, `require()`/`module.exports`
- **AMD**: Browser async loading, less common now
- **UMD**: Universal compatibility, complex
- **ES6 Modules**: Modern standard, static, `import`/`export`
- **ES6 is the future** - use for new projects
- **Static analysis** enables tree-shaking in ES6
- **CommonJS** loads at runtime, ES6 at parse time
- **Browser support** for ES6 modules with `type="module"`
- **Node.js** supports both (ES6 with .mjs or package.json config)
- **Choose ES6 modules** for modern JavaScript development
