# Module Patterns

Design patterns for organizing and structuring JavaScript modules for better code organization and reusability.

---

## 1. Revealing Module Pattern

Expose only public API, keep implementation private.

```javascript
// counter.js
const CounterModule = (function() {
  // Private variables
  let count = 0;
  const maxCount = 100;
  
  // Private functions
  function validateCount(newCount) {
    return newCount >= 0 && newCount <= maxCount;
  }
  
  function log(message) {
    console.log(`[Counter] ${message}`);
  }
  
  // Public API
  return {
    increment() {
      if (count < maxCount) {
        count++;
        log(`Incremented to ${count}`);
      }
      return count;
    },
    
    decrement() {
      if (count > 0) {
        count--;
        log(`Decremented to ${count}`);
      }
      return count;
    },
    
    getCount() {
      return count;
    },
    
    reset() {
      count = 0;
      log('Reset to 0');
    }
  };
})();

// Usage
CounterModule.increment();  // 1
CounterModule.increment();  // 2
console.log(CounterModule.getCount());  // 2
// CounterModule.count is undefined (private)
```

---

## 2. Singleton Pattern

Ensure only one instance exists.

```javascript
// database.js
const Database = (function() {
  let instance;
  
  function createInstance() {
    const connection = {
      host: 'localhost',
      port: 5432,
      connect() {
        console.log('Connected to database');
      },
      query(sql) {
        console.log(`Executing: ${sql}`);
      }
    };
    return connection;
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

// Usage
const db1 = Database.getInstance();
const db2 = Database.getInstance();

console.log(db1 === db2);  // true (same instance)
```

### ES6 Singleton

```javascript
// database.js
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }
    
    this.connection = null;
    Database.instance = this;
  }
  
  connect() {
    this.connection = 'Connected';
    console.log('Database connected');
  }
}

export default new Database();  // Export instance

// app.js
import db from './database.js';
db.connect();
```

---

## 3. Factory Pattern

Create objects without specifying exact class.

```javascript
// userFactory.js
export function createUser(type, name) {
  const baseUser = {
    name,
    createdAt: new Date()
  };
  
  switch (type) {
    case 'admin':
      return {
        ...baseUser,
        role: 'admin',
        permissions: ['read', 'write', 'delete'],
        manageUsers() {
          console.log(`${this.name} managing users`);
        }
      };
      
    case 'moderator':
      return {
        ...baseUser,
        role: 'moderator',
        permissions: ['read', 'write'],
        moderate() {
          console.log(`${this.name} moderating content`);
        }
      };
      
    case 'user':
    default:
      return {
        ...baseUser,
        role: 'user',
        permissions: ['read'],
        view() {
          console.log(`${this.name} viewing content`);
        }
      };
  }
}

// Usage
import { createUser } from './userFactory.js';

const admin = createUser('admin', 'Alice');
const user = createUser('user', 'Bob');

admin.manageUsers();
user.view();
```

---

## 4. Namespace Pattern

Avoid global namespace pollution.

```javascript
// app.js
const MyApp = {
  utils: {
    string: {
      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      },
      reverse(str) {
        return str.split('').reverse().join('');
      }
    },
    
    array: {
      unique(arr) {
        return [...new Set(arr)];
      },
      flatten(arr) {
        return arr.flat(Infinity);
      }
    }
  },
  
  services: {
    api: {
      baseURL: 'https://api.example.com',
      fetch(endpoint) {
        return fetch(`${this.baseURL}${endpoint}`);
      }
    }
  }
};

// Usage
MyApp.utils.string.capitalize('hello');
MyApp.utils.array.unique([1, 2, 2, 3]);
MyApp.services.api.fetch('/users');
```

### ES6 Namespace

```javascript
// utils/index.js
export * as string from './string.js';
export * as array from './array.js';
export * as object from './object.js';

// app.js
import * as utils from './utils/index.js';

utils.string.capitalize('hello');
utils.array.unique([1, 2, 3]);
```

---

## 5. Module Augmentation

Extend existing modules.

```javascript
// base.js
export const math = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};

// extended.js
import { math } from './base.js';

// Augment the module
math.multiply = function(a, b) {
  return a * b;
};

math.divide = function(a, b) {
  return a / b;
};

export { math };

// app.js
import { math } from './extended.js';

console.log(math.add(5, 3));      // 8
console.log(math.multiply(5, 3));  // 15
```

---

## 6. Dependency Injection Pattern

Pass dependencies rather than hard-coding them.

```javascript
// emailService.js
export class EmailService {
  constructor(config) {
    this.apiKey = config.apiKey;
    this.from = config.from;
  }
  
  send(to, subject, body) {
    console.log(`Sending email to ${to}`);
    // Send email using this.apiKey
  }
}

// userService.js
export class UserService {
  constructor(emailService) {
    this.emailService = emailService;  // Injected dependency
  }
  
  async registerUser(userData) {
    // Create user...
    
    // Use injected email service
    this.emailService.send(
      userData.email,
      'Welcome!',
      'Thanks for registering'
    );
  }
}

// app.js
import { EmailService } from './emailService.js';
import { UserService } from './userService.js';

const emailService = new EmailService({
  apiKey: 'xyz',
  from: 'noreply@example.com'
});

const userService = new UserService(emailService);
userService.registerUser({ email: 'user@example.com' });
```

---

## 7. Observer Pattern (Pub/Sub)

Subscribe to and publish events.

```javascript
// eventBus.js
class EventBus {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  off(event, callback) {
    if (!this.events[event]) return;
    
    this.events[event] = this.events[event].filter(
      cb => cb !== callback
    );
  }
  
  emit(event, data) {
    if (!this.events[event]) return;
    
    this.events[event].forEach(callback => {
      callback(data);
    });
  }
}

export default new EventBus();

// userModule.js
import eventBus from './eventBus.js';

export function registerUser(userData) {
  // Register user...
  eventBus.emit('user:registered', userData);
}

// emailModule.js
import eventBus from './eventBus.js';

eventBus.on('user:registered', (userData) => {
  console.log(`Sending welcome email to ${userData.email}`);
});

// app.js
import { registerUser } from './userModule.js';
import './emailModule.js';  // Subscribe to events

registerUser({ email: 'user@example.com' });
// Logs: "Sending welcome email to user@example.com"
```

---

## 8. Facade Pattern

Simplified interface to complex subsystems.

```javascript
// Complex subsystems
class CPU {
  freeze() { console.log('CPU frozen'); }
  jump(position) { console.log(`Jumping to ${position}`); }
  execute() { console.log('Executing'); }
}

class Memory {
  load(position, data) {
    console.log(`Loading ${data} at ${position}`);
  }
}

class HardDrive {
  read(sector, size) {
    console.log(`Reading ${size} bytes from sector ${sector}`);
    return 'boot data';
  }
}

// Facade
export class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }
  
  start() {
    this.cpu.freeze();
    const bootData = this.hardDrive.read(0, 1024);
    this.memory.load(0, bootData);
    this.cpu.jump(0);
    this.cpu.execute();
  }
}

// app.js
import { ComputerFacade } from './computer.js';

const computer = new ComputerFacade();
computer.start();  // Simple interface to complex process
```

---

## 9. Strategy Pattern

Encapsulate algorithms and make them interchangeable.

```javascript
// strategies/sortStrategies.js
export const bubbleSort = {
  sort(arr) {
    console.log('Using bubble sort');
    // Implementation
    return arr.sort();
  }
};

export const quickSort = {
  sort(arr) {
    console.log('Using quick sort');
    // Implementation
    return arr.sort();
  }
};

export const mergeSort = {
  sort(arr) {
    console.log('Using merge sort');
    // Implementation
    return arr.sort();
  }
};

// sorter.js
export class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }
  
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  
  sort(arr) {
    return this.strategy.sort(arr);
  }
}

// app.js
import { Sorter } from './sorter.js';
import { bubbleSort, quickSort } from './strategies/sortStrategies.js';

const sorter = new Sorter(bubbleSort);
sorter.sort([3, 1, 4, 1, 5]);

// Change strategy
sorter.setStrategy(quickSort);
sorter.sort([3, 1, 4, 1, 5]);
```

---

## 10. Barrel Pattern (Index Exports)

Centralize exports from multiple modules.

```javascript
// components/Button.js
export class Button { }

// components/Input.js
export class Input { }

// components/Modal.js
export class Modal { }

// components/index.js (Barrel)
export { Button } from './Button.js';
export { Input } from './Input.js';
export { Modal } from './Modal.js';

// app.js
// Instead of multiple imports:
// import { Button } from './components/Button.js';
// import { Input } from './components/Input.js';

// Single import from barrel:
import { Button, Input, Modal } from './components/index.js';
```

---

## 11. Plugin Pattern

Extend functionality with plugins.

```javascript
// core.js
export class App {
  constructor() {
    this.plugins = [];
  }
  
  use(plugin) {
    this.plugins.push(plugin);
    plugin.install(this);
    return this;
  }
  
  run() {
    console.log('App running with plugins:', this.plugins.length);
  }
}

// plugins/logger.js
export const LoggerPlugin = {
  install(app) {
    app.log = function(message) {
      console.log(`[LOG] ${message}`);
    };
  }
};

// plugins/router.js
export const RouterPlugin = {
  install(app) {
    app.router = {
      navigate(path) {
        console.log(`Navigating to ${path}`);
      }
    };
  }
};

// app.js
import { App } from './core.js';
import { LoggerPlugin } from './plugins/logger.js';
import { RouterPlugin } from './plugins/router.js';

const app = new App();
app.use(LoggerPlugin);
app.use(RouterPlugin);

app.log('Hello');           // From LoggerPlugin
app.router.navigate('/home'); // From RouterPlugin
app.run();
```

---

## 12. Mixin Pattern

Add functionality to objects/classes.

```javascript
// mixins.js
export const TimestampMixin = {
  getTimestamp() {
    return this.createdAt;
  },
  updateTimestamp() {
    this.updatedAt = new Date();
  }
};

export const ValidationMixin = {
  validate() {
    return this.errors.length === 0;
  },
  addError(error) {
    this.errors.push(error);
  }
};

// user.js
import { TimestampMixin, ValidationMixin } from './mixins.js';

class User {
  constructor(name) {
    this.name = name;
    this.createdAt = new Date();
    this.updatedAt = null;
    this.errors = [];
  }
}

// Apply mixins
Object.assign(User.prototype, TimestampMixin, ValidationMixin);

export default User;

// app.js
import User from './user.js';

const user = new User('John');
console.log(user.getTimestamp());  // From TimestampMixin
user.updateTimestamp();            // From TimestampMixin
user.addError('Invalid email');    // From ValidationMixin
console.log(user.validate());      // false
```

---

## Best Practices

1. **Use ES6 modules for new projects**
2. **Keep modules focused** - single responsibility
3. **Avoid circular dependencies**
4. **Use barrel exports** for better organization
5. **Document module APIs**
6. **Dependency injection** for testability
7. **Keep modules small and composable**

---

## Key Takeaways

- **Revealing Module**: Expose public API, hide implementation
- **Singleton**: One instance shared across app
- **Factory**: Create objects dynamically
- **Namespace**: Organize code, avoid global pollution
- **Dependency Injection**: Pass dependencies for flexibility
- **Observer/Pub-Sub**: Event-driven communication
- **Facade**: Simplify complex interfaces
- **Strategy**: Interchangeable algorithms
- **Barrel**: Centralize exports
- **Plugin**: Extend core functionality
- **Mixin**: Compose functionality
- **Choose pattern** based on use case
