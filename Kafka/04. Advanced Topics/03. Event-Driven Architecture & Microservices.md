# 03. Event-Driven Architecture & Microservices

## Event-Driven Architecture (EDA)

### What is EDA?

**Event-Driven Architecture** is a software design pattern where components communicate through events.

**Key Concepts:**
- **Event**: A significant change in state
- **Event Producer**: Publishes events
- **Event Consumer**: Reacts to events
- **Event Bus**: Kafka (or other message broker)

**Example Events:**
- User registered
- Order placed
- Payment completed
- Inventory updated

---

## Traditional vs Event-Driven

### Traditional Request-Response

```
Service A â†’ HTTP Call â†’ Service B
          â† Response  â†

Tight coupling, synchronous
```

### Event-Driven

```
Service A â†’ Event â†’ Kafka â†’ Service B
                      â””â†’ Service C
                      â””â†’ Service D

Loose coupling, asynchronous
```

**Benefits:**
âœ… Decoupling
âœ… Scalability
âœ… Resilience
âœ… Flexibility
âœ… Audit trail

---

## Event Types

### 1. Domain Events

Business-significant events.

```javascript
{
  "eventType": "OrderPlaced",
  "orderId": "12345",
  "userId": "user123",
  "amount": 99.99,
  "timestamp": "2024-12-30T10:30:00Z"
}
```

### 2. Integration Events

Events for inter-service communication.

```javascript
{
  "eventType": "PaymentCompleted",
  "paymentId": "pay123",
  "orderId": "12345",
  "status": "SUCCESS"
}
```

### 3. System Events

Internal system events (logs, metrics).

```javascript
{
  "eventType": "ServiceStarted",
  "service": "order-service",
  "timestamp": "2024-12-30T10:00:00Z"
}
```

---

## Microservices with Kafka

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Kafka Event Bus                      â”‚
â”‚  orders | payments | inventory | notifications | users â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘                â†‘                â†‘                â†‘
     â”‚                â”‚                â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order  â”‚  â”‚Paymentâ”‚  â”‚Inventoryâ”‚ â”‚Email   â”‚
â”‚Serviceâ”‚  â”‚Serviceâ”‚  â”‚Serviceâ”‚  â”‚Service â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## E-Commerce Example

### Services

1. **Order Service**: Create orders
2. **Payment Service**: Process payments
3. **Inventory Service**: Manage stock
4. **Notification Service**: Send emails/SMS

### Event Flow

```
1. User places order
   â†’ Order Service produces "OrderCreated" event

2. Payment Service consumes "OrderCreated"
   â†’ Processes payment
   â†’ Produces "PaymentCompleted" event

3. Inventory Service consumes "PaymentCompleted"
   â†’ Reserves stock
   â†’ Produces "InventoryReserved" event

4. Notification Service consumes "OrderCreated"
   â†’ Sends confirmation email
```

---

## Event Sourcing

### What is Event Sourcing?

Storing all state changes as a sequence of events instead of current state.

**Traditional:**
```
Database: { orderId: 123, status: "SHIPPED" }
```

**Event Sourcing:**
```
Events:
1. OrderCreated
2. PaymentReceived
3. OrderShipped

Current state = replay all events
```

### Benefits

âœ… Complete audit trail
âœ… Time travel (rebuild state at any point)
âœ… Event replay
âœ… No data loss

### Drawbacks

âŒ Complex queries
âŒ Storage overhead
âŒ Learning curve

---

## CQRS (Command Query Responsibility Segregation)

### What is CQRS?

Separate models for reading and writing data.

**Architecture:**
```
Command Side (Write):
  API â†’ Command Handler â†’ Event Store â†’ Kafka

Query Side (Read):
  Kafka â†’ Event Processor â†’ Read Database â†’ Query API
```

### Example

**Write Model:**
```java
public class OrderCommandHandler {
    public void createOrder(CreateOrderCommand cmd) {
        // Validate
        // Save event
        eventStore.save(new OrderCreatedEvent(...));
        // Publish to Kafka
        kafka.send("orders", event);
    }
}
```

**Read Model:**
```java
@KafkaListener(topics = "orders")
public void updateReadModel(OrderCreatedEvent event) {
    // Update materialized view
    orderRepository.save(new OrderView(event));
}
```

---

## Saga Pattern

### What is Saga?

A sequence of local transactions coordinated to achieve a business goal.

### Choreography-Based Saga

Services coordinate via events.

```
1. Order Service: Create order â†’ "OrderCreated"
2. Payment Service: Process payment â†’ "PaymentCompleted"
3. Inventory Service: Reserve stock â†’ "StockReserved"
4. Shipping Service: Ship order â†’ "OrderShipped"

If any fails â†’ Compensating events
```

**Compensating Events:**
```
Payment fails â†’ "PaymentFailed"
â†’ Order Service cancels order
â†’ Inventory Service releases stock
```

### Orchestration-Based Saga

Central orchestrator coordinates.

```
Saga Orchestrator:
  1. Call Order Service
  2. Call Payment Service
  3. Call Inventory Service
  4. If failure â†’ Rollback
```

---

## Outbox Pattern

### Problem

Ensure database write and event publish are atomic.

### Solution

1. Write to database and outbox table in same transaction
2. Separate process reads outbox and publishes to Kafka
3. Delete from outbox after successful publish

**Example:**

```java
@Transactional
public void createOrder(Order order) {
    // 1. Save order
    orderRepository.save(order);
    
    // 2. Save to outbox
    outboxRepository.save(new OutboxEvent(
        "OrderCreated",
        order.getId(),
        toJson(order)
    ));
}

// Separate scheduler
@Scheduled(fixedDelay = 1000)
public void publishOutboxEvents() {
    List<OutboxEvent> events = outboxRepository.findPending();
    
    for (OutboxEvent event : events) {
        kafka.send(event.getTopic(), event.getPayload());
        outboxRepository.delete(event);
    }
}
```

---

## Best Practices

### Event Design

âœ… Use past tense names (OrderCreated, not CreateOrder)
âœ… Include event ID and timestamp
âœ… Make events immutable
âœ… Keep events small and focused
âœ… Version events

```javascript
{
  "eventId": "evt-123",
  "eventType": "OrderCreated",
  "eventVersion": "v1",
  "timestamp": "2024-12-30T10:30:00Z",
  "data": { ... }
}
```

### Microservices

âœ… One topic per event type
âœ… Idempotent consumers
âœ… Use dead letter queues
âœ… Monitor consumer lag
âœ… Implement circuit breakers

### Data Consistency

âœ… Use Saga pattern for distributed transactions
âœ… Implement compensating transactions
âœ… Use outbox pattern for atomicity
âœ… Accept eventual consistency

---

## Summary

**Event-Driven Architecture:**
- Components communicate via events
- Loose coupling, scalability
- Kafka as event bus

**Patterns:**
- **Event Sourcing**: Store all state changes
- **CQRS**: Separate read/write models
- **Saga**: Distributed transactions
- **Outbox**: Atomic DB + Kafka writes

**Benefits:**
- Decoupling
- Scalability
- Resilience
- Audit trail

---

## Interview Questions & Answers

### Q1: What is Event-Driven Architecture?
**A:** EDA is a design pattern where components communicate asynchronously through events. Producers publish events to an event bus (like Kafka), and consumers react to events independently, enabling loose coupling and scalability.

### Q2: What are the benefits of using Kafka in microservices?
**A:**
- **Decoupling**: Services don't call each other directly
- **Scalability**: Each service scales independently
- **Resilience**: Service failures don't cascade
- **Asynchronous**: Non-blocking communication
- **Event replay**: Can reprocess historical events

### Q3: What is Event Sourcing?
**A:** Event Sourcing stores all state changes as a sequence of events instead of just the current state. The current state is derived by replaying all events. Provides complete audit trail and enables time travel.

### Q4: What is CQRS?
**A:** Command Query Responsibility Segregation separates read and write models:
- **Command (Write)**: Handles state changes, publishes events
- **Query (Read)**: Optimized for reads, built from events

Allows independent scaling and optimization of reads vs writes.

### Q5: What is the Saga pattern?
**A:** Saga is a pattern for managing distributed transactions across microservices. It breaks a transaction into a sequence of local transactions, each publishing an event. If one fails, compensating transactions rollback previous steps.

Two types: Choreography (event-driven) and Orchestration (central coordinator).

### Q6: What is the Outbox pattern?
**A:** Outbox pattern ensures atomic database write and event publish:
1. Write to DB and outbox table in same transaction
2. Separate process reads outbox and publishes to Kafka
3. Delete from outbox after successful publish

Prevents lost events or inconsistency.

### Q7: What is choreography vs orchestration in Saga?
**A:**
- **Choreography**: Services coordinate via events (decentralized, each service knows next step)
- **Orchestration**: Central orchestrator directs services (centralized, orchestrator knows full workflow)

Choreography = loose coupling, Orchestration = easier to manage complex workflows.

### Q8: How do you handle failures in event-driven systems?
**A:**
- **Retry logic**: Retry failed messages
- **Dead Letter Queue**: Move failed messages after retries
- **Compensating transactions**: Rollback via reverse events
- **Idempotent processing**: Handle duplicates safely
- **Circuit breakers**: Prevent cascading failures

### Q9: What is eventual consistency?
**A:** In distributed systems, data may be temporarily inconsistent but eventually becomes consistent. Trade-off for availability and partition tolerance (CAP theorem).

Example: Order service creates order, inventory service updates stock later (not immediate).

### Q10: How do you version events?
**A:**
- Include `eventVersion` field
- Use different topics for major changes
- Maintain backward compatibility
- Support multiple versions simultaneously

```json
{"eventType": "OrderCreated", "eventVersion": "v2", ...}
```

### Q11: What is the difference between event and message?
**A:**
- **Event**: Notification of something that happened (past tense, e.g., OrderCreated)
- **Message**: Command or request to do something (imperative, e.g., CreateOrder)

Events are facts, messages are instructions.

### Q12: How do you ensure idempotent event processing?
**A:**
1. Track processed event IDs in database
2. Check if event already processed before handling
3. Use unique message keys
4. Design operations to be naturally idempotent (e.g., set status vs increment counter)

### Q13: What is the strangler pattern for migration?
**A:** Gradually migrate from monolith to microservices by:
1. Route new features to microservices
2. Gradually move existing features
3. Keep monolith running during transition
4. Eventually "strangle" the monolith

Kafka helps by enabling dual writes during transition.

### Q14: How do you handle event ordering in microservices?
**A:**
- Use partition keys (same key = same partition = order preserved)
- Single consumer per partition
- Sequence numbers in events
- Accept that global ordering is hard in distributed systems

### Q15: What is Change Data Capture (CDC)?
**A:** CDC captures database changes (inserts, updates, deletes) and publishes them as events to Kafka. Tools like Debezium enable this.

Use case: Keep read models in sync, replicate data, trigger downstream processing.

**End of Advanced Topics! Kafka content complete!** ğŸ‰