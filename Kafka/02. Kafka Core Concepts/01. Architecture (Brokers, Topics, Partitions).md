# 01. Architecture (Brokers, Topics, Partitions)

## Kafka Architecture Overview

Kafka is a distributed system with several key components working together:

```
┌─────────────────────────────────────────────────────────┐
│                   Kafka Cluster                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │ Broker 0 │  │ Broker 1 │  │ Broker 2 │              │
│  │          │  │          │  │          │              │
│  │ Topic A  │  │ Topic A  │  │ Topic B  │              │
│  │ Part 0   │  │ Part 1   │  │ Part 0   │              │
│  └──────────┘  └──────────┘  └──────────┘              │
│                                                         │
│            ┌──────────────────┐                        │
│            │ ZooKeeper/KRaft  │                        │
│            │   (Metadata)     │                        │
│            └──────────────────┘                        │
└─────────────────────────────────────────────────────────┘
       ↑                                      ↓
   Producers                              Consumers
```

---

## 1. Kafka Broker

### What is a Broker?

A **broker** is a Kafka server that:
- Stores topic data (messages)
- Handles read/write requests
- Manages partitions
- Participates in replication

### Key Characteristics

✅ **Unique ID**: Each broker has unique broker.id (e.g., 0, 1, 2)
✅ **Stateless**: Brokers don't track consumer state
✅ **Horizontal Scaling**: Add more brokers to scale
✅ **Load Balancing**: Partitions distributed across brokers

### Broker Configuration

```properties
# server.properties
broker.id=0
listeners=PLAINTEXT://:9092
log.dirs=/tmp/kafka-logs
num.partitions=1
default.replication.factor=3
```

### Multiple Brokers Example

```
Broker 0 (Port 9092)
├── Topic: orders, Partition: 0 (Leader)
├── Topic: orders, Partition: 1 (Follower)
└── Topic: users, Partition: 0 (Leader)

Broker 1 (Port 9093)
├── Topic: orders, Partition: 1 (Leader)
├── Topic: orders, Partition: 2 (Follower)
└── Topic: users, Partition: 1 (Leader)

Broker 2 (Port 9094)
├── Topic: orders, Partition: 2 (Leader)
├── Topic: orders, Partition: 0 (Follower)
└── Topic: users, Partition: 0 (Follower)
```

---

## 2. Topics

### What is a Topic?

A **topic** is a category/stream where messages are published.

**Analogy**: Like a folder in a file system or a table in a database.

### Topic Characteristics

- **Named**: e.g., "orders", "user-clicks", "logs"
- **Immutable**: Messages cannot be modified
- **Append-only**: New messages added to the end
- **Retention-based**: Messages kept for configured time/size

### Topic Example

```
Topic: "orders"
┌─────────────────────────────────────┐
│ [Order1] [Order2] [Order3] [Order4] │
│                              ↑       │
│                         New messages │
│                         appended here│
└─────────────────────────────────────┘
```

### Topic Naming Conventions

✅ **Good:**
- `user.signup`
- `order.created`
- `payment.completed`
- `logs.application`

❌ **Avoid:**
- Spaces: `user signup`
- Special chars: `order@created`
- Too generic: `data`, `events`

---

## 3. Partitions

### What is a Partition?

A **partition** is a subdivision of a topic for parallelism and scalability.

### Why Partitions?

1. **Scalability**: Distribute data across multiple brokers
2. **Parallelism**: Multiple consumers read simultaneously
3. **Performance**: Each partition can be on different disk

### Partition Structure

```
Topic: "orders" (3 partitions)

Partition 0:  [Msg0] [Msg3] [Msg6] [Msg9]  (Broker 0)
Partition 1:  [Msg1] [Msg4] [Msg7] [Msg10] (Broker 1)
Partition 2:  [Msg2] [Msg5] [Msg8] [Msg11] (Broker 2)
                ↑
              Offset
```

### Key Concepts

#### Offset
- Unique ID for each message within a partition
- Starts at 0, increments sequentially
- Consumer tracks its position using offset

```
Partition 0:
┌──────┬──────┬──────┬──────┬──────┐
│Offset│ 0    │ 1    │ 2    │ 3    │
├──────┼──────┼──────┼──────┼──────┤
│ Msg  │ A    │ B    │ C    │ D    │
└──────┴──────┴──────┴──────┴──────┘
```

#### Ordering
- ✅ **Guaranteed**: Within a partition
- ❌ **Not guaranteed**: Across partitions

```
Partition 0: [1] [2] [3] → Order preserved
Partition 1: [4] [5] [6] → Order preserved

Global order: Could be [1][4][2][5][3][6] → NOT preserved
```

### Partition Distribution

**Example: 3 brokers, 6 partitions**

```
Broker 0: P0, P3
Broker 1: P1, P4
Broker 2: P2, P5
```

**Load balanced across all brokers**

---

## How Data Flows

### Producer → Topic → Partition

```
Producer sends message "Order #123"
         ↓
  Partitioner decides
  (based on key or round-robin)
         ↓
    ┌─────────────┐
    │   Topic     │
    ├─────────────┤
    │ Partition 0 │ ← Message goes here
    │ Partition 1 │
    │ Partition 2 │
    └─────────────┘
```

### Partitioning Strategy

#### 1. With Key (Hash-based)

```java
// Same key → Same partition
producer.send("orders", "user123", "Order data");

partition = hash("user123") % number_of_partitions
```

**Use case**: All orders from same user in same partition (maintains order)

#### 2. Without Key (Round-robin)

```java
// No key → Random distribution
producer.send("orders", null, "Order data");
```

**Use case**: Load balancing, order doesn't matter

---

## Storage Architecture

### Log Segments

Each partition is stored as a log on disk:

```
/tmp/kafka-logs/
  ├── orders-0/
  │   ├── 00000000000000000000.log    (Segment 1)
  │   ├── 00000000000000100000.log    (Segment 2)
  │   └── 00000000000000200000.log    (Segment 3)
  ├── orders-1/
  │   └── 00000000000000000000.log
  └── orders-2/
      └── 00000000000000000000.log
```

### Segment Rolling

New segment created when:
- Size limit reached (e.g., 1GB)
- Time limit reached (e.g., 7 days)

---

## Cluster Coordination

### ZooKeeper (Legacy)

- Manages broker metadata
- Leader election
- Topic configuration
- Consumer group coordination

### KRaft (New - Kafka 3.0+)

- Built-in consensus protocol
- No external ZooKeeper needed
- Simpler architecture
- Better performance

```
ZooKeeper Mode:
Producer → Broker → ZooKeeper (metadata)
                ↓
           Consumer

KRaft Mode:
Producer → Broker (with built-in metadata)
                ↓
           Consumer
```

---

## Scaling Patterns

### Horizontal Scaling

**Add more brokers:**

```
Before (2 brokers, 4 partitions):
Broker 0: P0, P2
Broker 1: P1, P3

After (4 brokers, 4 partitions):
Broker 0: P0
Broker 1: P1
Broker 2: P2
Broker 3: P3

→ Better distribution, more throughput
```

### Partition Scaling

**Increase partitions:**

```bash
kafka-topics.sh --alter --topic orders --partitions 6
```

**Note**: Can only increase, not decrease partitions

---

## Best Practices

### Number of Partitions

✅ **Start with:**
- Partitions = max(num_brokers, expected_consumers)
- For high throughput: 10-100 partitions
- For low volume: 3-10 partitions

### Partition Key Selection

✅ **Good keys:**
- User ID (for user-related events)
- Order ID (for order processing)
- Device ID (for IoT data)

❌ **Bad keys:**
- Timestamp (uneven distribution)
- Random UUID (defeats purpose)

### Topic Design

✅ **One topic per event type:**
- `user.created`
- `user.updated`
- `user.deleted`

❌ **Avoid single topic for all:**
- `events` (too generic)

---

## Summary

**Broker:**
- Kafka server
- Stores and serves data
- Unique broker.id
- Horizontal scaling

**Topic:**
- Named stream of messages
- Append-only log
- Divided into partitions
- Configurable retention

**Partition:**
- Subdivision of topic
- Unit of parallelism
- Sequential offset within partition
- Distributed across brokers

**Architecture:**
```
Producer → Broker (Topic → Partitions) → Consumer
              ↓
       ZooKeeper/KRaft
```

---

## Interview Questions & Answers

### Q1: What is a Kafka broker?
**A:** A Kafka broker is a server that stores data and serves client requests. Each broker has a unique ID, manages partitions, handles read/write operations, and participates in data replication. Multiple brokers form a Kafka cluster.

### Q2: What is a Kafka topic?
**A:** A topic is a category or stream name where messages are published. It's like a table in a database or a folder in a filesystem. Topics are divided into partitions for scalability and parallelism.

### Q3: What is a partition in Kafka?
**A:** A partition is a subdivision of a topic. Each partition is an ordered, immutable sequence of messages. Partitions enable:
- Parallel processing (multiple consumers)
- Scalability (distributed across brokers)
- Load balancing

### Q4: What is an offset in Kafka?
**A:** An offset is a unique sequential ID assigned to each message within a partition. It starts at 0 and increments by 1 for each new message. Consumers use offsets to track their read position.

### Q5: Is message ordering guaranteed in Kafka?
**A:** 
- **Within a partition**: Yes, order is guaranteed
- **Across partitions**: No, order is not guaranteed

For ordered processing, send related messages to the same partition using a message key.

### Q6: How does Kafka decide which partition a message goes to?
**A:**
- **With key**: `partition = hash(key) % num_partitions` (same key → same partition)
- **Without key**: Round-robin or random distribution across partitions
- **Custom partitioner**: You can implement custom partitioning logic

### Q7: Can you decrease the number of partitions for a topic?
**A:** No, you can only increase partitions, not decrease. Decreasing would require data migration and could break ordering guarantees. Plan partition count carefully at topic creation.

### Q8: What is the difference between ZooKeeper and KRaft mode?
**A:**
- **ZooKeeper mode (legacy)**: Uses external ZooKeeper for metadata management, leader election, and coordination
- **KRaft mode (new)**: Uses Kafka's built-in Raft consensus protocol, no ZooKeeper needed, simpler architecture, available from Kafka 3.0+

### Q9: How are partitions distributed across brokers?
**A:** Kafka distributes partitions evenly across available brokers for load balancing. Example with 3 brokers and 6 partitions:
- Broker 0: P0, P3
- Broker 1: P1, P4  
- Broker 2: P2, P5

### Q10: What happens when you add more brokers to a cluster?
**A:** New brokers join the cluster but existing partitions are NOT automatically redistributed. You must manually reassign partitions using `kafka-reassign-partitions.sh` to balance load across new brokers.

### Q11: How is data stored in Kafka?
**A:** Data is stored as log segments on disk:
```
/kafka-logs/
  ├── topic-partition/
  │   ├── 00000000000000000000.log (segment)
  │   ├── 00000000000000100000.log (segment)
```
Each partition is a directory with multiple log segment files.

### Q12: What is a good partition key?
**A:** A good partition key:
- Ensures even distribution (avoid hot partitions)
- Groups related messages (e.g., userId for user events)
- Has high cardinality (many unique values)

**Good**: userId, orderId, deviceId
**Bad**: timestamp, boolean values, null

### Q13: How many partitions should a topic have?
**A:** General guidelines:
- Start with: `max(number_of_brokers, number_of_consumers)`
- High throughput: 10-100 partitions
- Low volume: 3-10 partitions
- Consider: target throughput, number of consumers, retention period

### Q14: What is broker.id and why is it important?
**A:** broker.id is a unique integer identifier for each broker in the cluster. It must be unique across all brokers. Used for:
- Identifying brokers in metadata
- Partition assignment
- Replication and leadership

### Q15: Can multiple topics share the same partition?
**A:** No, partitions belong to a single topic. Each topic has its own set of partitions. However, multiple partitions from different topics can be stored on the same broker.

**Next:** Producers & Consumers!