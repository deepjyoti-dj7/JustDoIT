# üöÄ Stream Performance

## üìñ Overview

Understanding stream performance helps you write efficient code. Streams are not always faster than loops - know when to use them and how to optimize.

---

## ‚ö° Performance Factors

### 1. Boxing/Unboxing Overhead

**Problem: Boxing is Expensive**
```java
// BAD - boxing overhead
long sum1 = Stream.of(1, 2, 3, 4, 5)
    .reduce(0, Integer::sum);  // Autoboxing Integer ‚Üî int

// GOOD - primitive stream
long sum2 = IntStream.of(1, 2, 3, 4, 5)
    .sum();  // No boxing!
```

**Comparison:**
```java
// Slow - boxing
List<Integer> numbers = IntStream.range(1, 1_000_000)
    .boxed()  // int ‚Üí Integer
    .collect(Collectors.toList());

long sum = numbers.stream()
    .mapToInt(Integer::intValue)  // Integer ‚Üí int
    .sum();

// Fast - primitive stream
int sum = IntStream.range(1, 1_000_000)
    .sum();
```

### 2. Short-Circuiting Operations

**Operations that Can Stop Early:**
```java
List<Integer> numbers = IntStream.range(1, 1_000_000)
    .boxed()
    .collect(Collectors.toList());

// findFirst stops after first match
Optional<Integer> first = numbers.stream()
    .filter(n -> n > 100)
    .findFirst();  // Stops at 101

// anyMatch stops after first true
boolean hasEven = numbers.stream()
    .anyMatch(n -> n % 2 == 0);  // Stops at 2

// limit stops after N elements
List<Integer> first10 = numbers.stream()
    .limit(10)
    .collect(Collectors.toList());
```

**Short-Circuiting Operations:**
- `findFirst()`
- `findAny()`
- `anyMatch()`
- `allMatch()`
- `noneMatch()`
- `limit()`

### 3. Operation Order Matters

**Bad Order - More Processing**
```java
// BAD - map then filter
List<String> result1 = words.stream()
    .map(String::toUpperCase)      // Transforms ALL
    .filter(s -> s.length() > 5)   // Then filters
    .collect(Collectors.toList());
```

**Good Order - Less Processing**
```java
// GOOD - filter then map
List<String> result2 = words.stream()
    .filter(s -> s.length() > 5)   // Filters first
    .map(String::toUpperCase)      // Transforms only filtered
    .collect(Collectors.toList());
```

### 4. Stateless vs Stateful Operations

**Stateless (Fast):**
```java
// No buffering needed
list.stream()
    .filter(predicate)  // Stateless
    .map(function)      // Stateless
    .collect(Collectors.toList());
```

**Stateful (Slow):**
```java
// Requires buffering entire stream
list.stream()
    .sorted()           // Stateful - must see all elements
    .distinct()         // Stateful - must track seen elements
    .collect(Collectors.toList());
```

---

## üìä Performance Comparisons

### Loop vs Stream

**Simple Iteration:**
```java
List<Integer> numbers = IntStream.range(1, 1_000_000)
    .boxed()
    .collect(Collectors.toList());

// Traditional loop - FASTER for simple ops
long start1 = System.nanoTime();
int sum1 = 0;
for (int n : numbers) {
    sum1 += n;
}
long end1 = System.nanoTime();
System.out.println("Loop: " + (end1 - start1) / 1_000_000 + "ms");

// Stream - overhead
long start2 = System.nanoTime();
int sum2 = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();
long end2 = System.nanoTime();
System.out.println("Stream: " + (end2 - start2) / 1_000_000 + "ms");

// Primitive stream - FASTER
long start3 = System.nanoTime();
int sum3 = IntStream.range(1, 1_000_000)
    .sum();
long end3 = System.nanoTime();
System.out.println("IntStream: " + (end3 - start3) / 1_000_000 + "ms");
```

**Complex Pipeline:**
```java
// Stream shines with complex operations
List<String> result = words.stream()
    .filter(s -> s.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .distinct()
    .limit(100)
    .collect(Collectors.toList());
```

---

## üéØ Optimization Techniques

### 1. Use Primitive Streams
```java
// BAD
int sum = Stream.of(1, 2, 3, 4, 5)
    .reduce(0, Integer::sum);

// GOOD
int sum = IntStream.of(1, 2, 3, 4, 5)
    .sum();

// Available primitive streams:
// IntStream, LongStream, DoubleStream
```

### 2. Avoid Unnecessary Boxing
```java
// BAD
List<Integer> squares = IntStream.range(1, 100)
    .boxed()  // int ‚Üí Integer
    .map(n -> n * n)
    .collect(Collectors.toList());

// GOOD
int[] squares = IntStream.range(1, 100)
    .map(n -> n * n)
    .toArray();
```

### 3. Use Method References
```java
// Slightly slower - lambda
list.stream()
    .map(s -> s.toLowerCase())
    .collect(Collectors.toList());

// Slightly faster - method reference
list.stream()
    .map(String::toLowerCase)
    .collect(Collectors.toList());
```

### 4. Parallel Streams for Large Data
```java
// Sequential for small data (< 10K)
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();

// Parallel for large data (> 100K) with CPU-intensive ops
int sum = numbers.parallelStream()
    .mapToInt(Integer::intValue)
    .sum();
```

### 5. Lazy Evaluation Benefits
```java
// Only processes until limit reached
List<Integer> first10Even = IntStream.range(1, 1_000_000)
    .filter(n -> n % 2 == 0)  // Lazy
    .limit(10)                // Short-circuits
    .boxed()
    .collect(Collectors.toList());
// Only checks ~20 numbers, not 1M!
```

---

## üìâ Common Performance Pitfalls

### 1. Unnecessary Stream Creation
```java
// BAD - creating stream unnecessarily
if (list.stream().count() > 0) { }

// GOOD - direct check
if (!list.isEmpty()) { }
```

### 2. Multiple Terminal Operations
```java
// BAD - multiple passes
long count = list.stream().count();
long sum = list.stream().mapToInt(Integer::intValue).sum();

// GOOD - single pass
IntSummaryStatistics stats = list.stream()
    .mapToInt(Integer::intValue)
    .summaryStatistics();
long count = stats.getCount();
long sum = stats.getSum();
```

### 3. Inappropriate Parallel Streams
```java
// BAD - small dataset
List<Integer> small = Arrays.asList(1, 2, 3, 4, 5);
small.parallelStream().forEach(System.out::println);  // Overhead!

// GOOD - use sequential
small.forEach(System.out::println);
```

### 4. Mixing Ordered and Unordered
```java
// BAD - defeats parallelism
Set<Integer> set = new HashSet<>(numbers);
List<Integer> sorted = set.parallelStream()
    .sorted()  // Forces ordering
    .collect(Collectors.toList());

// BETTER - unordered if order doesn't matter
List<Integer> result = set.parallelStream()
    .collect(Collectors.toList());
```

---

## üîç Benchmarking

### JMH Benchmarking Example
```java
import org.openjdk.jmh.annotations.*;

@State(Scope.Thread)
public class StreamBenchmark {
    
    List<Integer> numbers;
    
    @Setup
    public void setup() {
        numbers = IntStream.range(1, 10000)
            .boxed()
            .collect(Collectors.toList());
    }
    
    @Benchmark
    public int traditionalLoop() {
        int sum = 0;
        for (int n : numbers) {
            sum += n;
        }
        return sum;
    }
    
    @Benchmark
    public int streamSum() {
        return numbers.stream()
            .mapToInt(Integer::intValue)
            .sum();
    }
    
    @Benchmark
    public int parallelStreamSum() {
        return numbers.parallelStream()
            .mapToInt(Integer::intValue)
            .sum();
    }
}
```

### Manual Timing
```java
public class PerformanceTest {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(1, 1_000_000)
            .boxed()
            .collect(Collectors.toList());
        
        // Warm-up
        for (int i = 0; i < 10; i++) {
            numbers.stream().count();
        }
        
        // Measure
        long start = System.nanoTime();
        // Operation to test
        long end = System.nanoTime();
        
        System.out.println("Time: " + (end - start) / 1_000_000 + "ms");
    }
}
```

---

## üìä Performance Guidelines

| Scenario | Use | Reason |
|----------|-----|--------|
| Simple iteration | Loop | Less overhead |
| Complex pipeline | Stream | Clearer code |
| Numeric operations | Primitive stream | No boxing |
| Large dataset + CPU work | Parallel stream | Utilizes cores |
| Small dataset | Sequential | Avoid overhead |
| Finding first match | Short-circuit | Early termination |
| Multiple stats | summaryStatistics | Single pass |

---

## ‚ö° Quick Optimization Checklist

- [ ] Use primitive streams (IntStream, LongStream, DoubleStream)
- [ ] Avoid unnecessary boxing/unboxing
- [ ] Filter before map
- [ ] Use short-circuiting when possible
- [ ] Avoid stateful operations if possible
- [ ] Consider parallel only for large datasets
- [ ] Use method references over lambdas
- [ ] Reuse collectors where possible
- [ ] Benchmark critical paths
- [ ] Don't optimize prematurely

---

## üîó Related Topics

- [Parallel Streams](06.%20Parallel%20Streams.md)
- [Intermediate Operations](03.%20Intermediate%20Operations.md)
- [Terminal Operations](04.%20Terminal%20Operations.md)

---

## üí° Key Takeaways

- Streams have overhead - not always faster than loops
- Use primitive streams to avoid boxing
- Operation order matters: filter before map
- Short-circuiting improves performance
- Stateful operations (sorted, distinct) are expensive
- Parallel streams help with large datasets + CPU work
- Always benchmark performance-critical code
- Lazy evaluation is a key performance feature
- summaryStatistics for multiple stats in one pass
- Don't optimize prematurely - measure first
