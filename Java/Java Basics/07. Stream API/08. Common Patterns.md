# ðŸŽ¨ Common Stream Patterns

## ðŸ“– Overview

Real-world stream patterns and idioms for common programming tasks.

---

## ðŸ’» Pattern 1: Map-Filter-Collect

### Basic Pattern
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
// [ALICE, CHARLIE, DAVID]
```

### With Objects
```java
List<Person> people = getPeople();

List<String> adultNames = people.stream()
    .filter(p -> p.getAge() >= 18)
    .map(Person::getName)
    .collect(Collectors.toList());
```

---

## ðŸ’» Pattern 2: Grouping and Counting

### Group by Property
```java
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));
```

### Count by Property
```java
Map<String, Long> countByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));
```

### Group and Transform
```java
Map<String, List<String>> namesByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.mapping(Person::getName, Collectors.toList())
    ));
```

---

## ðŸ’» Pattern 3: Top N Elements

### Using sorted() and limit()
```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9, 3, 7);

List<Integer> top3 = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .limit(3)
    .collect(Collectors.toList());
// [9, 8, 7]
```

### Top N by Property
```java
List<Person> oldest3 = people.stream()
    .sorted(Comparator.comparing(Person::getAge).reversed())
    .limit(3)
    .collect(Collectors.toList());
```

### Bottom N
```java
List<Integer> bottom3 = numbers.stream()
    .sorted()
    .limit(3)
    .collect(Collectors.toList());
// [1, 2, 3]
```

---

## ðŸ’» Pattern 4: Flattening Nested Collections

### Flatten List of Lists
```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4),
    Arrays.asList(5, 6)
);

List<Integer> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5, 6]
```

### Flatten Objects to Properties
```java
class Department {
    List<Employee> employees;
}

List<Department> departments = getDepartments();

List<Employee> allEmployees = departments.stream()
    .flatMap(dept -> dept.getEmployees().stream())
    .collect(Collectors.toList());
```

### String to Characters
```java
List<String> words = Arrays.asList("Hello", "World");

List<Character> chars = words.stream()
    .flatMap(word -> word.chars().mapToObj(c -> (char) c))
    .collect(Collectors.toList());
// [H, e, l, l, o, W, o, r, l, d]
```

---

## ðŸ’» Pattern 5: Partitioning

### Binary Split
```java
Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1, 3, 5, 7, 9], true=[2, 8]}
```

### Extract Both Parts
```java
List<Integer> evens = partitioned.get(true);
List<Integer> odds = partitioned.get(false);
```

### Partition with Counting
```java
Map<Boolean, Long> counts = numbers.stream()
    .collect(Collectors.partitioningBy(
        n -> n % 2 == 0,
        Collectors.counting()
    ));
// {false=5, true=2}
```

---

## ðŸ’» Pattern 6: Finding and Matching

### Find First Match
```java
Optional<Person> firstAdult = people.stream()
    .filter(p -> p.getAge() >= 18)
    .findFirst();

String name = firstAdult
    .map(Person::getName)
    .orElse("No adults found");
```

### Check Conditions
```java
// Any
boolean hasAdults = people.stream()
    .anyMatch(p -> p.getAge() >= 18);

// All
boolean allAdults = people.stream()
    .allMatch(p -> p.getAge() >= 18);

// None
boolean noMinors = people.stream()
    .noneMatch(p -> p.getAge() < 18);
```

---

## ðŸ’» Pattern 7: Reducing to Single Value

### Sum/Average/Min/Max
```java
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();

OptionalDouble avg = numbers.stream()
    .mapToInt(Integer::intValue)
    .average();

Optional<Integer> max = numbers.stream()
    .max(Integer::compareTo);
```

### Custom Reduction
```java
// Concatenate strings
String concat = words.stream()
    .reduce("", (a, b) -> a + " " + b);

// Product
int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);
```

---

## ðŸ’» Pattern 8: Converting Collections

### List to Set
```java
Set<String> set = list.stream()
    .collect(Collectors.toSet());
```

### List to Map
```java
Map<Integer, Person> map = people.stream()
    .collect(Collectors.toMap(
        Person::getId,
        Function.identity()
    ));
```

### Array to List
```java
String[] array = {"A", "B", "C"};
List<String> list = Arrays.stream(array)
    .collect(Collectors.toList());
```

---

## ðŸ’» Pattern 9: Joining Strings

### Simple Join
```java
String result = names.stream()
    .collect(Collectors.joining(", "));
// "Alice, Bob, Charlie"
```

### With Prefix/Suffix
```java
String result = names.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// "[Alice, Bob, Charlie]"
```

### Filter and Join
```java
String adultNames = people.stream()
    .filter(p -> p.getAge() >= 18)
    .map(Person::getName)
    .collect(Collectors.joining(", "));
```

---

## ðŸ’» Pattern 10: Removing Duplicates

### Simple Distinct
```java
List<Integer> unique = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
```

### Distinct by Property
```java
// Using custom logic with Set
Set<String> seen = new HashSet<>();
List<Person> distinctByName = people.stream()
    .filter(p -> seen.add(p.getName()))
    .collect(Collectors.toList());
```

### Distinct by Multiple Properties
```java
Set<String> seen = new HashSet<>();
List<Person> distinct = people.stream()
    .filter(p -> seen.add(p.getName() + "|" + p.getAge()))
    .collect(Collectors.toList());
```

---

## ðŸ’» Pattern 11: Paging/Pagination

### Skip and Limit
```java
int page = 2;
int pageSize = 10;

List<Item> pageItems = allItems.stream()
    .skip((page - 1) * pageSize)
    .limit(pageSize)
    .collect(Collectors.toList());
```

### With Sorting
```java
List<Person> page = people.stream()
    .sorted(Comparator.comparing(Person::getName))
    .skip(pageNumber * pageSize)
    .limit(pageSize)
    .collect(Collectors.toList());
```

---

## ðŸ’» Pattern 12: Chaining Optional

### flatMap with Optional
```java
Optional<Person> person = findPerson(id);
Optional<String> city = person
    .flatMap(Person::getAddress)
    .flatMap(Address::getCity);
```

### map with Optional
```java
Optional<String> name = person
    .map(Person::getName)
    .map(String::toUpperCase);
```

---

## ðŸ’» Pattern 13: Complex Aggregations

### Multiple Statistics
```java
IntSummaryStatistics stats = people.stream()
    .mapToInt(Person::getAge)
    .summaryStatistics();

System.out.println("Count: " + stats.getCount());
System.out.println("Average: " + stats.getAverage());
System.out.println("Min: " + stats.getMin());
System.out.println("Max: " + stats.getMax());
```

### Custom Aggregation
```java
Map<String, DoubleSummaryStatistics> salaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.summarizingDouble(Employee::getSalary)
    ));
```

---

## ðŸ’» Pattern 14: Filtering Nulls

### Remove Nulls
```java
List<String> nonNull = list.stream()
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

### flatMap with Optional
```java
List<String> values = optionals.stream()
    .flatMap(Optional::stream)  // Java 9+
    .collect(Collectors.toList());
```

---

## ðŸ’» Pattern 15: Combining Streams

### Concatenate
```java
Stream<String> stream1 = list1.stream();
Stream<String> stream2 = list2.stream();

List<String> combined = Stream.concat(stream1, stream2)
    .collect(Collectors.toList());
```

### Multiple Concatenations
```java
Stream<String> combined = Stream.of(
    list1.stream(),
    list2.stream(),
    list3.stream()
).flatMap(Function.identity());
```

---

## ðŸŽ¯ Real-World Example

```java
public class OrderProcessor {
    
    public OrderSummary processOrders(List<Order> orders) {
        // Filter valid orders
        List<Order> validOrders = orders.stream()
            .filter(Order::isValid)
            .collect(Collectors.toList());
        
        // Calculate total revenue
        double totalRevenue = validOrders.stream()
            .mapToDouble(Order::getTotal)
            .sum();
        
        // Group by status
        Map<OrderStatus, Long> countByStatus = validOrders.stream()
            .collect(Collectors.groupingBy(
                Order::getStatus,
                Collectors.counting()
            ));
        
        // Top 5 customers by order count
        Map<String, Long> ordersByCustomer = validOrders.stream()
            .collect(Collectors.groupingBy(
                Order::getCustomerId,
                Collectors.counting()
            ));
        
        List<String> topCustomers = ordersByCustomer.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .limit(5)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
        
        // Average order value
        double avgOrderValue = validOrders.stream()
            .mapToDouble(Order::getTotal)
            .average()
            .orElse(0.0);
        
        return new OrderSummary(
            validOrders.size(),
            totalRevenue,
            countByStatus,
            topCustomers,
            avgOrderValue
        );
    }
}
```

---

## ðŸ“Š Pattern Summary

| Pattern | Use Case | Example |
|---------|----------|---------|
| Map-Filter-Collect | Transform and filter | names â†’ uppercase names |
| Grouping | Categorize data | people by city |
| Top N | Find extremes | top 10 scores |
| Flattening | Nested collections | list of lists â†’ flat list |
| Partitioning | Binary split | even/odd numbers |
| Finding | Search with conditions | first adult |
| Reducing | Aggregate to single value | sum, product |
| Joining | String concatenation | names â†’ "A, B, C" |
| Distinct | Remove duplicates | unique names |
| Paging | Pagination | page 2 of results |

---

## ðŸ”— Related Topics

- [Intermediate Operations](03.%20Intermediate%20Operations.md)
- [Terminal Operations](04.%20Terminal%20Operations.md)
- [Collectors](05.%20Collectors.md)

---

## ðŸ’¡ Key Takeaways

- Learn common patterns to solve real problems efficiently
- Map-Filter-Collect is the most common pattern
- Grouping and partitioning organize data
- flatMap flattens nested structures
- Collectors provide powerful aggregation
- Chaining operations creates readable pipelines
- Reuse patterns across different domains
- Practice makes stream operations intuitive
