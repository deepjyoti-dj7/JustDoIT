# üéØ Terminal Operations

## üìñ Overview

**Terminal operations** produce a result or side-effect and close the stream. Once a terminal operation is executed, the stream cannot be reused.

**Key Characteristics:**
- Trigger the execution of the pipeline
- Produce a non-stream result
- Stream is consumed and cannot be reused
- Eager evaluation

---

## üíª Core Terminal Operations

### 1. forEach() - Iteration
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Simple iteration
names.stream()
    .forEach(System.out::println);

// With index (using IntStream)
IntStream.range(0, names.size())
    .forEach(i -> System.out.println(i + ": " + names.get(i)));

// Parallel forEach (order not guaranteed)
names.parallelStream()
    .forEach(System.out::println);

// forEachOrdered (maintains order even in parallel)
names.parallelStream()
    .forEachOrdered(System.out::println);
```

### 2. collect() - Collecting to Collections
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// To List
List<String> list = names.stream()
    .collect(Collectors.toList());

// To Set
Set<String> set = names.stream()
    .collect(Collectors.toSet());

// To specific collection
ArrayList<String> arrayList = names.stream()
    .collect(Collectors.toCollection(ArrayList::new));

// To Map
Map<String, Integer> nameLength = names.stream()
    .collect(Collectors.toMap(
        name -> name,
        String::length
    ));

// To String
String joined = names.stream()
    .collect(Collectors.joining(", "));
// "Alice, Bob, Charlie"
```

### 3. reduce() - Reduction Operations
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum
int sum = numbers.stream()
    .reduce(0, Integer::sum);
// 15

// Product
int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);
// 120

// Max
Optional<Integer> max = numbers.stream()
    .reduce(Integer::max);

// String concatenation
List<String> words = Arrays.asList("Hello", "World");
String concat = words.stream()
    .reduce("", (a, b) -> a + " " + b);
// " Hello World"

// Better with identity and combiner
String result = words.stream()
    .reduce("Start:", 
            (a, b) -> a + " " + b,
            (a, b) -> a + b);
```

### 4. count() - Counting Elements
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

long count = names.stream()
    .filter(s -> s.length() > 3)
    .count();
// 2

// Count with condition
long evenCount = IntStream.range(1, 10)
    .filter(n -> n % 2 == 0)
    .count();
// 4
```

### 5. findFirst() - First Element
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

Optional<String> first = names.stream()
    .filter(s -> s.startsWith("B"))
    .findFirst();
// Optional[Bob]

// With default
String name = names.stream()
    .filter(s -> s.startsWith("Z"))
    .findFirst()
    .orElse("Not Found");
// "Not Found"
```

### 6. findAny() - Any Element
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Sequential - usually returns first
Optional<String> any = names.stream()
    .filter(s -> s.length() > 3)
    .findAny();

// Parallel - can return any matching element
Optional<String> parallel = names.parallelStream()
    .filter(s -> s.length() > 3)
    .findAny();
```

### 7. anyMatch() - Check If Any Match
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

boolean hasEven = numbers.stream()
    .anyMatch(n -> n % 2 == 0);
// true

boolean hasNegative = numbers.stream()
    .anyMatch(n -> n < 0);
// false
```

### 8. allMatch() - Check If All Match
```java
List<Integer> numbers = Arrays.asList(2, 4, 6, 8);

boolean allEven = numbers.stream()
    .allMatch(n -> n % 2 == 0);
// true

boolean allPositive = numbers.stream()
    .allMatch(n -> n > 0);
// true
```

### 9. noneMatch() - Check If None Match
```java
List<Integer> numbers = Arrays.asList(1, 3, 5, 7);

boolean noEven = numbers.stream()
    .noneMatch(n -> n % 2 == 0);
// true

boolean noNegative = numbers.stream()
    .noneMatch(n -> n < 0);
// true
```

### 10. min() / max() - Finding Extremes
```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

Optional<Integer> min = numbers.stream()
    .min(Integer::compareTo);
// Optional[1]

Optional<Integer> max = numbers.stream()
    .max(Integer::compareTo);
// Optional[9]

// With custom comparator
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Optional<String> longest = names.stream()
    .max(Comparator.comparingInt(String::length));
// Optional[Charlie]
```

---

## üî¢ Primitive Stream Terminal Operations

### sum()
```java
int sum = IntStream.range(1, 6).sum();
// 15

double total = DoubleStream.of(1.1, 2.2, 3.3).sum();
// 6.6
```

### average()
```java
OptionalDouble avg = IntStream.range(1, 6).average();
// OptionalDouble[3.0]

double averageValue = avg.orElse(0.0);
```

### summaryStatistics()
```java
IntSummaryStatistics stats = IntStream.range(1, 6)
    .summaryStatistics();

System.out.println("Count: " + stats.getCount());     // 5
System.out.println("Sum: " + stats.getSum());         // 15
System.out.println("Min: " + stats.getMin());         // 1
System.out.println("Max: " + stats.getMax());         // 5
System.out.println("Average: " + stats.getAverage()); // 3.0
```

---

## üîÑ toArray() - Converting to Array

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Object array
Object[] array1 = names.stream().toArray();

// Typed array
String[] array2 = names.stream().toArray(String[]::new);

// Primitive array
int[] intArray = IntStream.range(1, 6).toArray();
```

---

## üìä Terminal Operations Summary

| Operation | Returns | Short-Circuits | Description |
|-----------|---------|----------------|-------------|
| forEach | void | No | Iterate elements |
| forEachOrdered | void | No | Ordered iteration |
| collect | Collection/Object | No | Collect to collection |
| reduce | Optional/Value | No | Reduce to single value |
| count | long | No | Count elements |
| findFirst | Optional | Yes | First element |
| findAny | Optional | Yes | Any element |
| anyMatch | boolean | Yes | Check if any match |
| allMatch | boolean | Yes | Check if all match |
| noneMatch | boolean | Yes | Check if none match |
| min | Optional | No | Minimum element |
| max | Optional | No | Maximum element |
| toArray | Array | No | Convert to array |

**Short-Circuiting**: Can stop processing early

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use collect for collections | Most flexible collection creation |
| ‚úÖ Use reduce for aggregations | Sum, product, concatenation |
| ‚úÖ Match operations for checks | anyMatch, allMatch, noneMatch |
| ‚úÖ findAny for parallel | Better performance than findFirst |
| ‚úÖ summaryStatistics for stats | Get multiple stats in one pass |
| ‚ùå Don't use forEach for side effects | Prefer collect or reduce |
| ‚ùå Avoid reusing stream | Create new stream after terminal op |

---

## üéØ Common Patterns

### Pattern 1: Filter and Collect
```java
List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
```

### Pattern 2: Map and Reduce
```java
int totalLength = words.stream()
    .mapToInt(String::length)
    .sum();
```

### Pattern 3: Find with Default
```java
String result = list.stream()
    .filter(condition)
    .findFirst()
    .orElse("default");
```

### Pattern 4: Check Conditions
```java
if (list.stream().anyMatch(predicate)) {
    // Handle match
}
```

### Pattern 5: Collect to Map
```java
Map<String, Integer> map = list.stream()
    .collect(Collectors.toMap(
        Function.identity(),
        String::length
    ));
```

---

## üîó Related Topics

- [Intermediate Operations](03.%20Intermediate%20Operations.md)
- [Collectors](05.%20Collectors.md)
- [Stream Performance](07.%20Stream%20Performance.md)

---

## üí° Key Takeaways

- Terminal operations trigger pipeline execution
- Stream is consumed and cannot be reused
- Short-circuiting operations can improve performance
- collect() is most versatile for creating collections
- reduce() for aggregations and custom reductions
- Match operations (anyMatch, allMatch, noneMatch) for conditions
- Primitive streams have specialized operations (sum, average)
- summaryStatistics provides multiple stats efficiently
