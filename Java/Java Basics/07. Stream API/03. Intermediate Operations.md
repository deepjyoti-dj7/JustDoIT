# ‚öôÔ∏è Intermediate Operations

## üìñ Overview

**Intermediate operations** transform a stream into another stream. They are **lazy** - not executed until a terminal operation is invoked. Multiple intermediate operations can be chained together.

**Key Characteristics:**
- Return a new Stream
- Lazy evaluation (deferred execution)
- Chainable
- Stateless (mostly) or stateful

---

## üíª Core Intermediate Operations

### 1. filter() - Filtering Elements
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// [2, 4, 6]

List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> longNames = names.stream()
    .filter(s -> s.length() > 3)
    .collect(Collectors.toList());
// [Alice, Charlie]
```

### 2. map() - Transforming Elements
```java
List<String> words = Arrays.asList("hello", "world");

List<String> upper = words.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
// [HELLO, WORLD]

List<Integer> lengths = words.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 5]

// Object transformation
List<User> users = getUsers();
List<String> names = users.stream()
    .map(User::getName)
    .collect(Collectors.toList());
```

### 3. flatMap() - Flattening Streams
```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4),
    Arrays.asList(5, 6)
);

List<Integer> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5, 6]

// Words to characters
List<String> words = Arrays.asList("Hello", "World");
List<String> chars = words.stream()
    .flatMap(word -> Arrays.stream(word.split("")))
    .collect(Collectors.toList());
// [H, e, l, l, o, W, o, r, l, d]

// Optional flattening
List<Optional<String>> optionals = Arrays.asList(
    Optional.of("A"), Optional.empty(), Optional.of("B")
);
List<String> values = optionals.stream()
    .flatMap(Optional::stream)
    .collect(Collectors.toList());
// [A, B]
```

### 4. distinct() - Removing Duplicates
```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4);

List<Integer> unique = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
// [1, 2, 3, 4]

// Uses equals() for objects
List<String> words = Arrays.asList("apple", "APPLE", "Apple");
List<String> distinctWords = words.stream()
    .map(String::toLowerCase)
    .distinct()
    .collect(Collectors.toList());
// [apple]
```

### 5. sorted() - Sorting Elements
```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

// Natural order
List<Integer> sorted = numbers.stream()
    .sorted()
    .collect(Collectors.toList());
// [1, 2, 5, 8, 9]

// Reverse order
List<Integer> reversed = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());
// [9, 8, 5, 2, 1]

// Custom comparator
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> byLength = names.stream()
    .sorted(Comparator.comparingInt(String::length))
    .collect(Collectors.toList());
// [Bob, Alice, Charlie]

// Multiple comparators
List<Person> people = getPeople();
List<Person> sortedPeople = people.stream()
    .sorted(Comparator.comparing(Person::getAge)
                      .thenComparing(Person::getName))
    .collect(Collectors.toList());
```

### 6. limit() - Limiting Elements
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> first3 = numbers.stream()
    .limit(3)
    .collect(Collectors.toList());
// [1, 2, 3]

// With infinite stream
Stream.iterate(0, n -> n + 1)
    .limit(5)
    .forEach(System.out::println);
// 0, 1, 2, 3, 4
```

### 7. skip() - Skipping Elements
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> afterSkip = numbers.stream()
    .skip(2)
    .collect(Collectors.toList());
// [3, 4, 5]

// Pagination pattern
int page = 2, pageSize = 3;
List<String> results = allItems.stream()
    .skip((page - 1) * pageSize)
    .limit(pageSize)
    .collect(Collectors.toList());
```

### 8. peek() - Debugging/Side Effects
```java
List<Integer> numbers = Arrays.asList(1, 2, 3);

List<Integer> result = numbers.stream()
    .peek(n -> System.out.println("Original: " + n))
    .map(n -> n * 2)
    .peek(n -> System.out.println("Doubled: " + n))
    .collect(Collectors.toList());

// Logging in pipeline
List<String> processed = names.stream()
    .filter(s -> s.length() > 3)
    .peek(s -> logger.info("Filtered: " + s))
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

### 9. takeWhile() - Take Until Condition (Java 9+)
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 2, 1);

List<Integer> taken = numbers.stream()
    .takeWhile(n -> n < 4)
    .collect(Collectors.toList());
// [1, 2, 3]

// Different from filter
List<Integer> filtered = numbers.stream()
    .filter(n -> n < 4)
    .collect(Collectors.toList());
// [1, 2, 3, 2, 1]
```

### 10. dropWhile() - Drop Until Condition (Java 9+)
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 2, 1);

List<Integer> dropped = numbers.stream()
    .dropWhile(n -> n < 4)
    .collect(Collectors.toList());
// [4, 5, 2, 1]
```

---

## üîÑ Primitive Stream Operations

### mapToInt/mapToLong/mapToDouble
```java
List<String> words = Arrays.asList("hello", "world");

int totalLength = words.stream()
    .mapToInt(String::length)
    .sum();

IntStream intStream = words.stream()
    .mapToInt(String::length);
```

### flatMapToInt/flatMapToLong/flatMapToDouble
```java
List<String> words = Arrays.asList("123", "456");

IntStream digits = words.stream()
    .flatMapToInt(s -> s.chars());
```

### boxed() - Convert to Object Stream
```java
IntStream intStream = IntStream.range(1, 5);
Stream<Integer> boxed = intStream.boxed();
```

---

## üìä Operation Characteristics

| Operation | Stateless | Stateful | Short-Circuiting |
|-----------|-----------|----------|------------------|
| filter | ‚úÖ | | |
| map | ‚úÖ | | |
| flatMap | ‚úÖ | | |
| peek | ‚úÖ | | |
| distinct | | ‚úÖ | |
| sorted | | ‚úÖ | |
| limit | | ‚úÖ | ‚úÖ |
| skip | | ‚úÖ | |
| takeWhile | ‚úÖ | | ‚úÖ |
| dropWhile | ‚úÖ | | |

**Stateless**: Doesn't maintain state across elements  
**Stateful**: Requires state (buffering/storing elements)  
**Short-Circuiting**: Can terminate early

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Chain operations | Combine multiple operations fluently |
| ‚úÖ Order matters | filter before map for performance |
| ‚úÖ Use primitive streams | mapToInt for numeric operations |
| ‚úÖ peek for debugging | Not for main logic |
| ‚ùå Avoid stateful lambdas | Don't modify external state |
| ‚ùå Don't overuse peek | Can impact performance |

---

## üéØ Chaining Example

```java
List<String> result = list.stream()
    .filter(s -> s != null)           // Remove nulls
    .map(String::trim)                // Trim whitespace
    .filter(s -> !s.isEmpty())        // Remove empty
    .map(String::toLowerCase)         // Lowercase
    .distinct()                       // Remove duplicates
    .sorted()                         // Sort
    .limit(10)                        // Top 10
    .collect(Collectors.toList());
```

---

## üîó Related Topics

- [Creating Streams](02.%20Creating%20Streams.md)
- [Terminal Operations](04.%20Terminal%20Operations.md)
- [Stream Performance](07.%20Stream%20Performance.md)

---

## üí° Key Takeaways

- Intermediate operations are lazy - don't execute until terminal operation
- Can be chained for complex transformations
- filter, map, flatMap are most common
- sorted and distinct are stateful (require buffering)
- Use primitive streams (mapToInt) to avoid boxing
- Order of operations affects performance
- peek is for debugging, not business logic
