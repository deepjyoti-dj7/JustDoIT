# üîß Creating Streams

## üìñ Overview

Streams can be created from various sources: collections, arrays, I/O channels, generator functions, and more.

---

## üíª Creation Methods

### 1. From Collections
```java
List<String> list = Arrays.asList("A", "B", "C");
Stream<String> stream = list.stream();
Stream<String> parallelStream = list.parallelStream();

Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3));
Stream<Integer> setStream = set.stream();
```

### 2. From Arrays
```java
String[] array = {"X", "Y", "Z"};
Stream<String> stream1 = Arrays.stream(array);
Stream<String> stream2 = Stream.of(array);

// Partial array
int[] numbers = {1, 2, 3, 4, 5};
IntStream intStream = Arrays.stream(numbers, 1, 4); // [2, 3, 4]
```

### 3. Using Stream.of()
```java
Stream<String> stream = Stream.of("A", "B", "C");
Stream<Integer> singleElement = Stream.of(42);
Stream<String> empty = Stream.empty();
```

### 4. Primitive Streams
```java
// IntStream
IntStream intStream1 = IntStream.range(1, 5);        // [1, 2, 3, 4]
IntStream intStream2 = IntStream.rangeClosed(1, 5);  // [1, 2, 3, 4, 5]
IntStream intStream3 = IntStream.of(1, 2, 3);

// LongStream
LongStream longStream = LongStream.range(1L, 1000000L);

// DoubleStream
DoubleStream doubleStream = DoubleStream.of(1.1, 2.2, 3.3);
```

### 5. Stream.iterate() - Infinite Streams
```java
// Infinite stream
Stream<Integer> infinite = Stream.iterate(0, n -> n + 2);
infinite.limit(5).forEach(System.out::println);  // 0, 2, 4, 6, 8

// With predicate (Java 9+)
Stream<Integer> limited = Stream.iterate(0, n -> n < 10, n -> n + 2);
limited.forEach(System.out::println);  // 0, 2, 4, 6, 8
```

### 6. Stream.generate()
```java
// Random numbers
Stream<Double> randoms = Stream.generate(Math::random).limit(5);

// Constant values
Stream<String> constants = Stream.generate(() -> "Hello").limit(3);

// Using Supplier
Supplier<Integer> supplier = new Supplier<>() {
    private int current = 0;
    public Integer get() { return current++; }
};
Stream<Integer> generated = Stream.generate(supplier).limit(5);
```

### 7. From Files (I/O)
```java
// Read lines from file
try (Stream<String> lines = Files.lines(Paths.get("data.txt"))) {
    lines.filter(line -> line.contains("Java"))
         .forEach(System.out::println);
} catch (IOException e) {
    e.printStackTrace();
}

// List files in directory
try (Stream<Path> paths = Files.list(Paths.get("."))) {
    paths.filter(Files::isRegularFile)
         .forEach(System.out::println);
}

// Walk directory tree
try (Stream<Path> paths = Files.walk(Paths.get("src"))) {
    paths.filter(p -> p.toString().endsWith(".java"))
         .forEach(System.out::println);
}
```

### 8. From Strings
```java
// Characters
IntStream chars = "Hello".chars();
chars.mapToObj(c -> (char) c).forEach(System.out::println);

// Split and stream
Stream<String> words = Pattern.compile("\\s+")
    .splitAsStream("Java is awesome");
```

### 9. Stream Builder
```java
Stream.Builder<String> builder = Stream.builder();
builder.add("A").add("B").add("C");
Stream<String> stream = builder.build();
```

### 10. Concatenating Streams
```java
Stream<String> stream1 = Stream.of("A", "B");
Stream<String> stream2 = Stream.of("C", "D");
Stream<String> concatenated = Stream.concat(stream1, stream2);
```

### 11. From Optional (Java 9+)
```java
Optional<String> optional = Optional.of("Value");
Stream<String> stream = optional.stream();  // Stream with one element

Optional<String> empty = Optional.empty();
Stream<String> emptyStream = empty.stream();  // Empty stream
```

### 12. From Collections (Advanced)
```java
Map<String, Integer> map = Map.of("A", 1, "B", 2);

// Stream of keys
Stream<String> keys = map.keySet().stream();

// Stream of values
Stream<Integer> values = map.values().stream();

// Stream of entries
Stream<Map.Entry<String, Integer>> entries = map.entrySet().stream();
```

---

## üìä Creation Methods Summary

| Method | Type | Use Case |
|--------|------|----------|
| `collection.stream()` | Sequential | Most common |
| `collection.parallelStream()` | Parallel | Parallel processing |
| `Arrays.stream()` | Sequential | From arrays |
| `Stream.of()` | Sequential | Varargs or single element |
| `IntStream.range()` | Primitive | Numeric ranges |
| `Stream.iterate()` | Infinite | Generated sequences |
| `Stream.generate()` | Infinite | Supplier-based |
| `Files.lines()` | Sequential | File I/O |
| `Stream.builder()` | Sequential | Dynamic building |
| `Stream.concat()` | Sequential | Combine streams |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use primitive streams | Avoid boxing: IntStream, LongStream, DoubleStream |
| ‚úÖ Close I/O streams | Use try-with-resources for Files.lines() |
| ‚úÖ Limit infinite streams | Always use limit() or takeWhile() |
| ‚úÖ Prefer collection.stream() | Most readable for collections |
| ‚ùå Don't reuse streams | Create new stream for each operation |

---

## üîó Related Topics

- [Introduction to Streams](01.%20Introduction%20to%20Streams.md)
- [Intermediate Operations](03.%20Intermediate%20Operations.md)

---

## üí° Key Takeaways

- Multiple ways to create streams from different sources
- Primitive streams avoid boxing overhead
- I/O streams must be closed (use try-with-resources)
- Infinite streams require limiting operations
- parallelStream() for concurrent processing
