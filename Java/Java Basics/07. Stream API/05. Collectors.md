# üì¶ Collectors

## üìñ Overview

The **Collectors** utility class provides powerful reduction operations for collecting stream elements into collections, grouping, partitioning, and aggregating data.

**Package:** `java.util.stream.Collectors`

---

## üíª Basic Collectors

### 1. toList() / toSet()
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

List<String> list = names.stream()
    .collect(Collectors.toList());

Set<String> set = names.stream()
    .collect(Collectors.toSet());

// Specific implementation (Java 10+)
List<String> immutableList = names.stream()
    .collect(Collectors.toUnmodifiableList());
```

### 2. toCollection()
```java
// Specific collection type
LinkedList<String> linkedList = names.stream()
    .collect(Collectors.toCollection(LinkedList::new));

TreeSet<String> treeSet = names.stream()
    .collect(Collectors.toCollection(TreeSet::new));
```

### 3. toMap()
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Key: name, Value: length
Map<String, Integer> map1 = names.stream()
    .collect(Collectors.toMap(
        name -> name,           // key mapper
        String::length          // value mapper
    ));

// Using Function.identity()
Map<String, Integer> map2 = names.stream()
    .collect(Collectors.toMap(
        Function.identity(),
        String::length
    ));

// Handle duplicates with merge function
List<String> duplicates = Arrays.asList("A", "B", "A", "C");
Map<String, Integer> map3 = duplicates.stream()
    .collect(Collectors.toMap(
        Function.identity(),
        s -> 1,
        Integer::sum            // merge function
    ));
// {A=2, B=1, C=1}

// Custom Map implementation
TreeMap<String, Integer> treeMap = names.stream()
    .collect(Collectors.toMap(
        Function.identity(),
        String::length,
        (v1, v2) -> v1,
        TreeMap::new
    ));
```

### 4. joining()
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Simple join
String result1 = names.stream()
    .collect(Collectors.joining());
// "AliceBobCharlie"

// With delimiter
String result2 = names.stream()
    .collect(Collectors.joining(", "));
// "Alice, Bob, Charlie"

// With prefix and suffix
String result3 = names.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// "[Alice, Bob, Charlie]"
```

---

## üìä Grouping and Partitioning

### 5. groupingBy() - Grouping Elements
```java
class Person {
    String name;
    int age;
    String city;
    
    // constructor, getters
}

List<Person> people = Arrays.asList(
    new Person("Alice", 25, "NYC"),
    new Person("Bob", 30, "LA"),
    new Person("Charlie", 25, "NYC"),
    new Person("David", 30, "LA")
);

// Group by age
Map<Integer, List<Person>> byAge = people.stream()
    .collect(Collectors.groupingBy(Person::getAge));
// {25=[Alice, Charlie], 30=[Bob, David]}

// Group by city
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// Group and count
Map<Integer, Long> countByAge = people.stream()
    .collect(Collectors.groupingBy(
        Person::getAge,
        Collectors.counting()
    ));
// {25=2, 30=2}

// Group and collect names
Map<Integer, List<String>> namesByAge = people.stream()
    .collect(Collectors.groupingBy(
        Person::getAge,
        Collectors.mapping(Person::getName, Collectors.toList())
    ));
// {25=[Alice, Charlie], 30=[Bob, David]}

// Multi-level grouping
Map<String, Map<Integer, List<Person>>> byCityAndAge = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.groupingBy(Person::getAge)
    ));
// {NYC={25=[Alice, Charlie]}, LA={30=[Bob, David]}}
```

### 6. partitioningBy() - Binary Grouping
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

// Partition into even and odd
Map<Boolean, List<Integer>> partitioned = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {false=[1, 3, 5], true=[2, 4, 6]}

// Partition with downstream collector
Map<Boolean, Long> countPartitioned = numbers.stream()
    .collect(Collectors.partitioningBy(
        n -> n % 2 == 0,
        Collectors.counting()
    ));
// {false=3, true=3}

// Partition people by age threshold
Map<Boolean, List<Person>> partitionedPeople = people.stream()
    .collect(Collectors.partitioningBy(p -> p.getAge() >= 30));
```

---

## üî¢ Numeric Collectors

### 7. counting()
```java
long count = names.stream()
    .collect(Collectors.counting());

// Used with grouping
Map<String, Long> counts = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));
```

### 8. summingInt() / averagingInt()
```java
List<Person> people = getPeople();

// Sum of ages
int totalAge = people.stream()
    .collect(Collectors.summingInt(Person::getAge));

// Average age
double avgAge = people.stream()
    .collect(Collectors.averagingInt(Person::getAge));

// Also: summingLong, summingDouble, averagingLong, averagingDouble
```

### 9. summarizingInt()
```java
IntSummaryStatistics stats = people.stream()
    .collect(Collectors.summarizingInt(Person::getAge));

System.out.println("Count: " + stats.getCount());
System.out.println("Sum: " + stats.getSum());
System.out.println("Min: " + stats.getMin());
System.out.println("Max: " + stats.getMax());
System.out.println("Average: " + stats.getAverage());
```

### 10. minBy() / maxBy()
```java
Optional<Person> youngest = people.stream()
    .collect(Collectors.minBy(Comparator.comparingInt(Person::getAge)));

Optional<Person> oldest = people.stream()
    .collect(Collectors.maxBy(Comparator.comparingInt(Person::getAge)));
```

---

## üîÑ Downstream Collectors

### mapping()
```java
// Collect names grouped by age
Map<Integer, List<String>> namesByAge = people.stream()
    .collect(Collectors.groupingBy(
        Person::getAge,
        Collectors.mapping(Person::getName, Collectors.toList())
    ));
```

### filtering() - Java 9+
```java
// Group by city, but only people over 25
Map<String, List<Person>> filtered = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.filtering(p -> p.getAge() > 25, Collectors.toList())
    ));
```

### flatMapping() - Java 9+
```java
// If Person has List<String> hobbies
Map<String, List<String>> hobbiesByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.flatMapping(
            p -> p.getHobbies().stream(),
            Collectors.toSet()
        )
    ));
```

### collectingAndThen()
```java
// Collect to list and make immutable
List<String> immutableList = names.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        Collections::unmodifiableList
    ));

// Get most common age
Optional<Integer> mostCommonAge = people.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.groupingBy(Person::getAge, Collectors.counting()),
        map -> map.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
    ));
```

---

## üéØ Advanced Examples

### Example 1: Top N Elements
```java
List<String> top3 = names.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        list -> list.stream()
            .sorted(Comparator.comparingInt(String::length).reversed())
            .limit(3)
            .collect(Collectors.toList())
    ));
```

### Example 2: Complex Grouping
```java
// Group by city, then by age range
Map<String, Map<String, List<Person>>> grouped = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.groupingBy(p -> {
            int age = p.getAge();
            if (age < 25) return "Young";
            else if (age < 40) return "Middle";
            else return "Senior";
        })
    ));
```

### Example 3: Custom Collector
```java
// Collect to comma-separated string
String csv = people.stream()
    .map(Person::getName)
    .collect(Collectors.joining(","));

// With statistics
Map<String, IntSummaryStatistics> statsByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.summarizingInt(Person::getAge)
    ));
```

---

## üìä Collectors Summary

| Collector | Purpose | Returns |
|-----------|---------|---------|
| toList() | Collect to List | List\<T> |
| toSet() | Collect to Set | Set\<T> |
| toMap() | Collect to Map | Map<K,V> |
| joining() | Join strings | String |
| groupingBy() | Group elements | Map<K,List\<T>> |
| partitioningBy() | Binary grouping | Map<Boolean,List\<T>> |
| counting() | Count elements | Long |
| summingInt() | Sum values | Integer |
| averagingInt() | Average values | Double |
| summarizingInt() | Statistics | IntSummaryStatistics |
| minBy() / maxBy() | Min/Max element | Optional\<T> |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use toList() for simple cases | Most common collector |
| ‚úÖ groupingBy for categorization | Group by key |
| ‚úÖ partitioningBy for binary split | Better than groupingBy with boolean |
| ‚úÖ Downstream collectors for complex ops | mapping, filtering, counting |
| ‚úÖ collectingAndThen for transformations | Apply function to result |
| ‚ùå Avoid nested streams in collectors | Can hurt readability |

---

## üîó Related Topics

- [Terminal Operations](04.%20Terminal%20Operations.md)
- [Stream Performance](07.%20Stream%20Performance.md)
- [Common Patterns](08.%20Common%20Patterns.md)

---

## üí° Key Takeaways

- Collectors provide powerful data aggregation
- toList/toSet/toMap for basic collection
- groupingBy for categorization by key
- partitioningBy for binary classification
- Downstream collectors enable complex operations
- joining for string concatenation
- summarizingInt provides statistics efficiently
- collectingAndThen applies transformation to result
- Custom collectors possible via Collector.of()
