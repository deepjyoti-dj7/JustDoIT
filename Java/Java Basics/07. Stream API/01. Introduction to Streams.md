# üåä Introduction to Streams

## üìñ Overview

**Stream API** provides a functional approach to process collections of objects. Introduced in Java 8, it enables declarative data processing with support for sequential and parallel execution.

**Key Characteristics:**
- Not a data structure - doesn't store elements
- Functional in nature - operations produce results without modifying source
- Lazy evaluation - intermediate operations are deferred
- Possibly unbounded - infinite streams are possible
- Consumable - can only be traversed once

---

## üîÑ Stream Pipeline

Every stream operation follows this pattern:

```
Source ‚Üí Intermediate Operations ‚Üí Terminal Operation
```

**Example:**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

List<String> result = names.stream()              // Source
    .filter(s -> s.length() > 3)                  // Intermediate
    .map(String::toUpperCase)                     // Intermediate
    .sorted()                                     // Intermediate
    .collect(Collectors.toList());                // Terminal
```

---

## üíª Quick Examples

### Example 1: Basic Stream Operations
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum of squares of even numbers
int sum = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .reduce(0, Integer::sum);

System.out.println(sum);  // Output: 20
```

### Example 2: Lazy Evaluation
```java
Stream<Integer> stream = Arrays.asList(1, 2, 3, 4).stream()
    .filter(n -> {
        System.out.println("Filtering: " + n);
        return n > 2;
    })
    .map(n -> {
        System.out.println("Mapping: " + n);
        return n * 2;
    });

// Nothing printed yet - operations are lazy
System.out.println("Stream created");

// Now operations execute
stream.forEach(System.out::println);
```

---

## üìä Operation Types

| Type | Description | Examples |
|------|-------------|----------|
| **Intermediate** | Returns a stream, lazy | filter, map, flatMap, sorted, distinct, limit, skip |
| **Terminal** | Produces result or side-effect | forEach, collect, reduce, count, findFirst, anyMatch |

---

## ‚úÖ When to Use Streams

| Use Streams | Avoid Streams |
|-------------|---------------|
| Complex data transformations | Simple iterations |
| Filtering and mapping | Modifying existing collection in place |
| Aggregations (sum, average) | When side effects are primary goal |
| Parallel processing | When order and state matter critically |
| Functional-style code | Performance-critical tight loops |

---

## ‚ö° Key Benefits

1. **Declarative** - Focus on *what* not *how*
2. **Composable** - Chain multiple operations
3. **Parallelizable** - Easy parallel execution
4. **Lazy** - Efficient evaluation
5. **Readable** - Cleaner than loops

---

## ‚ö†Ô∏è Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Reusing streams | IllegalStateException | Create new stream |
| Stateful lambdas | Race conditions in parallel | Use stateless operations |
| Boxing overhead | Performance cost | Use IntStream, LongStream, DoubleStream |
| Forgetting terminal op | Nothing executes | Always end with terminal operation |
| Infinite streams | OutOfMemoryError | Use limit() or takeWhile() |

---

## üéØ Quick Reference

```java
// Creation
Stream<String> stream = list.stream();
IntStream numbers = IntStream.range(1, 10);

// Intermediate (lazy)
stream.filter(predicate)
      .map(function)
      .sorted();

// Terminal (eager)
stream.collect(Collectors.toList());
stream.forEach(System.out::println);
long count = stream.count();
```

---

## üîó Related Topics

- [Creating Streams](02.%20Creating%20Streams.md)
- [Intermediate Operations](03.%20Intermediate%20Operations.md)
- [Terminal Operations](04.%20Terminal%20Operations.md)
- [Lambda Expressions](../06.%20Lambda%20%26%20Functional%20Programming/01.%20Lambda%20Expressions.md)

---

## üí° Key Takeaways

- Streams enable functional-style operations on data
- Pipeline: Source ‚Üí Intermediate Ops ‚Üí Terminal Op
- Lazy evaluation improves performance
- Streams are single-use and cannot be reused
- Use primitive streams to avoid boxing
- Prefer streams for complex transformations
- Easy parallelization with parallelStream()
