# üìÅ File Class

## üìñ Overview

The **File** class represents file and directory pathnames. It's part of the legacy `java.io` package (before NIO.2).

**Package:** `java.io.File`

**Note:** For new code, prefer `java.nio.file.Path` and `Files` class.

---

## üíª Creating File Objects

```java
import java.io.File;

// Different ways to create File objects
File file1 = new File("data.txt");
File file2 = new File("/home/user/data.txt");
File file3 = new File("C:\\Users\\user\\data.txt");  // Windows

// Parent directory + filename
File file4 = new File("/home/user", "data.txt");

// Using parent File object
File parent = new File("/home/user");
File file5 = new File(parent, "data.txt");

// Separator (platform-independent)
String path = "folder" + File.separator + "file.txt";
File file6 = new File(path);
```

---

## üîç Checking File Properties

```java
File file = new File("data.txt");

// Existence
boolean exists = file.exists();

// Type checks
boolean isFile = file.isFile();
boolean isDir = file.isDirectory();

// Permissions
boolean canRead = file.canRead();
boolean canWrite = file.canWrite();
boolean canExecute = file.canExecute();

// Hidden file
boolean isHidden = file.isHidden();

// Absolute path
boolean isAbsolute = file.isAbsolute();
```

---

## üìä File Information

```java
File file = new File("data.txt");

// Name and path
String name = file.getName();              // "data.txt"
String path = file.getPath();              // relative or absolute
String absPath = file.getAbsolutePath();   // absolute path
String canonicalPath = file.getCanonicalPath(); // resolves symlinks

// Parent
String parent = file.getParent();          // parent directory
File parentFile = file.getParentFile();

// Size (in bytes)
long size = file.length();

// Last modified
long lastModified = file.lastModified();
Date date = new Date(lastModified);
```

---

## üî® File Operations

### Creating Files and Directories

```java
// Create new file
File file = new File("newfile.txt");
boolean created = file.createNewFile();  // Returns false if exists

// Create directory
File dir = new File("newfolder");
boolean dirCreated = dir.mkdir();        // Single directory

// Create nested directories
File nestedDir = new File("parent/child/grandchild");
boolean dirsCreated = nestedDir.mkdirs(); // All parent directories
```

### Deleting Files and Directories

```java
File file = new File("file.txt");
boolean deleted = file.delete();  // Returns false if doesn't exist

// Directory must be empty to delete
File dir = new File("folder");
if (dir.isDirectory() && dir.list().length == 0) {
    dir.delete();
}

// Delete on JVM exit
file.deleteOnExit();
```

### Renaming/Moving Files

```java
File oldFile = new File("old.txt");
File newFile = new File("new.txt");

boolean renamed = oldFile.renameTo(newFile);
```

### Modifying Properties

```java
File file = new File("data.txt");

// Set permissions
file.setReadable(true);
file.setWritable(true);
file.setExecutable(true);

// Set read-only
file.setReadOnly();

// Set last modified time
long time = System.currentTimeMillis();
file.setLastModified(time);
```

---

## üìÇ Directory Operations

### Listing Directory Contents

```java
File dir = new File("/home/user");

// Array of names
String[] files = dir.list();

// Array of File objects
File[] fileObjects = dir.listFiles();

// With filter
String[] txtFiles = dir.list((dir, name) -> name.endsWith(".txt"));

File[] largeFiles = dir.listFiles(file -> file.length() > 1024);
```

### List Roots (Drive Letters)

```java
File[] roots = File.listRoots();
for (File root : roots) {
    System.out.println(root.getAbsolutePath());
}
// Windows: C:\, D:\
// Unix: /
```

---

## üéØ Complete Examples

### Example 1: Check and Create File

```java
import java.io.File;
import java.io.IOException;

public class FileExample {
    public static void main(String[] args) {
        File file = new File("data.txt");
        
        if (!file.exists()) {
            try {
                boolean created = file.createNewFile();
                System.out.println("File created: " + created);
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("File already exists");
            System.out.println("Size: " + file.length() + " bytes");
            System.out.println("Readable: " + file.canRead());
        }
    }
}
```

### Example 2: List Directory Recursively

```java
public class RecursiveListing {
    public static void listFiles(File dir, String indent) {
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                System.out.println(indent + file.getName());
                if (file.isDirectory()) {
                    listFiles(file, indent + "  ");
                }
            }
        }
    }
    
    public static void main(String[] args) {
        listFiles(new File("."), "");
    }
}
```

### Example 3: File Information

```java
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class FileInfo {
    public static void printInfo(File file) {
        if (!file.exists()) {
            System.out.println("File does not exist");
            return;
        }
        
        System.out.println("Name: " + file.getName());
        System.out.println("Path: " + file.getAbsolutePath());
        System.out.println("Size: " + file.length() + " bytes");
        System.out.println("Directory: " + file.isDirectory());
        System.out.println("File: " + file.isFile());
        System.out.println("Hidden: " + file.isHidden());
        System.out.println("Readable: " + file.canRead());
        System.out.println("Writable: " + file.canWrite());
        
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date lastModified = new Date(file.lastModified());
        System.out.println("Last Modified: " + sdf.format(lastModified));
    }
}
```

### Example 4: Delete Directory Recursively

```java
public class DirectoryDelete {
    public static boolean deleteDirectory(File dir) {
        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File file : files) {
                    deleteDirectory(file);
                }
            }
        }
        return dir.delete();
    }
    
    public static void main(String[] args) {
        File dir = new File("temp");
        if (deleteDirectory(dir)) {
            System.out.println("Directory deleted");
        }
    }
}
```

---

## üìä File Class Methods Summary

| Method | Description | Returns |
|--------|-------------|---------|
| exists() | Check if exists | boolean |
| isFile() | Check if file | boolean |
| isDirectory() | Check if directory | boolean |
| createNewFile() | Create new file | boolean |
| mkdir() | Create directory | boolean |
| mkdirs() | Create nested directories | boolean |
| delete() | Delete file/directory | boolean |
| renameTo(File) | Rename/move | boolean |
| getName() | Get filename | String |
| getAbsolutePath() | Get absolute path | String |
| length() | Get file size | long |
| lastModified() | Get last modified time | long |
| list() | List directory contents | String[] |
| listFiles() | List as File objects | File[] |

---

## ‚ö†Ô∏è Limitations and Issues

| Issue | Description | Solution |
|-------|-------------|----------|
| No exception on failure | Methods return false | Use NIO.2 Files class |
| Limited metadata | Basic info only | Use NIO.2 for attributes |
| Poor error messages | Hard to debug | Use Files.walkFileTree() |
| No atomic operations | Race conditions | Use NIO.2 atomic moves |
| Platform-dependent | Path separators | Use File.separator or Path API |

---

## ‚ö° Best Practices

- ‚úÖ Use `File.separator` for platform independence
- ‚úÖ Check `exists()` before operations
- ‚úÖ Handle `IOException` for file creation
- ‚úÖ Close streams properly (use try-with-resources)
- ‚úÖ Use `mkdirs()` instead of `mkdir()` for nested directories
- ‚ùå Don't use for new code - prefer NIO.2 Path API
- ‚ùå Don't ignore return values
- ‚ùå Don't forget to delete temporary files

---

## üîó Related Topics

- [NIO Files Class](05.%20NIO%20Files%20Class.md)
- [Path & Paths](06.%20Path%20%26%20Paths.md)
- [Reading Files](02.%20Reading%20Files.md)

---

## üí° Key Takeaways

- File class represents file/directory pathnames
- Legacy API - prefer NIO.2 for new code
- Methods return boolean - check return values
- No automatic exception throwing
- Platform-independent with File.separator
- Can check existence, type, permissions, size
- mkdir() for single, mkdirs() for nested directories
- delete() requires empty directory
- listFiles() for directory traversal
