# üìÇ NIO Files Class

## üìñ Overview

The **Files** class (Java NIO.2, introduced in Java 7) provides modern, powerful file operations. It's the recommended way to work with files in modern Java.

**Package:** `java.nio.file.Files`

**Benefits:**
- Exception-based error handling (not boolean returns)
- Better performance
- Atomic operations
- Rich set of utility methods
- Works with Path objects

---

## üíª Reading Files

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.*;
import java.util.stream.Stream;

// Read all lines
List<String> lines = Files.readAllLines(Paths.get("file.txt"));

// Read as String (Java 11+)
String content = Files.readString(Paths.get("file.txt"));

// Read all bytes
byte[] bytes = Files.readAllBytes(Paths.get("file.bin"));

// Stream lines (lazy loading)
try (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {
    lines.forEach(System.out::println);
}

// With charset
List<String> lines = Files.readAllLines(
    Paths.get("file.txt"),
    StandardCharsets.UTF_8
);
```

---

## üíª Writing Files

```java
// Write String (Java 11+)
Files.writeString(Paths.get("file.txt"), "Hello, World!");

// Write lines
List<String> lines = Arrays.asList("Line 1", "Line 2");
Files.write(Paths.get("file.txt"), lines);

// Write bytes
byte[] bytes = "Hello".getBytes();
Files.write(Paths.get("file.bin"), bytes);

// Append mode
Files.writeString(
    Paths.get("file.txt"),
    "\nNew line",
    StandardOpenOption.APPEND
);

// With options
Files.write(
    Paths.get("file.txt"),
    lines,
    StandardCharsets.UTF_8,
    StandardOpenOption.CREATE,
    StandardOpenOption.TRUNCATE_EXISTING
);
```

---

## üíª File Operations

### Creating Files and Directories

```java
// Create file
Path file = Files.createFile(Paths.get("newfile.txt"));

// Create directory
Path dir = Files.createDirectory(Paths.get("newfolder"));

// Create nested directories
Path dirs = Files.createDirectories(Paths.get("a/b/c"));

// Create temp file
Path temp = Files.createTempFile("prefix", ".txt");
Path temp2 = Files.createTempFile(Paths.get("/tmp"), "prefix", ".txt");

// Create temp directory
Path tempDir = Files.createTempDirectory("prefix");
```

### Copying Files

```java
// Simple copy
Files.copy(
    Paths.get("source.txt"),
    Paths.get("dest.txt")
);

// With options
Files.copy(
    Paths.get("source.txt"),
    Paths.get("dest.txt"),
    StandardCopyOption.REPLACE_EXISTING,
    StandardCopyOption.COPY_ATTRIBUTES
);

// Copy from InputStream
try (InputStream in = new FileInputStream("source.txt")) {
    Files.copy(in, Paths.get("dest.txt"));
}

// Copy to OutputStream
try (OutputStream out = new FileOutputStream("dest.txt")) {
    Files.copy(Paths.get("source.txt"), out);
}
```

### Moving Files

```java
// Simple move
Files.move(
    Paths.get("old.txt"),
    Paths.get("new.txt")
);

// With options
Files.move(
    Paths.get("old.txt"),
    Paths.get("new.txt"),
    StandardCopyOption.REPLACE_EXISTING,
    StandardCopyOption.ATOMIC_MOVE
);
```

### Deleting Files

```java
// Delete file (throws exception if doesn't exist)
Files.delete(Paths.get("file.txt"));

// Delete if exists (no exception)
boolean deleted = Files.deleteIfExists(Paths.get("file.txt"));
```

---

## üíª Checking File Properties

```java
Path path = Paths.get("file.txt");

// Existence
boolean exists = Files.exists(path);
boolean notExists = Files.notExists(path);

// Type
boolean isRegular = Files.isRegularFile(path);
boolean isDir = Files.isDirectory(path);
boolean isSymLink = Files.isSymbolicLink(path);

// Permissions
boolean readable = Files.isReadable(path);
boolean writable = Files.isWritable(path);
boolean executable = Files.isExecutable(path);

// Hidden
boolean hidden = Files.isHidden(path);

// Same file
boolean same = Files.isSameFile(path1, path2);

// Size
long size = Files.size(path);

// Last modified
FileTime modified = Files.getLastModifiedTime(path);
```

---

## üíª Directory Listing

```java
// List directory
try (Stream<Path> paths = Files.list(Paths.get("."))) {
    paths.forEach(System.out::println);
}

// Walk file tree (depth-first)
try (Stream<Path> paths = Files.walk(Paths.get("."))) {
    paths.filter(Files::isRegularFile)
         .forEach(System.out::println);
}

// Walk with max depth
try (Stream<Path> paths = Files.walk(Paths.get("."), 2)) {
    paths.forEach(System.out::println);
}

// Find files
try (Stream<Path> paths = Files.find(
        Paths.get("."),
        Integer.MAX_VALUE,
        (path, attrs) -> path.toString().endsWith(".txt"))) {
    
    paths.forEach(System.out::println);
}
```

---

## üíª File Attributes

```java
Path path = Paths.get("file.txt");

// Basic attributes
BasicFileAttributes attrs = Files.readAttributes(
    path,
    BasicFileAttributes.class
);

System.out.println("Size: " + attrs.size());
System.out.println("Created: " + attrs.creationTime());
System.out.println("Modified: " + attrs.lastModifiedTime());
System.out.println("Accessed: " + attrs.lastAccessTime());
System.out.println("Directory: " + attrs.isDirectory());
System.out.println("Regular file: " + attrs.isRegularFile());
System.out.println("Symbolic link: " + attrs.isSymbolicLink());

// Set attributes
Files.setAttribute(path, "dos:hidden", true);
Files.setAttribute(path, "dos:readonly", true);

// Get attribute
Object hidden = Files.getAttribute(path, "dos:hidden");

// Set times
FileTime now = FileTime.fromMillis(System.currentTimeMillis());
Files.setLastModifiedTime(path, now);
```

---

## üíª File Store Information

```java
Path path = Paths.get("file.txt");
FileStore store = Files.getFileStore(path);

System.out.println("Name: " + store.name());
System.out.println("Type: " + store.type());
System.out.println("Total space: " + store.getTotalSpace() / (1024 * 1024) + " MB");
System.out.println("Usable space: " + store.getUsableSpace() / (1024 * 1024) + " MB");
System.out.println("Unallocated: " + store.getUnallocatedSpace() / (1024 * 1024) + " MB");
System.out.println("Read-only: " + store.isReadOnly());
```

---

## üéØ Complete Examples

### Example 1: Copy Directory Recursively

```java
public class DirectoryCopy {
    public static void copyDirectory(Path source, Path target) throws IOException {
        Files.walk(source)
             .forEach(src -> {
                 try {
                     Path dest = target.resolve(source.relativize(src));
                     if (Files.isDirectory(src)) {
                         Files.createDirectories(dest);
                     } else {
                         Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);
                     }
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
             });
    }
}
```

### Example 2: Delete Directory Recursively

```java
public class DirectoryDelete {
    public static void deleteDirectory(Path path) throws IOException {
        if (Files.exists(path)) {
            Files.walk(path)
                 .sorted(Comparator.reverseOrder())
                 .forEach(p -> {
                     try {
                         Files.delete(p);
                     } catch (IOException e) {
                         e.printStackTrace();
                     }
                 });
        }
    }
}
```

### Example 3: Find Files by Extension

```java
public class FileFinder {
    public static List<Path> findFiles(Path start, String extension) {
        List<Path> result = new ArrayList<>();
        
        try (Stream<Path> paths = Files.walk(start)) {
            result = paths
                .filter(Files::isRegularFile)
                .filter(p -> p.toString().endsWith(extension))
                .collect(Collectors.toList());
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        List<Path> javaFiles = findFiles(Paths.get("."), ".java");
        javaFiles.forEach(System.out::println);
    }
}
```

### Example 4: Calculate Directory Size

```java
public class DirectorySize {
    public static long calculateSize(Path path) throws IOException {
        if (Files.isRegularFile(path)) {
            return Files.size(path);
        }
        
        try (Stream<Path> paths = Files.walk(path)) {
            return paths
                .filter(Files::isRegularFile)
                .mapToLong(p -> {
                    try {
                        return Files.size(p);
                    } catch (IOException e) {
                        return 0L;
                    }
                })
                .sum();
        }
    }
    
    public static void main(String[] args) throws IOException {
        long size = calculateSize(Paths.get("."));
        System.out.println("Size: " + size / (1024 * 1024) + " MB");
    }
}
```

### Example 5: File Content Comparison

```java
public class FileComparator {
    public static boolean areFilesEqual(Path path1, Path path2) {
        try {
            // Quick check: size
            if (Files.size(path1) != Files.size(path2)) {
                return false;
            }
            
            // Compare bytes
            byte[] bytes1 = Files.readAllBytes(path1);
            byte[] bytes2 = Files.readAllBytes(path2);
            
            return Arrays.equals(bytes1, bytes2);
            
        } catch (IOException e) {
            return false;
        }
    }
    
    // For large files - use mismatch() (Java 12+)
    public static boolean areFilesEqualLarge(Path path1, Path path2) {
        try {
            return Files.mismatch(path1, path2) == -1;
        } catch (IOException e) {
            return false;
        }
    }
}
```

---

## üìä Files vs File Class

| Feature | Files (NIO.2) | File (Legacy) |
|---------|---------------|---------------|
| **API** | Modern, clean | Legacy |
| **Errors** | Exceptions | Boolean returns |
| **Performance** | Better | Slower |
| **Atomic ops** | Yes | No |
| **Attributes** | Rich | Basic |
| **Path handling** | Path object | String-based |
| **Recommended** | ‚úÖ Yes | ‚ùå No |

---

## üìä StandardCopyOption

| Option | Description |
|--------|-------------|
| REPLACE_EXISTING | Replace if target exists |
| COPY_ATTRIBUTES | Copy file attributes |
| ATOMIC_MOVE | Atomic move operation |

---

## üìä StandardOpenOption

| Option | Description |
|--------|-------------|
| READ | Open for reading |
| WRITE | Open for writing |
| APPEND | Append to end |
| TRUNCATE_EXISTING | Truncate to 0 bytes |
| CREATE | Create if doesn't exist |
| CREATE_NEW | Create, fail if exists |
| DELETE_ON_CLOSE | Delete when closed |
| SPARSE | Sparse file |
| SYNC | Synchronous I/O |
| DSYNC | Synchronous data I/O |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Files class | Modern and powerful |
| ‚úÖ Use try-with-resources | For streams |
| ‚úÖ Specify charset | UTF-8 recommended |
| ‚úÖ Handle IOException | Always catch |
| ‚úÖ Use atomic operations | For critical files |
| ‚úÖ Close streams | Especially Files.walk/lines |
| ‚ùå Don't load huge files | Use streaming |
| ‚ùå Don't ignore exceptions | Check errors |

---

## üîó Related Topics

- [Path & Paths](06.%20Path%20%26%20Paths.md)
- [Reading Files](02.%20Reading%20Files.md)
- [Writing Files](03.%20Writing%20Files.md)

---

## üí° Key Takeaways

- Files class is modern replacement for File
- Exception-based error handling
- Rich set of utility methods
- Works with Path objects
- Better performance than legacy API
- Atomic operations available
- Stream-based directory traversal
- Files.walk() for recursive operations
- Always close streams (use try-with-resources)
- Prefer Files class for all new code
