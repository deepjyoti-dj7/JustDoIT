# üíæ Serialization

## üìñ Overview

**Serialization** is the process of converting an object into a byte stream for storage or transmission. **Deserialization** is the reverse process of reconstructing the object from bytes.

**Use Cases:**
- Saving object state to disk
- Sending objects over network
- Caching objects
- Deep cloning objects

---

## üíª Basic Serialization

### Making a Class Serializable

```java
import java.io.Serializable;

public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
    private String email;
    
    // Constructors, getters, setters
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
}
```

**Key Points:**
- Implement `Serializable` interface (marker interface)
- Add `serialVersionUID` for version control
- All fields must be serializable or transient

---

## üíª Writing Objects (Serialization)

```java
import java.io.*;

public class SerializeExample {
    public static void main(String[] args) {
        Person person = new Person("Alice", 25, "alice@example.com");
        
        try (ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream("person.ser"))) {
            
            out.writeObject(person);
            System.out.println("Object serialized");
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üíª Reading Objects (Deserialization)

```java
public class DeserializeExample {
    public static void main(String[] args) {
        try (ObjectInputStream in = new ObjectInputStream(
                new FileInputStream("person.ser"))) {
            
            Person person = (Person) in.readObject();
            System.out.println("Object deserialized: " + person);
            
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üíª Multiple Objects

```java
// Write multiple objects
try (ObjectOutputStream out = new ObjectOutputStream(
        new FileOutputStream("people.ser"))) {
    
    out.writeObject(person1);
    out.writeObject(person2);
    out.writeObject(person3);
}

// Read multiple objects
try (ObjectInputStream in = new ObjectInputStream(
        new FileInputStream("people.ser"))) {
    
    Person p1 = (Person) in.readObject();
    Person p2 = (Person) in.readObject();
    Person p3 = (Person) in.readObject();
}
```

---

## üíª Transient Fields

```java
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String username;
    private transient String password;  // Not serialized
    private transient int loginAttempts;  // Not serialized
    
    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}

// After deserialization:
// username is restored
// password is null
// loginAttempts is 0
```

---

## üíª Static Fields

```java
public class Config implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private static String globalConfig;  // NOT serialized (static)
    
    // Static fields belong to class, not instance
}
```

---

## üíª Custom Serialization

### Using writeObject() and readObject()

```java
public class Person implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private transient String password;
    
    // Custom serialization
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();  // Write non-transient fields
        
        // Custom logic
        String encrypted = encrypt(password);
        out.writeObject(encrypted);
    }
    
    // Custom deserialization
    private void readObject(ObjectInputStream in) 
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();  // Read non-transient fields
        
        // Custom logic
        String encrypted = (String) in.readObject();
        this.password = decrypt(encrypted);
    }
    
    private String encrypt(String s) { return s; }  // Simplified
    private String decrypt(String s) { return s; }
}
```

---

## üíª Externalizable Interface

```java
import java.io.Externalizable;

public class Person implements Externalizable {
    private String name;
    private int age;
    
    // Required no-arg constructor
    public Person() {}
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(name);
        out.writeInt(age);
    }
    
    @Override
    public void readExternal(ObjectInput in) 
            throws IOException, ClassNotFoundException {
        name = in.readUTF();
        age = in.readInt();
    }
}
```

**Externalizable vs Serializable:**
- Externalizable: Complete control, must implement methods
- Serializable: Automatic, less control

---

## üíª SerialVersionUID

```java
public class Person implements Serializable {
    // Explicit version UID
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
}
```

**Purpose:**
- Version control for serialized objects
- Prevents `InvalidClassException` during deserialization
- Change when class structure changes incompatibly

**Generate UID:**
```bash
serialver Person
# Output: Person: static final long serialVersionUID = 1234567890L;
```

---

## üéØ Complete Examples

### Example 1: Save/Load Object

```java
public class SaveLoad {
    public static void save(Object obj, String filename) {
        try (ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream(filename))) {
            out.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static Object load(String filename) {
        try (ObjectInputStream in = new ObjectInputStream(
                new FileInputStream(filename))) {
            return in.readObject();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
    
    public static void main(String[] args) {
        Person person = new Person("Alice", 25, "alice@example.com");
        
        save(person, "person.ser");
        Person loaded = (Person) load("person.ser");
        
        System.out.println(loaded);
    }
}
```

### Example 2: Serialize Collection

```java
public class CollectionSerialization {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "alice@example.com"),
            new Person("Bob", 30, "bob@example.com")
        );
        
        // Serialize
        try (ObjectOutputStream out = new ObjectOutputStream(
                new FileOutputStream("people.ser"))) {
            out.writeObject(people);
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // Deserialize
        try (ObjectInputStream in = new ObjectInputStream(
                new FileInputStream("people.ser"))) {
            @SuppressWarnings("unchecked")
            List<Person> loaded = (List<Person>) in.readObject();
            loaded.forEach(System.out::println);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### Example 3: Deep Copy Using Serialization

```java
public class DeepCopy {
    @SuppressWarnings("unchecked")
    public static <T extends Serializable> T deepCopy(T object) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(bos);
            out.writeObject(object);
            out.close();
            
            ByteArrayInputStream bis = new ByteArrayInputStream(
                bos.toByteArray());
            ObjectInputStream in = new ObjectInputStream(bis);
            return (T) in.readObject();
            
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }
    }
    
    public static void main(String[] args) {
        Person original = new Person("Alice", 25, "alice@example.com");
        Person copy = deepCopy(original);
        
        System.out.println("Original: " + original);
        System.out.println("Copy: " + copy);
        System.out.println("Same object? " + (original == copy));  // false
    }
}
```

### Example 4: Versioning Example

```java
// Version 1
public class PersonV1 implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int age;
}

// Version 2 - Added email field
public class PersonV2 implements Serializable {
    private static final long serialVersionUID = 1L;  // Same UID
    
    private String name;
    private int age;
    private String email = "unknown@example.com";  // Default value
    
    // Can deserialize V1 objects - email gets default value
}

// Version 3 - Incompatible change
public class PersonV3 implements Serializable {
    private static final long serialVersionUID = 2L;  // Changed UID
    
    private String fullName;  // Changed field name
    private int age;
    
    // Cannot deserialize V1 or V2 objects
}
```

---

## ‚ö†Ô∏è Inheritance and Serialization

```java
// Parent not serializable
class Animal {
    String species;
    
    public Animal(String species) {
        this.species = species;
    }
}

// Child serializable
class Dog extends Animal implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name;
    
    public Dog(String species, String name) {
        super(species);
        this.name = name;
    }
    
    // Parent fields NOT automatically serialized
    // Parent must have no-arg constructor
}
```

---

## üìä Serialization Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Always add serialVersionUID | Version control |
| ‚úÖ Mark sensitive fields transient | Security |
| ‚úÖ Implement readObject/writeObject | Custom logic |
| ‚úÖ Consider Externalizable | Performance-critical |
| ‚úÖ Validate deserialized objects | Security |
| ‚úÖ Use try-with-resources | Proper cleanup |
| ‚ùå Don't serialize sensitive data | Security risk |
| ‚ùå Don't rely on default serialization | Limited control |
| ‚ùå Don't serialize non-serializable fields | Runtime error |

---

## ‚ö†Ô∏è Common Issues

| Issue | Cause | Solution |
|-------|-------|----------|
| NotSerializableException | Non-serializable field | Make field transient |
| InvalidClassException | Version mismatch | Update serialVersionUID |
| ClassNotFoundException | Class not in classpath | Include class |
| Null transient fields | Default after deserialization | Initialize in readObject() |
| Performance issues | Large object graphs | Consider alternatives |

---

## üîÑ Alternatives to Java Serialization

```java
// JSON (using Gson)
Gson gson = new Gson();
String json = gson.toJson(person);
Person person = gson.fromJson(json, Person.class);

// JSON (using Jackson)
ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(person);
Person person = mapper.readValue(json, Person.class);

// XML (using JAXB)
JAXBContext context = JAXBContext.newInstance(Person.class);
Marshaller marshaller = context.createMarshaller();
marshaller.marshal(person, new File("person.xml"));

// Protocol Buffers, Avro, etc.
```

---

## üìä Serialization Comparison

| Format | Size | Speed | Readability | Cross-language |
|--------|------|-------|-------------|----------------|
| Java Serialization | Large | Medium | No | No |
| JSON | Medium | Fast | Yes | Yes |
| XML | Large | Slow | Yes | Yes |
| Protocol Buffers | Small | Very Fast | No | Yes |
| Avro | Small | Very Fast | No | Yes |

---

## üîó Related Topics

- [Reading Files](02.%20Reading%20Files.md)
- [Writing Files](03.%20Writing%20Files.md)
- [NIO Files Class](05.%20NIO%20Files%20Class.md)

---

## üí° Key Takeaways

- Serialization converts objects to byte streams
- Implement Serializable interface
- Add serialVersionUID for version control
- Use transient for non-serialized fields
- Static fields are NOT serialized
- Custom serialization with writeObject/readObject
- Externalizable for full control
- Security concerns with deserialization
- Consider JSON/Protocol Buffers for cross-platform
- Always validate deserialized objects
