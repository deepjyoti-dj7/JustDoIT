# üéØ Method References

## üìñ Overview

**Method references** are shorthand notation for lambda expressions that call a specific method. They provide a more concise and readable way to refer to methods without executing them.

**Key Features:**
- Shorthand for lambda expressions
- More readable and concise
- Four types: Static, Instance, Constructor, Arbitrary Object
- Uses `::` operator

**Syntax:** `ClassName::methodName` or `objectName::methodName`

**Introduced in:** Java 8 (2014)

---

## üéØ Types of Method References

| Type | Syntax | Lambda Equivalent | Example |
|------|--------|-------------------|---------|
| **Static** | `ClassName::staticMethod` | `(args) -> ClassName.staticMethod(args)` | `Math::max` |
| **Instance (Bound)** | `instance::instanceMethod` | `(args) -> instance.instanceMethod(args)` | `str::length` |
| **Instance (Unbound)** | `ClassName::instanceMethod` | `(obj, args) -> obj.instanceMethod(args)` | `String::toLowerCase` |
| **Constructor** | `ClassName::new` | `(args) -> new ClassName(args)` | `ArrayList::new` |

---

## üíª Example 1: Static Method Reference

```java
import java.util.*;
import java.util.function.*;

public class StaticMethodReference {
    
    // Custom static methods
    public static int square(int n) {
        return n * n;
    }
    
    public static boolean isEven(int n) {
        return n % 2 == 0;
    }
    
    public static String formatNumber(int n) {
        return String.format("Number: %d", n);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Static Method Reference ===\n");
        
        // 1. Built-in static methods
        System.out.println("1. Built-in Static Methods:");
        
        // Lambda: (a, b) -> Math.max(a, b)
        BinaryOperator<Integer> maxLambda = (a, b) -> Math.max(a, b);
        // Method reference
        BinaryOperator<Integer> maxRef = Math::max;
        
        System.out.println("Max using lambda: " + maxLambda.apply(10, 20));
        System.out.println("Max using method ref: " + maxRef.apply(10, 20));
        
        // Lambda: (a, b) -> Integer.compare(a, b)
        Comparator<Integer> compareLambda = (a, b) -> Integer.compare(a, b);
        // Method reference
        Comparator<Integer> compareRef = Integer::compare;
        
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        numbers.sort(compareRef);
        System.out.println("Sorted: " + numbers);
        
        // 2. Custom static methods
        System.out.println("\n2. Custom Static Methods:");
        
        // square method reference
        Function<Integer, Integer> squareRef = StaticMethodReference::square;
        System.out.println("Square of 5: " + squareRef.apply(5));
        
        // isEven method reference
        Predicate<Integer> isEvenRef = StaticMethodReference::isEven;
        System.out.println("Is 4 even? " + isEvenRef.test(4));
        
        // formatNumber method reference
        Function<Integer, String> formatRef = StaticMethodReference::formatNumber;
        System.out.println(formatRef.apply(42));
        
        // 3. With collections
        System.out.println("\n3. With Collections:");
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5);
        
        // Using method reference with map
        nums.stream()
            .map(StaticMethodReference::square)
            .forEach(n -> System.out.print(n + " "));
        System.out.println();
        
        // Using method reference with filter
        System.out.print("Even numbers: ");
        nums.stream()
            .filter(StaticMethodReference::isEven)
            .forEach(n -> System.out.print(n + " "));
        System.out.println();
    }
}
```

**Output:**
```
=== Static Method Reference ===

1. Built-in Static Methods:
Max using lambda: 20
Max using method ref: 20
Sorted: [1, 2, 5, 8, 9]

2. Custom Static Methods:
Square of 5: 25
Is 4 even? true
Number: 42

3. With Collections:
1 4 9 16 25 
Even numbers: 2 4
```

---

## üíª Example 2: Instance Method Reference (Bound)

```java
import java.util.*;
import java.util.function.*;

public class BoundInstanceMethodReference {
    
    public static void main(String[] args) {
        System.out.println("=== Bound Instance Method Reference ===\n");
        
        // 1. String instance methods
        System.out.println("1. String Instance Methods:");
        String str = "Hello Lambda";
        
        // Lambda: () -> str.length()
        Supplier<Integer> lengthLambda = () -> str.length();
        // Method reference (bound to str)
        Supplier<Integer> lengthRef = str::length;
        
        System.out.println("Length (lambda): " + lengthLambda.get());
        System.out.println("Length (method ref): " + lengthRef.get());
        
        // Lambda: (s) -> str.concat(s)
        Function<String, String> concatLambda = (s) -> str.concat(s);
        // Method reference
        Function<String, String> concatRef = str::concat;
        
        System.out.println("Concat (method ref): " + concatRef.apply(" World"));
        
        // Lambda: (ch) -> str.indexOf(ch)
        ToIntFunction<Character> indexOfLambda = (ch) -> str.indexOf(ch);
        // Method reference
        ToIntFunction<Character> indexOfRef = str::indexOf;
        
        System.out.println("Index of 'L': " + indexOfRef.applyAsInt('L'));
        
        // 2. Custom object instance methods
        System.out.println("\n2. Custom Object Methods:");
        
        Calculator calc = new Calculator();
        
        // Method reference to instance method
        BiFunction<Integer, Integer, Integer> addRef = calc::add;
        BiFunction<Integer, Integer, Integer> multiplyRef = calc::multiply;
        
        System.out.println("5 + 3 = " + addRef.apply(5, 3));
        System.out.println("5 * 3 = " + multiplyRef.apply(5, 3));
        
        // 3. System.out::println
        System.out.println("\n3. System.out::println:");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // Lambda: name -> System.out.println(name)
        names.forEach(name -> System.out.println(name));
        
        System.out.println("\nUsing method reference:");
        // Method reference
        names.forEach(System.out::println);
    }
}

class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int multiply(int a, int b) {
        return a * b;
    }
}
```

**Output:**
```
=== Bound Instance Method Reference ===

1. String Instance Methods:
Length (lambda): 12
Length (method ref): 12
Concat (method ref): Hello Lambda World
Index of 'L': 6

2. Custom Object Methods:
5 + 3 = 8
5 * 3 = 15

3. System.out::println:
Alice
Bob
Charlie

Using method reference:
Alice
Bob
Charlie
```

---

## üíª Example 3: Instance Method Reference (Unbound)

```java
import java.util.*;
import java.util.function.*;

public class UnboundInstanceMethodReference {
    
    public static void main(String[] args) {
        System.out.println("=== Unbound Instance Method Reference ===\n");
        
        // 1. String methods (unbound)
        System.out.println("1. String Methods (Unbound):");
        
        // Lambda: (str) -> str.toUpperCase()
        Function<String, String> upperLambda = (str) -> str.toUpperCase();
        // Method reference (unbound - not tied to specific instance)
        Function<String, String> upperRef = String::toUpperCase;
        
        System.out.println("Lambda: " + upperLambda.apply("hello"));
        System.out.println("Method ref: " + upperRef.apply("hello"));
        
        // Lambda: (str) -> str.length()
        ToIntFunction<String> lengthLambda = (str) -> str.length();
        // Method reference
        ToIntFunction<String> lengthRef = String::length;
        
        System.out.println("Length: " + lengthRef.applyAsInt("Lambda"));
        
        // 2. With collections
        System.out.println("\n2. With Collections:");
        List<String> words = Arrays.asList("java", "lambda", "stream", "api");
        
        // Using unbound method reference
        words.stream()
             .map(String::toUpperCase)  // Unbound reference
             .forEach(System.out::println);
        
        // 3. Sorting with unbound method reference
        System.out.println("\n3. Sorting:");
        List<String> names = Arrays.asList("Charlie", "Alice", "Bob");
        
        // Lambda: (s1, s2) -> s1.compareToIgnoreCase(s2)
        names.sort((s1, s2) -> s1.compareToIgnoreCase(s2));
        System.out.println("Lambda sort: " + names);
        
        names = Arrays.asList("Charlie", "Alice", "Bob");
        // Method reference: first parameter becomes the object
        names.sort(String::compareToIgnoreCase);
        System.out.println("Method ref sort: " + names);
        
        // 4. BiFunction with unbound reference
        System.out.println("\n4. BiFunction:");
        
        // Lambda: (str, ch) -> str.indexOf(ch)
        BiFunction<String, String, Integer> indexOfLambda = 
            (str, ch) -> str.indexOf(ch);
        // Method reference
        BiFunction<String, String, Integer> indexOfRef = String::indexOf;
        
        System.out.println("Index of 'a' in 'Lambda': " + 
                          indexOfRef.apply("Lambda", "a"));
    }
}
```

**Output:**
```
=== Unbound Instance Method Reference ===

1. String Methods (Unbound):
Lambda: HELLO
Method ref: HELLO
Length: 6

2. With Collections:
JAVA
LAMBDA
STREAM
API

3. Sorting:
Lambda sort: [Alice, Bob, Charlie]
Method ref sort: [Alice, Bob, Charlie]

4. BiFunction:
Index of 'a' in 'Lambda': 1
```

---

## üíª Example 4: Constructor Reference

```java
import java.util.*;
import java.util.function.*;

class Person {
    private String name;
    private int age;
    
    // No-arg constructor
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // Single parameter constructor
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }
    
    // Two parameter constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return String.format("Person{name='%s', age=%d}", name, age);
    }
}

public class ConstructorReference {
    
    public static void main(String[] args) {
        System.out.println("=== Constructor Reference ===\n");
        
        // 1. No-arg constructor
        System.out.println("1. No-arg Constructor:");
        
        // Lambda: () -> new Person()
        Supplier<Person> personLambda = () -> new Person();
        // Constructor reference
        Supplier<Person> personRef = Person::new;
        
        System.out.println("Lambda: " + personLambda.get());
        System.out.println("Method ref: " + personRef.get());
        
        // 2. Single parameter constructor
        System.out.println("\n2. Single Parameter Constructor:");
        
        // Lambda: (name) -> new Person(name)
        Function<String, Person> personWithNameLambda = (name) -> new Person(name);
        // Constructor reference
        Function<String, Person> personWithNameRef = Person::new;
        
        System.out.println("Lambda: " + personWithNameLambda.apply("Alice"));
        System.out.println("Method ref: " + personWithNameRef.apply("Bob"));
        
        // 3. Two parameter constructor
        System.out.println("\n3. Two Parameter Constructor:");
        
        // Lambda: (name, age) -> new Person(name, age)
        BiFunction<String, Integer, Person> personFullLambda = 
            (name, age) -> new Person(name, age);
        // Constructor reference
        BiFunction<String, Integer, Person> personFullRef = Person::new;
        
        System.out.println("Lambda: " + personFullLambda.apply("Charlie", 30));
        System.out.println("Method ref: " + personFullRef.apply("David", 25));
        
        // 4. Creating collections
        System.out.println("\n4. Collection Constructors:");
        
        // ArrayList constructor reference
        Supplier<List<String>> listSupplier = ArrayList::new;
        List<String> list = listSupplier.get();
        list.add("Item1");
        list.add("Item2");
        System.out.println("ArrayList: " + list);
        
        // HashSet constructor reference
        Supplier<Set<Integer>> setSupplier = HashSet::new;
        Set<Integer> set = setSupplier.get();
        set.add(1);
        set.add(2);
        System.out.println("HashSet: " + set);
        
        // 5. Array constructor reference
        System.out.println("\n5. Array Constructor:");
        
        // Lambda: (size) -> new String[size]
        IntFunction<String[]> arrayLambda = (size) -> new String[size];
        // Constructor reference
        IntFunction<String[]> arrayRef = String[]::new;
        
        String[] arr = arrayRef.apply(5);
        System.out.println("Array length: " + arr.length);
        
        // With Stream toArray
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        String[] namesArray = names.stream().toArray(String[]::new);
        System.out.println("Names array: " + Arrays.toString(namesArray));
    }
}
```

**Output:**
```
=== Constructor Reference ===

1. No-arg Constructor:
Lambda: Person{name='Unknown', age=0}
Method ref: Person{name='Unknown', age=0}

2. Single Parameter Constructor:
Lambda: Person{name='Alice', age=0}
Method ref: Person{name='Bob', age=0}

3. Two Parameter Constructor:
Lambda: Person{name='Charlie', age=30}
Method ref: Person{name='David', age=25}

4. Collection Constructors:
ArrayList: [Item1, Item2]
HashSet: [1, 2]

5. Array Constructor:
Array length: 5
Names array: [Alice, Bob, Charlie]
```

---

## üíª Example 5: Method Reference vs Lambda

```java
import java.util.*;
import java.util.function.*;

public class MethodReferenceVsLambda {
    
    public static void main(String[] args) {
        System.out.println("=== Method Reference vs Lambda ===\n");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // 1. Printing - both are equivalent
        System.out.println("1. Printing (Lambda):");
        names.forEach(name -> System.out.println(name));
        
        System.out.println("\n1. Printing (Method Reference):");
        names.forEach(System.out::println);
        
        // 2. Transformation - both are equivalent
        System.out.println("\n2. Uppercase (Lambda):");
        names.stream()
             .map(name -> name.toUpperCase())
             .forEach(System.out::println);
        
        System.out.println("\n2. Uppercase (Method Reference):");
        names.stream()
             .map(String::toUpperCase)
             .forEach(System.out::println);
        
        // 3. When lambda is better (additional logic)
        System.out.println("\n3. Lambda with Additional Logic:");
        names.stream()
             .map(name -> "Hello, " + name + "!")
             .forEach(System.out::println);
        
        // 4. When method reference is better (just calling method)
        System.out.println("\n4. Method Reference (Cleaner):");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Lambda (more verbose)
        long count1 = numbers.stream()
                            .filter(n -> n % 2 == 0)
                            .count();
        
        // Method reference (if we have a method)
        Predicate<Integer> isEven = MethodReferenceVsLambda::isEvenNumber;
        long count2 = numbers.stream()
                            .filter(isEven)
                            .count();
        
        System.out.println("Even count: " + count2);
    }
    
    public static boolean isEvenNumber(int n) {
        return n % 2 == 0;
    }
}
```

---

## üíª Example 6-10: Additional Examples

```java
// Example 6: Method Reference with Comparator
import java.util.*;

class Employee {
    String name;
    int age;
    
    Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class MethodReferenceComparator {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30),
            new Employee("Bob", 25),
            new Employee("Charlie", 35)
        );
        
        // Sort by name using method reference
        employees.sort(Comparator.comparing(Employee::getName));
        System.out.println("By name: " + employees);
        
        // Sort by age using method reference
        employees.sort(Comparator.comparing(Employee::getAge));
        System.out.println("By age: " + employees);
    }
}
```

---

## üìä Method Reference Types Summary

| Type | Example | Lambda Equivalent | Use Case |
|------|---------|-------------------|----------|
| Static | `Math::max` | `(a,b) -> Math.max(a,b)` | Utility methods |
| Bound Instance | `str::length` | `() -> str.length()` | Specific object method |
| Unbound Instance | `String::length` | `str -> str.length()` | Any object of type |
| Constructor | `ArrayList::new` | `() -> new ArrayList<>()` | Object creation |
| Array Constructor | `int[]::new` | `size -> new int[size]` | Array creation |

---

## üéØ Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use method references | When lambda just calls a method |
| ‚úÖ Keep it simple | Method reference should be obvious |
| ‚úÖ Prefer readability | Choose what's more readable |
| ‚úÖ Use with streams | Great with map, filter, forEach |
| ‚úÖ Static methods | Good candidates for method references |
| ‚ö†Ô∏è Don't force it | Use lambda if more logic needed |
| ‚ö†Ô∏è Consider clarity | Sometimes lambda is clearer |
| ‚ö†Ô∏è Avoid complexity | Don't chain too many references |

---

## ‚ö†Ô∏è Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Overusing | Forcing method reference when lambda is clearer | Use judgment |
| Wrong type | Unbound vs bound confusion | Understand the types |
| Ambiguous references | Multiple methods with same name | Be explicit with lambda |
| Parameter mismatch | Method parameters don't match | Check functional interface |
| Null safety | NullPointerException on null reference | Add null checks |

---

## üîó Related Topics

- [Lambda Expressions](01.%20Lambda%20Expressions.md)
- [Functional Interfaces](02.%20Functional%20Interfaces.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## üìù Interview Questions

1. **What are method references?**
   - Shorthand notation for lambda expressions
   - Use :: operator
   - More concise and readable

2. **What are the types of method references?**
   - Static method reference
   - Bound instance method reference
   - Unbound instance method reference
   - Constructor reference

3. **When to use method reference vs lambda?**
   - Method reference: when just calling a method
   - Lambda: when additional logic needed
   - Choose based on readability

4. **What is the difference between bound and unbound instance method reference?**
   - Bound: tied to specific instance
   - Unbound: works with any instance of the type

5. **Can constructor be referenced?**
   - Yes, using ClassName::new
   - Works with different constructors based on parameters

6. **What is the syntax for method reference?**
   - ClassName::methodName for static
   - object::methodName for instance
   - ClassName::new for constructor

7. **Are method references more efficient than lambdas?**
   - Generally same performance
   - JVM optimizes both similarly
   - Choose based on readability

8. **Can method reference have multiple parameters?**
   - Yes, determined by functional interface
   - BiFunction, BinaryOperator, etc.

9. **What is System.out::println?**
   - Bound instance method reference
   - References println method of System.out object
   - Very common pattern

10. **Can we reference private methods?**
    - Yes, from within the same class
    - Access rules still apply

11. **What is String::length vs str::length?**
    - String::length is unbound (any String object)
    - str::length is bound (specific String instance)

12. **Can we reference overloaded methods?**
    - Yes, compiler determines which method based on context
    - Functional interface signature determines which overload

13. **What is the benefit of constructor reference?**
    - Cleaner object creation
    - Works well with factories
    - Useful with streams

14. **Can we reference array constructors?**
    - Yes, using Type[]::new
    - Common with Stream.toArray()

15. **When would method reference fail?**
    - When method doesn't match functional interface signature
    - When additional logic is needed
    - When method is ambiguous

---

## üí° Key Takeaways

- Method references are shorthand for lambda expressions
- Four types: Static, Bound Instance, Unbound Instance, Constructor
- Use `::` operator for method references
- More concise and readable when just calling a method
- Choose based on readability and simplicity
- Works seamlessly with functional interfaces and streams
- Not always better than lambda - use judgment
- Essential tool for functional programming in Java
- Helps write cleaner, more maintainable code
