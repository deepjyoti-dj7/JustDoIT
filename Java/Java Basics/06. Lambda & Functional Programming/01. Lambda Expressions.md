# ðŸŽ¯ Lambda Expressions

## ðŸ“– Overview

**Lambda expressions** are anonymous functions that enable you to treat functionality as a method argument, or code as data. They provide a clear and concise way to implement single-method interfaces (functional interfaces).

**Key Features:**
- Concise syntax for anonymous functions
- Enable functional programming in Java
- Can be passed as arguments to methods
- Can be stored in variables
- Reduce boilerplate code

**Introduced in:** Java 8 (2014)

---

## ðŸŽ¯ Syntax

### Basic Syntax

```java
(parameters) -> expression
// or
(parameters) -> { statements; }
```

### Components
1. **Parameter list**: `(int a, int b)` or `(a, b)` (type inference)
2. **Arrow token**: `->`
3. **Body**: Single expression or block of statements

---

## ðŸ’» Example 1: Basic Lambda Expression

```java
public class BasicLambda {
    public static void main(String[] args) {
        System.out.println("=== Basic Lambda Expressions ===\n");
        
        // 1. Without parameters
        Runnable runnable = () -> System.out.println("Hello from Lambda!");
        runnable.run();
        
        // 2. With single parameter (parentheses optional)
        java.util.function.Consumer<String> printer = message -> 
            System.out.println("Message: " + message);
        printer.accept("Lambda is awesome!");
        
        // 3. With multiple parameters
        java.util.function.BiFunction<Integer, Integer, Integer> adder = 
            (a, b) -> a + b;
        System.out.println("Sum: " + adder.apply(5, 3));
        
        // 4. With explicit types
        java.util.function.BiFunction<Integer, Integer, Integer> multiplier = 
            (Integer x, Integer y) -> x * y;
        System.out.println("Product: " + multiplier.apply(5, 3));
        
        // 5. With block body
        java.util.function.Function<Integer, String> converter = (num) -> {
            String result;
            if (num > 0) {
                result = "Positive: " + num;
            } else if (num < 0) {
                result = "Negative: " + num;
            } else {
                result = "Zero";
            }
            return result;
        };
        System.out.println(converter.apply(5));
        System.out.println(converter.apply(-3));
        System.out.println(converter.apply(0));
    }
}
```

**Output:**
```
=== Basic Lambda Expressions ===

Hello from Lambda!
Message: Lambda is awesome!
Sum: 8
Product: 15
Positive: 5
Negative: -3
Zero
```

---

## ðŸ’» Example 2: Lambda vs Traditional Approach

```java
import java.util.*;

// Traditional approach with anonymous class
class TraditionalComparator {
    public static void main(String[] args) {
        System.out.println("=== Traditional vs Lambda ===\n");
        
        List<String> names = Arrays.asList("Charlie", "Alice", "Bob", "David");
        
        // Traditional: Anonymous inner class
        System.out.println("Traditional Approach:");
        Collections.sort(names, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });
        System.out.println(names);
        
        // Modern: Lambda expression
        System.out.println("\nLambda Approach:");
        names = Arrays.asList("Charlie", "Alice", "Bob", "David");
        Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
        System.out.println(names);
        
        // Even more concise: Method reference
        System.out.println("\nMethod Reference:");
        names = Arrays.asList("Charlie", "Alice", "Bob", "David");
        Collections.sort(names, String::compareTo);
        System.out.println(names);
    }
}
```

**Output:**
```
=== Traditional vs Lambda ===

Traditional Approach:
[Alice, Bob, Charlie, David]

Lambda Approach:
[Alice, Bob, Charlie, David]

Method Reference:
[Alice, Bob, Charlie, David]
```

---

## ðŸ’» Example 3: Custom Functional Interface

```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class CustomFunctionalInterface {
    public static void main(String[] args) {
        System.out.println("=== Custom Functional Interfaces ===\n");
        
        // Lambda implementations
        Calculator addition = (a, b) -> a + b;
        Calculator subtraction = (a, b) -> a - b;
        Calculator multiplication = (a, b) -> a * b;
        Calculator division = (a, b) -> b != 0 ? a / b : 0;
        
        int x = 10, y = 5;
        System.out.println("Addition: " + x + " + " + y + " = " + addition.calculate(x, y));
        System.out.println("Subtraction: " + x + " - " + y + " = " + subtraction.calculate(x, y));
        System.out.println("Multiplication: " + x + " * " + y + " = " + multiplication.calculate(x, y));
        System.out.println("Division: " + x + " / " + y + " = " + division.calculate(x, y));
        
        // String processors
        System.out.println("\nString Processors:");
        StringProcessor uppercase = str -> str.toUpperCase();
        StringProcessor lowercase = str -> str.toLowerCase();
        StringProcessor reverse = str -> new StringBuilder(str).reverse().toString();
        
        String text = "Lambda";
        System.out.println("Original: " + text);
        System.out.println("Uppercase: " + uppercase.process(text));
        System.out.println("Lowercase: " + lowercase.process(text));
        System.out.println("Reverse: " + reverse.process(text));
    }
}
```

**Output:**
```
=== Custom Functional Interfaces ===

Addition: 10 + 5 = 15
Subtraction: 10 - 5 = 5
Multiplication: 10 * 5 = 50
Division: 10 / 5 = 2

String Processors:
Original: Lambda
Uppercase: LAMBDA
Lowercase: lambda
Reverse: adbmaL
```

---

## ðŸ’» Example 4: Lambda with Collections

```java
import java.util.*;
import java.util.stream.*;

public class LambdaWithCollections {
    public static void main(String[] args) {
        System.out.println("=== Lambda with Collections ===\n");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 1. forEach with lambda
        System.out.println("Print all numbers:");
        numbers.forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        
        // 2. Filter even numbers
        System.out.println("Even numbers:");
        numbers.stream()
               .filter(n -> n % 2 == 0)
               .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        
        // 3. Square each number
        System.out.println("Squared numbers:");
        numbers.stream()
               .map(n -> n * n)
               .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        
        // 4. Sum of all numbers
        int sum = numbers.stream()
                         .reduce(0, (a, b) -> a + b);
        System.out.println("Sum: " + sum);
        
        // 5. Filter and transform
        System.out.println("\nSquare of even numbers:");
        List<Integer> squaredEvens = numbers.stream()
                                            .filter(n -> n % 2 == 0)
                                            .map(n -> n * n)
                                            .collect(Collectors.toList());
        System.out.println(squaredEvens);
    }
}
```

**Output:**
```
=== Lambda with Collections ===

Print all numbers:
1 2 3 4 5 6 7 8 9 10 

Even numbers:
2 4 6 8 10 

Squared numbers:
1 4 9 16 25 36 49 64 81 100 

Sum: 55

Square of even numbers:
[4, 16, 36, 64, 100]
```

---

## ðŸ’» Example 5: Lambda in Multi-threading

```java
public class LambdaMultithreading {
    public static void main(String[] args) {
        System.out.println("=== Lambda in Multi-threading ===\n");
        
        // Traditional approach
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread 1 (Traditional): " + Thread.currentThread().getName());
            }
        });
        
        // Lambda approach
        Thread thread2 = new Thread(() -> {
            System.out.println("Thread 2 (Lambda): " + Thread.currentThread().getName());
        });
        
        // Even more concise
        Thread thread3 = new Thread(() -> 
            System.out.println("Thread 3 (Concise Lambda): " + Thread.currentThread().getName())
        );
        
        thread1.start();
        thread2.start();
        thread3.start();
        
        // Using lambda with Executors
        System.out.println("\nUsing ExecutorService:");
        java.util.concurrent.ExecutorService executor = 
            java.util.concurrent.Executors.newFixedThreadPool(2);
        
        executor.submit(() -> {
            System.out.println("Task 1 executed by: " + Thread.currentThread().getName());
        });
        
        executor.submit(() -> {
            System.out.println("Task 2 executed by: " + Thread.currentThread().getName());
        });
        
        executor.shutdown();
    }
}
```

---

## ðŸ’» Example 6: Lambda Scope and Variables

```java
public class LambdaScope {
    private static int staticVar = 100;
    private int instanceVar = 200;
    
    public void demonstrateScope() {
        System.out.println("=== Lambda Scope ===\n");
        
        int localVar = 300;
        // localVar is effectively final
        
        Runnable runnable = () -> {
            // Can access static variables
            System.out.println("Static variable: " + staticVar);
            
            // Can access instance variables
            System.out.println("Instance variable: " + instanceVar);
            
            // Can access local variables (effectively final)
            System.out.println("Local variable: " + localVar);
            
            // Can modify static and instance variables
            staticVar++;
            instanceVar++;
            
            // Cannot modify local variable
            // localVar++; // Compilation error!
        };
        
        runnable.run();
        
        System.out.println("\nAfter lambda execution:");
        System.out.println("Static variable: " + staticVar);
        System.out.println("Instance variable: " + instanceVar);
        // localVar cannot be modified in lambda
    }
    
    public static void main(String[] args) {
        LambdaScope example = new LambdaScope();
        example.demonstrateScope();
    }
}
```

**Output:**
```
=== Lambda Scope ===

Static variable: 100
Instance variable: 200
Local variable: 300

After lambda execution:
Static variable: 101
Instance variable: 201
```

---

## ðŸ’» Example 7: Lambda with Sorting

```java
import java.util.*;

class Employee {
    private String name;
    private int age;
    private double salary;
    
    public Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
    
    @Override
    public String toString() {
        return String.format("Employee{name='%s', age=%d, salary=%.2f}", 
                           name, age, salary);
    }
}

public class LambdaSorting {
    public static void main(String[] args) {
        System.out.println("=== Lambda Sorting ===\n");
        
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 30, 75000),
            new Employee("Bob", 25, 65000),
            new Employee("Charlie", 35, 85000),
            new Employee("David", 28, 70000)
        );
        
        // Sort by name
        System.out.println("Sorted by name:");
        employees.sort((e1, e2) -> e1.getName().compareTo(e2.getName()));
        employees.forEach(System.out::println);
        
        // Sort by age
        System.out.println("\nSorted by age:");
        employees.sort((e1, e2) -> Integer.compare(e1.getAge(), e2.getAge()));
        employees.forEach(System.out::println);
        
        // Sort by salary (descending)
        System.out.println("\nSorted by salary (descending):");
        employees.sort((e1, e2) -> Double.compare(e2.getSalary(), e1.getSalary()));
        employees.forEach(System.out::println);
        
        // Using Comparator methods
        System.out.println("\nUsing Comparator.comparing:");
        employees.sort(Comparator.comparing(Employee::getName));
        employees.forEach(System.out::println);
    }
}
```

---

## ðŸ’» Example 8: Lambda with Event Handling

```java
import javax.swing.*;
import java.awt.*;

public class LambdaEventHandling {
    public static void main(String[] args) {
        System.out.println("=== Lambda Event Handling ===\n");
        
        JFrame frame = new JFrame("Lambda Event Demo");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(400, 200);
        frame.setLayout(new FlowLayout());
        
        JButton button1 = new JButton("Click Me (Traditional)");
        JButton button2 = new JButton("Click Me (Lambda)");
        JLabel label = new JLabel("Click count: 0");
        
        final int[] clickCount = {0};
        
        // Traditional approach
        button1.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent e) {
                System.out.println("Traditional button clicked!");
                clickCount[0]++;
                label.setText("Click count: " + clickCount[0]);
            }
        });
        
        // Lambda approach
        button2.addActionListener(e -> {
            System.out.println("Lambda button clicked!");
            clickCount[0]++;
            label.setText("Click count: " + clickCount[0]);
        });
        
        frame.add(button1);
        frame.add(button2);
        frame.add(label);
        frame.setVisible(true);
        
        System.out.println("GUI created with lambda event handlers");
    }
}
```

---

## ðŸ’» Example 9: Lambda with Custom Operations

```java
import java.util.*;
import java.util.function.*;

public class LambdaCustomOperations {
    
    // Generic method that accepts lambda
    public static <T> void processElements(List<T> list, 
                                          Predicate<T> filter,
                                          Consumer<T> action) {
        for (T item : list) {
            if (filter.test(item)) {
                action.accept(item);
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lambda Custom Operations ===\n");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Process even numbers and print their squares
        System.out.println("Squares of even numbers:");
        processElements(
            numbers,
            n -> n % 2 == 0,  // Filter: even numbers
            n -> System.out.print((n * n) + " ")  // Action: print square
        );
        System.out.println("\n");
        
        // Process numbers > 5 and print doubled
        System.out.println("Double of numbers > 5:");
        processElements(
            numbers,
            n -> n > 5,  // Filter: > 5
            n -> System.out.print((n * 2) + " ")  // Action: print double
        );
        System.out.println("\n");
        
        // String processing
        List<String> words = Arrays.asList("Lambda", "Java", "Functional", "Programming");
        
        System.out.println("Words with length > 5:");
        processElements(
            words,
            s -> s.length() > 5,  // Filter: length > 5
            s -> System.out.println(s.toUpperCase())  // Action: uppercase
        );
    }
}
```

**Output:**
```
=== Lambda Custom Operations ===

Squares of even numbers:
4 16 36 64 100 

Double of numbers > 5:
12 14 16 18 20 

Words with length > 5:
LAMBDA
FUNCTIONAL
PROGRAMMING
```

---

## ðŸ’» Example 10: Lambda Best Practices

```java
import java.util.*;
import java.util.function.*;

public class LambdaBestPractices {
    public static void main(String[] args) {
        System.out.println("=== Lambda Best Practices ===\n");
        
        // 1. Keep lambda expressions short and readable
        System.out.println("1. Short and readable:");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.forEach(name -> System.out.println(name));  // Good
        
        // 2. Use method references when possible
        System.out.println("\n2. Method references:");
        names.forEach(System.out::println);  // Better
        
        // 3. Don't overuse lambdas - extract complex logic
        System.out.println("\n3. Extract complex logic:");
        Predicate<String> isValidName = LambdaBestPractices::validateName;
        names.stream()
             .filter(isValidName)
             .forEach(System.out::println);
        
        // 4. Use standard functional interfaces
        System.out.println("\n4. Standard functional interfaces:");
        Function<String, Integer> lengthFunction = String::length;
        Consumer<String> printer = System.out::println;
        Predicate<String> isEmpty = String::isEmpty;
        
        // 5. Avoid side effects
        System.out.println("\n5. Avoid side effects:");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Bad: modifying external state
        List<Integer> result = new ArrayList<>();
        numbers.forEach(n -> result.add(n * 2));  // Side effect
        
        // Good: use map and collect
        List<Integer> betterResult = numbers.stream()
                                            .map(n -> n * 2)
                                            .collect(java.util.stream.Collectors.toList());
        System.out.println("Result: " + betterResult);
        
        // 6. Handle exceptions properly
        System.out.println("\n6. Exception handling:");
        List<String> strings = Arrays.asList("1", "2", "invalid", "4");
        strings.forEach(s -> {
            try {
                Integer.parseInt(s);
                System.out.println("Valid: " + s);
            } catch (NumberFormatException e) {
                System.out.println("Invalid: " + s);
            }
        });
    }
    
    private static boolean validateName(String name) {
        return name != null && name.length() >= 3 && !name.isEmpty();
    }
}
```

---

## ðŸ“Š Lambda Expression Syntax Variations

| Syntax | Example | Use Case |
|--------|---------|----------|
| No parameters | `() -> expression` | Runnable |
| Single parameter | `x -> expression` | Consumer |
| Single parameter with type | `(String x) -> expression` | Type clarity |
| Multiple parameters | `(x, y) -> expression` | BiFunction |
| Multiple parameters with types | `(int x, int y) -> expression` | Type clarity |
| Single statement block | `x -> { statement; }` | Single operation |
| Multiple statements | `x -> { stmt1; stmt2; return val; }` | Complex logic |

---

## ðŸŽ¯ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… Keep it short | Lambda should be concise (1-3 lines ideal) |
| âœ… Use method references | When lambda just calls a method |
| âœ… Descriptive names | Use clear parameter names |
| âœ… Avoid side effects | Lambda should be stateless when possible |
| âœ… Use functional interfaces | Prefer standard interfaces from java.util.function |
| âœ… Handle exceptions | Wrap checked exceptions appropriately |
| âœ… Extract complex logic | Move to separate methods if too complex |
| âš ï¸ Avoid nested lambdas | Reduces readability |
| âš ï¸ Don't modify external state | Keep lambdas pure when possible |
| âš ï¸ Careful with 'this' | Understand lambda scope |

---

## âš ï¸ Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Modifying local variables | Local variables must be effectively final | Use instance/static variables or wrapper objects |
| Complex lambdas | Long multi-line lambdas reduce readability | Extract to separate methods |
| Exception handling | Checked exceptions don't work well with lambdas | Use wrapper methods or custom functional interfaces |
| Overusing lambdas | Not everything needs a lambda | Use traditional approach when clearer |
| Performance overhead | Creating many lambda instances | Use method references or reuse lambdas |
| Debugging difficulty | Stack traces can be harder to read | Keep lambdas simple, use meaningful names |
| Type inference issues | Compiler can't infer types | Provide explicit types |
| Null pointer exceptions | Not checking for null | Add null checks or use Optional |

---

## ðŸ”— Related Topics

- [Functional Interfaces](02.%20Functional%20Interfaces.md)
- [Method References](03.%20Method%20References.md)
- [Predicate Interface](04.%20Predicate%20Interface.md)
- [Function Interface](05.%20Function%20Interface.md)
- [Consumer & Supplier](06.%20Consumer%20%26%20Supplier.md)
- [Optional Class](07.%20Optional%20Class.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## ðŸ“ Interview Questions

1. **What are lambda expressions in Java?**
   - Anonymous functions introduced in Java 8
   - Provide clear and concise way to implement functional interfaces
   - Enable functional programming paradigm

2. **What is the syntax of lambda expressions?**
   - `(parameters) -> expression` or `(parameters) -> { statements; }`
   - Can omit parameter types (type inference)
   - Parentheses optional for single parameter

3. **What is a functional interface?**
   - Interface with exactly one abstract method
   - Can be implemented using lambda expressions
   - Marked with @FunctionalInterface (optional)

4. **Can lambda expressions access local variables?**
   - Yes, but variables must be effectively final
   - Can't modify local variables from lambda
   - Can access and modify instance/static variables

5. **What are the advantages of lambda expressions?**
   - Less boilerplate code
   - Better readability
   - Enable functional programming
   - Easier parallel processing
   - More concise code

6. **Can lambda expressions throw exceptions?**
   - Yes, unchecked exceptions
   - Checked exceptions require interface modification
   - Need wrapper methods for checked exceptions

7. **What is the difference between lambda and anonymous inner class?**
   - Lambda: concise, no 'this' binding, stateless
   - Anonymous class: verbose, has 'this', stateful

8. **Can we have multiple statements in lambda?**
   - Yes, use curly braces and semicolons
   - Explicit return statement needed
   - Keep it concise for readability

9. **What is effectively final in lambda?**
   - Local variables accessed from lambda must not be modified
   - Compiler automatically makes them final
   - Ensures thread safety

10. **How does 'this' keyword work in lambda?**
    - Refers to enclosing class instance
    - Not the lambda itself
    - Different from anonymous inner classes

11. **Can lambda expressions be used with any interface?**
    - No, only functional interfaces
    - Interface must have exactly one abstract method
    - Can have default and static methods

12. **What is method reference and how is it related to lambda?**
    - Shorthand notation for lambda expressions
    - Four types: static, instance, constructor, arbitrary object
    - More concise when lambda just calls a method

13. **Are lambda expressions thread-safe?**
    - Stateless lambdas are thread-safe
    - Lambdas modifying shared state need synchronization
    - Avoid side effects for thread safety

14. **What is the performance impact of lambda expressions?**
    - Minimal overhead in modern JVMs
    - May create objects (can be optimized by JVM)
    - Generally as efficient as anonymous classes

15. **Can lambda expressions be serialized?**
    - Yes, if target functional interface is serializable
    - Lambda must not capture non-serializable variables
    - Use with caution (implementation-dependent)

---

## ðŸ’¡ Key Takeaways

- Lambda expressions enable functional programming in Java
- Syntax: `(parameters) -> expression` or `(parameters) -> { statements; }`
- Can only be used with functional interfaces
- Local variables accessed must be effectively final
- Keep lambdas short and readable
- Use method references when possible
- Avoid side effects for better maintainability
- Standard functional interfaces available in java.util.function
- Greatly simplify collection operations and event handling
- Essential for Stream API and modern Java development
