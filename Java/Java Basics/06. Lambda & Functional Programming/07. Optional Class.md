# üéØ Optional Class

## üìñ Overview

**Optional** is a container object that may or may not contain a non-null value. It's designed to help avoid NullPointerException and make code more readable and explicit about nullable values.

**Purpose:** Handle null values gracefully without explicit null checks

**Package:** `java.util`

**Introduced in:** Java 8 (2014)

---

## üéØ Key Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `of(T value)` | Create Optional with non-null value | Optional\<T> |
| `ofNullable(T value)` | Create Optional (null safe) | Optional\<T> |
| `empty()` | Create empty Optional | Optional\<T> |
| `isPresent()` | Check if value present | boolean |
| `isEmpty()` | Check if value absent (Java 11+) | boolean |
| `get()` | Get value (throws if empty) | T |
| `orElse(T other)` | Get value or default | T |
| `orElseGet(Supplier)` | Get value or from supplier | T |
| `orElseThrow()` | Get value or throw exception | T |
| `ifPresent(Consumer)` | Execute if present | void |
| `map(Function)` | Transform value | Optional\<U> |
| `flatMap(Function)` | Transform to Optional | Optional\<U> |
| `filter(Predicate)` | Filter value | Optional\<T> |

---

## üíª Example 1: Creating Optional

```java
import java.util.Optional;

public class CreatingOptional {
    public static void main(String[] args) {
        System.out.println("=== Creating Optional ===\n");
        
        // 1. Optional.of() - throws NullPointerException if null
        Optional<String> opt1 = Optional.of("Hello");
        System.out.println("Optional.of(): " + opt1);
        
        // Optional.of(null);  // Throws NullPointerException!
        
        // 2. Optional.ofNullable() - null safe
        Optional<String> opt2 = Optional.ofNullable("World");
        Optional<String> opt3 = Optional.ofNullable(null);
        
        System.out.println("Optional.ofNullable('World'): " + opt2);
        System.out.println("Optional.ofNullable(null): " + opt3);
        
        // 3. Optional.empty() - explicitly empty
        Optional<String> opt4 = Optional.empty();
        System.out.println("Optional.empty(): " + opt4);
        
        // Check if value is present
        System.out.println("\nChecking presence:");
        System.out.println("opt1.isPresent(): " + opt1.isPresent());
        System.out.println("opt3.isPresent(): " + opt3.isPresent());
        System.out.println("opt4.isEmpty(): " + opt4.isEmpty());
    }
}
```

**Output:**
```
=== Creating Optional ===

Optional.of(): Optional[Hello]
Optional.ofNullable('World'): Optional[World]
Optional.ofNullable(null): Optional.empty
Optional.empty(): Optional.empty

Checking presence:
opt1.isPresent(): true
opt3.isPresent(): false
opt4.isEmpty(): true
```

---

## üíª Example 2: Retrieving Values

```java
import java.util.Optional;

public class RetrievingValues {
    public static void main(String[] args) {
        System.out.println("=== Retrieving Values ===\n");
        
        Optional<String> present = Optional.of("Hello");
        Optional<String> empty = Optional.empty();
        
        // 1. get() - throws NoSuchElementException if empty
        System.out.println("1. get():");
        System.out.println("Present: " + present.get());
        // System.out.println(empty.get());  // Throws exception!
        
        // 2. orElse() - returns default if empty
        System.out.println("\n2. orElse():");
        System.out.println("Present: " + present.orElse("default"));
        System.out.println("Empty: " + empty.orElse("default"));
        
        // 3. orElseGet() - lazy evaluation with Supplier
        System.out.println("\n3. orElseGet():");
        String value1 = present.orElseGet(() -> {
            System.out.println("Computing default...");
            return "computed";
        });
        System.out.println("Present: " + value1);
        
        String value2 = empty.orElseGet(() -> {
            System.out.println("Computing default...");
            return "computed";
        });
        System.out.println("Empty: " + value2);
        
        // 4. orElseThrow() - custom exception
        System.out.println("\n4. orElseThrow():");
        try {
            String val = empty.orElseThrow(() -> 
                new IllegalArgumentException("Value not present!")
            );
        } catch (IllegalArgumentException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
```

---

## üíª Example 3: ifPresent and ifPresentOrElse

```java
import java.util.Optional;

public class ConditionalActions {
    public static void main(String[] args) {
        System.out.println("=== Conditional Actions ===\n");
        
        Optional<String> present = Optional.of("Lambda");
        Optional<String> empty = Optional.empty();
        
        // 1. ifPresent() - execute if value present
        System.out.println("1. ifPresent():");
        present.ifPresent(value -> 
            System.out.println("Value: " + value)
        );
        
        empty.ifPresent(value -> 
            System.out.println("This won't print")
        );
        
        // 2. ifPresentOrElse() - Java 9+
        System.out.println("\n2. ifPresentOrElse():");
        present.ifPresentOrElse(
            value -> System.out.println("Present: " + value),
            () -> System.out.println("Empty!")
        );
        
        empty.ifPresentOrElse(
            value -> System.out.println("Present: " + value),
            () -> System.out.println("Empty!")
        );
        
        // Practical example: processing user input
        System.out.println("\n3. Practical Example:");
        Optional<String> userInput = getUserInput();
        userInput.ifPresent(input -> {
            System.out.println("Processing: " + input.toUpperCase());
        });
    }
    
    static Optional<String> getUserInput() {
        // Simulate user input
        return Math.random() > 0.5 ? 
            Optional.of("user data") : 
            Optional.empty();
    }
}
```

---

## üíª Example 4: map() and flatMap()

```java
import java.util.Optional;

public class TransformingOptional {
    public static void main(String[] args) {
        System.out.println("=== Transforming Optional ===\n");
        
        Optional<String> name = Optional.of("alice");
        
        // 1. map() - transform value
        System.out.println("1. map():");
        Optional<String> upper = name.map(String::toUpperCase);
        System.out.println("Uppercase: " + upper.get());
        
        Optional<Integer> length = name.map(String::length);
        System.out.println("Length: " + length.get());
        
        // Chaining map
        Optional<String> result = name
            .map(String::trim)
            .map(String::toUpperCase)
            .map(s -> "Hello, " + s);
        System.out.println("Chained: " + result.get());
        
        // 2. flatMap() - when function returns Optional
        System.out.println("\n2. flatMap():");
        Optional<String> input = Optional.of("123");
        
        Optional<Integer> number = input.flatMap(s -> {
            try {
                return Optional.of(Integer.parseInt(s));
            } catch (NumberFormatException e) {
                return Optional.empty();
            }
        });
        
        System.out.println("Parsed number: " + number.orElse(-1));
        
        // map vs flatMap
        System.out.println("\n3. map vs flatMap:");
        
        // map returns Optional<Optional<String>>
        Optional<Optional<String>> mapResult = 
            Optional.of("test").map(s -> Optional.of(s.toUpperCase()));
        
        // flatMap returns Optional<String>
        Optional<String> flatMapResult = 
            Optional.of("test").flatMap(s -> Optional.of(s.toUpperCase()));
        
        System.out.println("flatMap result: " + flatMapResult.get());
    }
}
```

---

## üíª Example 5: filter()

```java
import java.util.Optional;
import java.util.function.Predicate;

public class FilteringOptional {
    public static void main(String[] args) {
        System.out.println("=== Filtering Optional ===\n");
        
        // 1. Basic filter
        Optional<Integer> number = Optional.of(42);
        
        Optional<Integer> even = number.filter(n -> n % 2 == 0);
        Optional<Integer> odd = number.filter(n -> n % 2 != 0);
        
        System.out.println("42 is even: " + even.isPresent());
        System.out.println("42 is odd: " + odd.isPresent());
        
        // 2. Chain filter with map
        System.out.println("\n2. Chain filter with map:");
        Optional<String> result = Optional.of("Hello")
            .filter(s -> s.length() > 3)
            .map(String::toUpperCase)
            .filter(s -> s.startsWith("H"));
        
        System.out.println("Result: " + result.orElse("Not found"));
        
        // 3. Validate user input
        System.out.println("\n3. Validate user input:");
        validateAge(Optional.of(25));
        validateAge(Optional.of(15));
        validateAge(Optional.empty());
        
        // 4. Complex filtering
        System.out.println("\n4. Complex filtering:");
        Optional<String> email = Optional.of("user@example.com");
        
        Predicate<String> hasAt = s -> s.contains("@");
        Predicate<String> hasDot = s -> s.contains(".");
        Predicate<String> validLength = s -> s.length() >= 5;
        
        Optional<String> validEmail = email
            .filter(hasAt)
            .filter(hasDot)
            .filter(validLength);
        
        System.out.println("Valid email: " + validEmail.isPresent());
    }
    
    static void validateAge(Optional<Integer> age) {
        age.filter(a -> a >= 18)
           .ifPresentOrElse(
               a -> System.out.println("Age " + a + " is valid"),
               () -> System.out.println("Age invalid or not provided")
           );
    }
}
```

---

## üíª Example 6: Avoiding Null Checks

```java
import java.util.Optional;

class User {
    private String name;
    private Address address;
    
    public User(String name, Address address) {
        this.name = name;
        this.address = address;
    }
    
    public Optional<String> getName() {
        return Optional.ofNullable(name);
    }
    
    public Optional<Address> getAddress() {
        return Optional.ofNullable(address);
    }
}

class Address {
    private String city;
    
    public Address(String city) {
        this.city = city;
    }
    
    public Optional<String> getCity() {
        return Optional.ofNullable(city);
    }
}

public class AvoidingNullChecks {
    
    // Traditional approach with null checks
    public static String getCityTraditional(User user) {
        if (user != null) {
            Address address = user.getAddress().orElse(null);
            if (address != null) {
                return address.getCity().orElse("Unknown");
            }
        }
        return "Unknown";
    }
    
    // Optional approach
    public static String getCityOptional(Optional<User> user) {
        return user
            .flatMap(User::getAddress)
            .flatMap(Address::getCity)
            .orElse("Unknown");
    }
    
    public static void main(String[] args) {
        System.out.println("=== Avoiding Null Checks ===\n");
        
        // User with full address
        User user1 = new User("Alice", new Address("New York"));
        System.out.println("User 1 city: " + 
            getCityOptional(Optional.of(user1)));
        
        // User with no address
        User user2 = new User("Bob", null);
        System.out.println("User 2 city: " + 
            getCityOptional(Optional.of(user2)));
        
        // No user
        System.out.println("No user city: " + 
            getCityOptional(Optional.empty()));
    }
}
```

---

## üíª Example 7: Optional with Collections

```java
import java.util.*;
import java.util.stream.Collectors;

public class OptionalWithCollections {
    public static void main(String[] args) {
        System.out.println("=== Optional with Collections ===\n");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // 1. findFirst()
        Optional<String> first = names.stream()
                                     .filter(s -> s.startsWith("C"))
                                     .findFirst();
        System.out.println("1. First name starting with C: " + first.orElse("None"));
        
        // 2. findAny()
        Optional<String> any = names.stream()
                                   .filter(s -> s.length() > 4)
                                   .findAny();
        System.out.println("2. Any name with length > 4: " + any.get());
        
        // 3. max() and min()
        Optional<String> longest = names.stream()
                                       .max(Comparator.comparingInt(String::length));
        System.out.println("3. Longest name: " + longest.get());
        
        // 4. reduce()
        Optional<String> concatenated = names.stream()
                                            .reduce((a, b) -> a + ", " + b);
        System.out.println("4. Concatenated: " + concatenated.get());
        
        // 5. Filter and collect
        System.out.println("\n5. Names starting with A:");
        names.stream()
             .filter(s -> s.startsWith("A"))
             .findFirst()
             .ifPresent(System.out::println);
        
        // 6. Map to Optional
        Map<String, String> map = new HashMap<>();
        map.put("key1", "value1");
        map.put("key2", null);
        
        System.out.println("\n6. Map values:");
        Optional.ofNullable(map.get("key1"))
                .ifPresent(v -> System.out.println("Found: " + v));
        
        Optional.ofNullable(map.get("key2"))
                .ifPresent(v -> System.out.println("Found: " + v));
        
        Optional.ofNullable(map.get("key3"))
                .ifPresentOrElse(
                    v -> System.out.println("Found: " + v),
                    () -> System.out.println("Key not found")
                );
    }
}
```

---

## üíª Example 8: Optional Best Practices

```java
import java.util.Optional;

public class OptionalBestPractices {
    
    // ‚ùå BAD: Using get() without checking
    public static String bad1(Optional<String> opt) {
        return opt.get();  // Can throw NoSuchElementException
    }
    
    // ‚úÖ GOOD: Using orElse
    public static String good1(Optional<String> opt) {
        return opt.orElse("default");
    }
    
    // ‚ùå BAD: Using isPresent() with get()
    public static void bad2(Optional<String> opt) {
        if (opt.isPresent()) {
            System.out.println(opt.get());
        }
    }
    
    // ‚úÖ GOOD: Using ifPresent
    public static void good2(Optional<String> opt) {
        opt.ifPresent(System.out::println);
    }
    
    // ‚ùå BAD: Returning null from method
    public static Optional<String> bad3(String input) {
        return null;  // Never return null!
    }
    
    // ‚úÖ GOOD: Returning Optional.empty()
    public static Optional<String> good3(String input) {
        return input == null ? Optional.empty() : Optional.of(input);
    }
    
    // ‚ùå BAD: Optional as field
    class BadClass {
        private Optional<String> name;  // Don't use Optional as field
    }
    
    // ‚úÖ GOOD: Regular field with Optional getter
    class GoodClass {
        private String name;
        
        public Optional<String> getName() {
            return Optional.ofNullable(name);
        }
    }
    
    // ‚ùå BAD: Optional as parameter
    public static void badMethod(Optional<String> param) {
        // Caller might pass null Optional!
    }
    
    // ‚úÖ GOOD: Regular parameter, return Optional
    public static Optional<String> goodMethod(String param) {
        return Optional.ofNullable(param);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Optional Best Practices ===\n");
        
        Optional<String> opt = Optional.of("test");
        
        System.out.println("Good practices:");
        System.out.println(good1(opt));
        good2(opt);
        System.out.println(good3("value"));
    }
}
```

---

## üíª Example 9: Optional or() and stream()

```java
import java.util.Optional;
import java.util.stream.Stream;

public class OptionalAdvanced {
    public static void main(String[] args) {
        System.out.println("=== Optional or() and stream() ===\n");
        
        // 1. or() - Java 9+ (alternative Optional)
        System.out.println("1. or() method:");
        Optional<String> primary = Optional.empty();
        Optional<String> secondary = Optional.of("backup");
        
        Optional<String> result = primary.or(() -> secondary);
        System.out.println("Result: " + result.get());
        
        // Chain multiple or()
        Optional<String> first = Optional.empty();
        Optional<String> second = Optional.empty();
        Optional<String> third = Optional.of("third");
        
        Optional<String> finalResult = first
            .or(() -> second)
            .or(() -> third);
        System.out.println("Final: " + finalResult.get());
        
        // 2. stream() - Java 9+
        System.out.println("\n2. stream() method:");
        Optional<String> opt1 = Optional.of("Hello");
        Optional<String> opt2 = Optional.empty();
        Optional<String> opt3 = Optional.of("World");
        
        Stream.of(opt1, opt2, opt3)
              .flatMap(Optional::stream)
              .forEach(System.out::println);
        
        // Practical use with collections
        System.out.println("\n3. Practical use:");
        Stream.of(
            findUser("Alice"),
            findUser("Bob"),
            findUser("Charlie")
        )
        .flatMap(Optional::stream)
        .forEach(System.out::println);
    }
    
    static Optional<String> findUser(String name) {
        return name.equals("Bob") ? 
            Optional.empty() : 
            Optional.of("User: " + name);
    }
}
```

---

## üíª Example 10: Real-World Scenarios

```java
import java.util.*;

class Product {
    private String name;
    private Double price;
    
    public Product(String name, Double price) {
        this.name = name;
        this.price = price;
    }
    
    public Optional<String> getName() {
        return Optional.ofNullable(name);
    }
    
    public Optional<Double> getPrice() {
        return Optional.ofNullable(price);
    }
}

public class RealWorldOptional {
    
    // Repository pattern
    private static Map<Integer, Product> products = new HashMap<>();
    
    static {
        products.put(1, new Product("Laptop", 999.99));
        products.put(2, new Product("Mouse", 25.99));
    }
    
    public static Optional<Product> findProductById(Integer id) {
        return Optional.ofNullable(products.get(id));
    }
    
    public static void main(String[] args) {
        System.out.println("=== Real-World Scenarios ===\n");
        
        // 1. Repository lookup
        System.out.println("1. Product Lookup:");
        findProductById(1)
            .flatMap(Product::getName)
            .ifPresent(name -> System.out.println("Found: " + name));
        
        findProductById(999)
            .flatMap(Product::getName)
            .ifPresentOrElse(
                name -> System.out.println("Found: " + name),
                () -> System.out.println("Product not found")
            );
        
        // 2. Configuration values
        System.out.println("\n2. Configuration:");
        Optional<String> config = getConfig("db.host");
        String dbHost = config.orElse("localhost");
        System.out.println("DB Host: " + dbHost);
        
        // 3. Discount calculation
        System.out.println("\n3. Price with Discount:");
        findProductById(1)
            .flatMap(Product::getPrice)
            .map(price -> price * 0.9)  // 10% discount
            .ifPresent(finalPrice -> 
                System.out.printf("Final Price: $%.2f%n", finalPrice)
            );
        
        // 4. Chain of fallbacks
        System.out.println("\n4. Chain of Fallbacks:");
        String value = getPrimaryValue()
            .or(() -> getSecondaryValue())
            .or(() -> getTertiaryValue())
            .orElse("default");
        System.out.println("Value: " + value);
        
        // 5. Validation pipeline
        System.out.println("\n5. Validation:");
        validateEmail("user@example.com");
        validateEmail("invalid");
    }
    
    static Optional<String> getConfig(String key) {
        Map<String, String> config = new HashMap<>();
        config.put("db.port", "5432");
        return Optional.ofNullable(config.get(key));
    }
    
    static Optional<String> getPrimaryValue() {
        return Optional.empty();
    }
    
    static Optional<String> getSecondaryValue() {
        return Optional.empty();
    }
    
    static Optional<String> getTertiaryValue() {
        return Optional.of("tertiary");
    }
    
    static void validateEmail(String email) {
        Optional.ofNullable(email)
            .filter(e -> e.contains("@"))
            .filter(e -> e.contains("."))
            .ifPresentOrElse(
                e -> System.out.println(e + " is valid"),
                () -> System.out.println(email + " is invalid")
            );
    }
}
```

---

## üìä Optional Methods Summary

| Category | Methods | Purpose |
|----------|---------|---------|
| **Creation** | of(), ofNullable(), empty() | Create Optional |
| **Checking** | isPresent(), isEmpty() | Check presence |
| **Retrieval** | get(), orElse(), orElseGet(), orElseThrow() | Get value |
| **Conditional** | ifPresent(), ifPresentOrElse() | Execute if present |
| **Transformation** | map(), flatMap() | Transform value |
| **Filtering** | filter() | Filter value |
| **Chaining** | or() | Alternative Optional |
| **Stream** | stream() | Convert to Stream |

---

## üéØ Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Return Optional from methods | Indicates possible absence |
| ‚úÖ Use orElse/orElseGet | Instead of get() |
| ‚úÖ Use ifPresent | Instead of isPresent() + get() |
| ‚úÖ Chain operations | map(), flatMap(), filter() |
| ‚úÖ Use ofNullable | When value might be null |
| ‚ùå Don't use Optional as field | Use in return types only |
| ‚ùå Don't use Optional as parameter | Use regular parameters |
| ‚ùå Don't call get() without checking | Use orElse instead |
| ‚ùå Don't return null Optional | Return Optional.empty() |
| ‚ùå Don't use for collections | Use empty collections instead |

---

## ‚ö†Ô∏è Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Using get() directly | NoSuchElementException | Use orElse() or orElseGet() |
| Optional as field | Not serializable, memory overhead | Use regular field with Optional getter |
| Optional as parameter | Caller can pass null | Use regular parameter |
| isPresent() + get() | Verbose | Use ifPresent() or map() |
| Returning null Optional | Defeats purpose | Return Optional.empty() |
| Over-using Optional | Adds complexity | Use for return types mainly |

---

## üîó Related Topics

- [Lambda Expressions](01.%20Lambda%20Expressions.md)
- [Functional Interfaces](02.%20Functional%20Interfaces.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## üìù Interview Questions

1. **What is Optional?** - Container that may or may not contain value
2. **Why use Optional?** - Avoid NullPointerException, explicit nullability
3. **Difference between of() and ofNullable()?** - of() throws on null
4. **When to use orElse() vs orElseGet()?** - orElseGet() is lazy
5. **Can Optional be null?** - Shouldn't be, defeats the purpose
6. **Should Optional be used as field?** - No, only return types
7. **What is flatMap() in Optional?** - Prevents nested Optionals
8. **How to check if Optional is empty?** - isEmpty() or !isPresent()
9. **What happens if get() called on empty?** - NoSuchElementException
10. **When was Optional introduced?** - Java 8

---

## üí° Key Takeaways

- Optional is a container for possibly-null values
- Use to make nullability explicit in APIs
- Prefer orElse/orElseGet over get()
- Chain operations with map/flatMap/filter
- Use only for return types, not fields or parameters
- Helps avoid NullPointerException
- Makes code more readable and intent clear
- Essential for modern Java development
- Integrates well with Stream API
- Encourages functional programming style
