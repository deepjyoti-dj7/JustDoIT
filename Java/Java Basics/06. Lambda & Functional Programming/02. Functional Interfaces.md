# ðŸŽ¯ Functional Interfaces

## ðŸ“– Overview

**Functional Interface** is an interface that contains exactly one abstract method. These interfaces can be implemented using lambda expressions, method references, or anonymous classes. They are the foundation of functional programming in Java.

**Key Characteristics:**
- Exactly one abstract method (SAM - Single Abstract Method)
- Can have multiple default methods
- Can have multiple static methods
- Can have methods from Object class
- Marked with @FunctionalInterface annotation (optional but recommended)

**Introduced in:** Java 8 (2014)

---

## ðŸŽ¯ Built-in Functional Interfaces

Java provides several functional interfaces in `java.util.function` package:

| Interface | Method | Description |
|-----------|--------|-------------|
| Predicate\<T> | `boolean test(T t)` | Tests a condition |
| Function<T,R> | `R apply(T t)` | Transforms input to output |
| Consumer\<T> | `void accept(T t)` | Consumes input (no return) |
| Supplier\<T> | `T get()` | Supplies a value |
| BiPredicate<T,U> | `boolean test(T t, U u)` | Tests condition with 2 params |
| BiFunction<T,U,R> | `R apply(T t, U u)` | Transforms 2 inputs |
| BiConsumer<T,U> | `void accept(T t, U u)` | Consumes 2 inputs |
| UnaryOperator\<T> | `T apply(T t)` | Function where input = output type |
| BinaryOperator\<T> | `T apply(T t1, T t2)` | BiFunction where all types same |

---

## ðŸ’» Example 1: Creating Custom Functional Interface

```java
// Custom functional interfaces
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

@FunctionalInterface
interface Validator {
    boolean validate(String input);
}

@FunctionalInterface
interface Formatter {
    String format(String input);
}

public class CustomFunctionalInterface {
    public static void main(String[] args) {
        System.out.println("=== Custom Functional Interfaces ===\n");
        
        // Calculator implementations
        Calculator add = (a, b) -> a + b;
        Calculator subtract = (a, b) -> a - b;
        Calculator multiply = (a, b) -> a * b;
        Calculator divide = (a, b) -> b != 0 ? a / b : 0;
        
        int x = 20, y = 4;
        System.out.println("Calculator Operations:");
        System.out.println(x + " + " + y + " = " + add.calculate(x, y));
        System.out.println(x + " - " + y + " = " + subtract.calculate(x, y));
        System.out.println(x + " * " + y + " = " + multiply.calculate(x, y));
        System.out.println(x + " / " + y + " = " + divide.calculate(x, y));
        
        // Validator implementations
        System.out.println("\nValidators:");
        Validator emailValidator = email -> email.contains("@") && email.contains(".");
        Validator lengthValidator = input -> input.length() >= 8;
        Validator alphaValidator = input -> input.matches("[a-zA-Z]+");
        
        String email = "test@example.com";
        String password = "SecurePass123";
        String name = "JohnDoe";
        
        System.out.println("Email valid: " + emailValidator.validate(email));
        System.out.println("Password length valid: " + lengthValidator.validate(password));
        System.out.println("Name is alphabetic: " + alphaValidator.validate(name));
        
        // Formatter implementations
        System.out.println("\nFormatters:");
        Formatter uppercase = String::toUpperCase;
        Formatter lowercase = String::toLowerCase;
        Formatter titleCase = input -> input.substring(0, 1).toUpperCase() + 
                                       input.substring(1).toLowerCase();
        
        String text = "hello world";
        System.out.println("Original: " + text);
        System.out.println("Uppercase: " + uppercase.format(text));
        System.out.println("Lowercase: " + lowercase.format(text));
        System.out.println("Title case: " + titleCase.format(text));
    }
}
```

**Output:**
```
=== Custom Functional Interfaces ===

Calculator Operations:
20 + 4 = 24
20 - 4 = 16
20 * 4 = 80
20 / 4 = 5

Validators:
Email valid: true
Password length valid: true
Name is alphabetic: true

Formatters:
Original: hello world
Uppercase: HELLO WORLD
Lowercase: hello world
Title case: Hello world
```

---

## ðŸ’» Example 2: Predicate Interface

```java
import java.util.*;
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        System.out.println("=== Predicate Interface ===\n");
        
        // Basic predicates
        Predicate<Integer> isEven = num -> num % 2 == 0;
        Predicate<Integer> isPositive = num -> num > 0;
        Predicate<Integer> isGreaterThan10 = num -> num > 10;
        
        System.out.println("Number Tests:");
        int number = 12;
        System.out.println(number + " is even: " + isEven.test(number));
        System.out.println(number + " is positive: " + isPositive.test(number));
        System.out.println(number + " is > 10: " + isGreaterThan10.test(number));
        
        // Combining predicates
        System.out.println("\nCombining Predicates:");
        Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
        Predicate<Integer> isEvenOrGreaterThan10 = isEven.or(isGreaterThan10);
        Predicate<Integer> isNotEven = isEven.negate();
        
        System.out.println(number + " is even AND positive: " + isEvenAndPositive.test(number));
        System.out.println(number + " is even OR > 10: " + isEvenOrGreaterThan10.test(number));
        System.out.println(number + " is NOT even: " + isNotEven.test(number));
        
        // String predicates
        System.out.println("\nString Predicates:");
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<String> startsWithA = s -> s.startsWith("A");
        Predicate<String> hasMinLength = s -> s.length() >= 5;
        
        List<String> names = Arrays.asList("Alice", "Bob", "Andrew", "Charlie", "");
        System.out.println("Names starting with A:");
        names.stream()
             .filter(startsWithA)
             .forEach(System.out::println);
        
        System.out.println("\nNames with length >= 5:");
        names.stream()
             .filter(hasMinLength)
             .forEach(System.out::println);
    }
}
```

**Output:**
```
=== Predicate Interface ===

Number Tests:
12 is even: true
12 is positive: true
12 is > 10: true

Combining Predicates:
12 is even AND positive: true
12 is even OR > 10: true
12 is NOT even: false

String Predicates:
Names starting with A:
Alice
Andrew

Names with length >= 5:
Alice
Andrew
Charlie
```

---

## ðŸ’» Example 3: Function Interface

```java
import java.util.*;
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        System.out.println("=== Function Interface ===\n");
        
        // Basic functions
        Function<String, Integer> stringLength = String::length;
        Function<Integer, Integer> square = n -> n * n;
        Function<Integer, String> intToString = Object::toString;
        
        System.out.println("Basic Functions:");
        String text = "Lambda";
        System.out.println("Length of '" + text + "': " + stringLength.apply(text));
        System.out.println("Square of 5: " + square.apply(5));
        System.out.println("Int to String: " + intToString.apply(42));
        
        // Function composition
        System.out.println("\nFunction Composition:");
        Function<Integer, Integer> addTwo = n -> n + 2;
        Function<Integer, Integer> multiplyByThree = n -> n * 3;
        
        // andThen: f(x) then g(x) = g(f(x))
        Function<Integer, Integer> addThenMultiply = addTwo.andThen(multiplyByThree);
        System.out.println("Add 2 then multiply by 3: " + addThenMultiply.apply(5)); // (5+2)*3 = 21
        
        // compose: g(x) then f(x) = f(g(x))
        Function<Integer, Integer> multiplyThenAdd = addTwo.compose(multiplyByThree);
        System.out.println("Multiply by 3 then add 2: " + multiplyThenAdd.apply(5)); // (5*3)+2 = 17
        
        // Complex transformations
        System.out.println("\nComplex Transformations:");
        Function<String, String> uppercase = String::toUpperCase;
        Function<String, String> addPrefix = s -> "Mr. " + s;
        Function<String, Integer> getLength = String::length;
        
        Function<String, String> transform = uppercase.andThen(addPrefix);
        System.out.println("Transform 'john': " + transform.apply("john"));
        
        Function<String, Integer> processString = uppercase.andThen(addPrefix).andThen(getLength);
        System.out.println("Length after processing 'john': " + processString.apply("john"));
        
        // List transformation
        System.out.println("\nList Transformation:");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Function<Integer, Integer> doubleIt = n -> n * 2;
        
        System.out.print("Doubled numbers: ");
        numbers.stream()
               .map(doubleIt)
               .forEach(n -> System.out.print(n + " "));
        System.out.println();
    }
}
```

**Output:**
```
=== Function Interface ===

Basic Functions:
Length of 'Lambda': 6
Square of 5: 25
Int to String: 42

Function Composition:
Add 2 then multiply by 3: 21
Multiply by 3 then add 2: 17

Complex Transformations:
Transform 'john': Mr. JOHN
Length after processing 'john': 8

List Transformation:
Doubled numbers: 2 4 6 8 10
```

---

## ðŸ’» Example 4: Consumer and Supplier

```java
import java.util.*;
import java.util.function.*;

public class ConsumerSupplierExample {
    public static void main(String[] args) {
        System.out.println("=== Consumer and Supplier ===\n");
        
        // Consumer examples
        System.out.println("Consumer Examples:");
        Consumer<String> print = System.out::println;
        Consumer<String> printUppercase = s -> System.out.println(s.toUpperCase());
        Consumer<Integer> printSquare = n -> System.out.println("Square: " + (n * n));
        
        print.accept("Hello Lambda");
        printUppercase.accept("lowercase text");
        printSquare.accept(5);
        
        // Chaining consumers
        System.out.println("\nChaining Consumers:");
        Consumer<String> c1 = s -> System.out.print("C1: " + s + " ");
        Consumer<String> c2 = s -> System.out.print("C2: " + s.toUpperCase() + " ");
        Consumer<String> c3 = s -> System.out.println("C3: " + s.length());
        
        Consumer<String> combined = c1.andThen(c2).andThen(c3);
        combined.accept("test");
        
        // Consumer with collections
        System.out.println("\nConsumer with Collections:");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.forEach(name -> System.out.println("Hello, " + name + "!"));
        
        // Supplier examples
        System.out.println("\nSupplier Examples:");
        Supplier<String> stringSupplier = () -> "Hello from Supplier";
        Supplier<Integer> randomSupplier = () -> (int) (Math.random() * 100);
        Supplier<List<String>> listSupplier = ArrayList::new;
        
        System.out.println(stringSupplier.get());
        System.out.println("Random number: " + randomSupplier.get());
        System.out.println("New list: " + listSupplier.get());
        
        // Supplier with lazy evaluation
        System.out.println("\nLazy Evaluation with Supplier:");
        Supplier<Double> expensiveOperation = () -> {
            System.out.println("Performing expensive operation...");
            return Math.pow(123456, 7);
        };
        
        System.out.println("Supplier created (not executed yet)");
        System.out.println("Result: " + expensiveOperation.get());
    }
}
```

**Output:**
```
=== Consumer and Supplier ===

Consumer Examples:
Hello Lambda
LOWERCASE TEXT
Square: 25

Chaining Consumers:
C1: test C2: TEST C3: 4

Consumer with Collections:
Hello, Alice!
Hello, Bob!
Hello, Charlie!

Supplier Examples:
Hello from Supplier
Random number: 47
New list: []

Lazy Evaluation with Supplier:
Supplier created (not executed yet)
Performing expensive operation...
Result: 5.123785196625E40
```

---

## ðŸ’» Example 5: BiFunction and BinaryOperator

```java
import java.util.function.*;

public class BiFunctionExample {
    public static void main(String[] args) {
        System.out.println("=== BiFunction and BinaryOperator ===\n");
        
        // BiFunction examples
        System.out.println("BiFunction Examples:");
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
        BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
        BiFunction<Integer, Integer, Double> divide = (a, b) -> b != 0 ? (double) a / b : 0.0;
        
        System.out.println("5 + 3 = " + add.apply(5, 3));
        System.out.println("5 * 3 = " + multiply.apply(5, 3));
        System.out.println("Concat: " + concat.apply("Hello", "World"));
        System.out.println("10 / 3 = " + divide.apply(10, 3));
        
        // BiFunction with andThen
        System.out.println("\nBiFunction with andThen:");
        BiFunction<Integer, Integer, Integer> addNumbers = (a, b) -> a + b;
        Function<Integer, Integer> squareResult = n -> n * n;
        
        BiFunction<Integer, Integer, Integer> addAndSquare = addNumbers.andThen(squareResult);
        System.out.println("(3 + 4)Â² = " + addAndSquare.apply(3, 4)); // (7)Â² = 49
        
        // BinaryOperator examples (same input/output type)
        System.out.println("\nBinaryOperator Examples:");
        BinaryOperator<Integer> max = (a, b) -> a > b ? a : b;
        BinaryOperator<Integer> min = (a, b) -> a < b ? a : b;
        BinaryOperator<String> mergeStrings = (s1, s2) -> s1.toUpperCase() + " " + s2.toLowerCase();
        
        System.out.println("Max(10, 20): " + max.apply(10, 20));
        System.out.println("Min(10, 20): " + min.apply(10, 20));
        System.out.println("Merge: " + mergeStrings.apply("Hello", "WORLD"));
        
        // Using BinaryOperator.maxBy and minBy
        System.out.println("\nBinaryOperator with Comparator:");
        BinaryOperator<String> maxByLength = BinaryOperator.maxBy(
            (s1, s2) -> Integer.compare(s1.length(), s2.length())
        );
        BinaryOperator<String> minByLength = BinaryOperator.minBy(
            (s1, s2) -> Integer.compare(s1.length(), s2.length())
        );
        
        System.out.println("Longer string: " + maxByLength.apply("Java", "Lambda"));
        System.out.println("Shorter string: " + minByLength.apply("Java", "Lambda"));
    }
}
```

**Output:**
```
=== BiFunction and BinaryOperator ===

BiFunction Examples:
5 + 3 = 8
5 * 3 = 15
Concat: Hello World
10 / 3 = 3.3333333333333335

BiFunction with andThen:
(3 + 4)Â² = 49

BinaryOperator Examples:
Max(10, 20): 20
Min(10, 20): 10
Merge: HELLO world

BinaryOperator with Comparator:
Longer string: Lambda
Shorter string: Java
```

---

## ðŸ’» Example 6: Specialized Functional Interfaces

```java
import java.util.function.*;

public class SpecializedFunctionalInterfaces {
    public static void main(String[] args) {
        System.out.println("=== Specialized Functional Interfaces ===\n");
        
        // IntPredicate - avoids boxing/unboxing
        System.out.println("IntPredicate:");
        IntPredicate isEven = n -> n % 2 == 0;
        System.out.println("4 is even: " + isEven.test(4));
        System.out.println("5 is even: " + isEven.test(5));
        
        // IntFunction - takes int, returns object
        System.out.println("\nIntFunction:");
        IntFunction<String> intToString = n -> "Number: " + n;
        System.out.println(intToString.apply(42));
        
        // ToIntFunction - takes object, returns int
        System.out.println("\nToIntFunction:");
        ToIntFunction<String> stringToLength = String::length;
        System.out.println("Length of 'Lambda': " + stringToLength.applyAsInt("Lambda"));
        
        // IntUnaryOperator - takes int, returns int
        System.out.println("\nIntUnaryOperator:");
        IntUnaryOperator square = n -> n * n;
        IntUnaryOperator increment = n -> n + 1;
        System.out.println("Square of 5: " + square.applyAsInt(5));
        System.out.println("Increment 10: " + increment.applyAsInt(10));
        
        // IntBinaryOperator - takes two ints, returns int
        System.out.println("\nIntBinaryOperator:");
        IntBinaryOperator add = (a, b) -> a + b;
        IntBinaryOperator multiply = (a, b) -> a * b;
        System.out.println("5 + 3 = " + add.applyAsInt(5, 3));
        System.out.println("5 * 3 = " + multiply.applyAsInt(5, 3));
        
        // IntConsumer - consumes int
        System.out.println("\nIntConsumer:");
        IntConsumer printer = n -> System.out.println("Value: " + n);
        printer.accept(100);
        
        // IntSupplier - supplies int
        System.out.println("\nIntSupplier:");
        IntSupplier randomInt = () -> (int) (Math.random() * 100);
        System.out.println("Random int: " + randomInt.getAsInt());
        
        // Similar interfaces exist for Long and Double
        System.out.println("\nLongPredicate:");
        LongPredicate isPositive = n -> n > 0;
        System.out.println("100L is positive: " + isPositive.test(100L));
        
        System.out.println("\nDoublePredicate:");
        DoublePredicate isGreaterThanOne = n -> n > 1.0;
        System.out.println("1.5 > 1.0: " + isGreaterThanOne.test(1.5));
    }
}
```

**Output:**
```
=== Specialized Functional Interfaces ===

IntPredicate:
4 is even: true
5 is even: false

IntFunction:
Number: 42

ToIntFunction:
Length of 'Lambda': 6

IntUnaryOperator:
Square of 5: 25
Increment 10: 11

IntBinaryOperator:
5 + 3 = 8
5 * 3 = 15

IntConsumer:
Value: 100

IntSupplier:
Random int: 47

LongPredicate:
100L is positive: true

DoublePredicate:
1.5 > 1.0: true
```

---

## ðŸ’» Example 7: @FunctionalInterface Annotation

```java
// Valid functional interfaces
@FunctionalInterface
interface ValidInterface1 {
    void singleMethod();
}

@FunctionalInterface
interface ValidInterface2 {
    void singleAbstractMethod();
    
    // Default methods are allowed
    default void defaultMethod() {
        System.out.println("Default method");
    }
    
    // Static methods are allowed
    static void staticMethod() {
        System.out.println("Static method");
    }
}

@FunctionalInterface
interface ValidInterface3 {
    void myMethod();
    
    // Methods from Object class don't count
    String toString();
    boolean equals(Object obj);
    int hashCode();
}

// This will cause compilation error if uncommented
// @FunctionalInterface
// interface InvalidInterface {
//     void method1();
//     void method2();  // Two abstract methods!
// }

public class FunctionalInterfaceAnnotation {
    public static void main(String[] args) {
        System.out.println("=== @FunctionalInterface Annotation ===\n");
        
        // Using valid functional interfaces
        ValidInterface1 vi1 = () -> System.out.println("ValidInterface1 implemented");
        vi1.singleMethod();
        
        ValidInterface2 vi2 = () -> System.out.println("ValidInterface2 implemented");
        vi2.singleAbstractMethod();
        vi2.defaultMethod();
        ValidInterface2.staticMethod();
        
        ValidInterface3 vi3 = () -> System.out.println("ValidInterface3 implemented");
        vi3.myMethod();
        
        System.out.println("\nBenefits of @FunctionalInterface:");
        System.out.println("1. Compiler checks for single abstract method");
        System.out.println("2. Documents intent clearly");
        System.out.println("3. Prevents accidental addition of abstract methods");
        System.out.println("4. IDE support and better tooling");
    }
}
```

**Output:**
```
=== @FunctionalInterface Annotation ===

ValidInterface1 implemented
ValidInterface2 implemented
Default method
Static method
ValidInterface3 implemented

Benefits of @FunctionalInterface:
1. Compiler checks for single abstract method
2. Documents intent clearly
3. Prevents accidental addition of abstract methods
4. IDE support and better tooling
```

---

## ðŸ’» Example 8: Functional Interface Factory Pattern

```java
import java.util.function.*;

public class FunctionalInterfaceFactory {
    
    // Factory methods for creating functional interfaces
    public static <T> Predicate<T> createRangePredicate(int min, int max, 
                                                        Function<T, Integer> extractor) {
        return t -> {
            int value = extractor.apply(t);
            return value >= min && value <= max;
        };
    }
    
    public static <T> Consumer<T> createLogger(String prefix) {
        return t -> System.out.println(prefix + ": " + t);
    }
    
    public static <T, R> Function<T, R> createCachedFunction(Function<T, R> function) {
        return new Function<T, R>() {
            private T cachedInput;
            private R cachedOutput;
            
            @Override
            public R apply(T input) {
                if (cachedInput == null || !cachedInput.equals(input)) {
                    System.out.println("Computing result for: " + input);
                    cachedInput = input;
                    cachedOutput = function.apply(input);
                } else {
                    System.out.println("Returning cached result for: " + input);
                }
                return cachedOutput;
            }
        };
    }
    
    public static void main(String[] args) {
        System.out.println("=== Functional Interface Factory ===\n");
        
        // Create range predicate
        System.out.println("Range Predicate:");
        Predicate<String> lengthInRange = createRangePredicate(3, 6, String::length);
        System.out.println("'Hi' length in range [3,6]: " + lengthInRange.test("Hi"));
        System.out.println("'Java' length in range [3,6]: " + lengthInRange.test("Java"));
        System.out.println("'Programming' length in range [3,6]: " + lengthInRange.test("Programming"));
        
        // Create logger
        System.out.println("\nLogger:");
        Consumer<String> infoLogger = createLogger("INFO");
        Consumer<String> errorLogger = createLogger("ERROR");
        infoLogger.accept("Application started");
        errorLogger.accept("Something went wrong");
        
        // Create cached function
        System.out.println("\nCached Function:");
        Function<Integer, Integer> expensiveSquare = createCachedFunction(n -> {
            try {
                Thread.sleep(100); // Simulate expensive operation
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return n * n;
        });
        
        System.out.println("Result: " + expensiveSquare.apply(5));
        System.out.println("Result: " + expensiveSquare.apply(5));  // Cached
        System.out.println("Result: " + expensiveSquare.apply(6));  // New computation
    }
}
```

---

## ðŸ’» Example 9: Chaining Functional Interfaces

```java
import java.util.*;
import java.util.function.*;

public class ChainingFunctionalInterfaces {
    public static void main(String[] args) {
        System.out.println("=== Chaining Functional Interfaces ===\n");
        
        // Chaining Predicates
        System.out.println("Chaining Predicates:");
        Predicate<Integer> isPositive = n -> n > 0;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isLessThan100 = n -> n < 100;
        
        Predicate<Integer> complexPredicate = isPositive
            .and(isEven)
            .and(isLessThan100);
        
        List<Integer> numbers = Arrays.asList(-5, 0, 4, 8, 15, 50, 102);
        System.out.println("Numbers that are positive, even, and < 100:");
        numbers.stream()
               .filter(complexPredicate)
               .forEach(n -> System.out.print(n + " "));
        System.out.println("\n");
        
        // Chaining Functions
        System.out.println("Chaining Functions:");
        Function<String, String> trim = String::trim;
        Function<String, String> uppercase = String::toUpperCase;
        Function<String, String> addExclamation = s -> s + "!";
        
        Function<String, String> pipeline = trim
            .andThen(uppercase)
            .andThen(addExclamation);
        
        String input = "  hello world  ";
        System.out.println("Original: '" + input + "'");
        System.out.println("Processed: '" + pipeline.apply(input) + "'");
        
        // Chaining Consumers
        System.out.println("\nChaining Consumers:");
        Consumer<List<Integer>> addElements = list -> {
            list.add(1);
            list.add(2);
            list.add(3);
        };
        Consumer<List<Integer>> printSize = list -> 
            System.out.println("Size: " + list.size());
        Consumer<List<Integer>> printElements = list -> 
            System.out.println("Elements: " + list);
        
        Consumer<List<Integer>> pipeline2 = addElements
            .andThen(printSize)
            .andThen(printElements);
        
        List<Integer> myList = new ArrayList<>();
        pipeline2.accept(myList);
    }
}
```

**Output:**
```
=== Chaining Functional Interfaces ===

Chaining Predicates:
Numbers that are positive, even, and < 100:
4 8 50 

Chaining Functions:
Original: '  hello world  '
Processed: 'HELLO WORLD!'

Chaining Consumers:
Size: 3
Elements: [1, 2, 3]
```

---

## ðŸ’» Example 10: Real-World Use Cases

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

class Product {
    private String name;
    private double price;
    private String category;
    
    public Product(String name, double price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
    
    @Override
    public String toString() {
        return String.format("%s ($%.2f) [%s]", name, price, category);
    }
}

public class RealWorldFunctionalInterfaces {
    public static void main(String[] args) {
        System.out.println("=== Real-World Use Cases ===\n");
        
        List<Product> products = Arrays.asList(
            new Product("Laptop", 999.99, "Electronics"),
            new Product("Mouse", 25.99, "Electronics"),
            new Product("Desk", 299.99, "Furniture"),
            new Product("Chair", 149.99, "Furniture"),
            new Product("Monitor", 399.99, "Electronics")
        );
        
        // 1. Filtering with Predicate
        System.out.println("1. Electronics under $500:");
        Predicate<Product> isElectronics = p -> p.getCategory().equals("Electronics");
        Predicate<Product> isAffordable = p -> p.getPrice() < 500;
        
        products.stream()
                .filter(isElectronics.and(isAffordable))
                .forEach(System.out::println);
        
        // 2. Transforming with Function
        System.out.println("\n2. Product names in uppercase:");
        Function<Product, String> extractName = Product::getName;
        Function<String, String> toUpperCase = String::toUpperCase;
        
        products.stream()
                .map(extractName.andThen(toUpperCase))
                .forEach(System.out::println);
        
        // 3. Processing with Consumer
        System.out.println("\n3. Apply discount:");
        Consumer<Product> applyDiscount = p -> {
            double discounted = p.getPrice() * 0.9;
            System.out.printf("%s: $%.2f -> $%.2f%n", 
                            p.getName(), p.getPrice(), discounted);
        };
        products.forEach(applyDiscount);
        
        // 4. Calculating with BiFunction
        System.out.println("\n4. Tax calculation:");
        BiFunction<Double, Double, Double> calculateTax = (price, taxRate) -> 
            price * taxRate;
        
        products.forEach(p -> {
            double tax = calculateTax.apply(p.getPrice(), 0.08);
            System.out.printf("%s: Tax = $%.2f%n", p.getName(), tax);
        });
        
        // 5. Grouping with Function
        System.out.println("\n5. Products grouped by category:");
        Map<String, List<Product>> grouped = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory));
        
        grouped.forEach((category, items) -> {
            System.out.println(category + ": " + items.size() + " items");
            items.forEach(p -> System.out.println("  - " + p));
        });
    }
}
```

---

## ðŸ“Š Built-in Functional Interfaces Summary

| Category | Interface | Method | Use Case |
|----------|-----------|--------|----------|
| **Predicate** | Predicate\<T> | `boolean test(T)` | Filtering, validation |
| | BiPredicate<T,U> | `boolean test(T,U)` | Two-input validation |
| | IntPredicate | `boolean test(int)` | Primitive int tests |
| **Function** | Function<T,R> | `R apply(T)` | Transformation |
| | BiFunction<T,U,R> | `R apply(T,U)` | Two-input transformation |
| | UnaryOperator\<T> | `T apply(T)` | Same-type transformation |
| | BinaryOperator\<T> | `T apply(T,T)` | Two same-type inputs |
| **Consumer** | Consumer\<T> | `void accept(T)` | Side effects |
| | BiConsumer<T,U> | `void accept(T,U)` | Two-input side effects |
| | IntConsumer | `void accept(int)` | Primitive int consumer |
| **Supplier** | Supplier\<T> | `T get()` | Lazy initialization |
| | IntSupplier | `int getAsInt()` | Primitive int supplier |

---

## ðŸŽ¯ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… Use @FunctionalInterface | Always annotate custom functional interfaces |
| âœ… Use standard interfaces | Prefer built-in interfaces from java.util.function |
| âœ… Keep SAM simple | Single abstract method should be focused |
| âœ… Meaningful names | Use descriptive method names |
| âœ… Document behavior | Add JavaDoc to custom interfaces |
| âœ… Use primitive versions | IntPredicate instead of Predicate\<Integer> for performance |
| âœ… Chain when appropriate | Use and(), or(), andThen() for composition |
| âš ï¸ Avoid checked exceptions | Functional interfaces don't handle checked exceptions well |
| âš ï¸ Don't abuse | Not everything needs to be a functional interface |
| âš ï¸ Consider readability | Sometimes traditional approach is clearer |

---

## âš ï¸ Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Multiple abstract methods | Interface won't be functional | Keep exactly one abstract method |
| Checked exceptions | Lambda can't throw checked exceptions | Use wrapper methods or custom interfaces |
| Overcomplication | Too many chained operations | Break into separate steps |
| Wrong interface | Using generic interface for primitives | Use specialized interfaces (IntPredicate, etc.) |
| Forgetting @FunctionalInterface | No compile-time check | Always use annotation |
| Mutable state | Side effects in functional interfaces | Keep stateless when possible |

---

## ðŸ”— Related Topics

- [Lambda Expressions](01.%20Lambda%20Expressions.md)
- [Method References](03.%20Method%20References.md)
- [Predicate Interface](04.%20Predicate%20Interface.md)
- [Function Interface](05.%20Function%20Interface.md)
- [Consumer & Supplier](06.%20Consumer%20%26%20Supplier.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## ðŸ“ Interview Questions

1. **What is a functional interface?**
   - Interface with exactly one abstract method
   - Can be implemented using lambda expressions
   - Marked with @FunctionalInterface annotation

2. **Can functional interface have multiple methods?**
   - Can have multiple default methods
   - Can have multiple static methods
   - Can have methods from Object class
   - Must have exactly one abstract method

3. **Why use @FunctionalInterface annotation?**
   - Compile-time checking
   - Documents intent
   - Prevents accidental method addition
   - Better IDE support

4. **What are built-in functional interfaces?**
   - Predicate, Function, Consumer, Supplier
   - BiFunction, BiPredicate, BiConsumer
   - UnaryOperator, BinaryOperator
   - Located in java.util.function package

5. **Difference between Predicate and Function?**
   - Predicate returns boolean
   - Function transforms input to output
   - Both take one parameter

6. **What is UnaryOperator?**
   - Special case of Function
   - Input and output types are same
   - Example: n -> n * 2

7. **What is BinaryOperator?**
   - Special case of BiFunction
   - All types (input1, input2, output) are same
   - Example: (a, b) -> a + b

8. **Can functional interface extend another interface?**
   - Yes, if total abstract methods = 1
   - Can extend multiple interfaces
   - Must maintain SAM principle

9. **Difference between Consumer and Supplier?**
   - Consumer takes input, returns nothing
   - Supplier takes nothing, returns output
   - Opposite purposes

10. **What are specialized functional interfaces?**
    - IntPredicate, LongFunction, DoubleConsumer, etc.
    - Avoid boxing/unboxing overhead
    - Better performance for primitives

11. **Can we create custom functional interfaces?**
    - Yes, with @FunctionalInterface annotation
    - Must have exactly one abstract method
    - Can add default and static methods

12. **How to chain functional interfaces?**
    - Predicate: and(), or(), negate()
    - Function: andThen(), compose()
    - Consumer: andThen()

13. **What is the difference between andThen() and compose()?**
    - andThen(): f.andThen(g) = g(f(x))
    - compose(): f.compose(g) = f(g(x))
    - Order of execution differs

14. **Can functional interface have generic types?**
    - Yes, most built-in interfaces are generic
    - Example: Function<T, R>, Predicate\<T>
    - Provides type safety

15. **Why prefer built-in functional interfaces?**
    - Standard, well-documented
    - Work seamlessly with Stream API
    - Better interoperability
    - No need to create custom interfaces

---

## ðŸ’¡ Key Takeaways

- Functional interface has exactly one abstract method (SAM)
- @FunctionalInterface annotation provides compile-time checking
- Java provides 40+ built-in functional interfaces in java.util.function
- Main interfaces: Predicate, Function, Consumer, Supplier
- Specialized interfaces (IntPredicate, etc.) avoid boxing overhead
- Can chain operations: and(), or(), andThen(), compose()
- Foundation for lambda expressions and functional programming
- Essential for Stream API and modern Java development
- Keep interfaces simple and focused
- Use standard interfaces when possible for better interoperability
