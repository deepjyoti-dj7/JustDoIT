# üéØ Function Interface

## üìñ Overview

**Function** is a functional interface that represents a function that accepts one argument and produces a result. It's used for transforming data from one form to another.

**Method Signature:** `R apply(T t)`

**Package:** `java.util.function`

**Introduced in:** Java 8 (2014)

---

## üéØ Key Methods

| Method | Description | Example |
|--------|-------------|---------|
| `apply(T t)` | Applies function | `function.apply(value)` |
| `andThen(Function)` | Compose after | `f.andThen(g)` = g(f(x)) |
| `compose(Function)` | Compose before | `f.compose(g)` = f(g(x)) |
| `identity()` | Returns input | `Function.identity()` |

---

## üíª Example 1: Basic Function

```java
import java.util.function.Function;

public class BasicFunction {
    public static void main(String[] args) {
        System.out.println("=== Basic Function ===\n");
        
        // String to Integer (length)
        Function<String, Integer> stringLength = String::length;
        System.out.println("Length of 'Lambda': " + stringLength.apply("Lambda"));
        
        // Integer to String
        Function<Integer, String> intToString = n -> "Number: " + n;
        System.out.println(intToString.apply(42));
        
        // Integer to Double (square)
        Function<Integer, Double> square = n -> Math.pow(n, 2);
        System.out.println("Square of 5: " + square.apply(5));
        
        // String transformation
        Function<String, String> uppercase = String::toUpperCase;
        Function<String, String> addPrefix = s -> "Mr. " + s;
        
        System.out.println("\nTransformations:");
        System.out.println(uppercase.apply("hello"));
        System.out.println(addPrefix.apply("John"));
    }
}
```

**Output:**
```
=== Basic Function ===

Length of 'Lambda': 6
Number: 42
Square of 5: 25.0

Transformations:
HELLO
Mr. John
```

---

## üíª Example 2: Function Composition

```java
import java.util.function.Function;

public class FunctionComposition {
    public static void main(String[] args) {
        System.out.println("=== Function Composition ===\n");
        
        Function<Integer, Integer> multiplyBy2 = n -> n * 2;
        Function<Integer, Integer> add10 = n -> n + 10;
        Function<Integer, Integer> square = n -> n * n;
        
        // andThen: f.andThen(g) means g(f(x))
        System.out.println("andThen Examples:");
        Function<Integer, Integer> multiplyThenAdd = multiplyBy2.andThen(add10);
        System.out.println("(5 * 2) + 10 = " + multiplyThenAdd.apply(5)); // 20
        
        Function<Integer, Integer> addThenSquare = add10.andThen(square);
        System.out.println("(5 + 10)¬≤ = " + addThenSquare.apply(5)); // 225
        
        // compose: f.compose(g) means f(g(x))
        System.out.println("\ncompose Examples:");
        Function<Integer, Integer> addThenMultiply = multiplyBy2.compose(add10);
        System.out.println("(5 + 10) * 2 = " + addThenMultiply.apply(5)); // 30
        
        // Complex chain
        Function<Integer, Integer> chain = multiplyBy2
                                          .andThen(add10)
                                          .andThen(square);
        System.out.println("\n((5 * 2) + 10)¬≤ = " + chain.apply(5)); // 400
        
        // String transformations
        Function<String, String> trim = String::trim;
        Function<String, String> uppercase = String::toUpperCase;
        Function<String, Integer> length = String::length;
        
        Function<String, Integer> processString = trim
                                                .andThen(uppercase)
                                                .andThen(length);
        
        String input = "  hello  ";
        System.out.println("\nProcessing '" + input + "': " + processString.apply(input));
    }
}
```

---

## üíª Example 3: Function with Collections

```java
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class FunctionWithCollections {
    public static void main(String[] args) {
        System.out.println("=== Function with Collections ===\n");
        
        List<String> names = Arrays.asList("alice", "bob", "charlie", "david");
        
        // Transform to uppercase
        Function<String, String> toUpperCase = String::toUpperCase;
        List<String> upperNames = names.stream()
                                      .map(toUpperCase)
                                      .collect(Collectors.toList());
        System.out.println("Uppercase: " + upperNames);
        
        // Get lengths
        Function<String, Integer> getLength = String::length;
        List<Integer> lengths = names.stream()
                                    .map(getLength)
                                    .collect(Collectors.toList());
        System.out.println("Lengths: " + lengths);
        
        // Complex transformation
        Function<String, String> transform = s -> s.substring(0, 1).toUpperCase() + 
                                                  s.substring(1);
        List<String> capitalized = names.stream()
                                       .map(transform)
                                       .collect(Collectors.toList());
        System.out.println("Capitalized: " + capitalized);
        
        // Number transformations
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Function<Integer, Integer> square = n -> n * n;
        
        List<Integer> squared = numbers.stream()
                                      .map(square)
                                      .collect(Collectors.toList());
        System.out.println("\nSquared numbers: " + squared);
    }
}
```

---

## üíª Example 4: BiFunction

```java
import java.util.function.BiFunction;

public class BiFunctionExample {
    public static void main(String[] args) {
        System.out.println("=== BiFunction (Two Parameters) ===\n");
        
        // Arithmetic operations
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
        BiFunction<Integer, Integer, Double> divide = (a, b) -> b != 0 ? (double) a / b : 0.0;
        
        System.out.println("5 + 3 = " + add.apply(5, 3));
        System.out.println("5 * 3 = " + multiply.apply(5, 3));
        System.out.println("10 / 3 = " + divide.apply(10, 3));
        
        // String operations
        BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
        BiFunction<String, Integer, String> repeat = (s, n) -> s.repeat(n);
        
        System.out.println("\n" + concat.apply("Hello", "World"));
        System.out.println(repeat.apply("Java ", 3));
        
        // With andThen
        BiFunction<Integer, Integer, Integer> addNumbers = (a, b) -> a + b;
        Function<Integer, Integer> squareResult = n -> n * n;
        
        BiFunction<Integer, Integer, Integer> addAndSquare = addNumbers.andThen(squareResult);
        System.out.println("\n(3 + 4)¬≤ = " + addAndSquare.apply(3, 4)); // 49
        
        // Practical example
        BiFunction<String, Integer, String> greet = (name, age) ->
            String.format("Hello %s, you are %d years old", name, age);
        
        System.out.println(greet.apply("Alice", 25));
    }
}
```

---

## üíª Example 5: UnaryOperator & BinaryOperator

```java
import java.util.function.*;

public class OperatorExample {
    public static void main(String[] args) {
        System.out.println("=== UnaryOperator & BinaryOperator ===\n");
        
        // UnaryOperator: Function where input = output type
        UnaryOperator<Integer> square = n -> n * n;
        UnaryOperator<Integer> increment = n -> n + 1;
        UnaryOperator<String> toUpper = String::toUpperCase;
        
        System.out.println("UnaryOperator:");
        System.out.println("Square of 5: " + square.apply(5));
        System.out.println("Increment 10: " + increment.apply(10));
        System.out.println("Uppercase 'hello': " + toUpper.apply("hello"));
        
        // BinaryOperator: BiFunction where all types are same
        BinaryOperator<Integer> add = (a, b) -> a + b;
        BinaryOperator<Integer> max = (a, b) -> a > b ? a : b;
        BinaryOperator<Integer> min = (a, b) -> a < b ? a : b;
        BinaryOperator<String> concat = (s1, s2) -> s1 + s2;
        
        System.out.println("\nBinaryOperator:");
        System.out.println("5 + 3 = " + add.apply(5, 3));
        System.out.println("Max(10, 20) = " + max.apply(10, 20));
        System.out.println("Min(10, 20) = " + min.apply(10, 20));
        System.out.println("Concat: " + concat.apply("Hello", "World"));
        
        // BinaryOperator.maxBy and minBy
        BinaryOperator<String> longerString = BinaryOperator.maxBy(
            (s1, s2) -> Integer.compare(s1.length(), s2.length())
        );
        
        System.out.println("\nLonger string: " + longerString.apply("Java", "Lambda"));
    }
}
```

---

## üíª Example 6: Specialized Functions

```java
import java.util.function.*;

public class SpecializedFunctions {
    public static void main(String[] args) {
        System.out.println("=== Specialized Functions ===\n");
        
        // IntFunction - takes int, returns object
        IntFunction<String> intToString = n -> "Number: " + n;
        System.out.println(intToString.apply(42));
        
        // ToIntFunction - takes object, returns int
        ToIntFunction<String> stringLength = String::length;
        System.out.println("Length: " + stringLength.applyAsInt("Lambda"));
        
        // IntUnaryOperator - int to int
        IntUnaryOperator square = n -> n * n;
        IntUnaryOperator negate = n -> -n;
        System.out.println("\nSquare of 5: " + square.applyAsInt(5));
        System.out.println("Negate 7: " + negate.applyAsInt(7));
        
        // IntBinaryOperator - two ints to int
        IntBinaryOperator multiply = (a, b) -> a * b;
        System.out.println("5 * 3 = " + multiply.applyAsInt(5, 3));
        
        // DoubleFunction
        DoubleFunction<String> formatDouble = d -> String.format("%.2f", d);
        System.out.println("\nFormatted: " + formatDouble.apply(3.14159));
        
        // ToDoubleFunction
        ToDoubleFunction<String> parseDouble = Double::parseDouble;
        System.out.println("Parsed: " + parseDouble.applyAsDouble("2.5"));
        
        // LongFunction
        LongFunction<String> longToHex = Long::toHexString;
        System.out.println("\n255 in hex: " + longToHex.apply(255L));
    }
}
```

---

## üíª Example 7: Function with Custom Objects

```java
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

class Employee {
    String name;
    double salary;
    
    Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }
    
    @Override
    public String toString() {
        return String.format("%s: $%.2f", name, salary);
    }
}

public class CustomObjectFunction {
    public static void main(String[] args) {
        System.out.println("=== Function with Custom Objects ===\n");
        
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 75000),
            new Employee("Bob", 65000),
            new Employee("Charlie", 85000)
        );
        
        // Extract names
        Function<Employee, String> getName = e -> e.name;
        List<String> names = employees.stream()
                                     .map(getName)
                                     .collect(Collectors.toList());
        System.out.println("Names: " + names);
        
        // Extract salaries
        Function<Employee, Double> getSalary = e -> e.salary;
        List<Double> salaries = employees.stream()
                                        .map(getSalary)
                                        .collect(Collectors.toList());
        System.out.println("Salaries: " + salaries);
        
        // Give raise
        Function<Employee, Employee> giveRaise = e -> 
            new Employee(e.name, e.salary * 1.1);
        
        List<Employee> raisedEmployees = employees.stream()
                                                 .map(giveRaise)
                                                 .collect(Collectors.toList());
        
        System.out.println("\nAfter 10% raise:");
        raisedEmployees.forEach(System.out::println);
        
        // Complex transformation
        Function<Employee, String> formatEmployee = e ->
            String.format("%s earns $%.0fK", e.name, e.salary / 1000);
        
        System.out.println("\nFormatted:");
        employees.stream()
                .map(formatEmployee)
                .forEach(System.out::println);
    }
}
```

---

## üíª Example 8: Function Factory Pattern

```java
import java.util.function.Function;

public class FunctionFactory {
    
    // Factory methods
    public static Function<Integer, Integer> createMultiplier(int factor) {
        return n -> n * factor;
    }
    
    public static Function<String, String> createFormatter(String prefix, String suffix) {
        return s -> prefix + s + suffix;
    }
    
    public static <T> Function<T, T> createValidator(T defaultValue) {
        return input -> input != null ? input : defaultValue;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Function Factory Pattern ===\n");
        
        // Create multipliers
        Function<Integer, Integer> double = createMultiplier(2);
        Function<Integer, Integer> triple = createMultiplier(3);
        
        System.out.println("5 doubled: " + doubleIt.apply(5));
        System.out.println("5 tripled: " + triple.apply(5));
        
        // Create formatters
        Function<String, String> htmlTag = createFormatter("<b>", "</b>");
        Function<String, String> quotes = createFormatter("\"", "\"");
        
        System.out.println("\n" + htmlTag.apply("Bold Text"));
        System.out.println(quotes.apply("Quoted Text"));
        
        // Create validators
        Function<String, String> stringValidator = createValidator("default");
        Function<Integer, Integer> intValidator = createValidator(0);
        
        System.out.println("\nValidated null: " + stringValidator.apply(null));
        System.out.println("Validated value: " + stringValidator.apply("actual"));
    }
}
```

---

## üíª Example 9: Caching with Function

```java
import java.util.*;
import java.util.function.Function;

public class CachingFunction {
    
    public static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new HashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Caching with Function ===\n");
        
        // Expensive function
        Function<Integer, Integer> expensive = n -> {
            System.out.println("Computing factorial of " + n + "...");
            int result = 1;
            for (int i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        };
        
        // Cached version
        Function<Integer, Integer> cached = memoize(expensive);
        
        System.out.println("First call:");
        System.out.println("Result: " + cached.apply(5));
        
        System.out.println("\nSecond call (cached):");
        System.out.println("Result: " + cached.apply(5));
        
        System.out.println("\nThird call (new input):");
        System.out.println("Result: " + cached.apply(6));
    }
}
```

---

## üíª Example 10: Real-World Use Cases

```java
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class RealWorldFunctions {
    
    // Data transformation pipeline
    public static Function<String, String> buildPipeline() {
        return ((Function<String, String>) String::trim)
               .andThen(String::toLowerCase)
               .andThen(s -> s.replaceAll("\\s+", "_"));
    }
    
    public static void main(String[] args) {
        System.out.println("=== Real-World Use Cases ===\n");
        
        // 1. URL slug generator
        Function<String, String> slugGenerator = buildPipeline();
        
        System.out.println("1. URL Slug Generator:");
        String title = "  Hello World from Java  ";
        System.out.println("Title: '" + title + "'");
        System.out.println("Slug: '" + slugGenerator.apply(title) + "'");
        
        // 2. Price calculator with tax
        Function<Double, Double> addTax = price -> price * 1.08;
        Function<Double, Double> applyDiscount = price -> price * 0.9;
        Function<Double, String> formatPrice = price -> String.format("$%.2f", price);
        
        Function<Double, String> priceCalculator = addTax
                                                  .andThen(applyDiscount)
                                                  .andThen(formatPrice);
        
        System.out.println("\n2. Price Calculator:");
        System.out.println("Final price: " + priceCalculator.apply(100.0));
        
        // 3. Data cleaning
        List<String> rawData = Arrays.asList(
            " alice@example.com ",
            " BOB@TEST.COM ",
            "charlie@demo.com  "
        );
        
        Function<String, String> cleanEmail = String::trim;
        Function<String, String> normalizeEmail = String::toLowerCase;
        Function<String, String> cleanData = cleanEmail.andThen(normalizeEmail);
        
        System.out.println("\n3. Data Cleaning:");
        List<String> cleaned = rawData.stream()
                                     .map(cleanData)
                                     .collect(Collectors.toList());
        System.out.println("Cleaned: " + cleaned);
        
        // 4. Data aggregation
        Map<String, Integer> wordFrequency = Arrays.asList(
            "java", "lambda", "java", "function", "lambda", "java"
        ).stream()
         .collect(Collectors.groupingBy(
             Function.identity(),
             Collectors.summingInt(e -> 1)
         ));
        
        System.out.println("\n4. Word Frequency:");
        System.out.println(wordFrequency);
    }
}
```

---

## üìä Function Variants

| Type | Method | Description | Example |
|------|--------|-------------|---------|
| Function<T,R> | `R apply(T)` | Transform T to R | `n -> n * 2` |
| BiFunction<T,U,R> | `R apply(T, U)` | Two inputs | `(a,b) -> a + b` |
| UnaryOperator\<T> | `T apply(T)` | Same type I/O | `n -> n + 1` |
| BinaryOperator\<T> | `T apply(T, T)` | Two same inputs | `(a,b) -> Math.max(a,b)` |
| IntFunction\<R> | `R apply(int)` | Int to object | `n -> "Num:" + n` |
| ToIntFunction\<T> | `int applyAsInt(T)` | Object to int | `String::length` |

---

## üéØ Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use composition | Build complex functions from simple ones |
| ‚úÖ Keep functions pure | No side effects |
| ‚úÖ Use method references | When possible for readability |
| ‚úÖ Chain with andThen | For sequential transformations |
| ‚úÖ Use specialized types | Better performance (IntFunction, etc.) |
| ‚úÖ Meaningful names | Describe transformation clearly |
| ‚ö†Ô∏è Avoid deep nesting | Keep chains readable |
| ‚ö†Ô∏è Handle nulls | Add null checks when needed |

---

## üîó Related Topics

- [Lambda Expressions](01.%20Lambda%20Expressions.md)
- [Functional Interfaces](02.%20Functional%20Interfaces.md)
- [Predicate Interface](04.%20Predicate%20Interface.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## üìù Interview Questions

1. **What is Function interface?** - Transforms input to output
2. **Difference between andThen and compose?** - Order of execution
3. **What is UnaryOperator?** - Function where input = output type
4. **What is BinaryOperator?** - BiFunction where all types same
5. **What is Function.identity()?** - Returns input unchanged
6. **When to use Function vs Predicate?** - Transformation vs testing
7. **Can Function have side effects?** - Not recommended
8. **What are specialized functions?** - IntFunction, ToIntFunction, etc.
9. **How to cache Function results?** - Use memoization pattern
10. **What is BiFunction?** - Function with two parameters

---

## üí° Key Takeaways

- Function transforms input to output
- Use andThen() and compose() for function composition
- UnaryOperator and BinaryOperator for same-type operations
- Specialized versions for primitives (performance)
- Keep functions pure (no side effects)
- Essential for data transformation and Stream API
- Can be chained to build complex transformations
