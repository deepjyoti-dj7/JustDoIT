# üéØ Consumer & Supplier

## üìñ Overview

**Consumer** and **Supplier** are complementary functional interfaces in Java 8. Consumer accepts input and returns nothing, while Supplier takes no input and returns a value.

**Consumer Method:** `void accept(T t)` - Consumes input  
**Supplier Method:** `T get()` - Supplies output

**Package:** `java.util.function`

**Introduced in:** Java 8 (2014)

---

## üéØ Consumer Interface

| Type | Method | Description |
|------|--------|-------------|
| Consumer\<T> | `void accept(T)` | Single parameter |
| BiConsumer<T,U> | `void accept(T, U)` | Two parameters |
| IntConsumer | `void accept(int)` | Primitive int |
| LongConsumer | `void accept(long)` | Primitive long |
| DoubleConsumer | `void accept(double)` | Primitive double |

---

## üíª Example 1: Basic Consumer

```java
import java.util.*;
import java.util.function.Consumer;

public class BasicConsumer {
    public static void main(String[] args) {
        System.out.println("=== Basic Consumer ===\n");
        
        // Simple consumers
        Consumer<String> print = System.out::println;
        Consumer<String> printUpper = s -> System.out.println(s.toUpperCase());
        Consumer<Integer> printSquare = n -> System.out.println("Square: " + (n * n));
        
        print.accept("Hello Consumer");
        printUpper.accept("lowercase");
        printSquare.accept(5);
        
        // Consumer with List
        System.out.println("\nWith Collections:");
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.forEach(name -> System.out.println("Hello, " + name));
        
        // Consumer with map
        Map<String, Integer> ages = new HashMap<>();
        ages.put("Alice", 25);
        ages.put("Bob", 30);
        
        System.out.println("\nMap forEach:");
        ages.forEach((name, age) -> 
            System.out.println(name + " is " + age + " years old")
        );
    }
}
```

**Output:**
```
=== Basic Consumer ===

Hello Consumer
LOWERCASE
Square: 25

With Collections:
Hello, Alice
Hello, Bob
Hello, Charlie

Map forEach:
Alice is 25 years old
Bob is 30 years old
```

---

## üíª Example 2: Chaining Consumers

```java
import java.util.function.Consumer;

public class ChainingConsumers {
    public static void main(String[] args) {
        System.out.println("=== Chaining Consumers ===\n");
        
        Consumer<String> c1 = s -> System.out.println("C1: " + s);
        Consumer<String> c2 = s -> System.out.println("C2: " + s.toUpperCase());
        Consumer<String> c3 = s -> System.out.println("C3: Length = " + s.length());
        
        // Chain consumers with andThen
        Consumer<String> combined = c1.andThen(c2).andThen(c3);
        
        System.out.println("Single consumer:");
        c1.accept("hello");
        
        System.out.println("\nChained consumers:");
        combined.accept("hello");
        
        // Practical example: logging and processing
        Consumer<String> log = s -> System.out.println("[LOG] Processing: " + s);
        Consumer<String> process = s -> System.out.println("[PROCESS] Result: " + s.trim());
        Consumer<String> validate = s -> {
            if (!s.isEmpty()) {
                System.out.println("[VALIDATE] Valid input");
            }
        };
        
        Consumer<String> pipeline = log.andThen(validate).andThen(process);
        
        System.out.println("\nProcessing Pipeline:");
        pipeline.accept("  data  ");
    }
}
```

---

## üíª Example 3: BiConsumer

```java
import java.util.*;
import java.util.function.BiConsumer;

public class BiConsumerExample {
    public static void main(String[] args) {
        System.out.println("=== BiConsumer (Two Parameters) ===\n");
        
        // Basic BiConsumers
        BiConsumer<String, Integer> printNameAge = (name, age) ->
            System.out.println(name + " is " + age + " years old");
        
        BiConsumer<Integer, Integer> printSum = (a, b) ->
            System.out.println(a + " + " + b + " = " + (a + b));
        
        printNameAge.accept("Alice", 25);
        printSum.accept(10, 20);
        
        // With Map
        System.out.println("\nWith Map:");
        Map<String, Double> prices = new HashMap<>();
        prices.put("Apple", 1.50);
        prices.put("Banana", 0.75);
        prices.put("Orange", 2.00);
        
        BiConsumer<String, Double> printPrice = (item, price) ->
            System.out.printf("%s costs $%.2f%n", item, price);
        
        prices.forEach(printPrice);
        
        // Chaining BiConsumers
        System.out.println("\nChaining BiConsumers:");
        BiConsumer<String, Integer> print1 = (s, n) -> 
            System.out.println("First: " + s + ", " + n);
        BiConsumer<String, Integer> print2 = (s, n) -> 
            System.out.println("Second: " + s.toUpperCase() + ", " + (n * 2));
        
        BiConsumer<String, Integer> chained = print1.andThen(print2);
        chained.accept("test", 5);
    }
}
```

---

## üíª Example 4: Specialized Consumers

```java
import java.util.function.*;
import java.util.stream.IntStream;

public class SpecializedConsumers {
    public static void main(String[] args) {
        System.out.println("=== Specialized Consumers ===\n");
        
        // IntConsumer
        IntConsumer printInt = n -> System.out.print(n + " ");
        IntConsumer printSquare = n -> System.out.print((n * n) + " ");
        
        System.out.println("IntConsumer:");
        IntStream.rangeClosed(1, 5).forEach(printInt);
        System.out.println("\n\nSquares:");
        IntStream.rangeClosed(1, 5).forEach(printSquare);
        
        // LongConsumer
        System.out.println("\n\nLongConsumer:");
        LongConsumer printLong = n -> System.out.println("Long: " + n);
        printLong.accept(1000000L);
        
        // DoubleConsumer
        System.out.println("\nDoubleConsumer:");
        DoubleConsumer printDouble = d -> System.out.printf("%.2f%n", d);
        printDouble.accept(3.14159);
        
        // ObjIntConsumer
        System.out.println("\nObjIntConsumer:");
        ObjIntConsumer<String> printWithIndex = (str, index) ->
            System.out.println(index + ": " + str);
        
        printWithIndex.accept("First", 1);
        printWithIndex.accept("Second", 2);
    }
}
```

---

## üéØ Supplier Interface

| Type | Method | Description |
|------|--------|-------------|
| Supplier\<T> | `T get()` | Supplies object |
| IntSupplier | `int getAsInt()` | Supplies int |
| LongSupplier | `long getAsLong()` | Supplies long |
| DoubleSupplier | `double getAsDouble()` | Supplies double |
| BooleanSupplier | `boolean getAsBoolean()` | Supplies boolean |

---

## üíª Example 5: Basic Supplier

```java
import java.util.*;
import java.util.function.Supplier;

public class BasicSupplier {
    public static void main(String[] args) {
        System.out.println("=== Basic Supplier ===\n");
        
        // Simple suppliers
        Supplier<String> stringSupplier = () -> "Hello from Supplier";
        Supplier<Integer> randomSupplier = () -> (int) (Math.random() * 100);
        Supplier<Date> dateSupplier = Date::new;
        Supplier<List<String>> listSupplier = ArrayList::new;
        
        System.out.println(stringSupplier.get());
        System.out.println("Random: " + randomSupplier.get());
        System.out.println("Date: " + dateSupplier.get());
        System.out.println("New List: " + listSupplier.get());
        
        // UUID generator
        Supplier<String> uuidSupplier = () -> UUID.randomUUID().toString();
        System.out.println("\nUUID: " + uuidSupplier.get());
        
        // Current time supplier
        Supplier<Long> timeSupplier = System::currentTimeMillis;
        System.out.println("Timestamp: " + timeSupplier.get());
    }
}
```

**Output:**
```
=== Basic Supplier ===

Hello from Supplier
Random: 47
Date: Tue Dec 03 10:30:45 UTC 2025
New List: []

UUID: 550e8400-e29b-41d4-a716-446655440000
Timestamp: 1701600645123
```

---

## üíª Example 6: Lazy Evaluation with Supplier

```java
import java.util.function.Supplier;

public class LazyEvaluation {
    
    private static String expensiveOperation() {
        System.out.println("Performing expensive operation...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Expensive Result";
    }
    
    // Without Supplier - always executes
    public static void logEager(String message, String data) {
        if (message != null) {
            System.out.println(message + ": " + data);
        }
    }
    
    // With Supplier - lazy execution
    public static void logLazy(String message, Supplier<String> dataSupplier) {
        if (message != null) {
            System.out.println(message + ": " + dataSupplier.get());
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lazy Evaluation ===\n");
        
        System.out.println("Eager (always executes):");
        logEager(null, expensiveOperation());  // Executes even though not needed
        
        System.out.println("\nLazy (executes only when needed):");
        logLazy(null, LazyEvaluation::expensiveOperation);  // Doesn't execute
        
        System.out.println("\nLazy with valid message:");
        logLazy("Info", LazyEvaluation::expensiveOperation);  // Executes now
    }
}
```

---

## üíª Example 7: Factory Pattern with Supplier

```java
import java.util.function.Supplier;
import java.util.*;

class Product {
    String name;
    Product(String name) { this.name = name; }
    @Override
    public String toString() { return "Product: " + name; }
}

public class SupplierFactory {
    
    // Factory methods returning Suppliers
    public static Supplier<Product> createProductSupplier(String name) {
        return () -> new Product(name);
    }
    
    public static <T> Supplier<List<T>> createListSupplier() {
        return ArrayList::new;
    }
    
    public static <T> Supplier<Set<T>> createSetSupplier() {
        return HashSet::new;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Factory Pattern with Supplier ===\n");
        
        // Product factories
        Supplier<Product> laptopFactory = createProductSupplier("Laptop");
        Supplier<Product> phoneFactory = createProductSupplier("Phone");
        
        System.out.println("Creating products:");
        System.out.println(laptopFactory.get());
        System.out.println(phoneFactory.get());
        System.out.println(phoneFactory.get());  // Each call creates new instance
        
        // Collection factories
        Supplier<List<String>> listFactory = createListSupplier();
        Supplier<Set<Integer>> setFactory = createSetSupplier();
        
        System.out.println("\nCreating collections:");
        List<String> list = listFactory.get();
        list.add("Item1");
        System.out.println("List: " + list);
        
        Set<Integer> set = setFactory.get();
        set.add(1);
        System.out.println("Set: " + set);
    }
}
```

---

## üíª Example 8: Specialized Suppliers

```java
import java.util.function.*;
import java.util.Random;

public class SpecializedSuppliers {
    public static void main(String[] args) {
        System.out.println("=== Specialized Suppliers ===\n");
        
        Random random = new Random();
        
        // IntSupplier
        IntSupplier randomInt = () -> random.nextInt(100);
        System.out.println("Random int: " + randomInt.getAsInt());
        System.out.println("Random int: " + randomInt.getAsInt());
        
        // LongSupplier
        LongSupplier timestamp = System::currentTimeMillis;
        System.out.println("\nTimestamp: " + timestamp.getAsLong());
        
        // DoubleSupplier
        DoubleSupplier randomDouble = random::nextDouble;
        System.out.println("\nRandom double: " + randomDouble.getAsDouble());
        
        // BooleanSupplier
        BooleanSupplier coinFlip = () -> random.nextBoolean();
        System.out.println("\nCoin flip: " + (coinFlip.getAsBoolean() ? "Heads" : "Tails"));
        System.out.println("Coin flip: " + (coinFlip.getAsBoolean() ? "Heads" : "Tails"));
        
        // Sequence generators
        IntSupplier counter = new IntSupplier() {
            private int count = 0;
            @Override
            public int getAsInt() {
                return count++;
            }
        };
        
        System.out.println("\nCounter:");
        System.out.println(counter.getAsInt());
        System.out.println(counter.getAsInt());
        System.out.println(counter.getAsInt());
    }
}
```

---

## üíª Example 9: Consumer and Supplier Together

```java
import java.util.*;
import java.util.function.*;

public class ConsumerSupplierTogether {
    
    public static void processData(Supplier<String> dataSupplier, 
                                  Consumer<String> dataProcessor) {
        String data = dataSupplier.get();
        dataProcessor.accept(data);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Consumer & Supplier Together ===\n");
        
        // Data generation and processing pipeline
        Supplier<Integer> randomNumberSupplier = () -> (int) (Math.random() * 100);
        Consumer<Integer> numberProcessor = n -> 
            System.out.println("Processing number: " + n + ", Square: " + (n * n));
        
        System.out.println("Generate and process:");
        for (int i = 0; i < 3; i++) {
            Integer number = randomNumberSupplier.get();
            numberProcessor.accept(number);
        }
        
        // String generation and processing
        System.out.println("\nString processing:");
        Supplier<String> dataSupplier = () -> "Sample Data " + System.currentTimeMillis();
        Consumer<String> dataConsumer = s -> 
            System.out.println("Consumed: " + s.toUpperCase());
        
        processData(dataSupplier, dataConsumer);
        processData(dataSupplier, dataConsumer);
        
        // Builder pattern
        System.out.println("\nBuilder Pattern:");
        List<String> results = new ArrayList<>();
        Supplier<String> itemSupplier = () -> "Item-" + results.size();
        Consumer<String> itemConsumer = results::add;
        
        for (int i = 0; i < 5; i++) {
            String item = itemSupplier.get();
            itemConsumer.accept(item);
        }
        System.out.println("Results: " + results);
    }
}
```

---

## üíª Example 10: Real-World Use Cases

```java
import java.util.*;
import java.util.function.*;
import java.util.logging.*;

public class RealWorldConsumerSupplier {
    
    private static final Logger logger = Logger.getLogger("AppLogger");
    
    public static void main(String[] args) {
        System.out.println("=== Real-World Use Cases ===\n");
        
        // 1. Configuration supplier
        Supplier<Properties> configSupplier = () -> {
            Properties props = new Properties();
            props.setProperty("db.host", "localhost");
            props.setProperty("db.port", "5432");
            return props;
        };
        
        System.out.println("1. Configuration:");
        Properties config = configSupplier.get();
        System.out.println(config);
        
        // 2. Logging consumer
        Consumer<String> infoLogger = msg -> logger.info(msg);
        Consumer<String> errorLogger = msg -> logger.severe(msg);
        
        System.out.println("\n2. Logging:");
        infoLogger.accept("Application started");
        errorLogger.accept("An error occurred");
        
        // 3. Data validation pipeline
        Consumer<String> validator = email -> {
            if (email.contains("@")) {
                System.out.println("Valid email: " + email);
            } else {
                System.out.println("Invalid email: " + email);
            }
        };
        
        Consumer<String> transformer = String::toLowerCase;
        Consumer<String> storage = email -> System.out.println("Stored: " + email);
        
        Consumer<String> pipeline = validator.andThen(storage);
        
        System.out.println("\n3. Validation Pipeline:");
        pipeline.accept("user@example.com");
        pipeline.accept("invalid.email");
        
        // 4. Default value supplier
        Map<String, Supplier<String>> defaults = new HashMap<>();
        defaults.put("username", () -> "guest");
        defaults.put("language", () -> "en");
        defaults.put("theme", () -> "light");
        
        System.out.println("\n4. Default Values:");
        String username = defaults.get("username").get();
        System.out.println("Username: " + username);
        
        // 5. Event handlers
        List<Consumer<String>> eventHandlers = Arrays.asList(
            event -> System.out.println("[Handler 1] " + event),
            event -> System.out.println("[Handler 2] " + event.toUpperCase()),
            event -> System.out.println("[Handler 3] Length: " + event.length())
        );
        
        System.out.println("\n5. Event Handlers:");
        String event = "button_clicked";
        eventHandlers.forEach(handler -> handler.accept(event));
    }
}
```

---

## üìä Consumer vs Supplier

| Aspect | Consumer | Supplier |
|--------|----------|----------|
| **Purpose** | Consumes data | Produces data |
| **Input** | Takes parameter | No parameter |
| **Output** | Returns nothing (void) | Returns value |
| **Use Case** | Processing, printing | Generation, factory |
| **Example** | `System.out::println` | `ArrayList::new` |
| **Chaining** | andThen() | Not chainable |

---

## üéØ Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Consumer for side effects | Printing, logging, storing |
| ‚úÖ Use Supplier for lazy init | Defer expensive operations |
| ‚úÖ Chain consumers | Build processing pipelines |
| ‚úÖ Factory pattern with Supplier | Object creation |
| ‚úÖ Use specialized versions | Better performance |
| ‚ö†Ô∏è Avoid complex logic | Keep simple and focused |
| ‚ö†Ô∏è Handle exceptions | Wrap in try-catch if needed |
| ‚ö†Ô∏è Thread safety | Consider concurrency issues |

---

## ‚ö†Ô∏è Common Pitfalls

| Pitfall | Issue | Solution |
|---------|-------|----------|
| Side effects in Supplier | Unexpected behavior | Keep Suppliers pure |
| Expensive Consumer operations | Performance issues | Optimize or parallelize |
| Forgetting andThen order | Wrong execution sequence | Understand chaining |
| Null values | NullPointerException | Add null checks |
| Not using specialized versions | Boxing overhead | Use IntConsumer, etc. |

---

## üîó Related Topics

- [Lambda Expressions](01.%20Lambda%20Expressions.md)
- [Functional Interfaces](02.%20Functional%20Interfaces.md)
- [Predicate Interface](04.%20Predicate%20Interface.md)
- [Function Interface](05.%20Function%20Interface.md)
- [Stream API](../07.%20Stream%20API/01.%20Introduction%20to%20Streams.md)

---

## üìù Interview Questions

1. **What is Consumer interface?** - Accepts input, returns nothing
2. **What is Supplier interface?** - Takes no input, returns value
3. **Can Consumer be chained?** - Yes, using andThen()
4. **Can Supplier be chained?** - No, only produces value
5. **What is BiConsumer?** - Consumer with two parameters
6. **When to use Supplier?** - Lazy initialization, factories
7. **Difference between Consumer and Function?** - Consumer returns void
8. **What are specialized Consumers?** - IntConsumer, LongConsumer, etc.
9. **What is lazy evaluation?** - Defer execution until needed
10. **Real-world use of Consumer?** - Logging, forEach, event handling

---

## üí° Key Takeaways

- Consumer accepts input, performs action, returns nothing
- Supplier provides values without taking input
- Consumer can be chained with andThen()
- Supplier perfect for lazy initialization and factories
- Use specialized versions for primitives
- Consumer ideal for side effects (printing, logging)
- Supplier ideal for object creation and value generation
- Both essential for functional programming in Java
