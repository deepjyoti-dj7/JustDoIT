# üîç Annotation Processing

## üìñ Overview

**Annotation Processing** is reading and processing annotations at runtime using the Reflection API or at compile time using annotation processors.

**Two Types:**
1. **Runtime Processing** - Using Reflection API
2. **Compile-Time Processing** - Using Annotation Processor API

---

## üíª Runtime Processing with Reflection

### Checking Annotations

```java
Class<?> clazz = MyClass.class;

// Check if annotation present
boolean hasAnnotation = clazz.isAnnotationPresent(Entity.class);

// Get annotation
Entity entity = clazz.getAnnotation(Entity.class);
if (entity != null) {
    String tableName = entity.table();
}

// Get all annotations
Annotation[] annotations = clazz.getAnnotations();

// Get declared annotations (not inherited)
Annotation[] declared = clazz.getDeclaredAnnotations();
```

### Processing Class Annotations

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Entity {
    String table() default "";
}

@Entity(table = "users")
public class User {
    private String name;
}

// Process
public class AnnotationProcessor {
    public static void processEntity(Class<?> clazz) {
        if (clazz.isAnnotationPresent(Entity.class)) {
            Entity entity = clazz.getAnnotation(Entity.class);
            System.out.println("Table: " + entity.table());
        }
    }
    
    public static void main(String[] args) {
        processEntity(User.class);
    }
}
```

### Processing Field Annotations

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String name() default "";
    boolean nullable() default true;
}

public class User {
    @Column(name = "user_id", nullable = false)
    private Long id;
    
    @Column(name = "user_name")
    private String name;
}

// Process fields
public class FieldProcessor {
    public static void processFields(Class<?> clazz) {
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                System.out.println("Field: " + field.getName());
                System.out.println("Column: " + column.name());
                System.out.println("Nullable: " + column.nullable());
            }
        }
    }
}
```

### Processing Method Annotations

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String description() default "";
}

public class MyTest {
    @Test(description = "Test addition")
    public void testAdd() {
        // Test code
    }
    
    @Test(description = "Test subtraction")
    public void testSubtract() {
        // Test code
    }
}

// Process methods
public class TestRunner {
    public static void runTests(Class<?> clazz) throws Exception {
        Object instance = clazz.getDeclaredConstructor().newInstance();
        
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Test.class)) {
                Test test = method.getAnnotation(Test.class);
                System.out.println("Running: " + test.description());
                method.invoke(instance);
                System.out.println("Passed");
            }
        }
    }
}
```

---

## üéØ Complete Examples

### Example 1: Simple Validation Framework

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface NotNull {
    String message() default "Field cannot be null";
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Min {
    int value();
    String message() default "Value too small";
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Max {
    int value();
    String message() default "Value too large";
}

// Domain class
public class User {
    @NotNull(message = "Name is required")
    private String name;
    
    @Min(value = 0, message = "Age cannot be negative")
    @Max(value = 150, message = "Age too large")
    private Integer age;
    
    public User(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    
    // Getters
    public String getName() { return name; }
    public Integer getAge() { return age; }
}

// Validator
public class Validator {
    public static List<String> validate(Object obj) {
        List<String> errors = new ArrayList<>();
        Class<?> clazz = obj.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            field.setAccessible(true);
            
            try {
                Object value = field.get(obj);
                
                // Check @NotNull
                if (field.isAnnotationPresent(NotNull.class)) {
                    if (value == null) {
                        NotNull annotation = field.getAnnotation(NotNull.class);
                        errors.add(annotation.message());
                    }
                }
                
                // Check @Min
                if (field.isAnnotationPresent(Min.class) && value != null) {
                    Min annotation = field.getAnnotation(Min.class);
                    if (value instanceof Integer) {
                        int intValue = (Integer) value;
                        if (intValue < annotation.value()) {
                            errors.add(annotation.message());
                        }
                    }
                }
                
                // Check @Max
                if (field.isAnnotationPresent(Max.class) && value != null) {
                    Max annotation = field.getAnnotation(Max.class);
                    if (value instanceof Integer) {
                        int intValue = (Integer) value;
                        if (intValue > annotation.value()) {
                            errors.add(annotation.message());
                        }
                    }
                }
                
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        
        return errors;
    }
    
    public static void main(String[] args) {
        User user1 = new User(null, 25);
        List<String> errors1 = validate(user1);
        System.out.println("Errors: " + errors1);  // [Name is required]
        
        User user2 = new User("Alice", 200);
        List<String> errors2 = validate(user2);
        System.out.println("Errors: " + errors2);  // [Age too large]
        
        User user3 = new User("Bob", 30);
        List<String> errors3 = validate(user3);
        System.out.println("Valid: " + errors3.isEmpty());  // true
    }
}
```

### Example 2: Simple Test Framework

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String description() default "";
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface BeforeTest {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface AfterTest {
}

// Test class
public class CalculatorTest {
    
    @BeforeTest
    public void setup() {
        System.out.println("Setup");
    }
    
    @Test(description = "Test addition")
    public void testAdd() {
        assert 2 + 2 == 4 : "Addition failed";
        System.out.println("  testAdd passed");
    }
    
    @Test(description = "Test subtraction")
    public void testSubtract() {
        assert 5 - 3 == 2 : "Subtraction failed";
        System.out.println("  testSubtract passed");
    }
    
    @AfterTest
    public void cleanup() {
        System.out.println("Cleanup");
    }
}

// Test runner
public class TestRunner {
    public static void runTests(Class<?> testClass) {
        try {
            Object instance = testClass.getDeclaredConstructor().newInstance();
            
            // Find methods
            Method beforeMethod = null;
            Method afterMethod = null;
            List<Method> testMethods = new ArrayList<>();
            
            for (Method method : testClass.getDeclaredMethods()) {
                if (method.isAnnotationPresent(BeforeTest.class)) {
                    beforeMethod = method;
                } else if (method.isAnnotationPresent(AfterTest.class)) {
                    afterMethod = method;
                } else if (method.isAnnotationPresent(Test.class)) {
                    testMethods.add(method);
                }
            }
            
            // Run tests
            for (Method testMethod : testMethods) {
                Test test = testMethod.getAnnotation(Test.class);
                System.out.println("\nRunning: " + test.description());
                
                // Before
                if (beforeMethod != null) {
                    beforeMethod.invoke(instance);
                }
                
                // Test
                try {
                    testMethod.invoke(instance);
                } catch (Exception e) {
                    System.out.println("  FAILED: " + e.getCause().getMessage());
                }
                
                // After
                if (afterMethod != null) {
                    afterMethod.invoke(instance);
                }
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) {
        runTests(CalculatorTest.class);
    }
}
```

### Example 3: Dependency Injection

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Inject {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
}

// Components
@Component
public class UserRepository {
    public String findUser(int id) {
        return "User" + id;
    }
}

@Component
public class UserService {
    @Inject
    private UserRepository repository;
    
    public String getUser(int id) {
        return repository.findUser(id);
    }
}

// Simple DI container
public class DIContainer {
    private Map<Class<?>, Object> instances = new HashMap<>();
    
    public <T> T getInstance(Class<T> clazz) {
        try {
            // Check if already created
            if (instances.containsKey(clazz)) {
                return (T) instances.get(clazz);
            }
            
            // Create instance
            T instance = clazz.getDeclaredConstructor().newInstance();
            instances.put(clazz, instance);
            
            // Inject dependencies
            for (Field field : clazz.getDeclaredFields()) {
                if (field.isAnnotationPresent(Inject.class)) {
                    field.setAccessible(true);
                    Object dependency = getInstance(field.getType());
                    field.set(instance, dependency);
                }
            }
            
            return instance;
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to create instance", e);
        }
    }
    
    public static void main(String[] args) {
        DIContainer container = new DIContainer();
        
        UserService service = container.getInstance(UserService.class);
        String user = service.getUser(123);
        System.out.println(user);  // User123
    }
}
```

### Example 4: ORM Mapper

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Table {
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {
}

// Entity
@Table("users")
public class User {
    @Id
    @Column("id")
    private Long id;
    
    @Column("name")
    private String name;
    
    @Column("email")
    private String email;
    
    // Constructors, getters, setters
    public User() {}
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}

// Simple ORM
public class SimpleORM {
    
    public static String generateSelectSQL(Class<?> clazz) {
        if (!clazz.isAnnotationPresent(Table.class)) {
            throw new IllegalArgumentException("Class not annotated with @Table");
        }
        
        Table table = clazz.getAnnotation(Table.class);
        StringBuilder sql = new StringBuilder("SELECT ");
        
        List<String> columns = new ArrayList<>();
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                columns.add(column.value());
            }
        }
        
        sql.append(String.join(", ", columns));
        sql.append(" FROM ").append(table.value());
        
        return sql.toString();
    }
    
    public static String generateInsertSQL(Object obj) {
        Class<?> clazz = obj.getClass();
        
        if (!clazz.isAnnotationPresent(Table.class)) {
            throw new IllegalArgumentException("Class not annotated with @Table");
        }
        
        Table table = clazz.getAnnotation(Table.class);
        List<String> columns = new ArrayList<>();
        List<String> values = new ArrayList<>();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                columns.add(column.value());
                
                try {
                    field.setAccessible(true);
                    Object value = field.get(obj);
                    if (value instanceof String) {
                        values.add("'" + value + "'");
                    } else {
                        values.add(String.valueOf(value));
                    }
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
        
        return String.format("INSERT INTO %s (%s) VALUES (%s)",
            table.value(),
            String.join(", ", columns),
            String.join(", ", values));
    }
    
    public static void main(String[] args) {
        // Generate SELECT
        String selectSQL = generateSelectSQL(User.class);
        System.out.println(selectSQL);
        // SELECT id, name, email FROM users
        
        // Generate INSERT
        User user = new User(1L, "Alice", "alice@example.com");
        String insertSQL = generateInsertSQL(user);
        System.out.println(insertSQL);
        // INSERT INTO users (id, name, email) VALUES (1, 'Alice', 'alice@example.com')
    }
}
```

---

## üìä Reflection API for Annotations

| Method | Description |
|--------|-------------|
| isAnnotationPresent(Class) | Check if annotation present |
| getAnnotation(Class) | Get annotation |
| getAnnotations() | Get all annotations |
| getDeclaredAnnotations() | Get declared annotations |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use RUNTIME retention | For reflection processing |
| ‚úÖ Cache reflection results | Avoid repeated processing |
| ‚úÖ Validate annotation values | Check constraints |
| ‚úÖ Handle missing annotations | Gracefully |
| ‚úÖ Use setAccessible() carefully | For private fields |
| ‚ùå Don't process annotations in loops | Performance impact |
| ‚ùå Don't ignore exceptions | Proper error handling |

---

## üéØ Performance Tips

```java
// ‚ùå BAD - Repeated reflection
public void process(Object obj) {
    for (int i = 0; i < 1000; i++) {
        Field[] fields = obj.getClass().getDeclaredFields();  // Repeated!
        // Process fields
    }
}

// ‚úÖ GOOD - Cache results
public class AnnotationCache {
    private static Map<Class<?>, Field[]> fieldCache = new HashMap<>();
    
    public static Field[] getFields(Class<?> clazz) {
        return fieldCache.computeIfAbsent(clazz, Class::getDeclaredFields);
    }
}
```

---

## üîó Related Topics

- [Built-in Annotations](01.%20Built-in%20Annotations.md)
- [Custom Annotations](02.%20Custom%20Annotations.md)
- [Meta-Annotations](03.%20Meta-Annotations.md)
- [Reflection](../15.%20Reflection/01.%20Reflection%20Basics.md)

---

## üí° Key Takeaways

- Runtime processing uses Reflection API
- Use RetentionPolicy.RUNTIME for reflection
- Check with isAnnotationPresent() before accessing
- Process class, field, method, parameter annotations
- Invoke methods with Method.invoke()
- setAccessible(true) for private members
- Cache reflection results for performance
- Validation frameworks use annotation processing
- DI frameworks inject dependencies via annotations
- ORM frameworks map objects to database
- Always handle exceptions properly
