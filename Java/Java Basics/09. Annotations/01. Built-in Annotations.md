# üè∑Ô∏è Built-in Annotations

## üìñ Overview

**Annotations** provide metadata about code. They don't directly affect program execution but can be used by the compiler, build tools, or at runtime.

**Purpose:**
- Compiler instructions
- Build-time processing
- Runtime processing
- Code documentation

---

## üíª @Override

Indicates a method overrides a superclass method.

```java
class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark!");
    }
    
    // Compile error if method doesn't override
    // @Override
    // public void makeSond() {  // Typo
    //     System.out.println("Bark!");
    // }
}
```

**Benefits:**
- Catches typos at compile time
- Makes intent clear
- Prevents accidental overloading

---

## üíª @Deprecated

Marks code as outdated and discouraged.

```java
public class Calculator {
    
    // Old method
    @Deprecated
    public int add(int a, int b) {
        return a + b;
    }
    
    // New method
    public int sum(int a, int b) {
        return a + b;
    }
}

// Using deprecated code
Calculator calc = new Calculator();
int result = calc.add(5, 3);  // Compiler warning
```

**With message (Java 9+):**
```java
@Deprecated(since = "1.5", forRemoval = true)
public void oldMethod() {
    // ...
}
```

**Parameters:**
- `since` - version when deprecated
- `forRemoval` - will be removed in future

---

## üíª @SuppressWarnings

Suppresses compiler warnings.

```java
public class WarningExample {
    
    // Suppress unchecked warning
    @SuppressWarnings("unchecked")
    public List<String> getList() {
        List list = new ArrayList();  // Raw type
        return list;
    }
    
    // Suppress multiple warnings
    @SuppressWarnings({"unchecked", "rawtypes"})
    public void process() {
        List list = new ArrayList();
        list.add("item");
    }
    
    // Suppress deprecation warning
    @SuppressWarnings("deprecation")
    public void useOldCode() {
        Date date = new Date(2024, 1, 1);  // Deprecated constructor
    }
}
```

**Common values:**
- `"unchecked"` - unchecked operations
- `"rawtypes"` - raw types
- `"deprecation"` - deprecated code
- `"unused"` - unused variables
- `"all"` - all warnings

---

## üíª @FunctionalInterface

Marks an interface as functional (single abstract method).

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
    
    // Can have default methods
    default int add(int a, int b) {
        return a + b;
    }
    
    // Can have static methods
    static int multiply(int a, int b) {
        return a * b;
    }
    
    // Compile error: multiple abstract methods
    // int subtract(int a, int b);
}

// Usage with lambda
Calculator calc = (a, b) -> a + b;
```

---

## üíª @SafeVarargs

Suppresses warnings about varargs with generic types.

```java
public class VarargsExample {
    
    // Without @SafeVarargs - warning
    public static <T> void print(T... items) {
        for (T item : items) {
            System.out.println(item);
        }
    }
    
    // With @SafeVarargs - no warning
    @SafeVarargs
    public static <T> void printSafe(T... items) {
        for (T item : items) {
            System.out.println(item);
        }
    }
    
    public static void main(String[] args) {
        printSafe("A", "B", "C");
        printSafe(1, 2, 3);
    }
}
```

**Requirements:**
- Method must be `static`, `final`, or `private`
- Only for varargs parameters

---

## üíª Java 9+ Annotations

### @Deprecated (Enhanced)

```java
@Deprecated(since = "9", forRemoval = true)
public class OldClass {
    // Will be removed in future version
}
```

### @SuppressWarnings (Enhanced)

```java
@SuppressWarnings("removal")  // Java 9+
public void useDeprecatedForRemoval() {
    OldClass obj = new OldClass();
}
```

---

## üéØ Complete Examples

### Example 1: Method Override

```java
class Shape {
    public double area() {
        return 0.0;
    }
    
    public void draw() {
        System.out.println("Drawing shape");
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing circle");
    }
    
    // This would cause compile error
    // @Override
    // public void drow() {  // Typo
    //     System.out.println("Drawing");
    // }
}
```

### Example 2: Deprecation Migration

```java
public class UserService {
    
    // Old API
    @Deprecated(since = "2.0", forRemoval = true)
    public User getUser(int id) {
        return findUserById(id);
    }
    
    // New API
    public User findUserById(int id) {
        // Implementation
        return new User(id);
    }
    
    // Client code
    public void processUser() {
        @SuppressWarnings("deprecation")
        User user = getUser(123);  // Suppress warning
        
        // Better: use new API
        User user2 = findUserById(123);
    }
}
```

### Example 3: Generic Varargs

```java
public class GenericUtils {
    
    @SafeVarargs
    public static <T> List<T> asList(T... elements) {
        List<T> list = new ArrayList<>();
        for (T element : elements) {
            list.add(element);
        }
        return list;
    }
    
    @SafeVarargs
    public static <T> void printAll(T... items) {
        for (T item : items) {
            System.out.println(item);
        }
    }
    
    public static void main(String[] args) {
        List<String> names = asList("Alice", "Bob", "Charlie");
        printAll(1, 2, 3, 4, 5);
    }
}
```

### Example 4: Functional Interface

```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

@FunctionalInterface
interface StringProcessor {
    String process(String input);
    
    // Default methods allowed
    default String processUpper(String input) {
        return process(input).toUpperCase();
    }
}

public class FunctionalExample {
    public static void main(String[] args) {
        // Lambda expressions
        MathOperation add = (a, b) -> a + b;
        MathOperation multiply = (a, b) -> a * b;
        
        System.out.println("Add: " + add.operate(5, 3));
        System.out.println("Multiply: " + multiply.operate(5, 3));
        
        StringProcessor trim = String::trim;
        System.out.println(trim.process("  hello  "));
    }
}
```

---

## üìä Built-in Annotations Summary

| Annotation | Purpose | Since |
|------------|---------|-------|
| @Override | Mark method override | Java 5 |
| @Deprecated | Mark as outdated | Java 5 |
| @SuppressWarnings | Suppress warnings | Java 5 |
| @FunctionalInterface | Mark functional interface | Java 8 |
| @SafeVarargs | Suppress varargs warnings | Java 7 |

---

## üìä @SuppressWarnings Values

| Value | Description |
|-------|-------------|
| "all" | All warnings |
| "unchecked" | Unchecked operations |
| "rawtypes" | Raw type usage |
| "deprecation" | Deprecated API usage |
| "unused" | Unused code |
| "cast" | Unnecessary casts |
| "serial" | Serializable without serialVersionUID |
| "null" | Null analysis |
| "removal" | Deprecated for removal (Java 9+) |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Always use @Override | Catch overriding errors |
| ‚úÖ Document @Deprecated | Explain alternatives |
| ‚úÖ Minimize @SuppressWarnings scope | Apply to smallest scope |
| ‚úÖ Use @FunctionalInterface | Clear intent for lambdas |
| ‚úÖ Add since/forRemoval | Deprecation details |
| ‚ùå Don't suppress all warnings | Fix issues instead |
| ‚ùå Don't overuse @Deprecated | Only for serious issues |
| ‚ùå Don't forget @SafeVarargs | Prevent heap pollution |

---

## üéØ When to Use Each Annotation

### @Override
```java
// ‚úÖ GOOD - Always use for overriding
@Override
public String toString() {
    return "MyClass";
}

// ‚ùå BAD - Easy to miss typos
public String tostring() {  // Typo!
    return "MyClass";
}
```

### @Deprecated
```java
// ‚úÖ GOOD - Clear migration path
@Deprecated(since = "2.0", forRemoval = true)
public void oldMethod() { }

// New alternative
public void newMethod() { }

// ‚ùå BAD - No alternative provided
@Deprecated
public void method() { }  // What should I use instead?
```

### @SuppressWarnings
```java
// ‚úÖ GOOD - Minimal scope
public void process() {
    @SuppressWarnings("unchecked")
    List<String> list = (List<String>) getList();
}

// ‚ùå BAD - Too broad
@SuppressWarnings("all")
public class MyClass {
    // Suppresses all warnings for entire class
}
```

---

## üîó Related Topics

- [Custom Annotations](02.%20Custom%20Annotations.md)
- [Meta-Annotations](03.%20Meta-Annotations.md)
- [Annotation Processing](04.%20Annotation%20Processing.md)
- [Lambda Expressions](../06.%20Lambda%20%26%20Functional%20Programming/01.%20Lambda%20Expressions.md)

---

## üí° Key Takeaways

- Annotations provide metadata about code
- @Override catches overriding mistakes at compile time
- @Deprecated marks outdated code with migration info
- @SuppressWarnings suppresses specific compiler warnings
- @FunctionalInterface enforces single abstract method
- @SafeVarargs suppresses varargs heap pollution warnings
- Apply @SuppressWarnings to smallest possible scope
- Always provide alternatives when deprecating
- Use forRemoval=true for future removal
- Annotations don't affect program execution directly
