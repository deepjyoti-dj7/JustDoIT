# üéØ Meta-Annotations

## üìñ Overview

**Meta-annotations** are annotations that apply to other annotations. They control how annotations behave and where they can be used.

**Standard Meta-Annotations:**
- @Retention - How long to keep
- @Target - Where to apply
- @Documented - Include in Javadoc
- @Inherited - Inherit to subclasses
- @Repeatable - Allow multiple instances (Java 8+)

---

## üíª @Retention

Controls how long annotations are retained.

### Retention Policies

```java
import java.lang.annotation.*;

// SOURCE - Discarded by compiler
@Retention(RetentionPolicy.SOURCE)
public @interface CompileTimeCheck {
}

// CLASS - In bytecode, not at runtime (default)
@Retention(RetentionPolicy.CLASS)
public @interface BytecodeInfo {
}

// RUNTIME - Available at runtime via reflection
@Retention(RetentionPolicy.RUNTIME)
public @interface RuntimeInfo {
}
```

### Retention Policy Comparison

| Policy | Compiler | Bytecode | Runtime | Use Case |
|--------|----------|----------|---------|----------|
| SOURCE | ‚úÖ | ‚ùå | ‚ùå | Code generation, warnings |
| CLASS | ‚úÖ | ‚úÖ | ‚ùå | Bytecode analysis |
| RUNTIME | ‚úÖ | ‚úÖ | ‚úÖ | Reflection, frameworks |

### Examples by Retention

```java
// SOURCE - For compiler only
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.METHOD)
public @interface Override {  // Built-in example
}

// RUNTIME - For reflection
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Inject {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}
```

---

## üíª @Target

Specifies where annotation can be applied.

### Target Types

```java
import java.lang.annotation.*;

// Single target
@Target(ElementType.METHOD)
public @interface MethodOnly {
}

// Multiple targets
@Target({ElementType.FIELD, ElementType.PARAMETER})
public @interface FieldOrParam {
}

// All targets (no @Target means all)
public @interface AnyWhere {
}
```

### ElementType Values

```java
// TYPE - Class, interface, enum
@Target(ElementType.TYPE)
public @interface Entity {
}

// FIELD - Field declaration
@Target(ElementType.FIELD)
public @interface Column {
}

// METHOD - Method declaration
@Target(ElementType.METHOD)
public @interface GetMapping {
}

// PARAMETER - Method parameter
@Target(ElementType.PARAMETER)
public @interface RequestBody {
}

// CONSTRUCTOR - Constructor
@Target(ElementType.CONSTRUCTOR)
public @interface Autowired {
}

// LOCAL_VARIABLE - Local variable
@Target(ElementType.LOCAL_VARIABLE)
public @interface NonNull {
}

// ANNOTATION_TYPE - Annotation type (meta-annotation)
@Target(ElementType.ANNOTATION_TYPE)
public @interface MetaAnnotation {
}

// PACKAGE - Package declaration
@Target(ElementType.PACKAGE)
public @interface PackageInfo {
}

// TYPE_PARAMETER - Type parameter (Java 8+)
@Target(ElementType.TYPE_PARAMETER)
public @interface NonEmpty {
}

// TYPE_USE - Type use (Java 8+)
@Target(ElementType.TYPE_USE)
public @interface NotNull {
}
```

---

## üíª @Documented

Includes annotation in Javadoc.

```java
import java.lang.annotation.*;

// With @Documented - appears in Javadoc
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface API {
    String version();
}

// Without @Documented - not in Javadoc
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Internal {
}

// Usage
@API(version = "1.0")
public class UserService {
    // @API appears in generated Javadoc
    
    @Internal
    public void internalMethod() {
        // @Internal doesn't appear in Javadoc
    }
}
```

---

## üíª @Inherited

Allows subclasses to inherit annotation.

```java
import java.lang.annotation.*;

// With @Inherited
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Service {
}

// Without @Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
}

// Usage
@Service
class BaseService {
}

class UserService extends BaseService {
    // Inherits @Service annotation
}

@Component
class BaseComponent {
}

class MyComponent extends BaseComponent {
    // Does NOT inherit @Component annotation
}

// Check at runtime
System.out.println(UserService.class.isAnnotationPresent(Service.class));  // true
System.out.println(MyComponent.class.isAnnotationPresent(Component.class)); // false
```

**Important:** Only works for class-level annotations, not methods or fields.

---

## üíª @Repeatable (Java 8+)

Allows multiple instances of same annotation.

```java
import java.lang.annotation.*;

// Define container
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedules {
    Schedule[] value();
}

// Define repeatable annotation
@Repeatable(Schedules.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedule {
    String day();
    String time();
}

// Usage - old way (before Java 8)
@Schedules({
    @Schedule(day = "Monday", time = "09:00"),
    @Schedule(day = "Friday", time = "17:00")
})
public void task1() {
}

// Usage - new way (Java 8+)
@Schedule(day = "Monday", time = "09:00")
@Schedule(day = "Friday", time = "17:00")
public void task2() {
}
```

---

## üéØ Complete Examples

### Example 1: Validation Framework

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@Documented
public @interface NotNull {
    String message() default "Field cannot be null";
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@Documented
public @interface Size {
    int min() default 0;
    int max() default Integer.MAX_VALUE;
    String message() default "Size constraint violation";
}

// Usage
public class User {
    @NotNull(message = "Name is required")
    private String name;
    
    @Size(min = 8, max = 20, message = "Password must be 8-20 characters")
    private String password;
}
```

### Example 2: Role-Based Access

```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface Secured {
}

@Repeatable(Roles.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Role {
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Roles {
    Role[] value();
}

// Usage
@Secured
@Role("ADMIN")
@Role("SUPER_ADMIN")
public class AdminController {
    
    @Role("ADMIN")
    public void deleteUser() {
    }
}
```

### Example 3: Testing Framework

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Test {
    String description() default "";
    Class<? extends Throwable> expected() default None.class;
    
    class None extends Throwable {
        private static final long serialVersionUID = 1L;
    }
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Before {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface After {
}

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface TestClass {
}

// Usage
@TestClass
public class CalculatorTest {
    
    @Before
    public void setup() {
        System.out.println("Setup");
    }
    
    @Test(description = "Test addition")
    public void testAdd() {
        // Test code
    }
    
    @Test(expected = ArithmeticException.class)
    public void testDivideByZero() {
        int result = 10 / 0;
    }
    
    @After
    public void cleanup() {
        System.out.println("Cleanup");
    }
}
```

### Example 4: API Documentation

```java
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface API {
    String version();
    String description() default "";
    boolean deprecated() default false;
}

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Endpoint {
    String path();
    String method() default "GET";
}

@Repeatable(Authors.class)
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Author {
    String name();
    String email() default "";
}

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Authors {
    Author[] value();
}

// Usage
@API(version = "2.0", description = "User Management API")
@Author(name = "Alice", email = "alice@example.com")
@Author(name = "Bob", email = "bob@example.com")
public class UserController {
    
    @Endpoint(path = "/users", method = "GET")
    @Author(name = "Alice")
    public List<User> getUsers() {
        return null;
    }
}
```

---

## üìä Meta-Annotation Summary

| Meta-Annotation | Purpose | Common Values |
|-----------------|---------|---------------|
| @Retention | Lifetime | SOURCE, CLASS, RUNTIME |
| @Target | Where to apply | TYPE, FIELD, METHOD, etc. |
| @Documented | In Javadoc | N/A (marker) |
| @Inherited | Subclass inheritance | N/A (marker) |
| @Repeatable | Multiple instances | Container class |

---

## üìä When to Use Each Retention

| Retention | Use Case | Example |
|-----------|----------|---------|
| SOURCE | Compiler checks, code generation | @Override, @SuppressWarnings |
| CLASS | Bytecode instrumentation | Bytecode analysis tools |
| RUNTIME | Reflection, frameworks | @Entity, @Inject, @Test |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use RUNTIME for frameworks | Enable reflection |
| ‚úÖ Use SOURCE for compile checks | No runtime overhead |
| ‚úÖ Specify @Target | Restrict usage |
| ‚úÖ Use @Documented for APIs | Include in Javadoc |
| ‚úÖ Use @Inherited carefully | Only for class-level |
| ‚úÖ Design container for @Repeatable | Before making repeatable |
| ‚ùå Don't overuse @Inherited | Can cause confusion |
| ‚ùå Don't forget @Retention | Defaults to CLASS |

---

## üéØ Design Patterns

### Pattern 1: Framework Annotation
```java
@Inherited
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
    String value() default "";
}
```

### Pattern 2: Validation Annotation
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Valid {
}
```

### Pattern 3: Meta-Meta-Annotation
```java
@Target(ElementType.ANNOTATION_TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraint {
    Class<? extends Validator> validatedBy();
}

@Constraint(validatedBy = NotNullValidator.class)
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNull {
}
```

---

## üîó Related Topics

- [Built-in Annotations](01.%20Built-in%20Annotations.md)
- [Custom Annotations](02.%20Custom%20Annotations.md)
- [Annotation Processing](04.%20Annotation%20Processing.md)

---

## üí° Key Takeaways

- Meta-annotations control annotation behavior
- @Retention: SOURCE, CLASS, or RUNTIME
- @Target specifies where annotation applies
- @Documented includes in Javadoc
- @Inherited allows subclass inheritance (classes only)
- @Repeatable enables multiple instances (Java 8+)
- Use RUNTIME retention for reflection-based frameworks
- Always specify @Target to restrict usage
- @Inherited only works for class-level annotations
- @Repeatable requires container annotation
