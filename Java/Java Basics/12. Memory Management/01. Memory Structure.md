# üèóÔ∏è Memory Structure

## üìñ Overview

**JVM Memory Structure** is divided into several runtime data areas, each serving specific purposes for program execution.

**Main Memory Areas:**
- Heap Memory
- Stack Memory
- Method Area (Metaspace)
- Program Counter (PC) Register
- Native Method Stack

---

## üíª JVM Memory Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              JVM Memory                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ         Heap Memory                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Young Gen   ‚îÇ  ‚îÇ  Old Gen     ‚îÇ ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ (Eden+S0+S1)‚îÇ  ‚îÇ  (Tenured)   ‚îÇ ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ    Method Area (Metaspace)          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Class metadata                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Static variables                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Constant pool                     ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ  Stack   ‚îÇ  ‚îÇ  Stack   ‚îÇ  (Per Thread)  ‚îÇ
‚îÇ  ‚îÇ Thread 1 ‚îÇ  ‚îÇ Thread 2 ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ    Native Method Stack                ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ    Program Counter Register           ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª Heap Memory

**Shared across all threads** - Stores objects and instance variables.

### Structure

```java
// Heap Memory Generations
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Young Generation                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ Eden ‚îÇ  ‚îÇ S0 ‚îÇ  ‚îÇ S1 ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Old Generation (Tenured)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Example

```java
public class HeapExample {
    // Instance variables - stored in Heap
    private int id;
    private String name;
    
    public static void main(String[] args) {
        // Object created in Heap
        HeapExample obj = new HeapExample();
        obj.id = 1;
        obj.name = "Test";
        
        // Array created in Heap
        int[] numbers = new int[10];
        
        // String objects in Heap (String pool)
        String str1 = "Hello";
        String str2 = new String("World");
    }
}
```

**Characteristics:**
- Shared by all threads
- Stores objects and arrays
- Garbage collected
- Larger than stack
- Slower access than stack

---

## üíª Stack Memory

**Per-thread memory** - Stores local variables and method call frames.

### Structure

```java
// Stack Frame Structure
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Method Frame 3       ‚îÇ
‚îÇ  - Local variables     ‚îÇ
‚îÇ  - Operand stack       ‚îÇ
‚îÇ  - Frame data          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Method Frame 2       ‚îÇ
‚îÇ  - Local variables     ‚îÇ
‚îÇ  - Operand stack       ‚îÇ
‚îÇ  - Frame data          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Method Frame 1       ‚îÇ
‚îÇ  - Local variables     ‚îÇ
‚îÇ  - Operand stack       ‚îÇ
‚îÇ  - Frame data          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Example

```java
public class StackExample {
    public static void main(String[] args) {
        // Primitive variables in Stack
        int x = 10;
        double y = 20.5;
        
        // Reference variable in Stack, object in Heap
        String name = "John";
        
        calculate(x, y);
    }
    
    public static void calculate(int a, double b) {
        // Local variables in Stack
        double result = a + b;
        System.out.println(result);
    }
    // When method exits, stack frame is popped
}
```

**Characteristics:**
- One per thread
- Stores method frames, local variables, references
- LIFO (Last In First Out)
- Faster access
- Limited size (can cause StackOverflowError)
- Automatically cleared when method returns

---

## üíª Method Area (Metaspace)

**Shared across threads** - Stores class-level data.

### Example

```java
public class MethodAreaExample {
    // Static variables - Method Area
    private static int counter = 0;
    private static final String CONSTANT = "Fixed";
    
    // Class definition stored in Method Area
    public void increment() {
        counter++;
    }
    
    public static void main(String[] args) {
        MethodAreaExample obj1 = new MethodAreaExample();
        MethodAreaExample obj2 = new MethodAreaExample();
        
        obj1.increment();  // counter = 1
        obj2.increment();  // counter = 2
        
        // Both share same static variable
        System.out.println(counter);  // 2
    }
}
```

**Stores:**
- Class structure (metadata)
- Method bytecode
- Static variables
- Runtime constant pool
- Field and method data

**Java 8+ Change:**
- PermGen removed
- Metaspace introduced (native memory)
- No more OutOfMemoryError: PermGen space

---

## üíª Program Counter Register

**Per-thread** - Holds address of current instruction.

```java
public class PCRegisterExample {
    public static void main(String[] args) {
        int a = 10;      // PC points here
        int b = 20;      // Then here
        int c = a + b;   // Then here
        
        if (c > 25) {    // PC may jump based on condition
            System.out.println(c);
        }
    }
}
```

**Purpose:**
- Tracks current instruction being executed
- Each thread has its own PC register
- Contains address of JVM instruction

---

## üíª Native Method Stack

**Per-thread** - Used for native (non-Java) methods.

```java
public class NativeMethodExample {
    // Native method declaration
    public native void nativeMethod();
    
    static {
        // Load native library
        System.loadLibrary("mylibrary");
    }
    
    public static void main(String[] args) {
        NativeMethodExample obj = new NativeMethodExample();
        obj.nativeMethod();  // Uses native method stack
    }
}
```

**Purpose:**
- Supports native methods (C/C++)
- Separate from JVM stack
- Can also throw StackOverflowError

---

## üéØ Complete Example

```java
public class MemoryDemo {
    // Static variable - Method Area
    private static int staticCounter = 0;
    
    // Instance variable - will be in Heap when object created
    private int instanceCounter;
    
    public static void main(String[] args) {
        // Local primitive - Stack
        int localVar = 10;
        
        // Reference in Stack, object in Heap
        MemoryDemo obj1 = new MemoryDemo();
        MemoryDemo obj2 = new MemoryDemo();
        
        // Modifying instance variables (Heap)
        obj1.instanceCounter = 1;
        obj2.instanceCounter = 2;
        
        // Modifying static variable (Method Area)
        staticCounter = 100;
        
        // Method call - new stack frame
        obj1.calculate(5, 10);
        
        // Array in Heap, reference in Stack
        int[] numbers = new int[5];
        
        // String literal - String pool in Heap
        String str1 = "Hello";
        
        // String object - Heap
        String str2 = new String("World");
    }
    
    public void calculate(int a, int b) {
        // Local variables - Stack
        int sum = a + b;
        int product = a * b;
        
        // Object creation - Heap
        Integer result = sum + product;
        
        System.out.println(result);
    }
    // Stack frame removed after method execution
}
```

---

## üìä Memory Area Comparison

| Memory Area | Shared/Private | Stores | Size | GC |
|-------------|---------------|--------|------|-----|
| Heap | Shared | Objects, arrays | Configurable | ‚úÖ Yes |
| Stack | Per-thread | Local variables, references | Fixed | ‚ùå No |
| Method Area | Shared | Class metadata, statics | Configurable | ‚úÖ Yes (Java 8+) |
| PC Register | Per-thread | Instruction address | Small | ‚ùå No |
| Native Stack | Per-thread | Native method data | Fixed | ‚ùå No |

---

## üìä Memory Allocation Example

| Code | Stack | Heap | Method Area |
|------|-------|------|-------------|
| `int x = 10;` | x = 10 | - | - |
| `String s = "Hi";` | s (ref) | "Hi" object | - |
| `static int c = 0;` | - | - | c = 0 |
| `Person p = new Person();` | p (ref) | Person object | Person class |

---

## ‚ö° Memory Configuration

```bash
# Heap size
java -Xms512m -Xmx2048m MyApp
# Min heap: 512MB, Max heap: 2048MB

# Metaspace size
java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m MyApp

# Stack size
java -Xss1m MyApp
# Stack size: 1MB per thread

# Print GC details
java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps MyApp

# Dump heap on OutOfMemoryError
java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heap.hprof MyApp
```

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Monitor heap usage | Prevent OutOfMemoryError |
| ‚úÖ Configure appropriate sizes | Based on application needs |
| ‚úÖ Use profiling tools | VisualVM, JProfiler |
| ‚úÖ Understand memory leaks | Release references |
| ‚úÖ Limit recursive depth | Avoid StackOverflowError |
| ‚ùå Don't ignore OutOfMemoryError | Investigate root cause |
| ‚ùå Don't set heap too large | Can cause long GC pauses |

---

## üéØ Common Errors

### StackOverflowError

```java
public class StackOverflowDemo {
    public static void recursiveMethod() {
        recursiveMethod();  // Infinite recursion
    }
    
    public static void main(String[] args) {
        recursiveMethod();  // Causes StackOverflowError
    }
}
```

### OutOfMemoryError: Java heap space

```java
public class HeapOutOfMemoryDemo {
    public static void main(String[] args) {
        List<byte[]> list = new ArrayList<>();
        while (true) {
            list.add(new byte[1024 * 1024]);  // 1MB each
            // Eventually causes OutOfMemoryError
        }
    }
}
```

---

## üîó Related Topics

- [Heap vs Stack](02.%20Heap%20vs%20Stack.md)
- [Garbage Collection](03.%20Garbage%20Collection.md)
- [Memory Leaks](05.%20Memory%20Leaks.md)

---

## üí° Key Takeaways

- JVM memory divided into Heap, Stack, Method Area, PC Register, Native Stack
- Heap: shared, stores objects, garbage collected
- Stack: per-thread, stores local variables and method frames
- Method Area: shared, stores class metadata and statics
- PC Register: per-thread, tracks current instruction
- Native Stack: per-thread, for native methods
- Java 8+ uses Metaspace instead of PermGen
- Configure memory sizes based on application needs
- StackOverflowError from deep recursion
- OutOfMemoryError from insufficient heap space
