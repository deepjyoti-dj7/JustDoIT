# üîÑ GC Algorithms

## üìñ Overview

Different **Garbage Collectors** optimize for different goals: throughput, latency, or memory footprint. Choosing the right GC depends on application requirements.

---

## üíª Serial GC

**Single-threaded** garbage collector, suitable for small applications.

### Characteristics

```bash
# Enable Serial GC
java -XX:+UseSerialGC MyApp
```

**Behavior:**
- Uses single thread for GC
- "Stop the World" for all GC operations
- Simple and efficient for small heaps
- Low memory footprint

**Use Cases:**
- Single-threaded applications
- Small heap sizes (<100 MB)
- Client applications
- Embedded systems

**Pros:**
- Low overhead
- Simple implementation
- Efficient for small heaps

**Cons:**
- Long pause times for large heaps
- Doesn't utilize multiple CPUs

---

## üíª Parallel GC (Throughput Collector)

**Multi-threaded** collector optimized for throughput.

### Characteristics

```bash
# Enable Parallel GC
java -XX:+UseParallelGC MyApp

# Set number of GC threads
java -XX:ParallelGCThreads=4 MyApp

# Set max pause time goal (milliseconds)
java -XX:MaxGCPauseMillis=200 MyApp

# Set throughput goal (percent)
java -XX:GCTimeRatio=99 MyApp
```

**Behavior:**
- Multiple threads for Young and Old Gen GC
- "Stop the World" for both Minor and Major GC
- Default GC in Java 8
- Optimizes for throughput

**Use Cases:**
- Batch processing
- Scientific computations
- Applications prioritizing throughput over latency

**Pros:**
- High throughput
- Efficient use of multiple CPUs
- Good for large datasets

**Cons:**
- Longer pause times
- Not suitable for low-latency applications

---

## üíª CMS GC (Concurrent Mark Sweep)

**Low-latency** collector that runs concurrently with application threads.

### Characteristics

```bash
# Enable CMS GC (deprecated in Java 9, removed in Java 14)
java -XX:+UseConcMarkSweepGC MyApp

# Set CMS initiating occupancy fraction
java -XX:CMSInitiatingOccupancyFraction=70 MyApp

# Enable incremental mode
java -XX:+CMSIncrementalMode MyApp
```

**Phases:**
1. **Initial Mark** (STW) - Mark root objects
2. **Concurrent Mark** - Mark reachable objects
3. **Concurrent Premark** - Handle changes during mark
4. **Remark** (STW) - Finalize marking
5. **Concurrent Sweep** - Remove dead objects
6. **Concurrent Reset** - Prepare for next cycle

**Use Cases:**
- Low-latency applications
- Web servers
- Interactive applications
- Real-time systems

**Pros:**
- Low pause times
- Concurrent collection
- Good for large heaps

**Cons:**
- Lower throughput than Parallel GC
- Memory fragmentation
- CPU overhead
- Deprecated (use G1 instead)

---

## üíª G1 GC (Garbage First)

**Region-based** collector balancing throughput and latency. **Default since Java 9.**

### Characteristics

```bash
# Enable G1 GC (default since Java 9)
java -XX:+UseG1GC MyApp

# Set max pause time goal (milliseconds)
java -XX:MaxGCPauseMillis=200 MyApp

# Set region size (1-32 MB)
java -XX:G1HeapRegionSize=16m MyApp

# Set initiating heap occupancy
java -XX:InitiatingHeapOccupancyPercent=45 MyApp
```

**Heap Structure:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      G1 Heap (divided into regions)    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ E ‚îÇ‚îÇ E ‚îÇ‚îÇ S ‚îÇ‚îÇ O ‚îÇ‚îÇ O ‚îÇ‚îÇ H ‚îÇ ...   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ   Eden  Eden Surv. Old  Old  Huge     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Behavior:**
- Divides heap into equal-sized regions
- Prioritizes regions with most garbage (Garbage First)
- Predictable pause times
- Concurrent and parallel phases

**Phases:**
1. **Young GC** - Collect Eden and Survivor regions
2. **Concurrent Marking** - Mark live objects
3. **Mixed GC** - Collect Young + some Old regions
4. **Full GC** - Fallback when concurrent marking fails

**Use Cases:**
- Large heaps (4GB+)
- Applications needing predictable pause times
- Multi-core systems
- Balanced throughput and latency

**Pros:**
- Predictable pause times
- Good for large heaps
- Compacts memory
- Balanced performance

**Cons:**
- More complex than Serial/Parallel
- Slightly lower throughput
- Memory overhead for region management

---

## üíª ZGC (Z Garbage Collector)

**Ultra-low-latency** collector for very large heaps (Java 11+, production-ready in Java 15).

### Characteristics

```bash
# Enable ZGC
java -XX:+UseZGC MyApp

# Set max heap
java -Xmx16g MyApp

# Set concurrent GC threads
java -XX:ConcGCThreads=4 MyApp
```

**Behavior:**
- Pause times < 10ms (even for TB heaps)
- Concurrent compaction
- Load barriers for object access
- Colored pointers

**Use Cases:**
- Very large heaps (TB scale)
- Ultra-low-latency requirements
- Real-time systems
- Large-scale applications

**Pros:**
- Sub-10ms pause times
- Scales to TB heaps
- Concurrent compaction
- Predictable performance

**Cons:**
- Higher memory overhead
- Lower throughput
- Requires Java 11+

---

## üíª Shenandoah GC

**Low-pause** collector (Java 12+, backported to Java 8/11).

### Characteristics

```bash
# Enable Shenandoah GC
java -XX:+UseShenandoahGC MyApp

# Set mode
java -XX:ShenandoahGCMode=iu MyApp
```

**Behavior:**
- Pause times independent of heap size
- Concurrent compaction
- Brooks pointers for forwarding

**Use Cases:**
- Low-latency applications
- Large heaps
- Predictable pause times

**Pros:**
- Very low pause times
- Concurrent evacuation
- Good for large heaps

**Cons:**
- Slightly lower throughput
- Memory overhead
- Requires Java 12+ (or backport)

---

## üìä GC Comparison

| GC | Pause Time | Throughput | Heap Size | Java Version | Default |
|----|------------|------------|-----------|--------------|---------|
| **Serial** | High | Medium | Small | All | Java 5-8 (client) |
| **Parallel** | High | High | Medium-Large | All | Java 5-8 (server) |
| **CMS** | Low | Medium | Large | 5-14 | Never |
| **G1** | Medium | High | Large | 7+ | Java 9+ |
| **ZGC** | Very Low | Medium | Very Large | 11+ | Never |
| **Shenandoah** | Very Low | Medium | Large | 12+ | Never |

---

## üìä Choosing the Right GC

| Requirement | Recommended GC |
|-------------|----------------|
| Small heap (<100 MB) | Serial GC |
| High throughput | Parallel GC |
| Balanced performance | G1 GC (default) |
| Low latency (<100ms) | G1 GC or CMS |
| Ultra-low latency (<10ms) | ZGC or Shenandoah |
| Very large heap (>32GB) | ZGC or Shenandoah |

---

## üéØ GC Tuning Example

```java
public class GCTuningDemo {
    public static void main(String[] args) {
        System.out.println("GC: " + 
            java.lang.management.ManagementFactory
                .getGarbageCollectorMXBeans()
                .stream()
                .map(gc -> gc.getName())
                .collect(java.util.stream.Collectors.joining(", ")));
        
        // Create objects to trigger GC
        List<byte[]> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            byte[] data = new byte[1024 * 1024];  // 1MB
            list.add(data);
            
            if (i % 100 == 0) {
                System.out.println("Created " + i + " objects");
            }
        }
        
        System.out.println("Done");
    }
}

// Run with different GCs:
// java -XX:+UseSerialGC -XX:+PrintGCDetails GCTuningDemo
// java -XX:+UseParallelGC -XX:+PrintGCDetails GCTuningDemo
// java -XX:+UseG1GC -XX:+PrintGCDetails GCTuningDemo
// java -XX:+UseZGC -XX:+PrintGCDetails GCTuningDemo
```

---

## ‚ö° Common GC Parameters

```bash
# Heap sizes
-Xms<size>          # Initial heap size
-Xmx<size>          # Maximum heap size
-Xmn<size>          # Young generation size

# GC logging
-Xlog:gc*           # GC logs (Java 9+)
-XX:+PrintGCDetails # GC details (Java 8)
-XX:+PrintGCTimeStamps

# Tuning
-XX:MaxGCPauseMillis=<n>     # Target max pause time
-XX:GCTimeRatio=<n>          # Throughput goal
-XX:ParallelGCThreads=<n>    # Parallel GC threads
-XX:ConcGCThreads=<n>        # Concurrent GC threads

# Advanced
-XX:+DisableExplicitGC       # Ignore System.gc()
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump
```

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use G1 for most cases | Good default choice |
| ‚úÖ Monitor GC logs | Identify issues |
| ‚úÖ Set Xms = Xmx | Avoid heap resizing |
| ‚úÖ Tune for your workload | Test different GCs |
| ‚úÖ Set realistic pause goals | Don't over-constrain |
| ‚ùå Don't use CMS | Deprecated, use G1/ZGC |
| ‚ùå Don't over-tune | Start with defaults |

---

## üîó Related Topics

- [Memory Structure](01.%20Memory%20Structure.md)
- [Garbage Collection](03.%20Garbage%20Collection.md)
- [Memory Leaks](05.%20Memory%20Leaks.md)

---

## üí° Key Takeaways

- Serial GC: single-threaded, small heaps
- Parallel GC: high throughput, batch processing
- CMS GC: low latency, deprecated
- G1 GC: balanced, default since Java 9
- ZGC: ultra-low latency, very large heaps
- Shenandoah: low pause times, concurrent
- Choose GC based on: heap size, latency, throughput requirements
- G1 is best default for most applications
- Use ZGC/Shenandoah for ultra-low latency
- Monitor and tune based on application behavior
