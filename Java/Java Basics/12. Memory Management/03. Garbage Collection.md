# üóëÔ∏è Garbage Collection

## üìñ Overview

**Garbage Collection (GC)** is automatic memory management in Java that reclaims memory occupied by objects no longer referenced by the program.

**Benefits:**
- Automatic memory deallocation
- Prevents memory leaks
- No manual memory management
- Safer than manual deallocation

---

## üíª How GC Works

### Object Reachability

```java
public class GCExample {
    public static void main(String[] args) {
        // Object is reachable
        Person person = new Person("Alice");
        
        // Object becomes unreachable (eligible for GC)
        person = null;
        
        // Create another object
        Person person2 = new Person("Bob");
        
        // Reassign reference - original object eligible for GC
        person2 = new Person("Charlie");
        
        // Objects created in loop - immediately eligible for GC
        for (int i = 0; i < 1000; i++) {
            Person temp = new Person("Temp" + i);
            // temp becomes unreachable after each iteration
        }
        
        // Suggest GC (doesn't guarantee execution)
        System.gc();
    }
}

class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    @Override
    protected void finalize() throws Throwable {
        System.out.println("GC: " + name);
        super.finalize();
    }
}
```

---

## üíª Generational GC

### Heap Generations

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Young Generation (1/3)           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ Eden ‚îÇ  ‚îÇ S0 ‚îÇ  ‚îÇ S1 ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ 80%  ‚îÇ  ‚îÇ10% ‚îÇ  ‚îÇ10% ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ    New objects      Survivor spaces     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Old Generation (2/3)                ‚îÇ
‚îÇ         Long-lived objects               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Generational Flow

```java
public class GenerationalDemo {
    public static void main(String[] args) {
        // Objects created in Eden
        for (int i = 0; i < 1000; i++) {
            String str = "Object-" + i;
            // Short-lived, collected quickly
        }
        
        // Long-lived objects eventually move to Old Gen
        List<String> longLived = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            longLived.add("Persistent-" + i);
        }
        // These survive multiple Minor GCs and move to Old Gen
    }
}
```

**Process:**
1. **New objects** ‚Üí Eden space
2. **Minor GC** ‚Üí Survivors move to S0/S1
3. **Multiple survivals** ‚Üí Move to Old Generation
4. **Major GC** ‚Üí Cleans Old Generation

---

## üíª Types of GC

### Minor GC (Young Generation)

```java
public class MinorGCDemo {
    public static void main(String[] args) {
        // Creates many short-lived objects
        for (int i = 0; i < 100000; i++) {
            String temp = new String("Temp" + i);
            // Most collected by Minor GC
        }
    }
}
```

- Frequent and fast
- Collects Young Generation
- Most objects die young (weak generational hypothesis)
- Uses "Stop the World" pause

### Major GC (Old Generation)

```java
public class MajorGCDemo {
    private static List<byte[]> list = new ArrayList<>();
    
    public static void main(String[] args) {
        // Fill Old Generation
        for (int i = 0; i < 1000; i++) {
            byte[] data = new byte[1024 * 1024];  // 1MB
            list.add(data);
            // Eventually triggers Major GC
        }
    }
}
```

- Less frequent, slower
- Collects Old Generation
- Longer "Stop the World" pause
- More expensive

### Full GC

- Collects entire heap (Young + Old)
- Most expensive
- Longest pause times
- Should be minimized

---

## üéØ Complete Examples

### Example 1: Eligible for GC

```java
public class GCEligibilityDemo {
    public static void main(String[] args) {
        // Case 1: Nullifying reference
        String str1 = "Hello";
        str1 = null;  // "Hello" eligible for GC
        
        // Case 2: Reassigning reference
        String str2 = "World";
        str2 = "Java";  // "World" eligible for GC
        
        // Case 3: Object created inside method
        createObject();  // Object eligible after method returns
        
        // Case 4: Island of isolation
        Sample s1 = new Sample();
        Sample s2 = new Sample();
        s1.other = s2;
        s2.other = s1;
        s1 = null;
        s2 = null;  // Both eligible (circular references don't prevent GC)
    }
    
    public static void createObject() {
        String local = "Local object";
        // local becomes unreachable when method returns
    }
}

class Sample {
    Sample other;
}
```

### Example 2: finalize() Method

```java
public class FinalizeDemo {
    private String name;
    
    public FinalizeDemo(String name) {
        this.name = name;
        System.out.println("Created: " + name);
    }
    
    @Override
    protected void finalize() throws Throwable {
        try {
            System.out.println("Finalizing: " + name);
            // Cleanup code (close files, release resources)
        } finally {
            super.finalize();
        }
    }
    
    public static void main(String[] args) {
        FinalizeDemo obj1 = new FinalizeDemo("Object-1");
        FinalizeDemo obj2 = new FinalizeDemo("Object-2");
        
        obj1 = null;
        obj2 = null;
        
        // Request GC (not guaranteed to run immediately)
        System.gc();
        
        // Wait for finalization
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Warning:** `finalize()` is deprecated since Java 9. Use try-with-resources or explicit cleanup instead.

### Example 3: Memory Monitoring

```java
public class MemoryMonitoring {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        
        System.out.println("=== Before Object Creation ===");
        printMemory(runtime);
        
        // Create many objects
        List<byte[]> list = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            byte[] data = new byte[1024 * 1024];  // 1MB each
            list.add(data);
        }
        
        System.out.println("\n=== After Object Creation ===");
        printMemory(runtime);
        
        // Clear references
        list.clear();
        list = null;
        
        // Suggest GC
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("\n=== After GC ===");
        printMemory(runtime);
    }
    
    private static void printMemory(Runtime runtime) {
        long total = runtime.totalMemory();
        long free = runtime.freeMemory();
        long used = total - free;
        long max = runtime.maxMemory();
        
        System.out.println("Total Memory: " + (total / 1024 / 1024) + " MB");
        System.out.println("Free Memory: " + (free / 1024 / 1024) + " MB");
        System.out.println("Used Memory: " + (used / 1024 / 1024) + " MB");
        System.out.println("Max Memory: " + (max / 1024 / 1024) + " MB");
    }
}
```

### Example 4: Triggering GC

```java
public class TriggerGCDemo {
    public static void main(String[] args) {
        System.out.println("Creating objects...");
        
        // Create objects that become immediately unreachable
        for (int i = 0; i < 1000000; i++) {
            String temp = new String("Object-" + i);
            // temp goes out of scope each iteration
        }
        
        System.out.println("Objects created");
        
        // Suggest GC (doesn't guarantee immediate execution)
        System.gc();
        System.out.println("Suggested GC");
        
        // Alternative: Runtime.getRuntime().gc();
        Runtime.getRuntime().gc();
        System.out.println("Suggested GC via Runtime");
        
        // Wait for GC
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("Done");
    }
}
```

---

## üìä GC Metrics

| Metric | Description |
|--------|-------------|
| **Throughput** | % time not spent in GC |
| **Latency** | Pause time during GC |
| **Footprint** | Memory used by GC |
| **Frequency** | How often GC runs |

---

## üìä GC Phases

| Phase | Description |
|-------|-------------|
| Mark | Identify live objects |
| Sweep | Remove dead objects |
| Compact | Defragment memory (optional) |

---

## ‚ö° JVM GC Options

```bash
# Print GC details
java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps MyApp

# Use G1 GC (default since Java 9)
java -XX:+UseG1GC MyApp

# Use Parallel GC
java -XX:+UseParallelGC MyApp

# Use CMS GC (deprecated)
java -XX:+UseConcMarkSweepGC MyApp

# Set heap size
java -Xms512m -Xmx2048m MyApp

# Set Young Generation size
java -Xmn256m MyApp

# Set GC log file
java -Xlog:gc*:file=gc.log MyApp

# Disable explicit GC (System.gc())
java -XX:+DisableExplicitGC MyApp
```

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Nullify references | Help GC identify unreachable objects |
| ‚úÖ Avoid System.gc() | Let JVM manage GC |
| ‚úÖ Use appropriate GC | Based on application needs |
| ‚úÖ Monitor GC logs | Identify performance issues |
| ‚úÖ Tune heap sizes | Avoid frequent GC |
| ‚úÖ Use object pools | For frequently created objects |
| ‚ùå Don't rely on finalize() | Deprecated and unreliable |
| ‚ùå Don't create unnecessary objects | Reduces GC pressure |

---

## üéØ GC Tuning Goals

1. **Maximize Throughput** - Minimize GC time
2. **Minimize Latency** - Reduce pause times
3. **Reduce Footprint** - Minimize memory usage

**Trade-offs:** Can't optimize all three simultaneously.

---

## üéØ When Objects Become Eligible for GC

```java
// 1. Nullifying reference
Object obj = new Object();
obj = null;

// 2. Reassigning reference
obj = new Object();
obj = new Object();  // First object eligible

// 3. Object created inside method
public void method() {
    Object obj = new Object();
}  // obj eligible when method returns

// 4. Island of isolation
A a1 = new A();
A a2 = new A();
a1.ref = a2;
a2.ref = a1;
a1 = null;
a2 = null;  // Both eligible (no external references)
```

---

## üîó Related Topics

- [Memory Structure](01.%20Memory%20Structure.md)
- [GC Algorithms](04.%20GC%20Algorithms.md)
- [Memory Leaks](05.%20Memory%20Leaks.md)
- [Reference Types](06.%20Reference%20Types.md)

---

## üí° Key Takeaways

- GC automatically reclaims memory from unreachable objects
- Generational GC: Young Gen (Eden + Survivors) and Old Gen
- Minor GC: frequent, fast, cleans Young Gen
- Major GC: less frequent, slower, cleans Old Gen
- Full GC: entire heap, most expensive
- System.gc() only suggests GC, doesn't guarantee execution
- finalize() is deprecated since Java 9
- Objects eligible for GC when no references exist
- Circular references don't prevent GC
- Monitor GC logs for performance tuning
