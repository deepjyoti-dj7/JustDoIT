# üîç Memory Leaks

## üìñ Overview

A **memory leak** occurs when objects are no longer used but remain referenced, preventing garbage collection. Over time, this reduces available memory and can cause `OutOfMemoryError`.

**Key Problem:** Objects that should be garbage collected remain reachable.

---

## üíª Common Causes

### 1. Static Collections

```java
public class StaticCollectionLeak {
    // Static collection retains all added elements forever
    private static List<Object> list = new ArrayList<>();
    
    public void addData(Object data) {
        list.add(data);  // ‚ùå Never removed, grows indefinitely
    }
    
    // Fix: Clear or use non-static
    public static void main(String[] args) {
        StaticCollectionLeak leak = new StaticCollectionLeak();
        
        // Add 1 million objects
        for (int i = 0; i < 1_000_000; i++) {
            leak.addData(new byte[1024]);  // 1KB each
        }
        
        // Objects never garbage collected due to static reference
        System.gc();
        System.out.println("List size: " + list.size());
    }
}

// ‚úÖ Solution 1: Clear when done
public class FixedStaticCollection {
    private static List<Object> list = new ArrayList<>();
    
    public void addData(Object data) {
        list.add(data);
    }
    
    public void clearData() {
        list.clear();  // Remove references
    }
}

// ‚úÖ Solution 2: Use non-static
public class FixedInstanceCollection {
    private List<Object> list = new ArrayList<>();  // Instance variable
    
    public void addData(Object data) {
        list.add(data);
    }
    // When instance is GC'd, list is also eligible
}
```

---

### 2. Unclosed Resources

```java
public class ResourceLeak {
    // ‚ùå Resource not closed
    public void readFileBad(String path) {
        try {
            FileInputStream fis = new FileInputStream(path);
            BufferedReader br = new BufferedReader(new InputStreamReader(fis));
            String line = br.readLine();
            // Missing close() - file handle and buffers remain open
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    // ‚úÖ Solution 1: try-with-resources (Java 7+)
    public void readFileGood(String path) {
        try (FileInputStream fis = new FileInputStream(path);
             BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {
            String line = br.readLine();
            // Auto-closed when leaving try block
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    // ‚úÖ Solution 2: finally block
    public void readFileFinally(String path) {
        FileInputStream fis = null;
        BufferedReader br = null;
        try {
            fis = new FileInputStream(path);
            br = new BufferedReader(new InputStreamReader(fis));
            String line = br.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (br != null) br.close();
                if (fis != null) fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

// Common unclosed resources:
// - FileInputStream/FileOutputStream
// - Connection (JDBC)
// - Statement/ResultSet
// - Socket
// - BufferedReader/BufferedWriter
```

---

### 3. Unremoved Listeners/Callbacks

```java
public class ListenerLeak {
    private List<EventListener> listeners = new ArrayList<>();
    
    // ‚ùå Listeners never removed
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // ‚úÖ Provide removal method
    public void removeListener(EventListener listener) {
        listeners.remove(listener);
    }
}

// Example: Swing listeners
public class SwingLeakExample {
    private JButton button = new JButton("Click");
    
    public void setupUI() {
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                // Anonymous inner class holds reference to outer class
                System.out.println("Clicked");
            }
        });
        
        // ‚ùå If button outlives this object, the outer class can't be GC'd
    }
    
    // ‚úÖ Solution: Remove listener when done
    private ActionListener listener;
    
    public void setupUIFixed() {
        listener = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Clicked");
            }
        };
        button.addActionListener(listener);
    }
    
    public void cleanup() {
        button.removeActionListener(listener);
    }
}
```

---

### 4. Inner Classes Holding References

```java
public class InnerClassLeak {
    private byte[] data = new byte[1024 * 1024];  // 1MB
    
    // ‚ùå Non-static inner class holds reference to outer class
    public class InnerClass {
        public void doSomething() {
            // Even if not explicitly using outer class,
            // implicit reference exists
            System.out.println("Inner class");
        }
    }
    
    public InnerClass getInnerInstance() {
        return new InnerClass();
        // Returns inner instance, but keeps outer instance alive
    }
    
    // ‚úÖ Solution: Use static inner class if possible
    public static class StaticInnerClass {
        public void doSomething() {
            System.out.println("Static inner class");
        }
    }
    
    public static void main(String[] args) {
        List<InnerClass> leaks = new ArrayList<>();
        
        for (int i = 0; i < 1000; i++) {
            InnerClassLeak outer = new InnerClassLeak();
            leaks.add(outer.getInnerInstance());
            // outer should be GC'd, but inner class keeps it alive
            // 1000 * 1MB = 1GB leaked!
        }
    }
}
```

---

### 5. ThreadLocal Variables

```java
public class ThreadLocalLeak {
    // ‚ùå ThreadLocal not removed
    private static ThreadLocal<Connection> connectionHolder = 
        new ThreadLocal<>();
    
    public void useConnection() {
        Connection conn = getConnection();
        connectionHolder.set(conn);
        // ... use connection
        // ‚ùå Not removed - leaked if thread is reused (thread pool)
    }
    
    // ‚úÖ Solution: Always remove after use
    public void useConnectionFixed() {
        try {
            Connection conn = getConnection();
            connectionHolder.set(conn);
            // ... use connection
        } finally {
            connectionHolder.remove();  // Clean up
        }
    }
    
    private Connection getConnection() {
        return null;  // Dummy
    }
}

// ThreadLocal in thread pool scenario
public class ThreadPoolLeakExample {
    private static ThreadLocal<byte[]> threadLocal = 
        new ThreadLocal<>();
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        
        for (int i = 0; i < 100; i++) {
            executor.submit(() -> {
                // Set large data
                threadLocal.set(new byte[1024 * 1024]);  // 1MB
                // ... do work
                // ‚ùå If not removed, thread keeps reference
                // Thread pool reuses threads, so data never GC'd
            });
        }
        
        executor.shutdown();
    }
}
```

---

### 6. HashMap/HashSet with Poor equals/hashCode

```java
public class HashMapLeak {
    public static void main(String[] args) {
        Map<Person, String> map = new HashMap<>();
        
        Person p1 = new Person("Alice", 25);
        map.put(p1, "Data");
        
        // Modify key (breaks hashCode contract)
        p1.setAge(26);
        
        // Can't find or remove entry anymore
        map.remove(p1);  // Doesn't work! hashCode changed
        
        // Entry leaks - never removed
        System.out.println("Map size: " + map.size());  // Still 1
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);  // Uses mutable field
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Person)) return false;
        Person other = (Person) obj;
        return age == other.age && Objects.equals(name, other.name);
    }
}

// ‚úÖ Solution: Don't modify objects used as keys
// OR use immutable objects as keys
```

---

## üéØ Complete Example: Memory Leak Detection

```java
public class MemoryLeakDetector {
    private static List<Object> leakyList = new ArrayList<>();
    
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        
        System.out.println("Creating objects...");
        
        for (int i = 0; i < 100; i++) {
            createObjects();
            
            if (i % 10 == 0) {
                long used = runtime.totalMemory() - runtime.freeMemory();
                System.out.println("Iteration " + i + 
                    ", Used: " + (used / 1024 / 1024) + " MB");
            }
        }
        
        System.out.println("Leaky list size: " + leakyList.size());
    }
    
    private static void createObjects() {
        // These objects accumulate in static list
        for (int i = 0; i < 1000; i++) {
            leakyList.add(new byte[1024]);  // 1KB each
        }
    }
}
```

---

## üìä Memory Leak Symptoms

| Symptom | Description |
|---------|-------------|
| Increasing memory usage | Gradual memory growth over time |
| OutOfMemoryError | Eventually runs out of heap |
| Degraded performance | More frequent GC, slower response |
| Long GC pauses | GC unable to reclaim memory |
| Heap dump growth | Heap snapshots show increasing objects |

---

## üìä Detection Tools

| Tool | Purpose |
|------|---------|
| **VisualVM** | Monitor heap, take heap dumps |
| **JProfiler** | Advanced profiling, leak detection |
| **Eclipse MAT** | Analyze heap dumps |
| **YourKit** | Java profiler with leak detection |
| **jmap** | Generate heap dumps |
| **jhat** | Analyze heap dumps |

---

## ‚ö° Detection Commands

```bash
# Generate heap dump
jmap -dump:format=b,file=heap.bin <pid>

# Force GC before dump
jmap -dump:live,format=b,file=heap.bin <pid>

# View heap histogram
jmap -histo <pid>

# Monitor with jstat
jstat -gcutil <pid> 1000

# Auto heap dump on OOM
java -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/path/to/dumps \
     MyApp

# Enable GC logging
java -Xlog:gc*:file=gc.log MyApp
```

---

## ‚ö° Prevention Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Close resources | Use try-with-resources |
| ‚úÖ Remove listeners | Provide unregister methods |
| ‚úÖ Clear collections | Null out or clear when done |
| ‚úÖ Use weak references | For caches and listeners |
| ‚úÖ Clean up ThreadLocal | Call remove() in finally |
| ‚úÖ Static inner classes | Avoid holding outer references |
| ‚úÖ Immutable keys | For HashMap/HashSet |
| ‚úÖ Profile regularly | Detect leaks early |
| ‚úÖ Code reviews | Check resource management |
| ‚ùå Avoid static collections | Or manage size |
| ‚ùå Don't modify keys | In HashMap/HashSet |

---

## üéØ Fixing Memory Leaks Workflow

1. **Detect:** Monitor memory growth patterns
2. **Reproduce:** Isolate leak in controlled environment
3. **Capture:** Take heap dump when memory is high
4. **Analyze:** Use Eclipse MAT or similar tool
5. **Identify:** Find objects consuming memory
6. **Trace:** Follow reference chain to root cause
7. **Fix:** Nullify references or close resources
8. **Verify:** Monitor after fix deployment

---

## üéØ Common Leak Patterns Summary

```java
// 1. Static collection
private static List<Object> list = new ArrayList<>();

// 2. Unclosed resource
InputStream is = new FileInputStream(file);  // Not closed

// 3. Unremoved listener
button.addActionListener(listener);  // Not removed

// 4. Inner class reference
public class Outer {
    class Inner { }  // Holds reference to Outer
}

// 5. ThreadLocal not cleaned
ThreadLocal<Object> tl = new ThreadLocal<>();
tl.set(obj);  // Not removed

// 6. Mutable key
Map<MutableKey, Value> map = new HashMap<>();
key.modify();  // Can't remove entry

// 7. Forgotten cache
private Map<Key, Value> cache = new HashMap<>();  // Grows forever
```

---

## üîó Related Topics

- [Memory Structure](01.%20Memory%20Structure.md)
- [Garbage Collection](03.%20Garbage%20Collection.md)
- [Reference Types](06.%20Reference%20Types.md)

---

## üí° Key Takeaways

- Memory leak = objects remain reachable but unused
- Static collections are common culprits
- Always close resources (use try-with-resources)
- Remove listeners and callbacks when done
- Non-static inner classes hold outer references
- Clean up ThreadLocal in thread pools
- Don't modify objects used as HashMap keys
- Use profiling tools to detect leaks early
- Monitor memory usage in production
- Heap dumps help identify leak sources
- Prevention is easier than fixing later
