# üîó Reference Types

## üìñ Overview

Java provides four types of references that determine how objects are garbage collected: **Strong**, **Soft**, **Weak**, and **Phantom**. These allow fine-grained control over object lifecycle and memory management.

---

## üíª Strong Reference

**Default reference type** - prevents garbage collection.

```java
public class StrongReferenceDemo {
    public static void main(String[] args) {
        // Strong reference
        Object obj = new Object();
        
        // Object won't be GC'd while reference exists
        System.gc();
        System.out.println("Object still alive: " + (obj != null));
        
        // Only eligible for GC when reference is removed
        obj = null;
        System.gc();
        
        // Now eligible for GC
    }
}
```

**Characteristics:**
- Default reference type
- Prevents garbage collection
- Object GC'd only when no strong references exist
- Most common reference type

**Use Cases:**
- Normal object usage
- When object must not be GC'd prematurely

---

## üíª Soft Reference

**Memory-sensitive** cache - cleared before OutOfMemoryError.

```java
import java.lang.ref.SoftReference;

public class SoftReferenceDemo {
    public static void main(String[] args) {
        // Create object with soft reference
        Object obj = new Object();
        SoftReference<Object> softRef = new SoftReference<>(obj);
        
        // Remove strong reference
        obj = null;
        
        // Object still available through soft reference
        Object retrieved = softRef.get();
        System.out.println("Retrieved: " + (retrieved != null));  // true
        
        // GC may clear soft reference if memory is low
        System.gc();
        
        retrieved = softRef.get();
        System.out.println("After GC: " + (retrieved != null));  // May be false
    }
}
```

### Example: Image Cache

```java
import java.lang.ref.SoftReference;
import java.util.HashMap;
import java.util.Map;

public class ImageCache {
    private Map<String, SoftReference<byte[]>> cache = new HashMap<>();
    
    public void cacheImage(String name, byte[] imageData) {
        cache.put(name, new SoftReference<>(imageData));
    }
    
    public byte[] getImage(String name) {
        SoftReference<byte[]> ref = cache.get(name);
        
        if (ref != null) {
            byte[] image = ref.get();
            if (image != null) {
                System.out.println("Cache hit: " + name);
                return image;
            } else {
                System.out.println("Cache cleared by GC: " + name);
                cache.remove(name);
            }
        }
        
        // Load from disk/network
        System.out.println("Cache miss: " + name);
        byte[] image = loadImageFromDisk(name);
        cacheImage(name, image);
        return image;
    }
    
    private byte[] loadImageFromDisk(String name) {
        // Simulate loading
        return new byte[1024 * 1024];  // 1MB
    }
    
    public static void main(String[] args) {
        ImageCache cache = new ImageCache();
        
        // Cache images
        cache.cacheImage("image1.jpg", new byte[1024 * 1024]);
        cache.cacheImage("image2.jpg", new byte[1024 * 1024]);
        
        // Retrieve images
        cache.getImage("image1.jpg");  // Cache hit
        cache.getImage("image2.jpg");  // Cache hit
        
        // Simulate low memory
        System.gc();
        
        cache.getImage("image1.jpg");  // May be cache miss
    }
}
```

**Characteristics:**
- Cleared before OutOfMemoryError
- Survives GC if memory is sufficient
- Ideal for memory-sensitive caches
- get() returns null if cleared

**Use Cases:**
- Image caches
- Data caches that can be reloaded
- Memory-sensitive caching

---

## üíª Weak Reference

**Weakly reachable** - cleared on next GC cycle.

```java
import java.lang.ref.WeakReference;

public class WeakReferenceDemo {
    public static void main(String[] args) {
        Object obj = new Object();
        WeakReference<Object> weakRef = new WeakReference<>(obj);
        
        System.out.println("Before: " + (weakRef.get() != null));  // true
        
        // Remove strong reference
        obj = null;
        
        // Object still temporarily available
        System.out.println("After null: " + (weakRef.get() != null));  // true
        
        // Next GC cycle clears weak reference
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("After GC: " + (weakRef.get() != null));  // false
    }
}
```

### Example: WeakHashMap

```java
import java.util.WeakHashMap;
import java.util.Map;

public class WeakHashMapDemo {
    public static void main(String[] args) {
        Map<Person, String> map = new WeakHashMap<>();
        
        Person p1 = new Person("Alice");
        Person p2 = new Person("Bob");
        
        map.put(p1, "Data 1");
        map.put(p2, "Data 2");
        
        System.out.println("Size: " + map.size());  // 2
        
        // Remove strong reference
        p1 = null;
        
        // Entry with p1 key is eligible for GC
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("After GC: " + map.size());  // 1 (p1 entry removed)
    }
}

class Person {
    private String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    @Override
    public String toString() {
        return name;
    }
}
```

### Example: Observer Pattern with Weak References

```java
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

public class WeakObserverPattern {
    private List<WeakReference<Observer>> observers = new ArrayList<>();
    
    public void addObserver(Observer observer) {
        observers.add(new WeakReference<>(observer));
    }
    
    public void notifyObservers(String message) {
        // Remove cleared weak references
        observers.removeIf(ref -> ref.get() == null);
        
        for (WeakReference<Observer> ref : observers) {
            Observer observer = ref.get();
            if (observer != null) {
                observer.update(message);
            }
        }
    }
    
    public static void main(String[] args) {
        WeakObserverPattern subject = new WeakObserverPattern();
        
        Observer obs1 = new Observer("Observer 1");
        Observer obs2 = new Observer("Observer 2");
        
        subject.addObserver(obs1);
        subject.addObserver(obs2);
        
        subject.notifyObservers("Event 1");  // Both notified
        
        // Remove strong reference
        obs1 = null;
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        subject.notifyObservers("Event 2");  // Only obs2 notified
    }
}

class Observer {
    private String name;
    
    public Observer(String name) {
        this.name = name;
    }
    
    public void update(String message) {
        System.out.println(name + " received: " + message);
    }
}
```

**Characteristics:**
- Cleared at next GC cycle
- Doesn't prevent garbage collection
- get() returns null after GC
- WeakHashMap uses weak references for keys

**Use Cases:**
- Canonicalizing mappings (WeakHashMap)
- Listeners that don't prevent GC
- Weak caches

---

## üíª Phantom Reference

**Post-mortem cleanup** - used with ReferenceQueue for finalization.

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

public class PhantomReferenceDemo {
    public static void main(String[] args) {
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        Object obj = new Object();
        PhantomReference<Object> phantomRef = 
            new PhantomReference<>(obj, queue);
        
        // get() always returns null
        System.out.println("get(): " + phantomRef.get());  // null
        
        // Remove strong reference
        obj = null;
        
        // Trigger GC
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        // Check if phantom reference was enqueued
        System.out.println("Enqueued: " + (queue.poll() != null));  // true
    }
}
```

### Example: Resource Cleanup

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.util.HashMap;
import java.util.Map;

public class ResourceCleanup {
    private static ReferenceQueue<Resource> queue = new ReferenceQueue<>();
    private static Map<PhantomReference<Resource>, String> refs = new HashMap<>();
    
    static class Resource {
        private String name;
        
        public Resource(String name) {
            this.name = name;
            System.out.println("Created: " + name);
        }
    }
    
    public static void main(String[] args) {
        // Create cleanup thread
        Thread cleanupThread = new Thread(() -> {
            while (true) {
                try {
                    PhantomReference<Resource> ref = 
                        (PhantomReference<Resource>) queue.remove();
                    String name = refs.remove(ref);
                    System.out.println("Cleaning up: " + name);
                    // Perform cleanup (close files, release resources)
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        cleanupThread.setDaemon(true);
        cleanupThread.start();
        
        // Create resources
        Resource r1 = new Resource("Resource 1");
        Resource r2 = new Resource("Resource 2");
        
        // Register phantom references
        refs.put(new PhantomReference<>(r1, queue), "Resource 1");
        refs.put(new PhantomReference<>(r2, queue), "Resource 2");
        
        // Remove strong references
        r1 = null;
        r2 = null;
        
        // Trigger GC
        System.gc();
        
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Characteristics:**
- get() always returns null
- Enqueued after object is finalized
- Used for post-mortem cleanup
- More reliable than finalize()

**Use Cases:**
- Resource cleanup
- Off-heap memory management
- Tracking object lifecycle

---

## üìä Reference Types Comparison

| Type | GC Behavior | get() After GC | Use Case |
|------|-------------|----------------|----------|
| **Strong** | Never collected | N/A | Normal usage |
| **Soft** | Before OutOfMemoryError | null | Memory-sensitive cache |
| **Weak** | Next GC cycle | null | Canonicalizing mappings |
| **Phantom** | After finalization | Always null | Post-mortem cleanup |

---

## üìä Reference Strength Hierarchy

```
Strong Reference (never GC'd)
      ‚Üì
Soft Reference (GC'd before OOM)
      ‚Üì
Weak Reference (GC'd on next cycle)
      ‚Üì
Phantom Reference (GC'd after finalization)
```

---

## üíª ReferenceQueue Example

```java
import java.lang.ref.*;
import java.util.HashMap;
import java.util.Map;

public class ReferenceQueueDemo {
    public static void main(String[] args) {
        ReferenceQueue<Object> queue = new ReferenceQueue<>();
        Map<Reference<Object>, String> refMap = new HashMap<>();
        
        // Create objects with weak references
        Object obj1 = new Object();
        Object obj2 = new Object();
        
        WeakReference<Object> ref1 = new WeakReference<>(obj1, queue);
        WeakReference<Object> ref2 = new WeakReference<>(obj2, queue);
        
        refMap.put(ref1, "Object 1");
        refMap.put(ref2, "Object 2");
        
        System.out.println("Created references");
        
        // Remove strong references
        obj1 = null;
        obj2 = null;
        
        // Trigger GC
        System.gc();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        // Check queue
        Reference<? extends Object> ref;
        while ((ref = queue.poll()) != null) {
            String name = refMap.remove(ref);
            System.out.println("Enqueued: " + name);
        }
    }
}
```

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Strong for most cases | Default is usually right |
| ‚úÖ Soft for caches | Memory-sensitive caching |
| ‚úÖ Weak for canonicalizing | WeakHashMap, listeners |
| ‚úÖ Phantom for cleanup | Resource management |
| ‚úÖ Check for null | get() may return null |
| ‚úÖ Use ReferenceQueue | Track when objects are GC'd |
| ‚ùå Don't over-use | Complexity vs benefit |
| ‚ùå Don't replace finalize() | Use try-with-resources instead |

---

## üéØ When to Use Each Type

| Scenario | Reference Type |
|----------|----------------|
| Normal object usage | Strong |
| Memory-sensitive cache | Soft |
| WeakHashMap keys | Weak |
| Auto-removing listeners | Weak |
| Resource cleanup | Phantom |
| Tracking object lifecycle | Phantom |

---

## üîó Related Topics

- [Memory Structure](01.%20Memory%20Structure.md)
- [Garbage Collection](03.%20Garbage%20Collection.md)
- [Memory Leaks](05.%20Memory%20Leaks.md)

---

## üí° Key Takeaways

- Four reference types: Strong, Soft, Weak, Phantom
- Strong references prevent GC (default)
- Soft references cleared before OutOfMemoryError
- Weak references cleared at next GC cycle
- Phantom references used for post-mortem cleanup
- get() returns null after object is GC'd (except Strong)
- ReferenceQueue tracks when objects are GC'd
- WeakHashMap uses weak references for keys
- Use Soft for memory-sensitive caches
- Use Weak for canonicalizing mappings
- Use Phantom for reliable resource cleanup
- Avoid over-using - adds complexity
