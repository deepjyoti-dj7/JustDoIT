# âš–ï¸ Heap vs Stack

## ğŸ“– Overview

**Heap** and **Stack** are two primary memory areas in JVM with different characteristics, purposes, and management strategies.

---

## ğŸ’» Stack Memory

### Characteristics

```java
public class StackExample {
    public static void main(String[] args) {
        // Primitive in Stack
        int x = 10;
        int y = 20;
        
        // Reference in Stack, object in Heap
        String name = "John";
        
        // Method call creates new stack frame
        int result = add(x, y);
        
        System.out.println(result);
    }  // Stack frame popped, variables destroyed
    
    public static int add(int a, int b) {
        // New stack frame
        int sum = a + b;
        return sum;
    }  // Stack frame popped
}
```

**Stack stores:**
- Local variables
- Method parameters
- Return addresses
- Partial results
- References to objects (not the objects themselves)

**Lifecycle:**
- Created when thread starts
- Frame pushed on method call
- Frame popped on method return
- Destroyed when thread terminates

---

## ğŸ’» Heap Memory

### Characteristics

```java
public class HeapExample {
    // Instance variables stored in Heap
    private int id;
    private String name;
    
    public static void main(String[] args) {
        // Objects created in Heap
        HeapExample obj1 = new HeapExample();
        obj1.id = 1;
        obj1.name = "Alice";
        
        HeapExample obj2 = new HeapExample();
        obj2.id = 2;
        obj2.name = "Bob";
        
        // Array in Heap
        int[] numbers = new int[100];
        
        // Wrapper objects in Heap
        Integer num = 42;
        
        // All these objects remain until garbage collected
    }
}
```

**Heap stores:**
- Objects
- Instance variables
- Arrays
- Class instances

**Lifecycle:**
- Created when JVM starts
- Shared by all threads
- Objects remain until garbage collected
- Destroyed when JVM shuts down

---

## ğŸ¯ Complete Examples

### Example 1: Understanding References

```java
public class ReferenceDemo {
    public static void main(String[] args) {
        // Stack: person (reference variable)
        // Heap: Person object
        Person person = new Person("Alice", 30);
        
        // Stack: another reference to same object
        Person samePerson = person;
        
        // Both references point to same Heap object
        samePerson.setAge(31);
        System.out.println(person.getAge());  // 31
        
        // Stack: newPerson (reference)
        // Heap: New Person object
        Person newPerson = new Person("Bob", 25);
        
        // Now person references different object
        person = newPerson;
        
        // Original object with Alice is eligible for GC
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void setAge(int age) { this.age = age; }
    public int getAge() { return age; }
}
```

### Example 2: Stack Frame Visualization

```java
public class StackFrameDemo {
    public static void main(String[] args) {
        int a = 10;           // Frame 1: main
        int b = 20;
        
        int result = method1(a, b);
        System.out.println(result);
    }
    
    public static int method1(int x, int y) {
        int sum = x + y;      // Frame 2: method1
        return method2(sum);
    }
    
    public static int method2(int value) {
        int doubled = value * 2;  // Frame 3: method2
        return doubled;
    }
}

/*
Stack visualization during execution:

Step 1 (in main):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()         â”‚
â”‚  a = 10        â”‚
â”‚  b = 20        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2 (calling method1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ method1()      â”‚
â”‚  x = 10        â”‚
â”‚  y = 20        â”‚
â”‚  sum = 30      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ main()         â”‚
â”‚  a = 10        â”‚
â”‚  b = 20        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3 (calling method2):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ method2()      â”‚
â”‚  value = 30    â”‚
â”‚  doubled = 60  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ method1()      â”‚
â”‚  x = 10        â”‚
â”‚  y = 20        â”‚
â”‚  sum = 30      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ main()         â”‚
â”‚  a = 10        â”‚
â”‚  b = 20        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After method2 returns:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ method1()      â”‚
â”‚  x = 10        â”‚
â”‚  y = 20        â”‚
â”‚  sum = 30      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ main()         â”‚
â”‚  a = 10        â”‚
â”‚  b = 20        â”‚
â”‚  result = 60   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/
```

### Example 3: Memory Allocation

```java
public class MemoryAllocationDemo {
    // Static variable - Method Area
    private static int staticVar = 100;
    
    // Instance variable - will be in Heap
    private int instanceVar = 50;
    
    public static void main(String[] args) {
        // Primitives in Stack
        int stackInt = 10;
        double stackDouble = 20.5;
        boolean stackBoolean = true;
        
        // Reference in Stack, object in Heap
        MemoryAllocationDemo obj = new MemoryAllocationDemo();
        
        // Reference in Stack, String in Heap
        String str = "Hello";
        
        // Reference in Stack, array in Heap
        int[] array = {1, 2, 3, 4, 5};
        
        // Reference in Stack, wrapper object in Heap
        Integer num = 42;
        
        // All objects remain in Heap until GC
        // Stack variables cleared when method returns
    }
}

/*
Memory Layout:

STACK (Thread-1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ main()                  â”‚
â”‚  stackInt = 10          â”‚
â”‚  stackDouble = 20.5     â”‚
â”‚  stackBoolean = true    â”‚
â”‚  obj = 0x1234 â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  str = 0x5678 â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  array = 0x9ABC â”€â”€â”€â”â”‚â”‚  â”‚
â”‚  num = 0xDEF0 â”€â”€â”€â”€â”â”‚â”‚â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”¼â”¼â”€â”€â”˜
                    â”‚â”‚â”‚â”‚
HEAP:               â”‚â”‚â”‚â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”¼â”¼â”€â”€â”
â”‚ MemoryAllocationDemoâ”‚â”‚â”‚  â”‚
â”‚ object (0x1234) â—„â”€â”€â”˜â”‚â”‚  â”‚
â”‚  instanceVar = 50   â”‚â”‚  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”€â”€â”¤
â”‚ String "Hello"      â”‚â”‚  â”‚
â”‚ (0x5678) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¤
â”‚ int[] array         â”‚  â”‚
â”‚ (0x9ABC) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  [1, 2, 3, 4, 5]       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Integer object         â”‚
â”‚ (0xDEF0) â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  value = 42            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

METHOD AREA:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ staticVar = 100        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/
```

### Example 4: String Pool

```java
public class StringPoolDemo {
    public static void main(String[] args) {
        // String literals go to String Pool (in Heap)
        String str1 = "Hello";
        String str2 = "Hello";
        
        // Both references point to same object in pool
        System.out.println(str1 == str2);  // true
        
        // new keyword creates object in Heap (outside pool)
        String str3 = new String("Hello");
        
        // Different objects
        System.out.println(str1 == str3);  // false
        
        // intern() moves to pool or returns existing
        String str4 = str3.intern();
        System.out.println(str1 == str4);  // true
    }
}

/*
Memory Layout:

STACK:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ str1 â”€â”€â”€â”€â”   â”‚
â”‚ str2 â”€â”€â”€â”€â”¤   â”‚
â”‚ str3 â”€â”€â”€â”€â”¼â”  â”‚
â”‚ str4 â”€â”€â”€â”€â”˜â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”€â”€â”˜
           â”‚â”‚
HEAP:      â”‚â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”€â”€â”
â”‚ String Pool â”‚
â”‚ "Hello" â—„â”€â”˜â”‚ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”¤
â”‚ String     â”‚ â”‚
â”‚ "Hello" â—„â”€â”€â”˜ â”‚
â”‚ (separate)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/
```

---

## ğŸ“Š Heap vs Stack Comparison

| Aspect | Stack | Heap |
|--------|-------|------|
| **Purpose** | Method execution, local variables | Object storage |
| **Scope** | Per-thread | Shared across threads |
| **Size** | Small (1-2 MB default) | Large (configurable) |
| **Access Speed** | Fast | Slower than stack |
| **Memory Management** | Automatic (LIFO) | Garbage Collection |
| **Stores** | Primitives, references | Objects, arrays |
| **Lifetime** | Method execution | Until GC |
| **Thread Safety** | Thread-safe (isolated) | Requires synchronization |
| **Allocation** | Continuous | Fragmented |
| **Error** | StackOverflowError | OutOfMemoryError |

---

## ğŸ“Š What Goes Where

| Declaration | Stack | Heap |
|-------------|-------|------|
| `int x = 10;` | âœ… x = 10 | âŒ |
| `Integer x = 10;` | âœ… reference | âœ… Integer object |
| `String s = "Hi";` | âœ… reference | âœ… String object |
| `int[] arr = new int[5];` | âœ… reference | âœ… array |
| `Person p = new Person();` | âœ… reference | âœ… Person object |
| `static int x = 10;` | âŒ | âŒ (Method Area) |

---

## ğŸ¯ Performance Implications

```java
public class PerformanceDemo {
    public static void main(String[] args) {
        // Fast - Stack allocation
        int sum = 0;
        for (int i = 0; i < 1000000; i++) {
            sum += i;
        }
        
        // Slower - Heap allocation
        Integer total = 0;
        for (int i = 0; i < 1000000; i++) {
            total += i;  // Boxing/unboxing + heap access
        }
        
        // Even slower - Object creation
        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            numbers.add(i);  // Each add creates object in heap
        }
    }
}
```

---

## âš¡ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… Use primitives when possible | Stack is faster |
| âœ… Limit object creation | Reduce heap pressure |
| âœ… Reuse objects | Object pooling |
| âœ… Avoid deep recursion | Prevent StackOverflowError |
| âœ… Nullify references | Help garbage collection |
| âŒ Don't store large data in stack | Use heap |
| âŒ Don't create unnecessary objects | Memory waste |

---

## ğŸ¯ Common Misconceptions

### Misconception 1: Objects are always in Heap

```java
// Modern JVMs can use escape analysis
public class EscapeAnalysis {
    public static void main(String[] args) {
        // If object doesn't escape method, JVM may allocate on stack
        Point p = new Point(10, 20);
        int sum = p.getX() + p.getY();
        System.out.println(sum);
        // p is not returned or stored, may be stack-allocated
    }
}
```

### Misconception 2: Stack is always faster

```java
// For frequently accessed objects, heap may be cached
public class CacheDemo {
    private static final String CONSTANT = "Cached";  // JVM optimizes
    
    public static void main(String[] args) {
        // Repeated access to same heap object can be fast
        for (int i = 0; i < 1000000; i++) {
            System.out.println(CONSTANT);  // No repeated lookups
        }
    }
}
```

---

## ğŸ”— Related Topics

- [Memory Structure](01.%20Memory%20Structure.md)
- [Garbage Collection](03.%20Garbage%20Collection.md)
- [Memory Leaks](05.%20Memory%20Leaks.md)

---

## ğŸ’¡ Key Takeaways

- Stack: fast, thread-local, automatic management
- Heap: shared, garbage collected, stores objects
- Primitives stored in stack
- Objects stored in heap, references in stack
- Stack uses LIFO structure
- Stack faster but smaller than heap
- StackOverflowError from deep recursion
- OutOfMemoryError from too many heap objects
- String literals go to String Pool in heap
- Modern JVMs optimize with escape analysis
