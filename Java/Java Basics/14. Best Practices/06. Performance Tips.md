# ‚ö° Performance Tips

## üìñ Overview

Performance optimization techniques to write efficient Java code. Remember: **premature optimization is the root of all evil** - optimize only when needed.

---

## üíª String Handling

```java
// ‚ùå Slow - String concatenation in loop
String result = "";
for (int i = 0; i < 10000; i++) {
    result += "item" + i;  // Creates new String each time
}

// ‚úÖ Fast - StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append("item").append(i);
}
String result = sb.toString();

// Benchmark: StringBuilder ~100x faster for 10k iterations

// ‚úÖ Use String.format for occasional formatting
String message = String.format("User %s has %d points", name, points);

// ‚úÖ Use text blocks for multi-line (Java 15+)
String html = """
    <html>
        <body>Hello</body>
    </html>
    """;
```

---

## üíª Collection Choice

```java
// Choose right collection for use case

// ‚úÖ Fast lookup by key - HashMap
Map<String, User> userMap = new HashMap<>();
User user = userMap.get("userId");  // O(1)

// ‚úÖ Fast contains check - HashSet
Set<String> validEmails = new HashSet<>();
boolean exists = validEmails.contains(email);  // O(1)

// ‚úÖ Sequential access - ArrayList
List<String> names = new ArrayList<>();
for (String name : names) { }  // Fast iteration

// ‚úÖ Frequent insertions/deletions - LinkedList
List<String> queue = new LinkedList<>();
queue.addFirst("item");  // O(1)
queue.removeLast();      // O(1)

// ‚ùå Wrong choice - ArrayList for many insertions at start
List<String> list = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    list.add(0, "item");  // O(n) - shifts all elements
}

// ‚úÖ Better - LinkedList or use addLast()
List<String> list = new LinkedList<>();
for (int i = 0; i < 10000; i++) {
    list.addFirst("item");  // O(1)
}
```

---

## üíª Loop Optimization

```java
// ‚ùå Slow - Method call in condition
for (int i = 0; i < list.size(); i++) {  // size() called every iteration
    process(list.get(i));
}

// ‚úÖ Fast - Cache size
int size = list.size();
for (int i = 0; i < size; i++) {
    process(list.get(i));
}

// ‚úÖ Better - Enhanced for loop
for (String item : list) {
    process(item);
}

// ‚úÖ Best - Stream (for operations that benefit)
list.stream()
    .filter(item -> item.length() > 5)
    .forEach(this::process);

// ‚úÖ Parallel stream for CPU-intensive work
list.parallelStream()
    .map(this::expensiveOperation)
    .collect(Collectors.toList());
```

---

## üíª Lazy Initialization

```java
// ‚ùå Eager - Always created even if not used
public class Service {
    private ExpensiveResource resource = new ExpensiveResource();
    
    public void doSomething() {
        // May not use resource
    }
}

// ‚úÖ Lazy - Created only when needed
public class Service {
    private ExpensiveResource resource;
    
    private ExpensiveResource getResource() {
        if (resource == null) {
            resource = new ExpensiveResource();
        }
        return resource;
    }
    
    public void doSomething() {
        getResource().use();
    }
}

// ‚úÖ Thread-safe lazy initialization
public class Service {
    private volatile ExpensiveResource resource;
    
    public ExpensiveResource getResource() {
        if (resource == null) {
            synchronized (this) {
                if (resource == null) {
                    resource = new ExpensiveResource();
                }
            }
        }
        return resource;
    }
}
```

---

## üíª Avoid Unnecessary Objects

```java
// ‚ùå Bad - Creates many objects
public String processData() {
    String result = "";
    for (int i = 0; i < 1000; i++) {
        result = result + getData(i);  // New String each time
    }
    return result;
}

// ‚úÖ Good - Reuse objects
public String processData() {
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < 1000; i++) {
        result.append(getData(i));
    }
    return result.toString();
}

// ‚ùå Bad - Boxing in loop
long sum = 0L;
for (int i = 0; i < 10000; i++) {
    Long value = calculateValue(i);  // Boxing
    sum += value;  // Unboxing
}

// ‚úÖ Good - Use primitives
long sum = 0L;
for (int i = 0; i < 10000; i++) {
    long value = calculateValue(i);  // No boxing
    sum += value;
}
```

---

## üíª Use Primitive Types

```java
// ‚ùå Slower - Wrapper classes
List<Integer> numbers = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    numbers.add(i);  // Autoboxing overhead
}

// ‚úÖ Faster - Primitive arrays (when possible)
int[] numbers = new int[10000];
for (int i = 0; i < 10000; i++) {
    numbers[i] = i;  // No boxing
}

// ‚úÖ Use primitive streams
int sum = IntStream.range(0, 10000)
    .filter(n -> n % 2 == 0)
    .sum();

// vs slower boxed stream
int sum = Stream.iterate(0, n -> n + 1)
    .limit(10000)
    .filter(n -> n % 2 == 0)
    .mapToInt(Integer::intValue)
    .sum();
```

---

## üíª Caching

```java
// ‚úÖ Cache expensive computations
public class PrimeChecker {
    private static final Set<Integer> PRIMES_CACHE = new HashSet<>();
    
    public boolean isPrime(int number) {
        if (PRIMES_CACHE.contains(number)) {
            return true;  // Cached result
        }
        
        boolean isPrime = calculateIsPrime(number);
        if (isPrime) {
            PRIMES_CACHE.add(number);
        }
        return isPrime;
    }
    
    private boolean calculateIsPrime(int number) {
        // Expensive calculation
        return true;
    }
}

// ‚úÖ Memoization with computeIfAbsent
Map<Integer, Integer> fibCache = new HashMap<>();

public int fibonacci(int n) {
    if (n <= 1) return n;
    return fibCache.computeIfAbsent(n, 
        k -> fibonacci(n - 1) + fibonacci(n - 2));
}
```

---

## üíª Database Optimization

```java
// ‚ùå N+1 Query Problem
List<Order> orders = orderRepository.findAll();
for (Order order : orders) {
    Customer customer = customerRepository.findById(order.getCustomerId());
    // 1 query for orders + N queries for customers
}

// ‚úÖ Fetch with JOIN
@Query("SELECT o FROM Order o JOIN FETCH o.customer")
List<Order> findAllWithCustomers();

// ‚úÖ Batch processing
@Transactional
public void processOrders(List<Order> orders) {
    for (int i = 0; i < orders.size(); i++) {
        orderRepository.save(orders.get(i));
        if (i % 50 == 0) {  // Batch size
            entityManager.flush();
            entityManager.clear();
        }
    }
}

// ‚úÖ Use pagination
Page<Order> orders = orderRepository.findAll(
    PageRequest.of(page, size, Sort.by("createdAt").descending())
);
```

---

## üíª Stream Performance

```java
// ‚úÖ Use primitive streams
// Slower
long sum = list.stream()
    .mapToInt(Integer::intValue)
    .sum();

// Faster
long sum = list.stream()
    .mapToInt(i -> i)
    .sum();

// ‚úÖ Parallel streams for CPU-intensive tasks
List<Result> results = data.parallelStream()
    .map(this::cpuIntensiveOperation)
    .collect(Collectors.toList());

// ‚ùå Don't use parallel for I/O operations
// Slower - thread overhead > I/O time
data.parallelStream()
    .forEach(this::saveToDatabase);

// ‚úÖ Better - sequential for I/O
data.stream()
    .forEach(this::saveToDatabase);
```

---

## üíª Exception Performance

```java
// ‚ùå Slow - Exceptions for flow control
public Integer parseOrNull(String value) {
    try {
        return Integer.parseInt(value);
    } catch (NumberFormatException e) {
        return null;  // Expensive for common case
    }
}

// ‚úÖ Fast - Validate first
public Integer parseOrNull(String value) {
    if (value == null || !value.matches("\\d+")) {
        return null;
    }
    return Integer.parseInt(value);
}

// Exception creation is expensive - avoid in hot paths
```

---

## üíª Regular Expressions

```java
// ‚ùå Slow - Compile pattern every time
for (String email : emails) {
    if (email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
        // ...
    }
}

// ‚úÖ Fast - Compile once, reuse
private static final Pattern EMAIL_PATTERN = 
    Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");

for (String email : emails) {
    if (EMAIL_PATTERN.matcher(email).matches()) {
        // ...
    }
}
```

---

## üìä Performance Comparison

| Operation | Slow Approach | Fast Approach | Speedup |
|-----------|--------------|---------------|---------|
| **String concat** | + in loop | StringBuilder | 100x |
| **Collection lookup** | ArrayList.contains() | HashSet.contains() | O(n) ‚Üí O(1) |
| **Boxing** | Integer in loop | int primitive | 5-10x |
| **Stream** | Boxed stream | Primitive stream | 2-3x |
| **Regex** | Compile each time | Compiled Pattern | 10x |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Profile first | Measure before optimizing |
| ‚úÖ Use StringBuilder | For string concatenation |
| ‚úÖ Right collection | HashMap vs ArrayList |
| ‚úÖ Use primitives | Avoid unnecessary boxing |
| ‚úÖ Cache results | Expensive computations |
| ‚úÖ Batch operations | Database updates |
| ‚úÖ Lazy initialization | Create when needed |
| ‚ùå Don't premature optimize | Clarity first |
| ‚ùå Don't use exceptions for flow | Expensive |
| ‚ùå Don't parallel for I/O | Sequential better |

---

## üîß Profiling Tools

| Tool | Purpose |
|------|---------|
| **JProfiler** | Memory & CPU profiling |
| **VisualVM** | Monitor performance |
| **JMH** | Micro-benchmarking |
| **Java Flight Recorder** | Production profiling |
| **YourKit** | Performance analysis |

---

## üí° Key Takeaways

- Profile before optimizing
- Use StringBuilder for string concatenation
- Choose right collection for use case
- Prefer primitives over wrappers
- Cache expensive computations
- Avoid creating unnecessary objects
- Use lazy initialization when appropriate
- Compile regex patterns once
- Don't use exceptions for control flow
- Parallel streams for CPU-intensive tasks only
- Batch database operations
- Premature optimization is evil - optimize bottlenecks
