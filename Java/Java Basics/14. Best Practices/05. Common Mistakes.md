# ‚ö†Ô∏è Common Mistakes

## üìñ Overview

Common Java mistakes that developers should avoid to write better, more maintainable code.

---

## üíª NullPointerException

```java
// ‚ùå Common mistake
public String getCustomerName(Long id) {
    Customer customer = findCustomer(id);
    return customer.getName();  // NPE if customer is null
}

// ‚úÖ Solution 1: Null check
public String getCustomerName(Long id) {
    Customer customer = findCustomer(id);
    if (customer != null) {
        return customer.getName();
    }
    return "Unknown";
}

// ‚úÖ Solution 2: Optional
public Optional<String> getCustomerName(Long id) {
    return findCustomer(id)
        .map(Customer::getName);
}

// ‚úÖ Solution 3: Objects.requireNonNull
public void processCustomer(Customer customer) {
    Objects.requireNonNull(customer, "Customer cannot be null");
    // Safe to use customer
}
```

---

## üíª Ignoring Exceptions

```java
// ‚ùå Bad - Silent failure
try {
    processPayment(order);
} catch (Exception e) {
    // Ignored - very dangerous!
}

// ‚ùå Bad - Only printing
try {
    processPayment(order);
} catch (Exception e) {
    e.printStackTrace();  // Not enough
}

// ‚úÖ Good - Proper handling
try {
    processPayment(order);
} catch (PaymentException e) {
    logger.error("Payment failed for order: " + order.getId(), e);
    notifyAdmin(e);
    throw new OrderProcessingException("Payment failed", e);
}
```

---

## üíª String Comparison

```java
// ‚ùå Wrong - Using ==
String name1 = "Alice";
String name2 = new String("Alice");
if (name1 == name2) {  // false - compares references
    System.out.println("Equal");
}

// ‚úÖ Correct - Using equals()
if (name1.equals(name2)) {  // true - compares values
    System.out.println("Equal");
}

// ‚úÖ Null-safe comparison
if (Objects.equals(name1, name2)) {  // Handles null
    System.out.println("Equal");
}
```

---

## üíª Resource Leaks

```java
// ‚ùå Bad - Resource not closed
public void readFile(String path) throws IOException {
    FileInputStream fis = new FileInputStream(path);
    BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
    String line = reader.readLine();
    // File handle never closed - memory leak
}

// ‚úÖ Good - try-with-resources
public void readFile(String path) throws IOException {
    try (FileInputStream fis = new FileInputStream(path);
         BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {
        String line = reader.readLine();
        // Auto-closed
    }
}
```

---

## üíª Modifying Collection While Iterating

```java
// ‚ùå Wrong - ConcurrentModificationException
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
for (String item : list) {
    if (item.equals("B")) {
        list.remove(item);  // Throws exception
    }
}

// ‚úÖ Solution 1: Iterator
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("B")) {
        iterator.remove();  // Safe removal
    }
}

// ‚úÖ Solution 2: removeIf (Java 8+)
list.removeIf(item -> item.equals("B"));

// ‚úÖ Solution 3: Stream
List<String> filtered = list.stream()
    .filter(item -> !item.equals("B"))
    .collect(Collectors.toList());
```

---

## üíª Not Overriding equals() and hashCode()

```java
// ‚ùå Bad - Missing overrides
public class Person {
    private String name;
    private int age;
    // No equals() and hashCode()
}

Set<Person> set = new HashSet<>();
set.add(new Person("Alice", 25));
set.add(new Person("Alice", 25));
System.out.println(set.size());  // 2 - should be 1

// ‚úÖ Good - Proper implementation
public class Person {
    private String name;
    private int age;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return age == person.age && 
               Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

---

## üíª Using Raw Types

```java
// ‚ùå Bad - Raw type (no type safety)
List list = new ArrayList();
list.add("String");
list.add(123);
list.add(new Date());

String str = (String) list.get(1);  // ClassCastException at runtime

// ‚úÖ Good - Generic type
List<String> list = new ArrayList<>();
list.add("String");
// list.add(123);  // Compile error - type safe
String str = list.get(0);  // No casting needed
```

---

## üíª StringBuilder in Loops

```java
// ‚ùå Bad - String concatenation in loop
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i + ", ";  // Creates new String object each time
}

// ‚úÖ Good - StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i).append(", ");
}
String result = sb.toString();

// ‚úÖ Better - Stream (Java 8+)
String result = IntStream.range(0, 1000)
    .mapToObj(String::valueOf)
    .collect(Collectors.joining(", "));
```

---

## üíª Catching Generic Exception

```java
// ‚ùå Bad - Too generic
try {
    processOrder(order);
    sendEmail(customer);
    updateInventory(items);
} catch (Exception e) {  // Catches everything
    logger.error("Error", e);
}

// ‚úÖ Good - Specific exceptions
try {
    processOrder(order);
    sendEmail(customer);
    updateInventory(items);
} catch (OrderException e) {
    logger.error("Order processing failed", e);
    rollbackOrder(order);
} catch (EmailException e) {
    logger.warn("Email notification failed", e);
    // Order still processed
} catch (InventoryException e) {
    logger.error("Inventory update failed", e);
    compensateOrder(order);
}
```

---

## üíª Not Closing Database Connections

```java
// ‚ùå Bad - Connection leak
public List<User> getUsers() {
    Connection conn = dataSource.getConnection();
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM users");
    // Process results
    // Never closed - connection leak
}

// ‚úÖ Good - Proper cleanup
public List<User> getUsers() {
    try (Connection conn = dataSource.getConnection();
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {
        // Process results
        List<User> users = new ArrayList<>();
        while (rs.next()) {
            users.add(mapUser(rs));
        }
        return users;
    } catch (SQLException e) {
        throw new DataAccessException("Failed to fetch users", e);
    }
}
```

---

## üíª Unnecessary Object Creation

```java
// ‚ùå Bad - Creating unnecessary objects
Boolean flag = new Boolean(true);
Integer count = new Integer(10);
String str = new String("Hello");

// ‚úÖ Good - Use primitives or autoboxing
boolean flag = true;
int count = 10;
String str = "Hello";

// ‚úÖ Good - Use valueOf for wrappers
Integer count = Integer.valueOf(10);
Boolean flag = Boolean.valueOf(true);
```

---

## üíª Ignoring Return Values

```java
// ‚ùå Bad - Ignoring return value
String text = "  hello world  ";
text.trim();  // Returns new string, original unchanged
System.out.println(text);  // Still has spaces

// ‚úÖ Good - Use return value
String text = "  hello world  ";
String trimmed = text.trim();
System.out.println(trimmed);  // Spaces removed
```

---

## üíª Using Float/Double for Money

```java
// ‚ùå Bad - Precision issues
double price = 0.1;
double quantity = 0.2;
double total = price + quantity;
System.out.println(total);  // 0.30000000000000004

// ‚úÖ Good - Use BigDecimal
BigDecimal price = new BigDecimal("0.1");
BigDecimal quantity = new BigDecimal("0.2");
BigDecimal total = price.add(quantity);
System.out.println(total);  // 0.3
```

---

## üíª Static Mutable Fields

```java
// ‚ùå Bad - Mutable static field
public class Config {
    public static List<String> settings = new ArrayList<>();
    // Can be modified from anywhere - not thread-safe
}

// ‚úÖ Good - Immutable static field
public class Config {
    public static final List<String> SETTINGS = 
        Collections.unmodifiableList(Arrays.asList("setting1", "setting2"));
}
```

---

## üìä Common Mistakes Summary

| Mistake | Impact | Solution |
|---------|--------|----------|
| **NPE** | Runtime crash | Null checks, Optional |
| **Ignoring exceptions** | Silent failures | Proper handling |
| **String ==** | Wrong comparisons | Use equals() |
| **Resource leaks** | Memory issues | try-with-resources |
| **Modify during iteration** | Exception | Iterator, removeIf |
| **Missing equals/hashCode** | Wrong behavior | Override both |
| **Raw types** | No type safety | Use generics |
| **String + in loop** | Performance | StringBuilder |
| **Generic catch** | Poor error handling | Specific exceptions |
| **Float for money** | Precision loss | BigDecimal |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Optional | Avoid null checks |
| ‚úÖ Handle exceptions | Log and recover |
| ‚úÖ Close resources | try-with-resources |
| ‚úÖ Use generics | Type safety |
| ‚úÖ Override equals/hashCode | For collections |
| ‚úÖ Use BigDecimal | For money |
| ‚úÖ StringBuilder | For concatenation |
| ‚ùå Don't ignore exceptions | Always handle |
| ‚ùå Don't use == for strings | Use equals() |
| ‚ùå Don't modify while iterating | Use iterator |

---

## üí° Key Takeaways

- Check for null before dereferencing
- Always handle exceptions properly
- Use equals() not == for objects
- Close all resources with try-with-resources
- Don't modify collections while iterating
- Override equals() and hashCode() together
- Use generic types for type safety
- Use StringBuilder for string concatenation in loops
- Catch specific exceptions, not generic
- Use BigDecimal for monetary values
