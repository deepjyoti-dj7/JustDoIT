# ‚ú® Clean Code

## üìñ Overview

**Clean Code** is code that is easy to read, understand, and maintain. It follows consistent patterns and expresses intent clearly.

---

## üíª Meaningful Names

```java
// ‚ùå Bad - Unclear names
int d;  // elapsed time in days
String s1;
List<int[]> lst;

public void proc(int a, int b) {
    int temp = a + b;
    // ...
}

// ‚úÖ Good - Clear, descriptive names
int elapsedTimeInDays;
String customerName;
List<Customer> activeCustomers;

public void calculateTotal(int price, int quantity) {
    int totalCost = price * quantity;
    // ...
}
```

---

## üíª Small Functions

```java
// ‚ùå Bad - Too long, does too much
public void processOrder(Order order) {
    // Validate customer
    if (order.getCustomer() == null) {
        throw new IllegalArgumentException("Customer required");
    }
    if (!order.getCustomer().isActive()) {
        throw new IllegalStateException("Customer inactive");
    }
    
    // Validate items
    if (order.getItems().isEmpty()) {
        throw new IllegalArgumentException("Order has no items");
    }
    for (OrderItem item : order.getItems()) {
        if (item.getQuantity() <= 0) {
            throw new IllegalArgumentException("Invalid quantity");
        }
    }
    
    // Calculate total
    double total = 0;
    for (OrderItem item : order.getItems()) {
        total += item.getPrice() * item.getQuantity();
    }
    order.setTotal(total);
    
    // Process payment
    // ... 50 more lines
    
    // Send notification
    // ... 30 more lines
}

// ‚úÖ Good - Small, focused functions
public void processOrder(Order order) {
    validateOrder(order);
    calculateTotal(order);
    processPayment(order);
    sendConfirmation(order);
}

private void validateOrder(Order order) {
    validateCustomer(order.getCustomer());
    validateItems(order.getItems());
}

private void validateCustomer(Customer customer) {
    if (customer == null) {
        throw new IllegalArgumentException("Customer required");
    }
    if (!customer.isActive()) {
        throw new IllegalStateException("Customer inactive");
    }
}

private void validateItems(List<OrderItem> items) {
    if (items.isEmpty()) {
        throw new IllegalArgumentException("Order has no items");
    }
    items.forEach(this::validateItem);
}

private void validateItem(OrderItem item) {
    if (item.getQuantity() <= 0) {
        throw new IllegalArgumentException("Invalid quantity");
    }
}

private void calculateTotal(Order order) {
    double total = order.getItems().stream()
        .mapToDouble(item -> item.getPrice() * item.getQuantity())
        .sum();
    order.setTotal(total);
}
```

---

## üíª Do One Thing

```java
// ‚ùå Bad - Multiple responsibilities
public User saveUserAndSendEmail(User user) {
    // Save user
    database.save(user);
    
    // Send email
    String subject = "Welcome!";
    String body = "Thanks for signing up";
    emailService.send(user.getEmail(), subject, body);
    
    // Log activity
    logger.info("User saved: " + user.getId());
    
    return user;
}

// ‚úÖ Good - Single responsibility
public User saveUser(User user) {
    return database.save(user);
}

public void sendWelcomeEmail(User user) {
    String subject = "Welcome!";
    String body = "Thanks for signing up";
    emailService.send(user.getEmail(), subject, body);
}

public void logUserCreation(User user) {
    logger.info("User saved: " + user.getId());
}

// Orchestrate in higher level
public void registerUser(User user) {
    User savedUser = saveUser(user);
    sendWelcomeEmail(savedUser);
    logUserCreation(savedUser);
}
```

---

## üíª Comments

```java
// ‚ùå Bad - Redundant comments
// Get the name
public String getName() {
    return name;  // return name
}

// Increment counter by 1
counter++;

// Check if user is active
if (user.isActive()) {
    // ...
}

// ‚úÖ Good - Comments only when needed
// Regex pattern for email validation (RFC 5322)
private static final String EMAIL_PATTERN = "^[...]$";

// Workaround for bug #1234 - remove after library update
if (someCondition) {
    // ...
}

// Algorithm: Binary search O(log n)
private int binarySearch(int[] arr, int target) {
    // ...
}

// ‚úÖ Better - Self-documenting code
// Instead of:
// Check if employee is eligible for bonus
if (employee.getSalary() > 50000 && employee.getYears() > 2) {
    // ...
}

// Use:
if (isEligibleForBonus(employee)) {
    // ...
}

private boolean isEligibleForBonus(Employee employee) {
    return employee.getSalary() > 50000 && employee.getYears() > 2;
}
```

---

## üíª Error Handling

```java
// ‚ùå Bad - Swallowing exceptions
try {
    processPayment(order);
} catch (Exception e) {
    // Silent failure
}

// ‚ùå Bad - Generic catch
try {
    processPayment(order);
} catch (Exception e) {
    System.out.println("Error occurred");
}

// ‚úÖ Good - Specific exceptions
try {
    processPayment(order);
} catch (PaymentDeclinedException e) {
    logger.warn("Payment declined for order: " + order.getId(), e);
    notifyCustomer(order.getCustomer(), "Payment declined");
    throw e;
} catch (NetworkException e) {
    logger.error("Network error during payment", e);
    retryPayment(order);
}

// ‚úÖ Good - Don't return null
// Instead of:
public Customer findCustomer(Long id) {
    Customer customer = database.find(id);
    return customer;  // May return null
}

// Use Optional:
public Optional<Customer> findCustomer(Long id) {
    return Optional.ofNullable(database.find(id));
}

// Or throw exception:
public Customer getCustomer(Long id) {
    return database.find(id)
        .orElseThrow(() -> new CustomerNotFoundException(id));
}
```

---

## üíª DRY (Don't Repeat Yourself)

```java
// ‚ùå Bad - Repeated code
public void sendEmailToCustomer(Customer customer, String message) {
    String email = customer.getEmail();
    String subject = "Notification";
    emailService.send(email, subject, message);
    logger.info("Email sent to: " + email);
}

public void sendEmailToSupplier(Supplier supplier, String message) {
    String email = supplier.getEmail();
    String subject = "Notification";
    emailService.send(email, subject, message);
    logger.info("Email sent to: " + email);
}

// ‚úÖ Good - Extracted common logic
public void sendNotificationEmail(String email, String message) {
    String subject = "Notification";
    emailService.send(email, subject, message);
    logger.info("Email sent to: " + email);
}

public void notifyCustomer(Customer customer, String message) {
    sendNotificationEmail(customer.getEmail(), message);
}

public void notifySupplier(Supplier supplier, String message) {
    sendNotificationEmail(supplier.getEmail(), message);
}
```

---

## üíª Avoid Magic Numbers

```java
// ‚ùå Bad - Magic numbers
if (employee.getYears() > 5 && employee.getSalary() < 100000) {
    employee.setSalary(employee.getSalary() * 1.1);
}

// ‚úÖ Good - Named constants
private static final int SENIOR_EMPLOYEE_YEARS = 5;
private static final double MAX_SALARY_FOR_RAISE = 100000;
private static final double RAISE_PERCENTAGE = 0.1;

if (employee.getYears() > SENIOR_EMPLOYEE_YEARS && 
    employee.getSalary() < MAX_SALARY_FOR_RAISE) {
    double newSalary = employee.getSalary() * (1 + RAISE_PERCENTAGE);
    employee.setSalary(newSalary);
}

// ‚úÖ Better - Extract to method
if (isEligibleForRaise(employee)) {
    applyRaise(employee);
}

private boolean isEligibleForRaise(Employee employee) {
    return employee.getYears() > SENIOR_EMPLOYEE_YEARS && 
           employee.getSalary() < MAX_SALARY_FOR_RAISE;
}

private void applyRaise(Employee employee) {
    double newSalary = employee.getSalary() * (1 + RAISE_PERCENTAGE);
    employee.setSalary(newSalary);
}
```

---

## üíª Keep It Simple (KISS)

```java
// ‚ùå Bad - Over-complicated
public boolean isValidAge(Integer age) {
    if (age != null) {
        if (age >= 0) {
            if (age <= 150) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    } else {
        return false;
    }
}

// ‚úÖ Good - Simple and clear
public boolean isValidAge(Integer age) {
    return age != null && age >= 0 && age <= 150;
}
```

---

## üíª Consistent Formatting

```java
// ‚úÖ Good - Consistent style
public class Customer {
    private String name;
    private String email;
    
    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }
    
    public String getName() {
        return name;
    }
    
    public String getEmail() {
        return email;
    }
    
    @Override
    public String toString() {
        return "Customer{" +
               "name='" + name + '\'' +
               ", email='" + email + '\'' +
               '}';
    }
}
```

---

## üíª Avoid Deep Nesting

```java
// ‚ùå Bad - Too many nested levels
public void processOrder(Order order) {
    if (order != null) {
        if (order.getCustomer() != null) {
            if (order.getItems() != null) {
                if (!order.getItems().isEmpty()) {
                    for (OrderItem item : order.getItems()) {
                        if (item.getQuantity() > 0) {
                            // Process item
                        }
                    }
                }
            }
        }
    }
}

// ‚úÖ Good - Early returns
public void processOrder(Order order) {
    if (order == null) return;
    if (order.getCustomer() == null) return;
    if (order.getItems() == null || order.getItems().isEmpty()) return;
    
    order.getItems().stream()
        .filter(item -> item.getQuantity() > 0)
        .forEach(this::processItem);
}

private void processItem(OrderItem item) {
    // Process item
}
```

---

## üìä Clean Code Principles

| Principle | Description |
|-----------|-------------|
| **Meaningful Names** | Clear, descriptive identifiers |
| **Small Functions** | Do one thing well |
| **DRY** | Don't repeat yourself |
| **KISS** | Keep it simple |
| **YAGNI** | You aren't gonna need it |
| **Separation of Concerns** | Different responsibilities separate |
| **Single Responsibility** | One reason to change |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use meaningful names | Self-documenting |
| ‚úÖ Keep functions small | < 20 lines |
| ‚úÖ Avoid deep nesting | Max 3 levels |
| ‚úÖ Handle errors properly | Don't swallow exceptions |
| ‚úÖ Use constants | No magic numbers |
| ‚úÖ Write tests | Code is testable |
| ‚ùå Don't write clever code | Write clear code |
| ‚ùå Don't over-comment | Code should explain itself |
| ‚ùå Don't optimize prematurely | Clarity first |

---

## üí° Key Takeaways

- Code is read more than written
- Meaningful names are crucial
- Functions should be small and focused
- Comments explain why, not what
- Don't repeat yourself (DRY)
- Keep it simple (KISS)
- Handle errors gracefully
- Avoid magic numbers
- Reduce nesting with early returns
- Consistent formatting matters
