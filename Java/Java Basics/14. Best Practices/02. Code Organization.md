# ğŸ“ Code Organization

## ğŸ“– Overview

**Code organization** involves structuring packages, classes, and files for maintainability, readability, and scalability.

---

## ğŸ’» Package Structure

```
com.company.project/
â”œâ”€â”€ config/              # Configuration classes
â”‚   â”œâ”€â”€ AppConfig.java
â”‚   â””â”€â”€ SecurityConfig.java
â”œâ”€â”€ controller/          # REST controllers
â”‚   â”œâ”€â”€ UserController.java
â”‚   â””â”€â”€ OrderController.java
â”œâ”€â”€ service/            # Business logic
â”‚   â”œâ”€â”€ UserService.java
â”‚   â”œâ”€â”€ OrderService.java
â”‚   â””â”€â”€ impl/
â”‚       â”œâ”€â”€ UserServiceImpl.java
â”‚       â””â”€â”€ OrderServiceImpl.java
â”œâ”€â”€ repository/         # Data access
â”‚   â”œâ”€â”€ UserRepository.java
â”‚   â””â”€â”€ OrderRepository.java
â”œâ”€â”€ model/             # Domain entities
â”‚   â”œâ”€â”€ User.java
â”‚   â”œâ”€â”€ Order.java
â”‚   â””â”€â”€ OrderItem.java
â”œâ”€â”€ dto/               # Data transfer objects
â”‚   â”œâ”€â”€ UserDTO.java
â”‚   â””â”€â”€ OrderDTO.java
â”œâ”€â”€ exception/         # Custom exceptions
â”‚   â”œâ”€â”€ ResourceNotFoundException.java
â”‚   â””â”€â”€ InvalidRequestException.java
â””â”€â”€ util/              # Utility classes
    â”œâ”€â”€ DateUtils.java
    â””â”€â”€ StringUtils.java
```

---

## ğŸ’» Class Organization

```java
// âœ… Well-organized class
public class Customer {
    // 1. Constants
    private static final int MAX_ORDERS = 100;
    private static final String DEFAULT_COUNTRY = "USA";
    
    // 2. Static variables
    private static int customerCount = 0;
    
    // 3. Instance variables (private first)
    private Long id;
    private String name;
    private String email;
    private Address address;
    
    // 4. Constructors
    public Customer() {
        customerCount++;
    }
    
    public Customer(String name, String email) {
        this();
        this.name = name;
        this.email = email;
    }
    
    // 5. Static methods
    public static int getCustomerCount() {
        return customerCount;
    }
    
    // 6. Public methods
    public void updateProfile(String name, String email) {
        this.name = name;
        this.email = email;
        validateProfile();
    }
    
    public boolean hasValidEmail() {
        return email != null && email.contains("@");
    }
    
    // 7. Protected methods
    protected void notifyCustomer(String message) {
        System.out.println("Notifying: " + message);
    }
    
    // 8. Private methods
    private void validateProfile() {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Name is required");
        }
    }
    
    // 9. Getters and setters (at the end)
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    // 10. Nested classes (if needed)
    public static class Address {
        private String street;
        private String city;
        private String zipCode;
        
        // ... methods
    }
}
```

**Order:**
1. Constants
2. Static variables
3. Instance variables
4. Constructors
5. Static methods
6. Public methods
7. Protected methods
8. Private methods
9. Getters/Setters
10. Nested classes

---

## ğŸ’» Method Organization

```java
public class OrderService {
    // âœ… Public API methods first
    public Order createOrder(Customer customer, List<OrderItem> items) {
        validateCustomer(customer);
        validateItems(items);
        
        Order order = buildOrder(customer, items);
        double total = calculateTotal(items);
        order.setTotal(total);
        
        return saveOrder(order);
    }
    
    public Order getOrderById(Long orderId) {
        return findOrder(orderId)
            .orElseThrow(() -> new OrderNotFoundException(orderId));
    }
    
    // Private helper methods below
    private void validateCustomer(Customer customer) {
        if (customer == null) {
            throw new IllegalArgumentException("Customer is required");
        }
    }
    
    private void validateItems(List<OrderItem> items) {
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("Order must have items");
        }
    }
    
    private Order buildOrder(Customer customer, List<OrderItem> items) {
        Order order = new Order();
        order.setCustomer(customer);
        order.setItems(items);
        order.setOrderDate(LocalDateTime.now());
        return order;
    }
    
    private double calculateTotal(List<OrderItem> items) {
        return items.stream()
            .mapToDouble(item -> item.getPrice() * item.getQuantity())
            .sum();
    }
    
    private Order saveOrder(Order order) {
        // Save logic
        return order;
    }
    
    private Optional<Order> findOrder(Long orderId) {
        // Find logic
        return Optional.empty();
    }
}
```

---

## ğŸ’» File Organization

```java
// âœ… One public class per file
// File: Customer.java
public class Customer {
    // Customer implementation
}

// âŒ Multiple public classes (not allowed)
// File: Classes.java
// public class Customer { }
// public class Order { }  // Compilation error

// âœ… Private helper classes in same file
// File: Customer.java
public class Customer {
    private Address address;
    
    // Helper class
    private static class Address {
        private String street;
        private String city;
    }
}
```

---

## ğŸ’» Layered Architecture

```java
// Controller Layer - Handle HTTP requests
@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserService userService;
    
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
}

// Service Layer - Business logic
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public UserDTO getUserById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
        return convertToDTO(user);
    }
    
    private UserDTO convertToDTO(User user) {
        // Conversion logic
        return new UserDTO();
    }
}

// Repository Layer - Data access
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    List<User> findByActive(boolean active);
}

// Model Layer - Domain entities
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private boolean active;
    
    // Getters and setters
}
```

---

## ğŸ’» Separation of Concerns

```java
// âœ… Good - Separated concerns
public class OrderController {
    private final OrderService orderService;
    
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        Order order = orderService.createOrder(request);
        return ResponseEntity.ok(order);
    }
}

public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;
    
    public Order createOrder(OrderRequest request) {
        Order order = buildOrder(request);
        paymentService.processPayment(order);
        return orderRepository.save(order);
    }
}

// âŒ Bad - Mixed concerns
public class OrderController {
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        // HTTP logic
        // Business logic
        // Database logic
        // All mixed together
        Order order = new Order();
        // ... direct database access
        // ... payment processing
        // ... validation
        return ResponseEntity.ok(order);
    }
}
```

---

## ğŸ’» Module Organization (Java 9+)

```java
// module-info.java
module com.company.project {
    // Dependencies
    requires java.sql;
    requires spring.boot;
    
    // Exported packages
    exports com.company.project.api;
    exports com.company.project.model;
    
    // Opens for reflection
    opens com.company.project.entity to hibernate.core;
}
```

---

## ğŸ“Š Package Organization Patterns

| Pattern | Structure | Use Case |
|---------|-----------|----------|
| **Layer-based** | controller/, service/, repository/ | Small to medium apps |
| **Feature-based** | user/, order/, payment/ | Large apps |
| **Hexagonal** | domain/, application/, infrastructure/ | DDD projects |
| **Clean Architecture** | entities/, usecases/, adapters/ | Complex systems |

---

## ğŸ“Š Class Size Guidelines

| Metric | Guideline | Reason |
|--------|-----------|--------|
| **Lines** | < 300 lines | Maintainability |
| **Methods** | < 20 methods | Single responsibility |
| **Dependencies** | < 7 dependencies | Low coupling |
| **Cyclomatic complexity** | < 10 | Testability |

---

## âš¡ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… One class per file | Easier to find and maintain |
| âœ… Group by feature | Related code together |
| âœ… Follow layer pattern | Separate concerns |
| âœ… Limit class size | Keep classes focused |
| âœ… Consistent structure | Same order in all classes |
| âœ… Package by feature | Not just by type |
| âŒ Don't mix concerns | Separate layers |
| âŒ Don't create God classes | Break into smaller classes |

---

## ğŸ¯ Feature-Based vs Layer-Based

```
# Layer-Based (Traditional)
src/main/java/
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ UserController.java
â”‚   â””â”€â”€ OrderController.java
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ UserService.java
â”‚   â””â”€â”€ OrderService.java
â””â”€â”€ repository/
    â”œâ”€â”€ UserRepository.java
    â””â”€â”€ OrderRepository.java

# Feature-Based (Modern)
src/main/java/
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ UserController.java
â”‚   â”œâ”€â”€ UserService.java
â”‚   â”œâ”€â”€ UserRepository.java
â”‚   â””â”€â”€ User.java
â””â”€â”€ order/
    â”œâ”€â”€ OrderController.java
    â”œâ”€â”€ OrderService.java
    â”œâ”€â”€ OrderRepository.java
    â””â”€â”€ Order.java
```

---

## ğŸ¯ Dependency Direction

```java
// âœ… Good - Dependencies point inward
// Controller -> Service -> Repository -> Entity

@RestController
public class UserController {
    private final UserService userService;  // Depends on service
}

@Service
public class UserService {
    private final UserRepository userRepository;  // Depends on repository
}

@Repository
public interface UserRepository {
    // No dependencies on upper layers
}

// âŒ Bad - Circular dependencies
@Service
public class UserService {
    private UserController controller;  // Service depends on controller!
}
```

---

## ğŸ’¡ Key Takeaways

- Organize by layers or features
- One public class per file
- Order class members consistently
- Separate concerns into layers
- Keep classes small and focused
- Follow dependency direction (inward)
- Group related functionality
- Use meaningful package names
- Limit class dependencies
- Maintain consistent structure
