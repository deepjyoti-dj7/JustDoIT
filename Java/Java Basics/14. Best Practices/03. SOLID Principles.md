# ðŸŽ¯ SOLID Principles

## ðŸ“– Overview

**SOLID** is an acronym for five design principles that make software more maintainable, flexible, and scalable.

- **S**ingle Responsibility Principle
- **O**pen/Closed Principle
- **L**iskov Substitution Principle
- **I**nterface Segregation Principle
- **D**ependency Inversion Principle

---

## ðŸ’» Single Responsibility Principle (SRP)

**"A class should have only one reason to change."**

```java
// âŒ Bad - Multiple responsibilities
public class User {
    private String name;
    private String email;
    
    // User management
    public void save() {
        // Database logic
    }
    
    // Email functionality
    public void sendEmail(String message) {
        // Email sending logic
    }
    
    // Reporting
    public void generateReport() {
        // Report generation
    }
}

// âœ… Good - Single responsibility
public class User {
    private String name;
    private String email;
    
    // Getters and setters only
}

public class UserRepository {
    public void save(User user) {
        // Database logic
    }
}

public class EmailService {
    public void sendEmail(User user, String message) {
        // Email sending logic
    }
}

public class ReportGenerator {
    public void generateUserReport(User user) {
        // Report generation
    }
}
```

---

## ðŸ’» Open/Closed Principle (OCP)

**"Classes should be open for extension but closed for modification."**

```java
// âŒ Bad - Modifying class for new shapes
public class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return Math.PI * circle.radius * circle.radius;
        } else if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        }
        // Need to modify for each new shape
        return 0;
    }
}

// âœ… Good - Extend without modification
public interface Shape {
    double calculateArea();
}

public class Circle implements Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

public class Triangle implements Shape {
    private double base;
    private double height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

public class AreaCalculator {
    public double calculateArea(Shape shape) {
        return shape.calculateArea();
    }
}
```

---

## ðŸ’» Liskov Substitution Principle (LSP)

**"Subtypes must be substitutable for their base types."**

```java
// âŒ Bad - Violates LSP
public class Bird {
    public void fly() {
        System.out.println("Flying");
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}

// âœ… Good - Follows LSP
public abstract class Bird {
    public abstract void move();
}

public class Sparrow extends Bird {
    @Override
    public void move() {
        fly();
    }
    
    private void fly() {
        System.out.println("Flying");
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        swim();
    }
    
    private void swim() {
        System.out.println("Swimming");
    }
}

// Client code works with any Bird
public void makeBirdMove(Bird bird) {
    bird.move();  // Works for all birds
}
```

---

## ðŸ’» Interface Segregation Principle (ISP)

**"Clients should not be forced to depend on interfaces they don't use."**

```java
// âŒ Bad - Fat interface
public interface Worker {
    void work();
    void eat();
    void sleep();
}

public class Human implements Worker {
    @Override
    public void work() {
        System.out.println("Working");
    }
    
    @Override
    public void eat() {
        System.out.println("Eating");
    }
    
    @Override
    public void sleep() {
        System.out.println("Sleeping");
    }
}

public class Robot implements Worker {
    @Override
    public void work() {
        System.out.println("Working");
    }
    
    @Override
    public void eat() {
        // Robots don't eat - forced to implement
        throw new UnsupportedOperationException();
    }
    
    @Override
    public void sleep() {
        // Robots don't sleep - forced to implement
        throw new UnsupportedOperationException();
    }
}

// âœ… Good - Segregated interfaces
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public interface Sleepable {
    void sleep();
}

public class Human implements Workable, Eatable, Sleepable {
    @Override
    public void work() {
        System.out.println("Working");
    }
    
    @Override
    public void eat() {
        System.out.println("Eating");
    }
    
    @Override
    public void sleep() {
        System.out.println("Sleeping");
    }
}

public class Robot implements Workable {
    @Override
    public void work() {
        System.out.println("Working");
    }
    // Only implements what it needs
}
```

---

## ðŸ’» Dependency Inversion Principle (DIP)

**"Depend on abstractions, not concretions."**

```java
// âŒ Bad - High-level depends on low-level
public class MySQLDatabase {
    public void save(String data) {
        System.out.println("Saving to MySQL: " + data);
    }
}

public class UserService {
    private MySQLDatabase database = new MySQLDatabase();
    
    public void saveUser(String user) {
        database.save(user);  // Tightly coupled to MySQL
    }
}

// âœ… Good - Depend on abstraction
public interface Database {
    void save(String data);
}

public class MySQLDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("Saving to MySQL: " + data);
    }
}

public class MongoDBDatabase implements Database {
    @Override
    public void save(String data) {
        System.out.println("Saving to MongoDB: " + data);
    }
}

public class UserService {
    private final Database database;
    
    // Dependency injected
    public UserService(Database database) {
        this.database = database;
    }
    
    public void saveUser(String user) {
        database.save(user);  // Loosely coupled
    }
}

// Usage
public class Main {
    public static void main(String[] args) {
        // Can easily switch implementations
        Database db = new MySQLDatabase();
        UserService service = new UserService(db);
        service.saveUser("Alice");
        
        // Switch to MongoDB
        db = new MongoDBDatabase();
        service = new UserService(db);
        service.saveUser("Bob");
    }
}
```

---

## ðŸ’» Complete Example: Payment System

```java
// Applying all SOLID principles

// DIP - Abstraction
public interface PaymentProcessor {
    void processPayment(double amount);
}

// ISP - Specific interfaces
public interface Refundable {
    void refund(double amount);
}

public interface Trackable {
    String getTransactionId();
}

// OCP - Open for extension
public class CreditCardProcessor implements PaymentProcessor, Refundable, Trackable {
    private String transactionId;
    
    @Override
    public void processPayment(double amount) {
        transactionId = generateTransactionId();
        System.out.println("Processing credit card payment: $" + amount);
    }
    
    @Override
    public void refund(double amount) {
        System.out.println("Refunding: $" + amount);
    }
    
    @Override
    public String getTransactionId() {
        return transactionId;
    }
    
    private String generateTransactionId() {
        return "TXN-" + System.currentTimeMillis();
    }
}

public class PayPalProcessor implements PaymentProcessor, Refundable {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing PayPal payment: $" + amount);
    }
    
    @Override
    public void refund(double amount) {
        System.out.println("PayPal refund: $" + amount);
    }
}

// SRP - Single responsibility
public class OrderService {
    private final PaymentProcessor paymentProcessor;
    
    public OrderService(PaymentProcessor paymentProcessor) {
        this.paymentProcessor = paymentProcessor;
    }
    
    public void processOrder(double amount) {
        paymentProcessor.processPayment(amount);
    }
}

// LSP - Substitutable
public class PaymentFactory {
    public static PaymentProcessor getProcessor(String type) {
        switch (type) {
            case "credit":
                return new CreditCardProcessor();
            case "paypal":
                return new PayPalProcessor();
            default:
                throw new IllegalArgumentException("Unknown type");
        }
    }
}
```

---

## ðŸ“Š SOLID Benefits

| Principle | Benefit |
|-----------|---------|
| **SRP** | Easier to maintain and test |
| **OCP** | Add features without breaking code |
| **LSP** | Reliable polymorphism |
| **ISP** | Flexible interfaces |
| **DIP** | Loose coupling, easy testing |

---

## âš¡ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… Apply pragmatically | Don't over-engineer |
| âœ… Start with SRP | Foundation for others |
| âœ… Use dependency injection | For DIP |
| âœ… Prefer composition | Over inheritance |
| âœ… Keep interfaces small | ISP |
| âŒ Don't force patterns | Use when beneficial |
| âŒ Don't over-abstract | Balance simplicity |

---

## ðŸ’¡ Key Takeaways

- SRP: One class, one responsibility
- OCP: Extend behavior without modification
- LSP: Subtypes must be substitutable
- ISP: Many small interfaces > one large interface
- DIP: Depend on abstractions, not implementations
- SOLID improves maintainability and testability
- Apply principles pragmatically
- Use dependency injection for loose coupling
- Favor composition over inheritance
- Design for change
