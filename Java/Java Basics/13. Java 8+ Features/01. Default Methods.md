# üîß Default Methods

## üìñ Overview

**Default methods** (Java 8+) allow interfaces to have method implementations. This enables adding new methods to interfaces without breaking existing implementations.

**Syntax:**
```java
interface MyInterface {
    default void myMethod() {
        // Implementation
    }
}
```

---

## üíª Basic Default Method

```java
interface Vehicle {
    // Abstract method
    void start();
    
    // Default method with implementation
    default void stop() {
        System.out.println("Vehicle stopped");
    }
    
    default void honk() {
        System.out.println("Beep beep!");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started");
    }
    
    // Can optionally override default method
    @Override
    public void stop() {
        System.out.println("Car stopped with brakes");
    }
    
    // honk() inherited as-is
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike started");
    }
    
    // Using default methods as-is
}

public class DefaultMethodDemo {
    public static void main(String[] args) {
        Vehicle car = new Car();
        car.start();  // Car started
        car.stop();   // Car stopped with brakes
        car.honk();   // Beep beep!
        
        Vehicle bike = new Bike();
        bike.start(); // Bike started
        bike.stop();  // Vehicle stopped (default)
        bike.honk();  // Beep beep! (default)
    }
}
```

---

## üíª Static Methods in Interfaces

```java
interface MathUtils {
    // Static method in interface
    static int add(int a, int b) {
        return a + b;
    }
    
    static int multiply(int a, int b) {
        return a * b;
    }
    
    // Default method can call static method
    default int square(int n) {
        return multiply(n, n);
    }
}

public class StaticMethodDemo {
    public static void main(String[] args) {
        // Call static method directly on interface
        int sum = MathUtils.add(5, 3);
        int product = MathUtils.multiply(4, 7);
        
        System.out.println("Sum: " + sum);        // 8
        System.out.println("Product: " + product); // 28
    }
}
```

---

## üíª Multiple Inheritance - Diamond Problem

```java
interface A {
    default void display() {
        System.out.println("A display");
    }
}

interface B {
    default void display() {
        System.out.println("B display");
    }
}

// Must override to resolve conflict
class C implements A, B {
    @Override
    public void display() {
        // Option 1: Provide own implementation
        System.out.println("C display");
        
        // Option 2: Call specific interface method
        // A.super.display();
        // B.super.display();
    }
}

public class DiamondProblemDemo {
    public static void main(String[] args) {
        C obj = new C();
        obj.display();  // C display
    }
}
```

### Calling Super Interface Methods

```java
interface Left {
    default void print() {
        System.out.println("Left");
    }
}

interface Right {
    default void print() {
        System.out.println("Right");
    }
}

class Diamond implements Left, Right {
    @Override
    public void print() {
        // Call specific interface's default method
        System.out.print("Diamond: ");
        Left.super.print();
        Right.super.print();
    }
}

public class SuperCallDemo {
    public static void main(String[] args) {
        Diamond d = new Diamond();
        d.print();
        // Output:
        // Diamond: Left
        // Right
    }
}
```

---

## üíª Real-World Example: Collection Evolution

```java
// Java 8 added default methods to List interface
interface CustomList<E> {
    // Abstract methods
    E get(int index);
    int size();
    
    // Default method - backward compatible
    default void forEach(Consumer<E> action) {
        for (int i = 0; i < size(); i++) {
            action.accept(get(i));
        }
    }
    
    default boolean isEmpty() {
        return size() == 0;
    }
}

class SimpleList<E> implements CustomList<E> {
    private List<E> list = new ArrayList<>();
    
    public void add(E element) {
        list.add(element);
    }
    
    @Override
    public E get(int index) {
        return list.get(index);
    }
    
    @Override
    public int size() {
        return list.size();
    }
    
    // forEach and isEmpty inherited from interface
}

public class CollectionEvolutionDemo {
    public static void main(String[] args) {
        SimpleList<String> list = new SimpleList<>();
        list.add("Java");
        list.add("Python");
        list.add("JavaScript");
        
        // Using inherited default method
        list.forEach(System.out::println);
        
        System.out.println("Empty: " + list.isEmpty());
    }
}
```

---

## üíª Logger Example

```java
interface Logger {
    // Abstract method
    void log(String message);
    
    // Default methods for different log levels
    default void info(String message) {
        log("[INFO] " + message);
    }
    
    default void warning(String message) {
        log("[WARNING] " + message);
    }
    
    default void error(String message) {
        log("[ERROR] " + message);
    }
    
    // Static utility method
    static String timestamp() {
        return java.time.LocalDateTime.now().toString();
    }
}

class ConsoleLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println(Logger.timestamp() + " " + message);
    }
}

class FileLogger implements Logger {
    @Override
    public void log(String message) {
        // Write to file
        System.out.println("Writing to file: " + message);
    }
    
    // Override default method for custom behavior
    @Override
    public void error(String message) {
        log("[CRITICAL ERROR] " + message);
        // Send alert, etc.
    }
}

public class LoggerDemo {
    public static void main(String[] args) {
        Logger console = new ConsoleLogger();
        console.info("Application started");
        console.warning("Low memory");
        console.error("Connection failed");
        
        System.out.println();
        
        Logger file = new FileLogger();
        file.info("Data saved");
        file.error("Disk full");
    }
}
```

---

## üíª Plugin System Example

```java
interface Plugin {
    // Abstract methods
    String getName();
    void execute();
    
    // Default methods
    default void initialize() {
        System.out.println("Initializing " + getName());
    }
    
    default void cleanup() {
        System.out.println("Cleaning up " + getName());
    }
    
    default boolean isEnabled() {
        return true;
    }
}

class EmailPlugin implements Plugin {
    @Override
    public String getName() {
        return "Email Plugin";
    }
    
    @Override
    public void execute() {
        System.out.println("Sending email...");
    }
}

class DatabasePlugin implements Plugin {
    @Override
    public String getName() {
        return "Database Plugin";
    }
    
    @Override
    public void execute() {
        System.out.println("Querying database...");
    }
    
    @Override
    public void initialize() {
        System.out.println("Connecting to database...");
        Plugin.super.initialize();
    }
}

public class PluginSystemDemo {
    public static void main(String[] args) {
        List<Plugin> plugins = Arrays.asList(
            new EmailPlugin(),
            new DatabasePlugin()
        );
        
        for (Plugin plugin : plugins) {
            if (plugin.isEnabled()) {
                plugin.initialize();
                plugin.execute();
                plugin.cleanup();
                System.out.println();
            }
        }
    }
}
```

---

## üìä Default vs Static Methods

| Feature | Default Method | Static Method |
|---------|----------------|---------------|
| **Keyword** | `default` | `static` |
| **Invocation** | On instance | On interface |
| **Override** | Can be overridden | Cannot be overridden |
| **Inheritance** | Inherited by class | Not inherited |
| **Access** | `this` available | No instance access |

---

## üìä Resolution Rules

When a class inherits same method from multiple sources:

| Priority | Source | Rule |
|----------|--------|------|
| **1st** | Class method | Class wins over interface |
| **2nd** | Sub-interface | More specific interface wins |
| **3rd** | Explicit choice | Must override and choose |

---

## ‚ö° Benefits

| Benefit | Description |
|---------|-------------|
| ‚úÖ Backward compatibility | Add methods without breaking code |
| ‚úÖ Code reuse | Share implementation across classes |
| ‚úÖ Evolution | Evolve interfaces over time |
| ‚úÖ Multiple inheritance | Inherit from multiple interfaces |
| ‚úÖ Optional override | Use default or provide custom |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use for optional behavior | Provide sensible defaults |
| ‚úÖ Document clearly | Explain default behavior |
| ‚úÖ Keep simple | Don't add complex logic |
| ‚úÖ Resolve conflicts explicitly | Override when ambiguous |
| ‚úÖ Use static for utilities | Helper methods in interfaces |
| ‚ùå Don't abuse | Prefer composition when complex |
| ‚ùå Don't replace abstract classes | Different use cases |

---

## üéØ Common Use Cases

1. **API Evolution** - Add methods to existing interfaces
2. **Optional Behavior** - Provide default implementations
3. **Utility Methods** - Static helpers in interfaces
4. **Multiple Inheritance** - Combine behavior from multiple sources
5. **Backward Compatibility** - Extend functionality without breaking changes

---

## üîó Related Topics

- Lambda Expressions (Section 6)
- Functional Interfaces (Section 6)
- Stream API (uses default methods extensively)

---

## üí° Key Takeaways

- Default methods provide implementations in interfaces
- Enable backward-compatible API evolution
- Static methods in interfaces are utility methods
- Classes can override default methods
- Resolve conflicts explicitly when multiple defaults exist
- Use `InterfaceName.super.method()` to call specific default
- Default methods enabled Java 8 Collections API enhancement
- Cannot override static methods from interfaces
- Class methods win over interface default methods
- More specific interface wins over general interface
