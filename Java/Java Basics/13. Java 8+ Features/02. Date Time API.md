# üìÖ Date Time API

## üìñ Overview

**Java 8 Date Time API** (java.time package) provides immutable, thread-safe classes for date and time manipulation, replacing legacy Date and Calendar classes.

**Key Classes:**
- `LocalDate` - Date without time
- `LocalTime` - Time without date
- `LocalDateTime` - Date and time without timezone
- `ZonedDateTime` - Date and time with timezone
- `Instant` - Timestamp
- `Duration` - Time-based amount
- `Period` - Date-based amount

---

## üíª LocalDate

Date without time or timezone.

```java
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.ChronoUnit;

public class LocalDateDemo {
    public static void main(String[] args) {
        // Current date
        LocalDate today = LocalDate.now();
        System.out.println("Today: " + today);
        
        // Specific date
        LocalDate birthday = LocalDate.of(1990, Month.JANUARY, 15);
        System.out.println("Birthday: " + birthday);
        
        // Parse from string
        LocalDate parsed = LocalDate.parse("2024-12-25");
        System.out.println("Parsed: " + parsed);
        
        // Get components
        System.out.println("Year: " + today.getYear());
        System.out.println("Month: " + today.getMonth());
        System.out.println("Day: " + today.getDayOfMonth());
        System.out.println("Day of week: " + today.getDayOfWeek());
        
        // Manipulate dates
        LocalDate tomorrow = today.plusDays(1);
        LocalDate nextWeek = today.plusWeeks(1);
        LocalDate nextMonth = today.plusMonths(1);
        LocalDate lastYear = today.minusYears(1);
        
        System.out.println("Tomorrow: " + tomorrow);
        System.out.println("Next week: " + nextWeek);
        
        // Calculate difference
        long daysBetween = ChronoUnit.DAYS.between(birthday, today);
        System.out.println("Days since birthday: " + daysBetween);
        
        // Comparison
        System.out.println("Is today after birthday? " + today.isAfter(birthday));
        System.out.println("Is leap year? " + today.isLeapYear());
    }
}
```

---

## üíª LocalTime

Time without date or timezone.

```java
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;

public class LocalTimeDemo {
    public static void main(String[] args) {
        // Current time
        LocalTime now = LocalTime.now();
        System.out.println("Now: " + now);
        
        // Specific time
        LocalTime lunchTime = LocalTime.of(12, 30);
        System.out.println("Lunch: " + lunchTime);
        
        // With seconds and nanoseconds
        LocalTime precise = LocalTime.of(14, 30, 45, 123456789);
        System.out.println("Precise: " + precise);
        
        // Parse from string
        LocalTime parsed = LocalTime.parse("18:30:00");
        System.out.println("Parsed: " + parsed);
        
        // Get components
        System.out.println("Hour: " + now.getHour());
        System.out.println("Minute: " + now.getMinute());
        System.out.println("Second: " + now.getSecond());
        
        // Manipulate time
        LocalTime later = now.plusHours(2).plusMinutes(30);
        LocalTime earlier = now.minusHours(1);
        
        System.out.println("Later: " + later);
        System.out.println("Earlier: " + earlier);
        
        // Calculate difference
        long minutesBetween = ChronoUnit.MINUTES.between(lunchTime, now);
        System.out.println("Minutes since lunch: " + minutesBetween);
        
        // Comparison
        System.out.println("Is now after lunch? " + now.isAfter(lunchTime));
    }
}
```

---

## üíª LocalDateTime

Date and time without timezone.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LocalDateTimeDemo {
    public static void main(String[] args) {
        // Current date and time
        LocalDateTime now = LocalDateTime.now();
        System.out.println("Now: " + now);
        
        // Specific date and time
        LocalDateTime meeting = LocalDateTime.of(2024, 12, 25, 14, 30);
        System.out.println("Meeting: " + meeting);
        
        // From LocalDate and LocalTime
        LocalDate date = LocalDate.now();
        LocalTime time = LocalTime.of(10, 30);
        LocalDateTime combined = LocalDateTime.of(date, time);
        System.out.println("Combined: " + combined);
        
        // Parse from string
        LocalDateTime parsed = LocalDateTime.parse("2024-12-25T14:30:00");
        System.out.println("Parsed: " + parsed);
        
        // Formatting
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");
        String formatted = now.format(formatter);
        System.out.println("Formatted: " + formatted);
        
        // Manipulate
        LocalDateTime future = now.plusDays(7).plusHours(3);
        LocalDateTime past = now.minusMonths(2);
        
        System.out.println("Future: " + future);
        System.out.println("Past: " + past);
        
        // Extract components
        LocalDate dateOnly = now.toLocalDate();
        LocalTime timeOnly = now.toLocalTime();
        System.out.println("Date only: " + dateOnly);
        System.out.println("Time only: " + timeOnly);
    }
}
```

---

## üíª ZonedDateTime

Date and time with timezone.

```java
import java.time.ZonedDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class ZonedDateTimeDemo {
    public static void main(String[] args) {
        // Current with system timezone
        ZonedDateTime now = ZonedDateTime.now();
        System.out.println("Now: " + now);
        
        // Specific timezone
        ZonedDateTime tokyo = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        ZonedDateTime newYork = ZonedDateTime.now(ZoneId.of("America/New_York"));
        ZonedDateTime london = ZonedDateTime.now(ZoneId.of("Europe/London"));
        
        System.out.println("Tokyo: " + tokyo);
        System.out.println("New York: " + newYork);
        System.out.println("London: " + london);
        
        // Convert between timezones
        ZonedDateTime tokyoTime = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        ZonedDateTime nyTime = tokyoTime.withZoneSameInstant(ZoneId.of("America/New_York"));
        
        System.out.println("Tokyo: " + tokyoTime.format(DateTimeFormatter.ofPattern("HH:mm")));
        System.out.println("NY: " + nyTime.format(DateTimeFormatter.ofPattern("HH:mm")));
        
        // Get available zones
        System.out.println("\nSample timezones:");
        ZoneId.getAvailableZoneIds().stream()
            .filter(z -> z.startsWith("America/"))
            .limit(5)
            .forEach(System.out::println);
    }
}
```

---

## üíª Instant

Machine-readable timestamp (epoch seconds).

```java
import java.time.Instant;
import java.time.Duration;

public class InstantDemo {
    public static void main(String[] args) {
        // Current instant
        Instant now = Instant.now();
        System.out.println("Now: " + now);
        
        // Epoch time
        System.out.println("Epoch seconds: " + now.getEpochSecond());
        System.out.println("Epoch millis: " + now.toEpochMilli());
        
        // From epoch
        Instant fromEpoch = Instant.ofEpochSecond(1609459200);  // 2021-01-01
        System.out.println("From epoch: " + fromEpoch);
        
        // Manipulate
        Instant later = now.plusSeconds(3600);  // 1 hour later
        Instant earlier = now.minusSeconds(86400);  // 1 day earlier
        
        // Calculate duration
        Duration duration = Duration.between(earlier, now);
        System.out.println("Duration: " + duration.toHours() + " hours");
        
        // Comparison
        System.out.println("Is now after earlier? " + now.isAfter(earlier));
    }
}
```

---

## üíª Period & Duration

```java
import java.time.*;

public class PeriodDurationDemo {
    public static void main(String[] args) {
        // Period - date-based (years, months, days)
        LocalDate start = LocalDate.of(2020, 1, 1);
        LocalDate end = LocalDate.of(2024, 6, 15);
        
        Period period = Period.between(start, end);
        System.out.println("Period: " + period);
        System.out.println("Years: " + period.getYears());
        System.out.println("Months: " + period.getMonths());
        System.out.println("Days: " + period.getDays());
        
        // Create period
        Period twoWeeks = Period.ofWeeks(2);
        Period threeMonths = Period.ofMonths(3);
        
        LocalDate future = LocalDate.now().plus(threeMonths);
        System.out.println("3 months later: " + future);
        
        // Duration - time-based (hours, minutes, seconds)
        LocalTime startTime = LocalTime.of(9, 0);
        LocalTime endTime = LocalTime.of(17, 30);
        
        Duration duration = Duration.between(startTime, endTime);
        System.out.println("\nDuration: " + duration);
        System.out.println("Hours: " + duration.toHours());
        System.out.println("Minutes: " + duration.toMinutes());
        
        // Create duration
        Duration oneHour = Duration.ofHours(1);
        Duration thirtyMinutes = Duration.ofMinutes(30);
        
        LocalTime later = LocalTime.now().plus(oneHour);
        System.out.println("1 hour later: " + later);
    }
}
```

---

## üíª Formatting and Parsing

```java
import java.time.*;
import java.time.format.DateTimeFormatter;

public class FormattingDemo {
    public static void main(String[] args) {
        LocalDateTime now = LocalDateTime.now();
        
        // Predefined formatters
        System.out.println("ISO_DATE: " + now.format(DateTimeFormatter.ISO_DATE));
        System.out.println("ISO_TIME: " + now.format(DateTimeFormatter.ISO_TIME));
        System.out.println("ISO_DATE_TIME: " + now.format(DateTimeFormatter.ISO_DATE_TIME));
        
        // Custom patterns
        DateTimeFormatter custom1 = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
        DateTimeFormatter custom2 = DateTimeFormatter.ofPattern("EEEE, MMMM dd, yyyy");
        DateTimeFormatter custom3 = DateTimeFormatter.ofPattern("hh:mm a");
        
        System.out.println("\nCustom formats:");
        System.out.println(now.format(custom1));
        System.out.println(now.format(custom2));
        System.out.println(now.format(custom3));
        
        // Parsing
        String dateStr = "25/12/2024 14:30:00";
        LocalDateTime parsed = LocalDateTime.parse(dateStr, custom1);
        System.out.println("\nParsed: " + parsed);
    }
}
```

---

## üìä Classes Comparison

| Class | Contains | Timezone | Immutable |
|-------|----------|----------|-----------|
| **LocalDate** | Date only | No | Yes |
| **LocalTime** | Time only | No | Yes |
| **LocalDateTime** | Date + Time | No | Yes |
| **ZonedDateTime** | Date + Time | Yes | Yes |
| **Instant** | Timestamp | UTC | Yes |
| **Period** | Date-based amount | No | Yes |
| **Duration** | Time-based amount | No | Yes |

---

## üìä Common Patterns

| Pattern | Meaning | Example |
|---------|---------|---------|
| **yyyy** | Year | 2024 |
| **MM** | Month | 12 |
| **dd** | Day | 25 |
| **HH** | Hour (24h) | 14 |
| **mm** | Minute | 30 |
| **ss** | Second | 45 |
| **EEEE** | Day of week | Monday |
| **MMMM** | Month name | December |
| **a** | AM/PM | PM |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use LocalDate for dates | No time component |
| ‚úÖ Use LocalDateTime for timestamps | No timezone issues |
| ‚úÖ Use ZonedDateTime for global | Handle timezones |
| ‚úÖ Use Instant for machines | Epoch timestamp |
| ‚úÖ Immutable | All classes thread-safe |
| ‚úÖ Method chaining | Fluent API |
| ‚ùå Don't use Date/Calendar | Legacy, mutable |
| ‚ùå Don't modify | Create new instances |

---

## üéØ Migration from Legacy

```java
// Legacy (avoid)
Date date = new Date();
Calendar calendar = Calendar.getInstance();

// New API
LocalDate localDate = LocalDate.now();
LocalDateTime localDateTime = LocalDateTime.now();

// Convert legacy to new
Date legacyDate = new Date();
Instant instant = legacyDate.toInstant();
LocalDateTime ldt = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());

// Convert new to legacy
LocalDateTime newDateTime = LocalDateTime.now();
Instant instant2 = newDateTime.atZone(ZoneId.systemDefault()).toInstant();
Date legacyDate2 = Date.from(instant2);
```

---

## üîó Related Topics

- Stream API (functional operations on dates)
- Lambda Expressions (functional date operations)

---

## üí° Key Takeaways

- Java 8+ Date Time API is immutable and thread-safe
- LocalDate for dates, LocalTime for times, LocalDateTime for both
- ZonedDateTime handles timezones properly
- Instant for machine timestamps (epoch)
- Period for date-based amounts, Duration for time-based
- DateTimeFormatter for parsing and formatting
- All classes support method chaining
- Replaces legacy Date and Calendar
- No setter methods - return new instances
- Thread-safe by design
