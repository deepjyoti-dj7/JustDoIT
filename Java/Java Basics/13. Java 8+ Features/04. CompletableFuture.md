# ‚ö° CompletableFuture

## üìñ Overview

**CompletableFuture** (Java 8+) provides powerful asynchronous programming capabilities with completion stages, combining multiple async operations, and handling results/exceptions.

**Key Features:**
- Non-blocking asynchronous operations
- Composable async computations
- Exception handling
- Combining multiple futures

---

## üíª Basic CompletableFuture

```java
import java.util.concurrent.*;

public class BasicCompletableFutureDemo {
    public static void main(String[] args) throws Exception {
        // Create completed future
        CompletableFuture<String> future1 = CompletableFuture.completedFuture("Hello");
        System.out.println(future1.get());
        
        // Run async task (no return value)
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            System.out.println("Running in: " + Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Task completed");
        });
        
        future2.get();  // Wait for completion
        
        // Supply async task (with return value)
        CompletableFuture<Integer> future3 = CompletableFuture.supplyAsync(() -> {
            System.out.println("Calculating in: " + Thread.currentThread().getName());
            return 42;
        });
        
        System.out.println("Result: " + future3.get());
    }
}
```

---

## üíª Chaining with thenApply

```java
import java.util.concurrent.*;

public class ThenApplyDemo {
    public static void main(String[] args) throws Exception {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            System.out.println("Step 1: Fetching data");
            return "Java";
        })
        .thenApply(str -> {
            System.out.println("Step 2: Processing");
            return str.toUpperCase();
        })
        .thenApply(str -> {
            System.out.println("Step 3: Adding suffix");
            return str + " PROGRAMMING";
        });
        
        System.out.println("Result: " + future.get());
        // Output: JAVA PROGRAMMING
    }
}
```

---

## üíª thenAccept & thenRun

```java
import java.util.concurrent.*;

public class ThenAcceptRunDemo {
    public static void main(String[] args) throws Exception {
        // thenAccept - consumes result
        CompletableFuture<Void> future1 = CompletableFuture.supplyAsync(() -> {
            return "Hello World";
        })
        .thenAccept(result -> {
            System.out.println("Received: " + result);
        });
        
        future1.get();
        
        // thenRun - no access to result
        CompletableFuture<Void> future2 = CompletableFuture.supplyAsync(() -> {
            return 100;
        })
        .thenRun(() -> {
            System.out.println("Computation finished");
        });
        
        future2.get();
    }
}
```

---

## üíª Combining Futures

```java
import java.util.concurrent.*;

public class CombiningFuturesDemo {
    public static void main(String[] args) throws Exception {
        // thenCompose - sequential dependency
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "User:123")
            .thenCompose(userId -> getUserDetails(userId));
        
        System.out.println(future1.get());
        
        // thenCombine - parallel execution
        CompletableFuture<String> nameFuture = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Alice";
        });
        
        CompletableFuture<Integer> ageFuture = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return 25;
        });
        
        CompletableFuture<String> combined = nameFuture.thenCombine(ageFuture,
            (name, age) -> name + " is " + age + " years old");
        
        System.out.println(combined.get());
        
        // allOf - wait for all
        CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "Task1");
        CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "Task2");
        CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> "Task3");
        
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(f1, f2, f3);
        allFutures.get();
        System.out.println("All tasks completed");
        
        // anyOf - wait for any
        CompletableFuture<Object> anyFuture = CompletableFuture.anyOf(f1, f2, f3);
        System.out.println("First completed: " + anyFuture.get());
    }
    
    static CompletableFuture<String> getUserDetails(String userId) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return "Details for " + userId;
        });
    }
    
    static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üíª Exception Handling

```java
import java.util.concurrent.*;

public class ExceptionHandlingDemo {
    public static void main(String[] args) throws Exception {
        // exceptionally - handle exception
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Error occurred");
            }
            return "Success";
        })
        .exceptionally(ex -> {
            System.out.println("Exception: " + ex.getMessage());
            return "Default value";
        });
        
        System.out.println(future1.get());
        
        // handle - handle both result and exception
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Error");
            }
            return "Data";
        })
        .handle((result, ex) -> {
            if (ex != null) {
                return "Error: " + ex.getMessage();
            }
            return "Success: " + result;
        });
        
        System.out.println(future2.get());
        
        // whenComplete - side effect without modifying result
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            return "Result";
        })
        .whenComplete((result, ex) -> {
            if (ex != null) {
                System.out.println("Failed: " + ex);
            } else {
                System.out.println("Succeeded: " + result);
            }
        });
        
        System.out.println(future3.get());
    }
}
```

---

## üíª Real-World Example: E-Commerce

```java
import java.util.concurrent.*;
import java.util.*;

class Product {
    String name;
    double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
}

public class ECommerceDemo {
    public static void main(String[] args) throws Exception {
        String userId = "user123";
        String productId = "prod456";
        
        // Parallel execution
        CompletableFuture<Product> productFuture = getProductDetails(productId);
        CompletableFuture<List<String>> reviewsFuture = getProductReviews(productId);
        CompletableFuture<Double> priceFuture = getPrice(productId);
        CompletableFuture<Boolean> stockFuture = checkStock(productId);
        
        // Combine all results
        CompletableFuture<String> resultFuture = CompletableFuture.allOf(
            productFuture, reviewsFuture, priceFuture, stockFuture
        ).thenApply(v -> {
            try {
                Product product = productFuture.get();
                List<String> reviews = reviewsFuture.get();
                double price = priceFuture.get();
                boolean inStock = stockFuture.get();
                
                return String.format(
                    "Product: %s\nPrice: $%.2f\nIn Stock: %s\nReviews: %d",
                    product.name, price, inStock, reviews.size()
                );
            } catch (Exception e) {
                return "Error: " + e.getMessage();
            }
        });
        
        System.out.println(resultFuture.get());
    }
    
    static CompletableFuture<Product> getProductDetails(String id) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return new Product("Laptop", 999.99);
        });
    }
    
    static CompletableFuture<List<String>> getProductReviews(String id) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(800);
            return Arrays.asList("Great!", "Good value", "Fast delivery");
        });
    }
    
    static CompletableFuture<Double> getPrice(String id) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(500);
            return 999.99;
        });
    }
    
    static CompletableFuture<Boolean> checkStock(String id) {
        return CompletableFuture.supplyAsync(() -> {
            sleep(300);
            return true;
        });
    }
    
    static void sleep(int millis) {
        try { Thread.sleep(millis); } catch (InterruptedException e) {}
    }
}
```

---

## üìä Key Methods

| Method | Purpose |
|--------|----------|
| **supplyAsync** | Async task with return value |
| **runAsync** | Async task without return value |
| **thenApply** | Transform result |
| **thenAccept** | Consume result |
| **thenRun** | Run after completion |
| **thenCompose** | Sequential composition |
| **thenCombine** | Parallel combination |
| **allOf** | Wait for all futures |
| **anyOf** | Wait for any future |
| **exceptionally** | Handle exception |
| **handle** | Handle result and exception |
| **whenComplete** | Side effect on completion |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use supplyAsync for I/O | Non-blocking operations |
| ‚úÖ Handle exceptions | Use exceptionally or handle |
| ‚úÖ Avoid blocking | Use callbacks instead of get() |
| ‚úÖ Custom executor | For better control |
| ‚úÖ Combine parallel tasks | Use thenCombine or allOf |
| ‚ùå Don't block main thread | Use async callbacks |
| ‚ùå Don't forget error handling | Always handle exceptions |

---

## üí° Key Takeaways

- CompletableFuture enables async programming
- supplyAsync for tasks with return value
- runAsync for tasks without return value
- Chain operations with thenApply, thenAccept, thenRun
- Combine futures with thenCompose, thenCombine
- Wait for multiple with allOf, anyOf
- Handle exceptions with exceptionally, handle
- Non-blocking and composable
- Better than Future for async operations
