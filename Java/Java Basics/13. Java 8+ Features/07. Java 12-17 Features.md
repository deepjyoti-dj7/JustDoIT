# üéØ Java 12-17 Features

## üìñ Overview

**Java 12-17** introduced switch expressions, text blocks, records, sealed classes, pattern matching, and other modern features.

---

## üíª Switch Expressions (Java 14)

```java
public class SwitchExpressionsDemo {
    public static void main(String[] args) {
        // Old switch statement
        String day = "MONDAY";
        int numLetters;
        switch (day) {
            case "MONDAY":
            case "FRIDAY":
            case "SUNDAY":
                numLetters = 6;
                break;
            case "TUESDAY":
                numLetters = 7;
                break;
            default:
                numLetters = 0;
        }
        
        // New switch expression (Java 14+)
        int letters = switch (day) {
            case "MONDAY", "FRIDAY", "SUNDAY" -> 6;
            case "TUESDAY" -> 7;
            case "THURSDAY", "SATURDAY" -> 8;
            case "WEDNESDAY" -> 9;
            default -> 0;
        };
        
        System.out.println("Letters: " + letters);
        
        // With yield
        String result = switch (day) {
            case "MONDAY", "FRIDAY" -> "Start/End of week";
            case "SATURDAY", "SUNDAY" -> {
                System.out.println("Weekend!");
                yield "Relax";
            }
            default -> "Weekday";
        };
        
        System.out.println(result);
    }
}
```

---

## üíª Text Blocks (Java 15)

```java
public class TextBlocksDemo {
    public static void main(String[] args) {
        // Old way - escaped strings
        String json1 = "{\n" +
                      "  \"name\": \"Alice\",\n" +
                      "  \"age\": 25\n" +
                      "}";
        
        // Text blocks (Java 15+)
        String json2 = """
            {
              "name": "Alice",
              "age": 25
            }
            """;
        
        System.out.println(json2);
        
        // HTML example
        String html = """
            <html>
                <body>
                    <h1>Hello, World!</h1>
                    <p>Welcome to Java text blocks</p>
                </body>
            </html>
            """;
        
        System.out.println(html);
        
        // SQL query
        String query = """
            SELECT id, name, email
            FROM users
            WHERE status = 'active'
            ORDER BY created_at DESC
            """;
        
        System.out.println(query);
        
        // String interpolation with formatted
        String name = "Alice";
        int age = 25;
        String message = """
            Hello, %s!
            You are %d years old.
            """.formatted(name, age);
        
        System.out.println(message);
    }
}
```

---

## üíª Records (Java 16)

```java
// Record - immutable data carrier
record Person(String name, int age) {
    // Compact constructor for validation
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
    }
    
    // Custom methods allowed
    public boolean isAdult() {
        return age >= 18;
    }
}

// Record with implements
record Point(int x, int y) implements Comparable<Point> {
    @Override
    public int compareTo(Point other) {
        int result = Integer.compare(x, other.x);
        return result != 0 ? result : Integer.compare(y, other.y);
    }
}

public class RecordsDemo {
    public static void main(String[] args) {
        // Create record instance
        Person person = new Person("Alice", 25);
        
        // Automatic getters
        System.out.println("Name: " + person.name());
        System.out.println("Age: " + person.age());
        
        // Automatic toString
        System.out.println(person);  // Person[name=Alice, age=25]
        
        // Automatic equals and hashCode
        Person person2 = new Person("Alice", 25);
        System.out.println("Equal: " + person.equals(person2));  // true
        
        // Custom method
        System.out.println("Is adult: " + person.isAdult());
        
        // Records are immutable - no setters
        // person.setAge(26);  // Compilation error
        
        // Point example
        Point p1 = new Point(1, 2);
        Point p2 = new Point(3, 4);
        System.out.println("Compare: " + p1.compareTo(p2));
    }
}
```

---

## üíª Sealed Classes (Java 17)

```java
// Sealed class - restrict inheritance
sealed class Shape permits Circle, Rectangle, Triangle {
    abstract double area();
}

final class Circle extends Shape {
    private final double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}

final class Rectangle extends Shape {
    private final double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    double area() {
        return width * height;
    }
}

non-sealed class Triangle extends Shape {
    private final double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    double area() {
        return 0.5 * base * height;
    }
}

// This would cause compilation error:
// class Square extends Shape { }  // Not permitted

public class SealedClassesDemo {
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape rectangle = new Rectangle(4, 6);
        Shape triangle = new Triangle(3, 4);
        
        System.out.println("Circle area: " + circle.area());
        System.out.println("Rectangle area: " + rectangle.area());
        System.out.println("Triangle area: " + triangle.area());
    }
}
```

---

## üíª Pattern Matching for instanceof (Java 16)

```java
public class PatternMatchingDemo {
    public static void main(String[] args) {
        Object obj = "Hello, World!";
        
        // Old way
        if (obj instanceof String) {
            String str = (String) obj;
            System.out.println(str.toUpperCase());
        }
        
        // Pattern matching (Java 16+)
        if (obj instanceof String str) {
            System.out.println(str.toUpperCase());
        }
        
        // With logical operators
        if (obj instanceof String s && s.length() > 5) {
            System.out.println("Long string: " + s);
        }
        
        // Example: processing different types
        processObject("Java");
        processObject(42);
        processObject(3.14);
    }
    
    static void processObject(Object obj) {
        if (obj instanceof String s) {
            System.out.println("String of length: " + s.length());
        } else if (obj instanceof Integer i) {
            System.out.println("Integer: " + i * 2);
        } else if (obj instanceof Double d) {
            System.out.println("Double: " + d / 2);
        }
    }
}
```

---

## üíª Pattern Matching for switch (Java 17 Preview)

```java
public class SwitchPatternMatchingDemo {
    public static void main(String[] args) {
        processValue("Hello");
        processValue(42);
        processValue(3.14);
        processValue(null);
    }
    
    static void processValue(Object obj) {
        String result = switch (obj) {
            case String s -> "String: " + s.toUpperCase();
            case Integer i -> "Integer: " + (i * 2);
            case Double d -> "Double: " + (d / 2);
            case null -> "Null value";
            default -> "Unknown type";
        };
        
        System.out.println(result);
    }
    
    // With guards (Java 17+)
    static void processWithGuard(Object obj) {
        String result = switch (obj) {
            case String s && s.length() > 5 -> "Long string";
            case String s -> "Short string";
            case Integer i && i > 0 -> "Positive integer";
            case Integer i -> "Non-positive integer";
            default -> "Other";
        };
        
        System.out.println(result);
    }
}
```

---

## üíª Helpful NullPointerExceptions (Java 14)

```java
public class NullPointerDemo {
    static class Person {
        String name;
        Address address;
    }
    
    static class Address {
        String city;
    }
    
    public static void main(String[] args) {
        Person person = new Person();
        
        // Old NPE message (Java 13 and earlier):
        // NullPointerException
        
        // New NPE message (Java 14+):
        // NullPointerException: Cannot read field "city" because "person.address" is null
        try {
            String city = person.address.city;
        } catch (NullPointerException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

---

## üíª Stream.toList() (Java 16)

```java
import java.util.*;
import java.util.stream.*;

public class StreamToListDemo {
    public static void main(String[] args) {
        List<String> list = List.of("Java", "Python", "JavaScript", "C++");
        
        // Java 8-15
        List<String> result1 = list.stream()
            .filter(s -> s.startsWith("J"))
            .collect(Collectors.toList());
        
        // Java 16+ - simpler
        List<String> result2 = list.stream()
            .filter(s -> s.startsWith("J"))
            .toList();
        
        System.out.println(result2);  // [Java, JavaScript]
    }
}
```

---

## üìä Features by Version

| Version | Key Features |
|---------|--------------|
| **Java 12** | Switch expressions (preview), Compact number formatting |
| **Java 13** | Text blocks (preview), Switch expressions (preview) |
| **Java 14** | Switch expressions (standard), Records (preview), Helpful NPEs |
| **Java 15** | Text blocks (standard), Sealed classes (preview) |
| **Java 16** | Records (standard), Pattern matching for instanceof, Stream.toList() |
| **Java 17 LTS** | Sealed classes (standard), Pattern matching for switch (preview) |

---

## üìä Record vs Class

| Feature | Record | Class |
|---------|--------|-------|
| **Mutability** | Immutable | Mutable |
| **Boilerplate** | Auto-generated | Manual |
| **Constructor** | Canonical only | Multiple |
| **Inheritance** | Cannot extend | Can extend |
| **Use Case** | Data carriers | Complex objects |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use switch expressions | More concise |
| ‚úÖ Use text blocks | Multi-line strings |
| ‚úÖ Use records | Immutable data |
| ‚úÖ Use sealed classes | Controlled inheritance |
| ‚úÖ Use pattern matching | Avoid casting |
| ‚úÖ Use Stream.toList() | Simpler syntax |
| ‚ùå Don't modify records | They're immutable |
| ‚ùå Don't seal unnecessarily | Reduces flexibility |

---

## üí° Key Takeaways

- Switch expressions return values and use arrow syntax
- Text blocks simplify multi-line strings
- Records are immutable data carriers with auto-generated methods
- Sealed classes restrict which classes can extend/implement
- Pattern matching eliminates explicit casting
- Pattern matching for switch enables type-based branching
- Helpful NPEs pinpoint exact null field
- Stream.toList() simplifies collection from streams
- Java 17 is LTS (Long-Term Support)
- Modern features reduce boilerplate code
