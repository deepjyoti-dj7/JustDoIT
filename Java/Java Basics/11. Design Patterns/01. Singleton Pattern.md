# üîí Singleton Pattern

## üìñ Overview

**Singleton Pattern** ensures a class has only one instance and provides a global access point to it.

**When to Use:**
- Configuration managers
- Database connections
- Logging systems
- Thread pools
- Cache managers

---

## üíª Basic Singleton (Not Thread-Safe)

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // Private constructor
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**Problem:** Not thread-safe. Multiple threads can create multiple instances.

---

## üíª Eager Initialization

```java
public class EagerSingleton {
    private static final EagerSingleton instance = new EagerSingleton();
    
    private EagerSingleton() {
    }
    
    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

**Pros:** Thread-safe, simple  
**Cons:** Created at class loading time, even if never used

---

## üíª Synchronized Method (Thread-Safe)

```java
public class SynchronizedSingleton {
    private static SynchronizedSingleton instance;
    
    private SynchronizedSingleton() {
    }
    
    public static synchronized SynchronizedSingleton getInstance() {
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
```

**Pros:** Thread-safe, lazy initialization  
**Cons:** Performance overhead due to synchronization on every call

---

## üíª Double-Checked Locking (Best Practice)

```java
public class DoubleCheckedSingleton {
    private static volatile DoubleCheckedSingleton instance;
    
    private DoubleCheckedSingleton() {
    }
    
    public static DoubleCheckedSingleton getInstance() {
        if (instance == null) {  // First check (no locking)
            synchronized (DoubleCheckedSingleton.class) {
                if (instance == null) {  // Second check (with locking)
                    instance = new DoubleCheckedSingleton();
                }
            }
        }
        return instance;
    }
}
```

**Pros:** Thread-safe, lazy initialization, minimal locking overhead  
**Note:** `volatile` keyword is essential for proper working

---

## üíª Bill Pugh Singleton (Recommended)

```java
public class BillPughSingleton {
    
    private BillPughSingleton() {
    }
    
    // Static inner class - loaded only when getInstance() is called
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }
    
    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

**Pros:** Thread-safe, lazy initialization, no synchronization overhead  
**Best Practice:** This is the recommended approach

---

## üíª Enum Singleton (Most Robust)

```java
public enum EnumSingleton {
    INSTANCE;
    
    public void doSomething() {
        System.out.println("Doing something");
    }
}

// Usage
EnumSingleton.INSTANCE.doSomething();
```

**Pros:** 
- Thread-safe by default
- Prevents reflection attacks
- Serialization-safe
- Simplest implementation

**Best for:** When you need absolute guarantee of single instance

---

## üéØ Complete Examples

### Example 1: Database Connection Manager

```java
public class DatabaseConnection {
    private static volatile DatabaseConnection instance;
    private Connection connection;
    
    private DatabaseConnection() {
        // Initialize database connection
        try {
            connection = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/mydb", "user", "password"
            );
        } catch (SQLException e) {
            throw new RuntimeException("Failed to connect", e);
        }
    }
    
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            synchronized (DatabaseConnection.class) {
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }
    
    public Connection getConnection() {
        return connection;
    }
    
    public void executeQuery(String sql) {
        try (Statement stmt = connection.createStatement()) {
            ResultSet rs = stmt.executeQuery(sql);
            // Process results
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

// Usage
DatabaseConnection db = DatabaseConnection.getInstance();
db.executeQuery("SELECT * FROM users");
```

### Example 2: Configuration Manager

```java
public class ConfigManager {
    private static ConfigManager instance;
    private Properties properties;
    
    private ConfigManager() {
        properties = new Properties();
        loadProperties();
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    private void loadProperties() {
        try (InputStream input = getClass().getResourceAsStream("/config.properties")) {
            properties.load(input);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    public String getProperty(String key, String defaultValue) {
        return properties.getProperty(key, defaultValue);
    }
}

// Usage
ConfigManager config = ConfigManager.getInstance();
String dbUrl = config.getProperty("database.url");
int maxConnections = Integer.parseInt(config.getProperty("max.connections", "10"));
```

### Example 3: Logger

```java
public enum Logger {
    INSTANCE;
    
    private Logger() {
        // Initialize logger
    }
    
    public void log(String message) {
        System.out.println("[LOG] " + LocalDateTime.now() + ": " + message);
    }
    
    public void error(String message) {
        System.err.println("[ERROR] " + LocalDateTime.now() + ": " + message);
    }
    
    public void debug(String message) {
        if (isDebugEnabled()) {
            System.out.println("[DEBUG] " + LocalDateTime.now() + ": " + message);
        }
    }
    
    private boolean isDebugEnabled() {
        return Boolean.getBoolean("debug.enabled");
    }
}

// Usage
Logger.INSTANCE.log("Application started");
Logger.INSTANCE.error("Something went wrong");
Logger.INSTANCE.debug("Debug information");
```

### Example 4: Thread Pool Manager

```java
public class ThreadPoolManager {
    private static volatile ThreadPoolManager instance;
    private ExecutorService executorService;
    
    private ThreadPoolManager() {
        int processors = Runtime.getRuntime().availableProcessors();
        executorService = Executors.newFixedThreadPool(processors * 2);
    }
    
    public static ThreadPoolManager getInstance() {
        if (instance == null) {
            synchronized (ThreadPoolManager.class) {
                if (instance == null) {
                    instance = new ThreadPoolManager();
                }
            }
        }
        return instance;
    }
    
    public Future<?> submit(Runnable task) {
        return executorService.submit(task);
    }
    
    public <T> Future<T> submit(Callable<T> task) {
        return executorService.submit(task);
    }
    
    public void shutdown() {
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
        }
    }
}

// Usage
ThreadPoolManager pool = ThreadPoolManager.getInstance();
pool.submit(() -> System.out.println("Task executed"));
```

---

## üìä Singleton Implementation Comparison

| Implementation | Thread-Safe | Lazy Loading | Performance | Complexity |
|----------------|-------------|--------------|-------------|------------|
| Basic | ‚ùå | ‚úÖ | ‚≠ê‚≠ê‚≠ê | ‚≠ê |
| Eager | ‚úÖ | ‚ùå | ‚≠ê‚≠ê‚≠ê | ‚≠ê |
| Synchronized | ‚úÖ | ‚úÖ | ‚≠ê | ‚≠ê |
| Double-Checked | ‚úÖ | ‚úÖ | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Bill Pugh | ‚úÖ | ‚úÖ | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| Enum | ‚úÖ | ‚ùå | ‚≠ê‚≠ê‚≠ê | ‚≠ê |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Bill Pugh or Enum | Best implementations |
| ‚úÖ Make constructor private | Prevent instantiation |
| ‚úÖ Use volatile for DCL | Ensures visibility |
| ‚úÖ Consider enum for simplicity | Serialization-safe |
| ‚úÖ Prevent reflection attacks | Throw exception in constructor |
| ‚ùå Don't use basic singleton | Not thread-safe |
| ‚ùå Don't use synchronized method | Performance overhead |

---

## üéØ Preventing Singleton Violations

### Prevent Reflection Attack

```java
public class SafeSingleton {
    private static volatile SafeSingleton instance;
    
    private SafeSingleton() {
        if (instance != null) {
            throw new IllegalStateException("Instance already exists!");
        }
    }
    
    public static SafeSingleton getInstance() {
        if (instance == null) {
            synchronized (SafeSingleton.class) {
                if (instance == null) {
                    instance = new SafeSingleton();
                }
            }
        }
        return instance;
    }
}
```

### Prevent Serialization Issue

```java
public class SerializableSingleton implements Serializable {
    private static volatile SerializableSingleton instance;
    
    private SerializableSingleton() {
    }
    
    public static SerializableSingleton getInstance() {
        if (instance == null) {
            synchronized (SerializableSingleton.class) {
                if (instance == null) {
                    instance = new SerializableSingleton();
                }
            }
        }
        return instance;
    }
    
    // Prevent creating new instance during deserialization
    protected Object readResolve() {
        return getInstance();
    }
}
```

---

## üîó Related Topics

- [Factory Pattern](02.%20Factory%20Pattern.md)
- [Builder Pattern](03.%20Builder%20Pattern.md)

---

## üí° Key Takeaways

- Singleton ensures only one instance exists
- Use Bill Pugh (static inner class) for best practice
- Use Enum singleton for simplicity and robustness
- Double-checked locking requires `volatile`
- Prevent reflection attacks in constructor
- Implement `readResolve()` for serialization safety
- Enum singleton is immune to reflection and serialization attacks
- Avoid synchronized method approach (performance)
- Make constructor private always
- Consider lazy vs eager initialization based on use case
