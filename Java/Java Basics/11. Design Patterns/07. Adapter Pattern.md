# üîå Adapter Pattern

## üìñ Overview

**Adapter Pattern** converts the interface of a class into another interface clients expect. It allows classes with incompatible interfaces to work together.

**When to Use:**
- Integrate legacy code with new systems
- Use third-party libraries with different interfaces
- Make incompatible interfaces compatible
- Reuse existing classes

---

## üíª Class Adapter (Inheritance)

```java
// Target interface (what client expects)
interface MediaPlayer {
    void play(String filename);
}

// Adaptee (incompatible interface)
class AdvancedMediaPlayer {
    public void playMp4(String filename) {
        System.out.println("Playing MP4: " + filename);
    }
    
    public void playVlc(String filename) {
        System.out.println("Playing VLC: " + filename);
    }
}

// Class Adapter (using inheritance)
class MediaAdapter extends AdvancedMediaPlayer implements MediaPlayer {
    @Override
    public void play(String filename) {
        if (filename.endsWith(".mp4")) {
            playMp4(filename);
        } else if (filename.endsWith(".vlc")) {
            playVlc(filename);
        }
    }
}

// Usage
MediaPlayer player = new MediaAdapter();
player.play("movie.mp4");
player.play("song.vlc");
```

---

## üíª Object Adapter (Composition - Preferred)

```java
// Target interface
interface MediaPlayer {
    void play(String audioType, String filename);
}

// Adaptee
class Mp4Player {
    public void playMp4(String filename) {
        System.out.println("Playing MP4: " + filename);
    }
}

class VlcPlayer {
    public void playVlc(String filename) {
        System.out.println("Playing VLC: " + filename);
    }
}

// Object Adapter
class MediaAdapter implements MediaPlayer {
    private Mp4Player mp4Player;
    private VlcPlayer vlcPlayer;
    
    public MediaAdapter() {
        mp4Player = new Mp4Player();
        vlcPlayer = new VlcPlayer();
    }
    
    @Override
    public void play(String audioType, String filename) {
        if (audioType.equalsIgnoreCase("mp4")) {
            mp4Player.playMp4(filename);
        } else if (audioType.equalsIgnoreCase("vlc")) {
            vlcPlayer.playVlc(filename);
        } else {
            System.out.println("Invalid format: " + audioType);
        }
    }
}

// Client
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;
    
    @Override
    public void play(String audioType, String filename) {
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing MP3: " + filename);
        } else {
            mediaAdapter = new MediaAdapter();
            mediaAdapter.play(audioType, filename);
        }
    }
}

// Usage
MediaPlayer player = new AudioPlayer();
player.play("mp3", "song.mp3");
player.play("mp4", "video.mp4");
player.play("vlc", "movie.vlc");
```

---

## üéØ Complete Examples

### Example 1: Payment Gateway Adapter

```java
// Target interface
interface PaymentProcessor {
    void processPayment(double amount);
}

// Adaptee 1 - PayPal
class PayPalPayment {
    public void makePayment(double amount) {
        System.out.println("Processing $" + amount + " via PayPal");
    }
}

// Adaptee 2 - Stripe
class StripePayment {
    public void charge(double amount) {
        System.out.println("Charging $" + amount + " via Stripe");
    }
}

// Adaptee 3 - Square
class SquarePayment {
    public void pay(double dollars) {
        System.out.println("Paying $" + dollars + " via Square");
    }
}

// Adapters
class PayPalAdapter implements PaymentProcessor {
    private PayPalPayment paypal;
    
    public PayPalAdapter() {
        this.paypal = new PayPalPayment();
    }
    
    @Override
    public void processPayment(double amount) {
        paypal.makePayment(amount);
    }
}

class StripeAdapter implements PaymentProcessor {
    private StripePayment stripe;
    
    public StripeAdapter() {
        this.stripe = new StripePayment();
    }
    
    @Override
    public void processPayment(double amount) {
        stripe.charge(amount);
    }
}

class SquareAdapter implements PaymentProcessor {
    private SquarePayment square;
    
    public SquareAdapter() {
        this.square = new SquarePayment();
    }
    
    @Override
    public void processPayment(double amount) {
        square.pay(amount);
    }
}

// Client
class PaymentService {
    public void pay(PaymentProcessor processor, double amount) {
        processor.processPayment(amount);
    }
}

// Usage
PaymentService service = new PaymentService();

service.pay(new PayPalAdapter(), 100.0);
service.pay(new StripeAdapter(), 200.0);
service.pay(new SquareAdapter(), 150.0);
```

### Example 2: Temperature Converter

```java
// Target interface (Celsius)
interface TemperatureSensor {
    double getTemperature();
}

// Adaptee (Fahrenheit)
class FahrenheitSensor {
    public double getTemperatureInFahrenheit() {
        return 98.6; // Body temperature in Fahrenheit
    }
}

// Adapter
class TemperatureAdapter implements TemperatureSensor {
    private FahrenheitSensor fahrenheitSensor;
    
    public TemperatureAdapter(FahrenheitSensor sensor) {
        this.fahrenheitSensor = sensor;
    }
    
    @Override
    public double getTemperature() {
        double fahrenheit = fahrenheitSensor.getTemperatureInFahrenheit();
        // Convert F to C: (F - 32) √ó 5/9
        double celsius = (fahrenheit - 32) * 5.0 / 9.0;
        System.out.printf("%.1f¬∞F = %.1f¬∞C%n", fahrenheit, celsius);
        return celsius;
    }
}

// Usage
FahrenheitSensor fahrenheitSensor = new FahrenheitSensor();
TemperatureSensor celsiusSensor = new TemperatureAdapter(fahrenheitSensor);

double temp = celsiusSensor.getTemperature();
System.out.println("Temperature: " + temp + "¬∞C");
```

### Example 3: Database Adapter

```java
// Target interface
interface Database {
    void connect(String url);
    void executeQuery(String query);
    void disconnect();
}

// Adaptee 1 - MySQL
class MySQLDatabase {
    public void openConnection(String connectionString) {
        System.out.println("MySQL: Opening connection to " + connectionString);
    }
    
    public void runQuery(String sql) {
        System.out.println("MySQL: Executing " + sql);
    }
    
    public void closeConnection() {
        System.out.println("MySQL: Closing connection");
    }
}

// Adaptee 2 - MongoDB
class MongoDB {
    public void establishConnection(String uri) {
        System.out.println("MongoDB: Establishing connection to " + uri);
    }
    
    public void executeCommand(String command) {
        System.out.println("MongoDB: Executing " + command);
    }
    
    public void terminateConnection() {
        System.out.println("MongoDB: Terminating connection");
    }
}

// Adapters
class MySQLAdapter implements Database {
    private MySQLDatabase mysql;
    
    public MySQLAdapter() {
        this.mysql = new MySQLDatabase();
    }
    
    @Override
    public void connect(String url) {
        mysql.openConnection(url);
    }
    
    @Override
    public void executeQuery(String query) {
        mysql.runQuery(query);
    }
    
    @Override
    public void disconnect() {
        mysql.closeConnection();
    }
}

class MongoDBAdapter implements Database {
    private MongoDB mongodb;
    
    public MongoDBAdapter() {
        this.mongodb = new MongoDB();
    }
    
    @Override
    public void connect(String url) {
        mongodb.establishConnection(url);
    }
    
    @Override
    public void executeQuery(String query) {
        mongodb.executeCommand(query);
    }
    
    @Override
    public void disconnect() {
        mongodb.terminateConnection();
    }
}

// Client
class Application {
    private Database database;
    
    public Application(Database database) {
        this.database = database;
    }
    
    public void run() {
        database.connect("localhost:3306");
        database.executeQuery("SELECT * FROM users");
        database.disconnect();
    }
}

// Usage
Application app1 = new Application(new MySQLAdapter());
app1.run();

System.out.println();

Application app2 = new Application(new MongoDBAdapter());
app2.run();
```

### Example 4: Logging Adapter

```java
// Target interface
interface Logger {
    void log(String message);
}

// Adaptee 1 - Log4j
class Log4jLogger {
    public void logMessage(String msg, String level) {
        System.out.println("[Log4j] " + level + ": " + msg);
    }
}

// Adaptee 2 - Java Util Logging
class JavaLogger {
    public void writeLog(String message, int severity) {
        System.out.println("[JavaLogger] Severity " + severity + ": " + message);
    }
}

// Adapters
class Log4jAdapter implements Logger {
    private Log4jLogger log4j;
    
    public Log4jAdapter() {
        this.log4j = new Log4jLogger();
    }
    
    @Override
    public void log(String message) {
        log4j.logMessage(message, "INFO");
    }
}

class JavaLoggerAdapter implements Logger {
    private JavaLogger javaLogger;
    
    public JavaLoggerAdapter() {
        this.javaLogger = new JavaLogger();
    }
    
    @Override
    public void log(String message) {
        javaLogger.writeLog(message, 1);
    }
}

// Client
class Application {
    private Logger logger;
    
    public Application(Logger logger) {
        this.logger = logger;
    }
    
    public void doSomething() {
        logger.log("Application started");
        logger.log("Performing operation");
        logger.log("Application finished");
    }
}

// Usage
Application app1 = new Application(new Log4jAdapter());
app1.doSomething();

System.out.println();

Application app2 = new Application(new JavaLoggerAdapter());
app2.doSomething();
```

---

## üìä Adapter Pattern Types

| Type | Implementation | Java Support |
|------|----------------|--------------|
| Class Adapter | Inheritance | Single inheritance only |
| Object Adapter | Composition | Preferred (more flexible) |

---

## üìä Adapter Pattern Components

| Component | Role |
|-----------|------|
| Target | Interface client expects |
| Adapter | Converts Adaptee to Target |
| Adaptee | Existing incompatible interface |
| Client | Works with Target interface |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use Object Adapter | More flexible |
| ‚úÖ Adapt at boundaries | System edges |
| ‚úÖ Keep adapter simple | Single responsibility |
| ‚úÖ Document adaptations | Why and how |
| ‚úÖ Consider bidirectional | If needed |
| ‚ùå Don't adapt everything | Only when needed |
| ‚ùå Don't add new behavior | Just adapt |

---

## üéØ Adapter vs Other Patterns

| Pattern | Purpose |
|---------|---------|
| Adapter | Make incompatible interfaces work |
| Decorator | Add behavior to objects |
| Facade | Simplify complex subsystems |
| Proxy | Control access to objects |

---

## üéØ Real-World Examples

### Java Collections
```java
// Arrays.asList() adapts array to List interface
String[] array = {"A", "B", "C"};
List<String> list = Arrays.asList(array);
```

### Java I/O
```java
// InputStreamReader adapts InputStream to Reader
InputStream input = new FileInputStream("file.txt");
Reader reader = new InputStreamReader(input);
```

---

## üîó Related Topics

- [Decorator Pattern](06.%20Decorator%20Pattern.md)
- [Facade Pattern (similar concept)]
- [Proxy Pattern](../10.%20Reflection%20API/05.%20Dynamic%20Proxies.md)

---

## üí° Key Takeaways

- Adapter makes incompatible interfaces compatible
- Two types: Class Adapter (inheritance) and Object Adapter (composition)
- Object Adapter preferred in Java (single inheritance limitation)
- Used to integrate legacy code or third-party libraries
- Adapter doesn't add new functionality, just converts interface
- Client works with target interface, unaware of adaptation
- Keep adapters simple and focused
- Common in Java APIs (Arrays.asList, InputStreamReader)
- Follows Open/Closed Principle
- Essential for system integration and refactoring
