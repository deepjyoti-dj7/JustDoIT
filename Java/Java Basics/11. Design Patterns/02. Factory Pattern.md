# üè≠ Factory Pattern

## üìñ Overview

**Factory Pattern** provides an interface for creating objects without specifying their exact classes. It encapsulates object creation logic.

**Types:**
1. **Simple Factory** - Not a true pattern, but commonly used
2. **Factory Method** - Define interface, let subclasses decide
3. **Abstract Factory** - Create families of related objects

---

## üíª Simple Factory

```java
// Product
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

class Triangle implements Shape {
    public void draw() {
        System.out.println("Drawing Triangle");
    }
}

// Simple Factory
class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type.toLowerCase()) {
            case "circle":
                return new Circle();
            case "rectangle":
                return new Rectangle();
            case "triangle":
                return new Triangle();
            default:
                throw new IllegalArgumentException("Unknown shape: " + type);
        }
    }
}

// Usage
Shape circle = ShapeFactory.createShape("circle");
circle.draw();
```

---

## üíª Factory Method Pattern

```java
// Product
interface Vehicle {
    void drive();
}

class Car implements Vehicle {
    public void drive() {
        System.out.println("Driving a car");
    }
}

class Bike implements Vehicle {
    public void drive() {
        System.out.println("Riding a bike");
    }
}

// Creator (Factory interface)
abstract class VehicleFactory {
    // Factory method
    public abstract Vehicle createVehicle();
    
    // Template method using factory method
    public void deliverVehicle() {
        Vehicle vehicle = createVehicle();
        System.out.println("Vehicle prepared");
        vehicle.drive();
    }
}

// Concrete Creators
class CarFactory extends VehicleFactory {
    @Override
    public Vehicle createVehicle() {
        return new Car();
    }
}

class BikeFactory extends VehicleFactory {
    @Override
    public Vehicle createVehicle() {
        return new Bike();
    }
}

// Usage
VehicleFactory factory = new CarFactory();
factory.deliverVehicle();

factory = new BikeFactory();
factory.deliverVehicle();
```

---

## üíª Abstract Factory Pattern

```java
// Abstract Products
interface Button {
    void render();
}

interface Checkbox {
    void render();
}

// Concrete Products - Windows
class WindowsButton implements Button {
    public void render() {
        System.out.println("Rendering Windows Button");
    }
}

class WindowsCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering Windows Checkbox");
    }
}

// Concrete Products - Mac
class MacButton implements Button {
    public void render() {
        System.out.println("Rendering Mac Button");
    }
}

class MacCheckbox implements Checkbox {
    public void render() {
        System.out.println("Rendering Mac Checkbox");
    }
}

// Abstract Factory
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Concrete Factories
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Client
class Application {
    private Button button;
    private Checkbox checkbox;
    
    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }
    
    public void render() {
        button.render();
        checkbox.render();
    }
}

// Usage
String os = System.getProperty("os.name").toLowerCase();
GUIFactory factory;

if (os.contains("windows")) {
    factory = new WindowsFactory();
} else {
    factory = new MacFactory();
}

Application app = new Application(factory);
app.render();
```

---

## üéØ Complete Examples

### Example 1: Database Connection Factory

```java
interface DatabaseConnection {
    void connect();
    void disconnect();
}

class MySQLConnection implements DatabaseConnection {
    public void connect() {
        System.out.println("Connected to MySQL");
    }
    
    public void disconnect() {
        System.out.println("Disconnected from MySQL");
    }
}

class PostgreSQLConnection implements DatabaseConnection {
    public void connect() {
        System.out.println("Connected to PostgreSQL");
    }
    
    public void disconnect() {
        System.out.println("Disconnected from PostgreSQL");
    }
}

class MongoDBConnection implements DatabaseConnection {
    public void connect() {
        System.out.println("Connected to MongoDB");
    }
    
    public void disconnect() {
        System.out.println("Disconnected from MongoDB");
    }
}

class DatabaseFactory {
    public static DatabaseConnection getConnection(String dbType) {
        switch (dbType.toLowerCase()) {
            case "mysql":
                return new MySQLConnection();
            case "postgresql":
                return new PostgreSQLConnection();
            case "mongodb":
                return new MongoDBConnection();
            default:
                throw new IllegalArgumentException("Unknown database: " + dbType);
        }
    }
}

// Usage
DatabaseConnection db = DatabaseFactory.getConnection("mysql");
db.connect();
db.disconnect();
```

### Example 2: Notification Factory

```java
interface Notification {
    void send(String message);
}

class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

class SMSNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}

class PushNotification implements Notification {
    public void send(String message) {
        System.out.println("Push: " + message);
    }
}

abstract class NotificationFactory {
    public abstract Notification createNotification();
    
    public void notifyUser(String message) {
        Notification notification = createNotification();
        notification.send(message);
    }
}

class EmailNotificationFactory extends NotificationFactory {
    public Notification createNotification() {
        return new EmailNotification();
    }
}

class SMSNotificationFactory extends NotificationFactory {
    public Notification createNotification() {
        return new SMSNotification();
    }
}

// Usage
NotificationFactory factory = new EmailNotificationFactory();
factory.notifyUser("Hello World!");

factory = new SMSNotificationFactory();
factory.notifyUser("Hello World!");
```

### Example 3: Document Factory (Abstract Factory)

```java
// Abstract Products
interface DocumentParser {
    void parse(String content);
}

interface DocumentWriter {
    void write(String content);
}

// PDF Products
class PDFParser implements DocumentParser {
    public void parse(String content) {
        System.out.println("Parsing PDF: " + content);
    }
}

class PDFWriter implements DocumentWriter {
    public void write(String content) {
        System.out.println("Writing PDF: " + content);
    }
}

// Word Products
class WordParser implements DocumentParser {
    public void parse(String content) {
        System.out.println("Parsing Word: " + content);
    }
}

class WordWriter implements DocumentWriter {
    public void write(String content) {
        System.out.println("Writing Word: " + content);
    }
}

// Abstract Factory
interface DocumentFactory {
    DocumentParser createParser();
    DocumentWriter createWriter();
}

// Concrete Factories
class PDFFactory implements DocumentFactory {
    public DocumentParser createParser() {
        return new PDFParser();
    }
    
    public DocumentWriter createWriter() {
        return new PDFWriter();
    }
}

class WordFactory implements DocumentFactory {
    public DocumentParser createParser() {
        return new WordParser();
    }
    
    public DocumentWriter createWriter() {
        return new WordWriter();
    }
}

// Client
class DocumentProcessor {
    private DocumentFactory factory;
    
    public DocumentProcessor(DocumentFactory factory) {
        this.factory = factory;
    }
    
    public void processDocument(String content) {
        DocumentParser parser = factory.createParser();
        DocumentWriter writer = factory.createWriter();
        
        parser.parse(content);
        writer.write(content);
    }
}

// Usage
DocumentFactory factory = new PDFFactory();
DocumentProcessor processor = new DocumentProcessor(factory);
processor.processDocument("Hello World");
```

---

## üìä Factory Pattern Comparison

| Pattern | Purpose | Use Case |
|---------|---------|----------|
| Simple Factory | Create objects based on parameter | Simple object creation |
| Factory Method | Let subclasses decide which class to instantiate | Single product families |
| Abstract Factory | Create families of related objects | Multiple product families |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use for complex object creation | Hide creation logic |
| ‚úÖ Follow Open/Closed Principle | Easy to add new types |
| ‚úÖ Return interfaces/abstract classes | Loose coupling |
| ‚úÖ Use Abstract Factory for families | Related objects |
| ‚úÖ Combine with Singleton | Factory as singleton |
| ‚ùå Don't overuse | Simple objects don't need factory |
| ‚ùå Don't expose concrete classes | Return abstractions |

---

## üéØ When to Use

### Simple Factory
- Few product types
- Creation logic is simple
- No need for subclassing

### Factory Method
- Class delegates instantiation to subclasses
- Need flexibility in object creation
- Single product type with variations

### Abstract Factory
- System should be independent of product creation
- Family of related products
- Need to ensure products are used together

---

## üîó Related Topics

- [Singleton Pattern](01.%20Singleton%20Pattern.md)
- [Builder Pattern](03.%20Builder%20Pattern.md)
- [Strategy Pattern](05.%20Strategy%20Pattern.md)

---

## üí° Key Takeaways

- Factory patterns encapsulate object creation
- Simple Factory: static method creates objects
- Factory Method: subclasses decide what to create
- Abstract Factory: creates families of related objects
- Return interfaces/abstract classes, not concrete types
- Use for complex creation logic
- Makes code more maintainable and extensible
- Follows Open/Closed Principle
- Loose coupling between client and concrete classes
- Combine with other patterns (Singleton, Strategy)
