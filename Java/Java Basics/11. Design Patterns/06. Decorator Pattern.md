# üé® Decorator Pattern

## üìñ Overview

**Decorator Pattern** attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.

**When to Use:**
- Add responsibilities to objects dynamically
- Avoid explosion of subclasses
- Responsibilities can be withdrawn
- Extension by subclassing is impractical

---

## üíª Basic Decorator Pattern

```java
// Component interface
interface Coffee {
    String getDescription();
    double getCost();
}

// Concrete Component
class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

// Decorator base class
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription();
    }
    
    @Override
    public double getCost() {
        return coffee.getCost();
    }
}

// Concrete Decorators
class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

class WhippedCreamDecorator extends CoffeeDecorator {
    public WhippedCreamDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Whipped Cream";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.7;
    }
}

// Usage
Coffee coffee = new SimpleCoffee();
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new MilkDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new WhippedCreamDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
```

---

## üéØ Complete Examples

### Example 1: Text Formatting

```java
interface Text {
    String getContent();
}

class PlainText implements Text {
    private String content;
    
    public PlainText(String content) {
        this.content = content;
    }
    
    @Override
    public String getContent() {
        return content;
    }
}

abstract class TextDecorator implements Text {
    protected Text text;
    
    public TextDecorator(Text text) {
        this.text = text;
    }
    
    @Override
    public String getContent() {
        return text.getContent();
    }
}

class BoldDecorator extends TextDecorator {
    public BoldDecorator(Text text) {
        super(text);
    }
    
    @Override
    public String getContent() {
        return "<b>" + text.getContent() + "</b>";
    }
}

class ItalicDecorator extends TextDecorator {
    public ItalicDecorator(Text text) {
        super(text);
    }
    
    @Override
    public String getContent() {
        return "<i>" + text.getContent() + "</i>";
    }
}

class UnderlineDecorator extends TextDecorator {
    public UnderlineDecorator(Text text) {
        super(text);
    }
    
    @Override
    public String getContent() {
        return "<u>" + text.getContent() + "</u>";
    }
}

// Usage
Text text = new PlainText("Hello World");
System.out.println(text.getContent());

text = new BoldDecorator(text);
System.out.println(text.getContent());

text = new ItalicDecorator(text);
System.out.println(text.getContent());

text = new UnderlineDecorator(text);
System.out.println(text.getContent());
// Output: <u><i><b>Hello World</b></i></u>
```

### Example 2: Data Source Decorator

```java
interface DataSource {
    void writeData(String data);
    String readData();
}

class FileDataSource implements DataSource {
    private String filename;
    private String data;
    
    public FileDataSource(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void writeData(String data) {
        this.data = data;
        System.out.println("Writing to file: " + data);
    }
    
    @Override
    public String readData() {
        System.out.println("Reading from file");
        return data;
    }
}

abstract class DataSourceDecorator implements DataSource {
    protected DataSource wrapper;
    
    public DataSourceDecorator(DataSource source) {
        this.wrapper = source;
    }
    
    @Override
    public void writeData(String data) {
        wrapper.writeData(data);
    }
    
    @Override
    public String readData() {
        return wrapper.readData();
    }
}

class EncryptionDecorator extends DataSourceDecorator {
    public EncryptionDecorator(DataSource source) {
        super(source);
    }
    
    @Override
    public void writeData(String data) {
        String encrypted = encrypt(data);
        super.writeData(encrypted);
    }
    
    @Override
    public String readData() {
        String data = super.readData();
        return decrypt(data);
    }
    
    private String encrypt(String data) {
        System.out.println("Encrypting data");
        return "encrypted(" + data + ")";
    }
    
    private String decrypt(String data) {
        System.out.println("Decrypting data");
        return data.replace("encrypted(", "").replace(")", "");
    }
}

class CompressionDecorator extends DataSourceDecorator {
    public CompressionDecorator(DataSource source) {
        super(source);
    }
    
    @Override
    public void writeData(String data) {
        String compressed = compress(data);
        super.writeData(compressed);
    }
    
    @Override
    public String readData() {
        String data = super.readData();
        return decompress(data);
    }
    
    private String compress(String data) {
        System.out.println("Compressing data");
        return "compressed(" + data + ")";
    }
    
    private String decompress(String data) {
        System.out.println("Decompressing data");
        return data.replace("compressed(", "").replace(")", "");
    }
}

// Usage
DataSource source = new FileDataSource("data.txt");
source.writeData("Hello World");

source = new EncryptionDecorator(source);
source.writeData("Sensitive Data");

source = new CompressionDecorator(source);
source.writeData("Large Data");

String data = source.readData();
System.out.println("Final data: " + data);
```

### Example 3: Pizza Toppings

```java
interface Pizza {
    String getDescription();
    double getPrice();
}

class PlainPizza implements Pizza {
    @Override
    public String getDescription() {
        return "Plain Pizza";
    }
    
    @Override
    public double getPrice() {
        return 8.0;
    }
}

abstract class ToppingDecorator implements Pizza {
    protected Pizza pizza;
    
    public ToppingDecorator(Pizza pizza) {
        this.pizza = pizza;
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription();
    }
    
    @Override
    public double getPrice() {
        return pizza.getPrice();
    }
}

class CheeseTopping extends ToppingDecorator {
    public CheeseTopping(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + " + Cheese";
    }
    
    @Override
    public double getPrice() {
        return pizza.getPrice() + 1.5;
    }
}

class PepperoniTopping extends ToppingDecorator {
    public PepperoniTopping(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + " + Pepperoni";
    }
    
    @Override
    public double getPrice() {
        return pizza.getPrice() + 2.0;
    }
}

class MushroomTopping extends ToppingDecorator {
    public MushroomTopping(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + " + Mushroom";
    }
    
    @Override
    public double getPrice() {
        return pizza.getPrice() + 1.0;
    }
}

class OliveTopping extends ToppingDecorator {
    public OliveTopping(Pizza pizza) {
        super(pizza);
    }
    
    @Override
    public String getDescription() {
        return pizza.getDescription() + " + Olive";
    }
    
    @Override
    public double getPrice() {
        return pizza.getPrice() + 0.8;
    }
}

// Usage
Pizza pizza = new PlainPizza();
System.out.println(pizza.getDescription() + " = $" + pizza.getPrice());

pizza = new CheeseTopping(pizza);
pizza = new PepperoniTopping(pizza);
pizza = new MushroomTopping(pizza);
pizza = new OliveTopping(pizza);

System.out.println(pizza.getDescription() + " = $" + pizza.getPrice());
```

### Example 4: Notification System

```java
interface Notifier {
    void send(String message);
}

class EmailNotifier implements Notifier {
    @Override
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

abstract class NotifierDecorator implements Notifier {
    protected Notifier notifier;
    
    public NotifierDecorator(Notifier notifier) {
        this.notifier = notifier;
    }
    
    @Override
    public void send(String message) {
        notifier.send(message);
    }
}

class SMSDecorator extends NotifierDecorator {
    public SMSDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("SMS: " + message);
    }
}

class SlackDecorator extends NotifierDecorator {
    public SlackDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Slack: " + message);
    }
}

class FacebookDecorator extends NotifierDecorator {
    public FacebookDecorator(Notifier notifier) {
        super(notifier);
    }
    
    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Facebook: " + message);
    }
}

// Usage
Notifier notifier = new EmailNotifier();
notifier.send("Hello!");

notifier = new SMSDecorator(notifier);
notifier = new SlackDecorator(notifier);
notifier = new FacebookDecorator(notifier);

notifier.send("Important notification!");
// Sends via Email, SMS, Slack, and Facebook
```

---

## üìä Decorator Pattern Components

| Component | Role |
|-----------|------|
| Component | Interface for objects |
| ConcreteComponent | Base object |
| Decorator | Wraps Component |
| ConcreteDecorator | Adds responsibilities |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use same interface | Component and Decorator |
| ‚úÖ Keep decorators simple | Single responsibility |
| ‚úÖ Make decorators composable | Stack multiple |
| ‚úÖ Delegate to wrapped object | Don't duplicate logic |
| ‚úÖ Consider order of decoration | May affect behavior |
| ‚ùå Don't use for type checking | instanceof won't work well |
| ‚ùå Don't overuse | Can become complex |

---

## üéØ Decorator vs Inheritance

| Aspect | Inheritance | Decorator |
|--------|-------------|-----------|
| Flexibility | Compile-time | Runtime |
| Combinations | Class explosion | Dynamic composition |
| Modification | Subclass | Wrap object |
| Multiple behaviors | Multiple inheritance | Multiple decorators |

---

## üéØ Java API Examples

```java
// Java I/O uses Decorator Pattern
InputStream input = new FileInputStream("file.txt");
input = new BufferedInputStream(input);
input = new GZIPInputStream(input);

// Multiple decorators stacked
```

---

## üîó Related Topics

- [Strategy Pattern](05.%20Strategy%20Pattern.md)
- [Adapter Pattern](07.%20Adapter%20Pattern.md)
- [Proxy Pattern](05.%20Dynamic%20Proxies.md)

---

## üí° Key Takeaways

- Decorator adds behavior dynamically
- Alternative to subclassing
- Wraps object with same interface
- Can stack multiple decorators
- Each decorator adds one responsibility
- Order of decoration may matter
- Java I/O classes use decorator pattern
- More flexible than static inheritance
- Follows Open/Closed Principle
- Can lead to many small classes
