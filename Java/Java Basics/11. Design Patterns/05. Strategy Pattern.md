# ğŸ¯ Strategy Pattern

## ğŸ“– Overview

**Strategy Pattern** defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

**When to Use:**
- Multiple algorithms for a task
- Avoid conditional statements
- Runtime algorithm selection
- Similar classes differ only in behavior

---

## ğŸ’» Basic Strategy Pattern

```java
// Strategy interface
interface PaymentStrategy {
    void pay(int amount);
}

// Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String name;
    
    public CreditCardPayment(String cardNumber, String name) {
        this.cardNumber = cardNumber;
        this.name = name;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid $" + amount + " using Credit Card");
    }
}

class PayPalPayment implements PaymentStrategy {
    private String email;
    
    public PayPalPayment(String email) {
        this.email = email;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid $" + amount + " using PayPal");
    }
}

class BitcoinPayment implements PaymentStrategy {
    private String walletAddress;
    
    public BitcoinPayment(String walletAddress) {
        this.walletAddress = walletAddress;
    }
    
    @Override
    public void pay(int amount) {
        System.out.println("Paid $" + amount + " using Bitcoin");
    }
}

// Context
class ShoppingCart {
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }
    
    public void checkout(int amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment strategy not set");
        }
        paymentStrategy.pay(amount);
    }
}

// Usage
ShoppingCart cart = new ShoppingCart();

cart.setPaymentStrategy(new CreditCardPayment("1234-5678-9012", "John"));
cart.checkout(100);

cart.setPaymentStrategy(new PayPalPayment("john@example.com"));
cart.checkout(200);

cart.setPaymentStrategy(new BitcoinPayment("1A2B3C4D5E"));
cart.checkout(300);
```

---

## ğŸ¯ Complete Examples

### Example 1: Sorting Strategies

```java
interface SortStrategy {
    void sort(int[] array);
}

class BubbleSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Sorting using Bubble Sort");
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
}

class QuickSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Sorting using Quick Sort");
        quickSort(array, 0, array.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
}

class MergeSort implements SortStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Sorting using Merge Sort");
        mergeSort(array, 0, array.length - 1);
    }
    
    private void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    
    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int[n2];
        
        System.arraycopy(arr, left, L, 0, n1);
        System.arraycopy(arr, mid + 1, R, 0, n2);
        
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k++] = L[i++];
            } else {
                arr[k++] = R[j++];
            }
        }
        while (i < n1) arr[k++] = L[i++];
        while (j < n2) arr[k++] = R[j++];
    }
}

class Sorter {
    private SortStrategy strategy;
    
    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sort(int[] array) {
        strategy.sort(array);
    }
}

// Usage
int[] data = {64, 34, 25, 12, 22, 11, 90};
Sorter sorter = new Sorter();

sorter.setStrategy(new BubbleSort());
sorter.sort(data.clone());

sorter.setStrategy(new QuickSort());
sorter.sort(data.clone());

sorter.setStrategy(new MergeSort());
sorter.sort(data.clone());
```

### Example 2: Compression Strategies

```java
interface CompressionStrategy {
    void compress(String fileName);
}

class ZipCompression implements CompressionStrategy {
    @Override
    public void compress(String fileName) {
        System.out.println("Compressing " + fileName + " using ZIP algorithm");
    }
}

class RarCompression implements CompressionStrategy {
    @Override
    public void compress(String fileName) {
        System.out.println("Compressing " + fileName + " using RAR algorithm");
    }
}

class GzipCompression implements CompressionStrategy {
    @Override
    public void compress(String fileName) {
        System.out.println("Compressing " + fileName + " using GZIP algorithm");
    }
}

class CompressionContext {
    private CompressionStrategy strategy;
    
    public CompressionContext(CompressionStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void setStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void createArchive(String fileName) {
        strategy.compress(fileName);
    }
}

// Usage
CompressionContext context = new CompressionContext(new ZipCompression());
context.createArchive("document.txt");

context.setStrategy(new RarCompression());
context.createArchive("photo.jpg");

context.setStrategy(new GzipCompression());
context.createArchive("data.csv");
```

### Example 3: Navigation Strategies

```java
interface RouteStrategy {
    void buildRoute(String start, String end);
}

class RoadStrategy implements RouteStrategy {
    @Override
    public void buildRoute(String start, String end) {
        System.out.println("Building road route from " + start + " to " + end);
        System.out.println("Taking highways and streets");
    }
}

class WalkingStrategy implements RouteStrategy {
    @Override
    public void buildRoute(String start, String end) {
        System.out.println("Building walking route from " + start + " to " + end);
        System.out.println("Using pedestrian paths and shortcuts");
    }
}

class PublicTransportStrategy implements RouteStrategy {
    @Override
    public void buildRoute(String start, String end) {
        System.out.println("Building public transport route from " + start + " to " + end);
        System.out.println("Using buses, trains, and metro");
    }
}

class Navigator {
    private RouteStrategy strategy;
    
    public void setStrategy(RouteStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void navigate(String start, String end) {
        if (strategy == null) {
            System.out.println("Please select navigation mode");
            return;
        }
        strategy.buildRoute(start, end);
    }
}

// Usage
Navigator navigator = new Navigator();

navigator.setStrategy(new RoadStrategy());
navigator.navigate("Home", "Office");

navigator.setStrategy(new WalkingStrategy());
navigator.navigate("Office", "Restaurant");

navigator.setStrategy(new PublicTransportStrategy());
navigator.navigate("Restaurant", "Home");
```

### Example 4: Discount Strategies

```java
interface DiscountStrategy {
    double applyDiscount(double price);
}

class NoDiscount implements DiscountStrategy {
    @Override
    public double applyDiscount(double price) {
        return price;
    }
}

class SeasonalDiscount implements DiscountStrategy {
    @Override
    public double applyDiscount(double price) {
        System.out.println("Applying 20% seasonal discount");
        return price * 0.8;
    }
}

class BlackFridayDiscount implements DiscountStrategy {
    @Override
    public double applyDiscount(double price) {
        System.out.println("Applying 50% Black Friday discount");
        return price * 0.5;
    }
}

class LoyaltyDiscount implements DiscountStrategy {
    private int yearsOfMembership;
    
    public LoyaltyDiscount(int years) {
        this.yearsOfMembership = years;
    }
    
    @Override
    public double applyDiscount(double price) {
        double discount = Math.min(yearsOfMembership * 5, 30); // Max 30%
        System.out.println("Applying " + discount + "% loyalty discount");
        return price * (1 - discount / 100);
    }
}

class PriceCalculator {
    private DiscountStrategy discountStrategy;
    
    public PriceCalculator(DiscountStrategy strategy) {
        this.discountStrategy = strategy;
    }
    
    public void setDiscountStrategy(DiscountStrategy strategy) {
        this.discountStrategy = strategy;
    }
    
    public double calculatePrice(double originalPrice) {
        double finalPrice = discountStrategy.applyDiscount(originalPrice);
        System.out.println("Original: $" + originalPrice + 
                         ", Final: $" + finalPrice);
        return finalPrice;
    }
}

// Usage
double price = 100.0;

PriceCalculator calculator = new PriceCalculator(new NoDiscount());
calculator.calculatePrice(price);

calculator.setDiscountStrategy(new SeasonalDiscount());
calculator.calculatePrice(price);

calculator.setDiscountStrategy(new BlackFridayDiscount());
calculator.calculatePrice(price);

calculator.setDiscountStrategy(new LoyaltyDiscount(5));
calculator.calculatePrice(price);
```

---

## ğŸ’» Strategy with Lambda (Java 8+)

```java
// Functional interface
@FunctionalInterface
interface ValidationStrategy {
    boolean validate(String input);
}

class Validator {
    private ValidationStrategy strategy;
    
    public Validator(ValidationStrategy strategy) {
        this.strategy = strategy;
    }
    
    public boolean validate(String input) {
        return strategy.validate(input);
    }
}

// Usage with lambdas
Validator emailValidator = new Validator(
    input -> input.matches("^[A-Za-z0-9+_.-]+@(.+)$")
);

Validator phoneValidator = new Validator(
    input -> input.matches("\\d{3}-\\d{3}-\\d{4}")
);

Validator lengthValidator = new Validator(
    input -> input.length() >= 8
);

System.out.println(emailValidator.validate("test@example.com"));  // true
System.out.println(phoneValidator.validate("123-456-7890"));      // true
System.out.println(lengthValidator.validate("password123"));      // true
```

---

## ğŸ“Š Strategy Pattern Components

| Component | Role |
|-----------|------|
| Strategy | Interface for all algorithms |
| ConcreteStrategy | Implements specific algorithm |
| Context | Uses Strategy interface |

---

## âš¡ Best Practices

| Practice | Description |
|----------|-------------|
| âœ… Use interfaces | Define strategy contract |
| âœ… Inject strategy via constructor | Dependency injection |
| âœ… Allow runtime changes | setStrategy() method |
| âœ… Use lambdas for simple strategies | Java 8+ |
| âœ… Make strategies stateless | Reusability |
| âŒ Don't expose strategy details | To client |
| âŒ Don't create strategies per use | Reuse instances |

---

## ğŸ¯ Advantages & Disadvantages

### Advantages
- Eliminates conditional statements
- Easy to add new strategies
- Runtime algorithm selection
- Follows Open/Closed Principle
- Easy to test strategies independently

### Disadvantages
- Increased number of classes
- Client must know different strategies
- Communication overhead between Strategy and Context

---

## ğŸ”— Related Topics

- [Factory Pattern](02.%20Factory%20Pattern.md)
- [Observer Pattern](04.%20Observer%20Pattern.md)
- [Decorator Pattern](06.%20Decorator%20Pattern.md)

---

## ğŸ’¡ Key Takeaways

- Strategy pattern encapsulates algorithms
- Makes algorithms interchangeable
- Client can switch algorithms at runtime
- Eliminates conditional statements
- Use interface for strategy contract
- Strategies should be stateless when possible
- Java 8+ can use lambdas for simple strategies
- Context delegates to strategy object
- Easy to add new strategies without modifying context
- Follows Open/Closed and Single Responsibility principles
