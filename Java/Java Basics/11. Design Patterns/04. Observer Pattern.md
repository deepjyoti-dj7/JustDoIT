# üëÄ Observer Pattern

## üìñ Overview

**Observer Pattern** defines a one-to-many dependency where when one object (Subject) changes state, all its dependents (Observers) are notified automatically.

**When to Use:**
- Event handling systems
- Model-View-Controller (MVC)
- Publish-subscribe systems
- Real-time notifications

---

## üíª Basic Observer Pattern

```java
import java.util.*;

// Observer interface
interface Observer {
    void update(String message);
}

// Subject interface
interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

// Concrete Subject
class NewsAgency implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String news;
    
    @Override
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
    
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }
}

// Concrete Observers
class EmailSubscriber implements Observer {
    private String email;
    
    public EmailSubscriber(String email) {
        this.email = email;
    }
    
    @Override
    public void update(String message) {
        System.out.println("Email to " + email + ": " + message);
    }
}

class SMSSubscriber implements Observer {
    private String phone;
    
    public SMSSubscriber(String phone) {
        this.phone = phone;
    }
    
    @Override
    public void update(String message) {
        System.out.println("SMS to " + phone + ": " + message);
    }
}

// Usage
NewsAgency agency = new NewsAgency();

Observer emailSub = new EmailSubscriber("user@example.com");
Observer smsSub = new SMSSubscriber("123-456-7890");

agency.attach(emailSub);
agency.attach(smsSub);

agency.setNews("Breaking News: New Java version released!");
```

---

## üíª Using Java Built-in Observer (Legacy)

```java
import java.util.Observable;
import java.util.Observer;

// Subject (deprecated since Java 9)
class WeatherStation extends Observable {
    private float temperature;
    
    public void setTemperature(float temperature) {
        this.temperature = temperature;
        setChanged();           // Mark as changed
        notifyObservers(temperature);  // Notify observers
    }
}

// Observer
class TemperatureDisplay implements Observer {
    @Override
    public void update(Observable o, Object arg) {
        float temp = (float) arg;
        System.out.println("Temperature Display: " + temp + "¬∞C");
    }
}

// Usage (Note: Observable/Observer are deprecated)
WeatherStation station = new WeatherStation();
TemperatureDisplay display = new TemperatureDisplay();

station.addObserver(display);
station.setTemperature(25.5f);
```

**Note:** `Observable` and `Observer` are deprecated since Java 9. Use custom implementation or reactive libraries.

---

## üéØ Complete Examples

### Example 1: Stock Market Monitor

```java
interface StockObserver {
    void update(String stockSymbol, double price);
}

class Stock {
    private String symbol;
    private double price;
    private List<StockObserver> observers = new ArrayList<>();
    
    public Stock(String symbol, double price) {
        this.symbol = symbol;
        this.price = price;
    }
    
    public void addObserver(StockObserver observer) {
        observers.add(observer);
    }
    
    public void removeObserver(StockObserver observer) {
        observers.remove(observer);
    }
    
    public void setPrice(double price) {
        this.price = price;
        notifyObservers();
    }
    
    private void notifyObservers() {
        for (StockObserver observer : observers) {
            observer.update(symbol, price);
        }
    }
}

class StockTrader implements StockObserver {
    private String name;
    
    public StockTrader(String name) {
        this.name = name;
    }
    
    @Override
    public void update(String stockSymbol, double price) {
        System.out.println(name + " notified: " + stockSymbol + 
                         " is now $" + price);
        
        if (price > 150) {
            System.out.println(name + " is selling " + stockSymbol);
        } else if (price < 100) {
            System.out.println(name + " is buying " + stockSymbol);
        }
    }
}

// Usage
Stock appleStock = new Stock("AAPL", 145.50);

StockTrader trader1 = new StockTrader("Alice");
StockTrader trader2 = new StockTrader("Bob");

appleStock.addObserver(trader1);
appleStock.addObserver(trader2);

appleStock.setPrice(155.00);  // Both traders notified
appleStock.setPrice(95.00);   // Both traders notified
```

### Example 2: YouTube Channel Subscription

```java
interface Subscriber {
    void notifyVideo(String channelName, String videoTitle);
}

class YouTubeChannel {
    private String name;
    private List<Subscriber> subscribers = new ArrayList<>();
    
    public YouTubeChannel(String name) {
        this.name = name;
    }
    
    public void subscribe(Subscriber subscriber) {
        subscribers.add(subscriber);
        System.out.println("New subscriber added");
    }
    
    public void unsubscribe(Subscriber subscriber) {
        subscribers.remove(subscriber);
        System.out.println("Subscriber removed");
    }
    
    public void uploadVideo(String title) {
        System.out.println("\nUploading video: " + title);
        notifySubscribers(title);
    }
    
    private void notifySubscribers(String videoTitle) {
        for (Subscriber subscriber : subscribers) {
            subscriber.notifyVideo(name, videoTitle);
        }
    }
}

class User implements Subscriber {
    private String name;
    
    public User(String name) {
        this.name = name;
    }
    
    @Override
    public void notifyVideo(String channelName, String videoTitle) {
        System.out.println("Hey " + name + "! " + channelName + 
                         " uploaded: " + videoTitle);
    }
}

// Usage
YouTubeChannel channel = new YouTubeChannel("TechChannel");

User user1 = new User("Alice");
User user2 = new User("Bob");
User user3 = new User("Charlie");

channel.subscribe(user1);
channel.subscribe(user2);
channel.subscribe(user3);

channel.uploadVideo("Design Patterns in Java");
channel.uploadVideo("Advanced Java Tutorial");
```

### Example 3: Event Manager System

```java
interface EventListener {
    void onEvent(String eventType, String data);
}

class EventManager {
    private Map<String, List<EventListener>> listeners = new HashMap<>();
    
    public void subscribe(String eventType, EventListener listener) {
        listeners.computeIfAbsent(eventType, k -> new ArrayList<>())
                 .add(listener);
    }
    
    public void unsubscribe(String eventType, EventListener listener) {
        List<EventListener> eventListeners = listeners.get(eventType);
        if (eventListeners != null) {
            eventListeners.remove(listener);
        }
    }
    
    public void notify(String eventType, String data) {
        List<EventListener> eventListeners = listeners.get(eventType);
        if (eventListeners != null) {
            for (EventListener listener : eventListeners) {
                listener.onEvent(eventType, data);
            }
        }
    }
}

class LoggingListener implements EventListener {
    @Override
    public void onEvent(String eventType, String data) {
        System.out.println("[LOG] Event: " + eventType + ", Data: " + data);
    }
}

class EmailListener implements EventListener {
    private String email;
    
    public EmailListener(String email) {
        this.email = email;
    }
    
    @Override
    public void onEvent(String eventType, String data) {
        System.out.println("[EMAIL to " + email + "] Event: " + 
                         eventType + ", Data: " + data);
    }
}

// Usage
EventManager eventManager = new EventManager();

LoggingListener logger = new LoggingListener();
EmailListener emailer = new EmailListener("admin@example.com");

eventManager.subscribe("user.login", logger);
eventManager.subscribe("user.login", emailer);
eventManager.subscribe("user.logout", logger);

eventManager.notify("user.login", "User Alice logged in");
eventManager.notify("user.logout", "User Alice logged out");
```

### Example 4: Chat Room

```java
interface ChatObserver {
    void receiveMessage(String sender, String message);
    String getName();
}

class ChatRoom {
    private List<ChatObserver> users = new ArrayList<>();
    
    public void join(ChatObserver user) {
        users.add(user);
        broadcast("System", user.getName() + " joined the chat");
    }
    
    public void leave(ChatObserver user) {
        users.remove(user);
        broadcast("System", user.getName() + " left the chat");
    }
    
    public void sendMessage(String sender, String message) {
        broadcast(sender, message);
    }
    
    private void broadcast(String sender, String message) {
        for (ChatObserver user : users) {
            if (!user.getName().equals(sender)) {
                user.receiveMessage(sender, message);
            }
        }
    }
}

class ChatUser implements ChatObserver {
    private String name;
    
    public ChatUser(String name) {
        this.name = name;
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    @Override
    public void receiveMessage(String sender, String message) {
        System.out.println("[" + name + " received] " + sender + ": " + message);
    }
    
    public void sendMessage(ChatRoom chatRoom, String message) {
        System.out.println("[" + name + " sent] " + message);
        chatRoom.sendMessage(name, message);
    }
}

// Usage
ChatRoom chatRoom = new ChatRoom();

ChatUser alice = new ChatUser("Alice");
ChatUser bob = new ChatUser("Bob");
ChatUser charlie = new ChatUser("Charlie");

chatRoom.join(alice);
chatRoom.join(bob);
chatRoom.join(charlie);

alice.sendMessage(chatRoom, "Hello everyone!");
bob.sendMessage(chatRoom, "Hi Alice!");
```

---

## üìä Observer Pattern Components

| Component | Role |
|-----------|------|
| Subject | Maintains observers, notifies changes |
| Observer | Receives updates from subject |
| ConcreteSubject | Stores state, notifies on change |
| ConcreteObserver | Implements update behavior |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use interfaces | Loose coupling |
| ‚úÖ Avoid memory leaks | Unsubscribe when done |
| ‚úÖ Thread-safe notifications | For concurrent access |
| ‚úÖ Pass relevant data | In update() |
| ‚úÖ Handle observer failures | Don't stop other notifications |
| ‚ùå Don't create circular dependencies | Infinite loops |
| ‚ùå Don't notify in constructor | Object not fully initialized |

---

## üéØ Advantages & Disadvantages

### Advantages
- Loose coupling between subject and observers
- Dynamic relationships (runtime subscription)
- Broadcast communication
- Open/Closed Principle support

### Disadvantages
- Unexpected updates (hard to track)
- Memory leaks if observers not removed
- Performance issues with many observers
- No guarantee of notification order

---

## üîó Related Topics

- [Strategy Pattern](05.%20Strategy%20Pattern.md)
- [Decorator Pattern](06.%20Decorator%20Pattern.md)

---

## üí° Key Takeaways

- Observer pattern implements one-to-many dependency
- Subject notifies all observers when state changes
- Observers register/unregister dynamically
- Use for event-driven systems
- Java's Observable/Observer are deprecated (since Java 9)
- Implement custom observer or use reactive libraries
- Avoid memory leaks by unsubscribing
- Thread-safety important for concurrent systems
- Pass relevant data in notifications
- Don't create circular dependencies
