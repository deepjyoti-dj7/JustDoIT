# ğŸ—ï¸ JDK, JRE, JVM Architecture

## ğŸ“– Overview

Understanding the Java platform architecture is crucial for Java development.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            JDK (Java Development Kit)â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   JRE (Java Runtime Environment)â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚   JVM (Java Virtual Machine)â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”· JVM (Java Virtual Machine)

### What is JVM?
- Abstract machine that executes Java bytecode
- Platform-dependent (different for Windows, Linux, macOS)
- Provides runtime environment for Java programs

### Key Responsibilities:
1. **Load bytecode**
2. **Verify bytecode**
3. **Execute bytecode**
4. **Manage memory**
5. **Provide runtime environment**

### JVM Architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          JVM Architecture                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Class Loader Subsystem                   â”‚
â”‚  â”œâ”€â”€ Bootstrap Class Loader              â”‚
â”‚  â”œâ”€â”€ Extension Class Loader              â”‚
â”‚  â””â”€â”€ Application Class Loader            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Runtime Data Areas                       â”‚
â”‚  â”œâ”€â”€ Method Area (MetaSpace)             â”‚
â”‚  â”œâ”€â”€ Heap (Object Memory)                â”‚
â”‚  â”œâ”€â”€ Stack (Method Calls)                â”‚
â”‚  â”œâ”€â”€ PC Register                         â”‚
â”‚  â””â”€â”€ Native Method Stack                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Execution Engine                         â”‚
â”‚  â”œâ”€â”€ Interpreter                         â”‚
â”‚  â”œâ”€â”€ JIT Compiler                        â”‚
â”‚  â””â”€â”€ Garbage Collector                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Native Method Interface (JNI)            â”‚
â”‚  Native Method Libraries                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Example 1: JVM Memory Areas Demo

```java
public class JVMMemoryDemo {
    // Method Area: Class level data
    static int staticVar = 100;
    
    // Instance variables stored in Heap
    int instanceVar = 200;
    
    public void method1() {
        // Local variables stored in Stack
        int localVar = 300;
        
        // Object created in Heap
        String str = new String("Hello");
        
        System.out.println("Static: " + staticVar);
        System.out.println("Instance: " + instanceVar);
        System.out.println("Local: " + localVar);
        System.out.println("String: " + str);
    }
    
    public static void main(String[] args) {
        // Object reference in Stack, object in Heap
        JVMMemoryDemo obj = new JVMMemoryDemo();
        obj.method1();
        
        // Display memory information
        Runtime runtime = Runtime.getRuntime();
        System.out.println("\n--- Memory Info ---");
        System.out.println("Max Memory: " + runtime.maxMemory() / (1024*1024) + " MB");
        System.out.println("Total Memory: " + runtime.totalMemory() / (1024*1024) + " MB");
        System.out.println("Free Memory: " + runtime.freeMemory() / (1024*1024) + " MB");
    }
}
```

---

## ğŸ’» Example 2: Class Loading Demo

```java
public class ClassLoadingDemo {
    static {
        System.out.println("1. Static block executed - Class loading");
    }
    
    {
        System.out.println("3. Instance initialization block");
    }
    
    public ClassLoadingDemo() {
        System.out.println("4. Constructor executed");
    }
    
    public static void main(String[] args) {
        System.out.println("2. Main method started");
        
        ClassLoadingDemo obj1 = new ClassLoadingDemo();
        System.out.println("5. First object created\n");
        
        ClassLoadingDemo obj2 = new ClassLoadingDemo();
        System.out.println("6. Second object created");
    }
}
```

**Output:**
```
1. Static block executed - Class loading
2. Main method started
3. Instance initialization block
4. Constructor executed
5. First object created

3. Instance initialization block
4. Constructor executed
6. Second object created
```

---

## ğŸ’» Example 3: Stack Memory Demo

```java
public class StackMemoryDemo {
    public static void main(String[] args) {
        int a = 10;          // Stack
        int b = 20;          // Stack
        
        method1(a);
        method2(b);
        
        System.out.println("Back to main");
    }
    
    static void method1(int x) {
        int y = x + 10;      // Stack
        System.out.println("Method1: " + y);
    }
    
    static void method2(int x) {
        int z = x + 20;      // Stack
        System.out.println("Method2: " + z);
    }
}
```

**Stack Trace:**
```
main() frame
â”œâ”€â”€ a = 10
â”œâ”€â”€ b = 20
â”œâ”€â”€ method1() frame
â”‚   â”œâ”€â”€ x = 10
â”‚   â””â”€â”€ y = 20
â””â”€â”€ method2() frame
    â”œâ”€â”€ x = 20
    â””â”€â”€ z = 40
```

---

## ğŸ’» Example 4: Heap Memory Demo

```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class HeapMemoryDemo {
    public static void main(String[] args) {
        // Objects created in Heap
        Person p1 = new Person("Alice", 25);  // p1 in Stack, Person object in Heap
        Person p2 = new Person("Bob", 30);    // p2 in Stack, Person object in Heap
        
        System.out.println("Person 1: " + p1.name + ", " + p1.age);
        System.out.println("Person 2: " + p2.name + ", " + p2.age);
        
        // Reference assignment
        Person p3 = p1;  // p3 points to same object as p1
        p3.name = "Alice Smith";
        
        System.out.println("After modification:");
        System.out.println("Person 1: " + p1.name);  // Changed
        System.out.println("Person 3: " + p3.name);  // Changed
    }
}
```

---

## ğŸ’» Example 5: Garbage Collection Demo

```java
public class GarbageCollectionDemo {
    private String name;
    
    public GarbageCollectionDemo(String name) {
        this.name = name;
        System.out.println(name + " object created");
    }
    
    @Override
    protected void finalize() {
        System.out.println(name + " object garbage collected");
    }
    
    public static void main(String[] args) {
        GarbageCollectionDemo obj1 = new GarbageCollectionDemo("Object1");
        GarbageCollectionDemo obj2 = new GarbageCollectionDemo("Object2");
        
        // Make obj1 eligible for GC
        obj1 = null;
        
        // Request garbage collection
        System.gc();
        
        System.out.println("End of main method");
    }
}
```

**Note:** `finalize()` is deprecated in Java 9+. Use try-with-resources or Cleaner API instead.

---

## ğŸ’» Example 6: JIT Compiler Effect

```java
public class JITDemo {
    public static void main(String[] args) {
        long startTime = System.nanoTime();
        
        // First execution (interpreted)
        int result1 = fibonacci(30);
        long time1 = System.nanoTime() - startTime;
        
        // Warm-up: Execute multiple times for JIT compilation
        for (int i = 0; i < 10000; i++) {
            fibonacci(30);
        }
        
        // Execution after JIT compilation
        startTime = System.nanoTime();
        int result2 = fibonacci(30);
        long time2 = System.nanoTime() - startTime;
        
        System.out.println("First execution time: " + time1 + " ns");
        System.out.println("After JIT compilation: " + time2 + " ns");
        System.out.println("Speedup: " + (time1 / (double) time2) + "x");
    }
    
    static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

---

## ğŸ’» Example 7: Class Loader Hierarchy

```java
public class ClassLoaderDemo {
    public static void main(String[] args) {
        // Get class loader for current class
        ClassLoader classLoader = ClassLoaderDemo.class.getClassLoader();
        
        System.out.println("Current class loader: " + classLoader);
        System.out.println("Parent (Extension): " + classLoader.getParent());
        System.out.println("Parent's parent (Bootstrap): " + classLoader.getParent().getParent());
        
        // String class loaded by Bootstrap class loader
        System.out.println("\nString class loader: " + String.class.getClassLoader());
        
        // ArrayList class loaded by Bootstrap class loader
        System.out.println("ArrayList class loader: " + 
                          java.util.ArrayList.class.getClassLoader());
    }
}
```

**Output:**
```
Current class loader: jdk.internal.loader.ClassLoaders$AppClassLoader@...
Parent (Extension): jdk.internal.loader.ClassLoaders$PlatformClassLoader@...
Parent's parent (Bootstrap): null

String class loader: null
ArrayList class loader: null
```

**Note:** Bootstrap class loader is implemented in native code, so it shows as `null`.

---

## ğŸ”· JRE (Java Runtime Environment)

### What is JRE?
- Runtime environment for executing Java applications
- Contains JVM + Core libraries
- **No development tools** (no compiler)

### Components:
1. **JVM** - Executes bytecode
2. **Core Libraries** - rt.jar, charsets.jar
3. **Supporting Files** - Property files, resource bundles

### JRE Structure:
```
JRE/
â”œâ”€â”€ bin/
â”‚   â”œâ”€â”€ java (JVM launcher)
â”‚   â””â”€â”€ other runtime tools
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ rt.jar (core classes)
â”‚   â”œâ”€â”€ charsets.jar
â”‚   â””â”€â”€ other libraries
â””â”€â”€ conf/
    â””â”€â”€ configuration files
```

---

## ğŸ”· JDK (Java Development Kit)

### What is JDK?
- Complete development kit for Java
- Contains JRE + Development tools
- Required for **developing** Java applications

### Components:
1. **JRE** - Runtime environment
2. **Development Tools**:
   - `javac` - Compiler
   - `javadoc` - Documentation generator
   - `jar` - Archive tool
   - `javap` - Class file disassembler
   - `jdb` - Debugger
   - `jconsole` - Monitoring tool

### JDK Structure:
```
JDK/
â”œâ”€â”€ bin/
â”‚   â”œâ”€â”€ javac (compiler)
â”‚   â”œâ”€â”€ java (JVM)
â”‚   â”œâ”€â”€ javadoc
â”‚   â”œâ”€â”€ jar
â”‚   â””â”€â”€ other tools
â”œâ”€â”€ jre/
â”‚   â””â”€â”€ (JRE components)
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ tools.jar
â”‚   â””â”€â”€ dt.jar
â””â”€â”€ include/
    â””â”€â”€ C header files
```

---

## ğŸ“Š JDK vs JRE vs JVM

| Feature | JDK | JRE | JVM |
|---------|-----|-----|-----|
| **Full Form** | Java Development Kit | Java Runtime Environment | Java Virtual Machine |
| **Purpose** | Develop & Run | Run only | Execute bytecode |
| **Contains** | JRE + Dev Tools | JVM + Libraries | Core execution engine |
| **Tools** | javac, javadoc, jar, etc. | No dev tools | No tools |
| **Size** | Largest | Medium | Smallest |
| **For Developers** | Yes | No | No |
| **For End Users** | Optional | Yes | Part of JRE |

---

## ğŸ’» Example 8: Complete Compilation & Execution

```java
// File: Calculator.java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result = calc.add(10, 20);
        System.out.println("Result: " + result);
    }
}
```

**Process:**

```bash
# Step 1: Compile (using JDK's javac)
javac Calculator.java
# Creates Calculator.class (bytecode)

# Step 2: Run (using JRE's java)
java Calculator
# JVM loads, verifies, and executes bytecode
```

**Behind the scenes:**
1. **Class Loader** loads Calculator.class
2. **Bytecode Verifier** checks code safety
3. **Interpreter** starts executing
4. **JIT Compiler** optimizes hot methods
5. **Garbage Collector** manages memory

---

## ğŸ“Š Memory Areas Deep Dive

### 1. **Method Area (MetaSpace in Java 8+)**
- Stores class-level data
- Static variables
- Method code
- Runtime constant pool

### 2. **Heap**
- Object instances
- Instance variables
- Arrays
- Shared among all threads

### 3. **Stack**
- Method calls (frames)
- Local variables
- Partial results
- One stack per thread

### 4. **PC Register**
- Current instruction address
- One per thread

### 5. **Native Method Stack**
- Native method calls
- JNI (Java Native Interface)

---

## ğŸ’¡ Best Practices

1. âœ… Use appropriate JDK version for your project
2. âœ… Set JAVA_HOME environment variable
3. âœ… Update JDK regularly for security patches
4. âœ… Use JRE for production deployment (smaller footprint)
5. âœ… Monitor JVM memory usage
6. âœ… Tune JVM parameters for performance
7. âœ… Understand garbage collection for your use case

---

## ğŸ¯ Interview Questions

1. **What is the difference between JDK, JRE, and JVM?**
2. **Explain JVM architecture**
3. **What is bytecode?**
4. **How does class loading work?**
5. **What is the difference between Stack and Heap?**
6. **What is JIT compiler?**
7. **Explain garbage collection in JVM**
8. **What is MetaSpace (Method Area)?**
9. **Can we run Java program without JDK?**
10. **What happens when we execute `java ClassName`?**

---

## ğŸ“š Next Topics

- [Data Types & Variables](03.%20Data%20Types%20%26%20Variables.md)
- [Operators & Expressions](04.%20Operators%20%26%20Expressions.md)
- [Memory Management](../../12.%20Memory%20Management/01.%20Memory%20Structure.md)
