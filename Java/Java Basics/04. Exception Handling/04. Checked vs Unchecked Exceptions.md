# âœ… Checked vs Unchecked Exceptions

## ðŸ“– Overview

Java exceptions are divided into two categories based on compile-time checking:

1. **Checked Exceptions** - Checked at compile-time, must be handled
2. **Unchecked Exceptions** - Checked at runtime, handling optional

---

## ðŸŽ¯ Key Differences

| Feature | Checked Exception | Unchecked Exception |
|---------|------------------|---------------------|
| **Checking Time** | Compile-time | Runtime |
| **Handling** | Must handle/declare | Optional |
| **Extends** | Exception (not RuntimeException) | RuntimeException or Error |
| **Purpose** | Recoverable conditions | Programming errors |
| **Example** | IOException, SQLException | NullPointerException, ArithmeticException |
| **Compiler Enforcement** | Yes | No |

---

## ðŸ’» Example 1: Checked Exception - Must Handle

```java
import java.io.*;

public class CheckedExceptionDemo {
    // Method 1: Handle with try-catch
    static void readFileWithCatch() {
        System.out.println("=== Method 1: Handle with try-catch ===");
        try {
            FileReader fr = new FileReader("file.txt");  // Checked exception
            System.out.println("File opened successfully");
            fr.close();
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        } catch (IOException e) {
            System.out.println("I/O error: " + e.getMessage());
        }
    }
    
    // Method 2: Declare with throws
    static void readFileWithThrows() throws IOException {
        System.out.println("\n=== Method 2: Declare with throws ===");
        FileReader fr = new FileReader("file.txt");  // Throws to caller
        System.out.println("File opened successfully");
        fr.close();
    }
    
    // Won't compile without handling
    // static void invalidMethod() {
    //     FileReader fr = new FileReader("file.txt");  // COMPILE ERROR
    // }
    
    public static void main(String[] args) {
        readFileWithCatch();
        
        try {
            readFileWithThrows();
        } catch (IOException e) {
            System.out.println("Caught in main: " + e.getMessage());
        }
    }
}
```

---

## ðŸ’» Example 2: Unchecked Exception - Optional Handling

```java
public class UncheckedExceptionDemo {
    // No need to handle - compiles fine
    static int divide(int a, int b) {
        return a / b;  // May throw ArithmeticException
    }
    
    // Can handle if we want
    static int divideWithHandling(int a, int b) {
        try {
            return a / b;
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero");
            return 0;
        }
    }
    
    // No handling needed
    static void printLength(String str) {
        System.out.println(str.length());  // May throw NullPointerException
    }
    
    public static void main(String[] args) {
        System.out.println("=== Unchecked Exceptions - No Forced Handling ===\n");
        
        // Example 1: No exception
        System.out.println("10 / 2 = " + divide(10, 2));
        
        // Example 2: Exception occurs
        try {
            System.out.println("10 / 0 = " + divide(10, 0));
        } catch (ArithmeticException e) {
            System.out.println("Caught: Division by zero");
        }
        
        // Example 3: With handling
        System.out.println("With handling: " + divideWithHandling(10, 0));
        
        // Example 4: NullPointerException
        try {
            printLength(null);
        } catch (NullPointerException e) {
            System.out.println("Caught: Null pointer");
        }
    }
}
```

---

## ðŸ’» Example 3: Common Checked Exceptions

```java
import java.io.*;
import java.sql.*;
import java.net.*;

public class CommonCheckedExceptions {
    public static void main(String[] args) {
        System.out.println("=== Common Checked Exceptions ===\n");
        
        // 1. IOException
        System.out.println("1. IOException:");
        try {
            FileInputStream fis = new FileInputStream("nonexistent.txt");
        } catch (FileNotFoundException e) {
            System.out.println("   Caught: " + e.getClass().getSimpleName());
        }
        
        // 2. SQLException
        System.out.println("\n2. SQLException:");
        try {
            throw new SQLException("Database connection failed");
        } catch (SQLException e) {
            System.out.println("   Caught: " + e.getClass().getSimpleName());
            System.out.println("   Message: " + e.getMessage());
        }
        
        // 3. ClassNotFoundException
        System.out.println("\n3. ClassNotFoundException:");
        try {
            Class.forName("com.nonexistent.MyClass");
        } catch (ClassNotFoundException e) {
            System.out.println("   Caught: " + e.getClass().getSimpleName());
        }
        
        // 4. InterruptedException
        System.out.println("\n4. InterruptedException:");
        try {
            Thread.sleep(100);
            System.out.println("   Thread slept successfully");
        } catch (InterruptedException e) {
            System.out.println("   Caught: " + e.getClass().getSimpleName());
        }
        
        // 5. MalformedURLException
        System.out.println("\n5. MalformedURLException:");
        try {
            URL url = new URL("invalid url");
        } catch (MalformedURLException e) {
            System.out.println("   Caught: " + e.getClass().getSimpleName());
        }
        
        System.out.println("\nAll must be caught or declared with throws");
    }
}
```

---

## ðŸ’» Example 4: Common Unchecked Exceptions

```java
public class CommonUncheckedExceptions {
    public static void main(String[] args) {
        System.out.println("=== Common Unchecked Exceptions ===\n");
        
        // 1. ArithmeticException
        System.out.println("1. ArithmeticException:");
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        // 2. NullPointerException
        System.out.println("\n2. NullPointerException:");
        try {
            String str = null;
            str.length();
        } catch (NullPointerException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        // 3. ArrayIndexOutOfBoundsException
        System.out.println("\n3. ArrayIndexOutOfBoundsException:");
        try {
            int[] arr = {1, 2, 3};
            int x = arr[5];
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        // 4. NumberFormatException
        System.out.println("\n4. NumberFormatException:");
        try {
            int num = Integer.parseInt("abc");
        } catch (NumberFormatException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        // 5. IllegalArgumentException
        System.out.println("\n5. IllegalArgumentException:");
        try {
            Thread.sleep(-100);
        } catch (IllegalArgumentException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        // 6. ClassCastException
        System.out.println("\n6. ClassCastException:");
        try {
            Object obj = "Hello";
            Integer num = (Integer) obj;
        } catch (ClassCastException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        // 7. IllegalStateException
        System.out.println("\n7. IllegalStateException:");
        try {
            throw new IllegalStateException("Invalid state");
        } catch (IllegalStateException e) {
            System.out.println("   " + e.getClass().getSimpleName());
        }
        
        System.out.println("\nNo compile-time checking required");
    }
}
```

---

## ðŸ’» Example 5: Why Checked Exceptions Exist

```java
import java.io.*;

class FileProcessor {
    // Checked exception forces caller to think about error handling
    public String readFile(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        StringBuilder content = new StringBuilder();
        String line;
        
        while ((line = reader.readLine()) != null) {
            content.append(line).append("\n");
        }
        
        reader.close();
        return content.toString();
    }
}

public class WhyCheckedExceptions {
    public static void main(String[] args) {
        FileProcessor processor = new FileProcessor();
        
        // Compiler forces us to handle or declare
        // processor.readFile("test.txt");  // COMPILE ERROR
        
        // Option 1: Handle the exception
        System.out.println("=== Option 1: Handle ===");
        try {
            String content = processor.readFile("test.txt");
            System.out.println("Content: " + content);
        } catch (FileNotFoundException e) {
            System.out.println("File not found - creating default");
        } catch (IOException e) {
            System.out.println("I/O error - using cache");
        }
        
        // Option 2: Propagate using throws (would add to method signature)
        System.out.println("\nChecked exceptions ensure error handling is considered");
    }
}
```

---

## ðŸ’» Example 6: When to Use Each Type

```java
// Checked exception - Recoverable external issue
class InsufficientBalanceException extends Exception {
    private double balance;
    private double requested;
    
    public InsufficientBalanceException(double balance, double requested) {
        super("Insufficient balance. Balance: " + balance + ", Requested: " + requested);
        this.balance = balance;
        this.requested = requested;
    }
    
    public double getBalance() { return balance; }
    public double getRequested() { return requested; }
}

// Unchecked exception - Programming error
class InvalidAccountNumberException extends RuntimeException {
    public InvalidAccountNumberException(String accountNumber) {
        super("Invalid account number: " + accountNumber);
    }
}

class BankAccount {
    private String accountNumber;
    private double balance;
    
    public BankAccount(String accountNumber, double balance) {
        // Validate input - throw unchecked for programming error
        if (accountNumber == null || accountNumber.length() != 10) {
            throw new InvalidAccountNumberException(accountNumber);
        }
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    // Checked exception - User can fix by depositing money
    public void withdraw(double amount) throws InsufficientBalanceException {
        if (amount > balance) {
            throw new InsufficientBalanceException(balance, amount);
        }
        balance -= amount;
    }
    
    public void deposit(double amount) {
        // Unchecked - Invalid input is programming error
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        balance += amount;
    }
    
    public double getBalance() { return balance; }
}

public class WhenToUseEach {
    public static void main(String[] args) {
        System.out.println("=== Checked vs Unchecked Usage ===\n");
        
        // Unchecked - Programming error
        System.out.println("1. Unchecked (Programming Error):");
        try {
            BankAccount acc = new BankAccount("123", 1000);  // Invalid number
        } catch (InvalidAccountNumberException e) {
            System.out.println("   Error: " + e.getMessage());
            System.out.println("   Fix: Provide valid 10-digit account number\n");
        }
        
        // Valid account
        BankAccount account = new BankAccount("1234567890", 1000);
        
        // Checked - User can recover
        System.out.println("2. Checked (Recoverable):");
        try {
            account.withdraw(1500);
        } catch (InsufficientBalanceException e) {
            System.out.println("   Error: " + e.getMessage());
            System.out.println("   Fix: Deposit more money or reduce amount");
            System.out.println("   Current balance: " + e.getBalance());
            System.out.println("   Requested: " + e.getRequested());
        }
        
        System.out.println("\n3. Current balance: " + account.getBalance());
    }
}
```

---

## ðŸ’» Example 7: Converting Between Types

```java
import java.io.*;

public class ConvertingExceptions {
    // Converting checked to unchecked
    static String readFileUnchecked(String filename) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            return reader.readLine();
        } catch (IOException e) {
            // Wrap checked in unchecked
            throw new RuntimeException("Failed to read file", e);
        }
    }
    
    // Converting unchecked to checked
    static int parseIntChecked(String str) throws NumberFormatException {
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            // Could wrap in checked if needed
            throw e;  // Or throw new Exception(e);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Converting Exception Types ===\n");
        
        // Now unchecked - no forced handling
        System.out.println("1. Checked converted to Unchecked:");
        try {
            String content = readFileUnchecked("test.txt");
            System.out.println("Content: " + content);
        } catch (RuntimeException e) {
            System.out.println("Error: " + e.getMessage());
            System.out.println("Cause: " + e.getCause().getClass().getSimpleName());
        }
        
        System.out.println("\n2. Unchecked remains Unchecked:");
        try {
            int num = parseIntChecked("abc");
        } catch (NumberFormatException e) {
            System.out.println("Error: " + e.getClass().getSimpleName());
        }
    }
}
```

---

## ðŸ’» Example 8: Exception Propagation Difference

```java
import java.io.*;

public class PropagationDifference {
    // Checked - must declare or handle
    static void method1Checked() throws IOException {
        throw new IOException("Checked exception");
    }
    
    static void method2Checked() throws IOException {
        method1Checked();  // Must declare throws
    }
    
    // Unchecked - no declaration needed
    static void method1Unchecked() {
        throw new RuntimeException("Unchecked exception");
    }
    
    static void method2Unchecked() {
        method1Unchecked();  // No throws declaration needed
    }
    
    public static void main(String[] args) {
        System.out.println("=== Propagation Difference ===\n");
        
        // Checked - forced to handle
        System.out.println("1. Checked Exception:");
        try {
            method2Checked();
        } catch (IOException e) {
            System.out.println("   Must catch: " + e.getMessage());
        }
        
        // Unchecked - optional handling
        System.out.println("\n2. Unchecked Exception:");
        try {
            method2Unchecked();
        } catch (RuntimeException e) {
            System.out.println("   Optional catch: " + e.getMessage());
        }
        
        System.out.println("\n3. Without catch (unchecked only):");
        // method2Unchecked();  // Would terminate program
        System.out.println("   Would propagate to JVM and terminate");
    }
}
```

---

## ðŸ’» Example 9: Real-World Example - User Registration

```java
import java.io.*;

// Checked - External issues
class EmailAlreadyExistsException extends Exception {
    public EmailAlreadyExistsException(String email) {
        super("Email already registered: " + email);
    }
}

// Unchecked - Invalid input (programming/validation error)
class InvalidEmailFormatException extends RuntimeException {
    public InvalidEmailFormatException(String email) {
        super("Invalid email format: " + email);
    }
}

class UserService {
    private String[] existingEmails = {"user@example.com", "test@example.com"};
    
    // Checked - User can try different email
    public void registerUser(String email, String password) throws EmailAlreadyExistsException {
        // Unchecked - Invalid input
        if (!email.contains("@")) {
            throw new InvalidEmailFormatException(email);
        }
        
        // Checked - External condition
        for (String existing : existingEmails) {
            if (existing.equals(email)) {
                throw new EmailAlreadyExistsException(email);
            }
        }
        
        System.out.println("User registered successfully: " + email);
    }
}

public class UserRegistrationExample {
    public static void main(String[] args) {
        UserService service = new UserService();
        
        System.out.println("=== User Registration ===\n");
        
        // Test 1: Invalid format (unchecked - programming error)
        System.out.println("1. Invalid email format:");
        try {
            service.registerUser("invalidemail", "pass123");
        } catch (InvalidEmailFormatException e) {
            System.out.println("   Validation error: " + e.getMessage());
            System.out.println("   Fix: Validate input before calling\n");
        } catch (EmailAlreadyExistsException e) {
            System.out.println("   Error: " + e.getMessage());
        }
        
        // Test 2: Email exists (checked - user can fix)
        System.out.println("2. Email already exists:");
        try {
            service.registerUser("user@example.com", "pass123");
        } catch (EmailAlreadyExistsException e) {
            System.out.println("   Error: " + e.getMessage());
            System.out.println("   Action: Try different email or login\n");
        }
        
        // Test 3: Success
        System.out.println("3. Valid registration:");
        try {
            service.registerUser("newuser@example.com", "pass123");
        } catch (EmailAlreadyExistsException e) {
            System.out.println("   Error: " + e.getMessage());
        }
    }
}
```

---

## ðŸ’» Example 10: Design Decision - API Design

```java
import java.io.*;

class DataProcessor {
    // Approach 1: Checked exceptions in API
    public void processFileChecked(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        // Process file
        reader.close();
    }
    
    // Approach 2: Wrap in unchecked
    public void processFileUnchecked(String filename) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            // Process file
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException("Failed to process file", e);
        }
    }
}

public class APIDesign {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();
        
        System.out.println("=== API Design Choices ===\n");
        
        // Approach 1: Checked - Explicit handling
        System.out.println("1. Checked Exception API:");
        try {
            processor.processFileChecked("data.txt");
        } catch (IOException e) {
            System.out.println("   Forced to handle");
            System.out.println("   Pro: Caller aware of failure possibility");
            System.out.println("   Con: Verbose, forces handling\n");
        }
        
        // Approach 2: Unchecked - Cleaner code
        System.out.println("2. Unchecked Exception API:");
        try {
            processor.processFileUnchecked("data.txt");
        } catch (RuntimeException e) {
            System.out.println("   Optional handling");
            System.out.println("   Pro: Cleaner code, flexible");
            System.out.println("   Con: Caller might miss error handling");
        }
        
        System.out.println("\nChoice depends on:");
        System.out.println("- Is error recoverable?");
        System.out.println("- Should caller be forced to handle?");
        System.out.println("- API simplicity vs explicitness");
    }
}
```

---

## ðŸ“Š Complete Comparison

| Aspect | Checked | Unchecked |
|--------|---------|-----------|
| **Superclass** | Exception (not RuntimeException) | RuntimeException or Error |
| **Compile Check** | Yes | No |
| **Must Handle** | Yes (catch or throws) | No |
| **Typical Use** | Recoverable external issues | Programming errors |
| **Examples** | IOException, SQLException | NullPointerException, IllegalArgumentException |
| **Design Philosophy** | Explicit error handling | Optional error handling |
| **When to Use** | User can fix | Developer should prevent |

---

## ðŸ’¡ Best Practices

1. âœ… **Use checked for recoverable conditions**
   ```java
   public void withdraw(double amount) throws InsufficientFundsException {
       // User can deposit more
   }
   ```

2. âœ… **Use unchecked for programming errors**
   ```java
   if (amount < 0) {
       throw new IllegalArgumentException("Amount must be positive");
   }
   ```

3. âœ… **Don't overuse checked exceptions**
   ```java
   // Bad - forces handling for simple validation
   void setAge(int age) throws InvalidAgeException
   
   // Good - unchecked for validation
   void setAge(int age) {
       if (age < 0) throw new IllegalArgumentException();
   }
   ```

4. âœ… **Document unchecked exceptions**
   ```java
   /**
    * @throws IllegalArgumentException if amount is negative
    */
   void deposit(double amount) { }
   ```

---

## âš ï¸ Common Pitfalls

```java
public class CheckedUncheckedPitfalls {
    // 1. Overusing checked exceptions
    // void setName(String name) throws InvalidNameException  // BAD
    
    // 2. Catching Exception (catches both checked and unchecked)
    void badPractice() {
        try {
            // code
        } catch (Exception e) {  // Too broad
            // Lost distinction between checked/unchecked
        }
    }
    
    // 3. Empty catch for checked exceptions
    void silentFailure() {
        try {
            // FileReader
        } catch (IOException e) {
            // Empty - BAD!
        }
    }
}
```

---

## ðŸŽ¯ Interview Questions

1. **What are checked exceptions?**
2. **What are unchecked exceptions?**
3. **Difference between checked and unchecked?**
4. **Examples of checked exceptions?**
5. **Examples of unchecked exceptions?**
6. **When to use checked vs unchecked?**
7. **Can we convert checked to unchecked?**
8. **Why have checked exceptions?**
9. **What does RuntimeException extend?**
10. **Do unchecked exceptions need to be declared?**
11. **What is Error class - checked or unchecked?**
12. **Can we catch unchecked exceptions?**
13. **Best practices for exception types?**
14. **How to choose exception type for custom exception?**
15. **What exceptions should never be caught?**

---

## ðŸ“š Related Topics

- [Exception Hierarchy](03.%20Exception%20Hierarchy.md)
- [throw & throws](05.%20throw%20%26%20throws.md)
- [Custom Exceptions](06.%20Custom%20Exceptions.md)
- [Best Practices](08.%20Best%20Practices.md)
