# ‚öñÔ∏è Abstract Classes vs Interfaces

## üìñ Overview

Both abstract classes and interfaces are used to achieve abstraction in Java, but they have different purposes and characteristics. Understanding when to use each is crucial for good object-oriented design.

---

## üìä Detailed Comparison

| Feature | Abstract Class | Interface |
|---------|----------------|-----------|
| **Keyword** | `abstract class` | `interface` |
| **Implementation** | `extends` | `implements` |
| **Multiple Inheritance** | ‚ùå Cannot extend multiple classes | ‚úÖ Can implement multiple interfaces |
| **Methods** | Abstract + Concrete | Abstract, Default (Java 8+), Static (Java 8+), Private (Java 9+) |
| **Variables** | Any type (instance, static, final) | Only `public static final` |
| **Constructors** | ‚úÖ Can have | ‚ùå Cannot have |
| **Access Modifiers** | All (public, protected, private, default) | Only public or default |
| **Method Implementation** | Can be partial | Must be full (except default methods) |
| **Use Case** | IS-A relationship (inheritance) | CAN-DO relationship (capability) |
| **Speed** | Fast | Slightly slower (requires extra indirection) |

---

## üíª Example 1: Basic Comparison

```java
// Abstract Class
abstract class Animal {
    String name;  // Instance variable
    
    // Constructor
    Animal(String name) {
        this.name = name;
    }
    
    // Abstract method
    abstract void makeSound();
    
    // Concrete method
    void sleep() {
        System.out.println(name + " is sleeping");
    }
}

// Interface
interface Flyable {
    // Constant (public static final)
    int MAX_HEIGHT = 10000;
    
    // Abstract method
    void fly();
    
    // Default method
    default void land() {
        System.out.println("Landing safely");
    }
}

// Using both
class Bird extends Animal implements Flyable {
    Bird(String name) {
        super(name);
    }
    
    @Override
    void makeSound() {
        System.out.println(name + " chirps");
    }
    
    @Override
    public void fly() {
        System.out.println(name + " is flying");
    }
}

public class ComparisonDemo {
    public static void main(String[] args) {
        Bird sparrow = new Bird("Sparrow");
        sparrow.makeSound();
        sparrow.fly();
        sparrow.land();
        sparrow.sleep();
        System.out.println("Max height: " + Flyable.MAX_HEIGHT);
    }
}
```

**Output:**
```
Sparrow chirps
Sparrow is flying
Landing safely
Sparrow is sleeping
Max height: 10000
```

---

## üíª Example 2: Multiple Inheritance

```java
// Cannot extend multiple classes
abstract class Vehicle {
    abstract void move();
}

abstract class Electronics {
    abstract void powerOn();
}

// ERROR: Cannot extend multiple classes
// class Tesla extends Vehicle, Electronics { }

// But can implement multiple interfaces
interface Drivable {
    void drive();
}

interface Chargeable {
    void charge();
}

// This works!
class ElectricCar extends Vehicle implements Drivable, Chargeable {
    @Override
    void move() {
        System.out.println("Moving electrically");
    }
    
    @Override
    public void drive() {
        System.out.println("Driving smoothly");
    }
    
    @Override
    public void charge() {
        System.out.println("Charging battery");
    }
}

public class MultipleInheritanceDemo {
    public static void main(String[] args) {
        ElectricCar tesla = new ElectricCar();
        tesla.move();
        tesla.drive();
        tesla.charge();
    }
}
```

---

## üíª Example 3: Constructors and Variables

```java
// Abstract class with constructor and variables
abstract class Employee {
    protected String name;
    protected int id;
    private double baseSalary;
    static int employeeCount = 0;
    
    // Constructor
    Employee(String name, int id, double baseSalary) {
        this.name = name;
        this.id = id;
        this.baseSalary = baseSalary;
        employeeCount++;
    }
    
    abstract double calculateSalary();
    
    void displayInfo() {
        System.out.println("Name: " + name + ", ID: " + id);
        System.out.println("Salary: $" + calculateSalary());
    }
    
    double getBaseSalary() {
        return baseSalary;
    }
}

// Interface - no constructor, only constants
interface Bonus {
    double PERFORMANCE_BONUS = 5000;  // public static final
    double YEARLY_BONUS = 10000;
    
    double calculateBonus();
}

class Manager extends Employee implements Bonus {
    private int teamSize;
    
    Manager(String name, int id, double baseSalary, int teamSize) {
        super(name, id, baseSalary);
        this.teamSize = teamSize;
    }
    
    @Override
    double calculateSalary() {
        return getBaseSalary() + calculateBonus();
    }
    
    @Override
    public double calculateBonus() {
        return PERFORMANCE_BONUS + (teamSize * 1000);
    }
}

public class ConstructorVariableDemo {
    public static void main(String[] args) {
        Manager mgr = new Manager("Alice", 101, 50000, 5);
        mgr.displayInfo();
        System.out.println("Employee Count: " + Employee.employeeCount);
    }
}
```

---

## üíª Example 4: When to Use Abstract Class

```java
// Use abstract class for IS-A relationship
// When classes share common implementation
abstract class Shape {
    protected String color;
    protected boolean filled;
    
    Shape(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
    }
    
    // Common behavior for all shapes
    void displayProperties() {
        System.out.println("Color: " + color);
        System.out.println("Filled: " + filled);
    }
    
    // Must be implemented by subclasses
    abstract double calculateArea();
    abstract double calculatePerimeter();
}

class Circle extends Shape {
    private double radius;
    
    Circle(String color, boolean filled, double radius) {
        super(color, filled);
        this.radius = radius;
    }
    
    @Override
    double calculateArea() {
        return 3.14 * radius * radius;
    }
    
    @Override
    double calculatePerimeter() {
        return 2 * 3.14 * radius;
    }
}

class Rectangle extends Shape {
    private double length, width;
    
    Rectangle(String color, boolean filled, double length, double width) {
        super(color, filled);
        this.length = length;
        this.width = width;
    }
    
    @Override
    double calculateArea() {
        return length * width;
    }
    
    @Override
    double calculatePerimeter() {
        return 2 * (length + width);
    }
}

public class AbstractClassUseCase {
    public static void main(String[] args) {
        Shape circle = new Circle("Red", true, 5);
        circle.displayProperties();
        System.out.println("Area: " + circle.calculateArea());
        System.out.println("Perimeter: " + circle.calculatePerimeter());
        
        System.out.println();
        
        Shape rectangle = new Rectangle("Blue", false, 10, 5);
        rectangle.displayProperties();
        System.out.println("Area: " + rectangle.calculateArea());
        System.out.println("Perimeter: " + rectangle.calculatePerimeter());
    }
}
```

---

## üíª Example 5: When to Use Interface

```java
// Use interface for CAN-DO relationship
// When defining capabilities/behaviors
interface Drawable {
    void draw();
}

interface Resizable {
    void resize(double factor);
}

interface Rotatable {
    void rotate(double angle);
}

// Different classes can have same capabilities
class Image implements Drawable, Resizable, Rotatable {
    private String filename;
    private double width, height;
    
    Image(String filename, double width, double height) {
        this.filename = filename;
        this.width = width;
        this.height = height;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing image: " + filename);
    }
    
    @Override
    public void resize(double factor) {
        width *= factor;
        height *= factor;
        System.out.println("Resized to: " + width + "x" + height);
    }
    
    @Override
    public void rotate(double angle) {
        System.out.println("Rotated by " + angle + " degrees");
    }
}

class Text implements Drawable, Resizable {
    private String content;
    private int fontSize;
    
    Text(String content, int fontSize) {
        this.content = content;
        this.fontSize = fontSize;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing text: " + content);
    }
    
    @Override
    public void resize(double factor) {
        fontSize = (int)(fontSize * factor);
        System.out.println("Font size: " + fontSize);
    }
}

public class InterfaceUseCase {
    public static void main(String[] args) {
        System.out.println("=== Image ===");
        Image img = new Image("photo.jpg", 800, 600);
        img.draw();
        img.resize(0.5);
        img.rotate(90);
        
        System.out.println("\n=== Text ===");
        Text text = new Text("Hello World", 12);
        text.draw();
        text.resize(2);
    }
}
```

---

## üíª Example 6: Default Methods in Interface

```java
// Before Java 8: Interface evolution was difficult
interface OldPayment {
    void processPayment(double amount);
}

// Java 8+: Can add default methods without breaking existing code
interface ModernPayment {
    void processPayment(double amount);
    
    // New method with default implementation
    default void sendReceipt(String email) {
        System.out.println("Sending receipt to: " + email);
    }
    
    default void logTransaction() {
        System.out.println("Transaction logged");
    }
}

class CreditCard implements ModernPayment {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing $" + amount + " via credit card");
    }
    
    // Can override default method
    @Override
    public void sendReceipt(String email) {
        System.out.println("Sending detailed receipt to: " + email);
    }
    
    // Uses default logTransaction()
}

class Cash implements ModernPayment {
    @Override
    public void processPayment(double amount) {
        System.out.println("Receiving $" + amount + " in cash");
    }
    
    // Uses both default methods
}

public class DefaultMethodsDemo {
    public static void main(String[] args) {
        ModernPayment cc = new CreditCard();
        cc.processPayment(100);
        cc.sendReceipt("user@email.com");
        cc.logTransaction();
        
        System.out.println();
        
        ModernPayment cash = new Cash();
        cash.processPayment(50);
        cash.sendReceipt("customer@email.com");
        cash.logTransaction();
    }
}
```

---

## üíª Example 7: Diamond Problem

```java
// Diamond problem with interfaces (solved in Java 8)
interface A {
    default void display() {
        System.out.println("Interface A");
    }
}

interface B {
    default void display() {
        System.out.println("Interface B");
    }
}

// Must explicitly choose which implementation
class C implements A, B {
    @Override
    public void display() {
        // Option 1: Provide own implementation
        System.out.println("Class C");
        
        // Option 2: Call specific interface method
        // A.super.display();
        // B.super.display();
    }
}

// Diamond problem with abstract classes (not possible)
abstract class Parent1 {
    void show() {
        System.out.println("Parent 1");
    }
}

abstract class Parent2 {
    void show() {
        System.out.println("Parent 2");
    }
}

// ERROR: Cannot extend multiple classes
// class Child extends Parent1, Parent2 { }

public class DiamondProblemDemo {
    public static void main(String[] args) {
        C obj = new C();
        obj.display();
    }
}
```

---

## üíª Example 8: Real-World Design Decision

```java
// Scenario: Building a media player system

// Use abstract class for common implementation
abstract class MediaFile {
    protected String filename;
    protected long fileSize;
    protected String format;
    
    MediaFile(String filename, long fileSize, String format) {
        this.filename = filename;
        this.fileSize = fileSize;
        this.format = format;
    }
    
    // Common method
    void displayInfo() {
        System.out.println("File: " + filename);
        System.out.println("Size: " + fileSize + " bytes");
        System.out.println("Format: " + format);
    }
    
    // Must be implemented
    abstract void play();
    abstract void stop();
}

// Use interfaces for capabilities
interface Streamable {
    void stream(String url);
}

interface Downloadable {
    void download(String destination);
}

interface Shareable {
    void share(String platform);
}

// Audio file with streaming capability
class AudioFile extends MediaFile implements Streamable, Downloadable {
    AudioFile(String filename, long fileSize) {
        super(filename, fileSize, "MP3");
    }
    
    @Override
    void play() {
        System.out.println("Playing audio: " + filename);
    }
    
    @Override
    void stop() {
        System.out.println("Stopped audio");
    }
    
    @Override
    public void stream(String url) {
        System.out.println("Streaming from: " + url);
    }
    
    @Override
    public void download(String destination) {
        System.out.println("Downloading to: " + destination);
    }
}

// Video file with all capabilities
class VideoFile extends MediaFile implements Streamable, Downloadable, Shareable {
    VideoFile(String filename, long fileSize) {
        super(filename, fileSize, "MP4");
    }
    
    @Override
    void play() {
        System.out.println("Playing video: " + filename);
    }
    
    @Override
    void stop() {
        System.out.println("Stopped video");
    }
    
    @Override
    public void stream(String url) {
        System.out.println("Streaming video from: " + url);
    }
    
    @Override
    public void download(String destination) {
        System.out.println("Downloading video to: " + destination);
    }
    
    @Override
    public void share(String platform) {
        System.out.println("Sharing on: " + platform);
    }
}

public class MediaPlayerDesign {
    public static void main(String[] args) {
        System.out.println("=== Audio File ===");
        AudioFile audio = new AudioFile("song.mp3", 5000000);
        audio.displayInfo();
        audio.play();
        audio.stream("https://music.com/song");
        audio.download("/music/");
        audio.stop();
        
        System.out.println("\n=== Video File ===");
        VideoFile video = new VideoFile("movie.mp4", 50000000);
        video.displayInfo();
        video.play();
        video.stream("https://video.com/movie");
        video.share("Facebook");
        video.stop();
    }
}
```

---

## üìä When to Use What?

### Use Abstract Class When:
1. ‚úÖ You want to share code among related classes
2. ‚úÖ You need non-public members (protected, private)
3. ‚úÖ You need instance variables
4. ‚úÖ You need constructors
5. ‚úÖ Classes are closely related (IS-A relationship)
6. ‚úÖ You want to provide common behavior

**Example:** Animal ‚Üí Dog, Cat, Bird

### Use Interface When:
1. ‚úÖ Unrelated classes implement your interface
2. ‚úÖ You want to specify behavior (CAN-DO)
3. ‚úÖ You need multiple inheritance
4. ‚úÖ You want to define a contract
5. ‚úÖ You're designing for future extension
6. ‚úÖ You need type declaration

**Example:** Flyable, Swimmable, Runnable

---

## üíª Example 9: Combining Both

```java
// Abstract class for common structure
abstract class Document {
    protected String title;
    protected String author;
    protected int pages;
    
    Document(String title, String author, int pages) {
        this.title = title;
        this.author = author;
        this.pages = pages;
    }
    
    abstract void open();
    abstract void close();
    
    void printInfo() {
        System.out.println("Title: " + title);
        System.out.println("Author: " + author);
        System.out.println("Pages: " + pages);
    }
}

// Interfaces for capabilities
interface Printable {
    void print();
}

interface Editable {
    void edit();
}

interface Encryptable {
    void encrypt(String key);
    void decrypt(String key);
}

// PDF with printing and encryption
class PDFDocument extends Document implements Printable, Encryptable {
    PDFDocument(String title, String author, int pages) {
        super(title, author, pages);
    }
    
    @Override
    void open() {
        System.out.println("Opening PDF: " + title);
    }
    
    @Override
    void close() {
        System.out.println("Closing PDF");
    }
    
    @Override
    public void print() {
        System.out.println("Printing PDF...");
    }
    
    @Override
    public void encrypt(String key) {
        System.out.println("Encrypting PDF with key: " + key);
    }
    
    @Override
    public void decrypt(String key) {
        System.out.println("Decrypting PDF with key: " + key);
    }
}

// Word document with all capabilities
class WordDocument extends Document implements Printable, Editable, Encryptable {
    WordDocument(String title, String author, int pages) {
        super(title, author, pages);
    }
    
    @Override
    void open() {
        System.out.println("Opening Word document: " + title);
    }
    
    @Override
    void close() {
        System.out.println("Closing Word document");
    }
    
    @Override
    public void print() {
        System.out.println("Printing Word document...");
    }
    
    @Override
    public void edit() {
        System.out.println("Editing Word document");
    }
    
    @Override
    public void encrypt(String key) {
        System.out.println("Encrypting document");
    }
    
    @Override
    public void decrypt(String key) {
        System.out.println("Decrypting document");
    }
}

public class CombinedDemo {
    public static void main(String[] args) {
        System.out.println("=== PDF Document ===");
        PDFDocument pdf = new PDFDocument("Java Guide", "John Doe", 500);
        pdf.printInfo();
        pdf.open();
        pdf.encrypt("secret123");
        pdf.print();
        pdf.close();
        
        System.out.println("\n=== Word Document ===");
        WordDocument word = new WordDocument("Report", "Jane Smith", 50);
        word.printInfo();
        word.open();
        word.edit();
        word.print();
        word.close();
    }
}
```

---

## üí° Best Practices

1. ‚úÖ **Favor composition over inheritance**
   ```java
   // Instead of deep inheritance, use interfaces
   class Player implements Movable, Drawable, Collidable { }
   ```

2. ‚úÖ **Use abstract class for template methods**
   ```java
   abstract class GameCharacter {
       final void update() {
           move();
           attack();
           render();
       }
       abstract void move();
       abstract void attack();
   }
   ```

3. ‚úÖ **Use interfaces to define contracts**
   ```java
   interface Repository {
       void save(Object obj);
       Object find(int id);
   }
   ```

4. ‚úÖ **Combine both for flexibility**
   ```java
   abstract class Vehicle { }
   interface Electric { }
   class Tesla extends Vehicle implements Electric { }
   ```

5. ‚úÖ **Keep interfaces focused**
   ```java
   interface Reader { void read(); }
   interface Writer { void write(); }
   // Better than one big interface
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class ComparisonPitfalls {
    // 1. Don't use abstract class just for creating objects
    abstract class OnlyForObjects {
        // If no abstract methods, why abstract?
    }
    
    // 2. Don't create God interfaces (too many methods)
    interface GodInterface {
        void method1();
        void method2();
        // ... 20 more methods
        // Split into smaller interfaces!
    }
    
    // 3. Don't confuse IS-A with CAN-DO
    // Wrong: class Bird extends Flyable { }  // Flyable is capability
    // Right: class Bird implements Flyable { }
    
    // 4. Don't forget default methods can cause conflicts
    interface A {
        default void show() { }
    }
    interface B {
        default void show() { }
    }
    class C implements A, B {
        // Must override show() to resolve conflict!
    }
}
```

---

## üéØ Decision Tree

```
Need to share code?
‚îú‚îÄ YES ‚Üí Consider Abstract Class
‚îÇ  ‚îî‚îÄ Need multiple inheritance?
‚îÇ     ‚îú‚îÄ YES ‚Üí Use Interface + Composition
‚îÇ     ‚îî‚îÄ NO ‚Üí Use Abstract Class
‚îî‚îÄ NO ‚Üí Use Interface
   ‚îî‚îÄ Defining capability?
      ‚îú‚îÄ YES ‚Üí Use Interface
      ‚îî‚îÄ NO ‚Üí Evaluate based on requirements
```

---

## üéØ Interview Questions

1. **Difference between abstract class and interface?**
2. **When to use abstract class vs interface?**
3. **Can interface extend abstract class?**
4. **Can abstract class implement interface?**
5. **Why use interface if abstract class exists?**
6. **What is diamond problem?**
7. **How does Java 8 solve diamond problem?**
8. **Can we have multiple inheritance in Java?**
9. **What are default methods? Why were they added?**
10. **Abstract class vs interface performance?**
11. **Can interface have constructors?**
12. **Can abstract class have static methods?**
13. **What is marker interface?**
14. **What is functional interface?**
15. **Real-world examples of when to use each?**

---

## üìö Related Topics

- [Abstraction](07.%20Abstraction.md)
- [Interfaces](08.%20Interfaces.md)
- [Inheritance](04.%20Inheritance.md)
- [Polymorphism](05.%20Polymorphism.md)
- [Classes & Objects](01.%20Classes%20&%20Objects.md)
