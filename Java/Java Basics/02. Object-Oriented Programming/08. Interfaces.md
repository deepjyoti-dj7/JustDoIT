# üîå Interfaces

## üìñ Overview

**Interface** is a blueprint of a class that contains only abstract methods and constants. It is used to achieve 100% abstraction and multiple inheritance in Java.

**Key Features:**
- All methods are public abstract by default
- All variables are public static final by default
- Cannot have constructors
- Cannot be instantiated
- Class implements interface using `implements` keyword
- From Java 8: can have default and static methods
- From Java 9: can have private methods

---

## üéØ Interface Syntax

```
interface InterfaceName {
    // Constant (public static final)
    datatype VARIABLE_NAME = value;
    
    // Abstract method (public abstract)
    returnType methodName(parameters);
    
    // Default method (Java 8+)
    default returnType methodName() { }
    
    // Static method (Java 8+)
    static returnType methodName() { }
    
    // Private method (Java 9+)
    private returnType methodName() { }
}
```

---

## üíª Example 1: Basic Interface

```java
// Interface definition
interface Animal {
    // Abstract methods (public abstract by default)
    void eat();
    void sleep();
    void makeSound();
}

// Implementing interface
class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("Dog eats bones and meat");
    }
    
    @Override
    public void sleep() {
        System.out.println("Dog sleeps in kennel");
    }
    
    @Override
    public void makeSound() {
        System.out.println("Dog barks: Woof!");
    }
}

class Cat implements Animal {
    @Override
    public void eat() {
        System.out.println("Cat eats fish");
    }
    
    @Override
    public void sleep() {
        System.out.println("Cat sleeps on couch");
    }
    
    @Override
    public void makeSound() {
        System.out.println("Cat meows: Meow!");
    }
}

public class BasicInterfaceDemo {
    public static void main(String[] args) {
        // Cannot instantiate interface
        // Animal animal = new Animal();  // ERROR!
        
        // Create objects of implementing classes
        Animal dog = new Dog();
        dog.eat();
        dog.sleep();
        dog.makeSound();
        
        System.out.println();
        
        Animal cat = new Cat();
        cat.eat();
        cat.sleep();
        cat.makeSound();
    }
}
```

**Output:**
```
Dog eats bones and meat
Dog sleeps in kennel
Dog barks: Woof!

Cat eats fish
Cat sleeps on couch
Cat meows: Meow!
```

---

## üíª Example 2: Interface with Constants

```java
interface Calculator {
    // Constants (public static final by default)
    double PI = 3.14159;
    int MAX_VALUE = 1000;
    
    // Abstract methods
    int add(int a, int b);
    int subtract(int a, int b);
    int multiply(int a, int b);
    double divide(int a, int b);
}

class SimpleCalculator implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
    
    @Override
    public int multiply(int a, int b) {
        return a * b;
    }
    
    @Override
    public double divide(int a, int b) {
        if (b == 0) {
            System.out.println("Cannot divide by zero");
            return 0;
        }
        return (double) a / b;
    }
    
    double calculateCircleArea(double radius) {
        return PI * radius * radius;
    }
}

public class InterfaceConstantsDemo {
    public static void main(String[] args) {
        SimpleCalculator calc = new SimpleCalculator();
        
        System.out.println("Add: " + calc.add(10, 5));
        System.out.println("Subtract: " + calc.subtract(10, 5));
        System.out.println("Multiply: " + calc.multiply(10, 5));
        System.out.println("Divide: " + calc.divide(10, 5));
        
        System.out.println("\nConstants:");
        System.out.println("PI = " + Calculator.PI);
        System.out.println("MAX_VALUE = " + Calculator.MAX_VALUE);
        
        System.out.println("\nCircle Area (radius=5): " + calc.calculateCircleArea(5));
    }
}
```

---

## üíª Example 3: Multiple Interface Implementation

```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

interface Runnable {
    void run();
}

// Implementing multiple interfaces
class Duck implements Flyable, Swimmable, Runnable {
    @Override
    public void fly() {
        System.out.println("Duck flies in the sky");
    }
    
    @Override
    public void swim() {
        System.out.println("Duck swims in the pond");
    }
    
    @Override
    public void run() {
        System.out.println("Duck runs on land");
    }
}

class Penguin implements Swimmable, Runnable {
    @Override
    public void swim() {
        System.out.println("Penguin swims in ocean");
    }
    
    @Override
    public void run() {
        System.out.println("Penguin waddles on ice");
    }
}

public class MultipleInterfacesDemo {
    public static void main(String[] args) {
        System.out.println("=== Duck ===");
        Duck duck = new Duck();
        duck.fly();
        duck.swim();
        duck.run();
        
        System.out.println("\n=== Penguin ===");
        Penguin penguin = new Penguin();
        penguin.swim();
        penguin.run();
        // penguin.fly();  // ERROR - Penguin doesn't implement Flyable
    }
}
```

---

## üíª Example 4: Default Methods (Java 8+)

```java
interface Vehicle {
    // Abstract methods
    void start();
    void stop();
    
    // Default method (with implementation)
    default void horn() {
        System.out.println("Beep beep!");
    }
    
    default void displayInfo() {
        System.out.println("This is a vehicle");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started with key");
    }
    
    @Override
    public void stop() {
        System.out.println("Car stopped");
    }
    
    // Can override default method
    @Override
    public void horn() {
        System.out.println("Car horn: Beep beep beep!");
    }
}

class Bike implements Vehicle {
    @Override
    public void start() {
        System.out.println("Bike started with kick");
    }
    
    @Override
    public void stop() {
        System.out.println("Bike stopped");
    }
    
    // Uses default horn() method from interface
}

public class DefaultMethodDemo {
    public static void main(String[] args) {
        System.out.println("=== Car ===");
        Vehicle car = new Car();
        car.start();
        car.horn();  // Overridden
        car.displayInfo();
        car.stop();
        
        System.out.println("\n=== Bike ===");
        Vehicle bike = new Bike();
        bike.start();
        bike.horn();  // Default implementation
        bike.displayInfo();
        bike.stop();
    }
}
```

---

## üíª Example 5: Static Methods in Interface (Java 8+)

```java
interface MathOperations {
    // Abstract method
    int calculate(int a, int b);
    
    // Static method
    static int square(int n) {
        return n * n;
    }
    
    static int cube(int n) {
        return n * n * n;
    }
    
    static void printWelcome() {
        System.out.println("Welcome to Math Operations!");
    }
}

class Addition implements MathOperations {
    @Override
    public int calculate(int a, int b) {
        return a + b;
    }
}

class Multiplication implements MathOperations {
    @Override
    public int calculate(int a, int b) {
        return a * b;
    }
}

public class StaticMethodDemo {
    public static void main(String[] args) {
        // Call static methods using interface name
        MathOperations.printWelcome();
        System.out.println("Square of 5: " + MathOperations.square(5));
        System.out.println("Cube of 3: " + MathOperations.cube(3));
        
        System.out.println();
        
        MathOperations add = new Addition();
        System.out.println("Addition: " + add.calculate(10, 5));
        // add.square(5);  // ERROR - cannot call static method on object
        
        MathOperations mult = new Multiplication();
        System.out.println("Multiplication: " + mult.calculate(10, 5));
    }
}
```

---

## üíª Example 6: Interface Inheritance

```java
interface Shape {
    double calculateArea();
}

interface ColoredShape extends Shape {
    void setColor(String color);
    String getColor();
}

interface LabeledShape extends Shape {
    void setLabel(String label);
    String getLabel();
}

// Implementing extended interface
class Circle implements ColoredShape, LabeledShape {
    private double radius;
    private String color;
    private String label;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return 3.14 * radius * radius;
    }
    
    @Override
    public void setColor(String color) {
        this.color = color;
    }
    
    @Override
    public String getColor() {
        return color;
    }
    
    @Override
    public void setLabel(String label) {
        this.label = label;
    }
    
    @Override
    public String getLabel() {
        return label;
    }
    
    void displayInfo() {
        System.out.println("Label: " + label);
        System.out.println("Color: " + color);
        System.out.println("Area: " + calculateArea());
    }
}

public class InterfaceInheritanceDemo {
    public static void main(String[] args) {
        Circle circle = new Circle(5);
        circle.setLabel("Circle 1");
        circle.setColor("Red");
        circle.displayInfo();
    }
}
```

---

## üíª Example 7: Payment System with Interfaces

```java
interface Payment {
    boolean processPayment(double amount);
    void refund(double amount);
    String getPaymentMethod();
}

interface SecurePayment extends Payment {
    boolean authenticate(String credentials);
}

class CreditCard implements SecurePayment {
    private String cardNumber;
    private boolean authenticated;
    
    CreditCard(String cardNumber) {
        this.cardNumber = cardNumber;
        this.authenticated = false;
    }
    
    @Override
    public boolean authenticate(String pin) {
        if (pin.equals("1234")) {
            authenticated = true;
            System.out.println("Authentication successful");
            return true;
        }
        System.out.println("Authentication failed");
        return false;
    }
    
    @Override
    public boolean processPayment(double amount) {
        if (!authenticated) {
            System.out.println("Please authenticate first");
            return false;
        }
        System.out.println("Processing $" + amount + " via Credit Card");
        return true;
    }
    
    @Override
    public void refund(double amount) {
        System.out.println("Refunding $" + amount + " to card");
    }
    
    @Override
    public String getPaymentMethod() {
        return "Credit Card";
    }
}

class Cash implements Payment {
    @Override
    public boolean processPayment(double amount) {
        System.out.println("Receiving $" + amount + " in cash");
        return true;
    }
    
    @Override
    public void refund(double amount) {
        System.out.println("Refunding $" + amount + " in cash");
    }
    
    @Override
    public String getPaymentMethod() {
        return "Cash";
    }
}

public class PaymentSystemDemo {
    public static void main(String[] args) {
        System.out.println("=== Credit Card ===");
        SecurePayment cc = new CreditCard("1234-5678-9012-3456");
        System.out.println("Method: " + cc.getPaymentMethod());
        cc.processPayment(100);
        cc.authenticate("1234");
        cc.processPayment(100);
        cc.refund(50);
        
        System.out.println("\n=== Cash ===");
        Payment cash = new Cash();
        System.out.println("Method: " + cash.getPaymentMethod());
        cash.processPayment(50);
    }
}
```

---

## üíª Example 8: Functional Interface

```java
// Functional interface - only one abstract method
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // Can have default methods
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }
    
    // Can have static methods
    static void welcome() {
        System.out.println("Calculator ready!");
    }
}

public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        Calculator.welcome();
        
        // Lambda expression for addition
        Calculator add = (a, b) -> a + b;
        int sum = add.calculate(10, 5);
        add.printResult(sum);
        
        // Lambda expression for multiplication
        Calculator multiply = (a, b) -> a * b;
        int product = multiply.calculate(10, 5);
        multiply.printResult(product);
        
        // Lambda expression for subtraction
        Calculator subtract = (a, b) -> a - b;
        subtract.printResult(subtract.calculate(10, 5));
    }
}
```

---

## üíª Example 9: Marker Interface

```java
// Marker interface (empty interface)
interface Serializable {
    // No methods - just marks the class
}

interface Cloneable {
    // No methods
}

class Student implements Serializable, Cloneable {
    String name;
    int rollNo;
    
    Student(String name, int rollNo) {
        this.name = name;
        this.rollNo = rollNo;
    }
    
    void saveToFile() {
        if (this instanceof Serializable) {
            System.out.println("Student can be serialized");
            System.out.println("Saving to file...");
        }
    }
    
    Student createCopy() {
        if (this instanceof Cloneable) {
            System.out.println("Student can be cloned");
            return new Student(this.name, this.rollNo);
        }
        return null;
    }
    
    void display() {
        System.out.println("Name: " + name + ", Roll: " + rollNo);
    }
}

public class MarkerInterfaceDemo {
    public static void main(String[] args) {
        Student s1 = new Student("Alice", 101);
        s1.display();
        s1.saveToFile();
        
        System.out.println();
        
        Student s2 = s1.createCopy();
        s2.display();
    }
}
```

---

## üíª Example 10: Real-World Database Interface

```java
interface Database {
    void connect(String url);
    void disconnect();
    boolean executeQuery(String query);
    
    default void printStatus(String status) {
        System.out.println("Status: " + status);
    }
}

class MySQLDatabase implements Database {
    private boolean connected = false;
    
    @Override
    public void connect(String url) {
        System.out.println("Connecting to MySQL: " + url);
        connected = true;
        printStatus("Connected to MySQL");
    }
    
    @Override
    public void disconnect() {
        System.out.println("Disconnecting from MySQL");
        connected = false;
        printStatus("Disconnected");
    }
    
    @Override
    public boolean executeQuery(String query) {
        if (!connected) {
            System.out.println("Not connected to database");
            return false;
        }
        System.out.println("Executing MySQL query: " + query);
        return true;
    }
}

class MongoDatabase implements Database {
    private boolean connected = false;
    
    @Override
    public void connect(String url) {
        System.out.println("Connecting to MongoDB: " + url);
        connected = true;
        printStatus("Connected to MongoDB");
    }
    
    @Override
    public void disconnect() {
        System.out.println("Disconnecting from MongoDB");
        connected = false;
        printStatus("Disconnected");
    }
    
    @Override
    public boolean executeQuery(String query) {
        if (!connected) {
            System.out.println("Not connected to database");
            return false;
        }
        System.out.println("Executing MongoDB query: " + query);
        return true;
    }
}

public class DatabaseDemo {
    public static void main(String[] args) {
        System.out.println("=== MySQL ===");
        Database mysql = new MySQLDatabase();
        mysql.connect("localhost:3306/mydb");
        mysql.executeQuery("SELECT * FROM users");
        mysql.disconnect();
        
        System.out.println("\n=== MongoDB ===");
        Database mongo = new MongoDatabase();
        mongo.connect("localhost:27017/mydb");
        mongo.executeQuery("db.users.find()");
        mongo.disconnect();
    }
}
```

---

## üìä Interface Characteristics

| Feature | Interface |
|---------|-----------|
| **Methods** | Abstract (default), default (Java 8+), static (Java 8+), private (Java 9+) |
| **Variables** | public static final only |
| **Constructors** | Not allowed |
| **Instantiation** | Cannot instantiate |
| **Multiple Inheritance** | Yes (class can implement multiple interfaces) |
| **Access Modifiers** | public or default for interface itself |
| **Keyword** | `implements` |

---

## üìä Interface Evolution (Java 8 & 9)

| Version | Feature | Example |
|---------|---------|---------|
| **Before Java 8** | Only abstract methods | `void method();` |
| **Java 8** | Default methods | `default void method() { }` |
| **Java 8** | Static methods | `static void method() { }` |
| **Java 9** | Private methods | `private void helper() { }` |

---

## üí° Best Practices

1. ‚úÖ **Use interfaces to define contracts**
   ```java
   interface PaymentProcessor {
       boolean process(double amount);
   }
   ```

2. ‚úÖ **Name interfaces as adjectives or nouns**
   ```java
   interface Runnable, Serializable, Comparable
   ```

3. ‚úÖ **Keep interfaces focused and cohesive**
   ```java
   interface Readable { }
   interface Writable { }
   // Better than one interface with both
   ```

4. ‚úÖ **Use functional interfaces for lambdas**
   ```java
   @FunctionalInterface
   interface Operation {
       int apply(int a, int b);
   }
   ```

5. ‚úÖ **Program to interface, not implementation**
   ```java
   List<String> list = new ArrayList<>();  // Good
   // ArrayList<String> list = new ArrayList<>();  // Less flexible
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class InterfacePitfalls {
    // 1. Cannot instantiate interface
    interface Test { }
    // Test t = new Test();  // ERROR!
    
    // 2. All interface variables are public static final
    interface Constants {
        int VALUE = 10;  // Cannot be changed
        // VALUE = 20;  // ERROR!
    }
    
    // 3. Cannot have constructors
    interface Wrong {
        // Wrong() { }  // ERROR!
    }
    
    // 4. Methods must be public in implementation
    interface MyInterface {
        void method();
    }
    class MyClass implements MyInterface {
        // void method() { }  // ERROR - must be public
        public void method() { }  // Correct
    }
    
    // 5. Must implement all abstract methods
    interface Multi {
        void method1();
        void method2();
    }
    class Incomplete implements Multi {
        public void method1() { }
        // ERROR - must implement method2() too
    }
}
```

---

## üéØ Interview Questions

1. **What is an interface?**
2. **Difference between interface and abstract class?**
3. **Can interface have constructors?**
4. **Can interface have instance variables?**
5. **What are default methods in interface?**
6. **What are static methods in interface?**
7. **Can interface extend another interface?**
8. **Can class implement multiple interfaces?**
9. **What is marker interface?**
10. **What is functional interface?**
11. **Can interface have private methods?**
12. **Why use interfaces?**
13. **What are rules for interface methods?**
14. **Can interface methods be private/protected?**
15. **Real-world examples of interfaces?**

---

## üìö Related Topics

- [Abstraction](07.%20Abstraction.md)
- [Abstract Classes vs Interfaces](09.%20Abstract%20Classes%20vs%20Interfaces.md)
- [Polymorphism](05.%20Polymorphism.md)
- [Inheritance](04.%20Inheritance.md)
- [Classes & Objects](01.%20Classes%20&%20Objects.md)
