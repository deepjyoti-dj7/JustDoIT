# üîß Methods & Method Overloading

## üìñ Overview

**Methods** are blocks of code that perform specific tasks and can be called/invoked to execute that code.

**Key Concepts:**
- Method declaration and definition
- Parameters and return types
- Method overloading
- Variable arguments (varargs)
- Pass by value

---

## üéØ Method Structure

```
returnType methodName(parameters) {
    // method body
    return value;  // if returnType is not void
}

Components:
1. Return Type: What the method returns (int, String, void, etc.)
2. Method Name: Identifier for the method
3. Parameters: Input values (optional)
4. Method Body: Code to execute
5. Return Statement: Returns value to caller
```

---

## üíª Example 1: Basic Methods

```java
class Calculator {
    // Method with no parameters, no return
    void greet() {
        System.out.println("Welcome to Calculator!");
    }
    
    // Method with parameters, with return
    int add(int a, int b) {
        return a + b;
    }
    
    // Method with parameters, no return
    void printSum(int a, int b) {
        int sum = a + b;
        System.out.println("Sum: " + sum);
    }
    
    // Method with no parameters, with return
    double getPi() {
        return 3.14159;
    }
}

public class BasicMethodsDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Call method with no parameters, no return
        calc.greet();
        
        // Call method with parameters, with return
        int result = calc.add(10, 20);
        System.out.println("Result: " + result);
        
        // Call method with parameters, no return
        calc.printSum(15, 25);
        
        // Call method with no parameters, with return
        double pi = calc.getPi();
        System.out.println("Pi: " + pi);
    }
}
```

---

## üíª Example 2: Method Overloading - Same Name, Different Parameters

```java
class MathOperations {
    // Overloaded add methods
    
    // Method 1: Two int parameters
    int add(int a, int b) {
        System.out.println("add(int, int) called");
        return a + b;
    }
    
    // Method 2: Three int parameters
    int add(int a, int b, int c) {
        System.out.println("add(int, int, int) called");
        return a + b + c;
    }
    
    // Method 3: Two double parameters
    double add(double a, double b) {
        System.out.println("add(double, double) called");
        return a + b;
    }
    
    // Method 4: Different order of parameters
    String add(int a, String b) {
        System.out.println("add(int, String) called");
        return a + b;
    }
    
    String add(String a, int b) {
        System.out.println("add(String, int) called");
        return a + b;
    }
}

public class MethodOverloadingDemo {
    public static void main(String[] args) {
        MathOperations math = new MathOperations();
        
        // Different methods called based on arguments
        System.out.println("Result: " + math.add(5, 10));
        System.out.println();
        
        System.out.println("Result: " + math.add(5, 10, 15));
        System.out.println();
        
        System.out.println("Result: " + math.add(5.5, 10.5));
        System.out.println();
        
        System.out.println("Result: " + math.add(5, "Hello"));
        System.out.println();
        
        System.out.println("Result: " + math.add("Hello", 5));
    }
}
```

**Output:**
```
add(int, int) called
Result: 15

add(int, int, int) called
Result: 30

add(double, double) called
Result: 16.0

add(int, String) called
Result: 5Hello

add(String, int) called
Result: Hello5
```

---

## üíª Example 3: Method Overloading Rules

```java
class OverloadingRules {
    // Valid overloading - different number of parameters
    void display(int a) {
        System.out.println("One int: " + a);
    }
    
    void display(int a, int b) {
        System.out.println("Two ints: " + a + ", " + b);
    }
    
    // Valid overloading - different type of parameters
    void display(String a) {
        System.out.println("String: " + a);
    }
    
    // Valid overloading - different order of parameters
    void display(int a, String b) {
        System.out.println("Int and String: " + a + ", " + b);
    }
    
    void display(String a, int b) {
        System.out.println("String and Int: " + a + ", " + b);
    }
    
    // INVALID overloading - different return type only
    // int display(int a) {  // ERROR! Same signature as first method
    //     return a;
    // }
    
    // INVALID overloading - different parameter names only
    // void display(int x) {  // ERROR! Same signature as first method
    //     System.out.println(x);
    // }
}

public class OverloadingRulesDemo {
    public static void main(String[] args) {
        OverloadingRules obj = new Object();
        
        obj.display(10);
        obj.display(10, 20);
        obj.display("Hello");
        obj.display(10, "World");
        obj.display("Java", 8);
        
        System.out.println("\nKey Points:");
        System.out.println("‚úì Different number of parameters");
        System.out.println("‚úì Different types of parameters");
        System.out.println("‚úì Different order of parameters");
        System.out.println("‚úó Different return type only");
        System.out.println("‚úó Different parameter names only");
    }
}
```

---

## üíª Example 4: Variable Arguments (Varargs)

```java
class VarargsExample {
    // Varargs method - accepts any number of arguments
    int sum(int... numbers) {
        System.out.println("Number of arguments: " + numbers.length);
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
    
    // Varargs with other parameters
    void display(String message, int... numbers) {
        System.out.println(message);
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
    
    // Overloading with varargs
    void print(int... nums) {
        System.out.println("Varargs method");
    }
    
    void print(int a, int b) {
        System.out.println("Two parameters method");
    }
}

public class VarargsDemo {
    public static void main(String[] args) {
        VarargsExample obj = new VarargsExample();
        
        // Call with different number of arguments
        System.out.println("Sum: " + obj.sum(5));
        System.out.println("Sum: " + obj.sum(5, 10));
        System.out.println("Sum: " + obj.sum(5, 10, 15));
        System.out.println("Sum: " + obj.sum(5, 10, 15, 20, 25));
        System.out.println("Sum: " + obj.sum());  // Zero arguments
        
        System.out.println();
        
        // With message
        obj.display("Numbers:", 1, 2, 3, 4, 5);
        obj.display("Even numbers:", 2, 4, 6, 8);
        
        System.out.println();
        
        // Overloading resolution
        obj.print(10, 20);  // Calls two parameters method (more specific)
        obj.print(10, 20, 30);  // Calls varargs method
    }
}
```

---

## üíª Example 5: Return Types

```java
class ReturnTypes {
    // Return int
    int getAge() {
        return 25;
    }
    
    // Return String
    String getName() {
        return "John Doe";
    }
    
    // Return boolean
    boolean isEligible(int age) {
        return age >= 18;
    }
    
    // Return array
    int[] getNumbers() {
        return new int[]{1, 2, 3, 4, 5};
    }
    
    // Return object
    Person getPerson() {
        Person p = new Person();
        p.name = "Alice";
        p.age = 30;
        return p;
    }
    
    // Return void (no return)
    void printMessage() {
        System.out.println("Hello!");
        // No return statement needed
    }
    
    // Multiple return statements
    String getGrade(int marks) {
        if (marks >= 90) return "A";
        else if (marks >= 80) return "B";
        else if (marks >= 70) return "C";
        else if (marks >= 60) return "D";
        else return "F";
    }
}

class Person {
    String name;
    int age;
}

public class ReturnTypesDemo {
    public static void main(String[] args) {
        ReturnTypes obj = new ReturnTypes();
        
        int age = obj.getAge();
        System.out.println("Age: " + age);
        
        String name = obj.getName();
        System.out.println("Name: " + name);
        
        boolean eligible = obj.isEligible(20);
        System.out.println("Eligible: " + eligible);
        
        int[] numbers = obj.getNumbers();
        System.out.print("Numbers: ");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        Person person = obj.getPerson();
        System.out.println("Person: " + person.name + ", " + person.age);
        
        obj.printMessage();
        
        String grade = obj.getGrade(85);
        System.out.println("Grade: " + grade);
    }
}
```

---

## üíª Example 6: Pass by Value

```java
class PassByValue {
    // Primitive types - pass by value
    void modifyPrimitive(int x) {
        x = x * 2;
        System.out.println("Inside method: " + x);
    }
    
    // Reference types - pass by value (of reference)
    void modifyObject(StringBuilder sb) {
        sb.append(" World");
        System.out.println("Inside method: " + sb);
    }
    
    // Reassigning reference doesn't affect original
    void reassignObject(StringBuilder sb) {
        sb = new StringBuilder("New String");
        System.out.println("Inside method: " + sb);
    }
}

public class PassByValueDemo {
    public static void main(String[] args) {
        PassByValue obj = new PassByValue();
        
        // Primitive type
        System.out.println("=== Primitive Type ===");
        int num = 10;
        System.out.println("Before: " + num);
        obj.modifyPrimitive(num);
        System.out.println("After: " + num);  // Unchanged
        
        // Reference type - modify object
        System.out.println("\n=== Reference Type (Modify) ===");
        StringBuilder sb1 = new StringBuilder("Hello");
        System.out.println("Before: " + sb1);
        obj.modifyObject(sb1);
        System.out.println("After: " + sb1);  // Changed
        
        // Reference type - reassign
        System.out.println("\n=== Reference Type (Reassign) ===");
        StringBuilder sb2 = new StringBuilder("Original");
        System.out.println("Before: " + sb2);
        obj.reassignObject(sb2);
        System.out.println("After: " + sb2);  // Unchanged
        
        System.out.println("\nKey Point: Java is always pass-by-value!");
    }
}
```

---

## üíª Example 7: Static vs Instance Methods

```java
class MethodTypes {
    static int staticVar = 10;
    int instanceVar = 20;
    
    // Static method - belongs to class
    static void staticMethod() {
        System.out.println("Static method called");
        System.out.println("Static var: " + staticVar);
        // System.out.println(instanceVar);  // ERROR! Can't access instance variable
        // instanceMethod();  // ERROR! Can't call instance method
    }
    
    // Instance method - belongs to object
    void instanceMethod() {
        System.out.println("Instance method called");
        System.out.println("Instance var: " + instanceVar);
        System.out.println("Static var: " + staticVar);  // OK
        staticMethod();  // OK
    }
}

public class StaticVsInstanceDemo {
    public static void main(String[] args) {
        // Static method - call using class name
        MethodTypes.staticMethod();
        
        System.out.println();
        
        // Instance method - requires object
        MethodTypes obj = new MethodTypes();
        obj.instanceMethod();
        
        // Can also call static method using object (not recommended)
        obj.staticMethod();
    }
}
```

---

## üíª Example 8: Method with Array Parameters

```java
class ArrayMethods {
    // Method accepting array
    int findMax(int[] arr) {
        int max = arr[0];
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
        }
        return max;
    }
    
    // Method returning array
    int[] getEvenNumbers(int n) {
        int[] evens = new int[n];
        for (int i = 0; i < n; i++) {
            evens[i] = (i + 1) * 2;
        }
        return evens;
    }
    
    // Method modifying array
    void doubleValues(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            arr[i] *= 2;
        }
    }
    
    // Varargs with array operations
    double average(int... numbers) {
        if (numbers.length == 0) return 0;
        
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return (double) sum / numbers.length;
    }
}

public class ArrayMethodsDemo {
    public static void main(String[] args) {
        ArrayMethods obj = new ArrayMethods();
        
        // Find max
        int[] numbers = {5, 12, 8, 20, 3};
        int max = obj.findMax(numbers);
        System.out.println("Max: " + max);
        
        // Get even numbers
        int[] evens = obj.getEvenNumbers(5);
        System.out.print("Even numbers: ");
        for (int num : evens) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // Double values
        System.out.print("Before doubling: ");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        obj.doubleValues(numbers);
        System.out.print("After doubling: ");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // Average
        double avg = obj.average(10, 20, 30, 40, 50);
        System.out.println("Average: " + avg);
    }
}
```

---

## üìä Method Overloading vs Method Overriding

| Feature | Method Overloading | Method Overriding |
|---------|-------------------|-------------------|
| **Definition** | Same method name, different parameters | Same method signature in subclass |
| **Where** | Same class | Parent and child class |
| **Parameters** | Must be different | Must be same |
| **Return type** | Can be different | Must be same or covariant |
| **Polymorphism** | Compile-time | Runtime |
| **Purpose** | Multiple ways to call method | Change parent behavior |

---

## üìä Method Overloading Resolution

| Scenario | Example | Method Called |
|----------|---------|---------------|
| **Exact match** | `method(5, 10)` with `method(int, int)` | Exact match |
| **Widening** | `method(5)` with `method(double)` | Widened to double |
| **Autoboxing** | `method(5)` with `method(Integer)` | Autoboxed to Integer |
| **Varargs** | `method(1, 2, 3)` with `method(int...)` | Varargs (last resort) |

---

## üí° Best Practices

1. ‚úÖ **Use descriptive method names**
   ```java
   // Good
   double calculateSalary(int hours, double rate) { }
   
   // Bad
   double calc(int a, double b) { }
   ```

2. ‚úÖ **Keep methods short and focused**
   ```java
   // Good: One responsibility
   boolean isEligible(int age) {
       return age >= 18;
   }
   ```

3. ‚úÖ **Overload methods logically**
   ```java
   void print(String s) { }
   void print(int i) { }
   void print(double d) { }
   ```

4. ‚úÖ **Use varargs when appropriate**
   ```java
   int sum(int... numbers) {
       // Works with any number of arguments
   }
   ```

5. ‚úÖ **Validate parameters**
   ```java
   int divide(int a, int b) {
       if (b == 0) throw new IllegalArgumentException();
       return a / b;
   }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class MethodPitfalls {
    // 1. Ambiguous overloading
    void method(int a, double b) { }
    void method(double a, int b) { }
    // method(5, 5);  // ERROR! Ambiguous
    
    // 2. Confusing overloading with overriding
    class Parent {
        void display(int a) { }
    }
    class Child extends Parent {
        void display(double a) { }  // Overloading, NOT overriding!
    }
    
    // 3. Modifying primitive parameters
    void modify(int x) {
        x = 100;  // Doesn't affect original
    }
    
    // 4. Varargs must be last parameter
    // void method(int... a, String b) { }  // ERROR!
    void method(String b, int... a) { }  // OK
    
    // 5. Return type not considered in overloading
    // void print(int a) { }
    // int print(int a) { }  // ERROR! Same signature
}
```

---

## üéØ Interview Questions

1. **What is a method in Java?**
2. **What is method signature?**
3. **What is method overloading?**
4. **Rules for method overloading?**
5. **Can we overload main method?**
6. **What is varargs?**
7. **Can we have multiple varargs parameters?**
8. **What is pass by value?**
9. **Does Java support pass by reference?**
10. **Difference between method overloading and overriding?**
11. **Can we overload methods with different return types only?**
12. **What is the use of return statement?**
13. **Can we change return type in overloaded methods?**
14. **What happens if method doesn't return value?**
15. **Can static methods be overloaded?**

---

## üìö Related Topics

- [Classes & Objects](01.%20Classes%20%26%20Objects.md)
- [Constructors](02.%20Constructors.md)
- [Polymorphism](05.%20Polymorphism.md)
- [Static Keyword](../03.%20Advanced%20OOP%20Concepts/01.%20Static%20Keyword.md)
- [Inheritance](04.%20Inheritance.md)
