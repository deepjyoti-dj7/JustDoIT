# üîÑ Polymorphism

## üìñ Overview

**Polymorphism** means "many forms" - the ability of an object to take many forms. It allows one interface to be used for different data types.

**Key Concepts:**
- Compile-time polymorphism (Method Overloading)
- Runtime polymorphism (Method Overriding)
- Dynamic method dispatch
- Upcasting and downcasting
- instanceof operator

---

## üéØ Types of Polymorphism

```
1. Compile-time Polymorphism (Static Binding)
   - Method Overloading
   - Operator Overloading (not in Java)
   - Decided at compile time
   
2. Runtime Polymorphism (Dynamic Binding)
   - Method Overriding
   - Decided at runtime
   - Uses inheritance
```

---

## üíª Example 1: Compile-time Polymorphism (Method Overloading)

```java
class Calculator {
    // Method overloading - same name, different parameters
    int add(int a, int b) {
        return a + b;
    }
    
    int add(int a, int b, int c) {
        return a + b + c;
    }
    
    double add(double a, double b) {
        return a + b;
    }
}

public class CompileTimePolymorphismDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Compiler decides which method to call based on arguments
        System.out.println("add(5, 10): " + calc.add(5, 10));
        System.out.println("add(5, 10, 15): " + calc.add(5, 10, 15));
        System.out.println("add(5.5, 10.5): " + calc.add(5.5, 10.5));
        
        System.out.println("\nDecision made at compile-time");
    }
}
```

---

## üíª Example 2: Runtime Polymorphism (Method Overriding)

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Cat meows");
    }
}

public class RuntimePolymorphismDemo {
    public static void main(String[] args) {
        // Parent reference, child objects
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();
        Animal animal3 = new Animal();
        
        // Method called depends on actual object type (runtime decision)
        animal1.makeSound();  // Dog barks
        animal2.makeSound();  // Cat meows
        animal3.makeSound();  // Animal makes a sound
        
        System.out.println("\nDecision made at runtime");
    }
}
```

---

## üíª Example 3: Dynamic Method Dispatch

```java
class Shape {
    void draw() {
        System.out.println("Drawing shape");
    }
    
    double calculateArea() {
        return 0;
    }
}

class Circle extends Shape {
    double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    void draw() {
        System.out.println("Drawing circle");
    }
    
    @Override
    double calculateArea() {
        return 3.14 * radius * radius;
    }
}

class Rectangle extends Shape {
    double length, width;
    
    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    void draw() {
        System.out.println("Drawing rectangle");
    }
    
    @Override
    double calculateArea() {
        return length * width;
    }
}

public class DynamicMethodDispatchDemo {
    public static void main(String[] args) {
        // Array of parent type holding child objects
        Shape[] shapes = new Shape[3];
        shapes[0] = new Circle(5);
        shapes[1] = new Rectangle(10, 5);
        shapes[2] = new Shape();
        
        // Polymorphic behavior
        for (Shape shape : shapes) {
            shape.draw();
            System.out.println("Area: " + shape.calculateArea());
            System.out.println();
        }
    }
}
```

---

## üíª Example 4: Upcasting and Downcasting

```java
class Parent {
    void parentMethod() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    void childMethod() {
        System.out.println("Child method");
    }
    
    @Override
    void parentMethod() {
        System.out.println("Child's overridden parent method");
    }
}

public class CastingDemo {
    public static void main(String[] args) {
        // Upcasting (implicit)
        System.out.println("=== Upcasting ===");
        Parent parent = new Child();  // Automatic
        parent.parentMethod();  // Calls Child's version
        // parent.childMethod();  // ERROR! Parent reference can't see child-specific methods
        
        // Downcasting (explicit)
        System.out.println("\n=== Downcasting ===");
        if (parent instanceof Child) {
            Child child = (Child) parent;  // Manual cast
            child.childMethod();  // Now we can call child-specific methods
            child.parentMethod();
        }
        
        // Invalid downcasting
        System.out.println("\n=== Invalid Downcasting ===");
        Parent parent2 = new Parent();
        if (parent2 instanceof Child) {
            Child child2 = (Child) parent2;
        } else {
            System.out.println("parent2 is not an instance of Child");
        }
    }
}
```

---

## üíª Example 5: instanceof Operator

```java
class Vehicle { }
class Car extends Vehicle { }
class ElectricCar extends Car { }

public class InstanceofDemo {
    public static void main(String[] args) {
        Vehicle v = new Car();
        
        // Check instance type
        System.out.println("v instanceof Vehicle: " + (v instanceof Vehicle));
        System.out.println("v instanceof Car: " + (v instanceof Car));
        System.out.println("v instanceof ElectricCar: " + (v instanceof ElectricCar));
        
        System.out.println();
        
        // Safe casting using instanceof
        if (v instanceof Car) {
            Car car = (Car) v;
            System.out.println("Safely cast to Car");
        }
        
        if (v instanceof ElectricCar) {
            ElectricCar eCar = (ElectricCar) v;
            System.out.println("Safely cast to ElectricCar");
        } else {
            System.out.println("Not an ElectricCar");
        }
        
        // Real object check
        ElectricCar ec = new ElectricCar();
        System.out.println("\nec instanceof Vehicle: " + (ec instanceof Vehicle));
        System.out.println("ec instanceof Car: " + (ec instanceof Car));
        System.out.println("ec instanceof ElectricCar: " + (ec instanceof ElectricCar));
    }
}
```

---

## üíª Example 6: Real-World Example - Payment Processing

```java
abstract class Payment {
    protected double amount;
    
    Payment(double amount) {
        this.amount = amount;
    }
    
    abstract void processPayment();
    
    void displayAmount() {
        System.out.println("Amount: $" + amount);
    }
}

class CreditCardPayment extends Payment {
    String cardNumber;
    
    CreditCardPayment(double amount, String cardNumber) {
        super(amount);
        this.cardNumber = cardNumber;
    }
    
    @Override
    void processPayment() {
        System.out.println("Processing credit card payment");
        System.out.println("Card: " + cardNumber);
        displayAmount();
    }
}

class PayPalPayment extends Payment {
    String email;
    
    PayPalPayment(double amount, String email) {
        super(amount);
        this.email = email;
    }
    
    @Override
    void processPayment() {
        System.out.println("Processing PayPal payment");
        System.out.println("Email: " + email);
        displayAmount();
    }
}

class CashPayment extends Payment {
    CashPayment(double amount) {
        super(amount);
    }
    
    @Override
    void processPayment() {
        System.out.println("Processing cash payment");
        displayAmount();
    }
}

public class PaymentDemo {
    // Polymorphic method
    static void makePayment(Payment payment) {
        payment.processPayment();
        System.out.println("Payment completed!\n");
    }
    
    public static void main(String[] args) {
        // Different payment types, same interface
        Payment payment1 = new CreditCardPayment(100, "1234-5678-9012-3456");
        Payment payment2 = new PayPalPayment(50, "user@email.com");
        Payment payment3 = new CashPayment(75);
        
        makePayment(payment1);
        makePayment(payment2);
        makePayment(payment3);
    }
}
```

---

## üíª Example 7: Covariant Return Type

```java
class Animal {
    Animal reproduce() {
        System.out.println("Animal reproduces");
        return new Animal();
    }
}

class Dog extends Animal {
    // Covariant return type - return type is subclass of parent's return type
    @Override
    Dog reproduce() {
        System.out.println("Dog reproduces");
        return new Dog();
    }
}

public class CovariantReturnTypeDemo {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Animal newAnimal = animal.reproduce();
        
        System.out.println();
        
        Dog dog = new Dog();
        Dog newDog = dog.reproduce();  // Returns Dog, not Animal
        
        System.out.println("\nCovariant return type allows subclass return type");
    }
}
```

---

## üíª Example 8: Overriding Rules

```java
class Parent {
    // Public method
    public void publicMethod() {
        System.out.println("Parent public method");
    }
    
    // Protected method
    protected void protectedMethod() {
        System.out.println("Parent protected method");
    }
    
    // Final method - cannot be overridden
    final void finalMethod() {
        System.out.println("Parent final method");
    }
    
    // Static method - not overridden, but hidden
    static void staticMethod() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    // Can override with same or wider access modifier
    @Override
    public void publicMethod() {
        System.out.println("Child public method");
    }
    
    // Can make protected method public
    @Override
    public void protectedMethod() {
        System.out.println("Child protected method (now public)");
    }
    
    // Cannot override final method
    // void finalMethod() { }  // ERROR!
    
    // This is method hiding, not overriding
    static void staticMethod() {
        System.out.println("Child static method");
    }
}

public class OverridingRulesDemo {
    public static void main(String[] args) {
        Parent parent = new Child();
        parent.publicMethod();
        parent.protectedMethod();
        parent.finalMethod();
        
        // Static methods - called based on reference type, not object type
        parent.staticMethod();  // Parent's version
        Child.staticMethod();   // Child's version
    }
}
```

---

## üìä Compile-time vs Runtime Polymorphism

| Feature | Compile-time | Runtime |
|---------|--------------|---------|
| **Also known as** | Static binding, Early binding | Dynamic binding, Late binding |
| **Achieved by** | Method overloading | Method overriding |
| **Inheritance** | Not required | Required |
| **Performance** | Faster (decided at compile-time) | Slower (decided at runtime) |
| **Example** | `add(int, int)`, `add(double, double)` | Parent ref = new Child() |
| **Flexibility** | Less flexible | More flexible |

---

## üìä Method Overloading vs Overriding

| Feature | Overloading | Overriding |
|---------|-------------|------------|
| **Where** | Same class | Parent-child class |
| **Parameters** | Must be different | Must be same |
| **Return type** | Can be different | Same or covariant |
| **Access modifier** | Can be any | Same or wider |
| **Polymorphism type** | Compile-time | Runtime |
| **Inheritance** | Not required | Required |
| **static methods** | Can be overloaded | Cannot be overridden (hidden) |
| **final methods** | Can be overloaded | Cannot be overridden |

---

## üí° Best Practices

1. ‚úÖ **Use @Override annotation**
   ```java
   @Override
   void method() { }  // Catches errors
   ```

2. ‚úÖ **Program to interface/superclass**
   ```java
   List<String> list = new ArrayList<>();  // Not ArrayList list = ...
   ```

3. ‚úÖ **Use instanceof before downcasting**
   ```java
   if (obj instanceof Child) {
       Child child = (Child) obj;
   }
   ```

4. ‚úÖ **Follow Liskov Substitution Principle**
   ```java
   // Child should be substitutable for parent
   ```

5. ‚úÖ **Keep overridden methods consistent with parent**
   ```java
   // Don't change expected behavior
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class PolymorphismPitfalls {
    // 1. Static methods are not polymorphic
    class Parent {
        static void display() {
            System.out.println("Parent");
        }
    }
    class Child extends Parent {
        static void display() {
            System.out.println("Child");
        }
    }
    // Parent ref = new Child();
    // ref.display();  // Prints "Parent" (not polymorphic!)
    
    // 2. Private methods cannot be overridden
    class Base {
        private void method() { }
    }
    class Derived extends Base {
        void method() { }  // New method, not override!
    }
    
    // 3. Constructor chaining confusion
    class A {
        A() {
            display();  // Calls overridden method!
        }
        void display() {
            System.out.println("A");
        }
    }
    class B extends A {
        int x = 5;
        void display() {
            System.out.println("x = " + x);  // x is 0 here!
        }
    }
    
    // 4. ClassCastException
    void riskyCode() {
        Parent p = new Parent();
        // Child c = (Child) p;  // Runtime error!
    }
}
```

---

## üéØ Interview Questions

1. **What is polymorphism?**
2. **Types of polymorphism in Java?**
3. **Difference between overloading and overriding?**
4. **What is dynamic method dispatch?**
5. **Can we override static methods?**
6. **Can we override private methods?**
7. **Can we override final methods?**
8. **What is upcasting?**
9. **What is downcasting?**
10. **What is the instanceof operator?**
11. **What is covariant return type?**
12. **Can we change return type in overriding?**
13. **Can we change access modifier in overriding?**
14. **What is method hiding?**
15. **Compile-time vs runtime polymorphism?**

---

## üìö Related Topics

- [Methods & Method Overloading](03.%20Methods%20%26%20Method%20Overloading.md)
- [Inheritance](04.%20Inheritance.md)
- [Abstraction](07.%20Abstraction.md)
- [Interfaces](08.%20Interfaces.md)
- [Final Keyword](../03.%20Advanced%20OOP%20Concepts/02.%20Final%20Keyword.md)
