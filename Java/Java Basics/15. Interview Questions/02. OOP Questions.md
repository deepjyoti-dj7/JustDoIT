# ðŸŽ¯ OOP Questions

## ðŸ“– Object-Oriented Programming

### Q1: What are the four pillars of OOP?

**Answer:**

**1. Encapsulation** - Bundling data and methods
```java
class Account {
    private double balance;  // Hidden
    
    public void deposit(double amount) {  // Controlled access
        if (amount > 0) balance += amount;
    }
    
    public double getBalance() {
        return balance;
    }
}
```

**2. Inheritance** - Acquiring properties from parent
```java
class Animal {
    void eat() { System.out.println("Eating"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Barking"); }
}
```

**3. Polymorphism** - Many forms
```java
// Method overloading
void print(int x) { }
void print(String x) { }

// Method overriding
class Animal { void sound() { } }
class Dog extends Animal { 
    @Override void sound() { System.out.println("Bark"); }
}
```

**4. Abstraction** - Hiding implementation
```java
abstract class Shape {
    abstract double area();  // Hide implementation
}

class Circle extends Shape {
    double radius;
    double area() { return Math.PI * radius * radius; }
}
```

---

### Q2: What is encapsulation? Why is it important?

**Answer:** Hiding internal state and requiring access through methods.

**Benefits:**
- Data protection
- Flexibility to change implementation
- Easier maintenance
- Controlled access

```java
// Bad - No encapsulation
class User {
    public String password;  // Direct access
}

// Good - Encapsulated
class User {
    private String password;
    
    public void setPassword(String pwd) {
        if (pwd.length() >= 8) {  // Validation
            this.password = encrypt(pwd);
        }
    }
    
    public boolean verifyPassword(String pwd) {
        return encrypt(pwd).equals(password);
    }
    
    private String encrypt(String pwd) {
        // Encryption logic
        return pwd;
    }
}
```

---

### Q3: Explain inheritance with types

**Answer:** Mechanism where class acquires properties of another class.

**Types:**

**1. Single Inheritance**
```java
class Animal { }
class Dog extends Animal { }
```

**2. Multilevel Inheritance**
```java
class Animal { }
class Mammal extends Animal { }
class Dog extends Mammal { }
```

**3. Hierarchical Inheritance**
```java
class Animal { }
class Dog extends Animal { }
class Cat extends Animal { }
```

**4. Multiple Inheritance (via interfaces)**
```java
interface Flyable { void fly(); }
interface Swimmable { void swim(); }
class Duck implements Flyable, Swimmable {
    public void fly() { }
    public void swim() { }
}
```

**Note:** Java doesn't support multiple inheritance with classes (Diamond Problem).

---

### Q4: What is polymorphism? Explain compile-time vs runtime

**Answer:** Ability of object to take many forms.

**Compile-time (Static) - Method Overloading**
```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}

Calculator calc = new Calculator();
calc.add(5, 10);        // Calls int version
calc.add(5.5, 10.5);    // Calls double version
```

**Runtime (Dynamic) - Method Overriding**
```java
class Shape {
    void draw() { System.out.println("Drawing shape"); }
}

class Circle extends Shape {
    @Override
    void draw() { System.out.println("Drawing circle"); }
}

class Rectangle extends Shape {
    @Override
    void draw() { System.out.println("Drawing rectangle"); }
}

// Runtime polymorphism
Shape shape = new Circle();  // Decides at runtime
shape.draw();  // "Drawing circle"

shape = new Rectangle();
shape.draw();  // "Drawing rectangle"
```

---

### Q5: What is abstraction? Difference from encapsulation?

**Answer:**

**Abstraction:** Hiding complexity, showing only essentials
**Encapsulation:** Hiding data, providing controlled access

```java
// Abstraction - What it does
abstract class Vehicle {
    abstract void start();  // How it starts is hidden
    abstract void stop();
}

class Car extends Vehicle {
    void start() {
        // Complex starting mechanism hidden
        checkFuel();
        initializeEngine();
        startIgnition();
    }
    
    void stop() { /* ... */ }
    
    private void checkFuel() { }
    private void initializeEngine() { }
    private void startIgnition() { }
}

// Encapsulation - Protecting data
class BankAccount {
    private double balance;  // Hidden
    
    public void deposit(double amount) {  // Controlled
        if (amount > 0) balance += amount;
    }
}
```

**Key Difference:**
- Abstraction: Hide HOW (implementation details)
- Encapsulation: Hide WHAT (data members)

---

### Q6: What is an abstract class? When to use it?

**Answer:** Class that cannot be instantiated, may have abstract methods.

```java
abstract class Employee {
    String name;
    double salary;
    
    // Concrete method
    void displayInfo() {
        System.out.println(name + ": " + salary);
    }
    
    // Abstract method - must be implemented
    abstract double calculateBonus();
}

class Manager extends Employee {
    @Override
    double calculateBonus() {
        return salary * 0.2;  // 20% bonus
    }
}

class Developer extends Employee {
    @Override
    double calculateBonus() {
        return salary * 0.15;  // 15% bonus
    }
}
```

**When to use:**
- Common base with some default behavior
- Template pattern
- Partial implementation needed
- IS-A relationship

---

### Q7: What is an interface? When to use it over abstract class?

**Answer:** Contract that classes must implement.

```java
interface Drawable {
    void draw();  // public abstract by default
    
    default void display() {  // Java 8+
        System.out.println("Displaying");
    }
    
    static void info() {  // Java 8+
        System.out.println("Drawable interface");
    }
}

class Circle implements Drawable {
    @Override
    public void draw() {
        System.out.println("Drawing circle");
    }
}
```

**Interface vs Abstract Class:**

| Use Interface When | Use Abstract Class When |
|-------------------|------------------------|
| Multiple inheritance needed | Single inheritance sufficient |
| No common implementation | Some common implementation |
| CAN-DO capability | IS-A relationship |
| Purely contract | Template with defaults |

```java
// Interface - CAN-DO capability
interface Flyable { void fly(); }
interface Swimmable { void swim(); }
class Duck implements Flyable, Swimmable { }

// Abstract class - IS-A relationship
abstract class Animal {
    void sleep() { }  // Common implementation
    abstract void sound();
}
class Dog extends Animal { }
```

---

### Q8: Explain constructor rules in inheritance

**Answer:**

**Rules:**
1. Constructor not inherited
2. Parent constructor called first
3. `super()` must be first statement
4. Default constructor calls parent no-arg constructor

```java
class Parent {
    Parent() {
        System.out.println("Parent no-arg");
    }
    
    Parent(String name) {
        System.out.println("Parent: " + name);
    }
}

class Child extends Parent {
    Child() {
        super();  // Calls Parent()
        System.out.println("Child no-arg");
    }
    
    Child(String name) {
        super(name);  // Calls Parent(String)
        System.out.println("Child: " + name);
    }
}

// Output:
new Child();
// Parent no-arg
// Child no-arg

new Child("Java");
// Parent: Java
// Child: Java
```

---

### Q9: What is composition vs inheritance?

**Answer:**

**Inheritance (IS-A):** Class extends another class
**Composition (HAS-A):** Class contains another class

```java
// Inheritance - IS-A
class Vehicle { }
class Car extends Vehicle { }  // Car IS-A Vehicle

// Composition - HAS-A
class Engine {
    void start() { System.out.println("Engine started"); }
}

class Car {
    private Engine engine;  // Car HAS-A Engine
    
    Car() {
        engine = new Engine();
    }
    
    void start() {
        engine.start();
    }
}
```

**Prefer Composition:**
- More flexible
- Avoids tight coupling
- Easier to change

```java
// Problem with inheritance
class Stack extends ArrayList {
    // Exposes all ArrayList methods (remove, clear, etc.)
    // Breaks Stack contract
}

// Better with composition
class Stack {
    private List<Object> elements = new ArrayList<>();
    
    void push(Object obj) { elements.add(obj); }
    Object pop() { return elements.remove(elements.size() - 1); }
    // Only expose what's needed
}
```

---

### Q10: What is method hiding?

**Answer:** When static method in subclass has same signature as parent.

```java
class Parent {
    static void display() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    static void display() {  // Hides parent method
        System.out.println("Child static");
    }
}

// Usage
Parent p = new Parent();
p.display();  // Parent static

Child c = new Child();
c.display();  // Child static

Parent pc = new Child();
pc.display();  // Parent static (decided at compile-time)
```

**Key Point:** Static methods resolved at compile-time, not runtime.

---

### Q11: Explain covariant return type

**Answer:** Overriding method can return subtype of parent's return type.

```java
class Animal {
    Animal getAnimal() {
        return new Animal();
    }
}

class Dog extends Animal {
    @Override
    Dog getAnimal() {  // Covariant return (Dog is subtype of Animal)
        return new Dog();
    }
}

// Usage
Animal a = new Dog();
Animal result = a.getAnimal();  // Returns Dog object
```

---

### Q12: What is the diamond problem?

**Answer:** Ambiguity when class inherits from two classes with same method.

```java
// Java doesn't allow this
class A {
    void show() { System.out.println("A"); }
}

class B extends A { }
class C extends A { }
class D extends B, C { }  // Compilation error

// Solution: Use interfaces
interface B {
    default void show() { System.out.println("B"); }
}

interface C {
    default void show() { System.out.println("C"); }
}

class D implements B, C {
    @Override
    public void show() {
        B.super.show();  // Explicitly call B's method
        C.super.show();  // Or C's method
    }
}
```

---

### Q13: What is the Liskov Substitution Principle?

**Answer:** Subtypes must be substitutable for their base types.

```java
// Violates LSP
class Bird {
    void fly() { System.out.println("Flying"); }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("Can't fly");
    }
}

// Follows LSP
abstract class Bird {
    abstract void move();
}

class Sparrow extends Bird {
    void move() { System.out.println("Flying"); }
}

class Penguin extends Bird {
    void move() { System.out.println("Swimming"); }
}

// Client code works with any Bird
void makeMove(Bird bird) {
    bird.move();  // Works for all birds
}
```

---

### Q14: What is shallow copy vs deep copy?

**Answer:**

**Shallow Copy:** Copies references, not objects
**Deep Copy:** Copies entire object graph

```java
class Address {
    String city;
    Address(String city) { this.city = city; }
}

class Person implements Cloneable {
    String name;
    Address address;
    
    // Shallow copy
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();  // Copies references
    }
    
    // Deep copy
    public Person deepCopy() {
        Person copy = new Person();
        copy.name = this.name;
        copy.address = new Address(this.address.city);  // New object
        return copy;
    }
}

// Usage
Person p1 = new Person();
p1.address = new Address("NYC");

Person p2 = (Person) p1.clone();  // Shallow
p2.address.city = "LA";
// Both p1 and p2 now have "LA"

Person p3 = p1.deepCopy();  // Deep
p3.address.city = "Chicago";
// Only p3 has "Chicago", p1 unchanged
```

---

### Q15: Explain object cloning

**Answer:** Creating exact copy of object.

```java
class Student implements Cloneable {
    int id;
    String name;
    
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// Usage
Student s1 = new Student();
s1.id = 1;
s1.name = "Alice";

Student s2 = (Student) s1.clone();
s2.id = 2;
// s1 and s2 are separate objects
```

**Note:** Must implement `Cloneable` interface, otherwise throws `CloneNotSupportedException`.

---

## ðŸ’¡ Quick Tips

- Understand OOP principles deeply
- Use real-world examples
- Explain benefits and trade-offs
- Show code examples
- Relate to SOLID principles
