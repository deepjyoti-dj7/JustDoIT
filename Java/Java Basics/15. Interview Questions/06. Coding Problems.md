# ðŸŽ¯ Coding Problems

## ðŸ“– Common Algorithms

### Q1: Reverse an array

**Answer:**

```java
// Method 1: Two pointers
public void reverseArray(int[] arr) {
    int left = 0, right = arr.length - 1;
    while (left < right) {
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;
        left++;
        right--;
    }
}

// Method 2: Collections
public void reverseArray2(Integer[] arr) {
    Collections.reverse(Arrays.asList(arr));
}

// Test
int[] arr = {1, 2, 3, 4, 5};
reverseArray(arr);  // [5, 4, 3, 2, 1]
```

---

### Q2: Find duplicates in array

**Answer:**

```java
// Method 1: HashSet
public List<Integer> findDuplicates(int[] arr) {
    Set<Integer> seen = new HashSet<>();
    Set<Integer> duplicates = new HashSet<>();
    
    for (int num : arr) {
        if (!seen.add(num)) {
            duplicates.add(num);
        }
    }
    
    return new ArrayList<>(duplicates);
}

// Method 2: HashMap with frequency
public List<Integer> findDuplicates2(int[] arr) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : arr) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    
    List<Integer> result = new ArrayList<>();
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        if (entry.getValue() > 1) {
            result.add(entry.getKey());
        }
    }
    return result;
}

// Test
int[] arr = {1, 2, 3, 2, 4, 5, 1};
findDuplicates(arr);  // [1, 2]
```

---

### Q3: Find second largest element

**Answer:**

```java
public int secondLargest(int[] arr) {
    if (arr.length < 2) {
        throw new IllegalArgumentException("Array too small");
    }
    
    int largest = Integer.MIN_VALUE;
    int secondLargest = Integer.MIN_VALUE;
    
    for (int num : arr) {
        if (num > largest) {
            secondLargest = largest;
            largest = num;
        } else if (num > secondLargest && num != largest) {
            secondLargest = num;
        }
    }
    
    if (secondLargest == Integer.MIN_VALUE) {
        throw new IllegalArgumentException("No second largest");
    }
    
    return secondLargest;
}

// Test
int[] arr = {5, 2, 8, 1, 9, 3};
secondLargest(arr);  // 8
```

---

### Q4: Check if array is sorted

**Answer:**

```java
// Ascending order
public boolean isSorted(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}

// Both ascending and descending
public String checkSorted(int[] arr) {
    boolean ascending = true;
    boolean descending = true;
    
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] < arr[i - 1]) ascending = false;
        if (arr[i] > arr[i - 1]) descending = false;
    }
    
    if (ascending) return "Ascending";
    if (descending) return "Descending";
    return "Not sorted";
}

// Test
isSorted(new int[]{1, 2, 3, 4});  // true
isSorted(new int[]{4, 2, 3, 1});  // false
```

---

### Q5: Rotate array

**Answer:**

```java
// Rotate right by k positions
public void rotateArray(int[] arr, int k) {
    int n = arr.length;
    k = k % n;  // Handle k > n
    
    // Reverse entire array
    reverse(arr, 0, n - 1);
    // Reverse first k elements
    reverse(arr, 0, k - 1);
    // Reverse remaining elements
    reverse(arr, k, n - 1);
}

private void reverse(int[] arr, int start, int end) {
    while (start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

// Test
int[] arr = {1, 2, 3, 4, 5};
rotateArray(arr, 2);  // [4, 5, 1, 2, 3]
```

---

### Q6: Merge two sorted arrays

**Answer:**

```java
public int[] mergeSorted(int[] arr1, int[] arr2) {
    int n1 = arr1.length, n2 = arr2.length;
    int[] result = new int[n1 + n2];
    int i = 0, j = 0, k = 0;
    
    while (i < n1 && j < n2) {
        if (arr1[i] <= arr2[j]) {
            result[k++] = arr1[i++];
        } else {
            result[k++] = arr2[j++];
        }
    }
    
    while (i < n1) result[k++] = arr1[i++];
    while (j < n2) result[k++] = arr2[j++];
    
    return result;
}

// Test
int[] arr1 = {1, 3, 5, 7};
int[] arr2 = {2, 4, 6, 8};
mergeSorted(arr1, arr2);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Q7: Find missing number in array (1 to n)

**Answer:**

```java
// Method 1: Sum formula
public int findMissing(int[] arr, int n) {
    int expectedSum = n * (n + 1) / 2;
    int actualSum = 0;
    for (int num : arr) {
        actualSum += num;
    }
    return expectedSum - actualSum;
}

// Method 2: XOR
public int findMissing2(int[] arr, int n) {
    int xor1 = 0, xor2 = 0;
    
    for (int i = 1; i <= n; i++) {
        xor1 ^= i;
    }
    
    for (int num : arr) {
        xor2 ^= num;
    }
    
    return xor1 ^ xor2;
}

// Test
int[] arr = {1, 2, 4, 5, 6};  // Missing 3
findMissing(arr, 6);  // 3
```

---

### Q8: Two sum problem

**Answer:**

```java
// Find two numbers that sum to target
public int[] twoSum(int[] arr, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < arr.length; i++) {
        int complement = target - arr[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(arr[i], i);
    }
    
    return new int[]{-1, -1};  // Not found
}

// Test
int[] arr = {2, 7, 11, 15};
twoSum(arr, 9);  // [0, 1] (2 + 7 = 9)
```

---

### Q9: Find maximum subarray sum (Kadane's Algorithm)

**Answer:**

```java
public int maxSubarraySum(int[] arr) {
    int maxSum = arr[0];
    int currentSum = arr[0];
    
    for (int i = 1; i < arr.length; i++) {
        currentSum = Math.max(arr[i], currentSum + arr[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}

// Test
int[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
maxSubarraySum(arr);  // 6 (subarray: [4, -1, 2, 1])
```

---

### Q10: Fibonacci series

**Answer:**

```java
// Method 1: Recursive
public int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Method 2: Iterative
public int fibonacci2(int n) {
    if (n <= 1) return n;
    
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        int temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// Method 3: Dynamic Programming
public int fibonacci3(int n) {
    if (n <= 1) return n;
    
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// Test
fibonacci(10);  // 55
```

---

### Q11: Check if number is prime

**Answer:**

```java
public boolean isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    
    // Check divisibility up to âˆšn
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
    }
    
    return true;
}

// Test
isPrime(17);  // true
isPrime(18);  // false
```

---

### Q12: Factorial

**Answer:**

```java
// Recursive
public long factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// Iterative
public long factorial2(int n) {
    long result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// Test
factorial(5);  // 120
```

---

### Q13: Binary search

**Answer:**

```java
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;  // Not found
}

// Recursive
public int binarySearchRecursive(int[] arr, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) return mid;
    if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, right);
    return binarySearchRecursive(arr, target, left, mid - 1);
}

// Test
int[] arr = {1, 3, 5, 7, 9, 11};
binarySearch(arr, 7);  // 3
```

---

### Q14: Bubble sort

**Answer:**

```java
public void bubbleSort(int[] arr) {
    int n = arr.length;
    boolean swapped;
    
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        
        if (!swapped) break;  // Already sorted
    }
}

// Test
int[] arr = {64, 34, 25, 12, 22, 11, 90};
bubbleSort(arr);  // [11, 12, 22, 25, 34, 64, 90]
```

---

### Q15: Selection sort

**Answer:**

```java
public void selectionSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        
        // Find minimum element
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Swap
        if (minIndex != i) {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}

// Test
int[] arr = {64, 25, 12, 22, 11};
selectionSort(arr);  // [11, 12, 22, 25, 64]
```

---

## ðŸ”¢ Number Problems

### P1: Armstrong number

```java
// Number equals sum of cubes of digits (153 = 1Â³ + 5Â³ + 3Â³)
public boolean isArmstrong(int num) {
    int original = num;
    int sum = 0;
    
    while (num > 0) {
        int digit = num % 10;
        sum += digit * digit * digit;
        num /= 10;
    }
    
    return sum == original;
}

// Test: 153, 370, 371, 407
```

---

### P2: Reverse number

```java
public int reverseNumber(int num) {
    int reversed = 0;
    
    while (num != 0) {
        reversed = reversed * 10 + num % 10;
        num /= 10;
    }
    
    return reversed;
}

// Test: 1234 â†’ 4321
```

---

### P3: Sum of digits

```java
public int sumOfDigits(int num) {
    int sum = 0;
    while (num > 0) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

// Test: 1234 â†’ 10
```

---

### P4: GCD (Greatest Common Divisor)

```java
// Euclidean algorithm
public int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// Iterative
public int gcd2(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// Test: gcd(48, 18) = 6
```

---

### P5: LCM (Least Common Multiple)

```java
public int lcm(int a, int b) {
    return (a * b) / gcd(a, b);
}

// Test: lcm(12, 18) = 36
```

---

## ðŸ’¡ Quick Tips

**Arrays:**
- Two pointers for reversal/sorting
- HashMap for frequency/duplicates
- Binary search for sorted arrays
- Kadane's algorithm for subarray sum

**Strings:**
- StringBuilder for modifications
- HashMap for character frequency
- Two pointers for palindrome

**Numbers:**
- Modulo (%) to extract digits
- Division (/) to remove digits
- Recursion or iteration for factorial/fibonacci

**Searching & Sorting:**
- Binary search: O(log n)
- Bubble/Selection sort: O(nÂ²)
- Use Collections.sort() or Arrays.sort() in practice

**Common Patterns:**
- Sliding window
- Two pointers
- Hash map for O(1) lookup
- Dynamic programming for optimization
