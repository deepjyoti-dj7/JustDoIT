# ðŸŽ¯ Exception Handling Questions

## ðŸ“– Exception Handling Fundamentals

### Q1: What is exception handling? Why is it important?

**Answer:** Mechanism to handle runtime errors gracefully.

**Benefits:**
- Separates error handling from normal code
- Propagates errors up call stack
- Categorizes error types
- Maintains program flow

```java
// Without exception handling
public int divide(int a, int b) {
    return a / b;  // Crashes on b=0
}

// With exception handling
public int divide(int a, int b) {
    try {
        return a / b;
    } catch (ArithmeticException e) {
        System.out.println("Cannot divide by zero");
        return 0;
    }
}
```

---

### Q2: Explain exception hierarchy

**Answer:**

```
Throwable
â”œâ”€â”€ Error (JVM errors, not handled)
â”‚   â”œâ”€â”€ OutOfMemoryError
â”‚   â”œâ”€â”€ StackOverflowError
â”‚   â””â”€â”€ VirtualMachineError
â””â”€â”€ Exception
    â”œâ”€â”€ IOException (Checked)
    â”œâ”€â”€ SQLException (Checked)
    â””â”€â”€ RuntimeException (Unchecked)
        â”œâ”€â”€ NullPointerException
        â”œâ”€â”€ ArithmeticException
        â”œâ”€â”€ ArrayIndexOutOfBoundsException
        â””â”€â”€ IllegalArgumentException
```

**Key Points:**
- `Throwable` is root
- `Error` - JVM problems (don't catch)
- `Exception` - Application problems (handle)
- `RuntimeException` - Programming mistakes (unchecked)

---

### Q3: Checked vs Unchecked exceptions?

**Answer:**

**Checked Exceptions:** Must handle or declare
**Unchecked Exceptions:** Runtime exceptions, optional handling

```java
// Checked - Must handle
public void readFile() throws IOException {  // Declare
    FileReader fr = new FileReader("file.txt");
}

public void readFileSafe() {
    try {
        FileReader fr = new FileReader("file.txt");  // Handle
    } catch (IOException e) {
        e.printStackTrace();
    }
}

// Unchecked - Optional handling
public int divide(int a, int b) {
    return a / b;  // May throw ArithmeticException
}

public int divideSafe(int a, int b) {
    try {
        return a / b;
    } catch (ArithmeticException e) {  // Optional
        return 0;
    }
}
```

**Comparison:**

| Checked | Unchecked |
|---------|-----------|
| Compile-time verification | Runtime detection |
| Must handle/declare | Optional handling |
| IOException, SQLException | NullPointerException, ArithmeticException |
| Recoverable errors | Programming bugs |

---

### Q4: Explain try-catch-finally

**Answer:**

```java
public void processFile() {
    FileReader fr = null;
    try {
        fr = new FileReader("file.txt");
        // Process file
    } catch (FileNotFoundException e) {
        System.out.println("File not found");
    } catch (IOException e) {
        System.out.println("IO error");
    } finally {
        // Always executes
        if (fr != null) {
            try {
                fr.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**Key Points:**
- `try` - Code that may throw exception
- `catch` - Handle specific exception
- `finally` - Always executes (cleanup)
- Multiple catch blocks allowed
- `finally` runs even if return in try/catch

---

### Q5: What is try-with-resources?

**Answer:** Automatic resource management (Java 7+).

```java
// Old way
public void readFile() {
    BufferedReader br = null;
    try {
        br = new BufferedReader(new FileReader("file.txt"));
        String line = br.readLine();
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (br != null) {
            try {
                br.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

// New way - try-with-resources
public void readFile() {
    try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
        String line = br.readLine();
    } catch (IOException e) {
        e.printStackTrace();
    }
    // br.close() called automatically
}

// Multiple resources
try (FileReader fr = new FileReader("file.txt");
     BufferedReader br = new BufferedReader(fr)) {
    // Use resources
}
```

**Requirements:** Resource must implement `AutoCloseable`.

---

### Q6: What is throw vs throws?

**Answer:**

**throw:** Explicitly throw exception
**throws:** Declare method may throw exception

```java
// throw - Throw exception explicitly
public void validateAge(int age) {
    if (age < 18) {
        throw new IllegalArgumentException("Age must be 18+");
    }
}

// throws - Declare exception
public void readFile() throws IOException {
    FileReader fr = new FileReader("file.txt");
}

// Combined usage
public void processAge(int age) throws CustomException {
    if (age < 0) {
        throw new CustomException("Invalid age");  // throw
    }
}
```

---

### Q7: Can we have multiple catch blocks?

**Answer:** Yes, ordered from specific to general.

```java
public void process() {
    try {
        // Code
    } catch (FileNotFoundException e) {  // Most specific
        System.out.println("File not found");
    } catch (IOException e) {  // More general
        System.out.println("IO error");
    } catch (Exception e) {  // Most general
        System.out.println("General error");
    }
}

// Multi-catch (Java 7+)
try {
    // Code
} catch (IOException | SQLException e) {
    e.printStackTrace();
}

// Wrong order - Compilation error
try {
    // Code
} catch (Exception e) {  // Too general first
} catch (IOException e) {  // Unreachable
}
```

---

### Q8: When does finally not execute?

**Answer:** Rarely, but in these cases:

```java
// 1. System.exit()
try {
    System.exit(0);  // Terminates JVM
} finally {
    System.out.println("Won't execute");
}

// 2. Fatal error
try {
    throw new StackOverflowError();
} finally {
    System.out.println("May not execute");
}

// 3. Daemon thread death
// 4. Infinite loop in try/catch
// 5. System crash
```

**Normal cases - finally always executes:**
```java
try {
    return 1;
} finally {
    System.out.println("Executes before return");
}

try {
    throw new Exception();
} catch (Exception e) {
} finally {
    System.out.println("Executes after catch");
}
```

---

### Q9: Create custom exception

**Answer:**

```java
// Checked exception
class InsufficientFundsException extends Exception {
    private double amount;
    
    public InsufficientFundsException(double amount) {
        super("Insufficient funds: " + amount);
        this.amount = amount;
    }
    
    public double getAmount() {
        return amount;
    }
}

// Unchecked exception
class InvalidAccountException extends RuntimeException {
    public InvalidAccountException(String message) {
        super(message);
    }
}

// Usage
class BankAccount {
    private double balance;
    
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount > balance) {
            throw new InsufficientFundsException(amount - balance);
        }
        balance -= amount;
    }
    
    public void validateAccount(String accountId) {
        if (accountId == null || accountId.isEmpty()) {
            throw new InvalidAccountException("Invalid account ID");
        }
    }
}
```

---

### Q10: What is exception chaining?

**Answer:** Wrapping one exception in another to preserve context.

```java
class DataAccessException extends Exception {
    public DataAccessException(String message, Throwable cause) {
        super(message, cause);
    }
}

public void processData() throws DataAccessException {
    try {
        // Database operation
        Connection conn = DriverManager.getConnection(url);
    } catch (SQLException e) {
        // Chain exception
        throw new DataAccessException("Failed to process data", e);
    }
}

// Get cause
try {
    processData();
} catch (DataAccessException e) {
    Throwable cause = e.getCause();  // Original SQLException
    System.out.println("Root cause: " + cause);
}
```

---

### Q11: What is NullPointerException? How to avoid?

**Answer:** Most common runtime exception.

```java
// Causes NPE
String str = null;
str.length();  // NPE

List<String> list = null;
list.add("item");  // NPE

Person person = null;
person.getName();  // NPE

// Avoid NPE
// 1. Check null
if (str != null) {
    str.length();
}

// 2. Use Optional
Optional<String> opt = Optional.ofNullable(str);
opt.ifPresent(s -> System.out.println(s.length()));

// 3. Use default values
String result = str != null ? str : "default";

// 4. Objects.requireNonNull
String validated = Objects.requireNonNull(str, "str cannot be null");

// 5. @NotNull annotations
public void process(@NotNull String input) {
    // IDE warns if null passed
}
```

---

### Q12: Best practices for exception handling

**Answer:**

```java
// âœ… Good practices

// 1. Be specific
catch (FileNotFoundException e) { }  // Specific
// Not: catch (Exception e) { }  // Too broad

// 2. Don't swallow exceptions
catch (IOException e) {
    e.printStackTrace();  // At least log
}
// Not: catch (IOException e) { }  // Silent fail

// 3. Use finally or try-with-resources
try (FileReader fr = new FileReader("file.txt")) {
    // Auto-close
}

// 4. Don't use exceptions for control flow
// Bad:
try {
    int i = 0;
    while (true) {
        array[i++];
    }
} catch (ArrayIndexOutOfBoundsException e) { }

// Good:
for (int i = 0; i < array.length; i++) {
    // Process array[i]
}

// 5. Preserve stack trace
catch (Exception e) {
    throw new CustomException("Failed", e);  // Preserve
}
// Not: throw new CustomException("Failed");  // Lost trace

// 6. Clean up resources
finally {
    if (connection != null) connection.close();
}
```

---

### Q13: What happens if exception in finally?

**Answer:** Finally exception overrides try/catch exception.

```java
public int test() {
    try {
        return 1;
    } finally {
        return 2;  // Overrides try return
    }
}
// Returns 2

public void testException() throws Exception {
    try {
        throw new IOException("IO");
    } finally {
        throw new SQLException("SQL");  // Overrides IO exception
    }
}
// Throws SQLException, IOException lost

// Better approach
public void testSafe() throws Exception {
    Exception exception = null;
    try {
        throw new IOException("IO");
    } catch (Exception e) {
        exception = e;
    } finally {
        try {
            // Cleanup
        } catch (Exception e) {
            if (exception != null) {
                e.addSuppressed(exception);  // Preserve both
            }
            throw e;
        }
        if (exception != null) throw exception;
    }
}
```

---

### Q14: Explain suppressed exceptions

**Answer:** Exceptions lost during resource cleanup.

```java
// Problem
static class Resource implements AutoCloseable {
    void use() throws Exception {
        throw new Exception("Use failed");
    }
    
    public void close() throws Exception {
        throw new Exception("Close failed");
    }
}

// Without try-with-resources
try {
    Resource r = new Resource();
    r.use();
    r.close();
} catch (Exception e) {
    // Only sees "Use failed"
}

// With try-with-resources
try (Resource r = new Resource()) {
    r.use();
} catch (Exception e) {
    System.out.println(e.getMessage());  // Use failed
    for (Throwable suppressed : e.getSuppressed()) {
        System.out.println("Suppressed: " + suppressed.getMessage());
        // Suppressed: Close failed
    }
}
```

---

### Q15: Can constructor throw exception?

**Answer:** Yes, both checked and unchecked.

```java
class User {
    String email;
    
    // Unchecked exception
    public User(String email) {
        if (email == null) {
            throw new IllegalArgumentException("Email required");
        }
        this.email = email;
    }
}

class DatabaseConnection {
    Connection conn;
    
    // Checked exception
    public DatabaseConnection(String url) throws SQLException {
        conn = DriverManager.getConnection(url);
    }
}

// Usage
try {
    User user = new User(null);  // Throws IllegalArgumentException
} catch (IllegalArgumentException e) {
    System.out.println(e.getMessage());
}

try {
    DatabaseConnection db = new DatabaseConnection(url);
} catch (SQLException e) {
    e.printStackTrace();
}
```

**Note:** If constructor throws exception, object creation fails and constructor won't complete.

---

## ðŸ’¡ Quick Tips

- Use specific exceptions
- Always log exceptions
- Don't swallow exceptions
- Clean up resources
- Use try-with-resources
- Preserve stack traces
- Avoid using exceptions for control flow
