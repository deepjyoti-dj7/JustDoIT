# üéØ Tricky Questions

## üìñ Edge Cases & Gotchas

### Q1: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        Integer a = 128;
        Integer b = 128;
        System.out.println(a == b);
        
        Integer c = 127;
        Integer d = 127;
        System.out.println(c == d);
    }
}
```

**Answer:**
```
false
true
```

**Explanation:** Integer cache (-128 to 127). Objects outside range are different instances.

```java
// a and b are different objects (128 > 127)
Integer a = Integer.valueOf(128);  // New object
Integer b = Integer.valueOf(128);  // New object
a == b;  // false (different references)

// c and d from cache
Integer c = Integer.valueOf(127);  // From cache
Integer d = Integer.valueOf(127);  // Same from cache
c == d;  // true (same reference)

// Always use equals()
a.equals(b);  // true (compares values)
```

---

### Q2: What's the output?

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");
String s4 = new String("Hello").intern();

System.out.println(s1 == s2);
System.out.println(s1 == s3);
System.out.println(s1 == s4);
```

**Answer:**
```
true   (both from string pool)
false  (s3 is new object in heap)
true   (intern() returns pool reference)
```

---

### Q3: What's the output?

```java
public class Test {
    static int x = 10;
    
    static {
        x = 20;
    }
    
    public static void main(String[] args) {
        System.out.println(x);
        x = 30;
        System.out.println(x);
    }
}
```

**Answer:**
```
20  (static block executed before main)
30  (updated in main)
```

**Execution order:**
1. Static variables initialized (x = 10)
2. Static block executed (x = 20)
3. main method (x = 30)

---

### Q4: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        int i = 5;
        System.out.println(i++ + ++i);
    }
}
```

**Answer:** `12`

**Explanation:**
- `i++` returns 5, then i becomes 6
- `++i` makes i = 7, returns 7
- 5 + 7 = 12

---

### Q5: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(2.0 - 1.1);
    }
}
```

**Answer:** `0.8999999999999999`

**Explanation:** Floating-point precision issue. Use `BigDecimal` for precise calculations.

```java
BigDecimal a = new BigDecimal("2.0");
BigDecimal b = new BigDecimal("1.1");
System.out.println(a.subtract(b));  // 0.9
```

---

### Q6: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        String str = null;
        str += "hello";
        System.out.println(str);
    }
}
```

**Answer:** `nullhello`

**Explanation:** `str += "hello"` becomes `str = str + "hello"` = `str = null + "hello"` = `"nullhello"`

---

### Q7: What's the output?

```java
public class Parent {
    static {
        System.out.println("Parent static");
    }
    
    {
        System.out.println("Parent instance");
    }
    
    public Parent() {
        System.out.println("Parent constructor");
    }
}

public class Child extends Parent {
    static {
        System.out.println("Child static");
    }
    
    {
        System.out.println("Child instance");
    }
    
    public Child() {
        System.out.println("Child constructor");
    }
    
    public static void main(String[] args) {
        new Child();
    }
}
```

**Answer:**
```
Parent static
Child static
Parent instance
Parent constructor
Child instance
Child constructor
```

**Order:**
1. Parent static block
2. Child static block
3. Parent instance block
4. Parent constructor
5. Child instance block
6. Child constructor

---

### Q8: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        change(arr);
        System.out.println(arr[0]);
    }
    
    static void change(int[] arr) {
        arr[0] = 100;
        arr = new int[]{4, 5, 6};
        arr[0] = 200;
    }
}
```

**Answer:** `100`

**Explanation:**
- Arrays passed by reference
- `arr[0] = 100` modifies original array
- `arr = new int[]{}` creates new array (doesn't affect original)
- `arr[0] = 200` modifies new array (not original)

---

### Q9: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        try {
            return;
        } finally {
            System.out.println("Finally");
        }
    }
}
```

**Answer:** `Finally`

**Explanation:** `finally` always executes, even with return statement.

---

### Q10: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("1" + 2 + 3);
        System.out.println(1 + 2 + "3");
    }
}
```

**Answer:**
```
123
33
```

**Explanation:**
- `"1" + 2 + 3` ‚Üí `"1" + 2` = `"12"` ‚Üí `"12" + 3` = `"123"`
- `1 + 2 + "3"` ‚Üí `1 + 2` = `3` ‚Üí `3 + "3"` = `"33"`

---

### Q11: What's the output?

```java
public class Test {
    int x;
    
    public Test(int x) {
        this.x = x;
    }
    
    public static void main(String[] args) {
        Test t1 = new Test(10);
        Test t2 = new Test(10);
        
        System.out.println(t1 == t2);
        System.out.println(t1.equals(t2));
    }
}
```

**Answer:**
```
false  (different objects)
false  (equals() not overridden, uses ==)
```

**Fix:** Override `equals()`
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Test other = (Test) obj;
    return x == other.x;
}
```

---

### Q12: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A", "B", "C");
        list.remove(0);  // What happens?
    }
}
```

**Answer:** `UnsupportedOperationException`

**Explanation:** `Arrays.asList()` returns fixed-size list.

**Fix:**
```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
list.remove(0);  // Works
```

---

### Q13: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        
        list.remove(1);  // Removes what?
        System.out.println(list);
    }
}
```

**Answer:** `[1, 3]`

**Explanation:** `remove(1)` removes index 1 (value 2), not value 1.

**To remove value 1:**
```java
list.remove(Integer.valueOf(1));  // Removes value 1
```

---

### Q14: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put(null, 1);
        map.put(null, 2);
        System.out.println(map.size());
        System.out.println(map.get(null));
    }
}
```

**Answer:**
```
1
2
```

**Explanation:** HashMap allows one null key. Second put replaces first.

**Note:** Hashtable doesn't allow null keys/values.

---

### Q15: What's the output?

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(10 / 3);
        System.out.println(10.0 / 3);
        System.out.println(10 / 3.0);
        System.out.println((double) 10 / 3);
    }
}
```

**Answer:**
```
3          (integer division)
3.3333...  (double division)
3.3333...  (double division)
3.3333...  (type casting)
```

---

## üé≤ Common Pitfalls

### P1: Modifying collection while iterating

```java
// ‚ùå ConcurrentModificationException
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String s : list) {
    if (s.equals("B")) {
        list.remove(s);  // Exception
    }
}

// ‚úÖ Use Iterator
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if (it.next().equals("B")) {
        it.remove();
    }
}

// ‚úÖ Use removeIf (Java 8+)
list.removeIf(s -> s.equals("B"));
```

---

### P2: String comparison

```java
// ‚ùå Wrong
String s1 = "hello";
String s2 = new String("hello");
if (s1 == s2) { }  // false (compares references)

// ‚úÖ Correct
if (s1.equals(s2)) { }  // true (compares content)

// ‚úÖ Null-safe
if (Objects.equals(s1, s2)) { }
```

---

### P3: NullPointerException

```java
// ‚ùå Risky
String str = null;
if (str.equals("hello")) { }  // NPE

// ‚úÖ Safe
if ("hello".equals(str)) { }  // No NPE

// ‚úÖ Null check
if (str != null && str.equals("hello")) { }

// ‚úÖ Optional (Java 8+)
Optional.ofNullable(str)
        .filter(s -> s.equals("hello"))
        .ifPresent(s -> { });
```

---

### P4: Integer cache

```java
// ‚ùå Wrong for large values
Integer a = 1000;
Integer b = 1000;
if (a == b) { }  // false

// ‚úÖ Always use equals
if (a.equals(b)) { }  // true
```

---

### P5: Resource leaks

```java
// ‚ùå Resource leak
FileReader fr = new FileReader("file.txt");
// Exception before close

// ‚úÖ Try-with-resources
try (FileReader fr = new FileReader("file.txt")) {
    // Auto-closes
}
```

---

## üí° Quick Tips

- Use `equals()` for object comparison
- Remember Integer cache (-128 to 127)
- String pool vs heap objects
- `finally` always executes
- Floating-point precision issues
- Arrays/objects passed by reference
- Iterator for safe collection modification
- Watch operator precedence
- Type casting in arithmetic
- Null checks before method calls

