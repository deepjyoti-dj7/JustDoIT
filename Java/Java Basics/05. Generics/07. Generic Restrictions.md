# üö´ Generic Restrictions

## üìñ Overview

**Generic restrictions** are limitations imposed by Java's type erasure and type safety mechanisms. Understanding these restrictions is crucial for effective generic programming.

**Common Restrictions:**
- Cannot instantiate type parameters
- Cannot create arrays of parameterized types
- Cannot use primitives as type arguments
- Cannot create static fields of type parameter
- Cannot use casts or instanceof with parameterized types

---

## üíª Example 1: Cannot Instantiate Type Parameters

```java
public class CannotInstantiate {
    // ERROR: Cannot create instance of T
    // public static <T> T createInstance() {
    //     return new T();  // Compile error
    // }
    
    // Solution 1: Use Class object
    public static <T> T createWithClass(Class<T> clazz) {
        try {
            return clazz.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Cannot create instance", e);
        }
    }
    
    // Solution 2: Use Supplier
    public static <T> T createWithSupplier(java.util.function.Supplier<T> supplier) {
        return supplier.get();
    }
    
    static class Person {
        String name = "Default";
        
        @Override
        public String toString() {
            return "Person{name='" + name + "'}";
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Instantiate Type Parameters ===\n");
        
        // Using Class token
        Person p1 = createWithClass(Person.class);
        System.out.println("Created with Class: " + p1);
        
        // Using Supplier
        Person p2 = createWithSupplier(Person::new);
        System.out.println("Created with Supplier: " + p2);
        
        // Using lambda
        Person p3 = createWithSupplier(() -> new Person());
        System.out.println("Created with Lambda: " + p3);
    }
}
```

**Output:**
```
=== Cannot Instantiate Type Parameters ===

Created with Class: Person{name='Default'}
Created with Supplier: Person{name='Default'}
Created with Lambda: Person{name='Default'}
```

---

## üíª Example 2: Cannot Create Generic Arrays

```java
import java.util.*;

public class CannotCreateArrays {
    // ERROR: Cannot create array of parameterized type
    // public static <T> T[] createArray(int size) {
    //     return new T[size];  // Compile error
    // }
    
    // Solution 1: Use Object array with cast
    @SuppressWarnings("unchecked")
    public static <T> T[] createArrayWithCast(int size) {
        return (T[]) new Object[size];
    }
    
    // Solution 2: Use Class token
    @SuppressWarnings("unchecked")
    public static <T> T[] createArrayWithClass(Class<T> clazz, int size) {
        return (T[]) java.lang.reflect.Array.newInstance(clazz, size);
    }
    
    // Solution 3: Use ArrayList
    public static <T> List<T> createList() {
        return new ArrayList<>();
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Create Generic Arrays ===\n");
        
        // Cannot do this:
        // List<String>[] arrayOfLists = new List<String>[10];  // ERROR
        
        // Can use wildcard
        List<?>[] arrayOfLists = new List<?>[3];
        arrayOfLists[0] = Arrays.asList("A", "B");
        arrayOfLists[1] = Arrays.asList(1, 2);
        arrayOfLists[2] = Arrays.asList(1.1, 2.2);
        
        System.out.println("Array with wildcards:");
        for (List<?> list : arrayOfLists) {
            System.out.println(list);
        }
        
        // Using reflection
        String[] stringArray = createArrayWithClass(String.class, 5);
        stringArray[0] = "Hello";
        stringArray[1] = "World";
        
        System.out.println("\nArray with reflection:");
        System.out.println(Arrays.toString(stringArray));
        
        // Best solution: use List
        List<String> stringList = createList();
        stringList.add("A");
        stringList.add("B");
        System.out.println("\nUsing List instead: " + stringList);
    }
}
```

---

## üíª Example 3: Cannot Use Primitives

```java
import java.util.*;

public class CannotUsePrimitives {
    // ERROR: Cannot use primitive types
    // List<int> intList = new ArrayList<>();  // Compile error
    // Box<double> doubleBox = new Box<>();    // Compile error
    
    // Must use wrapper classes
    public static void main(String[] args) {
        System.out.println("=== Cannot Use Primitives ===\n");
        
        // Wrong - primitives not allowed
        // List<int> numbers = new ArrayList<>();
        
        // Correct - use wrappers
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);  // Autoboxing
        numbers.add(2);
        numbers.add(3);
        
        System.out.println("Integer list: " + numbers);
        
        // Common wrappers
        List<Byte> bytes = new ArrayList<>();
        List<Short> shorts = new ArrayList<>();
        List<Integer> integers = new ArrayList<>();
        List<Long> longs = new ArrayList<>();
        List<Float> floats = new ArrayList<>();
        List<Double> doubles = new ArrayList<>();
        List<Character> chars = new ArrayList<>();
        List<Boolean> booleans = new ArrayList<>();
        
        integers.add(100);
        doubles.add(3.14);
        chars.add('A');
        booleans.add(true);
        
        System.out.println("\nUsing wrappers:");
        System.out.println("Integers: " + integers);
        System.out.println("Doubles: " + doubles);
        System.out.println("Characters: " + chars);
        System.out.println("Booleans: " + booleans);
        
        // Autoboxing/unboxing
        int value = integers.get(0);  // Unboxing
        System.out.println("\nUnboxed value: " + value);
    }
}
```

---

## üíª Example 4: Cannot Use Static with Type Parameters

```java
public class CannotUseStatic {
    static class Container<T> {
        // ERROR: Cannot create static field of type T
        // private static T staticValue;  // Compile error
        
        // ERROR: Cannot use T in static method
        // public static T getStatic() {  // Compile error
        //     return staticValue;
        // }
        
        // Instance field is OK
        private T instanceValue;
        
        // Instance method is OK
        public T getInstance() {
            return instanceValue;
        }
        
        // Static generic method is OK
        public static <E> void staticMethod(E element) {
            System.out.println("Static method with: " + element);
        }
        
        // Static method with class type parameter OK
        public static <E> Container<E> create() {
            return new Container<>();
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Use Static with Type Parameters ===\n");
        
        Container<String> stringContainer = new Container<>();
        Container<Integer> intContainer = new Container<>();
        
        // Static generic method works
        Container.staticMethod("Hello");
        Container.staticMethod(42);
        
        // Static factory method
        Container<Double> doubleContainer = Container.create();
        System.out.println("\nCreated container: " + doubleContainer.getClass().getSimpleName());
    }
}
```

---

## üíª Example 5: Cannot Use instanceof with Parameterized Types

```java
import java.util.*;

public class CannotUseInstanceof {
    public static void checkType(Object obj) {
        // ERROR: Cannot use instanceof with parameterized type
        // if (obj instanceof List<String>) { }  // Compile error
        
        // OK: Use raw type
        if (obj instanceof List) {
            System.out.println("Object is a List");
            List<?> list = (List<?>) obj;
            System.out.println("List size: " + list.size());
        }
        
        // OK: Use class comparison
        if (obj.getClass() == ArrayList.class) {
            System.out.println("Object is ArrayList");
        }
    }
    
    public static <T> void genericCheck(T obj) {
        // ERROR: Cannot use instanceof with type parameter
        // if (obj instanceof T) { }  // Compile error
        
        // Can check against Object
        if (obj instanceof Object) {
            System.out.println("Object type: " + obj.getClass().getSimpleName());
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Use instanceof with Parameterized Types ===\n");
        
        List<String> stringList = new ArrayList<>(Arrays.asList("A", "B", "C"));
        List<Integer> intList = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        System.out.println("Checking string list:");
        checkType(stringList);
        
        System.out.println("\nChecking integer list:");
        checkType(intList);
        
        System.out.println("\nGeneric check:");
        genericCheck("Hello");
        genericCheck(42);
    }
}
```

---

## üíª Example 6: Cannot Catch or Throw Generic Exceptions

```java
public class CannotUseGenericExceptions {
    // ERROR: Generic class cannot extend Throwable
    // class GenericException<T> extends Exception { }  // Compile error
    
    // ERROR: Cannot catch type parameter
    // public <T extends Exception> void method() {
    //     try {
    //         // code
    //     } catch (T e) {  // Compile error
    //         // handle
    //     }
    // }
    
    // OK: Can have bounded type parameter for throwing
    public static <T extends Exception> void methodThatThrows() throws T {
        System.out.println("Method that can throw exception of type T");
    }
    
    // Workaround: Use Class token
    public static <T extends Exception> void handleException(
            Runnable code, 
            Class<T> exceptionClass) {
        try {
            code.run();
        } catch (Exception e) {
            if (exceptionClass.isInstance(e)) {
                System.out.println("Caught expected exception: " + e.getClass().getSimpleName());
            } else {
                throw new RuntimeException(e);
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Use Generic Exceptions ===\n");
        
        // Using workaround
        handleException(
            () -> {
                throw new IllegalArgumentException("Test exception");
            },
            IllegalArgumentException.class
        );
        
        handleException(
            () -> {
                throw new NullPointerException("Null test");
            },
            NullPointerException.class
        );
    }
}
```

---

## üíª Example 7: Cannot Overload with Same Erasure

```java
import java.util.*;

public class CannotOverloadSameErasure {
    // ERROR: Methods with same erasure
    // public void process(List<String> list) { }
    // public void process(List<Integer> list) { }  // Compile error
    
    // Solution 1: Different method names
    public void processStrings(List<String> list) {
        System.out.println("Processing strings: " + list);
    }
    
    public void processIntegers(List<Integer> list) {
        System.out.println("Processing integers: " + list);
    }
    
    // Solution 2: Different number of parameters
    public void process(List<String> list) {
        System.out.println("Processing one list: " + list);
    }
    
    public void process(List<String> list1, List<String> list2) {
        System.out.println("Processing two lists");
    }
    
    // Solution 3: Different parameter types
    public void handle(List<String> list) {
        System.out.println("Handling list: " + list);
    }
    
    public void handle(Set<String> set) {
        System.out.println("Handling set: " + set);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Overload with Same Erasure ===\n");
        
        CannotOverloadSameErasure obj = new CannotOverloadSameErasure();
        
        List<String> strings = Arrays.asList("A", "B", "C");
        List<Integer> integers = Arrays.asList(1, 2, 3);
        
        obj.processStrings(strings);
        obj.processIntegers(integers);
        
        System.out.println();
        obj.process(strings);
        obj.process(strings, strings);
        
        System.out.println();
        obj.handle(strings);
        obj.handle(new HashSet<>(strings));
    }
}
```

---

## üíª Example 8: Cannot Create Array of Type Parameter

```java
public class CannotCreateTypeArray<T> {
    // ERROR: Cannot create array of type parameter
    // private T[] array = new T[10];  // Compile error
    
    // Solution 1: Use Object array
    private Object[] array;
    
    public CannotCreateTypeArray(int size) {
        array = new Object[size];
    }
    
    @SuppressWarnings("unchecked")
    public T get(int index) {
        return (T) array[index];
    }
    
    public void set(int index, T value) {
        array[index] = value;
    }
    
    // Solution 2: Use List
    private java.util.List<T> list = new java.util.ArrayList<>();
    
    public void add(T element) {
        list.add(element);
    }
    
    public T getFromList(int index) {
        return list.get(index);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Cannot Create Array of Type Parameter ===\n");
        
        CannotCreateTypeArray<String> container = new CannotCreateTypeArray<>(5);
        container.set(0, "Hello");
        container.set(1, "World");
        
        System.out.println("From array:");
        System.out.println("Index 0: " + container.get(0));
        System.out.println("Index 1: " + container.get(1));
        
        container.add("Java");
        container.add("Generics");
        
        System.out.println("\nFrom list:");
        System.out.println("Index 0: " + container.getFromList(0));
        System.out.println("Index 1: " + container.getFromList(1));
    }
}
```

---

## üíª Example 9: Cannot Use Varargs with Generic Type

```java
import java.util.*;

public class VarargsRestriction {
    // Warning: Possible heap pollution
    @SafeVarargs
    public static <T> List<T> createList(T... elements) {
        List<T> list = new ArrayList<>();
        for (T element : elements) {
            list.add(element);
        }
        return list;
    }
    
    // Without @SafeVarargs - generates warning
    public static <T> void printAll(T... elements) {
        for (T element : elements) {
            System.out.println(element);
        }
    }
    
    // Heap pollution example
    @SafeVarargs
    static <T> void dangerousMethod(T... items) {
        Object[] objects = items;
        System.out.println("Array type: " + items.getClass().getComponentType());
    }
    
    public static void main(String[] args) {
        System.out.println("=== Varargs with Generic Type ===\n");
        
        List<String> strings = createList("A", "B", "C");
        System.out.println("Created list: " + strings);
        
        List<Integer> numbers = createList(1, 2, 3, 4, 5);
        System.out.println("Created numbers: " + numbers);
        
        System.out.println("\nPrinting all:");
        printAll("Hello", "World", "Java");
        
        System.out.println();
        dangerousMethod("X", "Y", "Z");
    }
}
```

---

## üíª Example 10: Real-World Workarounds

```java
import java.util.*;
import java.util.function.*;

public class GenericWorkarounds {
    // Generic factory with Class token
    static class Factory<T> {
        private Class<T> type;
        
        public Factory(Class<T> type) {
            this.type = type;
        }
        
        public T create() {
            try {
                return type.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException("Cannot create instance", e);
            }
        }
        
        public T[] createArray(int size) {
            @SuppressWarnings("unchecked")
            T[] array = (T[]) java.lang.reflect.Array.newInstance(type, size);
            return array;
        }
    }
    
    // Generic container using List instead of array
    static class Container<T> {
        private List<T> items = new ArrayList<>();
        
        public void add(T item) {
            items.add(item);
        }
        
        public T get(int index) {
            return items.get(index);
        }
        
        public int size() {
            return items.size();
        }
        
        public List<T> getAll() {
            return new ArrayList<>(items);
        }
    }
    
    // Using Supplier for object creation
    static class Builder<T> {
        private Supplier<T> supplier;
        
        public Builder(Supplier<T> supplier) {
            this.supplier = supplier;
        }
        
        public T build() {
            return supplier.get();
        }
        
        public List<T> buildMultiple(int count) {
            List<T> list = new ArrayList<>();
            for (int i = 0; i < count; i++) {
                list.add(supplier.get());
            }
            return list;
        }
    }
    
    static class Person {
        private static int counter = 0;
        private String name;
        
        public Person() {
            this.name = "Person" + (++counter);
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Real-World Workarounds ===\n");
        
        // Using Factory with Class token
        Factory<Person> factory = new Factory<>(Person.class);
        Person p1 = factory.create();
        System.out.println("Created with factory: " + p1);
        
        Person[] people = factory.createArray(3);
        System.out.println("Created array: " + Arrays.toString(people));
        
        // Using Container with List
        Container<String> container = new Container<>();
        container.add("Item1");
        container.add("Item2");
        container.add("Item3");
        
        System.out.println("\nContainer items: " + container.getAll());
        
        // Using Builder with Supplier
        Builder<Person> builder = new Builder<>(Person::new);
        Person p2 = builder.build();
        System.out.println("\nBuilt with supplier: " + p2);
        
        List<Person> persons = builder.buildMultiple(3);
        System.out.println("Built multiple: " + persons);
    }
}
```

---

## üìä Generic Restrictions Summary

| Restriction | Reason | Workaround |
|-------------|--------|------------|
| **Cannot instantiate T** | Type erasure | Use Class token or Supplier |
| **Cannot create T[]** | Array covariance + erasure | Use List or Object[] with cast |
| **Cannot use primitives** | Generics work with objects | Use wrapper classes |
| **Cannot use static T** | Static shared across types | Use static generic method |
| **Cannot instanceof T** | Type information erased | Use Class.isInstance() |
| **Cannot catch T** | Exception handling limitation | Use Class token check |
| **Cannot overload same erasure** | Methods have same signature | Different method names |

---

## üí° Best Practices

1. ‚úÖ **Use Class tokens for instantiation**
   ```java
   public <T> T create(Class<T> clazz) throws Exception {
       return clazz.getDeclaredConstructor().newInstance();
   }
   ```

2. ‚úÖ **Prefer List over arrays**
   ```java
   List<T> list = new ArrayList<>();  // Better
   T[] array = ...; // Avoid
   ```

3. ‚úÖ **Use @SafeVarargs for varargs**
   ```java
   @SafeVarargs
   public static <T> List<T> of(T... elements) { }
   ```

4. ‚úÖ **Use Supplier for object creation**
   ```java
   public <T> T create(Supplier<T> supplier) {
       return supplier.get();
   }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class RestrictionPitfalls<T> {
    // 1. Trying to instantiate
    // public T create() {
    //     return new T();  // ERROR
    // }
    
    // 2. Creating generic array
    // private T[] array = new T[10];  // ERROR
    
    // 3. Using primitives
    // List<int> numbers;  // ERROR
    
    // 4. Static with type parameter
    // private static T value;  // ERROR
    
    // 5. instanceof with parameterized type
    // if (obj instanceof List<String>) { }  // ERROR
    
    // 6. Catching type parameter
    // try { }
    // catch (T e) { }  // ERROR
}
```

---

## üéØ Interview Questions

1. **What are the main restrictions of generics in Java?**
2. **Why can't we instantiate type parameters?**
3. **Why can't we create generic arrays?**
4. **Why can't we use primitives with generics?**
5. **Can we have static fields of type parameter?**
6. **Can we use instanceof with parameterized types?**
7. **Can we catch generic exceptions?**
8. **Why can't we overload methods with same erasure?**
9. **What is @SafeVarargs annotation?**
10. **How to create instances of type parameter?**
11. **Workaround for generic array creation?**
12. **How to check type at runtime?**
13. **Why these restrictions exist?**
14. **What is heap pollution?**
15. **Best practices for working with restrictions?**

---

## üìö Related Topics

- [Introduction to Generics](01.%20Introduction%20to%20Generics.md)
- [Generic Classes](02.%20Generic%20Classes.md)
- [Generic Methods](03.%20Generic%20Methods.md)
- [Bounded Type Parameters](04.%20Bounded%20Type%20Parameters.md)
- [Type Erasure](06.%20Type%20Erasure.md)
