# üÉè Wildcards in Generics

## üìñ Overview

**Wildcards** represent an unknown type in generics. They provide flexibility when working with generic types, especially in method parameters.

**Types of Wildcards:**
- `?` - Unbounded wildcard
- `? extends Type` - Upper bounded wildcard
- `? super Type` - Lower bounded wildcard

**Key Points:**
- Wildcards increase flexibility
- PECS principle: Producer Extends, Consumer Super
- Cannot instantiate with wildcard
- Used mainly in method parameters

---

## üíª Example 1: Unbounded Wildcard (?)

```java
import java.util.*;

public class UnboundedWildcard {
    // Method accepting list of any type
    public static void printList(List<?> list) {
        for (Object element : list) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Count elements
    public static int countElements(List<?> list) {
        return list.size();
    }
    
    // Check if empty
    public static boolean isEmpty(List<?> list) {
        return list.isEmpty();
    }
    
    public static void main(String[] args) {
        System.out.println("=== Unbounded Wildcard ===\n");
        
        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);
        List<String> strings = Arrays.asList("A", "B", "C");
        List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
        
        System.out.println("Integers:");
        printList(integers);
        System.out.println("Count: " + countElements(integers));
        
        System.out.println("\nStrings:");
        printList(strings);
        System.out.println("Count: " + countElements(strings));
        
        System.out.println("\nDoubles:");
        printList(doubles);
        System.out.println("Empty: " + isEmpty(doubles));
    }
}
```

**Output:**
```
=== Unbounded Wildcard ===

Integers:
1 2 3 4 5 
Count: 5

Strings:
A B C 
Count: 3

Doubles:
1.1 2.2 3.3 
Empty: false
```

---

## üíª Example 2: Upper Bounded Wildcard (? extends)

```java
import java.util.*;

public class UpperBoundedWildcard {
    // Sum of numbers (producer)
    public static double sum(List<? extends Number> numbers) {
        double total = 0;
        for (Number num : numbers) {
            total += num.doubleValue();
        }
        return total;
    }
    
    // Find max number
    public static double findMax(List<? extends Number> numbers) {
        if (numbers.isEmpty()) {
            throw new IllegalArgumentException("Empty list");
        }
        
        double max = numbers.get(0).doubleValue();
        for (Number num : numbers) {
            if (num.doubleValue() > max) {
                max = num.doubleValue();
            }
        }
        return max;
    }
    
    // Average
    public static double average(List<? extends Number> numbers) {
        if (numbers.isEmpty()) return 0;
        return sum(numbers) / numbers.size();
    }
    
    public static void main(String[] args) {
        System.out.println("=== Upper Bounded Wildcard ===\n");
        
        List<Integer> integers = Arrays.asList(10, 20, 30, 40, 50);
        List<Double> doubles = Arrays.asList(1.5, 2.5, 3.5, 4.5);
        List<Float> floats = Arrays.asList(1.0f, 2.0f, 3.0f);
        
        System.out.println("Integers: " + integers);
        System.out.println("Sum: " + sum(integers));
        System.out.println("Max: " + findMax(integers));
        System.out.println("Average: " + average(integers));
        
        System.out.println("\nDoubles: " + doubles);
        System.out.println("Sum: " + sum(doubles));
        System.out.println("Average: " + average(doubles));
        
        System.out.println("\nFloats: " + floats);
        System.out.println("Sum: " + sum(floats));
    }
}
```

---

## üíª Example 3: Lower Bounded Wildcard (? super)

```java
import java.util.*;

public class LowerBoundedWildcard {
    // Add integers to any super type list (consumer)
    public static void addNumbers(List<? super Integer> list) {
        list.add(1);
        list.add(2);
        list.add(3);
        System.out.println("Added: 1, 2, 3");
    }
    
    // Copy from source to destination
    public static <T> void copy(List<? extends T> source, List<? super T> dest) {
        for (T item : source) {
            dest.add(item);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lower Bounded Wildcard ===\n");
        
        List<Integer> integers = new ArrayList<>();
        List<Number> numbers = new ArrayList<>();
        List<Object> objects = new ArrayList<>();
        
        // Can add to Integer or its supertypes
        addNumbers(integers);
        System.out.println("Integers: " + integers);
        
        addNumbers(numbers);
        System.out.println("Numbers: " + numbers);
        
        addNumbers(objects);
        System.out.println("Objects: " + objects);
        
        // Copy example
        List<Integer> source = Arrays.asList(10, 20, 30);
        List<Number> destination = new ArrayList<>();
        
        System.out.println("\nCopying from Integer to Number:");
        copy(source, destination);
        System.out.println("Destination: " + destination);
    }
}
```

---

## üíª Example 4: PECS Principle

```java
import java.util.*;

public class PECSPrinciple {
    // Producer Extends - reading from source
    public static double sumAll(List<? extends Number> producer) {
        double sum = 0;
        for (Number num : producer) {  // Reading - Producer
            sum += num.doubleValue();
        }
        return sum;
    }
    
    // Consumer Super - writing to destination
    public static void addIntegers(List<? super Integer> consumer) {
        consumer.add(1);  // Writing - Consumer
        consumer.add(2);
        consumer.add(3);
    }
    
    // PECS in action: copy method
    public static <T> void copyElements(
            List<? extends T> source,      // Producer Extends
            List<? super T> destination) { // Consumer Super
        for (T element : source) {
            destination.add(element);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== PECS Principle ===\n");
        
        // Producer Extends
        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);
        System.out.println("Sum of integers: " + sumAll(integers));
        
        List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
        System.out.println("Sum of doubles: " + sumAll(doubles));
        
        // Consumer Super
        List<Number> numbers = new ArrayList<>();
        addIntegers(numbers);
        System.out.println("\nNumbers after add: " + numbers);
        
        // PECS copy
        List<Integer> source = Arrays.asList(10, 20, 30);
        List<Object> destination = new ArrayList<>();
        
        copyElements(source, destination);
        System.out.println("\nCopied to destination: " + destination);
    }
}
```

---

## ÔøΩÔøΩ Example 5: Wildcard with Collections

```java
import java.util.*;

public class WildcardCollections {
    // Print any collection
    public static void printCollection(Collection<?> collection) {
        System.out.print("[");
        boolean first = true;
        for (Object element : collection) {
            if (!first) System.out.print(", ");
            System.out.print(element);
            first = false;
        }
        System.out.println("]");
    }
    
    // Check if any collection is empty
    public static boolean isAnyEmpty(Collection<?>... collections) {
        for (Collection<?> collection : collections) {
            if (collection.isEmpty()) {
                return true;
            }
        }
        return false;
    }
    
    // Get total size
    public static int totalSize(Collection<?>... collections) {
        int total = 0;
        for (Collection<?> collection : collections) {
            total += collection.size();
        }
        return total;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Wildcard Collections ===\n");
        
        List<String> strings = Arrays.asList("A", "B", "C");
        Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Queue<Double> doubles = new LinkedList<>(Arrays.asList(1.1, 2.2));
        
        System.out.println("List:");
        printCollection(strings);
        
        System.out.println("\nSet:");
        printCollection(numbers);
        
        System.out.println("\nQueue:");
        printCollection(doubles);
        
        System.out.println("\nAny empty? " + isAnyEmpty(strings, numbers, doubles));
        System.out.println("Total size: " + totalSize(strings, numbers, doubles));
    }
}
```

---

## üíª Example 6: Wildcard Restrictions

```java
import java.util.*;

public class WildcardRestrictions {
    public static void demonstrateRestrictions() {
        List<?> wildcardList = new ArrayList<String>();
        
        // Can read as Object
        Object obj = wildcardList.get(0);  // OK (if not empty)
        
        // Cannot add (except null)
        // wildcardList.add("test");  // ERROR
        // wildcardList.add(1);       // ERROR
        wildcardList.add(null);       // OK - null is valid for any type
        
        // Can get size, check empty
        int size = wildcardList.size();
        boolean empty = wildcardList.isEmpty();
        
        System.out.println("Size: " + size);
        System.out.println("Empty: " + empty);
    }
    
    public static void upperBoundRestrictions() {
        List<? extends Number> numbers = new ArrayList<Integer>();
        
        // Can read as Number
        Number num = numbers.get(0);  // OK (if not empty)
        
        // Cannot add
        // numbers.add(1);        // ERROR
        // numbers.add(1.5);      // ERROR
        // numbers.add(Integer.valueOf(1));  // ERROR
        
        System.out.println("Upper bound list created");
    }
    
    public static void lowerBoundRestrictions() {
        List<? super Integer> list = new ArrayList<Number>();
        
        // Can add Integer and its subtypes
        list.add(1);              // OK
        list.add(Integer.valueOf(2));  // OK
        
        // Cannot read as Integer
        // Integer num = list.get(0);  // ERROR
        Object obj = list.get(0);      // OK - can read as Object
        
        System.out.println("Lower bound list: " + list);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Wildcard Restrictions ===\n");
        
        demonstrateRestrictions();
        System.out.println();
        
        upperBoundRestrictions();
        System.out.println();
        
        lowerBoundRestrictions();
    }
}
```

---

## üíª Example 7: Wildcard vs Type Parameter

```java
import java.util.*;

public class WildcardVsTypeParameter {
    // Using wildcard - can't return same type
    public static double sumWildcard(List<? extends Number> numbers) {
        double sum = 0;
        for (Number num : numbers) {
            sum += num.doubleValue();
        }
        return sum;  // Returns primitive double
    }
    
    // Using type parameter - can return same type
    public static <T extends Number> T firstElement(List<T> list) {
        return list.isEmpty() ? null : list.get(0);  // Returns T
    }
    
    // Wildcard - read only
    public static void printWildcard(List<?> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
    
    // Type parameter - can modify
    public static <T> void addToList(List<T> list, T element) {
        list.add(element);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Wildcard vs Type Parameter ===\n");
        
        List<Integer> integers = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        // Wildcard usage
        System.out.println("Sum: " + sumWildcard(integers));
        
        // Type parameter usage
        Integer first = firstElement(integers);
        System.out.println("First element: " + first);
        
        // Type parameter for modification
        addToList(integers, 4);
        System.out.println("After adding 4: " + integers);
    }
}
```

---

## üíª Example 8: Multiple Wildcards

```java
import java.util.*;

public class MultipleWildcards {
    // Two wildcards - both can be different
    public static void copyDifferentTypes(
            List<? extends Number> source,
            List<? super Number> dest) {
        for (Number num : source) {
            dest.add(num);
        }
    }
    
    // Compare sizes of two lists
    public static boolean sameSizes(List<?> list1, List<?> list2) {
        return list1.size() == list2.size();
    }
    
    // Check if one list contains all of another
    public static boolean containsAll(
            Collection<?> collection,
            Collection<?> elements) {
        for (Object element : elements) {
            if (!collection.contains(element)) {
                return false;
            }
        }
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Multiple Wildcards ===\n");
        
        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);
        List<Number> numbers = new ArrayList<>();
        
        copyDifferentTypes(integers, numbers);
        System.out.println("Copied integers to numbers: " + numbers);
        
        List<String> strings1 = Arrays.asList("A", "B", "C");
        List<Double> doubles = Arrays.asList(1.0, 2.0, 3.0);
        
        System.out.println("\nSame sizes? " + sameSizes(strings1, doubles));
        
        List<String> strings2 = Arrays.asList("A", "B");
        System.out.println("Contains all? " + containsAll(strings1, strings2));
    }
}
```

---

## üíª Example 9: Real-World Example - Data Processor

```java
import java.util.*;

public class DataProcessor {
    // Process any numeric data
    public static class NumericProcessor {
        public static void processNumbers(List<? extends Number> numbers) {
            System.out.println("Processing " + numbers.size() + " numbers");
            System.out.printf("Sum: %.2f%n", sum(numbers));
            System.out.printf("Average: %.2f%n", average(numbers));
            System.out.printf("Max: %.2f%n", max(numbers));
            System.out.printf("Min: %.2f%n", min(numbers));
        }
        
        private static double sum(List<? extends Number> numbers) {
            double total = 0;
            for (Number num : numbers) {
                total += num.doubleValue();
            }
            return total;
        }
        
        private static double average(List<? extends Number> numbers) {
            return numbers.isEmpty() ? 0 : sum(numbers) / numbers.size();
        }
        
        private static double max(List<? extends Number> numbers) {
            if (numbers.isEmpty()) return 0;
            
            double maximum = numbers.get(0).doubleValue();
            for (Number num : numbers) {
                if (num.doubleValue() > maximum) {
                    maximum = num.doubleValue();
                }
            }
            return maximum;
        }
        
        private static double min(List<? extends Number> numbers) {
            if (numbers.isEmpty()) return 0;
            
            double minimum = numbers.get(0).doubleValue();
            for (Number num : numbers) {
                if (num.doubleValue() < minimum) {
                    minimum = num.doubleValue();
                }
            }
            return minimum;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Data Processor ===\n");
        
        List<Integer> scores = Arrays.asList(85, 90, 78, 92, 88, 95);
        System.out.println("Student Scores:");
        NumericProcessor.processNumbers(scores);
        
        System.out.println("\nTemperatures (Celsius):");
        List<Double> temperatures = Arrays.asList(36.5, 36.8, 37.0, 36.9, 36.7);
        NumericProcessor.processNumbers(temperatures);
        
        System.out.println("\nProduct Prices:");
        List<Float> prices = Arrays.asList(19.99f, 29.99f, 39.99f, 49.99f);
        NumericProcessor.processNumbers(prices);
    }
}
```

---

## üíª Example 10: Collection Utilities

```java
import java.util.*;

public class CollectionUtilities {
    // Merge multiple lists into one
    public static <T> List<T> merge(List<? extends T>... lists) {
        List<T> result = new ArrayList<>();
        for (List<? extends T> list : lists) {
            result.addAll(list);
        }
        return result;
    }
    
    // Find common elements
    public static <T> Set<T> findCommon(
            Collection<? extends T> col1,
            Collection<? extends T> col2) {
        Set<T> common = new HashSet<>();
        for (T element : col1) {
            if (col2.contains(element)) {
                common.add(element);
            }
        }
        return common;
    }
    
    // Remove all occurrences
    public static <T> void removeAll(
            Collection<? super T> collection,
            Collection<? extends T> toRemove) {
        for (T element : toRemove) {
            while (collection.remove(element)) {
                // Keep removing until no more found
            }
        }
    }
    
    // Add all with filtering
    public static <T> void addFiltered(
            Collection<? super T> destination,
            Collection<? extends T> source,
            java.util.function.Predicate<? super T> filter) {
        for (T element : source) {
            if (filter.test(element)) {
                destination.add(element);
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Collection Utilities ===\n");
        
        // Merge lists
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(4, 5, 6);
        List<Integer> list3 = Arrays.asList(7, 8, 9);
        
        List<Integer> merged = merge(list1, list2, list3);
        System.out.println("Merged lists: " + merged);
        
        // Find common
        Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C", "D"));
        Set<String> set2 = new HashSet<>(Arrays.asList("C", "D", "E", "F"));
        
        Set<String> common = findCommon(set1, set2);
        System.out.println("\nCommon elements: " + common);
        
        // Remove all
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 2, 4, 2, 5));
        List<Integer> toRemove = Arrays.asList(2, 4);
        
        System.out.println("\nBefore removal: " + numbers);
        removeAll(numbers, toRemove);
        System.out.println("After removal: " + numbers);
        
        // Add filtered
        List<Integer> source = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Integer> evens = new ArrayList<>();
        
        addFiltered(evens, source, n -> n % 2 == 0);
        System.out.println("\nEven numbers: " + evens);
    }
}
```

---

## üìä Wildcard Types Comparison

| Wildcard Type | Syntax | Can Read | Can Write | Use Case |
|---------------|--------|----------|-----------|----------|
| **Unbounded** | `?` | As Object | Only null | Unknown type |
| **Upper Bounded** | `? extends T` | As T | Only null | Producer (reading) |
| **Lower Bounded** | `? super T` | As Object | T and subtypes | Consumer (writing) |

---

## üí° Best Practices

1. ‚úÖ **Follow PECS principle**
   ```java
   // Producer Extends
   public void process(List<? extends Number> producer) { }
   
   // Consumer Super
   public void add(List<? super Integer> consumer) { }
   ```

2. ‚úÖ **Use wildcards for flexibility**
   ```java
   public void print(List<?> list) { }  // Any type
   ```

3. ‚úÖ **Use type parameters when returning same type**
   ```java
   public <T> T getFirst(List<T> list) {  // Returns T
       return list.isEmpty() ? null : list.get(0);
   }
   ```

4. ‚úÖ **Unbounded for type-agnostic operations**
   ```java
   public int size(Collection<?> collection) {
       return collection.size();
   }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class WildcardPitfalls {
    // 1. Cannot add to upper bounded wildcard
    public void wrong1(List<? extends Number> list) {
        // list.add(1);  // ERROR
        // list.add(1.5);  // ERROR
    }
    
    // 2. Can only read as Object from lower bounded
    public void wrong2(List<? super Integer> list) {
        // Integer num = list.get(0);  // ERROR
        Object obj = list.get(0);  // OK
    }
    
    // 3. Cannot instantiate with wildcard
    // List<?> list = new ArrayList<?>();  // ERROR
    List<?> list = new ArrayList<String>();  // OK
    
    // 4. Wildcard capture issues
    public void wrong3(List<?> list) {
        // Cannot call methods requiring same type
        // list.set(0, list.get(0));  // ERROR
    }
}
```

---

## üéØ Interview Questions

1. **What are wildcards in generics?**
2. **Types of wildcards?**
3. **What is unbounded wildcard?**
4. **What is upper bounded wildcard?**
5. **What is lower bounded wildcard?**
6. **What is PECS principle?**
7. **When to use `? extends`?**
8. **When to use `? super`?**
9. **Can we add elements to `List<? extends T>`?**
10. **Can we add elements to `List<? super T>`?**
11. **Difference between `?` and `Object`?**
12. **When to use wildcard vs type parameter?**
13. **Can we instantiate with wildcard?**
14. **What is wildcard capture?**
15. **Best practices for wildcards?**

---

## ÔøΩÔøΩ Related Topics

- [Introduction to Generics](01.%20Introduction%20to%20Generics.md)
- [Generic Classes](02.%20Generic%20Classes.md)
- [Generic Methods](03.%20Generic%20Methods.md)
- [Bounded Type Parameters](04.%20Bounded%20Type%20Parameters.md)
- [Type Erasure](06.%20Type%20Erasure.md)
