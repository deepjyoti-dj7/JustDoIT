# üéØ Introduction to Generics

## üìñ Overview

**Generics** enable types (classes and interfaces) to be parameters when defining classes, interfaces, and methods. They provide compile-time type safety and eliminate the need for type casting.

**Key Benefits:**
- Type safety at compile time
- Elimination of type casting
- Code reusability
- Cleaner and more readable code

**Introduced in:** Java 5 (2004)

---

## üéØ Why Generics?

### Without Generics (Before Java 5)

```java
List list = new ArrayList();
list.add("Hello");
list.add(100);  // Can add anything!

String str = (String) list.get(0);  // Explicit casting
String num = (String) list.get(1);  // Runtime error - ClassCastException!
```

### With Generics (Java 5+)

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(100);  // Compile error - type safe!

String str = list.get(0);  // No casting needed
```

---

## üíª Example 1: Problem Without Generics

```java
import java.util.*;

public class WithoutGenerics {
    public static void main(String[] args) {
        System.out.println("=== Without Generics (Old Way) ===\n");
        
        // Can store any type
        List list = new ArrayList();
        list.add("Java");
        list.add(100);
        list.add(45.5);
        list.add(true);
        
        System.out.println("List contents: " + list);
        
        // Type casting required
        String str = (String) list.get(0);
        System.out.println("String: " + str);
        
        // Runtime error - ClassCastException
        try {
            String wrongType = (String) list.get(1);
        } catch (ClassCastException e) {
            System.out.println("\nRuntime Error: " + e.getMessage());
            System.out.println("Cannot cast Integer to String");
        }
        
        // Need to check types manually
        for (Object obj : list) {
            if (obj instanceof String) {
                System.out.println("String: " + obj);
            } else if (obj instanceof Integer) {
                System.out.println("Integer: " + obj);
            }
        }
    }
}
```

---

## üíª Example 2: Solution With Generics

```java
import java.util.*;

public class WithGenerics {
    public static void main(String[] args) {
        System.out.println("=== With Generics (Type Safe) ===\n");
        
        // Type specified - only String allowed
        List<String> stringList = new ArrayList<>();
        stringList.add("Java");
        stringList.add("Python");
        stringList.add("JavaScript");
        // stringList.add(100);  // Compile error!
        
        System.out.println("String List: " + stringList);
        
        // No type casting needed
        String first = stringList.get(0);
        System.out.println("First element: " + first);
        
        // Type safe iteration
        for (String str : stringList) {
            System.out.println("Language: " + str);
        }
        
        // Different type for numbers
        List<Integer> intList = new ArrayList<>();
        intList.add(10);
        intList.add(20);
        intList.add(30);
        // intList.add("Hello");  // Compile error!
        
        System.out.println("\nInteger List: " + intList);
        
        // Type safe operations
        int sum = 0;
        for (Integer num : intList) {
            sum += num;  // No casting needed
        }
        System.out.println("Sum: " + sum);
    }
}
```

---

## üíª Example 3: Generic Class Basics

```java
// Non-generic class
class BoxWithoutGenerics {
    private Object content;
    
    public void set(Object content) {
        this.content = content;
    }
    
    public Object get() {
        return content;
    }
}

// Generic class
class Box<T> {
    private T content;
    
    public void set(T content) {
        this.content = content;
    }
    
    public T get() {
        return content;
    }
}

public class GenericClassBasics {
    public static void main(String[] args) {
        System.out.println("=== Generic Class Example ===\n");
        
        // Without generics
        System.out.println("1. Without Generics:");
        BoxWithoutGenerics box1 = new BoxWithoutGenerics();
        box1.set("Hello");
        String str = (String) box1.get();  // Casting required
        System.out.println("Content: " + str);
        
        box1.set(100);  // Can change type
        try {
            String wrong = (String) box1.get();
        } catch (ClassCastException e) {
            System.out.println("Runtime error: Cannot cast Integer to String");
        }
        
        // With generics
        System.out.println("\n2. With Generics:");
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello");
        String value = stringBox.get();  // No casting
        System.out.println("String Box: " + value);
        
        Box<Integer> intBox = new Box<>();
        intBox.set(100);
        // intBox.set("Hello");  // Compile error!
        Integer number = intBox.get();
        System.out.println("Integer Box: " + number);
        
        Box<Double> doubleBox = new Box<>();
        doubleBox.set(3.14);
        System.out.println("Double Box: " + doubleBox.get());
    }
}
```

---

## üíª Example 4: Generic Method Basics

```java
public class GenericMethodBasics {
    // Non-generic method
    static void printArray(Object[] array) {
        for (Object element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Generic method
    static <T> void printGenericArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Generic method with return type
    static <T> T getFirst(T[] array) {
        if (array != null && array.length > 0) {
            return array[0];
        }
        return null;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Methods ===\n");
        
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] strArray = {"A", "B", "C"};
        Double[] doubleArray = {1.1, 2.2, 3.3};
        
        System.out.println("Printing arrays:");
        printGenericArray(intArray);
        printGenericArray(strArray);
        printGenericArray(doubleArray);
        
        System.out.println("\nGetting first elements:");
        System.out.println("First integer: " + getFirst(intArray));
        System.out.println("First string: " + getFirst(strArray));
        System.out.println("First double: " + getFirst(doubleArray));
    }
}
```

---

## üíª Example 5: Multiple Type Parameters

```java
class Pair<K, V> {
    private K key;
    private V value;
    
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    public K getKey() { return key; }
    public V getValue() { return value; }
    
    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    
    @Override
    public String toString() {
        return "(" + key + ", " + value + ")";
    }
}

class Triple<A, B, C> {
    private A first;
    private B second;
    private C third;
    
    public Triple(A first, B second, C third) {
        this.first = first;
        this.second = second;
        this.third = third;
    }
    
    @Override
    public String toString() {
        return "(" + first + ", " + second + ", " + third + ")";
    }
}

public class MultipleTypeParameters {
    public static void main(String[] args) {
        System.out.println("=== Multiple Type Parameters ===\n");
        
        // Pair examples
        Pair<String, Integer> pair1 = new Pair<>("Age", 25);
        System.out.println("Pair 1: " + pair1);
        
        Pair<Integer, String> pair2 = new Pair<>(1, "First");
        System.out.println("Pair 2: " + pair2);
        
        Pair<String, Double> pair3 = new Pair<>("Price", 99.99);
        System.out.println("Pair 3: " + pair3);
        
        // Triple example
        Triple<String, Integer, Boolean> triple = 
            new Triple<>("Active", 100, true);
        System.out.println("\nTriple: " + triple);
        
        // Map example (built-in generic)
        java.util.Map<String, Integer> scores = new java.util.HashMap<>();
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);
        
        System.out.println("\nScores:");
        for (java.util.Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

---

## üíª Example 6: Generic Interface

```java
interface Container<T> {
    void add(T item);
    T get(int index);
    int size();
}

class SimpleContainer<T> implements Container<T> {
    private java.util.List<T> items = new java.util.ArrayList<>();
    
    @Override
    public void add(T item) {
        items.add(item);
    }
    
    @Override
    public T get(int index) {
        return items.get(index);
    }
    
    @Override
    public int size() {
        return items.size();
    }
}

public class GenericInterface {
    public static void main(String[] args) {
        System.out.println("=== Generic Interface ===\n");
        
        // String container
        Container<String> stringContainer = new SimpleContainer<>();
        stringContainer.add("Apple");
        stringContainer.add("Banana");
        stringContainer.add("Cherry");
        
        System.out.println("String Container:");
        for (int i = 0; i < stringContainer.size(); i++) {
            System.out.println(stringContainer.get(i));
        }
        
        // Integer container
        Container<Integer> intContainer = new SimpleContainer<>();
        intContainer.add(10);
        intContainer.add(20);
        intContainer.add(30);
        
        System.out.println("\nInteger Container:");
        for (int i = 0; i < intContainer.size(); i++) {
            System.out.println(intContainer.get(i));
        }
    }
}
```

---

## üíª Example 7: Common Generic Collections

```java
import java.util.*;

public class GenericCollections {
    public static void main(String[] args) {
        System.out.println("=== Generic Collections ===\n");
        
        // List
        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        System.out.println("List: " + names);
        
        // Set
        Set<Integer> numbers = new HashSet<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(1);  // Duplicate ignored
        System.out.println("Set: " + numbers);
        
        // Map
        Map<String, Integer> ages = new HashMap<>();
        ages.put("Alice", 25);
        ages.put("Bob", 30);
        ages.put("Charlie", 28);
        System.out.println("Map: " + ages);
        
        // Queue
        Queue<String> queue = new LinkedList<>();
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        System.out.println("Queue: " + queue);
        System.out.println("Poll: " + queue.poll());
        System.out.println("After poll: " + queue);
        
        // Stack (Vector is generic)
        Stack<Integer> stack = new Stack<>();
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println("\nStack: " + stack);
        System.out.println("Pop: " + stack.pop());
        System.out.println("After pop: " + stack);
    }
}
```

---

## üíª Example 8: Type Safety Demonstration

```java
import java.util.*;

class Student {
    String name;
    int age;
    
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class TypeSafetyDemo {
    public static void main(String[] args) {
        System.out.println("=== Type Safety with Generics ===\n");
        
        // Type safe list
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 20));
        students.add(new Student("Bob", 22));
        // students.add("Charlie");  // Compile error!
        // students.add(100);         // Compile error!
        
        System.out.println("Students:");
        for (Student student : students) {
            System.out.println(student.name + " is " + student.age + " years old");
        }
        
        // Type safe with operations
        List<Integer> scores = Arrays.asList(85, 90, 78, 92, 88);
        
        int total = 0;
        for (Integer score : scores) {
            total += score;  // No casting, type safe
        }
        
        double average = (double) total / scores.size();
        System.out.println("\nScores: " + scores);
        System.out.println("Average: " + average);
        
        // Compile-time checking
        List<String> strings = new ArrayList<>();
        strings.add("Hello");
        // int length = strings.get(0).length();  // Works, String method
        // int value = strings.get(0) + 10;       // Compile error!
    }
}
```

---

## üíª Example 9: Generic vs Raw Types

```java
import java.util.*;

public class GenericVsRaw {
    public static void main(String[] args) {
        System.out.println("=== Generic vs Raw Types ===\n");
        
        // Raw type (not recommended)
        List rawList = new ArrayList();
        rawList.add("String");
        rawList.add(100);
        rawList.add(true);
        
        System.out.println("Raw list: " + rawList);
        System.out.println("No compile-time type checking!");
        
        // Generic type (recommended)
        List<String> genericList = new ArrayList<>();
        genericList.add("Java");
        genericList.add("Python");
        // genericList.add(100);  // Compile error - type safe!
        
        System.out.println("\nGeneric list: " + genericList);
        System.out.println("Compile-time type checking enabled!");
        
        // Mixing raw and generic (not recommended)
        List<Integer> numbers = new ArrayList<>();
        numbers.add(10);
        
        List rawNumbers = numbers;  // Unchecked assignment
        rawNumbers.add("Hello");    // No compile error, but dangerous!
        
        System.out.println("\nMixed list: " + rawNumbers);
        
        try {
            Integer num = numbers.get(1);  // Runtime error!
        } catch (ClassCastException e) {
            System.out.println("Runtime error: " + e.getMessage());
        }
        
        System.out.println("\nConclusion: Always use generics!");
    }
}
```

---

## üíª Example 10: Real-World Example - Repository Pattern

```java
import java.util.*;

interface Repository<T> {
    void save(T entity);
    T findById(int id);
    List<T> findAll();
    void delete(int id);
}

class User {
    int id;
    String name;
    String email;
    
    User(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    @Override
    public String toString() {
        return "User{id=" + id + ", name='" + name + "', email='" + email + "'}";
    }
}

class Product {
    int id;
    String name;
    double price;
    
    Product(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    
    @Override
    public String toString() {
        return "Product{id=" + id + ", name='" + name + "', price=" + price + "}";
    }
}

class GenericRepository<T> implements Repository<T> {
    private Map<Integer, T> storage = new HashMap<>();
    private int currentId = 1;
    
    @Override
    public void save(T entity) {
        storage.put(currentId++, entity);
    }
    
    @Override
    public T findById(int id) {
        return storage.get(id);
    }
    
    @Override
    public List<T> findAll() {
        return new ArrayList<>(storage.values());
    }
    
    @Override
    public void delete(int id) {
        storage.remove(id);
    }
}

public class RepositoryPattern {
    public static void main(String[] args) {
        System.out.println("=== Repository Pattern with Generics ===\n");
        
        // User repository
        Repository<User> userRepo = new GenericRepository<>();
        userRepo.save(new User(1, "Alice", "alice@example.com"));
        userRepo.save(new User(2, "Bob", "bob@example.com"));
        
        System.out.println("All Users:");
        for (User user : userRepo.findAll()) {
            System.out.println(user);
        }
        
        System.out.println("\nFind User by ID 1:");
        System.out.println(userRepo.findById(1));
        
        // Product repository
        Repository<Product> productRepo = new GenericRepository<>();
        productRepo.save(new Product(1, "Laptop", 999.99));
        productRepo.save(new Product(2, "Mouse", 29.99));
        productRepo.save(new Product(3, "Keyboard", 79.99));
        
        System.out.println("\nAll Products:");
        for (Product product : productRepo.findAll()) {
            System.out.println(product);
        }
        
        System.out.println("\nDeleting product ID 2");
        productRepo.delete(2);
        
        System.out.println("All Products after deletion:");
        for (Product product : productRepo.findAll()) {
            System.out.println(product);
        }
    }
}
```

---

## üìä Benefits of Generics

| Benefit | Without Generics | With Generics |
|---------|-----------------|---------------|
| **Type Safety** | Runtime errors | Compile-time errors |
| **Type Casting** | Required everywhere | Not needed |
| **Code Reusability** | Duplicate code | Single generic code |
| **Readability** | Less clear | More clear |
| **Performance** | Same | Same (after erasure) |
| **Error Detection** | At runtime | At compile time |

---

## üí° Best Practices

1. ‚úÖ **Always use generics with collections**
   ```java
   List<String> list = new ArrayList<>();  // Good
   List list = new ArrayList();             // Bad
   ```

2. ‚úÖ **Use meaningful type parameter names**
   ```java
   class Box<T> { }        // T for Type
   class Pair<K, V> { }    // K for Key, V for Value
   class List<E> { }       // E for Element
   ```

3. ‚úÖ **Avoid raw types**
   ```java
   List<String> good = new ArrayList<>();  // Good
   List bad = new ArrayList();             // Bad
   ```

4. ‚úÖ **Use diamond operator**
   ```java
   List<String> list = new ArrayList<>();      // Good (Java 7+)
   List<String> list = new ArrayList<String>(); // Verbose
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class GenericsPitfalls {
    void demonstrate() {
        // 1. Using raw types
        List list = new ArrayList();  // Loses type safety
        
        // 2. Incorrect type parameter
        // List<int> numbers = new ArrayList<>();  // ERROR: primitives not allowed
        List<Integer> numbers = new ArrayList<>();  // Use wrapper
        
        // 3. Mixing raw and generic
        List<String> strings = new ArrayList<>();
        List raw = strings;
        raw.add(100);  // Compiles but dangerous!
    }
}
```

---

## üéØ Interview Questions

1. **What are generics in Java?**
2. **Why were generics introduced?**
3. **What are the benefits of generics?**
4. **What is type erasure?**
5. **Can we use primitives with generics?**
6. **What is a raw type?**
7. **What are type parameters?**
8. **Difference between List and List<Object>?**
9. **Can we create generic arrays?**
10. **What is the diamond operator?**
11. **When were generics introduced?**
12. **What is the naming convention for type parameters?**
13. **Can we have multiple type parameters?**
14. **What are bounded type parameters?**
15. **What are wildcards in generics?**

---

## üìö Related Topics

- [Generic Classes](02.%20Generic%20Classes.md)
- [Generic Methods](03.%20Generic%20Methods.md)
- [Bounded Type Parameters](04.%20Bounded%20Type%20Parameters.md)
- [Wildcards](05.%20Wildcards.md)
- [Type Erasure](06.%20Type%20Erasure.md)
