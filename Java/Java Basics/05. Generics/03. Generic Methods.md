# üîß Generic Methods

## üìñ Overview

**Generic methods** are methods that introduce their own type parameters. Unlike generic classes where the type parameter is defined at class level, generic methods define type parameters at method level.

**Syntax:**
```java
<T> returnType methodName(T parameter) {
    // method body
}
```

**Key Points:**
- Type parameter scope is limited to the method
- Can be in generic or non-generic classes
- Type inference determines actual type
- Can have multiple type parameters

---

## üíª Example 1: Basic Generic Method

```java
public class BasicGenericMethod {
    // Generic method to print array
    public static <T> void printArray(T[] array) {
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
            if (i < array.length - 1) {
                System.out.print(", ");
            }
        }
        System.out.println("]");
    }
    
    // Generic method with return type
    public static <T> T getFirst(T[] array) {
        if (array != null && array.length > 0) {
            return array[0];
        }
        return null;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Basic Generic Methods ===\n");
        
        Integer[] intArray = {1, 2, 3, 4, 5};
        String[] strArray = {"Apple", "Banana", "Cherry"};
        Double[] doubleArray = {1.1, 2.2, 3.3};
        
        System.out.println("Printing arrays:");
        printArray(intArray);
        printArray(strArray);
        printArray(doubleArray);
        
        System.out.println("\nGetting first elements:");
        System.out.println("First integer: " + getFirst(intArray));
        System.out.println("First string: " + getFirst(strArray));
        System.out.println("First double: " + getFirst(doubleArray));
    }
}
```

**Output:**
```
=== Basic Generic Methods ===

Printing arrays:
[1, 2, 3, 4, 5]
[Apple, Banana, Cherry]
[1.1, 2.2, 3.3]

Getting first elements:
First integer: 1
First string: Apple
First double: 1.1
```

---

## üíª Example 2: Multiple Type Parameters

```java
public class MultipleTypeParams {
    // Generic method with two type parameters
    public static <K, V> void printPair(K key, V value) {
        System.out.println(key + " => " + value);
    }
    
    // Generic method returning Pair
    public static <K, V> Pair<K, V> createPair(K key, V value) {
        return new Pair<>(key, value);
    }
    
    // Helper Pair class
    static class Pair<K, V> {
        K key;
        V value;
        
        Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        @Override
        public String toString() {
            return "(" + key + ", " + value + ")";
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Multiple Type Parameters ===\n");
        
        printPair("Name", "Alice");
        printPair(1, "First");
        printPair("Price", 99.99);
        
        System.out.println();
        Pair<String, Integer> pair1 = createPair("Age", 25);
        Pair<Integer, String> pair2 = createPair(101, "Employee");
        
        System.out.println(pair1);
        System.out.println(pair2);
    }
}
```

---

## üíª Example 3: Bounded Generic Methods

```java
public class BoundedGenericMethods {
    // Method accepting only Numbers
    public static <T extends Number> double sum(T num1, T num2) {
        return num1.doubleValue() + num2.doubleValue();
    }
    
    // Method with multiple bounds
    public static <T extends Comparable<T>> T findMax(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    // Method with array and Number bound
    public static <T extends Number> double average(T[] numbers) {
        double sum = 0;
        for (T num : numbers) {
            sum += num.doubleValue();
        }
        return sum / numbers.length;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Bounded Generic Methods ===\n");
        
        System.out.println("Sum (Integer): " + sum(10, 20));
        System.out.println("Sum (Double): " + sum(15.5, 20.3));
        System.out.println("Sum (Float): " + sum(7.5f, 2.5f));
        
        System.out.println("\nFinding max:");
        System.out.println("Max integer: " + findMax(10, 20));
        System.out.println("Max string: " + findMax("Apple", "Banana"));
        System.out.println("Max double: " + findMax(3.14, 2.71));
        
        Integer[] scores = {85, 90, 78, 92, 88};
        System.out.println("\nAverage score: " + average(scores));
    }
}
```

---

## üíª Example 4: Generic Method in Non-Generic Class

```java
public class NonGenericClassWithGenericMethod {
    // Non-generic class with generic methods
    
    public <T> void display(T element) {
        System.out.println("Element: " + element);
        System.out.println("Type: " + element.getClass().getSimpleName());
    }
    
    public <T> T echo(T input) {
        System.out.println("Echoing: " + input);
        return input;
    }
    
    public <T> boolean isNull(T object) {
        return object == null;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Methods in Non-Generic Class ===\n");
        
        NonGenericClassWithGenericMethod obj = new NonGenericClassWithGenericMethod();
        
        obj.display("Hello");
        obj.display(42);
        obj.display(3.14);
        
        System.out.println();
        String result = obj.echo("Test");
        Integer num = obj.echo(100);
        
        System.out.println("\nChecking null:");
        System.out.println("Is 'Hello' null? " + obj.isNull("Hello"));
        System.out.println("Is null null? " + obj.isNull(null));
    }
}
```

---

## üíª Example 5: Generic Method with Collections

```java
import java.util.*;

public class GenericCollectionMethods {
    // Print any collection
    public static <T> void printCollection(Collection<T> collection) {
        System.out.print("[");
        boolean first = true;
        for (T element : collection) {
            if (!first) System.out.print(", ");
            System.out.print(element);
            first = false;
        }
        System.out.println("]");
    }
    
    // Convert array to list
    public static <T> List<T> arrayToList(T[] array) {
        List<T> list = new ArrayList<>();
        for (T element : array) {
            list.add(element);
        }
        return list;
    }
    
    // Find element in collection
    public static <T> boolean contains(Collection<T> collection, T element) {
        for (T item : collection) {
            if (item.equals(element)) {
                return true;
            }
        }
        return false;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Collection Methods ===\n");
        
        List<String> strings = Arrays.asList("A", "B", "C");
        Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
        
        System.out.println("Collections:");
        printCollection(strings);
        printCollection(numbers);
        
        Integer[] intArray = {10, 20, 30, 40};
        List<Integer> intList = arrayToList(intArray);
        System.out.println("\nConverted array to list:");
        printCollection(intList);
        
        System.out.println("\nContains check:");
        System.out.println("List contains 'B': " + contains(strings, "B"));
        System.out.println("Set contains 5: " + contains(numbers, 5));
    }
}
```

---

## üíª Example 6: Swap Elements Generic Method

```java
public class SwapGeneric {
    // Generic swap method
    public static <T> void swap(T[] array, int i, int j) {
        if (i < 0 || i >= array.length || j < 0 || j >= array.length) {
            throw new ArrayIndexOutOfBoundsException("Invalid indices");
        }
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    // Print array helper
    public static <T> void printArray(T[] array) {
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i]);
            if (i < array.length - 1) System.out.print(", ");
        }
        System.out.println("]");
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Swap Method ===\n");
        
        Integer[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Before swap:");
        printArray(numbers);
        
        swap(numbers, 0, 4);
        System.out.println("After swapping index 0 and 4:");
        printArray(numbers);
        
        String[] words = {"Apple", "Banana", "Cherry"};
        System.out.println("\nBefore swap:");
        printArray(words);
        
        swap(words, 0, 2);
        System.out.println("After swapping index 0 and 2:");
        printArray(words);
    }
}
```

---

## üíª Example 7: Generic Comparison Methods

```java
public class GenericComparison {
    // Compare two comparable objects
    public static <T extends Comparable<T>> int compare(T a, T b) {
        return a.compareTo(b);
    }
    
    // Find minimum
    public static <T extends Comparable<T>> T min(T a, T b) {
        return a.compareTo(b) < 0 ? a : b;
    }
    
    // Find maximum
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    // Find min in array
    public static <T extends Comparable<T>> T findMin(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        
        T min = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i].compareTo(min) < 0) {
                min = array[i];
            }
        }
        return min;
    }
    
    // Find max in array
    public static <T extends Comparable<T>> T findMax(T[] array) {
        if (array == null || array.length == 0) {
            return null;
        }
        
        T max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i].compareTo(max) > 0) {
                max = array[i];
            }
        }
        return max;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Comparison Methods ===\n");
        
        System.out.println("Compare: " + compare(10, 20));
        System.out.println("Min: " + min(10, 20));
        System.out.println("Max: " + max(10, 20));
        
        Integer[] numbers = {45, 12, 78, 23, 67};
        System.out.println("\nArray: " + java.util.Arrays.toString(numbers));
        System.out.println("Min: " + findMin(numbers));
        System.out.println("Max: " + findMax(numbers));
        
        String[] words = {"Zebra", "Apple", "Mango", "Banana"};
        System.out.println("\nArray: " + java.util.Arrays.toString(words));
        System.out.println("Min: " + findMin(words));
        System.out.println("Max: " + findMax(words));
    }
}
```

---

## üíª Example 8: Generic Search Method

```java
public class GenericSearch {
    // Linear search
    public static <T> int linearSearch(T[] array, T target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i].equals(target)) {
                return i;
            }
        }
        return -1;
    }
    
    // Count occurrences
    public static <T> int countOccurrences(T[] array, T target) {
        int count = 0;
        for (T element : array) {
            if (element.equals(target)) {
                count++;
            }
        }
        return count;
    }
    
    // Contains check
    public static <T> boolean contains(T[] array, T target) {
        return linearSearch(array, target) != -1;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Search Methods ===\n");
        
        Integer[] numbers = {10, 20, 30, 40, 20, 50};
        System.out.println("Array: " + java.util.Arrays.toString(numbers));
        
        int index = linearSearch(numbers, 30);
        System.out.println("Index of 30: " + index);
        
        int count = countOccurrences(numbers, 20);
        System.out.println("Count of 20: " + count);
        
        System.out.println("Contains 40: " + contains(numbers, 40));
        System.out.println("Contains 100: " + contains(numbers, 100));
        
        String[] words = {"apple", "banana", "apple", "cherry"};
        System.out.println("\nArray: " + java.util.Arrays.toString(words));
        System.out.println("Index of 'banana': " + linearSearch(words, "banana"));
        System.out.println("Count of 'apple': " + countOccurrences(words, "apple"));
    }
}
```

---

## üíª Example 9: Generic Utility Methods

```java
import java.util.*;

public class GenericUtilities {
    // Reverse array
    public static <T> void reverse(T[] array) {
        int left = 0;
        int right = array.length - 1;
        
        while (left < right) {
            T temp = array[left];
            array[left] = array[right];
            array[right] = temp;
            left++;
            right--;
        }
    }
    
    // Fill array with value
    public static <T> void fill(T[] array, T value) {
        for (int i = 0; i < array.length; i++) {
            array[i] = value;
        }
    }
    
    // Copy array
    public static <T> T[] copy(T[] source) {
        @SuppressWarnings("unchecked")
        T[] destination = (T[]) java.lang.reflect.Array.newInstance(
            source.getClass().getComponentType(), source.length);
        System.arraycopy(source, 0, destination, 0, source.length);
        return destination;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Utility Methods ===\n");
        
        Integer[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Original: " + Arrays.toString(numbers));
        
        reverse(numbers);
        System.out.println("Reversed: " + Arrays.toString(numbers));
        
        String[] words = new String[5];
        fill(words, "Hello");
        System.out.println("\nFilled: " + Arrays.toString(words));
        
        Integer[] original = {10, 20, 30};
        Integer[] copied = copy(original);
        System.out.println("\nOriginal: " + Arrays.toString(original));
        System.out.println("Copied: " + Arrays.toString(copied));
    }
}
```

---

## üíª Example 10: Real-World Example - Data Processor

```java
import java.util.*;
import java.util.function.Predicate;

public class DataProcessor {
    // Filter collection based on predicate
    public static <T> List<T> filter(Collection<T> collection, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T element : collection) {
            if (predicate.test(element)) {
                result.add(element);
            }
        }
        return result;
    }
    
    // Transform collection
    public static <T, R> List<R> map(Collection<T> collection, Function<T, R> mapper) {
        List<R> result = new ArrayList<>();
        for (T element : collection) {
            result.add(mapper.apply(element));
        }
        return result;
    }
    
    // Simple Function interface
    interface Function<T, R> {
        R apply(T t);
    }
    
    // Reduce collection to single value
    public static <T> T reduce(Collection<T> collection, T identity, BinaryOperator<T> accumulator) {
        T result = identity;
        for (T element : collection) {
            result = accumulator.apply(result, element);
        }
        return result;
    }
    
    interface BinaryOperator<T> {
        T apply(T a, T b);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Data Processor Example ===\n");
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        System.out.println("Original: " + numbers);
        
        // Filter even numbers
        List<Integer> evens = filter(numbers, n -> n % 2 == 0);
        System.out.println("Even numbers: " + evens);
        
        // Map to squares
        List<Integer> squares = map(numbers, n -> n * n);
        System.out.println("Squares: " + squares);
        
        // Reduce to sum
        Integer sum = reduce(numbers, 0, (a, b) -> a + b);
        System.out.println("Sum: " + sum);
        
        // String example
        List<String> words = Arrays.asList("apple", "banana", "cherry");
        System.out.println("\nOriginal words: " + words);
        
        List<String> filtered = filter(words, s -> s.length() > 5);
        System.out.println("Words with length > 5: " + filtered);
        
        List<Integer> lengths = map(words, String::length);
        System.out.println("Lengths: " + lengths);
    }
}
```

---

## üìä Generic Methods vs Generic Classes

| Feature | Generic Method | Generic Class |
|---------|----------------|---------------|
| **Scope** | Method level | Class level |
| **Declaration** | Before return type | After class name |
| **Type Parameter** | `<T> void method(T t)` | `class Box<T>` |
| **Static Context** | Can be static | Type params not in static |
| **Location** | Any class | Class definition |
| **Inference** | From arguments | From instantiation |

---

## üí° Best Practices

1. ‚úÖ **Use type inference when possible**
   ```java
   List<String> list = Utils.<String>createList();  // Verbose
   List<String> list = Utils.createList();           // Inferred
   ```

2. ‚úÖ **Place type parameters before return type**
   ```java
   public static <T> T getFirst(T[] array) { }  // Correct
   ```

3. ‚úÖ **Use bounds when operations require specific methods**
   ```java
   public static <T extends Comparable<T>> T max(T a, T b) { }
   ```

4. ‚úÖ **Keep generic methods simple**
   ```java
   // Good - single responsibility
   public static <T> void print(T element) { }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class GenericMethodPitfalls {
    // 1. Forgetting type parameter declaration
    // public static T getValue() { }  // ERROR
    public static <T> T getValue() { }  // Correct
    
    // 2. Wrong placement of type parameter
    // public <T> static void method() { }  // Wrong order
    public static <T> void method() { }     // Correct
    
    // 3. Cannot infer from return type alone
    // String s = genericMethod();  // May not compile
    String s = this.<String>genericMethod();  // Explicit
}
```

---

## üéØ Interview Questions

1. **What is a generic method?**
2. **How to define a generic method?**
3. **Difference between generic method and generic class?**
4. **Can generic methods be static?**
5. **What is type inference in generic methods?**
6. **Can we have multiple type parameters?**
7. **What are bounded type parameters in methods?**
8. **Where to place type parameters in method signature?**
9. **Can non-generic class have generic methods?**
10. **How does compiler infer types?**
11. **Can we override generic methods?**
12. **What are the limitations of generic methods?**
13. **Can we use varargs with generics?**
14. **What is the scope of type parameter?**
15. **Best practices for generic methods?**

---

## üìö Related Topics

- [Introduction to Generics](01.%20Introduction%20to%20Generics.md)
- [Generic Classes](02.%20Generic%20Classes.md)
- [Bounded Type Parameters](04.%20Bounded%20Type%20Parameters.md)
- [Wildcards](05.%20Wildcards.md)
- [Type Erasure](06.%20Type%20Erasure.md)
