# üéØ Bounded Type Parameters

## üìñ Overview

**Bounded type parameters** restrict the types that can be used as type arguments in generic code. They allow you to invoke methods defined in the bounds.

**Syntax:**
```java
<T extends Type>        // Upper bound
<T extends Type1 & Type2>  // Multiple bounds
```

**Key Points:**
- Restricts type parameter to specific types
- Allows calling methods of bound type
- Can have multiple bounds with `&`
- First bound can be class, rest interfaces
- Enables more specific operations

---

## üíª Example 1: Basic Upper Bound

```java
public class UpperBoundDemo {
    // Method accepting only Number and its subclasses
    public static <T extends Number> double calculateAverage(T num1, T num2) {
        return (num1.doubleValue() + num2.doubleValue()) / 2.0;
    }
    
    // Method with upper bound for comparison
    public static <T extends Comparable<T>> T findMax(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Upper Bound Demo ===\n");
        
        // Works with Number subclasses
        System.out.println("Average of integers: " + calculateAverage(10, 20));
        System.out.println("Average of doubles: " + calculateAverage(15.5, 20.3));
        System.out.println("Average of floats: " + calculateAverage(7.5f, 2.5f));
        
        // calculateAverage("10", "20");  // ERROR: String not a Number
        
        System.out.println("\nFinding max:");
        System.out.println("Max integer: " + findMax(10, 20));
        System.out.println("Max string: " + findMax("Apple", "Banana"));
        System.out.println("Max double: " + findMax(3.14, 2.71));
    }
}
```

**Output:**
```
=== Upper Bound Demo ===

Average of integers: 15.0
Average of doubles: 17.9
Average of floats: 5.0

Finding max:
Max integer: 20
Max string: Banana
Max double: 3.14
```

---

## üíª Example 2: Bounded Generic Class

```java
class NumberBox<T extends Number> {
    private T value;
    
    public NumberBox(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T value) {
        this.value = value;
    }
    
    // Can call Number methods
    public double doubleValue() {
        return value.doubleValue();
    }
    
    public int intValue() {
        return value.intValue();
    }
    
    public boolean isPositive() {
        return value.doubleValue() > 0;
    }
    
    public void display() {
        System.out.println("Value: " + value);
        System.out.println("Double: " + doubleValue());
        System.out.println("Integer: " + intValue());
        System.out.println("Positive: " + isPositive());
    }
}

public class BoundedClassDemo {
    public static void main(String[] args) {
        System.out.println("=== Bounded Generic Class ===\n");
        
        NumberBox<Integer> intBox = new NumberBox<>(42);
        System.out.println("Integer Box:");
        intBox.display();
        
        System.out.println();
        NumberBox<Double> doubleBox = new NumberBox<>(-3.14);
        System.out.println("Double Box:");
        doubleBox.display();
        
        // NumberBox<String> strBox = new NumberBox<>("test");  // ERROR
    }
}
```

---

## üíª Example 3: Multiple Bounds

```java
interface Printable {
    void print();
}

class Document implements Comparable<Document>, Printable {
    private String content;
    private int priority;
    
    public Document(String content, int priority) {
        this.content = content;
        this.priority = priority;
    }
    
    @Override
    public int compareTo(Document other) {
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public void print() {
        System.out.println("Printing: " + content + " (Priority: " + priority + ")");
    }
    
    public String getContent() {
        return content;
    }
}

public class MultipleBounds {
    // Multiple bounds: class & interface
    public static <T extends Comparable<T> & Printable> void processAndPrint(T item) {
        item.print();  // From Printable
        // Can also use compareTo from Comparable
    }
    
    public static <T extends Comparable<T> & Printable> T findAndPrintMax(T item1, T item2) {
        T max = item1.compareTo(item2) > 0 ? item1 : item2;
        System.out.print("Max item: ");
        max.print();
        return max;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Multiple Bounds ===\n");
        
        Document doc1 = new Document("Report", 2);
        Document doc2 = new Document("Invoice", 5);
        Document doc3 = new Document("Memo", 1);
        
        System.out.println("Processing documents:");
        processAndPrint(doc1);
        processAndPrint(doc2);
        
        System.out.println();
        findAndPrintMax(doc2, doc3);
    }
}
```

---

## üíª Example 4: Bounded Type with Collections

```java
import java.util.*;

public class BoundedCollections {
    // Sum of numeric list
    public static <T extends Number> double sum(List<T> numbers) {
        double total = 0;
        for (T num : numbers) {
            total += num.doubleValue();
        }
        return total;
    }
    
    // Find max in comparable list
    public static <T extends Comparable<T>> T findMax(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        
        T max = list.get(0);
        for (T element : list) {
            if (element.compareTo(max) > 0) {
                max = element;
            }
        }
        return max;
    }
    
    // Sort any comparable list
    public static <T extends Comparable<T>> void bubbleSort(List<T> list) {
        int n = list.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (list.get(j).compareTo(list.get(j + 1)) > 0) {
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                }
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Bounded Collections ===\n");
        
        List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);
        System.out.println("Numbers: " + numbers);
        System.out.println("Sum: " + sum(numbers));
        System.out.println("Max: " + findMax(numbers));
        
        List<String> words = Arrays.asList("Zebra", "Apple", "Mango", "Banana");
        System.out.println("\nWords: " + words);
        System.out.println("Max: " + findMax(words));
        
        bubbleSort(words);
        System.out.println("Sorted: " + words);
    }
}
```

---

## üíª Example 5: Comparable Interface Bound

```java
class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class ComparableBound {
    // Generic method with Comparable bound
    public static <T extends Comparable<T>> boolean isGreater(T a, T b) {
        return a.compareTo(b) > 0;
    }
    
    public static <T extends Comparable<T>> T[] sortArray(T[] array) {
        T[] result = array.clone();
        
        for (int i = 0; i < result.length - 1; i++) {
            for (int j = 0; j < result.length - i - 1; j++) {
                if (result[j].compareTo(result[j + 1]) > 0) {
                    T temp = result[j];
                    result[j] = result[j + 1];
                    result[j + 1] = temp;
                }
            }
        }
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Comparable Bound ===\n");
        
        System.out.println("Is 10 > 5? " + isGreater(10, 5));
        System.out.println("Is 'A' > 'B'? " + isGreater('A', 'B'));
        
        Person[] people = {
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35)
        };
        
        System.out.println("\nBefore sorting:");
        System.out.println(Arrays.toString(people));
        
        Person[] sorted = sortArray(people);
        System.out.println("\nAfter sorting:");
        System.out.println(Arrays.toString(sorted));
    }
}
```

---

## üíª Example 6: Number Operations

```java
public class NumberOperations {
    // Calculator with Number bound
    static class Calculator<T extends Number> {
        public double add(T a, T b) {
            return a.doubleValue() + b.doubleValue();
        }
        
        public double subtract(T a, T b) {
            return a.doubleValue() - b.doubleValue();
        }
        
        public double multiply(T a, T b) {
            return a.doubleValue() * b.doubleValue();
        }
        
        public double divide(T a, T b) {
            if (b.doubleValue() == 0) {
                throw new ArithmeticException("Division by zero");
            }
            return a.doubleValue() / b.doubleValue();
        }
        
        public boolean isGreater(T a, T b) {
            return a.doubleValue() > b.doubleValue();
        }
        
        public T max(T a, T b) {
            return a.doubleValue() > b.doubleValue() ? a : b;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Number Operations ===\n");
        
        Calculator<Integer> intCalc = new Calculator<>();
        System.out.println("Integer Calculator:");
        System.out.println("10 + 5 = " + intCalc.add(10, 5));
        System.out.println("10 - 5 = " + intCalc.subtract(10, 5));
        System.out.println("10 * 5 = " + intCalc.multiply(10, 5));
        System.out.println("10 / 5 = " + intCalc.divide(10, 5));
        System.out.println("Max(10, 5) = " + intCalc.max(10, 5));
        
        Calculator<Double> doubleCalc = new Calculator<>();
        System.out.println("\nDouble Calculator:");
        System.out.println("10.5 + 3.2 = " + doubleCalc.add(10.5, 3.2));
        System.out.println("10.5 * 2.0 = " + doubleCalc.multiply(10.5, 2.0));
    }
}
```

---

## üíª Example 7: Shape Hierarchy with Bounds

```java
abstract class Shape {
    abstract double area();
    abstract double perimeter();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double perimeter() {
        return 2 * Math.PI * radius;
    }
    
    @Override
    public String toString() {
        return String.format("Circle(r=%.2f)", radius);
    }
}

class Rectangle extends Shape {
    private double length, width;
    
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    public double area() {
        return length * width;
    }
    
    @Override
    public double perimeter() {
        return 2 * (length + width);
    }
    
    @Override
    public String toString() {
        return String.format("Rectangle(%.2fx%.2f)", length, width);
    }
}

public class ShapeBounds {
    // Generic container for shapes
    static class ShapeContainer<T extends Shape> {
        private T shape;
        
        public ShapeContainer(T shape) {
            this.shape = shape;
        }
        
        public void displayInfo() {
            System.out.println("Shape: " + shape);
            System.out.printf("Area: %.2f%n", shape.area());
            System.out.printf("Perimeter: %.2f%n", shape.perimeter());
        }
        
        public double getArea() {
            return shape.area();
        }
    }
    
    // Find shape with max area
    public static <T extends Shape> T findMaxArea(T shape1, T shape2) {
        return shape1.area() > shape2.area() ? shape1 : shape2;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Shape Bounds ===\n");
        
        Circle circle = new Circle(5.0);
        Rectangle rectangle = new Rectangle(4.0, 6.0);
        
        ShapeContainer<Circle> circleContainer = new ShapeContainer<>(circle);
        ShapeContainer<Rectangle> rectContainer = new ShapeContainer<>(rectangle);
        
        System.out.println("Circle Info:");
        circleContainer.displayInfo();
        
        System.out.println("\nRectangle Info:");
        rectContainer.displayInfo();
        
        Shape maxShape = findMaxArea(circle, rectangle);
        System.out.println("\nShape with max area: " + maxShape);
    }
}
```

---

## üíª Example 8: Repository Pattern with Bounds

```java
import java.util.*;

interface Entity {
    Long getId();
    void setId(Long id);
}

class User implements Entity {
    private Long id;
    private String name;
    
    public User(String name) {
        this.name = name;
    }
    
    @Override
    public Long getId() { return id; }
    
    @Override
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    
    @Override
    public String toString() {
        return "User{id=" + id + ", name='" + name + "'}";
    }
}

class Product implements Entity {
    private Long id;
    private String name;
    private double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public Long getId() { return id; }
    
    @Override
    public void setId(Long id) { this.id = id; }
    
    @Override
    public String toString() {
        return "Product{id=" + id + ", name='" + name + "', price=" + price + "}";
    }
}

class Repository<T extends Entity> {
    private Map<Long, T> storage = new HashMap<>();
    private long nextId = 1;
    
    public T save(T entity) {
        if (entity.getId() == null) {
            entity.setId(nextId++);
        }
        storage.put(entity.getId(), entity);
        return entity;
    }
    
    public Optional<T> findById(Long id) {
        return Optional.ofNullable(storage.get(id));
    }
    
    public List<T> findAll() {
        return new ArrayList<>(storage.values());
    }
    
    public void deleteById(Long id) {
        storage.remove(id);
    }
}

public class BoundedRepository {
    public static void main(String[] args) {
        System.out.println("=== Bounded Repository ===\n");
        
        Repository<User> userRepo = new Repository<>();
        userRepo.save(new User("Alice"));
        userRepo.save(new User("Bob"));
        
        System.out.println("Users:");
        userRepo.findAll().forEach(System.out::println);
        
        Repository<Product> productRepo = new Repository<>();
        productRepo.save(new Product("Laptop", 999.99));
        productRepo.save(new Product("Mouse", 29.99));
        
        System.out.println("\nProducts:");
        productRepo.findAll().forEach(System.out::println);
    }
}
```

---

## üíª Example 9: Statistics Calculator

```java
import java.util.*;

public class StatisticsCalculator<T extends Number> {
    private List<T> numbers;
    
    public StatisticsCalculator() {
        this.numbers = new ArrayList<>();
    }
    
    public void add(T number) {
        numbers.add(number);
    }
    
    public double mean() {
        if (numbers.isEmpty()) return 0;
        
        double sum = 0;
        for (T num : numbers) {
            sum += num.doubleValue();
        }
        return sum / numbers.size();
    }
    
    public double min() {
        if (numbers.isEmpty()) return 0;
        
        double minimum = numbers.get(0).doubleValue();
        for (T num : numbers) {
            if (num.doubleValue() < minimum) {
                minimum = num.doubleValue();
            }
        }
        return minimum;
    }
    
    public double max() {
        if (numbers.isEmpty()) return 0;
        
        double maximum = numbers.get(0).doubleValue();
        for (T num : numbers) {
            if (num.doubleValue() > maximum) {
                maximum = num.doubleValue();
            }
        }
        return maximum;
    }
    
    public double sum() {
        double total = 0;
        for (T num : numbers) {
            total += num.doubleValue();
        }
        return total;
    }
    
    public void displayStats() {
        System.out.println("Count: " + numbers.size());
        System.out.printf("Sum: %.2f%n", sum());
        System.out.printf("Mean: %.2f%n", mean());
        System.out.printf("Min: %.2f%n", min());
        System.out.printf("Max: %.2f%n", max());
    }
    
    public static void main(String[] args) {
        System.out.println("=== Statistics Calculator ===\n");
        
        StatisticsCalculator<Integer> intStats = new StatisticsCalculator<>();
        intStats.add(10);
        intStats.add(20);
        intStats.add(30);
        intStats.add(40);
        intStats.add(50);
        
        System.out.println("Integer Statistics:");
        intStats.displayStats();
        
        StatisticsCalculator<Double> doubleStats = new StatisticsCalculator<>();
        doubleStats.add(1.5);
        doubleStats.add(2.7);
        doubleStats.add(3.9);
        
        System.out.println("\nDouble Statistics:");
        doubleStats.displayStats();
    }
}
```

---

## üíª Example 10: Real-World - Inventory System

```java
import java.util.*;

interface Storable {
    String getBarcode();
    int getQuantity();
    void setQuantity(int quantity);
}

class InventoryItem implements Storable, Comparable<InventoryItem> {
    private String barcode;
    private String name;
    private int quantity;
    private double price;
    
    public InventoryItem(String barcode, String name, int quantity, double price) {
        this.barcode = barcode;
        this.name = name;
        this.quantity = quantity;
        this.price = price;
    }
    
    @Override
    public String getBarcode() { return barcode; }
    
    @Override
    public int getQuantity() { return quantity; }
    
    @Override
    public void setQuantity(int quantity) { this.quantity = quantity; }
    
    public String getName() { return name; }
    public double getPrice() { return price; }
    
    @Override
    public int compareTo(InventoryItem other) {
        return this.name.compareTo(other.name);
    }
    
    @Override
    public String toString() {
        return String.format("%s - %s (Qty: %d, Price: $%.2f)", 
            barcode, name, quantity, price);
    }
}

class Inventory<T extends Storable & Comparable<T>> {
    private Map<String, T> items = new HashMap<>();
    
    public void addItem(T item) {
        items.put(item.getBarcode(), item);
        System.out.println("Added: " + item);
    }
    
    public void updateQuantity(String barcode, int quantity) {
        T item = items.get(barcode);
        if (item != null) {
            item.setQuantity(quantity);
            System.out.println("Updated quantity for " + barcode + " to " + quantity);
        }
    }
    
    public List<T> getSortedItems() {
        List<T> sorted = new ArrayList<>(items.values());
        Collections.sort(sorted);
        return sorted;
    }
    
    public List<T> getLowStockItems(int threshold) {
        List<T> lowStock = new ArrayList<>();
        for (T item : items.values()) {
            if (item.getQuantity() < threshold) {
                lowStock.add(item);
            }
        }
        return lowStock;
    }
    
    public void displayInventory() {
        System.out.println("\n=== Inventory ===");
        for (T item : getSortedItems()) {
            System.out.println(item);
        }
    }
}

public class InventorySystem {
    public static void main(String[] args) {
        System.out.println("=== Inventory System ===\n");
        
        Inventory<InventoryItem> inventory = new Inventory<>();
        
        inventory.addItem(new InventoryItem("001", "Laptop", 15, 999.99));
        inventory.addItem(new InventoryItem("002", "Mouse", 50, 29.99));
        inventory.addItem(new InventoryItem("003", "Keyboard", 5, 79.99));
        inventory.addItem(new InventoryItem("004", "Monitor", 8, 299.99));
        
        inventory.displayInventory();
        
        System.out.println("\nLow Stock Items (threshold: 10):");
        for (InventoryItem item : inventory.getLowStockItems(10)) {
            System.out.println("‚ö†Ô∏è " + item);
        }
        
        System.out.println();
        inventory.updateQuantity("003", 20);
    }
}
```

---

## üìä Types of Bounds

| Bound Type | Syntax | Description | Example |
|------------|--------|-------------|---------|
| **Upper Bound** | `<T extends Type>` | Restricts to Type and subtypes | `<T extends Number>` |
| **Multiple Bounds** | `<T extends A & B>` | Must satisfy all bounds | `<T extends Number & Comparable>` |
| **Class Bound** | `<T extends Class>` | Must extend specific class | `<T extends Shape>` |
| **Interface Bound** | `<T extends Interface>` | Must implement interface | `<T extends Comparable>` |

---

## üí° Best Practices

1. ‚úÖ **Use bounds when you need specific methods**
   ```java
   public static <T extends Number> double sum(T a, T b) {
       return a.doubleValue() + b.doubleValue();  // Can call Number methods
   }
   ```

2. ‚úÖ **Class bound must come first**
   ```java
   <T extends MyClass & Interface1 & Interface2>  // Correct
   <T extends Interface1 & MyClass>  // ERROR
   ```

3. ‚úÖ **Use Comparable for comparison operations**
   ```java
   public static <T extends Comparable<T>> T max(T a, T b) { }
   ```

4. ‚úÖ **Prefer interface bounds over class bounds**
   ```java
   <T extends Comparable<T>>  // Good - flexible
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class BoundedPitfalls {
    // 1. Class bound must be first
    // <T extends Interface & Class>  // ERROR
    // <T extends Class & Interface>  // Correct
    
    // 2. Cannot have multiple class bounds
    // <T extends Class1 & Class2>  // ERROR
    // <T extends Class1 & Interface>  // Correct
    
    // 3. Forgetting bounds when calling specific methods
    // public static <T> double sum(T a, T b) {
    //     return a.doubleValue();  // ERROR: T doesn't have doubleValue
    // }
    public static <T extends Number> double sum(T a, T b) {
        return a.doubleValue();  // Correct
    }
}
```

---

## üéØ Interview Questions

1. **What are bounded type parameters?**
2. **How to specify upper bounds?**
3. **Can we have multiple bounds?**
4. **What is the syntax for multiple bounds?**
5. **What comes first - class or interface bound?**
6. **Can we have multiple class bounds?**
7. **Why use bounded type parameters?**
8. **Difference between `<T>` and `<T extends Type>`?**
9. **What is the benefit of Number bound?**
10. **How does Comparable bound help?**
11. **Can we have lower bounds in type parameters?**
12. **What methods can we call on bounded types?**
13. **Can bounded types be used with collections?**
14. **What are recursive type bounds?**
15. **Best practices for using bounds?**

---

## üìö Related Topics

- [Introduction to Generics](01.%20Introduction%20to%20Generics.md)
- [Generic Classes](02.%20Generic%20Classes.md)
- [Generic Methods](03.%20Generic%20Methods.md)
- [Wildcards](05.%20Wildcards.md)
- [Type Erasure](06.%20Type%20Erasure.md)
