# üîÑ Type Erasure

## üìñ Overview

**Type erasure** is the process by which Java compiler removes all type parameters and replaces them with their bounds or `Object` if unbounded. This ensures backward compatibility with pre-generics code.

**Key Points:**
- Generics exist only at compile-time
- Type information is erased at runtime
- Compiler adds type casts where necessary
- Bridge methods are created for polymorphism
- Cannot use `instanceof` with parametrized types

---

## üíª Example 1: Basic Type Erasure

```java
// Before erasure (source code)
class Box<T> {
    private T value;
    
    public void set(T value) {
        this.value = value;
    }
    
    public T get() {
        return value;
    }
}

// After erasure (bytecode equivalent)
class BoxErased {
    private Object value;
    
    public void set(Object value) {
        this.value = value;
    }
    
    public Object get() {
        return value;
    }
}

public class TypeErasureDemo {
    public static void main(String[] args) {
        System.out.println("=== Type Erasure Demo ===\n");
        
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello");
        
        // Compiler inserts cast
        String value = stringBox.get();  // Actually: (String) stringBox.get()
        System.out.println("Value: " + value);
        
        // At runtime, both are just Box
        Box<Integer> intBox = new Box<>();
        Box<String> strBox = new Box<>();
        
        System.out.println("intBox class: " + intBox.getClass().getName());
        System.out.println("strBox class: " + strBox.getClass().getName());
        System.out.println("Same class? " + (intBox.getClass() == strBox.getClass()));
    }
}
```

**Output:**
```
=== Type Erasure Demo ===

Value: Hello
intBox class: Box
strBox class: Box
Same class? true
```

---

## üíª Example 2: Bounded Type Erasure

```java
// Before erasure
class NumberBox<T extends Number> {
    private T value;
    
    public void set(T value) {
        this.value = value;
    }
    
    public T get() {
        return value;
    }
    
    public double doubleValue() {
        return value.doubleValue();
    }
}

// After erasure - T replaced with Number
class NumberBoxErased {
    private Number value;
    
    public void set(Number value) {
        this.value = value;
    }
    
    public Number get() {
        return value;
    }
    
    public double doubleValue() {
        return value.doubleValue();
    }
}

public class BoundedErasure {
    public static void main(String[] args) {
        System.out.println("=== Bounded Type Erasure ===\n");
        
        NumberBox<Integer> intBox = new NumberBox<>();
        intBox.set(42);
        
        // Compiler inserts (Integer) cast
        Integer value = intBox.get();
        System.out.println("Value: " + value);
        System.out.println("Double value: " + intBox.doubleValue());
        
        // Both have Number as upper bound at runtime
        NumberBox<Integer> box1 = new NumberBox<>();
        NumberBox<Double> box2 = new NumberBox<>();
        
        System.out.println("\nSame runtime class? " + 
            (box1.getClass() == box2.getClass()));
    }
}
```

---

## üíª Example 3: Generic Method Erasure

```java
public class GenericMethodErasure {
    // Before erasure
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // After erasure
    public static void printArrayErased(Object[] array) {
        for (Object element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Bounded generic method
    public static <T extends Comparable<T>> T findMax(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    // After erasure - T becomes Comparable
    public static Comparable findMaxErased(Comparable a, Comparable b) {
        return a.compareTo(b) > 0 ? a : b;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Method Erasure ===\n");
        
        Integer[] numbers = {1, 2, 3, 4, 5};
        String[] words = {"A", "B", "C"};
        
        System.out.println("Using generic method:");
        printArray(numbers);
        printArray(words);
        
        System.out.println("\nFinding max:");
        System.out.println("Max of 10 and 20: " + findMax(10, 20));
        System.out.println("Max of 'A' and 'B': " + findMax('A', 'B'));
    }
}
```

---

## üíª Example 4: Bridge Methods

```java
class Node<T> {
    private T data;
    
    public Node(T data) {
        this.data = data;
    }
    
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
}

class IntegerNode extends Node<Integer> {
    public IntegerNode(Integer data) {
        super(data);
    }
    
    // Overrides Node<Integer>.setData(Integer)
    @Override
    public void setData(Integer data) {
        System.out.println("Setting integer data: " + data);
        super.setData(data);
    }
    
    // Compiler generates bridge method:
    // public void setData(Object data) {
    //     setData((Integer) data);
    // }
}

public class BridgeMethods {
    public static void main(String[] args) {
        System.out.println("=== Bridge Methods ===\n");
        
        IntegerNode node = new IntegerNode(10);
        System.out.println("Initial data: " + node.getData());
        
        node.setData(20);
        System.out.println("Updated data: " + node.getData());
        
        // The bridge method maintains polymorphism
        Node<Integer> genericNode = node;
        genericNode.setData(30);
        System.out.println("Final data: " + genericNode.getData());
    }
}
```

---

## üíª Example 5: Type Erasure Limitations

```java
import java.util.*;

public class ErasureLimitations {
    public static void demonstrateLimitations() {
        System.out.println("=== Type Erasure Limitations ===\n");
        
        // 1. Cannot use instanceof with parameterized type
        List<String> stringList = new ArrayList<>();
        // if (stringList instanceof List<String>) { }  // ERROR
        if (stringList instanceof List) {  // OK - raw type
            System.out.println("Is a List");
        }
        
        // 2. Cannot create generic array
        // List<String>[] arrayOfLists = new List<String>[10];  // ERROR
        List<?>[] arrayOfLists = new List<?>[10];  // OK with wildcard
        System.out.println("Created array of lists: length " + arrayOfLists.length);
        
        // 3. Cannot use primitive types
        // List<int> intList = new ArrayList<>();  // ERROR
        List<Integer> intList = new ArrayList<>();  // OK with wrapper
        System.out.println("Created Integer list");
        
        // 4. Cannot catch generic exception
        try {
            throw new Exception("test");
        } catch (Exception e) {  // Cannot use <T extends Exception>
            System.out.println("Caught: " + e.getMessage());
        }
        
        // 5. Same erasure causes conflicts
        // class Problem {
        //     void method(List<String> list) { }
        //     void method(List<Integer> list) { }  // ERROR - same erasure
        // }
    }
    
    public static void main(String[] args) {
        demonstrateLimitations();
    }
}
```

---

## üíª Example 6: Runtime Type Information

```java
import java.util.*;

public class RuntimeTypeInfo {
    public static <T> void printTypeInfo(List<T> list) {
        System.out.println("List class: " + list.getClass().getName());
        
        // Type parameter T is erased at runtime
        // Cannot determine T at runtime
        if (!list.isEmpty()) {
            Object first = list.get(0);
            System.out.println("First element type: " + first.getClass().getName());
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Runtime Type Information ===\n");
        
        List<String> strings = Arrays.asList("A", "B", "C");
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
        
        System.out.println("String List:");
        printTypeInfo(strings);
        
        System.out.println("\nInteger List:");
        printTypeInfo(integers);
        
        System.out.println("\nDouble List:");
        printTypeInfo(doubles);
        
        // All have same class at runtime
        System.out.println("\nAll same class? " +
            (strings.getClass() == integers.getClass()));
    }
}
```

---

## üíª Example 7: Heap Pollution

```java
import java.util.*;

public class HeapPollution {
    // Unsafe method - can cause heap pollution
    @SafeVarargs
    static <T> void addToList(List<T> list, T... elements) {
        for (T element : elements) {
            list.add(element);
        }
    }
    
    // Example of heap pollution
    static void demonstrateHeapPollution() {
        List<String> strings = new ArrayList<>();
        
        // This is safe
        addToList(strings, "A", "B", "C");
        System.out.println("Safe usage: " + strings);
        
        // Heap pollution example
        List<String>[] arrayOfLists = new List[2];
        arrayOfLists[0] = Arrays.asList("Hello");
        arrayOfLists[1] = Arrays.asList("World");
        
        // Due to erasure, this compiles but can fail at runtime
        Object[] objects = arrayOfLists;
        objects[0] = Arrays.asList(1, 2, 3);  // Heap pollution!
        
        try {
            String s = arrayOfLists[0].get(0);  // ClassCastException
        } catch (ClassCastException e) {
            System.out.println("Caught ClassCastException due to heap pollution");
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Heap Pollution ===\n");
        demonstrateHeapPollution();
    }
}
```

---

## üíª Example 8: Erasure and Overloading

```java
import java.util.*;

public class ErasureOverloading {
    // These methods have same erasure
    // public void process(List<String> list) { }  // ERROR
    // public void process(List<Integer> list) { }  // Same erasure
    
    // Solution 1: Use different method names
    public void processStrings(List<String> list) {
        System.out.println("Processing strings: " + list);
    }
    
    public void processIntegers(List<Integer> list) {
        System.out.println("Processing integers: " + list);
    }
    
    // Solution 2: Add additional parameter
    public void process(List<String> list, String dummy) {
        System.out.println("Processing strings: " + list);
    }
    
    public void process(List<Integer> list, Integer dummy) {
        System.out.println("Processing integers: " + list);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Erasure and Overloading ===\n");
        
        ErasureOverloading obj = new ErasureOverloading();
        
        List<String> strings = Arrays.asList("A", "B", "C");
        List<Integer> integers = Arrays.asList(1, 2, 3);
        
        obj.processStrings(strings);
        obj.processIntegers(integers);
        
        System.out.println();
        obj.process(strings, "");
        obj.process(integers, 0);
    }
}
```

---

## üíª Example 9: Reflection and Generics

```java
import java.lang.reflect.*;
import java.util.*;

public class ReflectionGenerics {
    public List<String> stringList;
    public List<Integer> integerList;
    public Map<String, Integer> map;
    
    public <T> void genericMethod(List<T> list) { }
    
    public static void printFieldTypes(Class<?> clazz) {
        System.out.println("=== Field Types ===");
        for (Field field : clazz.getDeclaredFields()) {
            System.out.println("\nField: " + field.getName());
            System.out.println("Type: " + field.getType());
            System.out.println("Generic Type: " + field.getGenericType());
            
            Type genericType = field.getGenericType();
            if (genericType instanceof ParameterizedType) {
                ParameterizedType paramType = (ParameterizedType) genericType;
                System.out.println("Type Arguments: " + 
                    Arrays.toString(paramType.getActualTypeArguments()));
            }
        }
    }
    
    public static void printMethodTypes(Class<?> clazz) {
        System.out.println("\n=== Method Types ===");
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.getName().equals("genericMethod")) {
                System.out.println("\nMethod: " + method.getName());
                
                TypeVariable<?>[] typeParams = method.getTypeParameters();
                System.out.println("Type Parameters: " + 
                    Arrays.toString(typeParams));
                
                Type[] paramTypes = method.getGenericParameterTypes();
                System.out.println("Parameter Types: " + 
                    Arrays.toString(paramTypes));
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Reflection and Generics ===\n");
        
        printFieldTypes(ReflectionGenerics.class);
        printMethodTypes(ReflectionGenerics.class);
        
        // At runtime, type information is limited
        List<String> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        
        System.out.println("\n=== Runtime Classes ===");
        System.out.println("list1 class: " + list1.getClass());
        System.out.println("list2 class: " + list2.getClass());
        System.out.println("Same? " + (list1.getClass() == list2.getClass()));
    }
}
```

---

## üíª Example 10: Real-World Impact

```java
import java.util.*;

public class RealWorldImpact {
    // Generic repository
    static class Repository<T> {
        private List<T> items = new ArrayList<>();
        
        public void add(T item) {
            items.add(item);
        }
        
        public List<T> getAll() {
            return new ArrayList<>(items);
        }
        
        // Due to erasure, cannot do this:
        // public T createNew() {
        //     return new T();  // ERROR - cannot instantiate T
        // }
        
        // Workaround: use Class token
        public T createNew(Class<T> clazz) throws Exception {
            return clazz.getDeclaredConstructor().newInstance();
        }
        
        // Cannot check type at runtime
        public boolean isTypeOf(Object obj) {
            // Cannot do: obj instanceof T
            // Workaround: pass Class<T>
            return items.isEmpty() ? false : 
                   items.get(0).getClass().isInstance(obj);
        }
    }
    
    static class User {
        private String name;
        
        public User() {
            this.name = "Default";
        }
        
        public User(String name) {
            this.name = name;
        }
        
        @Override
        public String toString() {
            return "User{name='" + name + "'}";
        }
    }
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Real-World Impact ===\n");
        
        Repository<User> userRepo = new Repository<>();
        userRepo.add(new User("Alice"));
        userRepo.add(new User("Bob"));
        
        System.out.println("Users: " + userRepo.getAll());
        
        // Using Class token to create new instance
        User newUser = userRepo.createNew(User.class);
        System.out.println("Created new user: " + newUser);
        
        // Type checking with workaround
        User testUser = new User("Test");
        System.out.println("Is User type? " + userRepo.isTypeOf(testUser));
        System.out.println("Is String type? " + userRepo.isTypeOf("Test"));
    }
}
```

---

## üìä Type Erasure Process

| Source Code | After Erasure | Description |
|-------------|---------------|-------------|
| `<T>` | `Object` | Unbounded type parameter |
| `<T extends Number>` | `Number` | Bounded type parameter |
| `List<String>` | `List` | Parameterized type |
| `T[]` | `Object[]` | Generic array |
| `<T extends A & B>` | `A` | Multiple bounds (first) |

---

## üí° Best Practices

1. ‚úÖ **Use Class tokens for type information**
   ```java
   public <T> T create(Class<T> clazz) throws Exception {
       return clazz.getDeclaredConstructor().newInstance();
   }
   ```

2. ‚úÖ **Avoid generic array creation**
   ```java
   // Don't
   // T[] array = new T[10];  // ERROR
   
   // Do
   @SuppressWarnings("unchecked")
   T[] array = (T[]) new Object[10];
   ```

3. ‚úÖ **Use raw types for instanceof**
   ```java
   if (obj instanceof List) {  // OK
       List<?> list = (List<?>) obj;
   }
   ```

4. ‚úÖ **Be aware of bridge methods**
   ```java
   // Compiler generates bridge methods for polymorphism
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
public class ErasurePitfalls {
    // 1. Cannot create instances of type parameter
    // public <T> T create() {
    //     return new T();  // ERROR
    // }
    
    // 2. Cannot use instanceof with parameterized type
    // public boolean check(Object obj) {
    //     return obj instanceof List<String>;  // ERROR
    // }
    
    // 3. Cannot create generic array
    // public <T> T[] createArray(int size) {
    //     return new T[size];  // ERROR
    // }
    
    // 4. Method overloading conflict
    // public void method(List<String> list) { }
    // public void method(List<Integer> list) { }  // ERROR
    
    // 5. Cannot catch generic exception
    // public <T extends Exception> void method() {
    //     try { }
    //     catch (T e) { }  // ERROR
    // }
}
```

---

## üéØ Interview Questions

1. **What is type erasure?**
2. **Why does Java use type erasure?**
3. **What happens to generics at runtime?**
4. **What are bridge methods?**
5. **Can we use instanceof with generics?**
6. **Why can't we create generic arrays?**
7. **How to get type information at runtime?**
8. **What is heap pollution?**
9. **Impact of type erasure on method overloading?**
10. **Can we catch generic exceptions?**
11. **What are Class tokens?**
12. **How to create generic array?**
13. **Difference between compile-time and runtime generics?**
14. **What is @SafeVarargs?**
15. **How does type erasure affect reflection?**

---

## üìö Related Topics

- [Introduction to Generics](01.%20Introduction%20to%20Generics.md)
- [Generic Classes](02.%20Generic%20Classes.md)
- [Generic Methods](03.%20Generic%20Methods.md)
- [Bounded Type Parameters](04.%20Bounded%20Type%20Parameters.md)
- [Wildcards](05.%20Wildcards.md)
