# ‚ö° Invoking Methods

## üìñ Overview

**Method Invocation** via Reflection allows calling methods dynamically at runtime using the `Method` object from `java.lang.reflect` package.

**Key Capabilities:**
- Call methods by name
- Pass arguments dynamically
- Handle return values
- Invoke private methods
- Static method invocation

---

## üíª Basic Method Invocation

### Getting Methods

```java
Class<?> clazz = String.class;

// Public method
Method method = clazz.getMethod("toUpperCase");

// Method with parameters
Method substringMethod = clazz.getMethod("substring", int.class, int.class);

// Private method (use getDeclaredMethod)
Method privateMethod = clazz.getDeclaredMethod("methodName", paramTypes);
```

### Invoking Methods

```java
String str = "hello";
Class<?> clazz = str.getClass();

// Get method
Method method = clazz.getMethod("toUpperCase");

// Invoke method
Object result = method.invoke(str);  // Returns Object
String upperCase = (String) result;  // Cast to expected type

System.out.println(upperCase);  // HELLO
```

### Methods with Parameters

```java
String str = "Hello World";

// Method: substring(int beginIndex, int endIndex)
Method method = String.class.getMethod("substring", int.class, int.class);

// Invoke with arguments
Object result = method.invoke(str, 0, 5);
System.out.println(result);  // Hello
```

---

## üíª Invoking Private Methods

### Setting Accessible

```java
class MyClass {
    private String secret() {
        return "Secret data";
    }
}

MyClass obj = new MyClass();

// Get private method
Method method = MyClass.class.getDeclaredMethod("secret");

// Make accessible
method.setAccessible(true);

// Invoke
Object result = method.invoke(obj);
System.out.println(result);  // Secret data
```

---

## üíª Static Method Invocation

### Calling Static Methods

```java
// Static method: Integer.parseInt(String)
Method method = Integer.class.getMethod("parseInt", String.class);

// For static methods, pass null as instance
Object result = method.invoke(null, "123");
int value = (int) result;

System.out.println(value);  // 123
```

### Example with Math

```java
// Math.max(int, int)
Method maxMethod = Math.class.getMethod("max", int.class, int.class);
Object result = maxMethod.invoke(null, 10, 20);
System.out.println(result);  // 20

// Math.sqrt(double)
Method sqrtMethod = Math.class.getMethod("sqrt", double.class);
Object sqrtResult = sqrtMethod.invoke(null, 16.0);
System.out.println(sqrtResult);  // 4.0
```

---

## üíª Handling Different Return Types

### Void Methods

```java
List<String> list = new ArrayList<>();

// add(E element) returns boolean
Method addMethod = list.getClass().getMethod("add", Object.class);
Object result = addMethod.invoke(list, "Hello");
System.out.println(result);  // true

// clear() returns void
Method clearMethod = list.getClass().getMethod("clear");
Object clearResult = clearMethod.invoke(list);
System.out.println(clearResult);  // null
```

### Primitive Return Types

```java
String str = "Hello";

// length() returns int (primitive)
Method lengthMethod = str.getClass().getMethod("length");
Object result = lengthMethod.invoke(str);
int length = (int) result;  // Auto-unboxing

System.out.println(length);  // 5
```

---

## üéØ Complete Examples

### Example 1: Dynamic Method Caller

```java
public class DynamicMethodCaller {
    
    public static Object callMethod(Object obj, String methodName, Object... args) {
        try {
            Class<?> clazz = obj.getClass();
            
            // Determine parameter types
            Class<?>[] paramTypes = new Class[args.length];
            for (int i = 0; i < args.length; i++) {
                paramTypes[i] = args[i].getClass();
            }
            
            // Get method
            Method method = clazz.getMethod(methodName, paramTypes);
            
            // Invoke method
            return method.invoke(obj, args);
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to call method", e);
        }
    }
    
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        
        // Call add method
        callMethod(list, "add", "Hello");
        callMethod(list, "add", "World");
        
        // Call size method
        Object size = callMethod(list, "size");
        System.out.println("Size: " + size);  // 2
        
        // Call get method
        Object element = callMethod(list, "get", 0);
        System.out.println("Element: " + element);  // Hello
    }
}
```

### Example 2: Test Runner

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Test {
}

class MyTests {
    @Test
    public void testAddition() {
        assert 2 + 2 == 4;
        System.out.println("testAddition passed");
    }
    
    @Test
    public void testSubtraction() {
        assert 5 - 3 == 2;
        System.out.println("testSubtraction passed");
    }
    
    public void notATest() {
        System.out.println("This won't run");
    }
}

public class TestRunner {
    
    public static void runTests(Class<?> testClass) {
        try {
            Object instance = testClass.getDeclaredConstructor().newInstance();
            
            int passed = 0;
            int failed = 0;
            
            for (Method method : testClass.getDeclaredMethods()) {
                if (method.isAnnotationPresent(Test.class)) {
                    try {
                        method.invoke(instance);
                        passed++;
                    } catch (Exception e) {
                        System.err.println(method.getName() + " failed: " + e.getCause());
                        failed++;
                    }
                }
            }
            
            System.out.println("\nResults: " + passed + " passed, " + failed + " failed");
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) {
        runTests(MyTests.class);
    }
}
```

### Example 3: Bean Property Accessor

```java
public class BeanPropertyAccessor {
    
    public static Object getProperty(Object bean, String propertyName) {
        try {
            String getterName = "get" + capitalize(propertyName);
            Method getter = bean.getClass().getMethod(getterName);
            return getter.invoke(bean);
        } catch (Exception e) {
            throw new RuntimeException("Failed to get property: " + propertyName, e);
        }
    }
    
    public static void setProperty(Object bean, String propertyName, Object value) {
        try {
            String setterName = "set" + capitalize(propertyName);
            
            // Find setter with matching parameter type
            for (Method method : bean.getClass().getMethods()) {
                if (method.getName().equals(setterName) 
                    && method.getParameterCount() == 1) {
                    method.invoke(bean, value);
                    return;
                }
            }
            
            throw new NoSuchMethodException("Setter not found: " + setterName);
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to set property: " + propertyName, e);
        }
    }
    
    private static String capitalize(String str) {
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
    
    public static void main(String[] args) {
        Person person = new Person();
        
        // Set properties
        setProperty(person, "name", "Alice");
        setProperty(person, "age", 30);
        
        // Get properties
        String name = (String) getProperty(person, "name");
        Integer age = (Integer) getProperty(person, "age");
        
        System.out.println("Name: " + name);  // Alice
        System.out.println("Age: " + age);    // 30
    }
}

class Person {
    private String name;
    private int age;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
```

### Example 4: Method Performance Monitor

```java
public class MethodMonitor {
    
    public static Object invokeWithTiming(Object obj, String methodName, Object... args) {
        try {
            // Get method
            Class<?>[] paramTypes = Arrays.stream(args)
                .map(Object::getClass)
                .toArray(Class[]::new);
            Method method = obj.getClass().getMethod(methodName, paramTypes);
            
            // Measure execution time
            long start = System.nanoTime();
            Object result = method.invoke(obj, args);
            long end = System.nanoTime();
            
            double durationMs = (end - start) / 1_000_000.0;
            System.out.printf("%s took %.3f ms%n", methodName, durationMs);
            
            return result;
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to invoke method", e);
        }
    }
    
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        
        // Add elements with timing
        for (int i = 0; i < 10000; i++) {
            list.add(i);
        }
        
        // Measure sort performance
        invokeWithTiming(Collections.class, "sort", list);
        
        // Measure contains performance
        invokeWithTiming(list, "contains", 5000);
    }
}
```

### Example 5: Command Pattern with Reflection

```java
public class CommandExecutor {
    private Map<String, Method> commands = new HashMap<>();
    private Object target;
    
    public CommandExecutor(Object target) {
        this.target = target;
        registerCommands();
    }
    
    private void registerCommands() {
        for (Method method : target.getClass().getDeclaredMethods()) {
            commands.put(method.getName(), method);
        }
    }
    
    public Object execute(String commandName, Object... args) {
        try {
            Method method = commands.get(commandName);
            if (method == null) {
                throw new IllegalArgumentException("Unknown command: " + commandName);
            }
            
            method.setAccessible(true);
            return method.invoke(target, args);
            
        } catch (Exception e) {
            throw new RuntimeException("Command execution failed", e);
        }
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        CommandExecutor executor = new CommandExecutor(calc);
        
        // Execute commands
        System.out.println(executor.execute("add", 10, 20));      // 30
        System.out.println(executor.execute("multiply", 5, 6));   // 30
        System.out.println(executor.execute("subtract", 100, 25)); // 75
    }
}

class Calculator {
    public int add(int a, int b) { return a + b; }
    public int subtract(int a, int b) { return a - b; }
    public int multiply(int a, int b) { return a * b; }
}
```

---

## üìä Method Invocation Summary

| Method Type | Instance Parameter | Example |
|-------------|-------------------|---------|
| Instance method | Object instance | method.invoke(obj, args) |
| Static method | null | method.invoke(null, args) |
| Private method | Need setAccessible(true) | method.setAccessible(true) |

---

## üìä Common Exceptions

| Exception | When It Occurs |
|-----------|----------------|
| NoSuchMethodException | Method not found |
| IllegalAccessException | Cannot access method |
| InvocationTargetException | Method throws exception |
| IllegalArgumentException | Wrong argument types |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Cache Method objects | Avoid repeated lookups |
| ‚úÖ Handle InvocationTargetException | Wrap actual exception |
| ‚úÖ Use setAccessible() for private | Enable access |
| ‚úÖ Validate parameter types | Before invocation |
| ‚úÖ Check for null return | For void methods |
| ‚ùå Don't invoke in tight loops | Performance impact |
| ‚ùå Don't ignore exceptions | Proper error handling |

---

## üéØ Error Handling Pattern

```java
public static Object safeInvoke(Object obj, String methodName, Object... args) {
    try {
        Class<?>[] paramTypes = Arrays.stream(args)
            .map(Object::getClass)
            .toArray(Class[]::new);
        
        Method method = obj.getClass().getMethod(methodName, paramTypes);
        return method.invoke(obj, args);
        
    } catch (NoSuchMethodException e) {
        throw new RuntimeException("Method not found: " + methodName, e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Cannot access method: " + methodName, e);
    } catch (InvocationTargetException e) {
        throw new RuntimeException("Method threw exception: " + methodName, 
                                   e.getCause());
    }
}
```

---

## üîó Related Topics

- [Class Object](01.%20Class%20Object.md)
- [Inspecting Classes](02.%20Inspecting%20Classes.md)
- [Accessing Fields](04.%20Accessing%20Fields.md)
- [Dynamic Proxies](05.%20Dynamic%20Proxies.md)

---

## üí° Key Takeaways

- Use Method.invoke(object, args) to call methods dynamically
- Pass null as object for static methods
- Use setAccessible(true) for private methods
- Handle InvocationTargetException to get actual exception
- Return type is always Object (requires casting)
- Void methods return null
- Primitive types are auto-boxed/unboxed
- Cache Method objects for performance
- Validate parameter types before invocation
- Handle all reflection exceptions properly
