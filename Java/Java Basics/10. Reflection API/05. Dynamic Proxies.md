# üé≠ Dynamic Proxies

## üìñ Overview

**Dynamic Proxies** allow creating proxy instances at runtime that implement specified interfaces. The proxy intercepts method calls and delegates them to an `InvocationHandler`.

**Key Use Cases:**
- AOP (Aspect-Oriented Programming)
- Lazy loading
- Logging and monitoring
- Security checks
- Transaction management
- Remote method invocation

---

## üíª Creating Dynamic Proxies

### Basic Proxy Creation

```java
import java.lang.reflect.*;

// Interface
interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
}

// Real implementation
class CalculatorImpl implements Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int subtract(int a, int b) {
        return a - b;
    }
}

// InvocationHandler
class LoggingHandler implements InvocationHandler {
    private Object target;
    
    public LoggingHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Calling: " + method.getName());
        Object result = method.invoke(target, args);
        System.out.println("Result: " + result);
        return result;
    }
}

// Usage
public class ProxyDemo {
    public static void main(String[] args) {
        Calculator calc = new CalculatorImpl();
        
        Calculator proxy = (Calculator) Proxy.newProxyInstance(
            Calculator.class.getClassLoader(),
            new Class<?>[] { Calculator.class },
            new LoggingHandler(calc)
        );
        
        proxy.add(10, 5);      // Logs method call
        proxy.subtract(20, 8); // Logs method call
    }
}
```

---

## üíª InvocationHandler

### Understanding InvocationHandler

```java
public interface InvocationHandler {
    /**
     * @param proxy  The proxy instance
     * @param method The method being invoked
     * @param args   Method arguments
     * @return       Result to return to caller
     */
    Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

### Simple InvocationHandler

```java
class SimpleHandler implements InvocationHandler {
    private Object target;
    
    public SimpleHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Before method call
        System.out.println("Before: " + method.getName());
        
        // Invoke actual method
        Object result = method.invoke(target, args);
        
        // After method call
        System.out.println("After: " + method.getName());
        
        return result;
    }
}
```

---

## üéØ Complete Examples

### Example 1: Performance Monitor

```java
interface UserService {
    User findUser(int id);
    void saveUser(User user);
    List<User> findAll();
}

class UserServiceImpl implements UserService {
    public User findUser(int id) {
        // Simulate DB query
        try { Thread.sleep(100); } catch (InterruptedException e) {}
        return new User(id, "User" + id);
    }
    
    public void saveUser(User user) {
        try { Thread.sleep(50); } catch (InterruptedException e) {}
        System.out.println("Saved: " + user);
    }
    
    public List<User> findAll() {
        try { Thread.sleep(200); } catch (InterruptedException e) {}
        return Arrays.asList(new User(1, "Alice"), new User(2, "Bob"));
    }
}

class PerformanceMonitor implements InvocationHandler {
    private Object target;
    
    public PerformanceMonitor(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long start = System.currentTimeMillis();
        
        Object result = method.invoke(target, args);
        
        long end = System.currentTimeMillis();
        long duration = end - start;
        
        System.out.printf("%s took %d ms%n", method.getName(), duration);
        
        return result;
    }
}

public class PerformanceDemo {
    public static void main(String[] args) {
        UserService service = new UserServiceImpl();
        
        UserService proxy = (UserService) Proxy.newProxyInstance(
            UserService.class.getClassLoader(),
            new Class<?>[] { UserService.class },
            new PerformanceMonitor(service)
        );
        
        proxy.findUser(1);      // findUser took 100 ms
        proxy.saveUser(new User(1, "Alice")); // saveUser took 50 ms
        proxy.findAll();        // findAll took 200 ms
    }
}

class User {
    private int id;
    private String name;
    
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "User{id=" + id + ", name='" + name + "'}";
    }
}
```

### Example 2: Security Proxy

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface RequireRole {
    String value();
}

interface AdminService {
    @RequireRole("ADMIN")
    void deleteUser(int id);
    
    @RequireRole("ADMIN")
    void resetPassword(int userId);
    
    List<User> listUsers();  // No annotation - public
}

class AdminServiceImpl implements AdminService {
    public void deleteUser(int id) {
        System.out.println("User " + id + " deleted");
    }
    
    public void resetPassword(int userId) {
        System.out.println("Password reset for user " + userId);
    }
    
    public List<User> listUsers() {
        return Arrays.asList(new User(1, "Alice"));
    }
}

class SecurityProxy implements InvocationHandler {
    private Object target;
    private String currentUserRole;
    
    public SecurityProxy(Object target, String currentUserRole) {
        this.target = target;
        this.currentUserRole = currentUserRole;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Check security annotation
        if (method.isAnnotationPresent(RequireRole.class)) {
            RequireRole annotation = method.getAnnotation(RequireRole.class);
            String requiredRole = annotation.value();
            
            if (!currentUserRole.equals(requiredRole)) {
                throw new SecurityException(
                    "Access denied. Required role: " + requiredRole
                );
            }
        }
        
        return method.invoke(target, args);
    }
}

public class SecurityDemo {
    public static void main(String[] args) {
        AdminService service = new AdminServiceImpl();
        
        // User with ADMIN role
        AdminService adminProxy = (AdminService) Proxy.newProxyInstance(
            AdminService.class.getClassLoader(),
            new Class<?>[] { AdminService.class },
            new SecurityProxy(service, "ADMIN")
        );
        
        adminProxy.deleteUser(1);      // Works
        adminProxy.listUsers();        // Works
        
        // User with USER role
        AdminService userProxy = (AdminService) Proxy.newProxyInstance(
            AdminService.class.getClassLoader(),
            new Class<?>[] { AdminService.class },
            new SecurityProxy(service, "USER")
        );
        
        userProxy.listUsers();         // Works (no annotation)
        try {
            userProxy.deleteUser(1);   // SecurityException
        } catch (SecurityException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

### Example 3: Lazy Loading Proxy

```java
interface Database {
    List<String> queryLargeDataset();
}

class DatabaseImpl implements Database {
    public DatabaseImpl() {
        System.out.println("DatabaseImpl created (expensive!)");
    }
    
    public List<String> queryLargeDataset() {
        System.out.println("Executing expensive query...");
        return Arrays.asList("Data1", "Data2", "Data3");
    }
}

class LazyLoadingProxy implements InvocationHandler {
    private Object target;
    private Class<?> targetClass;
    
    public LazyLoadingProxy(Class<?> targetClass) {
        this.targetClass = targetClass;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Create target only when first method is called
        if (target == null) {
            System.out.println("Lazy initialization...");
            target = targetClass.getDeclaredConstructor().newInstance();
        }
        
        return method.invoke(target, args);
    }
}

public class LazyLoadingDemo {
    public static void main(String[] args) {
        // Proxy created immediately, but Database not created yet
        Database database = (Database) Proxy.newProxyInstance(
            Database.class.getClassLoader(),
            new Class<?>[] { Database.class },
            new LazyLoadingProxy(DatabaseImpl.class)
        );
        
        System.out.println("Proxy created");
        
        // Database created only when method is called
        database.queryLargeDataset();
    }
}
```

### Example 4: Caching Proxy

```java
interface DataService {
    String fetchData(String key);
}

class DataServiceImpl implements DataService {
    public String fetchData(String key) {
        System.out.println("Fetching from database: " + key);
        // Simulate expensive operation
        try { Thread.sleep(100); } catch (InterruptedException e) {}
        return "Data for " + key;
    }
}

class CachingProxy implements InvocationHandler {
    private Object target;
    private Map<String, Object> cache = new HashMap<>();
    
    public CachingProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // Create cache key from method name and arguments
        String cacheKey = method.getName() + Arrays.toString(args);
        
        // Check cache
        if (cache.containsKey(cacheKey)) {
            System.out.println("Returning cached result");
            return cache.get(cacheKey);
        }
        
        // Call actual method
        Object result = method.invoke(target, args);
        
        // Store in cache
        cache.put(cacheKey, result);
        
        return result;
    }
}

public class CachingDemo {
    public static void main(String[] args) {
        DataService service = new DataServiceImpl();
        
        DataService proxy = (DataService) Proxy.newProxyInstance(
            DataService.class.getClassLoader(),
            new Class<?>[] { DataService.class },
            new CachingProxy(service)
        );
        
        proxy.fetchData("user1");  // Fetches from database
        proxy.fetchData("user1");  // Returns cached result
        proxy.fetchData("user2");  // Fetches from database
        proxy.fetchData("user2");  // Returns cached result
    }
}
```

### Example 5: Transaction Proxy

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Transactional {
}

interface OrderService {
    @Transactional
    void createOrder(String orderId);
    
    @Transactional
    void updateOrder(String orderId);
    
    String getOrderStatus(String orderId);
}

class OrderServiceImpl implements OrderService {
    public void createOrder(String orderId) {
        System.out.println("Creating order: " + orderId);
        // Business logic
    }
    
    public void updateOrder(String orderId) {
        System.out.println("Updating order: " + orderId);
        // Business logic
    }
    
    public String getOrderStatus(String orderId) {
        return "PENDING";
    }
}

class TransactionProxy implements InvocationHandler {
    private Object target;
    
    public TransactionProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        boolean isTransactional = method.isAnnotationPresent(Transactional.class);
        
        if (isTransactional) {
            System.out.println("BEGIN TRANSACTION");
        }
        
        try {
            Object result = method.invoke(target, args);
            
            if (isTransactional) {
                System.out.println("COMMIT TRANSACTION");
            }
            
            return result;
            
        } catch (Exception e) {
            if (isTransactional) {
                System.out.println("ROLLBACK TRANSACTION");
            }
            throw e;
        }
    }
}

public class TransactionDemo {
    public static void main(String[] args) {
        OrderService service = new OrderServiceImpl();
        
        OrderService proxy = (OrderService) Proxy.newProxyInstance(
            OrderService.class.getClassLoader(),
            new Class<?>[] { OrderService.class },
            new TransactionProxy(service)
        );
        
        proxy.createOrder("ORDER-1");  // Wrapped in transaction
        proxy.getOrderStatus("ORDER-1"); // No transaction
    }
}
```

---

## üìä Proxy.newProxyInstance Parameters

| Parameter | Description |
|-----------|-------------|
| ClassLoader | Class loader to define proxy class |
| Class<?>[] | Array of interfaces to implement |
| InvocationHandler | Handler for method invocations |

---

## üìä InvocationHandler.invoke Parameters

| Parameter | Description |
|-----------|-------------|
| proxy | Proxy instance (don't invoke methods on it!) |
| method | Method being called |
| args | Method arguments (null if no args) |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Proxy only interfaces | Not concrete classes |
| ‚úÖ Don't call methods on proxy | Inside invoke() - infinite loop |
| ‚úÖ Handle null args | args can be null |
| ‚úÖ Use for cross-cutting concerns | Logging, security, transactions |
| ‚úÖ Cache proxy instances | Avoid repeated creation |
| ‚ùå Don't use for all objects | Performance overhead |
| ‚ùå Don't ignore exceptions | Proper error handling |

---

## üéØ Common Patterns

### Pattern 1: Generic Proxy Factory
```java
public static <T> T createProxy(Class<T> iface, T target, InvocationHandler handler) {
    return (T) Proxy.newProxyInstance(
        iface.getClassLoader(),
        new Class<?>[] { iface },
        handler
    );
}
```

### Pattern 2: Combining Handlers
```java
class CompositeHandler implements InvocationHandler {
    private List<InvocationHandler> handlers;
    
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        for (InvocationHandler handler : handlers) {
            handler.invoke(proxy, method, args);
        }
        return null;
    }
}
```

### Pattern 3: Conditional Proxy
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (shouldProxy(method)) {
        // Custom logic
    }
    return method.invoke(target, args);
}
```

---

## üîó Related Topics

- [Class Object](01.%20Class%20Object.md)
- [Inspecting Classes](02.%20Inspecting%20Classes.md)
- [Invoking Methods](03.%20Invoking%20Methods.md)
- [Accessing Fields](04.%20Accessing%20Fields.md)

---

## üí° Key Takeaways

- Dynamic proxies implement interfaces at runtime
- Use Proxy.newProxyInstance() to create proxies
- InvocationHandler intercepts all method calls
- invoke() receives proxy, method, and args
- Don't invoke methods on proxy parameter (infinite loop)
- Proxies only work with interfaces (not classes)
- Use for cross-cutting concerns (logging, security, caching)
- Handler is called for every method invocation
- Can combine multiple handlers
- Cache proxy instances for performance
