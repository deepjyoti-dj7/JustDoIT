# üîì Accessing Fields

## üìñ Overview

**Field Access** via Reflection allows reading and modifying field values at runtime, including private fields, using the `Field` object from `java.lang.reflect` package.

**Key Capabilities:**
- Read field values
- Modify field values
- Access private fields
- Handle static fields
- Work with final fields

---

## üíª Getting Field Values

### Basic Field Access

```java
class Person {
    public String name = "Alice";
    private int age = 25;
}

Person person = new Person();

// Public field
Field nameField = Person.class.getField("name");
Object value = nameField.get(person);
System.out.println(value);  // Alice

// Private field
Field ageField = Person.class.getDeclaredField("age");
ageField.setAccessible(true);  // Required for private fields
Object ageValue = ageField.get(person);
System.out.println(ageValue);  // 25
```

### Typed Field Access

```java
Person person = new Person();
Field nameField = Person.class.getDeclaredField("name");

// Generic get() returns Object
Object obj = nameField.get(person);
String name = (String) obj;

// Type-specific methods
Field ageField = Person.class.getDeclaredField("age");
ageField.setAccessible(true);
int age = ageField.getInt(person);  // Direct int access
```

---

## üíª Setting Field Values

### Modifying Fields

```java
class Person {
    private String name;
    private int age;
}

Person person = new Person();

// Set name
Field nameField = Person.class.getDeclaredField("name");
nameField.setAccessible(true);
nameField.set(person, "Bob");

// Set age
Field ageField = Person.class.getDeclaredField("age");
ageField.setAccessible(true);
ageField.setInt(person, 30);  // Direct int setter

System.out.println(nameField.get(person));  // Bob
System.out.println(ageField.getInt(person));  // 30
```

### Working with Primitives

```java
class Data {
    private int intValue;
    private double doubleValue;
    private boolean boolValue;
}

Data data = new Data();

// int field
Field intField = Data.class.getDeclaredField("intValue");
intField.setAccessible(true);
intField.setInt(data, 42);
int intVal = intField.getInt(data);

// double field
Field doubleField = Data.class.getDeclaredField("doubleValue");
doubleField.setAccessible(true);
doubleField.setDouble(data, 3.14);
double doubleVal = doubleField.getDouble(data);

// boolean field
Field boolField = Data.class.getDeclaredField("boolValue");
boolField.setAccessible(true);
boolField.setBoolean(data, true);
boolean boolVal = boolField.getBoolean(data);
```

---

## üíª Static Fields

### Accessing Static Fields

```java
class Config {
    public static String APP_NAME = "MyApp";
    private static int MAX_CONNECTIONS = 100;
}

// Public static field
Field appNameField = Config.class.getField("APP_NAME");
Object value = appNameField.get(null);  // Pass null for static
System.out.println(value);  // MyApp

// Private static field
Field maxField = Config.class.getDeclaredField("MAX_CONNECTIONS");
maxField.setAccessible(true);
int maxConnections = maxField.getInt(null);
System.out.println(maxConnections);  // 100

// Modify static field
maxField.setInt(null, 200);
System.out.println(maxField.getInt(null));  // 200
```

---

## üíª Final Fields

### Modifying Final Fields

```java
class Constants {
    private final String VALUE = "Original";
}

Constants obj = new Constants();

// Access final field
Field field = Constants.class.getDeclaredField("VALUE");
field.setAccessible(true);

System.out.println(field.get(obj));  // Original

// Modify final field (works but not recommended)
field.set(obj, "Modified");
System.out.println(field.get(obj));  // Modified

// Note: This doesn't work reliably for primitive final fields
// due to compiler optimizations
```

**Warning:** Modifying final fields is unreliable and not recommended, especially for primitives and Strings that may be inlined by the compiler.

---

## üéØ Complete Examples

### Example 1: Generic Field Copier

```java
public class FieldCopier {
    
    public static void copyFields(Object source, Object target) {
        if (source.getClass() != target.getClass()) {
            throw new IllegalArgumentException("Objects must be of same type");
        }
        
        try {
            for (Field field : source.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                
                Object value = field.get(source);
                field.set(target, value);
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Failed to copy fields", e);
        }
    }
    
    public static void main(String[] args) throws Exception {
        Person source = new Person("Alice", 30);
        Person target = new Person();
        
        copyFields(source, target);
        
        System.out.println(target.getName());  // Alice
        System.out.println(target.getAge());   // 30
    }
}

class Person {
    private String name;
    private int age;
    
    public Person() {}
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}
```

### Example 2: Object to Map Converter

```java
public class ObjectMapper {
    
    public static Map<String, Object> toMap(Object obj) {
        Map<String, Object> map = new HashMap<>();
        
        try {
            for (Field field : obj.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                
                String key = field.getName();
                Object value = field.get(obj);
                
                map.put(key, value);
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Failed to convert to map", e);
        }
        
        return map;
    }
    
    public static <T> T fromMap(Map<String, Object> map, Class<T> clazz) {
        try {
            T instance = clazz.getDeclaredConstructor().newInstance();
            
            for (Field field : clazz.getDeclaredFields()) {
                field.setAccessible(true);
                
                String key = field.getName();
                if (map.containsKey(key)) {
                    Object value = map.get(key);
                    field.set(instance, value);
                }
            }
            
            return instance;
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to create from map", e);
        }
    }
    
    public static void main(String[] args) {
        Person person = new Person("Bob", 25);
        
        // Object to Map
        Map<String, Object> map = toMap(person);
        System.out.println(map);  // {name=Bob, age=25}
        
        // Map to Object
        Person restored = fromMap(map, Person.class);
        System.out.println(restored.getName());  // Bob
    }
}
```

### Example 3: Null Field Checker

```java
public class NullFieldChecker {
    
    public static List<String> findNullFields(Object obj) {
        List<String> nullFields = new ArrayList<>();
        
        try {
            for (Field field : obj.getClass().getDeclaredFields()) {
                field.setAccessible(true);
                
                Object value = field.get(obj);
                if (value == null) {
                    nullFields.add(field.getName());
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Failed to check fields", e);
        }
        
        return nullFields;
    }
    
    public static boolean hasNullFields(Object obj) {
        return !findNullFields(obj).isEmpty();
    }
    
    public static void main(String[] args) {
        User user = new User();
        user.setName("Alice");
        // email is null
        
        List<String> nullFields = findNullFields(user);
        System.out.println("Null fields: " + nullFields);  // [email]
        
        System.out.println("Has nulls: " + hasNullFields(user));  // true
    }
}

class User {
    private String name;
    private String email;
    
    public void setName(String name) { this.name = name; }
    public void setEmail(String email) { this.email = email; }
}
```

### Example 4: Field Value Injector

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@interface Inject {
    String value() default "";
}

public class FieldInjector {
    private Map<String, Object> dependencies = new HashMap<>();
    
    public void register(String name, Object instance) {
        dependencies.put(name, instance);
    }
    
    public void inject(Object obj) {
        try {
            for (Field field : obj.getClass().getDeclaredFields()) {
                if (field.isAnnotationPresent(Inject.class)) {
                    field.setAccessible(true);
                    
                    Inject annotation = field.getAnnotation(Inject.class);
                    String name = annotation.value();
                    
                    if (name.isEmpty()) {
                        name = field.getType().getSimpleName().toLowerCase();
                    }
                    
                    Object dependency = dependencies.get(name);
                    if (dependency != null) {
                        field.set(obj, dependency);
                    }
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Injection failed", e);
        }
    }
    
    public static void main(String[] args) {
        FieldInjector injector = new FieldInjector();
        
        // Register dependencies
        injector.register("database", new Database());
        injector.register("logger", new Logger());
        
        // Create and inject
        Service service = new Service();
        injector.inject(service);
        
        service.execute();
    }
}

class Service {
    @Inject
    private Database database;
    
    @Inject
    private Logger logger;
    
    public void execute() {
        logger.log("Starting...");
        database.query("SELECT * FROM users");
    }
}

class Database {
    public void query(String sql) {
        System.out.println("Executing: " + sql);
    }
}

class Logger {
    public void log(String message) {
        System.out.println("LOG: " + message);
    }
}
```

### Example 5: Deep Clone

```java
public class DeepCloner {
    
    public static <T> T deepClone(T obj) {
        try {
            @SuppressWarnings("unchecked")
            Class<T> clazz = (Class<T>) obj.getClass();
            T clone = clazz.getDeclaredConstructor().newInstance();
            
            for (Field field : clazz.getDeclaredFields()) {
                field.setAccessible(true);
                
                Object value = field.get(obj);
                
                // Clone mutable objects
                if (value != null && !isPrimitive(field.getType())) {
                    if (value instanceof String) {
                        // Strings are immutable
                        field.set(clone, value);
                    } else if (value instanceof List) {
                        field.set(clone, new ArrayList<>((List<?>) value));
                    } else if (value instanceof Map) {
                        field.set(clone, new HashMap<>((Map<?, ?>) value));
                    } else {
                        // For other objects, use reflection recursively
                        field.set(clone, deepClone(value));
                    }
                } else {
                    field.set(clone, value);
                }
            }
            
            return clone;
            
        } catch (Exception e) {
            throw new RuntimeException("Clone failed", e);
        }
    }
    
    private static boolean isPrimitive(Class<?> type) {
        return type.isPrimitive() || 
               type == Integer.class || 
               type == Long.class || 
               type == Double.class || 
               type == Boolean.class;
    }
    
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        Person cloned = deepClone(person);
        
        System.out.println(cloned.getName());  // Alice
        System.out.println(person == cloned);  // false (different objects)
    }
}
```

---

## üìä Field Access Methods

| Method | For Type | Description |
|--------|----------|-------------|
| get(obj) | Object | Generic getter |
| set(obj, value) | Object | Generic setter |
| getInt(obj) | int | Get int value |
| setInt(obj, value) | int | Set int value |
| getDouble(obj) | double | Get double value |
| getBoolean(obj) | boolean | Get boolean value |

---

## üìä Field Modifiers

| Property | Check Method |
|----------|--------------|
| Public | Modifier.isPublic() |
| Private | Modifier.isPrivate() |
| Protected | Modifier.isProtected() |
| Static | Modifier.isStatic() |
| Final | Modifier.isFinal() |
| Transient | Modifier.isTransient() |
| Volatile | Modifier.isVolatile() |

---

## ‚ö° Best Practices

| Practice | Description |
|----------|-------------|
| ‚úÖ Use setAccessible(true) | For private fields |
| ‚úÖ Cache Field objects | Performance |
| ‚úÖ Handle IllegalAccessException | Proper error handling |
| ‚úÖ Pass null for static fields | Field.get(null) |
| ‚úÖ Use type-specific getters | getInt(), getDouble() |
| ‚ùå Don't modify final fields | Unreliable behavior |
| ‚ùå Don't ignore security | setAccessible can fail |

---

## üéØ Common Patterns

### Pattern 1: Null Field Validator
```java
for (Field field : obj.getClass().getDeclaredFields()) {
    field.setAccessible(true);
    if (field.get(obj) == null) {
        throw new IllegalStateException("Field is null: " + field.getName());
    }
}
```

### Pattern 2: Reset Fields
```java
for (Field field : obj.getClass().getDeclaredFields()) {
    field.setAccessible(true);
    if (field.getType() == String.class) {
        field.set(obj, null);
    } else if (field.getType() == int.class) {
        field.setInt(obj, 0);
    }
}
```

### Pattern 3: Copy Non-Null Fields
```java
for (Field field : source.getClass().getDeclaredFields()) {
    field.setAccessible(true);
    Object value = field.get(source);
    if (value != null) {
        field.set(target, value);
    }
}
```

---

## üîó Related Topics

- [Class Object](01.%20Class%20Object.md)
- [Inspecting Classes](02.%20Inspecting%20Classes.md)
- [Invoking Methods](03.%20Invoking%20Methods.md)
- [Dynamic Proxies](05.%20Dynamic%20Proxies.md)

---

## üí° Key Takeaways

- Use Field.get(obj) to read field values
- Use Field.set(obj, value) to modify field values
- Call setAccessible(true) for private fields
- Pass null for static fields: field.get(null)
- Use type-specific methods: getInt(), setInt()
- Modifying final fields is unreliable
- Cache Field objects for performance
- Handle IllegalAccessException properly
- Security manager can prevent setAccessible()
- Use reflection to build generic utilities (mappers, validators, injectors)
