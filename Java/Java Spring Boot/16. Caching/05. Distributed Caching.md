# Distributed Caching - Complete Guide

---

## 1. Introduction to Distributed Caching

Distributed caching spreads cached data across multiple nodes, enabling sharing between application instances and improving scalability, availability, and fault tolerance.

### Why Distributed Caching?
- **Scalability** - Share cache across multiple app instances
- **High Availability** - Survive node failures
- **Consistency** - Unified cache view across cluster
- **Performance** - Reduce database load in microservices
- **Session Sharing** - Share user sessions across instances

### Common Use Cases
- Microservices architecture
- Load-balanced applications
- Session management
- API response caching
- Database query caching

---

## 2. Redis Distributed Caching

### 2.1. Overview

Redis is the most popular distributed cache:
- In-memory data store
- Supports replication and clustering
- Persistence options (RDB, AOF)
- Pub/Sub messaging
- Rich data structures

### 2.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 2.3. Basic Configuration

```yaml
spring:
  cache:
    type: redis
    redis:
      time-to-live: 600000  # 10 minutes
      cache-null-values: false
      key-prefix: "myapp::"
      use-key-prefix: true
  
  data:
    redis:
      host: redis-server.example.com
      port: 6379
      password: ${REDIS_PASSWORD}
      database: 0
```

### 2.4. Java Configuration

```java
@Configuration
@EnableCaching
public class RedisCacheConfig {
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("redis-server.example.com");
        config.setPort(6379);
        config.setPassword(RedisPassword.of("secret"));
        config.setDatabase(0);
        
        LettuceConnectionFactory factory = new LettuceConnectionFactory(config);
        return factory;
    }
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues();
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultConfig)
                .transactionAware()
                .build();
    }
}
```

---

## 3. Redis Clustering

### 3.1. Redis Cluster Configuration

```yaml
spring:
  data:
    redis:
      cluster:
        nodes:
          - redis-node1.example.com:6379
          - redis-node2.example.com:6379
          - redis-node3.example.com:6379
          - redis-node4.example.com:6379
          - redis-node5.example.com:6379
          - redis-node6.example.com:6379
        max-redirects: 3
      password: ${REDIS_PASSWORD}
      timeout: 2000ms
```

### 3.2. Java Configuration

```java
@Configuration
public class RedisClusterConfig {
    
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisClusterConfiguration clusterConfig = new RedisClusterConfiguration(
            Arrays.asList(
                "redis-node1.example.com:6379",
                "redis-node2.example.com:6379",
                "redis-node3.example.com:6379"
            )
        );
        clusterConfig.setPassword(RedisPassword.of("secret"));
        clusterConfig.setMaxRedirects(3);
        
        LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
                .commandTimeout(Duration.ofSeconds(2))
                .build();
        
        return new LettuceConnectionFactory(clusterConfig, clientConfig);
    }
}
```

### 3.3. How Redis Cluster Works

- **Sharding**: Data partitioned across nodes using hash slots (16384 slots)
- **Replication**: Each master has replicas for high availability
- **Automatic Failover**: Replicas promoted when master fails
- **Client-side routing**: Clients redirected to correct node

```
Master 1 (slots 0-5460)  → Replica 1
Master 2 (slots 5461-10922) → Replica 2
Master 3 (slots 10923-16383) → Replica 3
```

---

## 4. Redis Sentinel (High Availability)

### 4.1. Configuration

```yaml
spring:
  data:
    redis:
      sentinel:
        master: mymaster
        nodes:
          - sentinel1.example.com:26379
          - sentinel2.example.com:26379
          - sentinel3.example.com:26379
        password: ${SENTINEL_PASSWORD}
      password: ${REDIS_PASSWORD}
```

### 4.2. Java Configuration

```java
@Bean
public RedisConnectionFactory redisConnectionFactory() {
    RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
        .master("mymaster")
        .sentinel("sentinel1.example.com", 26379)
        .sentinel("sentinel2.example.com", 26379)
        .sentinel("sentinel3.example.com", 26379);
    
    sentinelConfig.setPassword(RedisPassword.of("secret"));
    sentinelConfig.setSentinelPassword(RedisPassword.of("sentinel-secret"));
    
    return new LettuceConnectionFactory(sentinelConfig);
}
```

### 4.3. Sentinel Features

- **Monitoring**: Checks master and replica health
- **Notification**: Alerts on failures
- **Automatic Failover**: Promotes replica to master
- **Configuration Provider**: Clients discover current master

---

## 5. Hazelcast Distributed Caching

### 5.1. Overview

- In-memory data grid
- Automatic clustering
- Distributed data structures
- No external server required (embedded mode)

### 5.2. Dependencies

```xml
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-spring</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 5.3. Configuration

```yaml
spring:
  cache:
    type: hazelcast
  
hazelcast:
  network:
    join:
      multicast:
        enabled: true
  map:
    products:
      time-to-live-seconds: 600
      max-idle-seconds: 300
      eviction:
        size: 1000
        max-size-policy: PER_NODE
        eviction-policy: LRU
```

### 5.4. Java Configuration

```java
@Configuration
@EnableCaching
public class HazelcastCacheConfig {
    
    @Bean
    public Config hazelcastConfig() {
        Config config = new Config();
        config.setInstanceName("hazelcast-cache");
        
        // Network configuration
        NetworkConfig networkConfig = config.getNetworkConfig();
        networkConfig.setPort(5701);
        networkConfig.setPortAutoIncrement(true);
        
        JoinConfig joinConfig = networkConfig.getJoin();
        joinConfig.getMulticastConfig().setEnabled(true);
        joinConfig.getTcpIpConfig().setEnabled(false);
        
        // Cache configuration
        MapConfig productCache = new MapConfig();
        productCache.setName("products");
        productCache.setTimeToLiveSeconds(600);
        productCache.setMaxIdleSeconds(300);
        
        EvictionConfig evictionConfig = new EvictionConfig();
        evictionConfig.setSize(1000);
        evictionConfig.setMaxSizePolicy(MaxSizePolicy.PER_NODE);
        evictionConfig.setEvictionPolicy(EvictionPolicy.LRU);
        productCache.setEvictionConfig(evictionConfig);
        
        config.addMapConfig(productCache);
        
        return config;
    }
    
    @Bean
    public HazelcastInstance hazelcastInstance(Config config) {
        return Hazelcast.newHazelcastInstance(config);
    }
}
```

### 5.5. Client-Server Mode

```java
@Bean
public HazelcastInstance hazelcastClient() {
    ClientConfig clientConfig = new ClientConfig();
    clientConfig.setClusterName("dev");
    clientConfig.getNetworkConfig()
        .addAddress("hazelcast-server1:5701", "hazelcast-server2:5701");
    
    return HazelcastClient.newHazelcastClient(clientConfig);
}
```

---

## 6. Cache Consistency

### 6.1. Consistency Models

**Strong Consistency**
- All nodes see same data at same time
- Slower writes (synchronous replication)
- Used in financial systems

**Eventual Consistency**
- Updates propagate asynchronously
- Faster writes
- Temporary inconsistencies possible
- Common in distributed caches

### 6.2. Cache Invalidation Strategies

**1. Time-Based (TTL)**
```java
@Cacheable(value = "products")
public Product getProduct(Long id) {
    // Cached for configured TTL
    return productRepository.findById(id).orElseThrow();
}
```

**2. Event-Based**
```java
@CacheEvict(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    Product updated = productRepository.save(product);
    // Cache invalidated on update
    return updated;
}
```

**3. Pub/Sub Invalidation**
```java
@Service
public class CacheInvalidationService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private CacheManager cacheManager;
    
    // Publish invalidation event
    public void invalidateCache(String cacheName, String key) {
        redisTemplate.convertAndSend("cache-invalidation", 
            cacheName + ":" + key);
    }
    
    // Subscribe to invalidation events
    @RedisMessageListener(topic = "cache-invalidation")
    public void handleInvalidation(String message) {
        String[] parts = message.split(":");
        String cacheName = parts[0];
        String key = parts[1];
        
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.evict(key);
        }
    }
}
```

### 6.3. Write-Through Pattern

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repository;
    
    @Autowired
    private CacheManager cacheManager;
    
    public Product updateProduct(Product product) {
        // Write to database
        Product saved = repository.save(product);
        
        // Update cache immediately
        Cache cache = cacheManager.getCache("products");
        cache.put(product.getId(), saved);
        
        return saved;
    }
}
```

---

## 7. Session Management

### 7.1. Spring Session with Redis

**Dependencies**
```xml
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

**Configuration**
```yaml
spring:
  session:
    store-type: redis
    timeout: 30m
  
  data:
    redis:
      host: redis-server.example.com
      port: 6379
```

**Enable Spring Session**
```java
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 1800)
public class SessionConfig {
}
```

**Usage**
```java
@RestController
public class SessionController {
    
    @GetMapping("/session")
    public Map<String, Object> getSession(HttpSession session) {
        session.setAttribute("user", "john");
        return Map.of(
            "sessionId", session.getId(),
            "user", session.getAttribute("user")
        );
    }
}
```

---

## 8. Multi-Level Caching (L1 + L2)

### 8.1. Local (L1) + Distributed (L2)

```java
@Configuration
public class MultiLevelCacheConfig {
    
    @Bean
    public CacheManager cacheManager(
        RedisConnectionFactory redisFactory
    ) {
        // L1: Local Caffeine cache
        CaffeineCacheManager l1CacheManager = new CaffeineCacheManager();
        l1CacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(1, TimeUnit.MINUTES));
        
        // L2: Distributed Redis cache
        RedisCacheManager l2CacheManager = RedisCacheManager.builder(redisFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)))
            .build();
        
        // Composite cache manager
        return new CompositeCacheManager(l1CacheManager, l2CacheManager);
    }
}
```

### 8.2. Custom Multi-Level Cache

```java
public class TwoLevelCache implements Cache {
    
    private final Cache l1Cache;  // Local
    private final Cache l2Cache;  // Distributed
    private final String name;
    
    @Override
    public ValueWrapper get(Object key) {
        // Check L1
        ValueWrapper value = l1Cache.get(key);
        if (value != null) {
            return value;
        }
        
        // Check L2
        value = l2Cache.get(key);
        if (value != null) {
            // Populate L1
            l1Cache.put(key, value.get());
        }
        
        return value;
    }
    
    @Override
    public void put(Object key, Object value) {
        // Write to both levels
        l1Cache.put(key, value);
        l2Cache.put(key, value);
    }
    
    @Override
    public void evict(Object key) {
        // Evict from both
        l1Cache.evict(key);
        l2Cache.evict(key);
    }
}
```

---

## 9. Cache Replication Strategies

### 9.1. Master-Replica Replication

```
┌─────────┐        ┌─────────┐
│ Master  │───────>│ Replica │
│ (Write) │        │ (Read)  │
└─────────┘        └─────────┘
```

**Redis Configuration**
```yaml
# Master
spring:
  data:
    redis:
      host: master.redis.example.com
      port: 6379

# Replica
spring:
  data:
    redis:
      host: replica.redis.example.com
      port: 6379
```

### 9.2. Peer-to-Peer Replication (Hazelcast)

```
┌──────┐     ┌──────┐     ┌──────┐
│ Node1│<───>│ Node2│<───>│ Node3│
└──────┘     └──────┘     └──────┘
```

All nodes are equal, data automatically replicated.

---

## 10. Partition Tolerance

### 10.1. Handling Network Partitions

```java
@Service
public class ResilientCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductRepository repository;
    
    public Product getProduct(Long id) {
        try {
            // Try cache
            String key = "product:" + id;
            Product product = (Product) redisTemplate.opsForValue().get(key);
            
            if (product != null) {
                return product;
            }
        } catch (Exception e) {
            log.warn("Cache unavailable, falling back to database", e);
        }
        
        // Fallback to database
        return repository.findById(id).orElseThrow();
    }
}
```

### 10.2. Circuit Breaker Pattern

```java
@Service
public class CacheWithCircuitBreaker {
    
    private final CircuitBreaker circuitBreaker;
    
    public CacheWithCircuitBreaker() {
        this.circuitBreaker = CircuitBreaker.ofDefaults("redis-cache");
    }
    
    public Product getFromCache(Long id) {
        return circuitBreaker.executeSupplier(() -> {
            return (Product) redisTemplate.opsForValue().get("product:" + id);
        });
    }
}
```

---

## 11. Best Practices

1. **Use Redis for distributed** - Proven, mature, widely supported
2. **Enable replication** - High availability and fault tolerance
3. **Configure TTL appropriately** - Balance freshness and traffic
4. **Monitor cache metrics** - Hit ratio, memory, latency
5. **Use connection pooling** - Reduce connection overhead
6. **Handle failures gracefully** - Fallback to database
7. **Implement cache warming** - Preload critical data
8. **Use pub/sub for invalidation** - Keep caches in sync
9. **Consider multi-level caching** - L1 (local) + L2 (distributed)
10. **Secure Redis connections** - Use passwords, TLS/SSL

---

## 12. Interview Questions

**Q1: What is distributed caching?**
**A:** Cache shared across multiple application instances (e.g., Redis, Hazelcast).

**Q2: Redis vs Hazelcast?**
**A:** Redis: External server, mature, persistence. Hazelcast: Embedded, no external dependency.

**Q3: What is Redis Cluster?**
**A:** Distributed Redis setup with automatic sharding and replication.

**Q4: What is Redis Sentinel?**
**A:** High availability solution for Redis with automatic failover.

**Q5: How does Redis Cluster shard data?**
**A:** Using hash slots (16384 slots) distributed across master nodes.

**Q6: What is eventual consistency?**
**A:** All nodes converge to same state eventually, but may differ temporarily.

**Q7: What is cache invalidation in distributed systems?**
**A:** Removing stale data from cache across all nodes.

**Q8: How to share sessions in distributed apps?**
**A:** Use Spring Session with Redis to store sessions externally.

**Q9: What is multi-level caching?**
**A:** Combining local (L1) and distributed (L2) caches for optimal performance.

**Q10: What is cache-aside pattern in distributed caching?**
**A:** App checks cache, loads from DB on miss, stores in cache.

**Q11: How to handle Redis connection failures?**
**A:** Implement fallback to database, use circuit breaker pattern.

**Q12: What is Redis replication?**
**A:** Copying data from master to replica nodes for redundancy.

**Q13: What is cache stampede?**
**A:** Multiple requests simultaneously loading same data on cache miss.

**Q14: How to prevent cache stampede in distributed cache?**
**A:** Use locks, synchronized loading, or probabilistic early expiration.

**Q15: What is pub/sub in Redis?**
**A:** Messaging pattern for cache invalidation events across instances.

**Q16: What is write-through caching?**
**A:** Write to database and cache simultaneously.

**Q17: What is cache serialization?**
**A:** Converting objects to bytes for storage in distributed cache.

**Q18: How to configure Redis connection pool?**
**A:** Via `spring.data.redis.lettuce.pool.*` properties.

**Q19: What is Hazelcast near cache?**
**A:** Local cache (L1) in front of distributed Hazelcast cache (L2).

**Q20: How to monitor distributed cache health?**
**A:** Track hit ratio, memory usage, latency, connection errors, replication lag.

---

## 13. Summary

Distributed caching enables cache sharing across application instances using Redis (most popular) or Hazelcast (embedded). Configure clustering and replication for high availability. Handle consistency with TTL, event-based invalidation, or pub/sub. Use Spring Session for distributed session management. Implement multi-level caching (L1 + L2) for optimal performance.

---

**Next:** Cache Strategies →
