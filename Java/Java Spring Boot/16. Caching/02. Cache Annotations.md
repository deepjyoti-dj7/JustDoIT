# Spring Cache Annotations - Complete Guide

---

## 1. Introduction to Spring Cache Abstraction

Spring provides a powerful caching abstraction that allows declarative caching using annotations. It works with various cache providers (Caffeine, Redis, EhCache) without changing application code.

### Key Features
- **Declarative caching** with annotations
- **Provider independence** - works with any cache implementation
- **Method-level caching** - transparent to caller
- **Conditional caching** - based on expressions
- **Flexible key generation**

---

## 2. Enabling Caching

### 2.1. Enable with @EnableCaching

```java
@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### 2.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Cache Provider (e.g., Caffeine) -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
```

---

## 3. @Cacheable - Read from Cache

### 3.1. Basic Usage

```java
@Service
public class ProductService {
    
    @Cacheable("products")
    public Product getProduct(Long id) {
        log.info("Fetching product {} from database", id);
        return productRepository.findById(id).orElse(null);
    }
}
```

**First call**: Fetches from database, stores in cache
**Subsequent calls**: Returns from cache (no database hit)

### 3.2. With Key

```java
@Cacheable(value = "products", key = "#id")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

### 3.3. Composite Key

```java
@Cacheable(value = "products", key = "#customerId + '_' + #productId")
public Product getCustomerProduct(Long customerId, Long productId) {
    return productRepository.findByCustomerAndProduct(customerId, productId);
}
```

### 3.4. Using Object Properties

```java
@Cacheable(value = "products", key = "#request.customerId + '_' + #request.category")
public List<Product> searchProducts(SearchRequest request) {
    return productRepository.search(request);
}
```

### 3.5. Key with Method Name

```java
@Cacheable(value = "products", key = "#root.methodName + '_' + #id")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

### 3.6. Conditional Caching

```java
// Only cache if product is active
@Cacheable(value = "products", key = "#id", condition = "#result != null && #result.active")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

### 3.7. Unless Expression

```java
// Don't cache if result is null
@Cacheable(value = "products", key = "#id", unless = "#result == null")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}

// Don't cache empty lists
@Cacheable(value = "products", unless = "#result.isEmpty()")
public List<Product> getAllProducts() {
    return productRepository.findAll();
}
```

### 3.8. Sync Mode (Prevent Cache Stampede)

```java
@Cacheable(value = "products", key = "#id", sync = true)
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

---

## 4. @CachePut - Update Cache

### 4.1. Basic Usage

```java
@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
```

**Behavior**: Always executes method and updates cache with result

### 4.2. Update After Creation

```java
@CachePut(value = "products", key = "#result.id")
public Product createProduct(Product product) {
    return productRepository.save(product);
}
```

### 4.3. Conditional Update

```java
@CachePut(value = "products", key = "#product.id", condition = "#product.price > 100")
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
```

---

## 5. @CacheEvict - Remove from Cache

### 5.1. Evict Single Entry

```java
@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
}
```

### 5.2. Evict All Entries

```java
@CacheEvict(value = "products", allEntries = true)
public void deleteAllProducts() {
    productRepository.deleteAll();
}
```

### 5.3. Before vs After Invocation

```java
// Evict before method execution (default: false)
@CacheEvict(value = "products", key = "#id", beforeInvocation = true)
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
    // Cache already evicted even if exception occurs
}

// Evict after method execution (default)
@CacheEvict(value = "products", key = "#id", beforeInvocation = false)
public void deleteProduct(Long id) {
    productRepository.deleteById(id);
    // Cache evicted only if method succeeds
}
```

### 5.4. Conditional Eviction

```java
@CacheEvict(value = "products", key = "#id", condition = "#result == true")
public boolean deactivateProduct(Long id) {
    return productRepository.deactivate(id);
}
```

---

## 6. @Caching - Multiple Cache Operations

### 6.1. Multiple Cacheable

```java
@Caching(cacheable = {
    @Cacheable(value = "products", key = "#id"),
    @Cacheable(value = "productsByName", key = "#result.name")
})
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

### 6.2. Cacheable + CacheEvict

```java
@Caching(
    cacheable = @Cacheable(value = "products", key = "#id"),
    evict = @CacheEvict(value = "allProducts", allEntries = true)
)
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

### 6.3. Multiple Evictions

```java
@Caching(evict = {
    @CacheEvict(value = "products", key = "#product.id"),
    @CacheEvict(value = "productsByCategory", key = "#product.category"),
    @CacheEvict(value = "allProducts", allEntries = true)
})
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
```

### 6.4. Complex Caching Strategy

```java
@Caching(
    put = @CachePut(value = "products", key = "#product.id"),
    evict = {
        @CacheEvict(value = "productsByCategory", key = "#product.category"),
        @CacheEvict(value = "searchResults", allEntries = true)
    }
)
public Product updateProduct(Product product) {
    return productRepository.save(product);
}
```

---

## 7. @CacheConfig - Class-Level Configuration

```java
@Service
@CacheConfig(cacheNames = "products", keyGenerator = "customKeyGenerator")
public class ProductService {
    
    @Cacheable // Uses "products" cache and customKeyGenerator
    public Product getProduct(Long id) {
        return productRepository.findById(id).orElse(null);
    }
    
    @CachePut(key = "#product.id") // Uses "products" cache
    public Product updateProduct(Product product) {
        return productRepository.save(product);
    }
    
    @CacheEvict(key = "#id") // Uses "products" cache
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }
}
```

---

## 8. SpEL Expressions in Cache Annotations

### 8.1. Available Variables

| Variable        | Description                          | Example                    |
|-----------------|--------------------------------------|----------------------------|
| `#root.method`  | Method being invoked                 | `#root.methodName`         |
| `#root.target`  | Target object                        | `#root.target`             |
| `#root.caches`  | Collection of caches                 | `#root.caches[0].name`     |
| `#result`       | Method return value (except @Cacheable) | `#result.id`           |
| `#paramName`    | Method parameter                     | `#id`, `#product.name`     |
| `#p0`, `#a0`    | First parameter                      | `#p0`, `#a0`               |

### 8.2. Examples

```java
// Method name in key
@Cacheable(value = "cache", key = "#root.methodName + '_' + #id")
public Product getProduct(Long id) { }

// Target class name
@Cacheable(value = "cache", key = "#root.targetClass + '_' + #id")
public Product getProduct(Long id) { }

// Parameter by position
@Cacheable(value = "cache", key = "#p0 + '_' + #p1")
public Product getProduct(Long customerId, Long productId) { }

// Conditional based on result
@Cacheable(value = "cache", condition = "#result != null && #result.price > 100")
public Product getProduct(Long id) { }

// Complex expression
@Cacheable(value = "cache", 
    key = "T(java.lang.String).format('%s_%s', #customerId, #category)",
    condition = "#category != null",
    unless = "#result.isEmpty()")
public List<Product> search(Long customerId, String category) { }
```

---

## 9. Custom Key Generator

### 9.1. Implementation

```java
@Component
public class CustomKeyGenerator implements KeyGenerator {
    
    @Override
    public Object generate(Object target, Method method, Object... params) {
        StringBuilder key = new StringBuilder();
        key.append(target.getClass().getSimpleName());
        key.append("_");
        key.append(method.getName());
        
        for (Object param : params) {
            key.append("_");
            if (param != null) {
                key.append(param.toString());
            } else {
                key.append("null");
            }
        }
        
        return key.toString();
    }
}
```

### 9.2. Usage

```java
@Cacheable(value = "products", keyGenerator = "customKeyGenerator")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElse(null);
}
```

---

## 10. Custom Cache Resolver

```java
@Component
public class CustomCacheResolver implements CacheResolver {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {
        Collection<Cache> caches = new ArrayList<>();
        
        // Dynamic cache selection based on parameter
        String cacheName = determineCacheName(context);
        caches.add(cacheManager.getCache(cacheName));
        
        return caches;
    }
    
    private String determineCacheName(CacheOperationInvocationContext<?> context) {
        Object[] args = context.getArgs();
        if (args.length > 0 && args[0] instanceof String) {
            return "cache_" + args[0];
        }
        return "defaultCache";
    }
}

@Cacheable(cacheResolver = "customCacheResolver")
public Product getProduct(String type, Long id) {
    return productRepository.findByTypeAndId(type, id);
}
```

---

## 11. Programmatic Cache Access

```java
@Service
public class ProductService {
    
    @Autowired
    private CacheManager cacheManager;
    
    public void manualCacheOperation() {
        Cache cache = cacheManager.getCache("products");
        
        // Get from cache
        Product product = cache.get(1L, Product.class);
        
        // Put in cache
        cache.put(1L, new Product(1L, "Laptop"));
        
        // Evict from cache
        cache.evict(1L);
        
        // Clear entire cache
        cache.clear();
    }
}
```

---

## 12. Cache Statistics

```java
@Service
public class CacheMonitorService {
    
    @Autowired
    private CacheManager cacheManager;
    
    public Map<String, CacheStats> getCacheStatistics() {
        Map<String, CacheStats> stats = new HashMap<>();
        
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    (com.github.benmanes.caffeine.cache.Cache<Object, Object>) 
                    ((CaffeineCache) cache).getNativeCache();
                
                CacheStats cacheStats = nativeCache.stats();
                stats.put(cacheName, cacheStats);
            }
        });
        
        return stats;
    }
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void logCacheStats() {
        getCacheStatistics().forEach((name, stats) -> {
            log.info("Cache: {}, Hits: {}, Misses: {}, Hit Ratio: {}%",
                name, stats.hitCount(), stats.missCount(), 
                stats.hitRate() * 100);
        });
    }
}
```

---

## 13. Best Practices

1. **Use @CacheConfig** for shared configuration
2. **Design meaningful cache keys** - avoid collisions
3. **Set appropriate TTL** - balance freshness and performance
4. **Use `unless`** to avoid caching nulls or empty results
5. **Enable `sync` mode** for frequently accessed keys
6. **Monitor cache metrics** - hit ratio, evictions
7. **Test cache behavior** - verify hits, misses, evictions
8. **Handle cache failures** - graceful degradation
9. **Document caching strategy** - keys, TTL, eviction
10. **Use @CacheEvict judiciously** - avoid over-invalidation

---

## 14. Common Pitfalls

### ❌ Self-Invocation
```java
// Won't work - same class call bypasses proxy
public void methodA() {
    methodB(); // Cache not applied
}

@Cacheable("cache")
public void methodB() { }
```

**Solution**: Call from another bean or use `@EnableAspectJAutoProxy`

### ❌ Caching Mutable Objects
```java
@Cacheable("products")
public Product getProduct(Long id) {
    return product; // If modified, affects cache
}
```

**Solution**: Return defensive copies or use immutable objects

### ❌ Wrong Key Design
```java
// Bad - object hashCode changes
@Cacheable(value = "cache", key = "#product")
public Product process(Product product) { }

// Good - use stable identifier
@Cacheable(value = "cache", key = "#product.id")
public Product process(Product product) { }
```

---

## 15. Interview Questions

**Q1: What is @Cacheable?**
**A:** Annotation that caches method results. Subsequent calls return cached value without executing method.

**Q2: @Cacheable vs @CachePut?**
**A:** Cacheable: Skips execution if cached. CachePut: Always executes and updates cache.

**Q3: What is @CacheEvict?**
**A:** Removes entries from cache, used when data is deleted or updated.

**Q4: What is the `key` attribute?**
**A:** Defines cache key using SpEL expressions (e.g., `#id`, `#product.name`).

**Q5: What is `condition`?**
**A:** SpEL expression determining whether to apply caching (evaluated before method execution).

**Q6: What is `unless`?**
**A:** SpEL expression to skip caching based on result (evaluated after method execution).

**Q7: What is `sync` mode?**
**A:** Synchronizes cache access to prevent stampede (multiple threads fetching same key).

**Q8: What is @CacheConfig?**
**A:** Class-level annotation providing default cache configuration (names, key generator).

**Q9: What is @Caching?**
**A:** Groups multiple cache operations (@Cacheable, @CachePut, @CacheEvict) on single method.

**Q10: beforeInvocation in @CacheEvict?**
**A:** true: Evict before method. false (default): Evict after method success.

**Q11: How to cache with composite key?**
**A:** Use SpEL: `key = "#param1 + '_' + #param2"`

**Q12: What is KeyGenerator?**
**A:** Interface for custom cache key generation logic.

**Q13: What is CacheResolver?**
**A:** Interface for dynamic cache selection based on context.

**Q14: Can you access cache programmatically?**
**A:** Yes, using CacheManager: `cacheManager.getCache("name").get(key)`

**Q15: Why doesn't caching work in self-invocation?**
**A:** Spring uses proxies. Internal calls bypass proxy, so annotations don't apply.

**Q16: How to cache null values?**
**A:** Remove `unless = "#result == null"` or configure cache provider to allow nulls.

**Q17: What is `allEntries` in @CacheEvict?**
**A:** When true, clears entire cache instead of single entry.

**Q18: How to use method name in cache key?**
**A:** SpEL: `key = "#root.methodName + '_' + #id"`

**Q19: What happens if cache provider fails?**
**A:** Depends on configuration. Usually falls back to executing method without caching.

**Q20: How to test caching?**
**A:** Verify method execution count, check cache statistics, use @CacheEvict in tests.

---

## 16. Summary

Spring Cache annotations provide declarative caching with @Cacheable, @CachePut, @CacheEvict, and @Caching. SpEL expressions enable flexible key generation and conditional caching. Understanding annotation behavior, key design, and common pitfalls ensures effective caching implementation.

---

**Next:** Cache Providers →
