# Cache Strategies - Complete Guide

---

## 1. Introduction to Cache Strategies

Cache strategies define how applications interact with cache and database to optimize performance, consistency, and reliability.

### Common Strategies
- **Cache-Aside** (Lazy Loading)
- **Read-Through**
- **Write-Through**
- **Write-Behind** (Write-Back)
- **Refresh-Ahead**

### Selection Criteria
- Read vs write ratio
- Consistency requirements
- Performance goals
- Data volatility
- System complexity

---

## 2. Cache-Aside (Lazy Loading)

### 2.1. Overview

Application manages cache explicitly:
1. Check cache
2. If miss, load from database
3. Store in cache
4. Return data

### 2.2. Implementation

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repository;
    
    @Autowired
    private CacheManager cacheManager;
    
    public Product getProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        
        // Check cache
        Product product = cache.get(id, Product.class);
        if (product != null) {
            return product;
        }
        
        // Load from database
        product = repository.findById(id)
            .orElseThrow(() -> new ProductNotFoundException(id));
        
        // Store in cache
        cache.put(id, product);
        
        return product;
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        repository.deleteById(id);
    }
    
    @CacheEvict(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        return repository.save(product);
    }
}
```

### 2.3. With Spring Annotations

```java
@Service
public class ProductService {
    
    @Cacheable("products")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    @CachePut(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        return repository.save(product);
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        repository.deleteById(id);
    }
}
```

### 2.4. Pros and Cons

**Pros:**
- Only requested data is cached
- Cache failures don't break the system
- Simple to implement

**Cons:**
- Cache miss penalty (3 round trips: cache check, DB load, cache write)
- Potential cache stampede
- Stale data if not invalidated properly

---

## 3. Read-Through

### 3.1. Overview

Cache automatically loads from database on miss:
1. Check cache
2. If miss, cache loads from database
3. Return data

### 3.2. Implementation

```java
@Configuration
public class ReadThroughCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products");
        cacheManager.setCacheLoader(new CacheLoader<Object, Object>() {
            @Override
            public Object load(Object key) {
                // Cache automatically loads from database
                return productRepository.findById((Long) key)
                    .orElseThrow();
            }
        });
        return cacheManager;
    }
}
```

### 3.3. Custom Read-Through Cache

```java
public class ReadThroughCache<K, V> {
    
    private final Cache cache;
    private final Function<K, V> loader;
    
    public ReadThroughCache(Cache cache, Function<K, V> loader) {
        this.cache = cache;
        this.loader = loader;
    }
    
    public V get(K key) {
        ValueWrapper wrapper = cache.get(key);
        if (wrapper != null) {
            return (V) wrapper.get();
        }
        
        // Load from source
        V value = loader.apply(key);
        cache.put(key, value);
        return value;
    }
}

// Usage
@Service
public class ProductService {
    
    private final ReadThroughCache<Long, Product> cache;
    
    public ProductService(CacheManager cacheManager, ProductRepository repository) {
        this.cache = new ReadThroughCache<>(
            cacheManager.getCache("products"),
            id -> repository.findById(id).orElseThrow()
        );
    }
    
    public Product getProduct(Long id) {
        return cache.get(id);
    }
}
```

### 3.4. Pros and Cons

**Pros:**
- Simplified application code
- Consistent cache loading logic
- Centralized data access

**Cons:**
- Cache dependency for reads
- Harder to implement
- Cache failure impacts reads

---

## 4. Write-Through

### 4.1. Overview

Write to cache and database simultaneously:
1. Write to cache
2. Cache writes to database synchronously
3. Confirm success

### 4.2. Implementation

```java
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository repository;
    
    @Autowired
    private CacheManager cacheManager;
    
    @Transactional
    public Product updateProduct(Product product) {
        // Write to database
        Product saved = repository.save(product);
        
        // Write to cache
        Cache cache = cacheManager.getCache("products");
        cache.put(product.getId(), saved);
        
        return saved;
    }
}
```

### 4.3. With Spring Cache

```java
@Service
public class ProductService {
    
    @CachePut(value = "products", key = "#product.id")
    @Transactional
    public Product createProduct(Product product) {
        return repository.save(product);
    }
    
    @CachePut(value = "products", key = "#product.id")
    @Transactional
    public Product updateProduct(Product product) {
        return repository.save(product);
    }
}
```

### 4.4. Custom Write-Through Cache

```java
public class WriteThroughCache<K, V> {
    
    private final Cache cache;
    private final BiConsumer<K, V> writer;
    
    public WriteThroughCache(Cache cache, BiConsumer<K, V> writer) {
        this.cache = cache;
        this.writer = writer;
    }
    
    @Transactional
    public void put(K key, V value) {
        // Write to database first
        writer.accept(key, value);
        
        // Then update cache
        cache.put(key, value);
    }
}

// Usage
@Service
public class ProductService {
    
    private final WriteThroughCache<Long, Product> cache;
    
    public ProductService(CacheManager cacheManager, ProductRepository repository) {
        this.cache = new WriteThroughCache<>(
            cacheManager.getCache("products"),
            (id, product) -> repository.save(product)
        );
    }
    
    public void updateProduct(Product product) {
        cache.put(product.getId(), product);
    }
}
```

### 4.5. Pros and Cons

**Pros:**
- Cache always consistent with database
- No stale data
- Reliable data durability

**Cons:**
- Write latency (2 operations)
- Cache failure impacts writes
- Unnecessary cache writes for rarely read data

---

## 5. Write-Behind (Write-Back)

### 5.1. Overview

Write to cache immediately, database asynchronously:
1. Write to cache
2. Return success
3. Cache writes to database asynchronously (batched)

### 5.2. Implementation

```java
@Service
public class WriteBehindService {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    private final Queue<Product> writeQueue = new ConcurrentLinkedQueue<>();
    
    public Product updateProduct(Product product) {
        // Write to cache immediately
        Cache cache = cacheManager.getCache("products");
        cache.put(product.getId(), product);
        
        // Queue for async database write
        writeQueue.offer(product);
        
        return product;
    }
    
    @Scheduled(fixedDelay = 5000)
    @Transactional
    public void flushToDatabase() {
        List<Product> batch = new ArrayList<>();
        Product product;
        
        // Drain queue
        while ((product = writeQueue.poll()) != null) {
            batch.add(product);
            
            if (batch.size() >= 100) {
                repository.saveAll(batch);
                batch.clear();
            }
        }
        
        // Save remaining
        if (!batch.isEmpty()) {
            repository.saveAll(batch);
        }
    }
}
```

### 5.3. Advanced Write-Behind

```java
@Component
public class WriteBehindCache {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private ProductRepository repository;
    
    private final BlockingQueue<Product> writeQueue = new LinkedBlockingQueue<>();
    private final ExecutorService executor = Executors.newFixedThreadPool(2);
    
    @PostConstruct
    public void init() {
        // Start background writer
        executor.submit(this::processWrites);
    }
    
    public void update(Product product) {
        // Write to cache immediately
        redisTemplate.opsForValue().set("product:" + product.getId(), product);
        
        // Queue for database write
        writeQueue.offer(product);
    }
    
    private void processWrites() {
        while (!Thread.interrupted()) {
            try {
                List<Product> batch = new ArrayList<>();
                
                // Wait for first item
                batch.add(writeQueue.take());
                
                // Drain additional items (up to 100)
                writeQueue.drainTo(batch, 99);
                
                // Batch write to database
                repository.saveAll(batch);
                
                log.info("Wrote {} products to database", batch.size());
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    @PreDestroy
    public void shutdown() {
        executor.shutdown();
    }
}
```

### 5.4. Pros and Cons

**Pros:**
- Fast writes (cache only)
- Reduced database load (batching)
- Better write performance

**Cons:**
- Risk of data loss (cache failure before DB write)
- Eventual consistency
- Complex implementation
- Requires reliable queue

---

## 6. Refresh-Ahead

### 6.1. Overview

Automatically refresh cache before expiration:
1. Cache tracks TTL
2. Before expiration, reload from database
3. Update cache with fresh data

### 6.2. Implementation

```java
@Configuration
public class RefreshAheadCacheConfig {
    
    @Bean
    public Caffeine<Object, Object> caffeineCacheBuilder() {
        return Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .refreshAfterWrite(8, TimeUnit.MINUTES)  // Refresh after 8 min
            .build(key -> loadFromDatabase(key));
    }
    
    private Object loadFromDatabase(Object key) {
        // Load fresh data from database
        return productRepository.findById((Long) key).orElseThrow();
    }
}
```

### 6.3. Custom Refresh-Ahead

```java
@Component
public class RefreshAheadCache {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    private final Map<Long, Instant> lastRefreshTime = new ConcurrentHashMap<>();
    
    public Product getProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        Product product = cache.get(id, Product.class);
        
        if (product != null) {
            // Check if refresh needed
            Instant lastRefresh = lastRefreshTime.get(id);
            if (lastRefresh != null && 
                Duration.between(lastRefresh, Instant.now()).toMinutes() > 8) {
                // Refresh asynchronously
                CompletableFuture.runAsync(() -> refreshCache(id));
            }
            return product;
        }
        
        // Cache miss - load and cache
        product = repository.findById(id).orElseThrow();
        cache.put(id, product);
        lastRefreshTime.put(id, Instant.now());
        
        return product;
    }
    
    private void refreshCache(Long id) {
        Product fresh = repository.findById(id).orElse(null);
        if (fresh != null) {
            Cache cache = cacheManager.getCache("products");
            cache.put(id, fresh);
            lastRefreshTime.put(id, Instant.now());
            log.info("Refreshed cache for product {}", id);
        }
    }
}
```

### 6.4. Pros and Cons

**Pros:**
- Reduced cache miss latency
- Always fresh data for hot keys
- Proactive cache warming

**Cons:**
- Unnecessary refreshes for cold keys
- Increased database load
- Complex implementation

---

## 7. Cache Invalidation Strategies

### 7.1. Time-Based (TTL)

```java
@Cacheable(value = "products")
public Product getProduct(Long id) {
    // Cached with configured TTL (e.g., 10 minutes)
    return repository.findById(id).orElseThrow();
}
```

**Configuration:**
```yaml
spring:
  cache:
    redis:
      time-to-live: 600000  # 10 minutes
```

### 7.2. Event-Based

```java
@Service
public class ProductService {
    
    @Cacheable("products")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    @CacheEvict(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        Product updated = repository.save(product);
        // Cache automatically invalidated
        return updated;
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearAllProducts() {
        // Invalidate entire cache
    }
}
```

### 7.3. Pub/Sub Invalidation (Distributed)

```java
@Service
public class CacheInvalidationService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private CacheManager cacheManager;
    
    // Publish invalidation event
    @CacheEvict(value = "products", key = "#id")
    public void invalidateProduct(Long id) {
        // Local cache evicted by @CacheEvict
        
        // Notify other instances
        redisTemplate.convertAndSend("cache:invalidate:products", id.toString());
    }
    
    // Subscribe to invalidation events
    @EventListener
    public void handleInvalidation(ProductUpdatedEvent event) {
        invalidateProduct(event.getProductId());
    }
}

@Component
public class CacheInvalidationListener implements MessageListener {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Override
    public void onMessage(Message message, byte[] pattern) {
        String channel = new String(message.getChannel());
        String body = new String(message.getBody());
        
        if (channel.equals("cache:invalidate:products")) {
            Long productId = Long.parseLong(body);
            Cache cache = cacheManager.getCache("products");
            cache.evict(productId);
            log.info("Invalidated product {} from cache", productId);
        }
    }
}
```

### 7.4. Manual Invalidation

```java
@Service
public class CacheManagementService {
    
    @Autowired
    private CacheManager cacheManager;
    
    public void evictCache(String cacheName, Object key) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.evict(key);
        }
    }
    
    public void evictAllCaches() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                cache.clear();
            }
        });
    }
}
```

---

## 8. Cache Warming

### 8.1. On Startup

```java
@Component
public class CacheWarmer {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private ProductRepository repository;
    
    @EventListener(ApplicationReadyEvent.class)
    public void warmCache() {
        log.info("Warming up product cache...");
        
        // Load popular products
        List<Product> popularProducts = repository.findPopular();
        popularProducts.forEach(product -> {
            productService.getProduct(product.getId());
        });
        
        log.info("Cache warmed with {} products", popularProducts.size());
    }
}
```

### 8.2. Scheduled Warming

```java
@Component
public class ScheduledCacheWarmer {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    @Scheduled(cron = "0 0 2 * * ?")  // 2 AM daily
    public void refreshCache() {
        log.info("Refreshing product cache...");
        
        Cache cache = cacheManager.getCache("products");
        
        // Load all products
        List<Product> products = repository.findAll();
        products.forEach(product -> {
            cache.put(product.getId(), product);
        });
        
        log.info("Refreshed cache with {} products", products.size());
    }
}
```

### 8.3. Selective Warming

```java
@Component
public class SelectiveCacheWarmer {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    @Scheduled(fixedRate = 3600000)  // Every hour
    public void warmHotKeys() {
        Cache cache = cacheManager.getCache("products");
        
        // Warm only frequently accessed products
        List<Long> hotProductIds = getHotProductIds();
        
        List<Product> hotProducts = repository.findAllById(hotProductIds);
        hotProducts.forEach(product -> {
            cache.put(product.getId(), product);
        });
        
        log.info("Warmed {} hot products", hotProducts.size());
    }
    
    private List<Long> getHotProductIds() {
        // Get IDs from analytics or access logs
        return Arrays.asList(1L, 2L, 5L, 10L);
    }
}
```

---

## 9. Cache Stampede Prevention

### 9.1. Synchronized Loading

```java
@Cacheable(value = "products", sync = true)
public Product getProduct(Long id) {
    // Only one thread loads data on cache miss
    return repository.findById(id).orElseThrow();
}
```

### 9.2. Lock-Based

```java
@Service
public class ProductService {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    private final ConcurrentHashMap<Long, Lock> locks = new ConcurrentHashMap<>();
    
    public Product getProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        Product product = cache.get(id, Product.class);
        
        if (product != null) {
            return product;
        }
        
        // Acquire lock for this ID
        Lock lock = locks.computeIfAbsent(id, k -> new ReentrantLock());
        lock.lock();
        try {
            // Double-check cache
            product = cache.get(id, Product.class);
            if (product != null) {
                return product;
            }
            
            // Load from database
            product = repository.findById(id).orElseThrow();
            cache.put(id, product);
            
            return product;
        } finally {
            lock.unlock();
            locks.remove(id);
        }
    }
}
```

### 9.3. Probabilistic Early Expiration

```java
@Component
public class ProbabilisticCache {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    private final Map<Long, Instant> cacheTime = new ConcurrentHashMap<>();
    private static final int TTL_MINUTES = 10;
    private static final double BETA = 1.0;
    
    public Product getProduct(Long id) {
        Cache cache = cacheManager.getCache("products");
        Product product = cache.get(id, Product.class);
        
        if (product != null) {
            // Probabilistic early expiration
            Instant cached = cacheTime.get(id);
            if (cached != null && shouldRefresh(cached)) {
                product = refreshCache(id);
            }
            return product;
        }
        
        return refreshCache(id);
    }
    
    private boolean shouldRefresh(Instant cachedTime) {
        long age = Duration.between(cachedTime, Instant.now()).toSeconds();
        long ttl = TTL_MINUTES * 60;
        
        // XFetch algorithm
        double delta = age * BETA * Math.log(Math.random());
        return delta >= (ttl - age);
    }
    
    private Product refreshCache(Long id) {
        Product product = repository.findById(id).orElseThrow();
        Cache cache = cacheManager.getCache("products");
        cache.put(id, product);
        cacheTime.put(id, Instant.now());
        return product;
    }
}
```

---

## 10. Monitoring and Metrics

### 10.1. Cache Hit Ratio

```java
@Component
public class CacheMetrics {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Scheduled(fixedRate = 60000)
    public void logCacheStats() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                CacheStats stats = nativeCache.stats();
                double hitRate = stats.hitRate() * 100;
                
                log.info("Cache '{}': Hit Rate={:.2f}%, Hits={}, Misses={}, Evictions={}",
                    cacheName, hitRate, stats.hitCount(), stats.missCount(), 
                    stats.evictionCount());
            }
        });
    }
}
```

### 10.2. Custom Metrics

```java
@Component
public class CacheMonitoring {
    
    private final MeterRegistry meterRegistry;
    private final CacheManager cacheManager;
    
    public CacheMonitoring(MeterRegistry meterRegistry, CacheManager cacheManager) {
        this.meterRegistry = meterRegistry;
        this.cacheManager = cacheManager;
        
        registerMetrics();
    }
    
    private void registerMetrics() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                // Hit count
                Gauge.builder("cache.hits", nativeCache, c -> c.stats().hitCount())
                    .tag("cache", cacheName)
                    .register(meterRegistry);
                
                // Miss count
                Gauge.builder("cache.misses", nativeCache, c -> c.stats().missCount())
                    .tag("cache", cacheName)
                    .register(meterRegistry);
                
                // Size
                Gauge.builder("cache.size", nativeCache, c -> c.estimatedSize())
                    .tag("cache", cacheName)
                    .register(meterRegistry);
            }
        });
    }
}
```

---

## 11. Best Practices

1. **Choose appropriate strategy** - Based on read/write patterns
2. **Use cache-aside for most cases** - Simple and reliable
3. **Prevent cache stampede** - Use sync=true or locks
4. **Implement cache warming** - For critical data
5. **Monitor hit ratio** - Target >80% for effective caching
6. **Set appropriate TTL** - Balance freshness and performance
7. **Handle cache failures** - Graceful degradation
8. **Use event-based invalidation** - For consistency
9. **Batch writes in write-behind** - Reduce database load
10. **Test invalidation logic** - Prevent stale data

---

## 12. Interview Questions

**Q1: What is cache-aside pattern?**
**A:** Application checks cache, loads from DB on miss, stores in cache.

**Q2: Cache-aside vs read-through?**
**A:** Cache-aside: App manages cache. Read-through: Cache loads automatically.

**Q3: What is write-through caching?**
**A:** Write to cache and database simultaneously for consistency.

**Q4: What is write-behind caching?**
**A:** Write to cache immediately, database asynchronously (batched).

**Q5: What is refresh-ahead strategy?**
**A:** Automatically refresh cache before expiration to reduce latency.

**Q6: What is cache stampede?**
**A:** Multiple requests simultaneously loading same data on cache miss.

**Q7: How to prevent cache stampede?**
**A:** Use `sync=true`, locks, or probabilistic early expiration.

**Q8: What is cache warming?**
**A:** Preloading cache with frequently accessed data.

**Q9: When to use write-behind caching?**
**A:** High write throughput, tolerate eventual consistency, need batching.

**Q10: Time-based vs event-based invalidation?**
**A:** Time-based: TTL expiration. Event-based: Invalidate on update/delete.

**Q11: What is cache hit ratio?**
**A:** Percentage of requests served from cache. Formula: hits / (hits + misses).

**Q12: How to invalidate cache in distributed system?**
**A:** Use Redis pub/sub to broadcast invalidation events.

**Q13: What is TTL?**
**A:** Time-to-live: Duration before cache entry expires.

**Q14: What is cache penetration?**
**A:** Repeated requests for non-existent data bypassing cache.

**Q15: How to handle cache penetration?**
**A:** Cache null values with short TTL or use bloom filter.

**Q16: What is cache avalanche?**
**A:** Many cache entries expire simultaneously, overwhelming database.

**Q17: How to prevent cache avalanche?**
**A:** Randomize TTL, use refresh-ahead, implement circuit breaker.

**Q18: What is hot key problem?**
**A:** Single key accessed very frequently, causing bottleneck.

**Q19: How to solve hot key problem?**
**A:** Replicate key, use local cache (L1), shard key.

**Q20: When not to use caching?**
**A:** Highly volatile data, low read frequency, strong consistency required.

---

## 13. Summary

Cache strategies optimize performance and consistency: cache-aside (most common), read-through (automatic loading), write-through (immediate consistency), write-behind (high write throughput), refresh-ahead (proactive refresh). Choose based on read/write patterns. Prevent cache stampede with synchronization. Implement cache warming and monitoring. Use event-based invalidation for consistency.

---

**Next:** Best Practices â†’
