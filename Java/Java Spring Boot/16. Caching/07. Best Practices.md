# Caching Best Practices - Complete Guide

---

## 1. Introduction

Effective caching requires following best practices to ensure performance, reliability, and maintainability. This guide covers production-ready caching patterns.

### Key Principles
- Cache only what's needed
- Set appropriate TTL
- Monitor and measure
- Handle failures gracefully
- Keep cache simple

---

## 2. What to Cache

### 2.1. Good Candidates

✅ **Static or Rarely Changing Data**
```java
@Cacheable("countries")
public List<Country> getAllCountries() {
    // Countries rarely change
    return countryRepository.findAll();
}
```

✅ **Expensive Computations**
```java
@Cacheable(value = "recommendations", key = "#userId")
public List<Product> getRecommendations(Long userId) {
    // Complex ML-based recommendations
    return recommendationEngine.compute(userId);
}
```

✅ **Frequently Accessed Data**
```java
@Cacheable("popularProducts")
public List<Product> getPopularProducts() {
    // Accessed thousands of times per minute
    return productRepository.findTop100ByOrderByViewsDesc();
}
```

✅ **External API Calls**
```java
@Cacheable(value = "weatherData", key = "#city")
public WeatherData getWeather(String city) {
    // Expensive external API call
    return weatherApiClient.fetchWeather(city);
}
```

### 2.2. Poor Candidates

❌ **User-Specific Sensitive Data**
```java
// BAD: Don't cache sensitive personal data
@Cacheable("userCreditCards")
public List<CreditCard> getUserCreditCards(Long userId) {
    return creditCardRepository.findByUserId(userId);
}
```

❌ **Highly Volatile Data**
```java
// BAD: Stock prices change every second
@Cacheable("stockPrices")
public BigDecimal getStockPrice(String symbol) {
    return stockExchange.getCurrentPrice(symbol);
}
```

❌ **Large Objects**
```java
// BAD: Caching 100MB files
@Cacheable("files")
public byte[] getLargeFile(String fileId) {
    return fileStorage.read(fileId);
}
```

---

## 3. Cache Key Design

### 3.1. Simple and Consistent

```java
// GOOD: Simple, predictable keys
@Cacheable(value = "products", key = "#id")
public Product getProduct(Long id) {
    return repository.findById(id).orElseThrow();
}

// GOOD: Composite key
@Cacheable(value = "products", key = "#id + '_' + #locale")
public Product getProduct(Long id, String locale) {
    return repository.findByIdAndLocale(id, locale);
}
```

### 3.2. Avoid Complex Keys

```java
// BAD: Complex, unpredictable key
@Cacheable(value = "data", key = "#request.hashCode()")
public Data getData(ComplexRequest request) {
    return service.process(request);
}

// GOOD: Extract stable fields
@Cacheable(value = "data", key = "#request.id + '_' + #request.type")
public Data getData(ComplexRequest request) {
    return service.process(request);
}
```

### 3.3. Custom Key Generator

```java
@Bean("stableKeyGenerator")
public KeyGenerator stableKeyGenerator() {
    return (target, method, params) -> {
        StringBuilder key = new StringBuilder();
        key.append(target.getClass().getSimpleName());
        key.append("_").append(method.getName());
        
        for (Object param : params) {
            if (param instanceof Identifiable) {
                key.append("_").append(((Identifiable) param).getId());
            } else {
                key.append("_").append(param.toString());
            }
        }
        
        return key.toString();
    };
}

@Cacheable(value = "data", keyGenerator = "stableKeyGenerator")
public Data getData(Request request) {
    return service.process(request);
}
```

---

## 4. TTL Configuration

### 4.1. Set Appropriate TTL

```java
// Static data: Long TTL (hours/days)
@Bean
public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
    Map<String, RedisCacheConfiguration> configs = new HashMap<>();
    
    // Countries: 24 hours (rarely change)
    configs.put("countries",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(24)));
    
    // Products: 1 hour (moderate change)
    configs.put("products",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1)));
    
    // Session: 30 minutes (user-specific)
    configs.put("sessions",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30)));
    
    // Real-time data: 1 minute (frequently changing)
    configs.put("stats",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(1)));
    
    return RedisCacheManager.builder(factory)
        .withInitialCacheConfigurations(configs)
        .build();
}
```

### 4.2. Avoid Common TTL Mistakes

```java
// BAD: No TTL (cache grows indefinitely)
Caffeine.newBuilder()
    .maximumSize(1000)
    .build();

// GOOD: Always set TTL or size limit
Caffeine.newBuilder()
    .maximumSize(1000)
    .expireAfterWrite(10, TimeUnit.MINUTES)
    .build();

// BAD: TTL too long for volatile data
@Cacheable(value = "liveScores")  // TTL = 24 hours
public Score getLiveScore(String matchId) {
    return scoreApi.getScore(matchId);
}

// GOOD: Short TTL for volatile data
configs.put("liveScores",
    RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofSeconds(30)));
```

---

## 5. Cache Size Management

### 5.1. Set Size Limits

```java
@Bean
public Caffeine<Object, Object> caffeineCacheBuilder() {
    return Caffeine.newBuilder()
        .maximumSize(10000)  // Limit entry count
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .recordStats()
        .build();
}
```

### 5.2. Weight-Based Eviction

```java
@Bean
public Caffeine<Object, Object> caffeineCacheBuilder() {
    return Caffeine.newBuilder()
        .maximumWeight(100_000)  // 100KB total
        .weigher((key, value) -> {
            if (value instanceof String) {
                return ((String) value).length();
            }
            // Estimate size
            return 100;
        })
        .build();
}
```

### 5.3. Redis Memory Limits

```properties
# redis.conf
maxmemory 2gb
maxmemory-policy allkeys-lru
```

---

## 6. Error Handling

### 6.1. Graceful Degradation

```java
@Service
public class ResilientProductService {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    private ProductRepository repository;
    
    public Product getProduct(Long id) {
        try {
            // Try cache
            Cache cache = cacheManager.getCache("products");
            Product product = cache.get(id, Product.class);
            
            if (product != null) {
                return product;
            }
        } catch (Exception e) {
            log.warn("Cache error, falling back to database", e);
        }
        
        // Fallback to database
        return repository.findById(id).orElseThrow();
    }
}
```

### 6.2. Circuit Breaker

```java
@Service
public class CacheServiceWithCircuitBreaker {
    
    private final CircuitBreaker circuitBreaker;
    
    public CacheServiceWithCircuitBreaker() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .build();
        
        this.circuitBreaker = CircuitBreaker.of("cache", config);
    }
    
    public Product getFromCache(Long id) {
        return circuitBreaker.executeSupplier(() -> {
            Cache cache = cacheManager.getCache("products");
            return cache.get(id, Product.class);
        });
    }
}
```

### 6.3. Timeout Configuration

```yaml
spring:
  data:
    redis:
      timeout: 2000ms
      connect-timeout: 2000ms
      lettuce:
        shutdown-timeout: 100ms
```

---

## 7. Cache Invalidation

### 7.1. Proactive Invalidation

```java
@Service
public class ProductService {
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    @CachePut(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        return repository.save(product);
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        repository.deleteById(id);
    }
    
    // Invalidate related caches
    @Caching(evict = {
        @CacheEvict(value = "products", key = "#id"),
        @CacheEvict(value = "productsByCategory", key = "#categoryId"),
        @CacheEvict(value = "popularProducts", allEntries = true)
    })
    public void deleteProduct(Long id, Long categoryId) {
        repository.deleteById(id);
    }
}
```

### 7.2. Scheduled Cleanup

```java
@Component
public class CacheCleanup {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Scheduled(cron = "0 0 2 * * ?")  // 2 AM daily
    public void clearStaleData() {
        log.info("Clearing stale cache data...");
        
        // Clear specific caches
        Cache cache = cacheManager.getCache("temporaryData");
        if (cache != null) {
            cache.clear();
        }
    }
}
```

---

## 8. Monitoring and Metrics

### 8.1. Track Hit Ratio

```java
@Component
public class CacheMetrics {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private CacheManager cacheManager;
    
    @PostConstruct
    public void registerMetrics() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                // Hit rate
                Gauge.builder("cache.hit.rate", nativeCache, 
                    c -> c.stats().hitRate() * 100)
                    .tag("cache", cacheName)
                    .description("Cache hit rate percentage")
                    .register(meterRegistry);
                
                // Size
                Gauge.builder("cache.size", nativeCache, 
                    c -> c.estimatedSize())
                    .tag("cache", cacheName)
                    .register(meterRegistry);
            }
        });
    }
}
```

### 8.2. Alert on Low Hit Ratio

```java
@Component
public class CacheHealthMonitor {
    
    @Scheduled(fixedRate = 300000)  // Every 5 minutes
    public void checkCacheHealth() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                CacheStats stats = nativeCache.stats();
                double hitRate = stats.hitRate();
                
                if (hitRate < 0.7) {  // Alert if below 70%
                    log.warn("Low cache hit rate for '{}': {:.2f}%", 
                        cacheName, hitRate * 100);
                    // Send alert to monitoring system
                }
            }
        });
    }
}
```

---

## 9. Testing

### 9.1. Unit Testing with Cache

```java
@SpringBootTest
@EnableCaching
class ProductServiceTest {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private CacheManager cacheManager;
    
    @MockBean
    private ProductRepository productRepository;
    
    @Test
    void testCaching() {
        Product product = new Product(1L, "Test Product");
        when(productRepository.findById(1L))
            .thenReturn(Optional.of(product));
        
        // First call - cache miss
        Product result1 = productService.getProduct(1L);
        verify(productRepository, times(1)).findById(1L);
        
        // Second call - cache hit
        Product result2 = productService.getProduct(1L);
        verify(productRepository, times(1)).findById(1L);  // Still 1
        
        assertSame(result1, result2);
    }
    
    @Test
    void testCacheEviction() {
        Product product = new Product(1L, "Test Product");
        when(productRepository.save(any())).thenReturn(product);
        
        // Update should evict cache
        productService.updateProduct(product);
        
        Cache cache = cacheManager.getCache("products");
        assertNull(cache.get(1L));
    }
    
    @BeforeEach
    void clearCache() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                cache.clear();
            }
        });
    }
}
```

### 9.2. Integration Testing

```java
@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
class CacheIntegrationTest {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Test
    void testCacheWithRealDatabase() {
        Product product = new Product(null, "Test Product");
        product = productRepository.save(product);
        
        Long id = product.getId();
        
        // Warm cache
        Product cached = productService.getProduct(id);
        
        // Modify in database directly
        productRepository.updatePrice(id, 99.99);
        
        // Should still return cached value
        Product fromCache = productService.getProduct(id);
        assertNotEquals(99.99, fromCache.getPrice());
        
        // Evict cache
        productService.updateProduct(cached);
        
        // Should return fresh value
        Product fresh = productService.getProduct(id);
        assertEquals(99.99, fresh.getPrice());
    }
}
```

---

## 10. Security

### 10.1. Secure Redis Connection

```yaml
spring:
  data:
    redis:
      host: redis.example.com
      port: 6379
      password: ${REDIS_PASSWORD}
      ssl:
        enabled: true
```

### 10.2. Don't Cache Sensitive Data

```java
// BAD: Caching passwords
@Cacheable("passwords")
public String getUserPassword(Long userId) {
    return userRepository.getPassword(userId);
}

// GOOD: Never cache sensitive data
public String getUserPassword(Long userId) {
    return userRepository.getPassword(userId);
}
```

### 10.3. Cache Key Sanitization

```java
@Bean("sanitizedKeyGenerator")
public KeyGenerator sanitizedKeyGenerator() {
    return (target, method, params) -> {
        StringBuilder key = new StringBuilder();
        key.append(method.getName());
        
        for (Object param : params) {
            // Sanitize to prevent injection
            String sanitized = param.toString()
                .replaceAll("[^a-zA-Z0-9_-]", "_");
            key.append("_").append(sanitized);
        }
        
        return key.toString();
    };
}
```

---

## 11. Performance Optimization

### 11.1. Use Local Cache for Hot Data

```java
@Configuration
public class TwoLevelCacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        // L1: Local Caffeine
        CaffeineCacheManager l1 = new CaffeineCacheManager();
        l1.setCaffeine(Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(1, TimeUnit.MINUTES));
        
        // L2: Distributed Redis
        RedisCacheManager l2 = RedisCacheManager.builder(factory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)))
            .build();
        
        return new CompositeCacheManager(l1, l2);
    }
}
```

### 11.2. Async Cache Population

```java
@Service
public class AsyncCacheService {
    
    @Async
    @CachePut(value = "products", key = "#product.id")
    public Product cacheProduct(Product product) {
        return product;
    }
    
    public void warmCacheAsync(List<Product> products) {
        products.forEach(this::cacheProduct);
    }
}
```

### 11.3. Batch Operations

```java
@Service
public class BatchCacheService {
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    public void cacheProducts(List<Product> products) {
        // Batch write to Redis
        redisTemplate.executePipelined(new SessionCallback<Object>() {
            @Override
            public Object execute(RedisOperations operations) {
                products.forEach(product -> {
                    operations.opsForValue().set(
                        "product:" + product.getId(),
                        product,
                        10, TimeUnit.MINUTES
                    );
                });
                return null;
            }
        });
    }
}
```

---

## 12. Common Pitfalls

### 12.1. Caching Mutable Objects

```java
// BAD: Caching mutable object
@Cacheable("users")
public User getUser(Long id) {
    return userRepository.findById(id).orElseThrow();
}

// Caller modifies cached object
User user = userService.getUser(1L);
user.setName("Modified");  // Affects cache!

// GOOD: Return defensive copy
@Cacheable("users")
public User getUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return new User(user);  // Defensive copy
}
```

### 12.2. Self-Invocation

```java
// BAD: Self-invocation doesn't trigger cache
@Service
public class ProductService {
    
    @Cacheable("products")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    public List<Product> getProducts(List<Long> ids) {
        // Won't use cache (self-invocation)
        return ids.stream()
            .map(this::getProduct)
            .collect(Collectors.toList());
    }
}

// GOOD: Inject self-reference
@Service
public class ProductService {
    
    @Autowired
    private ProductService self;
    
    @Cacheable("products")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
    
    public List<Product> getProducts(List<Long> ids) {
        // Uses cache
        return ids.stream()
            .map(id -> self.getProduct(id))
            .collect(Collectors.toList());
    }
}
```

### 12.3. Not Handling Null Values

```java
// BAD: Repeated DB queries for non-existent data
@Cacheable("products")
public Product getProduct(Long id) {
    return repository.findById(id).orElse(null);
}

// GOOD: Cache null with unless
@Cacheable(value = "products", unless = "#result == null")
public Product getProduct(Long id) {
    return repository.findById(id).orElse(null);
}

// OR: Use Optional
@Cacheable("products")
public Optional<Product> getProduct(Long id) {
    return repository.findById(id);
}
```

---

## 13. Documentation

### 13.1. Document Cache Strategy

```java
/**
 * Retrieves product by ID.
 * 
 * <p>Caching Strategy:
 * - Cache Name: products
 * - Key: Product ID
 * - TTL: 1 hour
 * - Invalidation: On update/delete
 * - Provider: Redis (production), Caffeine (dev)
 * 
 * @param id Product ID
 * @return Product
 * @throws ProductNotFoundException if not found
 */
@Cacheable(value = "products", key = "#id")
public Product getProduct(Long id) {
    return repository.findById(id)
        .orElseThrow(() -> new ProductNotFoundException(id));
}
```

### 13.2. Cache Configuration Documentation

```yaml
# Cache Configuration
# 
# Products Cache:
#   - Purpose: Reduce database load for product reads
#   - TTL: 1 hour (products don't change frequently)
#   - Size: 10,000 entries max
#   - Eviction: LRU
#
# Users Cache:
#   - Purpose: Fast user profile lookups
#   - TTL: 30 minutes (moderate change frequency)
#   - Size: 5,000 entries max
#
spring:
  cache:
    type: redis
```

---

## 14. Summary Checklist

✅ **Cache Design**
- [ ] Cache only necessary data
- [ ] Set appropriate TTL for each cache
- [ ] Configure size limits
- [ ] Use meaningful cache keys
- [ ] Document caching strategy

✅ **Reliability**
- [ ] Handle cache failures gracefully
- [ ] Implement circuit breaker
- [ ] Configure timeouts
- [ ] Test cache behavior

✅ **Performance**
- [ ] Monitor hit ratio (target >80%)
- [ ] Use multi-level caching if needed
- [ ] Implement cache warming
- [ ] Optimize serialization

✅ **Maintenance**
- [ ] Schedule cache cleanup
- [ ] Implement proper invalidation
- [ ] Log cache statistics
- [ ] Alert on anomalies

✅ **Security**
- [ ] Don't cache sensitive data
- [ ] Secure Redis connections
- [ ] Sanitize cache keys
- [ ] Use authentication

---

## 15. Interview Questions

**Q1: What are best practices for cache TTL?**
**A:** Set based on data volatility: static (hours/days), moderate (minutes/hour), volatile (seconds/minutes).

**Q2: How to handle cache failures?**
**A:** Graceful degradation - fallback to database, circuit breaker, timeouts.

**Q3: What is a good cache hit ratio?**
**A:** >80% indicates effective caching. <70% may need adjustment.

**Q4: Should you cache sensitive data?**
**A:** No. Never cache passwords, credit cards, PII without encryption.

**Q5: What is cache stampede and how to prevent it?**
**A:** Multiple requests loading same data on miss. Prevent with `sync=true` or locks.

**Q6: How to test caching?**
**A:** Verify cache hit/miss, invalidation, TTL expiration in unit/integration tests.

**Q7: What is self-invocation problem?**
**A:** Calling @Cacheable method from same class bypasses cache. Fix: inject self or use separate bean.

**Q8: How to monitor cache health?**
**A:** Track hit ratio, memory usage, latency, evictions. Alert on low hit rate.

**Q9: Should you cache mutable objects?**
**A:** No, or return defensive copies to prevent cache corruption.

**Q10: How to size cache?**
**A:** Based on: available memory, data size, access patterns. Monitor and adjust.

**Q11: What is two-level caching?**
**A:** L1 (local Caffeine) for hot data, L2 (distributed Redis) for shared cache.

**Q12: How to invalidate distributed cache?**
**A:** Use Redis pub/sub to broadcast invalidation events to all instances.

**Q13: When to use cache-aside vs write-through?**
**A:** Cache-aside: Read-heavy, lazy loading. Write-through: Strong consistency needed.

**Q14: How to handle null values?**
**A:** Use `unless = "#result == null"` or cache Optional.

**Q15: What is cache key collision?**
**A:** Different data mapped to same key. Prevent with unique, descriptive keys.

**Q16: How to cache method with multiple parameters?**
**A:** Composite key: `#param1 + '_' + #param2` or custom KeyGenerator.

**Q17: Should you cache in development?**
**A:** Use simple in-memory cache (Caffeine) for dev, Redis for prod.

**Q18: How to warm cache on startup?**
**A:** Use @EventListener(ApplicationReadyEvent) to preload critical data.

**Q19: What is cache penetration?**
**A:** Requests for non-existent data bypassing cache. Cache null values with short TTL.

**Q20: How to secure Redis?**
**A:** Password authentication, TLS/SSL, network isolation, disable dangerous commands.

---

## 16. Summary

Follow best practices: cache appropriate data, set TTL based on volatility, monitor hit ratio (>80%), handle failures gracefully, invalidate proactively, test thoroughly. Document cache strategy. Use multi-level caching for performance. Never cache sensitive data. Monitor and alert on cache health.

---

**End of Best Practices Guide**
