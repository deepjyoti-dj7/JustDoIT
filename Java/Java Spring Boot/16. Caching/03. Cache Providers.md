# Cache Providers - Complete Guide

---

## 1. Introduction to Cache Providers

Spring Boot supports multiple cache providers through its cache abstraction. Each provider has different characteristics, performance profiles, and use cases.

### Supported Providers
- **Simple** (ConcurrentHashMap) - Default, in-memory
- **Caffeine** - High-performance, in-memory
- **EhCache** - Feature-rich, in-memory/disk
- **Redis** - Distributed, in-memory data store
- **Hazelcast** - Distributed, in-memory data grid
- **Memcached** - Distributed, in-memory cache
- **Couchbase** - Distributed NoSQL database
- **JCache (JSR-107)** - Standard Java caching API

---

## 2. Simple Cache (Default)

### 2.1. Overview
- Default provider if no other is configured
- Uses `ConcurrentHashMap`
- In-memory, single-instance only
- No eviction policy
- Good for development/testing

### 2.2. Configuration

```yaml
spring:
  cache:
    type: simple
```

### 2.3. Programmatic Configuration

```java
@Configuration
@EnableCaching
public class SimpleCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(
            new ConcurrentMapCache("products"),
            new ConcurrentMapCache("users"),
            new ConcurrentMapCache("orders")
        ));
        return cacheManager;
    }
}
```

---

## 3. Caffeine Cache

### 3.1. Overview
- High-performance, in-memory cache
- Written by Google's Guava cache author
- Features: size-based eviction, time-based expiration, stats
- **Recommended** for single-instance applications

### 3.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
```

### 3.3. Configuration

```yaml
spring:
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000,expireAfterWrite=10m,recordStats
    cache-names:
      - products
      - users
      - orders
```

### 3.4. Programmatic Configuration

```java
@Configuration
@EnableCaching
public class CaffeineCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products", "users", "orders");
        cacheManager.setCaffeine(caffeineCacheBuilder());
        return cacheManager;
    }
    
    @Bean
    public Caffeine<Object, Object> caffeineCacheBuilder() {
        return Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .recordStats();
    }
}
```

### 3.5. Custom Cache Configuration

```java
@Configuration
public class CustomCaffeineCacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        
        // Different configurations for different caches
        cacheManager.registerCustomCache("products", 
            Caffeine.newBuilder()
                .maximumSize(5000)
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .build());
        
        cacheManager.registerCustomCache("users",
            Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterAccess(10, TimeUnit.MINUTES)
                .build());
        
        cacheManager.registerCustomCache("sessions",
            Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build());
        
        return cacheManager;
    }
}
```

### 3.6. Caffeine Features

```java
Caffeine.newBuilder()
    .initialCapacity(100)                          // Initial size
    .maximumSize(1000)                             // Max entries
    .maximumWeight(10000)                          // Max weight
    .weigher((key, value) -> value.toString().length()) // Custom weigher
    .expireAfterWrite(10, TimeUnit.MINUTES)        // Write expiration
    .expireAfterAccess(5, TimeUnit.MINUTES)        // Access expiration
    .refreshAfterWrite(1, TimeUnit.MINUTES)        // Auto-refresh
    .weakKeys()                                     // Weak reference keys
    .weakValues()                                   // Weak reference values
    .softValues()                                   // Soft reference values
    .removalListener((key, value, cause) -> {      // Removal listener
        log.info("Removed: {} - {}", key, cause);
    })
    .recordStats()                                  // Enable statistics
    .build();
```

---

## 4. Redis Cache

### 4.1. Overview
- Distributed, in-memory data store
- Supports persistence
- Pub/Sub messaging
- High availability with replication
- **Recommended** for distributed applications

### 4.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 4.3. Configuration

```yaml
spring:
  cache:
    type: redis
    redis:
      time-to-live: 600000  # 10 minutes in milliseconds
      cache-null-values: false
      key-prefix: "myapp::"
      use-key-prefix: true
  
  data:
    redis:
      host: localhost
      port: 6379
      password: ${REDIS_PASSWORD}
      database: 0
      timeout: 2000
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1ms
```

### 4.4. Programmatic Configuration

```java
@Configuration
@EnableCaching
public class RedisCacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(
                    RedisSerializationContext.SerializationPair.fromSerializer(
                        new StringRedisSerializer()))
                .serializeValuesWith(
                    RedisSerializationContext.SerializationPair.fromSerializer(
                        new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues();
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultConfig)
                .build();
    }
}
```

### 4.5. Custom Cache Configurations

```java
@Bean
public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
    // Default configuration
    RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10));
    
    // Custom configurations per cache
    Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
    
    cacheConfigurations.put("products",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1))
            .prefixCacheNameWith("product::"));
    
    cacheConfigurations.put("users",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30)));
    
    cacheConfigurations.put("sessions",
        RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(24)));
    
    return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(defaultConfig)
            .withInitialCacheConfigurations(cacheConfigurations)
            .transactionAware()
            .build();
}
```

### 4.6. Custom Serialization

```java
@Bean
public RedisCacheConfiguration redisCacheConfiguration() {
    Jackson2JsonRedisSerializer<Object> serializer = 
        new Jackson2JsonRedisSerializer<>(Object.class);
    
    ObjectMapper mapper = new ObjectMapper();
    mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    mapper.activateDefaultTyping(
        mapper.getPolymorphicTypeValidator(),
        ObjectMapper.DefaultTyping.NON_FINAL,
        JsonTypeInfo.As.PROPERTY);
    
    serializer.setObjectMapper(mapper);
    
    return RedisCacheConfiguration.defaultCacheConfig()
            .serializeKeysWith(
                RedisSerializationContext.SerializationPair.fromSerializer(
                    new StringRedisSerializer()))
            .serializeValuesWith(
                RedisSerializationContext.SerializationPair.fromSerializer(serializer))
            .entryTtl(Duration.ofMinutes(10));
}
```

---

## 5. EhCache

### 5.1. Overview
- Feature-rich Java cache
- In-memory and disk storage
- Supports clustering
- JCache (JSR-107) compliant

### 5.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
</dependency>
```

### 5.3. Configuration

```yaml
spring:
  cache:
    type: jcache
    jcache:
      config: classpath:ehcache.xml
```

### 5.4. ehcache.xml

```xml
<config xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
        xmlns='http://www.ehcache.org/v3'
        xsi:schemaLocation="http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd">
    
    <cache alias="products">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.model.Product</value-type>
        <expiry>
            <ttl unit="minutes">10</ttl>
        </expiry>
        <resources>
            <heap unit="entries">1000</heap>
            <offheap unit="MB">10</offheap>
        </resources>
    </cache>
    
    <cache alias="users">
        <key-type>java.lang.Long</key-type>
        <value-type>com.example.model.User</value-type>
        <expiry>
            <ttl unit="minutes">30</ttl>
        </expiry>
        <resources>
            <heap unit="entries">500</heap>
        </resources>
    </cache>
    
    <cache-template name="defaultTemplate">
        <expiry>
            <ttl unit="minutes">5</ttl>
        </expiry>
        <resources>
            <heap unit="entries">100</heap>
        </resources>
    </cache-template>
</config>
```

### 5.5. Programmatic Configuration

```java
@Configuration
@EnableCaching
public class EhCacheConfig {
    
    @Bean
    public JCacheCacheManager cacheManager() {
        return new JCacheCacheManager(cacheManager());
    }
    
    @Bean(destroyMethod = "close")
    public javax.cache.CacheManager cacheManager() {
        CachingProvider provider = Caching.getCachingProvider();
        return provider.getCacheManager(
            getClass().getResource("/ehcache.xml").toURI(),
            getClass().getClassLoader());
    }
}
```

---

## 6. Hazelcast

### 6.1. Overview
- Distributed in-memory data grid
- Automatic clustering
- Replication and partitioning
- High availability

### 6.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-spring</artifactId>
</dependency>
```

### 6.3. Configuration

```yaml
spring:
  cache:
    type: hazelcast
```

### 6.4. Programmatic Configuration

```java
@Configuration
@EnableCaching
public class HazelcastCacheConfig {
    
    @Bean
    public Config hazelcastConfig() {
        Config config = new Config();
        config.setInstanceName("hazelcast-instance");
        
        // Configure cache
        MapConfig mapConfig = new MapConfig();
        mapConfig.setName("products");
        mapConfig.setTimeToLiveSeconds(600); // 10 minutes
        mapConfig.setMaxIdleSeconds(300);    // 5 minutes
        mapConfig.setEvictionConfig(new EvictionConfig()
            .setSize(1000)
            .setMaxSizePolicy(MaxSizePolicy.PER_NODE)
            .setEvictionPolicy(EvictionPolicy.LRU));
        
        config.addMapConfig(mapConfig);
        
        return config;
    }
    
    @Bean
    public HazelcastInstance hazelcastInstance(Config config) {
        return Hazelcast.newHazelcastInstance(config);
    }
}
```

---

## 7. Comparing Cache Providers

### 7.1. Feature Comparison

| Feature              | Caffeine | Redis    | EhCache  | Hazelcast |
|----------------------|----------|----------|----------|-----------|
| **In-Memory**        | ✅       | ✅       | ✅       | ✅        |
| **Distributed**      | ❌       | ✅       | ✅       | ✅        |
| **Persistence**      | ❌       | ✅       | ✅       | ✅        |
| **Clustering**       | ❌       | ✅       | ✅       | ✅        |
| **Eviction Policies**| ✅       | ✅       | ✅       | ✅        |
| **Statistics**       | ✅       | ✅       | ✅       | ✅        |
| **TTL/TTI**          | ✅       | ✅       | ✅       | ✅        |
| **Async Operations** | ✅       | ✅       | ✅       | ✅        |
| **Spring Boot Support** | ✅    | ✅       | ✅       | ✅        |

### 7.2. Performance Comparison

| Provider  | Read Speed | Write Speed | Memory | Network | Use Case                    |
|-----------|------------|-------------|--------|---------|------------------------------|
| Caffeine  | Fastest    | Fastest     | Low    | None    | Single instance              |
| Redis     | Fast       | Fast        | Medium | Yes     | Distributed, shared cache    |
| EhCache   | Fast       | Fast        | Medium | Yes     | Enterprise, complex policies |
| Hazelcast | Fast       | Fast        | Medium | Yes     | Distributed computing        |

### 7.3. When to Use

**Caffeine:**
- Single-instance applications
- Maximum performance needed
- No sharing between instances required
- Development/testing

**Redis:**
- Microservices architecture
- Session sharing across instances
- Pub/Sub messaging needed
- Persistence required

**EhCache:**
- Enterprise applications
- Complex eviction policies
- Disk overflow needed
- JCache compliance required

**Hazelcast:**
- Distributed computing
- In-memory data grid
- High availability clustering
- Complex data structures

---

## 8. Multi-Level Caching

### 8.1. L1 (Local) + L2 (Distributed)

```java
@Configuration
public class MultiLevelCacheConfig {
    
    @Bean
    @Primary
    public CacheManager cacheManager(
        CacheManager caffeineCacheManager,
        CacheManager redisCacheManager
    ) {
        return new CompositeCacheManager(
            caffeineCacheManager,  // L1: Local
            redisCacheManager      // L2: Distributed
        );
    }
    
    @Bean
    public CacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products");
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(100)
            .expireAfterWrite(1, TimeUnit.MINUTES));
        return cacheManager;
    }
    
    @Bean
    public CacheManager redisCacheManager(RedisConnectionFactory factory) {
        return RedisCacheManager.builder(factory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)))
            .build();
    }
}
```

---

## 9. Cache Metrics

### 9.1. Caffeine Statistics

```java
@Component
public class CaffeineMetrics {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Scheduled(fixedRate = 60000)
    public void logStats() {
        cacheManager.getCacheNames().forEach(name -> {
            Cache cache = cacheManager.getCache(name);
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                CacheStats stats = nativeCache.stats();
                
                log.info("Cache: {}", name);
                log.info("  Hit Count: {}", stats.hitCount());
                log.info("  Miss Count: {}", stats.missCount());
                log.info("  Hit Rate: {}%", stats.hitRate() * 100);
                log.info("  Eviction Count: {}", stats.evictionCount());
                log.info("  Load Success Count: {}", stats.loadSuccessCount());
            }
        });
    }
}
```

### 9.2. Redis Metrics

```java
@Component
public class RedisMetrics {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void getRedisInfo() {
        Properties info = redisTemplate.getConnectionFactory()
            .getConnection()
            .info();
        
        log.info("Used Memory: {}", info.getProperty("used_memory_human"));
        log.info("Connected Clients: {}", info.getProperty("connected_clients"));
        log.info("Total Commands Processed: {}", info.getProperty("total_commands_processed"));
    }
}
```

---

## 10. Best Practices

1. **Choose right provider** based on architecture (single vs distributed)
2. **Configure appropriate TTL** - balance freshness and performance
3. **Set eviction policies** - prevent memory overflow
4. **Monitor cache statistics** - hit ratio, evictions, memory
5. **Use multi-level caching** for optimal performance
6. **Serialize efficiently** - choose appropriate serialization format
7. **Handle cache failures** - graceful degradation
8. **Test with realistic data** - verify cache sizing
9. **Document configuration** - TTL, size limits, eviction
10. **Plan for scaling** - consider distributed caching early

---

## 11. Interview Questions

**Q1: What is Caffeine?**
**A:** High-performance, in-memory cache library for Java, successor to Google Guava cache.

**Q2: When to use Redis vs Caffeine?**
**A:** Redis: Distributed apps, shared cache. Caffeine: Single instance, maximum performance.

**Q3: What is EhCache?**
**A:** Feature-rich Java cache supporting in-memory, disk, and clustering.

**Q4: What is Hazelcast?**
**A:** Distributed in-memory data grid with automatic clustering and replication.

**Q5: What is distributed caching?**
**A:** Cache shared across multiple application instances (e.g., Redis, Hazelcast).

**Q6: How does Redis persist data?**
**A:** RDB snapshots (periodic) and AOF (append-only file) for durability.

**Q7: What is multi-level caching?**
**A:** Combining local (L1) and distributed (L2) caches for optimal performance.

**Q8: What is cache serialization?**
**A:** Converting objects to bytes for storage. Options: JSON, Kryo, Java Serialization.

**Q9: What is TTL vs TTI?**
**A:** TTL: Time-to-live (write expiration). TTI: Time-to-idle (access expiration).

**Q10: How to configure different TTL per cache?**
**A:** Use cache-specific configuration in RedisCacheManager or Caffeine registration.

**Q11: What is JCache (JSR-107)?**
**A:** Standard Java caching API. Providers: EhCache, Hazelcast, Infinispan.

**Q12: Redis vs Memcached?**
**A:** Redis: Rich data types, persistence, pub/sub. Memcached: Simple key-value, faster.

**Q13: What is cache eviction policy?**
**A:** Algorithm for removing entries when cache is full (LRU, LFU, FIFO).

**Q14: How does Caffeine LRU work?**
**A:** Tracks access frequency and recency using TinyLFU and Window TinyLFU algorithms.

**Q15: Can you mix cache providers?**
**A:** Yes, using CompositeCacheManager for multi-level caching.

**Q16: What is cache clustering?**
**A:** Distributing cache across multiple nodes for scalability and availability.

**Q17: How to monitor cache performance?**
**A:** Track hit ratio, miss ratio, eviction count, memory usage, latency.

**Q18: What is cache warming?**
**A:** Preloading cache with frequently accessed data on startup.

**Q19: How does Redis handle failures?**
**A:** Replication (master-slave), Sentinel (monitoring), Cluster (partitioning).

**Q20: What is cache aside pattern?**
**A:** Application checks cache, loads from DB on miss, stores in cache.

---

## 12. Summary

Spring Boot supports multiple cache providers: Caffeine for single-instance, Redis for distributed, EhCache for enterprise features, and Hazelcast for data grids. Choose based on architecture, performance needs, and features. Configure TTL, eviction, and monitoring for production-ready caching.

---

**Next:** Cache Configuration →
