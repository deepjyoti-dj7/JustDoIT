# üóÑÔ∏è @DataJpaTest - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [What is @DataJpaTest](#what-is-datajpatest)
- [Basic Usage](#basic-usage)
- [Testing Repositories](#testing-repositories)
- [TestEntityManager](#testentitymanager)
- [Custom Queries](#custom-queries)
- [Advanced Scenarios](#advanced-scenarios)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**@DataJpaTest** is a Spring Boot test annotation that configures only JPA components for testing repository layer without loading the full application context.

### Why @DataJpaTest?

```
Benefits:
‚úÖ Faster than @SpringBootTest
‚úÖ Tests only persistence layer
‚úÖ Auto-configures TestEntityManager
‚úÖ Loads only JPA repositories
‚úÖ Uses in-memory database (H2)
‚úÖ Transactions rolled back after each test
‚úÖ No service/controller layers loaded
```

### @DataJpaTest vs @SpringBootTest

| Feature | @DataJpaTest | @SpringBootTest |
|---------|--------------|-----------------|
| **Speed** | Fast (< 2 sec) | Slower (5-10 sec) |
| **Context** | JPA layer only | Full application |
| **Components** | Repositories, Entities | All beans |
| **Database** | In-memory (H2) | Configured DB |
| **Transactions** | Auto rollback | Configurable |
| **Use Case** | Repository unit tests | Integration tests |

---

## üìö What is @DataJpaTest

### Auto-Configuration

```java
@DataJpaTest
class UserRepositoryTest {
    // Automatically configures:
    // ‚úÖ EntityManager
    // ‚úÖ TestEntityManager
    // ‚úÖ DataSource (in-memory H2)
    // ‚úÖ JPA repositories
    // ‚úÖ @Entity classes
    // ‚úÖ Transaction management
    
    // NOT configured:
    // ‚ùå @Service beans
    // ‚ùå @Controller beans
    // ‚ùå @Component beans
    // ‚ùå External systems (Redis, Kafka, etc.)
}
```

### Loaded Components

```
JPA Layer Components:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  JpaRepository                  ‚îÇ
‚îÇ  CrudRepository                 ‚îÇ
‚îÇ  @Entity classes                ‚îÇ
‚îÇ  EntityManager                  ‚îÇ
‚îÇ  TestEntityManager              ‚îÇ
‚îÇ  DataSource (H2)                ‚îÇ
‚îÇ  Transaction Manager            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

NOT Loaded:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  @Service                       ‚îÇ
‚îÇ  @Controller                    ‚îÇ
‚îÇ  @Component                     ‚îÇ
‚îÇ  External integrations          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ Basic Usage

### Simple Repository Test

```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldSaveUser() {
        // Given
        User user = new User("John Doe", "john@example.com");
        
        // When
        User savedUser = userRepository.save(user);
        
        // Then
        assertThat(savedUser.getId()).isNotNull();
        assertThat(savedUser.getName()).isEqualTo("John Doe");
    }
    
    @Test
    void shouldFindUserById() {
        // Given
        User user = entityManager.persistAndFlush(
            new User("John", "john@example.com")
        );
        
        // When
        Optional<User> found = userRepository.findById(user.getId());
        
        // Then
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John");
    }
}
```

### Entity Class

```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // Constructors, getters, setters
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
```

### Repository Interface

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByEmail(String email);
    
    List<User> findByNameContaining(String name);
    
    @Query("SELECT u FROM User u WHERE u.createdAt > :date")
    List<User> findRecentUsers(@Param("date") LocalDateTime date);
}
```

---

## üîç Testing Repositories

### CRUD Operations

```java
@DataJpaTest
class UserRepositoryCrudTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldCreateUser() {
        User user = new User("John", "john@example.com");
        
        User saved = userRepository.save(user);
        
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getName()).isEqualTo("John");
    }
    
    @Test
    void shouldReadUser() {
        User user = userRepository.save(new User("John", "john@example.com"));
        
        Optional<User> found = userRepository.findById(user.getId());
        
        assertThat(found).isPresent();
        assertThat(found.get().getEmail()).isEqualTo("john@example.com");
    }
    
    @Test
    void shouldUpdateUser() {
        User user = userRepository.save(new User("John", "john@example.com"));
        
        user.setName("John Updated");
        User updated = userRepository.save(user);
        
        assertThat(updated.getName()).isEqualTo("John Updated");
    }
    
    @Test
    void shouldDeleteUser() {
        User user = userRepository.save(new User("John", "john@example.com"));
        Long userId = user.getId();
        
        userRepository.delete(user);
        
        Optional<User> found = userRepository.findById(userId);
        assertThat(found).isEmpty();
    }
}
```

### Find Methods

```java
@DataJpaTest
class UserRepositoryFindTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldFindAll() {
        userRepository.save(new User("John", "john@example.com"));
        userRepository.save(new User("Jane", "jane@example.com"));
        
        List<User> users = userRepository.findAll();
        
        assertThat(users).hasSize(2);
    }
    
    @Test
    void shouldFindByEmail() {
        userRepository.save(new User("John", "john@example.com"));
        
        Optional<User> found = userRepository.findByEmail("john@example.com");
        
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John");
    }
    
    @Test
    void shouldReturnEmptyWhenNotFound() {
        Optional<User> found = userRepository.findByEmail("notfound@example.com");
        
        assertThat(found).isEmpty();
    }
    
    @Test
    void shouldFindByNameContaining() {
        userRepository.save(new User("John Doe", "john@example.com"));
        userRepository.save(new User("Jane Doe", "jane@example.com"));
        userRepository.save(new User("Bob Smith", "bob@example.com"));
        
        List<User> users = userRepository.findByNameContaining("Doe");
        
        assertThat(users).hasSize(2);
        assertThat(users)
            .extracting(User::getName)
            .containsExactlyInAnyOrder("John Doe", "Jane Doe");
    }
}
```

### Count and Exists

```java
@DataJpaTest
class UserRepositoryCountTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldCountUsers() {
        userRepository.save(new User("John", "john@example.com"));
        userRepository.save(new User("Jane", "jane@example.com"));
        
        long count = userRepository.count();
        
        assertThat(count).isEqualTo(2);
    }
    
    @Test
    void shouldCheckIfUserExists() {
        User user = userRepository.save(new User("John", "john@example.com"));
        
        boolean exists = userRepository.existsById(user.getId());
        
        assertThat(exists).isTrue();
    }
    
    @Test
    void shouldReturnFalseWhenNotExists() {
        boolean exists = userRepository.existsById(999L);
        
        assertThat(exists).isFalse();
    }
}
```

---

## üõ†Ô∏è TestEntityManager

### What is TestEntityManager?

TestEntityManager is a test-specific wrapper around EntityManager that provides utility methods for testing.

### Basic Usage

```java
@DataJpaTest
class TestEntityManagerExample {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldUseTestEntityManager() {
        // Persist entity
        User user = new User("John", "john@example.com");
        User persisted = entityManager.persist(user);
        
        // Flush to database
        entityManager.flush();
        
        // Clear persistence context
        entityManager.clear();
        
        // Find entity
        User found = entityManager.find(User.class, persisted.getId());
        
        assertThat(found.getName()).isEqualTo("John");
    }
}
```

### Persist and Flush

```java
@DataJpaTest
class PersistAndFlushTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldPersistAndFlush() {
        // Persist immediately to database
        User user = entityManager.persistAndFlush(
            new User("John", "john@example.com")
        );
        
        // ID should be generated
        assertThat(user.getId()).isNotNull();
        
        // Should be findable by repository
        Optional<User> found = userRepository.findById(user.getId());
        assertThat(found).isPresent();
    }
}
```

### Clear Persistence Context

```java
@DataJpaTest
class ClearContextTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldClearPersistenceContext() {
        // Persist user
        User user = entityManager.persistAndFlush(
            new User("John", "john@example.com")
        );
        
        // Modify in memory
        user.setName("John Modified");
        
        // Clear context - changes not saved
        entityManager.clear();
        
        // Find from database
        User found = entityManager.find(User.class, user.getId());
        
        // Should have original name
        assertThat(found.getName()).isEqualTo("John");
    }
}
```

### Testing Lazy Loading

```java
@DataJpaTest
class LazyLoadingTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldTestLazyLoading() {
        // Create user with orders (lazy loaded)
        User user = new User("John", "john@example.com");
        Order order1 = new Order(user, new BigDecimal("100"));
        Order order2 = new Order(user, new BigDecimal("200"));
        
        entityManager.persist(user);
        entityManager.persist(order1);
        entityManager.persist(order2);
        entityManager.flush();
        entityManager.clear();
        
        // Load user (orders not loaded yet)
        User found = entityManager.find(User.class, user.getId());
        
        // Access lazy collection
        assertThat(found.getOrders()).hasSize(2);
    }
}
```

---

## üîé Custom Queries

### @Query Testing

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmailCustom(@Param("email") String email);
    
    @Query("SELECT u FROM User u WHERE u.createdAt > :date")
    List<User> findRecentUsers(@Param("date") LocalDateTime date);
    
    @Query("SELECT COUNT(u) FROM User u WHERE u.name LIKE %:name%")
    long countByNameContaining(@Param("name") String name);
}
```

```java
@DataJpaTest
class CustomQueryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldExecuteCustomQuery() {
        userRepository.save(new User("John", "john@example.com"));
        
        Optional<User> found = userRepository.findByEmailCustom("john@example.com");
        
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John");
    }
    
    @Test
    void shouldFindRecentUsers() {
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        
        userRepository.save(new User("John", "john@example.com"));
        userRepository.save(new User("Jane", "jane@example.com"));
        
        List<User> recent = userRepository.findRecentUsers(yesterday);
        
        assertThat(recent).hasSize(2);
    }
    
    @Test
    void shouldCountByNameContaining() {
        userRepository.save(new User("John Doe", "john@example.com"));
        userRepository.save(new User("Jane Doe", "jane@example.com"));
        userRepository.save(new User("Bob Smith", "bob@example.com"));
        
        long count = userRepository.countByNameContaining("Doe");
        
        assertThat(count).isEqualTo(2);
    }
}
```

### Native Query Testing

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmailNative(String email);
    
    @Query(value = "SELECT * FROM users WHERE created_at > ?1", nativeQuery = true)
    List<User> findRecentUsersNative(LocalDateTime date);
}
```

```java
@DataJpaTest
class NativeQueryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldExecuteNativeQuery() {
        userRepository.save(new User("John", "john@example.com"));
        
        User found = userRepository.findByEmailNative("john@example.com");
        
        assertThat(found).isNotNull();
        assertThat(found.getName()).isEqualTo("John");
    }
}
```

### Modifying Queries

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Modifying
    @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
    int updateName(@Param("id") Long id, @Param("name") String name);
    
    @Modifying
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(@Param("email") String email);
}
```

```java
@DataJpaTest
class ModifyingQueryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUpdateName() {
        User user = userRepository.save(new User("John", "john@example.com"));
        
        int updated = userRepository.updateName(user.getId(), "John Updated");
        
        assertThat(updated).isEqualTo(1);
        
        User found = userRepository.findById(user.getId()).orElseThrow();
        assertThat(found.getName()).isEqualTo("John Updated");
    }
    
    @Test
    void shouldDeleteByEmail() {
        userRepository.save(new User("John", "john@example.com"));
        
        int deleted = userRepository.deleteByEmail("john@example.com");
        
        assertThat(deleted).isEqualTo(1);
        assertThat(userRepository.findByEmail("john@example.com")).isEmpty();
    }
}
```

---

## üöÄ Advanced Scenarios

### Testing Relationships

```java
// One-to-Many relationship
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();
}

@Entity
public class Order {
    @Id
    @GeneratedValue
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
    
    private BigDecimal amount;
}
```

```java
@DataJpaTest
class RelationshipTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Test
    void shouldSaveUserWithOrders() {
        User user = new User("John", "john@example.com");
        Order order1 = new Order(new BigDecimal("100"));
        Order order2 = new Order(new BigDecimal("200"));
        
        user.addOrder(order1);
        user.addOrder(order2);
        
        User saved = userRepository.save(user);
        
        assertThat(saved.getOrders()).hasSize(2);
    }
    
    @Test
    void shouldFindOrdersByUser() {
        User user = userRepository.save(new User("John", "john@example.com"));
        orderRepository.save(new Order(user, new BigDecimal("100")));
        orderRepository.save(new Order(user, new BigDecimal("200")));
        
        List<Order> orders = orderRepository.findByUser(user);
        
        assertThat(orders).hasSize(2);
    }
}
```

### Testing Pagination

```java
@DataJpaTest
class PaginationTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldPaginate() {
        // Create 25 users
        for (int i = 1; i <= 25; i++) {
            userRepository.save(new User("User" + i, "user" + i + "@example.com"));
        }
        
        // Request first page (10 items)
        Pageable pageable = PageRequest.of(0, 10);
        Page<User> page = userRepository.findAll(pageable);
        
        assertThat(page.getTotalElements()).isEqualTo(25);
        assertThat(page.getTotalPages()).isEqualTo(3);
        assertThat(page.getContent()).hasSize(10);
        assertThat(page.isFirst()).isTrue();
    }
    
    @Test
    void shouldSortUsers() {
        userRepository.save(new User("Charlie", "charlie@example.com"));
        userRepository.save(new User("Alice", "alice@example.com"));
        userRepository.save(new User("Bob", "bob@example.com"));
        
        Pageable pageable = PageRequest.of(0, 10, Sort.by("name").ascending());
        Page<User> page = userRepository.findAll(pageable);
        
        assertThat(page.getContent())
            .extracting(User::getName)
            .containsExactly("Alice", "Bob", "Charlie");
    }
}
```

### Testing Specifications

```java
public class UserSpecifications {
    
    public static Specification<User> hasEmail(String email) {
        return (root, query, cb) -> cb.equal(root.get("email"), email);
    }
    
    public static Specification<User> nameContains(String name) {
        return (root, query, cb) -> cb.like(root.get("name"), "%" + name + "%");
    }
}
```

```java
@DataJpaTest
class SpecificationTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUseSpecification() {
        userRepository.save(new User("John Doe", "john@example.com"));
        userRepository.save(new User("Jane Doe", "jane@example.com"));
        
        Specification<User> spec = UserSpecifications.nameContains("Doe");
        List<User> users = userRepository.findAll(spec);
        
        assertThat(users).hasSize(2);
    }
    
    @Test
    void shouldCombineSpecifications() {
        userRepository.save(new User("John Doe", "john@example.com"));
        
        Specification<User> spec = UserSpecifications.hasEmail("john@example.com")
            .and(UserSpecifications.nameContains("John"));
        
        List<User> users = userRepository.findAll(spec);
        
        assertThat(users).hasSize(1);
    }
}
```

### Testing Transactions

```java
@DataJpaTest
class TransactionTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void shouldRollbackTransaction() {
        // Save user
        userRepository.save(new User("John", "john@example.com"));
        
        // Verify saved
        assertThat(userRepository.count()).isEqualTo(1);
        
        // After test completes, transaction is rolled back
        // Database is clean for next test
    }
    
    @Test
    void shouldStartWithCleanDatabase() {
        // Previous test's data is rolled back
        assertThat(userRepository.count()).isEqualTo(0);
    }
}
```

---

## üí° Best Practices

### 1. Use In-Memory Database

```java
// ‚úÖ Good - Uses H2 by default
@DataJpaTest
class UserRepositoryTest {
    // Automatically uses H2
}

// application-test.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.hibernate.ddl-auto=create-drop
```

### 2. Use TestEntityManager for Setup

```java
// ‚úÖ Good - Use TestEntityManager for test data
@Test
void shouldFindUser() {
    User user = entityManager.persistAndFlush(
        new User("John", "john@example.com")
    );
    
    Optional<User> found = userRepository.findById(user.getId());
    assertThat(found).isPresent();
}

// ‚ùå Bad - Don't use repository for setup
@Test
void shouldFindUser() {
    User user = userRepository.save(new User("John", "john@example.com"));
    // Testing repository with itself
}
```

### 3. Test One Method Per Test

```java
// ‚úÖ Good - One method per test
@Test
void shouldSaveUser() {
    // Test save
}

@Test
void shouldFindUser() {
    // Test find
}

// ‚ùå Bad - Multiple methods in one test
@Test
void testUserOperations() {
    // Test save
    // Test find
    // Test update
    // Test delete
}
```

### 4. Use Descriptive Test Names

```java
// ‚úÖ Good
@Test
void shouldReturnUserWhenEmailExists() { }

@Test
void shouldReturnEmptyWhenEmailDoesNotExist() { }

// ‚ùå Bad
@Test
void testFindByEmail() { }
```

### 5. Clean Up After Relationships

```java
// ‚úÖ Good - Use cascade or manual cleanup
@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
private List<Order> orders;

// ‚ùå Bad - Orphaned data
@OneToMany
private List<Order> orders;
```

---

## üé§ Interview Questions

### Q1: What is @DataJpaTest?
**Answer:** A Spring Boot test annotation that configures only JPA components (repositories, entities, EntityManager) for testing the persistence layer.

### Q2: What database does @DataJpaTest use by default?
**Answer:** H2 in-memory database by default.

### Q3: Are transactions rolled back after each test?
**Answer:** Yes, each test runs in a transaction that is rolled back after completion.

### Q4: What is TestEntityManager?
**Answer:** A test-specific wrapper around EntityManager providing utility methods like `persist()`, `persistAndFlush()`, `flush()`, and `clear()`.

### Q5: Can you use real database with @DataJpaTest?
**Answer:** Yes, by configuring datasource in test properties and using `@AutoConfigureTestDatabase(replace = Replace.NONE)`.

### Q6: What components are NOT loaded by @DataJpaTest?
**Answer:** @Service, @Controller, @Component beans are not loaded. Only JPA layer components.

### Q7: How to test custom JPQL queries?
**Answer:** Create test method that calls repository method with @Query annotation and asserts results.

### Q8: Difference between persist() and persistAndFlush()?
**Answer:**
- `persist()`: Adds entity to persistence context
- `persistAndFlush()`: Persists AND immediately flushes to database

### Q9: How to test pagination in repository?
**Answer:**
```java
Pageable pageable = PageRequest.of(0, 10);
Page<User> page = repository.findAll(pageable);
assertThat(page.getTotalElements()).isEqualTo(25);
```

### Q10: How to test relationships?
**Answer:** Create entities with relationships, save parent (cascade), verify children are saved/loaded correctly.

### Q11: Can you mock repositories in @DataJpaTest?
**Answer:** No need to mock. @DataJpaTest tests real repository implementation against in-memory database.

### Q12: How to clear persistence context?
**Answer:** Use `entityManager.clear()`.

### Q13: How to test native queries?
**Answer:** Add `nativeQuery = true` to @Query annotation and test normally.

### Q14: What is @AutoConfigureTestDatabase?
**Answer:** Annotation to configure which database to use for tests. Default replaces real DB with H2.

### Q15: How to disable transaction rollback?
**Answer:** Use `@Rollback(false)` on test method.

### Q16: Can you test @Modifying queries?
**Answer:** Yes, test that update/delete count is correct and verify changes.

### Q17: How to test lazy loading?
**Answer:** Use `entityManager.clear()` to detach entities, then access lazy collection and verify.

### Q18: Should you test JPA built-in methods?
**Answer:** Generally no. Focus on custom queries and business logic.

### Q19: How to test specifications?
**Answer:** Create Specification, pass to `repository.findAll(spec)`, assert results.

### Q20: When to use @DataJpaTest vs @SpringBootTest?
**Answer:**
- @DataJpaTest: Unit testing repositories (fast, isolated)
- @SpringBootTest: Integration testing (complete workflow)

---

## üìö Summary

### Key Points

```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private UserRepository repository;  // Auto-configured
    
    @Autowired
    private TestEntityManager entityManager;  // Test utilities
    
    @Test
    void shouldTestRepository() {
        // Given - use TestEntityManager for setup
        User user = entityManager.persistAndFlush(
            new User("John", "john@example.com")
        );
        
        // When - test repository method
        Optional<User> found = repository.findById(user.getId());
        
        // Then - assert results
        assertThat(found).isPresent();
        assertThat(found.get().getName()).isEqualTo("John");
        
        // Transaction rolled back automatically
    }
}
```

### Best Practices

```
‚úÖ Use in-memory H2 database
‚úÖ Use TestEntityManager for setup
‚úÖ Test one method per test
‚úÖ Descriptive test names
‚úÖ Test custom queries
‚úÖ Verify relationships
‚úÖ Let transactions rollback
‚úÖ Test pagination and sorting
```

**Next:** Mockito Integration ‚Üí

