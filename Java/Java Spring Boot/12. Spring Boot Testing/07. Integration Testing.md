# üîÑ Integration Testing - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [What is Integration Testing](#what-is-integration-testing)
- [@SpringBootTest](#springboottest)
- [Testing Full Workflows](#testing-full-workflows)
- [Database Integration](#database-integration)
- [REST API Testing](#rest-api-testing)
- [Advanced Scenarios](#advanced-scenarios)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Integration Testing** verifies that different components of your application work together correctly as a complete system.

### Why Integration Testing?

```
Benefits:
‚úÖ Tests real component interactions
‚úÖ Verifies complete workflows
‚úÖ Catches integration issues
‚úÖ Tests with real database
‚úÖ Validates configuration
‚úÖ End-to-end verification
‚úÖ Realistic testing environment
```

### Unit vs Integration Testing

| Aspect | Unit Testing | Integration Testing |
|--------|--------------|---------------------|
| **Scope** | Single class | Multiple components |
| **Dependencies** | Mocked | Real or embedded |
| **Speed** | Fast (< 1s) | Slower (2-10s) |
| **Database** | Mocked | Real/embedded |
| **Context** | None/partial | Full Spring context |
| **Purpose** | Component isolation | Component interaction |

---

## üìö What is Integration Testing

### Integration Test Pyramid

```
         /\
        /  \  E2E Tests (Few)
       /    \
      /------\
     /        \  Integration Tests (Some)
    /          \
   /------------\
  /              \  Unit Tests (Many)
 /________________\
```

### What to Test

```
Integration Testing Covers:
‚úÖ Controller ‚Üí Service ‚Üí Repository flow
‚úÖ Database transactions
‚úÖ REST API endpoints
‚úÖ Security configuration
‚úÖ External service integration
‚úÖ Message queue integration
‚úÖ Cache behavior
‚úÖ Configuration properties
```

---

## üöÄ @SpringBootTest

### Basic Usage

```java
@SpringBootTest
class UserIntegrationTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldCreateUser() {
        // Given
        UserRequest request = new UserRequest("John", "john@example.com");
        
        // When
        User created = userService.createUser(request);
        
        // Then
        assertThat(created.getId()).isNotNull();
        assertThat(userRepository.findById(created.getId())).isPresent();
    }
    
    @AfterEach
    void cleanup() {
        userRepository.deleteAll();
    }
}
```

### Web Environment Options

```java
// MOCK - Default, loads WebApplicationContext with MockMvc
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
class MockWebTest {
    @Autowired
    private MockMvc mockMvc;
}

// RANDOM_PORT - Starts embedded server on random port
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class RandomPortTest {
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
}

// DEFINED_PORT - Uses defined port (8080)
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
class DefinedPortTest {
    @Autowired
    private TestRestTemplate restTemplate;
}

// NONE - No web environment
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
class NoWebTest {
    @Autowired
    private UserService userService;
}
```

### Configuration

```java
@SpringBootTest(
    properties = {
        "spring.datasource.url=jdbc:h2:mem:testdb",
        "spring.jpa.hibernate.ddl-auto=create-drop"
    }
)
class ConfiguredTest {
    // Custom properties for this test
}
```

---

## üîÑ Testing Full Workflows

### Complete User Creation Flow

```java
@SpringBootTest
@Transactional
class UserCreationFlowTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Test
    void shouldCreateUserWithCompleteWorkflow() {
        // Given
        UserRequest request = new UserRequest("John Doe", "john@example.com");
        
        // When - Full workflow
        User created = userService.createUser(request);
        
        // Then - Verify all steps
        // 1. User saved to database
        Optional<User> saved = userRepository.findById(created.getId());
        assertThat(saved).isPresent();
        assertThat(saved.get().getName()).isEqualTo("John Doe");
        
        // 2. Email sent (if real implementation)
        // verify email was sent
        
        // 3. Audit log created
        // verify audit log
    }
}
```

### Order Processing Workflow

```java
@SpringBootTest
@Transactional
class OrderProcessingFlowTest {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Test
    void shouldProcessCompleteOrder() {
        // Given - Setup test data
        User user = userRepository.save(new User("John", "john@example.com"));
        Product product = productRepository.save(
            new Product("Laptop", new BigDecimal("999.99"), 10)
        );
        
        OrderRequest request = new OrderRequest(
            user.getId(),
            Arrays.asList(new OrderItem(product.getId(), 2))
        );
        
        // When - Process order
        Order order = orderService.createOrder(request);
        
        // Then - Verify complete workflow
        // 1. Order created
        assertThat(order.getId()).isNotNull();
        assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);
        
        // 2. Inventory updated
        Product updated = productRepository.findById(product.getId()).orElseThrow();
        assertThat(updated.getStock()).isEqualTo(8);
        
        // 3. Total calculated
        assertThat(order.getTotal()).isEqualTo(new BigDecimal("1999.98"));
        
        // 4. Order persisted
        Order saved = orderRepository.findById(order.getId()).orElseThrow();
        assertThat(saved.getItems()).hasSize(1);
    }
}
```

---

## üóÑÔ∏è Database Integration

### Using Embedded Database

```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = Replace.ANY)
class EmbeddedDatabaseTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUseEmbeddedDatabase() {
        User user = new User("John", "john@example.com");
        
        User saved = userRepository.save(user);
        
        assertThat(saved.getId()).isNotNull();
    }
}
```

### Using Real Database

```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:postgresql://localhost:5432/testdb",
    "spring.datasource.username=test",
    "spring.datasource.password=test"
})
class RealDatabaseTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUseRealDatabase() {
        User user = userRepository.save(new User("John", "john@example.com"));
        assertThat(user.getId()).isNotNull();
    }
    
    @AfterEach
    void cleanup() {
        userRepository.deleteAll();
    }
}
```

### SQL Scripts

```java
@SpringBootTest
@Sql(scripts = "/test-data.sql", executionPhase = ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(scripts = "/cleanup.sql", executionPhase = ExecutionPhase.AFTER_TEST_METHOD)
class SqlScriptTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldLoadTestData() {
        // test-data.sql already loaded
        List<User> users = userRepository.findAll();
        
        assertThat(users).isNotEmpty();
    }
}
```

### Transaction Management

```java
@SpringBootTest
@Transactional
class TransactionTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldRollbackTransaction() {
        // Given
        UserRequest request = new UserRequest("John", "john@example.com");
        
        // When
        User created = userService.createUser(request);
        
        // Then - User exists within transaction
        assertThat(userRepository.findById(created.getId())).isPresent();
        
        // After test - transaction rolled back automatically
    }
    
    @Test
    @Rollback(false)
    void shouldCommitTransaction() {
        // Transaction will be committed after test
        userService.createUser(new UserRequest("John", "john@example.com"));
    }
}
```

---

## üåê REST API Testing

### Using MockMvc

```java
@SpringBootTest
@AutoConfigureMockMvc
class UserControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    void shouldCreateUserViaApi() throws Exception {
        UserRequest request = new UserRequest("John", "john@example.com");
        
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.name").value("John"));
        
        // Verify in database
        List<User> users = userRepository.findAll();
        assertThat(users).hasSize(1);
    }
    
    @AfterEach
    void cleanup() {
        userRepository.deleteAll();
    }
}
```

### Using TestRestTemplate

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class UserApiIntegrationTest {
    
    @LocalServerPort
    private int port;
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldCreateUser() {
        // Given
        UserRequest request = new UserRequest("John", "john@example.com");
        
        // When
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users",
            request,
            User.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody()).isNotNull();
        assertThat(response.getBody().getName()).isEqualTo("John");
        
        // Verify in database
        assertThat(userRepository.findAll()).hasSize(1);
    }
    
    @Test
    void shouldGetUser() {
        // Given - Create user first
        User user = userRepository.save(new User("John", "john@example.com"));
        
        // When
        ResponseEntity<User> response = restTemplate.getForEntity(
            "/api/users/" + user.getId(),
            User.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getName()).isEqualTo("John");
    }
    
    @Test
    void shouldUpdateUser() {
        // Given
        User user = userRepository.save(new User("John", "john@example.com"));
        UserRequest updateRequest = new UserRequest("John Updated", "john@example.com");
        
        // When
        restTemplate.put("/api/users/" + user.getId(), updateRequest);
        
        // Then
        User updated = userRepository.findById(user.getId()).orElseThrow();
        assertThat(updated.getName()).isEqualTo("John Updated");
    }
    
    @Test
    void shouldDeleteUser() {
        // Given
        User user = userRepository.save(new User("John", "john@example.com"));
        
        // When
        restTemplate.delete("/api/users/" + user.getId());
        
        // Then
        assertThat(userRepository.findById(user.getId())).isEmpty();
    }
    
    @AfterEach
    void cleanup() {
        userRepository.deleteAll();
    }
}
```

### Testing Error Scenarios

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ErrorHandlingIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void shouldReturn404WhenUserNotFound() {
        ResponseEntity<ErrorResponse> response = restTemplate.getForEntity(
            "/api/users/999",
            ErrorResponse.class
        );
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        assertThat(response.getBody().getMessage()).contains("not found");
    }
    
    @Test
    void shouldReturn400WhenInvalidData() {
        UserRequest invalidRequest = new UserRequest("", "invalid-email");
        
        ResponseEntity<ErrorResponse> response = restTemplate.postForEntity(
            "/api/users",
            invalidRequest,
            ErrorResponse.class
        );
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
    }
}
```

---

## üöÄ Advanced Scenarios

### Testing with Security

```java
@SpringBootTest
@AutoConfigureMockMvc
class SecureEndpointTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    @WithMockUser(username = "admin", roles = {"ADMIN"})
    void shouldAllowAdminAccess() throws Exception {
        mockMvc.perform(get("/api/admin/users"))
            .andExpect(status().isOk());
    }
    
    @Test
    @WithMockUser(username = "user", roles = {"USER"})
    void shouldDenyUserAccess() throws Exception {
        mockMvc.perform(delete("/api/users/1"))
            .andExpect(status().isForbidden());
    }
    
    @Test
    void shouldRequireAuthentication() throws Exception {
        mockMvc.perform(get("/api/users"))
            .andExpect(status().isUnauthorized());
    }
}
```

### Testing with Profiles

```java
@SpringBootTest
@ActiveProfiles("test")
class ProfileTest {
    
    @Value("${app.feature.enabled}")
    private boolean featureEnabled;
    
    @Test
    void shouldUseTestProfile() {
        assertThat(featureEnabled).isTrue();
    }
}
```

### Testing Async Operations

```java
@SpringBootTest
class AsyncOperationTest {
    
    @Autowired
    private AsyncService asyncService;
    
    @Test
    void shouldExecuteAsync() throws Exception {
        // When
        CompletableFuture<String> future = asyncService.processAsync();
        
        // Then
        String result = future.get(5, TimeUnit.SECONDS);
        assertThat(result).isEqualTo("Processed");
    }
}
```

### Testing Scheduled Tasks

```java
@SpringBootTest
class ScheduledTaskTest {
    
    @Autowired
    private ScheduledService scheduledService;
    
    @MockBean
    private TaskScheduler taskScheduler;
    
    @Test
    void shouldScheduleTask() {
        // Verify scheduled task configuration
        verify(taskScheduler).schedule(any(Runnable.class), any(Trigger.class));
    }
}
```

### Testing Events

```java
@SpringBootTest
class EventTest {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @MockBean
    private EventListener eventListener;
    
    @Test
    void shouldPublishEvent() {
        // When
        UserCreatedEvent event = new UserCreatedEvent(new User());
        eventPublisher.publishEvent(event);
        
        // Then
        verify(eventListener, timeout(1000)).onUserCreated(any());
    }
}
```

---

## üí° Best Practices

### 1. Use @Transactional for Data Cleanup

```java
// ‚úÖ Good - Automatic rollback
@SpringBootTest
@Transactional
class UserServiceTest {
    // No manual cleanup needed
}

// ‚ùå Bad - Manual cleanup
@SpringBootTest
class UserServiceTest {
    @AfterEach
    void cleanup() {
        userRepository.deleteAll();
        orderRepository.deleteAll();
        // Many more...
    }
}
```

### 2. Use Test Slices When Possible

```java
// ‚úÖ Good - Faster, focused
@WebMvcTest(UserController.class)
class UserControllerTest { }

@DataJpaTest
class UserRepositoryTest { }

// ‚ùå Bad - Slower, over-testing
@SpringBootTest
class UserControllerTest { }

@SpringBootTest
class UserRepositoryTest { }
```

### 3. Isolate Test Data

```java
// ‚úÖ Good - Each test independent
@Test
void test1() {
    User user = createUser("user1@example.com");
    // Test with user
}

@Test
void test2() {
    User user = createUser("user2@example.com");
    // Test with user
}

// ‚ùå Bad - Tests depend on each other
static User sharedUser;

@BeforeAll
static void setup() {
    sharedUser = createUser();
}
```

### 4. Use Meaningful Test Data

```java
// ‚úÖ Good - Clear test intent
@Test
void shouldValidateEmail() {
    UserRequest invalid = new UserRequest("John", "invalid-email");
    // Clear what's being tested
}

// ‚ùå Bad - Unclear
@Test
void shouldValidateEmail() {
    UserRequest request = new UserRequest("a", "b");
    // What's wrong with this data?
}
```

### 5. Test One Scenario Per Test

```java
// ‚úÖ Good - One scenario
@Test
void shouldCreateUserSuccessfully() {
    // Happy path
}

@Test
void shouldFailWhenEmailExists() {
    // Error scenario
}

// ‚ùå Bad - Multiple scenarios
@Test
void shouldHandleAllCases() {
    // Test success
    // Test error
    // Test edge case
}
```

---

## üé§ Interview Questions

### Q1: What is integration testing?
**Answer:** Testing that verifies multiple components work together correctly as a complete system.

### Q2: Difference between @SpringBootTest and @WebMvcTest?
**Answer:**
- @SpringBootTest: Loads full application context
- @WebMvcTest: Loads only web layer for controller testing

### Q3: What does @SpringBootTest do?
**Answer:** Loads complete Spring Boot application context for integration testing.

### Q4: What are webEnvironment options?
**Answer:** MOCK (default), RANDOM_PORT, DEFINED_PORT, NONE

### Q5: What is TestRestTemplate?
**Answer:** Spring's HTTP client for testing REST APIs in integration tests.

### Q6: How to test with embedded database?
**Answer:** Use `@AutoConfigureTestDatabase(replace = Replace.ANY)` or H2 automatically

### Q7: What is @Sql annotation?
**Answer:** Loads SQL scripts before/after test execution.

### Q8: How to rollback transactions in tests?
**Answer:** Use `@Transactional` annotation - auto-rollback after each test.

### Q9: How to test secured endpoints?
**Answer:** Use `@WithMockUser` annotation to mock authenticated user.

### Q10: What is @LocalServerPort?
**Answer:** Injects random port number when using RANDOM_PORT web environment.

### Q11: How to test complete workflows?
**Answer:** Use @SpringBootTest with real beans, test from controller to database.

### Q12: When to use @Transactional in tests?
**Answer:** For automatic database cleanup via transaction rollback.

### Q13: How to configure test properties?
**Answer:** Use `application-test.properties` or `@TestPropertySource` or `properties` in @SpringBootTest.

### Q14: What is @AutoConfigureMockMvc?
**Answer:** Auto-configures MockMvc for @SpringBootTest with web environment MOCK.

### Q15: How to test async operations?
**Answer:** Use CompletableFuture and await result with timeout.

### Q16: Can you use @MockBean in integration tests?
**Answer:** Yes, to replace specific beans with mocks while keeping others real.

### Q17: How to test multiple profiles?
**Answer:** Use `@ActiveProfiles("profile1", "profile2")`

### Q18: Should integration tests be fast?
**Answer:** They're slower than unit tests but should still be optimized (< 10s ideal).

### Q19: How many integration tests vs unit tests?
**Answer:** Follow test pyramid: Many unit tests, fewer integration tests, few E2E tests.

### Q20: When to use @SpringBootTest?
**Answer:** Testing complete workflows, multi-component interactions, full application behavior.

---

## üìö Summary

### Key Points

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Transactional
class UserIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldTestCompleteWorkflow() {
        // Given - Test data
        UserRequest request = new UserRequest("John", "john@example.com");
        
        // When - Execute via REST API
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users",
            request,
            User.class
        );
        
        // Then - Verify response and database
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(userRepository.findAll()).hasSize(1);
        
        // Transaction auto-rolled back
    }
}
```

### Best Practices

```
‚úÖ Use @Transactional for cleanup
‚úÖ Test complete workflows
‚úÖ Use TestRestTemplate/MockMvc
‚úÖ Verify database state
‚úÖ Isolate test data
‚úÖ Use meaningful test data
‚úÖ Test one scenario per test
‚úÖ Keep tests fast
```

**Next:** TestContainers ‚Üí

