# ðŸ”¬ Unit Testing - Complete Guide

## ðŸ“‹ Table of Contents
- [Introduction](#introduction)
- [JUnit 5 Basics](#junit-5-basics)
- [Assertions](#assertions)
- [Testing Service Layer](#testing-service-layer)
- [Mockito Fundamentals](#mockito-fundamentals)
- [Testing Best Practices](#testing-best-practices)
- [Parameterized Tests](#parameterized-tests)
- [Test Doubles](#test-doubles)
- [Interview Questions](#interview-questions)

---

## ðŸŽ¯ Introduction

**Unit Testing** focuses on testing individual components in isolation, typically a single class or method. Unit tests are fast, focused, and form the foundation of your test suite.

### Characteristics of Good Unit Tests

```
FIRST Principles:
âœ… Fast - Milliseconds to run
âœ… Independent - No dependencies on other tests
âœ… Repeatable - Same result every time
âœ… Self-validating - Pass or fail, no manual verification
âœ… Timely - Written with or before production code
```

### Unit Test Scope

```
Test in Isolation:
âœ… Single class/method
âœ… Mock all dependencies
âœ… No database
âœ… No network calls
âœ… No file I/O
âœ… Fast execution
```

---

## ðŸ§ª JUnit 5 Basics

### Test Class Structure

```java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    
    private Calculator calculator;
    
    @BeforeAll
    static void initAll() {
        // Runs once before all tests
        System.out.println("Starting Calculator tests");
    }
    
    @BeforeEach
    void init() {
        // Runs before each test
        calculator = new Calculator();
    }
    
    @Test
    void shouldAddTwoNumbers() {
        // Arrange
        int a = 5;
        int b = 3;
        
        // Act
        int result = calculator.add(a, b);
        
        // Assert
        assertEquals(8, result);
    }
    
    @Test
    void shouldSubtractTwoNumbers() {
        assertEquals(2, calculator.subtract(5, 3));
    }
    
    @AfterEach
    void tearDown() {
        // Runs after each test
        calculator = null;
    }
    
    @AfterAll
    static void tearDownAll() {
        // Runs once after all tests
        System.out.println("Finished Calculator tests");
    }
}
```

### Display Names

```java
@DisplayName("Calculator Tests")
class CalculatorTest {
    
    @Test
    @DisplayName("Should add two positive numbers correctly")
    void addPositiveNumbers() {
        Calculator calc = new Calculator();
        assertEquals(8, calc.add(5, 3));
    }
    
    @Test
    @DisplayName("Should handle negative numbers in addition")
    void addNegativeNumbers() {
        Calculator calc = new Calculator();
        assertEquals(-2, calc.add(-5, 3));
    }
    
    @Test
    @DisplayName("Addition should be commutative (a + b = b + a)")
    void additionIsCommutative() {
        Calculator calc = new Calculator();
        assertEquals(calc.add(3, 5), calc.add(5, 3));
    }
}
```

### Nested Tests

```java
@DisplayName("User Service Tests")
class UserServiceTest {
    
    private UserService userService;
    
    @BeforeEach
    void setup() {
        userService = new UserService();
    }
    
    @Nested
    @DisplayName("When creating a new user")
    class CreateUserTests {
        
        @Test
        @DisplayName("Should create user with valid data")
        void createValidUser() {
            User user = userService.createUser("john@example.com", "password");
            assertNotNull(user);
            assertEquals("john@example.com", user.getEmail());
        }
        
        @Test
        @DisplayName("Should throw exception for invalid email")
        void createUserInvalidEmail() {
            assertThrows(IllegalArgumentException.class,
                () -> userService.createUser("invalid-email", "password"));
        }
    }
    
    @Nested
    @DisplayName("When updating a user")
    class UpdateUserTests {
        
        private User existingUser;
        
        @BeforeEach
        void setupExistingUser() {
            existingUser = userService.createUser("john@example.com", "password");
        }
        
        @Test
        @DisplayName("Should update user name")
        void updateUserName() {
            userService.updateName(existingUser.getId(), "John Doe");
            assertEquals("John Doe", existingUser.getName());
        }
    }
}
```

---

## âœ… Assertions

### Basic Assertions

```java
class AssertionsTest {
    
    @Test
    void basicAssertions() {
        // Equality
        assertEquals(4, 2 + 2);
        assertEquals("Hello", "Hello");
        
        // Not equal
        assertNotEquals(5, 2 + 2);
        
        // Null checks
        assertNull(null);
        assertNotNull("not null");
        
        // Boolean
        assertTrue(5 > 3);
        assertFalse(5 < 3);
        
        // Same/different references
        String str1 = new String("test");
        String str2 = new String("test");
        String str3 = str1;
        
        assertSame(str1, str3);        // Same reference
        assertNotSame(str1, str2);     // Different references
        assertEquals(str1, str2);       // Equal values
    }
}
```

### AssertJ Fluent Assertions

```java
import static org.assertj.core.api.Assertions.*;

class AssertJTest {
    
    @Test
    void fluentAssertions() {
        // Strings
        assertThat("Hello World")
            .isNotNull()
            .startsWith("Hello")
            .endsWith("World")
            .contains("lo Wo");
        
        // Numbers
        assertThat(42)
            .isPositive()
            .isGreaterThan(40)
            .isLessThan(50)
            .isBetween(40, 50);
        
        // Collections
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        assertThat(names)
            .hasSize(3)
            .contains("Alice", "Bob")
            .doesNotContain("David")
            .startsWith("Alice")
            .endsWith("Charlie");
        
        // Objects
        User user = new User("john@example.com", "John");
        assertThat(user)
            .isNotNull()
            .extracting(User::getEmail)
            .isEqualTo("john@example.com");
        
        assertThat(user)
            .hasFieldOrPropertyWithValue("email", "john@example.com")
            .hasFieldOrPropertyWithValue("name", "John");
    }
}
```

### Exception Assertions

```java
class ExceptionTest {
    
    @Test
    void shouldThrowException() {
        // Simple exception check
        assertThrows(IllegalArgumentException.class,
            () -> service.processInvalidData(null));
        
        // Check exception message
        Exception exception = assertThrows(IllegalArgumentException.class,
            () -> service.processInvalidData(null));
        
        assertEquals("Data cannot be null", exception.getMessage());
    }
    
    @Test
    void shouldNotThrowException() {
        assertDoesNotThrow(() -> service.processValidData("data"));
    }
    
    @Test
    void testExceptionWithAssertJ() {
        assertThatThrownBy(() -> service.processInvalidData(null))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessage("Data cannot be null")
            .hasMessageContaining("null");
    }
}
```

### Group Assertions

```java
@Test
void groupedAssertions() {
    User user = new User("john@example.com", "John", 25);
    
    assertAll("User properties",
        () -> assertEquals("john@example.com", user.getEmail()),
        () -> assertEquals("John", user.getName()),
        () -> assertEquals(25, user.getAge())
    );
    
    // All assertions executed, all failures reported
}
```

---

## ðŸ”§ Testing Service Layer

### Simple Service Test

```java
class UserService {
    
    public User createUser(String email, String name) {
        if (email == null || email.isEmpty()) {
            throw new IllegalArgumentException("Email cannot be empty");
        }
        
        User user = new User();
        user.setEmail(email);
        user.setName(name);
        user.setCreatedAt(LocalDateTime.now());
        
        return user;
    }
    
    public boolean isValidEmail(String email) {
        return email != null && email.contains("@");
    }
}

class UserServiceTest {
    
    private UserService userService;
    
    @BeforeEach
    void setup() {
        userService = new UserService();
    }
    
    @Test
    void shouldCreateUserWithValidData() {
        // Arrange
        String email = "john@example.com";
        String name = "John Doe";
        
        // Act
        User user = userService.createUser(email, name);
        
        // Assert
        assertNotNull(user);
        assertEquals(email, user.getEmail());
        assertEquals(name, user.getName());
        assertNotNull(user.getCreatedAt());
    }
    
    @Test
    void shouldThrowExceptionWhenEmailIsNull() {
        assertThrows(IllegalArgumentException.class,
            () -> userService.createUser(null, "John"));
    }
    
    @Test
    void shouldThrowExceptionWhenEmailIsEmpty() {
        assertThrows(IllegalArgumentException.class,
            () -> userService.createUser("", "John"));
    }
    
    @Test
    void shouldValidateCorrectEmail() {
        assertTrue(userService.isValidEmail("john@example.com"));
    }
    
    @Test
    void shouldRejectInvalidEmail() {
        assertFalse(userService.isValidEmail("invalid-email"));
        assertFalse(userService.isValidEmail(null));
    }
}
```

### Testing with Dependencies (Mocking)

```java
// Service with dependency
class OrderService {
    
    private final OrderRepository orderRepository;
    private final EmailService emailService;
    
    public OrderService(OrderRepository orderRepository, EmailService emailService) {
        this.orderRepository = orderRepository;
        this.emailService = emailService;
    }
    
    public Order createOrder(OrderRequest request) {
        Order order = new Order();
        order.setOrderNumber(generateOrderNumber());
        order.setItems(request.getItems());
        order.setTotal(calculateTotal(request.getItems()));
        
        Order savedOrder = orderRepository.save(order);
        emailService.sendOrderConfirmation(savedOrder);
        
        return savedOrder;
    }
    
    private String generateOrderNumber() {
        return "ORD-" + System.currentTimeMillis();
    }
    
    private BigDecimal calculateTotal(List<OrderItem> items) {
        return items.stream()
            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// Unit test with mocks
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {
    
    @Mock
    private OrderRepository orderRepository;
    
    @Mock
    private EmailService emailService;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    void shouldCreateOrderSuccessfully() {
        // Arrange
        OrderRequest request = new OrderRequest();
        request.setItems(Arrays.asList(
            new OrderItem("Product 1", new BigDecimal("10.00"), 2),
            new OrderItem("Product 2", new BigDecimal("15.00"), 1)
        ));
        
        Order savedOrder = new Order();
        savedOrder.setId(1L);
        savedOrder.setTotal(new BigDecimal("35.00"));
        
        when(orderRepository.save(any(Order.class))).thenReturn(savedOrder);
        
        // Act
        Order result = orderService.createOrder(request);
        
        // Assert
        assertNotNull(result);
        assertEquals(new BigDecimal("35.00"), result.getTotal());
        
        verify(orderRepository).save(any(Order.class));
        verify(emailService).sendOrderConfirmation(savedOrder);
    }
}
```

---

## ðŸŽ­ Mockito Fundamentals

### Creating Mocks

```java
class MockCreationTest {
    
    @Test
    void createMocksManually() {
        // Manual mock creation
        UserRepository userRepository = Mockito.mock(UserRepository.class);
        
        // Use mock
        when(userRepository.findById(1L)).thenReturn(Optional.of(new User()));
    }
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
    }
}

// Or use extension
@ExtendWith(MockitoExtension.class)
class MockWithExtensionTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    // No need for MockitoAnnotations.openMocks()
}
```

### Stubbing Methods

```java
@Test
void stubbingExamples() {
    UserRepository mock = mock(UserRepository.class);
    
    // Simple stubbing
    when(mock.findById(1L)).thenReturn(Optional.of(new User("John")));
    
    // Multiple calls
    when(mock.count())
        .thenReturn(1L)
        .thenReturn(2L)
        .thenReturn(3L);
    
    assertEquals(1L, mock.count());
    assertEquals(2L, mock.count());
    assertEquals(3L, mock.count());
    
    // Throw exception
    when(mock.findById(999L)).thenThrow(new UserNotFoundException());
    
    // Argument matchers
    when(mock.findByEmail(anyString())).thenReturn(Optional.of(new User()));
    when(mock.findByEmail(eq("john@example.com"))).thenReturn(Optional.of(new User("John")));
    
    // Void methods
    doNothing().when(mock).delete(any(User.class));
    doThrow(new RuntimeException()).when(mock).deleteById(999L);
}
```

### Verification

```java
@Test
void verificationExamples() {
    UserRepository mock = mock(UserRepository.class);
    UserService service = new UserService(mock);
    
    // Call method
    service.getUser(1L);
    
    // Verify method was called
    verify(mock).findById(1L);
    
    // Verify with times
    verify(mock, times(1)).findById(1L);
    verify(mock, never()).deleteById(anyLong());
    verify(mock, atLeastOnce()).findById(anyLong());
    verify(mock, atMost(3)).findById(anyLong());
    
    // Verify with argument matcher
    verify(mock).findById(eq(1L));
    verify(mock).findById(longThat(id -> id > 0));
    
    // Verify no more interactions
    verifyNoMoreInteractions(mock);
}
```

### Argument Captors

```java
@Test
void argumentCaptorExample() {
    EmailService emailService = mock(EmailService.class);
    OrderService orderService = new OrderService(emailService);
    
    Order order = new Order();
    order.setCustomerEmail("john@example.com");
    
    orderService.sendOrderConfirmation(order);
    
    // Capture argument
    ArgumentCaptor<Email> emailCaptor = ArgumentCaptor.forClass(Email.class);
    verify(emailService).send(emailCaptor.capture());
    
    Email capturedEmail = emailCaptor.getValue();
    assertEquals("john@example.com", capturedEmail.getTo());
    assertEquals("Order Confirmation", capturedEmail.getSubject());
}
```

---

## ðŸ”„ Parameterized Tests

### @ValueSource

```java
class ParameterizedTest {
    
    @ParameterizedTest
    @ValueSource(strings = {"racecar", "radar", "level"})
    void isPalindrome(String word) {
        assertTrue(StringUtils.isPalindrome(word));
    }
    
    @ParameterizedTest
    @ValueSource(ints = {1, 3, 5, 7, 9})
    void isOdd(int number) {
        assertTrue(number % 2 != 0);
    }
}
```

### @CsvSource

```java
@ParameterizedTest
@CsvSource({
    "1, 1, 2",
    "2, 3, 5",
    "10, 20, 30",
    "-5, 5, 0"
})
void shouldAddTwoNumbers(int a, int b, int expected) {
    Calculator calculator = new Calculator();
    assertEquals(expected, calculator.add(a, b));
}

@ParameterizedTest
@CsvSource({
    "john@example.com, true",
    "invalid-email, false",
    "'', false",
    ", false"
})
void shouldValidateEmail(String email, boolean expected) {
    EmailValidator validator = new EmailValidator();
    assertEquals(expected, validator.isValid(email));
}
```

### @MethodSource

```java
class MethodSourceTest {
    
    @ParameterizedTest
    @MethodSource("provideUserData")
    void shouldCreateUser(String email, String name, int age) {
        User user = new User(email, name, age);
        
        assertNotNull(user);
        assertEquals(email, user.getEmail());
        assertEquals(name, user.getName());
        assertEquals(age, user.getAge());
    }
    
    static Stream<Arguments> provideUserData() {
        return Stream.of(
            Arguments.of("john@example.com", "John", 25),
            Arguments.of("jane@example.com", "Jane", 30),
            Arguments.of("bob@example.com", "Bob", 35)
        );
    }
}
```

### @EnumSource

```java
enum Status {
    ACTIVE, INACTIVE, PENDING
}

class EnumSourceTest {
    
    @ParameterizedTest
    @EnumSource(Status.class)
    void shouldHandleAllStatuses(Status status) {
        StatusProcessor processor = new StatusProcessor();
        assertDoesNotThrow(() -> processor.process(status));
    }
    
    @ParameterizedTest
    @EnumSource(value = Status.class, names = {"ACTIVE", "PENDING"})
    void shouldHandleSpecificStatuses(Status status) {
        assertTrue(status == Status.ACTIVE || status == Status.PENDING);
    }
}
```

---

## ðŸŽ­ Test Doubles

### Dummy

```java
// Object passed but never actually used
@Test
void dummyExample() {
    UserRepository dummy = mock(UserRepository.class);
    // dummy never actually called
    Logger logger = new Logger(dummy);
    logger.log("Message");
}
```

### Stub

```java
// Provides canned answers to calls
@Test
void stubExample() {
    UserRepository stub = mock(UserRepository.class);
    when(stub.findById(anyLong())).thenReturn(Optional.of(new User()));
    
    // Always returns same User
    User user1 = stub.findById(1L).get();
    User user2 = stub.findById(2L).get();
}
```

### Spy

```java
// Real object with ability to stub specific methods
@Test
void spyExample() {
    UserService realService = new UserService();
    UserService spy = spy(realService);
    
    // Use real implementation
    User user = spy.createUser("john@example.com", "John");
    
    // Stub specific method
    when(spy.isAdmin(anyLong())).thenReturn(true);
    
    assertTrue(spy.isAdmin(1L));
}
```

### Mock

```java
// Fully programmable test double
@Test
void mockExample() {
    UserRepository mock = mock(UserRepository.class);
    
    // Program behavior
    when(mock.findById(1L)).thenReturn(Optional.of(new User("John")));
    when(mock.findById(2L)).thenThrow(new UserNotFoundException());
    
    // Verify interactions
    mock.findById(1L);
    verify(mock).findById(1L);
}
```

---

## ðŸ’¡ Testing Best Practices

### 1. Test One Thing

```java
// âœ… Good - Focused test
@Test
void shouldCalculateDiscountCorrectly() {
    PriceCalculator calculator = new PriceCalculator();
    BigDecimal price = new BigDecimal("100.00");
    
    BigDecimal discounted = calculator.applyDiscount(price, 10);
    
    assertEquals(new BigDecimal("90.00"), discounted);
}

// âŒ Bad - Testing multiple things
@Test
void testPriceCalculator() {
    PriceCalculator calculator = new PriceCalculator();
    
    // Testing discount
    assertEquals(new BigDecimal("90.00"),
        calculator.applyDiscount(new BigDecimal("100.00"), 10));
    
    // Testing tax
    assertEquals(new BigDecimal("110.00"),
        calculator.addTax(new BigDecimal("100.00"), 10));
    
    // Testing total
    assertEquals(new BigDecimal("200.00"),
        calculator.calculateTotal(items));
}
```

### 2. Descriptive Names

```java
// âœ… Good - Clear intent
@Test
void shouldReturnEmptyListWhenNoUsersExist() { }

@Test
void shouldThrowExceptionWhenEmailIsInvalid() { }

@Test
void shouldCalculateTotalWithTaxIncluded() { }

// âŒ Bad - Unclear
@Test
void test1() { }

@Test
void testUser() { }

@Test
void testMethod() { }
```

### 3. Don't Test Implementation Details

```java
// âœ… Good - Test behavior
@Test
void shouldReturnUserByEmail() {
    User user = userService.findByEmail("john@example.com");
    assertEquals("john@example.com", user.getEmail());
}

// âŒ Bad - Test implementation
@Test
void shouldCallRepositoryFindByEmailMethod() {
    userService.findByEmail("john@example.com");
    verify(repository).findByEmail("john@example.com");
    // This test will break if implementation changes
}
```

### 4. Use Test Fixtures

```java
// âœ… Good - Reusable setup
class UserServiceTest {
    
    private UserService userService;
    private User testUser;
    
    @BeforeEach
    void setup() {
        userService = new UserService();
        testUser = createTestUser();
    }
    
    private User createTestUser() {
        return User.builder()
            .email("john@example.com")
            .name("John Doe")
            .age(25)
            .build();
    }
    
    @Test
    void test1() {
        // Use testUser
    }
    
    @Test
    void test2() {
        // Use testUser
    }
}
```

### 5. Test Edge Cases

```java
@Test
void shouldHandleNullInput() {
    assertThrows(IllegalArgumentException.class,
        () -> service.process(null));
}

@Test
void shouldHandleEmptyString() {
    assertThrows(IllegalArgumentException.class,
        () -> service.process(""));
}

@Test
void shouldHandleVeryLargeNumber() {
    BigInteger large = new BigInteger("999999999999999999999");
    assertDoesNotThrow(() -> calculator.square(large));
}

@Test
void shouldHandleNegativeNumbers() {
    assertEquals(-10, calculator.multiply(-2, 5));
}
```

---

## ðŸŽ¤ Interview Questions

### Q1: What is a unit test?
**Answer:** Test that verifies a single unit of code (class/method) in isolation, with dependencies mocked.

### Q2: Difference between @Mock and @InjectMocks?
**Answer:**
- @Mock: Creates mock object
- @InjectMocks: Creates object and injects mocks into it

### Q3: What is the AAA pattern?
**Answer:** Arrange (setup), Act (execute), Assert (verify) - structure for organizing tests.

### Q4: What is @ParameterizedTest?
**Answer:** Runs same test with different parameters:
```java
@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void test(int number) { }
```

### Q5: How to verify method was called?
**Answer:**
```java
verify(mock).methodName(arguments);
verify(mock, times(2)).methodName();
```

### Q6: What is ArgumentCaptor?
**Answer:** Captures arguments passed to mocked methods for assertions:
```java
ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class);
verify(mock).save(captor.capture());
assertEquals("John", captor.getValue().getName());
```

### Q7: Difference between Mock and Spy?
**Answer:**
- Mock: Completely fake, all methods must be stubbed
- Spy: Real object, can stub specific methods, others use real implementation

### Q8: What is @BeforeEach?
**Answer:** Method runs before each test method, used for test setup.

### Q9: How to test exceptions?
**Answer:**
```java
assertThrows(Exception.class, () -> method());
```

### Q10: What is @DisplayName?
**Answer:** Provides custom display name for tests in reports:
```java
@Test
@DisplayName("Should add two numbers correctly")
```

### Q11: What is verifyNoMoreInteractions()?
**Answer:** Verifies no other methods were called on mock after verified interactions.

### Q12: How to stub void methods?
**Answer:**
```java
doNothing().when(mock).voidMethod();
doThrow(Exception.class).when(mock).voidMethod();
```

### Q13: What is @Nested?
**Answer:** Groups related tests together in nested classes for better organization.

### Q14: Difference between assertEquals and assertSame?
**Answer:**
- assertEquals: Checks equality (equals() method)
- assertSame: Checks same reference (== comparison)

### Q15: What is assertAll()?
**Answer:** Groups multiple assertions, all execute even if some fail:
```java
assertAll(
    () -> assertEquals(expected1, actual1),
    () -> assertEquals(expected2, actual2)
);
```

### Q16: How to create mock manually?
**Answer:**
```java
UserRepository mock = Mockito.mock(UserRepository.class);
```

### Q17: What is @ExtendWith(MockitoExtension.class)?
**Answer:** JUnit 5 extension that initializes Mockito annotations (@Mock, @InjectMocks).

### Q18: How to test private methods?
**Answer:** Don't test directly - test through public methods. If needed, consider refactoring.

### Q19: What is when().thenReturn()?
**Answer:** Stubbing syntax to define mock behavior:
```java
when(mock.method()).thenReturn(value);
```

### Q20: Best practice for test independence?
**Answer:** Each test should be runnable alone, use @BeforeEach for setup, no shared mutable state.

---

## ðŸ“š Summary

### Unit Test Structure

```java
@ExtendWith(MockitoExtension.class)
class ServiceTest {
    
    @Mock
    private Repository repository;
    
    @InjectMocks
    private Service service;
    
    @Test
    void shouldDoSomething() {
        // Arrange
        when(repository.findById(1L)).thenReturn(Optional.of(data));
        
        // Act
        Result result = service.process(1L);
        
        // Assert
        assertNotNull(result);
        verify(repository).findById(1L);
    }
}
```

### Key Annotations

| Annotation | Purpose |
|------------|---------|
| `@Test` | Marks test method |
| `@BeforeEach` | Setup before each test |
| `@AfterEach` | Cleanup after each test |
| `@Mock` | Create mock object |
| `@InjectMocks` | Inject mocks into tested object |
| `@ParameterizedTest` | Run test with multiple parameters |
| `@DisplayName` | Custom test name |
| `@Nested` | Group related tests |

### Mockito Quick Reference

```java
// Create mock
Mock mock = mock(Mock.class);

// Stub
when(mock.method()).thenReturn(value);
when(mock.method()).thenThrow(exception);

// Verify
verify(mock).method();
verify(mock, times(2)).method();
verify(mock, never()).method();

// Argument matchers
any(), anyString(), anyLong(), eq(value)

// Capture arguments
ArgumentCaptor<Type> captor = ArgumentCaptor.forClass(Type.class);
verify(mock).method(captor.capture());
```

**Next:** MockMvc â†’

