# ğŸ§ª Testing Fundamentals - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [Testing Pyramid](#testing-pyramid)
- [Spring Boot Test Architecture](#spring-boot-test-architecture)
- [Test Annotations](#test-annotations)
- [Test Configuration](#test-configuration)
- [Test Profiles](#test-profiles)
- [Test Properties](#test-properties)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**Testing** is crucial for building reliable, maintainable Spring Boot applications. Spring Boot provides comprehensive testing support with auto-configuration, test slices, and integration with popular testing frameworks.

### Why Testing Matters

```
Quality Assurance:
âœ… Catch bugs early
âœ… Prevent regressions
âœ… Ensure expected behavior
âœ… Document functionality

Confidence:
âœ… Refactor safely
âœ… Deploy with confidence
âœ… Faster development cycles
âœ… Reduced production issues

Maintainability:
âœ… Living documentation
âœ… Easier onboarding
âœ… Code quality improvement
âœ… Design feedback
```

### Testing Philosophy

```
Fast Feedback Loop:
Unit Tests (milliseconds) â†’ Integration Tests (seconds) â†’ E2E Tests (minutes)

Test Isolation:
Each test should be independent and repeatable

Realistic Testing:
Test behavior, not implementation
```

---

## ğŸ”º Testing Pyramid

### Test Distribution

```
       /\
      /E2E\        10% - End-to-End Tests
     /______\
    /        \
   /Integration\ 20% - Integration Tests
  /__________  \
 /              \
/   Unit Tests   \ 70% - Unit Tests
/________________\
```

### Test Types

| Test Type | Purpose | Speed | Coverage | Tools |
|-----------|---------|-------|----------|-------|
| **Unit Tests** | Test individual methods/classes | âš¡ Fast | High | JUnit, Mockito |
| **Integration Tests** | Test component interactions | ğŸ¢ Slower | Medium | Spring Test, TestContainers |
| **E2E Tests** | Test complete user flows | ğŸŒ Slowest | Low | Selenium, REST Assured |

### Unit Tests

```java
// Test single method in isolation
@Test
void shouldCalculateTotal() {
    // Given
    OrderService orderService = new OrderService();
    Order order = new Order();
    order.addItem(new Item(10.00, 2));
    order.addItem(new Item(15.00, 1));
    
    // When
    BigDecimal total = orderService.calculateTotal(order);
    
    // Then
    assertEquals(new BigDecimal("35.00"), total);
}
```

### Integration Tests

```java
// Test multiple components together
@SpringBootTest
@AutoConfigureMockMvc
class OrderControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void shouldCreateOrder() throws Exception {
        mockMvc.perform(post("/api/orders")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"items\":[{\"productId\":1,\"quantity\":2}]}"))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.total").value(35.00));
    }
}
```

### E2E Tests

```java
// Test complete user journey
@Test
void userCanPlaceOrder() {
    // Login
    loginPage.login("user@example.com", "password");
    
    // Browse products
    productPage.searchProduct("laptop");
    
    // Add to cart
    productPage.addToCart();
    
    // Checkout
    cartPage.proceedToCheckout();
    checkoutPage.enterPaymentDetails();
    checkoutPage.placeOrder();
    
    // Verify
    assertTrue(confirmationPage.isOrderConfirmed());
}
```

---

## ğŸ—ï¸ Spring Boot Test Architecture

### Dependency

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

### Included Libraries

```
spring-boot-starter-test includes:

âœ… JUnit 5 - Testing framework
âœ… Spring Test - Spring testing support
âœ… AssertJ - Fluent assertions
âœ… Hamcrest - Matcher library
âœ… Mockito - Mocking framework
âœ… JSONassert - JSON assertions
âœ… JsonPath - JSON path expressions
```

### Test Structure

```
src/
â”œâ”€â”€ main/
â”‚   â””â”€â”€ java/
â”‚       â””â”€â”€ com/example/demo/
â”‚           â”œâ”€â”€ controller/
â”‚           â”œâ”€â”€ service/
â”‚           â”œâ”€â”€ repository/
â”‚           â””â”€â”€ model/
â””â”€â”€ test/
    â”œâ”€â”€ java/
    â”‚   â””â”€â”€ com/example/demo/
    â”‚       â”œâ”€â”€ controller/
    â”‚       â”‚   â””â”€â”€ UserControllerTest.java
    â”‚       â”œâ”€â”€ service/
    â”‚       â”‚   â””â”€â”€ UserServiceTest.java
    â”‚       â””â”€â”€ repository/
    â”‚           â””â”€â”€ UserRepositoryTest.java
    â””â”€â”€ resources/
        â”œâ”€â”€ application-test.properties
        â””â”€â”€ test-data.sql
```

---

## ğŸ·ï¸ Test Annotations

### Core Test Annotations

```java
// 1. @SpringBootTest - Full application context
@SpringBootTest
class FullContextTest {
    @Autowired
    private UserService userService;
    
    @Test
    void testWithFullContext() {
        // All beans loaded
    }
}

// 2. @WebMvcTest - Only web layer
@WebMvcTest(UserController.class)
class WebLayerTest {
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
}

// 3. @DataJpaTest - Only JPA components
@DataJpaTest
class RepositoryTest {
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
}

// 4. @RestClientTest - REST client testing
@RestClientTest(ExternalApiClient.class)
class RestClientTest {
    @Autowired
    private ExternalApiClient client;
    
    @Autowired
    private MockRestServiceServer server;
}

// 5. @JsonTest - JSON serialization testing
@JsonTest
class JsonSerializationTest {
    @Autowired
    private JacksonTester<User> json;
    
    @Test
    void testSerialization() throws Exception {
        User user = new User("John", "john@example.com");
        assertThat(json.write(user)).extractingJsonPathStringValue("$.name")
            .isEqualTo("John");
    }
}
```

### Lifecycle Annotations

```java
class TestLifecycle {
    
    @BeforeAll
    static void setupOnce() {
        // Runs once before all tests
        System.out.println("Before all tests");
    }
    
    @BeforeEach
    void setupEach() {
        // Runs before each test
        System.out.println("Before each test");
    }
    
    @Test
    void test1() {
        System.out.println("Test 1");
    }
    
    @Test
    void test2() {
        System.out.println("Test 2");
    }
    
    @AfterEach
    void teardownEach() {
        // Runs after each test
        System.out.println("After each test");
    }
    
    @AfterAll
    static void teardownOnce() {
        // Runs once after all tests
        System.out.println("After all tests");
    }
}

// Output:
// Before all tests
// Before each test
// Test 1
// After each test
// Before each test
// Test 2
// After each test
// After all tests
```

### Conditional Test Execution

```java
class ConditionalTests {
    
    @Test
    @EnabledOnOs(OS.LINUX)
    void onlyOnLinux() {
        // Runs only on Linux
    }
    
    @Test
    @EnabledOnJre(JRE.JAVA_17)
    void onlyOnJava17() {
        // Runs only on Java 17
    }
    
    @Test
    @EnabledIf("customCondition")
    void conditionalTest() {
        // Runs if condition is true
    }
    
    boolean customCondition() {
        return true;
    }
    
    @Test
    @DisabledOnOs(OS.WINDOWS)
    void notOnWindows() {
        // Disabled on Windows
    }
    
    @Test
    @Disabled("Not ready yet")
    void skippedTest() {
        // Always skipped
    }
}
```

---

## âš™ï¸ Test Configuration

### Application Context Caching

```java
// Context is cached and reused
@SpringBootTest
class Test1 {
    // Same configuration = cached context
}

@SpringBootTest
class Test2 {
    // Reuses context from Test1
}

@SpringBootTest(properties = "spring.profiles.active=test")
class Test3 {
    // Different configuration = new context
}
```

### Custom Test Configuration

```java
@TestConfiguration
public class TestConfig {
    
    @Bean
    @Primary
    public UserService testUserService() {
        return new TestUserService();
    }
    
    @Bean
    public TestDataGenerator testDataGenerator() {
        return new TestDataGenerator();
    }
}

@SpringBootTest
@Import(TestConfig.class)
class MyTest {
    @Autowired
    private UserService userService; // Uses TestUserService
    
    @Autowired
    private TestDataGenerator dataGenerator;
}
```

### Mock Beans

```java
@SpringBootTest
class ServiceTest {
    
    @MockBean
    private UserRepository userRepository;
    
    @Autowired
    private UserService userService; // Injected with mocked repository
    
    @Test
    void testWithMockedDependency() {
        // Arrange
        User user = new User("John");
        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
        
        // Act
        User result = userService.getUser(1L);
        
        // Assert
        assertEquals("John", result.getName());
    }
}
```

### Spy Beans

```java
@SpringBootTest
class SpyTest {
    
    @SpyBean
    private UserService userService;
    
    @Test
    void testWithSpiedBean() {
        // Real method called unless stubbed
        when(userService.isAdmin(anyLong())).thenReturn(true);
        
        // This calls real method
        User user = userService.getUser(1L);
        
        // This uses stubbed behavior
        boolean admin = userService.isAdmin(1L);
        assertTrue(admin);
    }
}
```

---

## ğŸ“‚ Test Profiles

### Profile Configuration

```yaml
# application.yml
spring:
  profiles:
    active: dev

---
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
```

### Using Test Profiles

```java
@SpringBootTest
@ActiveProfiles("test")
class TestWithProfile {
    
    @Autowired
    private DataSource dataSource;
    
    @Test
    void testUsesTestDatabase() {
        // Uses H2 in-memory database from test profile
    }
}
```

### Multiple Profiles

```java
@SpringBootTest
@ActiveProfiles({"test", "mock-external-services"})
class TestWithMultipleProfiles {
    // Uses both test and mock-external-services profiles
}
```

---

## ğŸ”§ Test Properties

### Inline Properties

```java
@SpringBootTest(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "app.feature.enabled=true",
    "app.external.api.url=http://localhost:8080"
})
class TestWithProperties {
    
    @Value("${app.feature.enabled}")
    private boolean featureEnabled;
    
    @Test
    void testWithCustomProperties() {
        assertTrue(featureEnabled);
    }
}
```

### Property Source

```java
@SpringBootTest
@TestPropertySource(properties = {
    "spring.jpa.hibernate.ddl-auto=create-drop",
    "logging.level.com.example=DEBUG"
})
class TestWithPropertySource {
}

// Or from file
@SpringBootTest
@TestPropertySource(locations = "classpath:test.properties")
class TestWithPropertyFile {
}
```

### Dynamic Properties

```java
@SpringBootTest
class DynamicPropertiesTest {
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("app.external.url", () -> "http://localhost:9999");
        registry.add("app.api.key", () -> "test-key-123");
    }
    
    @Value("${app.external.url}")
    private String externalUrl;
    
    @Test
    void testWithDynamicProperties() {
        assertEquals("http://localhost:9999", externalUrl);
    }
}
```

---

## ğŸ¯ Test Slicing

### Web Layer Testing (@WebMvcTest)

```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    void testGetUser() throws Exception {
        when(userService.getUser(1L))
            .thenReturn(new User(1L, "John"));
        
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value("John"));
    }
}
```

### Repository Layer Testing (@DataJpaTest)

```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Test
    void testFindByEmail() {
        // Arrange
        User user = new User("john@example.com", "John");
        entityManager.persist(user);
        entityManager.flush();
        
        // Act
        Optional<User> found = userRepository.findByEmail("john@example.com");
        
        // Assert
        assertTrue(found.isPresent());
        assertEquals("John", found.get().getName());
    }
}
```

---

## ğŸ’¡ Best Practices

### 1. Follow AAA Pattern

```java
// âœ… Good - Arrange, Act, Assert
@Test
void shouldCalculateDiscount() {
    // Arrange
    PriceCalculator calculator = new PriceCalculator();
    BigDecimal price = new BigDecimal("100.00");
    
    // Act
    BigDecimal discounted = calculator.applyDiscount(price, 10);
    
    // Assert
    assertEquals(new BigDecimal("90.00"), discounted);
}

// âŒ Bad - Mixed concerns
@Test
void test() {
    BigDecimal result = new PriceCalculator()
        .applyDiscount(new BigDecimal("100.00"), 10);
    assertEquals(new BigDecimal("90.00"), result);
}
```

### 2. Descriptive Test Names

```java
// âœ… Good - Clear intent
@Test
void shouldReturnUserWhenValidIdProvided() { }

@Test
void shouldThrowExceptionWhenUserNotFound() { }

@Test
void shouldCalculateTotalWithTaxIncluded() { }

// âŒ Bad - Unclear
@Test
void test1() { }

@Test
void testGetUser() { }

@Test
void testMethod() { }
```

### 3. One Assertion Per Test (Generally)

```java
// âœ… Good - Focused test
@Test
void shouldReturnCorrectUserName() {
    User user = userService.getUser(1L);
    assertEquals("John", user.getName());
}

@Test
void shouldReturnCorrectUserEmail() {
    User user = userService.getUser(1L);
    assertEquals("john@example.com", user.getEmail());
}

// âš ï¸ Acceptable - Related assertions
@Test
void shouldReturnCompleteUserDetails() {
    User user = userService.getUser(1L);
    assertAll(
        () -> assertEquals("John", user.getName()),
        () -> assertEquals("john@example.com", user.getEmail()),
        () -> assertNotNull(user.getCreatedAt())
    );
}
```

### 4. Test Independence

```java
// âœ… Good - Independent tests
@BeforeEach
void setup() {
    userRepository.deleteAll();
}

@Test
void test1() {
    User user = createUser("user1");
    // Test doesn't depend on other tests
}

@Test
void test2() {
    User user = createUser("user2");
    // Can run in any order
}

// âŒ Bad - Tests depend on each other
static User sharedUser;

@Test
void test1_createUser() {
    sharedUser = createUser("user1");
}

@Test
void test2_updateUser() {
    // Depends on test1
    sharedUser.setName("Updated");
}
```

### 5. Use Test Fixtures

```java
// âœ… Good - Reusable test data
public class TestFixtures {
    
    public static User createTestUser() {
        return User.builder()
            .name("John Doe")
            .email("john@example.com")
            .role(Role.USER)
            .build();
    }
    
    public static Order createTestOrder() {
        return Order.builder()
            .orderNumber("ORD-001")
            .status(OrderStatus.PENDING)
            .build();
    }
}

@Test
void testWithFixture() {
    User user = TestFixtures.createTestUser();
    // Use user in test
}
```

### 6. Test Edge Cases

```java
@Test
void shouldHandleNullInput() {
    assertThrows(IllegalArgumentException.class,
        () -> service.process(null));
}

@Test
void shouldHandleEmptyList() {
    List<User> result = service.getUsers(Collections.emptyList());
    assertTrue(result.isEmpty());
}

@Test
void shouldHandleLargeInput() {
    List<Integer> large = IntStream.range(0, 10000)
        .boxed()
        .collect(Collectors.toList());
    assertDoesNotThrow(() -> service.process(large));
}
```

---

## ğŸ¤ Interview Questions

### Q1: What is the testing pyramid?
**Answer:** 70% unit tests (fast, isolated), 20% integration tests (component interactions), 10% E2E tests (complete flows).

### Q2: What does spring-boot-starter-test include?
**Answer:** JUnit 5, Spring Test, Mockito, AssertJ, Hamcrest, JSONassert, JsonPath.

### Q3: Difference between @SpringBootTest and @WebMvcTest?
**Answer:**
- @SpringBootTest: Full application context, all beans
- @WebMvcTest: Only web layer, controllers

### Q4: What is @MockBean?
**Answer:** Creates mock of a bean and adds it to application context, replacing any existing bean of same type.

### Q5: What is @DataJpaTest?
**Answer:** Test slice for JPA repositories, configures in-memory database, transaction management.

### Q6: How to set test properties?
**Answer:**
```java
@SpringBootTest(properties = "app.feature=true")
// Or @TestPropertySource
```

### Q7: What is @ActiveProfiles?
**Answer:** Activates specific Spring profiles for tests:
```java
@ActiveProfiles("test")
```

### Q8: What is TestEntityManager?
**Answer:** JPA entity manager for tests, provides methods to persist/flush/find entities in test transactions.

### Q9: What is @DynamicPropertySource?
**Answer:** Adds properties to Environment programmatically:
```java
@DynamicPropertySource
static void props(DynamicPropertyRegistry reg) {
    reg.add("key", () -> "value");
}
```

### Q10: Difference between @Mock and @MockBean?
**Answer:**
- @Mock: Mockito annotation, creates mock (not Spring-managed)
- @MockBean: Spring Boot annotation, creates mock bean in context

### Q11: What is context caching?
**Answer:** Spring caches application context between tests with same configuration to improve performance.

### Q12: How to test exceptions?
**Answer:**
```java
assertThrows(Exception.class, () -> service.method());
```

### Q13: What is @TestConfiguration?
**Answer:** Configuration class for tests, provides additional beans or overrides.

### Q14: What is @SpyBean?
**Answer:** Creates spy of existing bean, allows stubbing specific methods while keeping real implementation.

### Q15: Best practices for test naming?
**Answer:** Use descriptive names: `shouldReturnUserWhenValidIdProvided`, `shouldThrowExceptionWhenUserNotFound`

### Q16: What is AAA pattern?
**Answer:** Arrange (setup), Act (execute), Assert (verify) - structure for clear tests.

### Q17: Should tests be independent?
**Answer:** Yes, each test should be runnable in any order without dependencies on other tests.

### Q18: How to test private methods?
**Answer:** Don't test directly - test through public methods. If needed, consider if method should be public or in separate class.

### Q19: What is @Disabled?
**Answer:** Marks test as disabled, skips execution:
```java
@Test
@Disabled("Not ready")
void test() { }
```

### Q20: How many assertions per test?
**Answer:** Generally one, but related assertions can be grouped with assertAll().

---

## ğŸ“š Summary

### Test Annotations Quick Reference

| Annotation | Purpose | Context |
|------------|---------|---------|
| `@SpringBootTest` | Full integration test | Entire application |
| `@WebMvcTest` | Web layer test | Controllers only |
| `@DataJpaTest` | Repository test | JPA components |
| `@RestClientTest` | REST client test | REST clients |
| `@JsonTest` | JSON serialization | Jackson/Gson |
| `@MockBean` | Mock bean | Replace bean in context |
| `@SpyBean` | Spy bean | Partial mock |
| `@ActiveProfiles` | Activate profiles | Test profiles |
| `@TestPropertySource` | Test properties | Custom properties |

### Testing Pyramid

```
Write tests at the right level:
- Unit tests: Fast, isolated, many
- Integration tests: Realistic, fewer
- E2E tests: Complete flows, minimal
```

### Key Takeaways

1. **70% Unit Tests**: Fast, isolated, test single components
2. **20% Integration Tests**: Test component interactions
3. **10% E2E Tests**: Test complete user flows
4. **Use Test Slices**: @WebMvcTest, @DataJpaTest for focused testing
5. **Mock Dependencies**: @MockBean for external dependencies
6. **Test Profiles**: Separate configuration for tests
7. **AAA Pattern**: Arrange, Act, Assert structure
8. **Independent Tests**: No dependencies between tests

**Next:** Unit Testing â†’

