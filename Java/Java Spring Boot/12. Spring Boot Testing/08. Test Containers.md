# üê≥ TestContainers - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [What is TestContainers](#what-is-testcontainers)
- [Basic Setup](#basic-setup)
- [Database Containers](#database-containers)
- [Spring Boot Integration](#spring-boot-integration)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**TestContainers** is a Java library that provides lightweight, throwaway Docker containers for integration testing.

### Why TestContainers?

```
Benefits:
‚úÖ Real database/service instances
‚úÖ Consistent test environment
‚úÖ Isolated test execution
‚úÖ No shared test database
‚úÖ Test against production DB
‚úÖ Automatic container lifecycle
‚úÖ CI/CD friendly
```

### TestContainers vs Embedded Database

| Feature | TestContainers | Embedded Database |
|---------|----------------|-------------------|
| **Database** | Real (PostgreSQL, MySQL) | In-memory (H2) |
| **Accuracy** | Production-like | Approximate |
| **Features** | All DB features | Limited |
| **Speed** | Slower (2-5s startup) | Faster (< 1s) |
| **Setup** | Docker required | No setup |
| **Use Case** | Integration tests | Unit tests |

---

## üìö What is TestContainers

### Architecture

```
Test Execution:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  JUnit Test                     ‚îÇ
‚îÇ  ‚îú‚îÄ @Testcontainers            ‚îÇ
‚îÇ  ‚îú‚îÄ @Container                  ‚îÇ
‚îÇ  ‚îî‚îÄ Test Methods                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  TestContainers Library         ‚îÇ
‚îÇ  ‚îú‚îÄ Container Management        ‚îÇ
‚îÇ  ‚îú‚îÄ Docker Client               ‚îÇ
‚îÇ  ‚îî‚îÄ Lifecycle Control           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Docker Engine                  ‚îÇ
‚îÇ  ‚îú‚îÄ PostgreSQL Container        ‚îÇ
‚îÇ  ‚îú‚îÄ MySQL Container             ‚îÇ
‚îÇ  ‚îî‚îÄ Other Containers            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Lifecycle

```
1. Before All Tests:
   - Start container
   - Wait for readiness
   - Configure connection

2. During Tests:
   - Execute tests
   - Use container

3. After All Tests:
   - Stop container
   - Remove container
   - Cleanup resources
```

---

## üöÄ Basic Setup

### Maven Dependencies

```xml
<dependencies>
    <!-- TestContainers Core -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>testcontainers</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
    
    <!-- JUnit 5 Support -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
    
    <!-- PostgreSQL Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>postgresql</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
    
    <!-- MySQL Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>mysql</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### Simple Example

```java
@Testcontainers
class SimpleContainerTest {
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine");
    
    @Test
    void shouldStartContainer() {
        assertThat(postgres.isRunning()).isTrue();
        assertThat(postgres.getJdbcUrl()).isNotNull();
    }
}
```

---

## üóÑÔ∏è Database Containers

### PostgreSQL Container

```java
@Testcontainers
@SpringBootTest
class PostgreSQLContainerTest {
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldSaveUser() {
        User user = new User("John", "john@example.com");
        
        User saved = userRepository.save(user);
        
        assertThat(saved.getId()).isNotNull();
        assertThat(userRepository.findById(saved.getId())).isPresent();
    }
}
```

### MySQL Container

```java
@Testcontainers
@SpringBootTest
class MySQLContainerTest {
    
    @Container
    private static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUseMySQL() {
        User user = userRepository.save(new User("John", "john@example.com"));
        assertThat(user.getId()).isNotNull();
    }
}
```

### MongoDB Container

```java
@Testcontainers
@SpringBootTest
class MongoDBContainerTest {
    
    @Container
    private static MongoDBContainer mongodb = new MongoDBContainer("mongo:7.0")
        .withExposedPorts(27017);
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongodb::getReplicaSetUrl);
    }
    
    @Autowired
    private MongoTemplate mongoTemplate;
    
    @Test
    void shouldSaveDocument() {
        User user = new User("John", "john@example.com");
        
        User saved = mongoTemplate.save(user);
        
        assertThat(saved.getId()).isNotNull();
    }
}
```

### Redis Container

```java
@Testcontainers
@SpringBootTest
class RedisContainerTest {
    
    @Container
    private static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
        .withExposedPorts(6379);
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.redis.host", redis::getHost);
        registry.add("spring.redis.port", redis::getFirstMappedPort);
    }
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Test
    void shouldSetAndGetValue() {
        redisTemplate.opsForValue().set("key", "value");
        
        String value = redisTemplate.opsForValue().get("key");
        
        assertThat(value).isEqualTo("value");
    }
}
```

---

## üå± Spring Boot Integration

### Base Test Class

```java
@Testcontainers
@SpringBootTest
public abstract class BaseIntegrationTest {
    
    @Container
    protected static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test")
        .withReuse(true);  // Reuse container across tests
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
}
```

### Extending Base Test

```java
class UserRepositoryTest extends BaseIntegrationTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldSaveUser() {
        User user = userRepository.save(new User("John", "john@example.com"));
        assertThat(user.getId()).isNotNull();
    }
}
```

### Multiple Containers

```java
@Testcontainers
@SpringBootTest
class MultipleContainersTest {
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine");
    
    @Container
    private static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
        .withExposedPorts(6379);
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        // PostgreSQL
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        
        // Redis
        registry.add("spring.redis.host", redis::getHost);
        registry.add("spring.redis.port", redis::getFirstMappedPort);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Test
    void shouldUseBothContainers() {
        // Use PostgreSQL
        User user = userRepository.save(new User("John", "john@example.com"));
        
        // Use Redis
        redisTemplate.opsForValue().set("user:" + user.getId(), user.getName());
        
        assertThat(redisTemplate.opsForValue().get("user:" + user.getId()))
            .isEqualTo("John");
    }
}
```

### Docker Compose

```java
@Testcontainers
@SpringBootTest
class DockerComposeTest {
    
    @Container
    private static DockerComposeContainer<?> compose = new DockerComposeContainer<>(
        new File("src/test/resources/docker-compose-test.yml")
    )
        .withExposedService("postgres", 5432)
        .withExposedService("redis", 6379);
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        String postgresHost = compose.getServiceHost("postgres", 5432);
        Integer postgresPort = compose.getServicePort("postgres", 5432);
        
        registry.add("spring.datasource.url", 
            () -> "jdbc:postgresql://" + postgresHost + ":" + postgresPort + "/testdb");
        
        String redisHost = compose.getServiceHost("redis", 6379);
        Integer redisPort = compose.getServicePort("redis", 6379);
        
        registry.add("spring.redis.host", () -> redisHost);
        registry.add("spring.redis.port", () -> redisPort);
    }
}
```

---

## üöÄ Advanced Features

### Init Scripts

```java
@Testcontainers
@SpringBootTest
class InitScriptTest {
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withInitScript("init.sql");  // Runs SQL on startup
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldHaveInitialData() {
        // init.sql created test data
        List<User> users = userRepository.findAll();
        assertThat(users).isNotEmpty();
    }
}
```

### Network Configuration

```java
@Testcontainers
class NetworkTest {
    
    private static Network network = Network.newNetwork();
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withNetwork(network)
        .withNetworkAliases("postgres");
    
    @Container
    private static GenericContainer<?> app = new GenericContainer<>("myapp:latest")
        .withNetwork(network)
        .withEnv("DB_HOST", "postgres")
        .dependsOn(postgres);
    
    @Test
    void shouldCommunicateOverNetwork() {
        assertThat(app.isRunning()).isTrue();
    }
}
```

### Wait Strategies

```java
@Testcontainers
class WaitStrategyTest {
    
    @Container
    private static GenericContainer<?> app = new GenericContainer<>("myapp:latest")
        .withExposedPorts(8080)
        .waitingFor(Wait.forHttp("/actuator/health")
            .forStatusCode(200)
            .withStartupTimeout(Duration.ofMinutes(2)));
    
    @Test
    void shouldWaitForHealthCheck() {
        assertThat(app.isRunning()).isTrue();
    }
}
```

### Container Reuse

```java
@Testcontainers
class ReuseContainerTest {
    
    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
        .withReuse(true);  // Reuse across test runs
    
    // Container won't be stopped after tests
    // Significantly speeds up repeated test runs
    // Requires: testcontainers.reuse.enable=true in ~/.testcontainers.properties
}
```

### Custom Container

```java
class CustomPostgreSQLContainer extends PostgreSQLContainer<CustomPostgreSQLContainer> {
    
    private static final String IMAGE_VERSION = "postgres:15-alpine";
    
    public CustomPostgreSQLContainer() {
        super(IMAGE_VERSION);
        this.withDatabaseName("testdb");
        this.withUsername("test");
        this.withPassword("test");
        this.withInitScript("schema.sql");
    }
}

@Testcontainers
@SpringBootTest
class CustomContainerTest {
    
    @Container
    private static CustomPostgreSQLContainer postgres = new CustomPostgreSQLContainer();
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
}
```

### Singleton Container

```java
public class PostgreSQLContainerSingleton {
    
    private static PostgreSQLContainer<?> container;
    
    public static PostgreSQLContainer<?> getInstance() {
        if (container == null) {
            container = new PostgreSQLContainer<>("postgres:15-alpine")
                .withDatabaseName("testdb")
                .withUsername("test")
                .withPassword("test");
            container.start();
        }
        return container;
    }
}

@SpringBootTest
class SingletonContainerTest {
    
    private static PostgreSQLContainer<?> postgres = PostgreSQLContainerSingleton.getInstance();
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
}
```

---

## üí° Best Practices

### 1. Reuse Containers

```java
// ‚úÖ Good - Reuse container
@Container
private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
    .withReuse(true);

// ‚ùå Bad - New container every time
@Container
private PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine");
```

### 2. Use Specific Versions

```java
// ‚úÖ Good - Specific version
new PostgreSQLContainer<>("postgres:15-alpine");

// ‚ùå Bad - Latest tag (unpredictable)
new PostgreSQLContainer<>("postgres:latest");
```

### 3. Share Container Across Tests

```java
// ‚úÖ Good - Static container
@Testcontainers
@SpringBootTest
class UserRepositoryTest {
    @Container
    private static PostgreSQLContainer<?> postgres = ...;
}

// ‚ùå Bad - Instance container (slower)
@Testcontainers
@SpringBootTest
class UserRepositoryTest {
    @Container
    private PostgreSQLContainer<?> postgres = ...;  // New container per test class
}
```

### 4. Use Base Test Class

```java
// ‚úÖ Good - Centralized configuration
public abstract class BaseIntegrationTest {
    @Container
    protected static PostgreSQLContainer<?> postgres = ...;
}

class UserTest extends BaseIntegrationTest { }
class OrderTest extends BaseIntegrationTest { }

// ‚ùå Bad - Duplicate configuration
class UserTest {
    @Container
    private static PostgreSQLContainer<?> postgres = ...;
}

class OrderTest {
    @Container
    private static PostgreSQLContainer<?> postgres = ...;
}
```

### 5. Clean Data Between Tests

```java
// ‚úÖ Good - Clean data
@SpringBootTest
@Transactional
class UserRepositoryTest extends BaseIntegrationTest {
    // Transaction rolled back after each test
}

// Or
@AfterEach
void cleanup() {
    userRepository.deleteAll();
}
```

---

## üé§ Interview Questions

### Q1: What is TestContainers?
**Answer:** A Java library that provides throwaway Docker containers for integration testing.

### Q2: Why use TestContainers?
**Answer:** To test against real databases/services instead of in-memory alternatives, ensuring production-like environment.

### Q3: What is @Testcontainers annotation?
**Answer:** JUnit 5 extension that manages container lifecycle (start/stop) automatically.

### Q4: What is @Container annotation?
**Answer:** Marks a field as a container that should be managed by TestContainers.

### Q5: Difference between static and instance @Container?
**Answer:**
- Static: One container for all tests in class (faster)
- Instance: New container per test method (slower, isolated)

### Q6: What is @DynamicPropertySource?
**Answer:** Adds properties to Spring environment after container starts (for dynamic JDBC URL, port, etc.)

### Q7: Can you reuse containers across test runs?
**Answer:** Yes, using `.withReuse(true)` and enabling in testcontainers.properties.

### Q8: How to run init scripts?
**Answer:** Use `.withInitScript("script.sql")` when creating container.

### Q9: What databases are supported?
**Answer:** PostgreSQL, MySQL, MongoDB, Redis, Kafka, Elasticsearch, and many more.

### Q10: Do you need Docker installed?
**Answer:** Yes, TestContainers requires Docker to be running.

### Q11: How to configure multiple containers?
**Answer:** Create multiple @Container fields or use DockerComposeContainer.

### Q12: What is DockerComposeContainer?
**Answer:** Container that runs docker-compose.yml file for complex multi-container setups.

### Q13: How to wait for container readiness?
**Answer:** Use wait strategies: `waitingFor(Wait.forHttp(...))` or similar.

### Q14: Can containers communicate with each other?
**Answer:** Yes, using Network: create network and assign containers to it.

### Q15: How to access container ports?
**Answer:** Use `container.getFirstMappedPort()` or `container.getMappedPort(originalPort)`.

### Q16: What is container reuse benefit?
**Answer:** Significantly faster test execution by not recreating containers.

### Q17: How to customize container image?
**Answer:** Extend container class and configure in constructor.

### Q18: Can you use custom Docker images?
**Answer:** Yes, use `GenericContainer<>("your-image:tag")`.

### Q19: Are TestContainers tests slower?
**Answer:** Yes, 2-5s container startup, but reuse makes subsequent runs faster.

### Q20: When to use TestContainers vs H2?
**Answer:** TestContainers for integration tests with real DB, H2 for fast unit tests.

---

## üìö Summary

### Key Points

```java
@Testcontainers
@SpringBootTest
class UserIntegrationTest {
    
    // Static container - reused across all tests
    @Container
    private static PostgreSQLContainer<?> postgres = 
        new PostgreSQLContainer<>("postgres:15-alpine")
            .withDatabaseName("testdb")
            .withReuse(true);
    
    // Configure Spring Boot dynamically
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldUseRealPostgreSQL() {
        User user = userRepository.save(new User("John", "john@example.com"));
        assertThat(user.getId()).isNotNull();
    }
}
```

### Best Practices

```
‚úÖ Use static containers
‚úÖ Enable container reuse
‚úÖ Use specific image versions
‚úÖ Create base test class
‚úÖ Clean data between tests
‚úÖ Use @DynamicPropertySource
‚úÖ Configure wait strategies
‚úÖ Share network for multi-container
```

### Configuration File

```properties
# ~/.testcontainers.properties
testcontainers.reuse.enable=true
```

**Next:** README Summary ‚Üí

