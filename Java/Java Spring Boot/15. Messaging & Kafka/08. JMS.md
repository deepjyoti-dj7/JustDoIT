# JMS (Java Message Service) - Complete Guide

---

## 1. Introduction to JMS

Java Message Service (JMS) is a Java API specification for sending and receiving messages between distributed systems. It provides a standard interface for asynchronous messaging, enabling loose coupling between application components.

### Key Features
- **Standard Java API** for messaging
- **Vendor independence** - works with multiple providers
- **Two messaging models**: Point-to-Point (Queue) and Publish-Subscribe (Topic)
- **Reliable delivery** with acknowledgments
- **Message filtering** with selectors
- **Transaction support**

---

## 2. JMS Architecture

### 2.1. Core Components

```
Producer → JMS Provider → Queue/Topic → Consumer
```

| Component              | Description                                    |
|------------------------|------------------------------------------------|
| **JMS Provider**       | Message broker (ActiveMQ, IBM MQ, Artemis)     |
| **JMS Client**         | Application using JMS API                      |
| **Producer/Sender**    | Creates and sends messages                     |
| **Consumer/Receiver**  | Receives and processes messages                |
| **Message**            | Data sent between applications                 |
| **Queue**              | Point-to-point destination                     |
| **Topic**              | Publish-subscribe destination                  |
| **ConnectionFactory**  | Creates connections to provider                |

### 2.2. Messaging Models

**Point-to-Point (Queue):**
- One producer, one consumer
- Message consumed by single receiver
- FIFO ordering
- Load balancing between consumers

**Publish-Subscribe (Topic):**
- One producer, multiple consumers
- Message delivered to all subscribers
- Broadcast pattern
- Durable and non-durable subscriptions

---

## 3. Spring Boot JMS Setup

### 3.1. Dependencies

**ActiveMQ:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
```

**Artemis:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-artemis</artifactId>
</dependency>
```

### 3.2. Configuration

**ActiveMQ:**
```yaml
spring:
  activemq:
    broker-url: tcp://localhost:61616
    user: admin
    password: admin
    pool:
      enabled: true
      max-connections: 10
    packages:
      trust-all: false
      trusted: com.example.model
  
  jms:
    listener:
      concurrency: 3
      max-concurrency: 10
    template:
      default-destination: default-queue
      delivery-mode: persistent
      priority: 5
      time-to-live: 60000
```

**Artemis:**
```yaml
spring:
  artemis:
    mode: native
    host: localhost
    port: 61616
    user: admin
    password: admin
  
  jms:
    pub-sub-domain: false  # false = Queue, true = Topic
```

---

## 4. Sending Messages

### 4.1. Using JmsTemplate

```java
@Service
public class OrderProducer {
    
    @Autowired
    private JmsTemplate jmsTemplate;
    
    public void sendOrder(Order order) {
        jmsTemplate.convertAndSend("order-queue", order);
    }
}
```

### 4.2. Send to Queue

```java
public void sendToQueue(String destination, Order order) {
    jmsTemplate.convertAndSend(destination, order);
}
```

### 4.3. Send to Topic

```java
@Service
public class NotificationProducer {
    
    @Autowired
    private JmsTemplate jmsTemplate;
    
    public void publishNotification(Notification notification) {
        jmsTemplate.setPubSubDomain(true);  // Enable topic mode
        jmsTemplate.convertAndSend("notification-topic", notification);
    }
}
```

### 4.4. Send with Message Post-Processor

```java
public void sendWithProperties(Order order) {
    jmsTemplate.convertAndSend("order-queue", order, message -> {
        message.setJMSPriority(9);
        message.setJMSExpiration(System.currentTimeMillis() + 60000);
        message.setStringProperty("orderType", order.getType());
        message.setStringProperty("customerId", order.getCustomerId());
        return message;
    });
}
```

### 4.5. Send with Callback

```java
public void sendWithCallback(Order order) {
    jmsTemplate.send("order-queue", session -> {
        ObjectMessage message = session.createObjectMessage(order);
        message.setStringProperty("source", "order-service");
        message.setJMSCorrelationID(UUID.randomUUID().toString());
        return message;
    });
}
```

---

## 5. Receiving Messages

### 5.1. @JmsListener

```java
@Component
public class OrderConsumer {
    
    @JmsListener(destination = "order-queue")
    public void receiveOrder(Order order) {
        log.info("Received order: {}", order);
        processOrder(order);
    }
}
```

### 5.2. Listener with Message Metadata

```java
@JmsListener(destination = "order-queue")
public void receive(Order order, Message message) throws JMSException {
    log.info("Message ID: {}", message.getJMSMessageID());
    log.info("Correlation ID: {}", message.getJMSCorrelationID());
    log.info("Priority: {}", message.getJMSPriority());
    log.info("Timestamp: {}", message.getJMSTimestamp());
    log.info("Order: {}", order);
}
```

### 5.3. Topic Listener

```java
@JmsListener(destination = "notification-topic", subscription = "order-service")
public void receiveNotification(Notification notification) {
    log.info("Received notification: {}", notification);
}
```

### 5.4. Durable Subscription

```java
@Configuration
public class JmsConfig {
    
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
        ConnectionFactory connectionFactory
    ) {
        DefaultJmsListenerContainerFactory factory = 
            new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setPubSubDomain(true);
        factory.setSubscriptionDurable(true);
        factory.setClientId("order-service-client");
        return factory;
    }
}

@JmsListener(
    destination = "notification-topic",
    subscription = "durable-subscription",
    containerFactory = "jmsListenerContainerFactory"
)
public void receiveDurable(Notification notification) {
    log.info("Durable subscriber received: {}", notification);
}
```

---

## 6. Message Selectors

### 6.1. SQL-like Filtering

```java
@JmsListener(
    destination = "order-queue",
    selector = "orderType = 'PRIORITY'"
)
public void receivePriorityOrders(Order order) {
    log.info("Priority order: {}", order);
}

@JmsListener(
    destination = "order-queue",
    selector = "customerId = '12345' AND orderValue > 1000"
)
public void receiveHighValueOrders(Order order) {
    log.info("High-value order: {}", order);
}
```

### 6.2. Sending with Selector Properties

```java
public void sendWithSelector(Order order) {
    jmsTemplate.convertAndSend("order-queue", order, message -> {
        message.setStringProperty("orderType", order.getType());
        message.setIntProperty("orderValue", order.getTotalValue());
        message.setStringProperty("customerId", order.getCustomerId());
        return message;
    });
}
```

---

## 7. Message Types

### 7.1. TextMessage

```java
public void sendText(String text) {
    jmsTemplate.send("text-queue", session -> session.createTextMessage(text));
}

@JmsListener(destination = "text-queue")
public void receiveText(String text) {
    log.info("Received: {}", text);
}
```

### 7.2. ObjectMessage

```java
public void sendObject(Order order) {
    jmsTemplate.send("object-queue", session -> session.createObjectMessage(order));
}

@JmsListener(destination = "object-queue")
public void receiveObject(Order order) {
    log.info("Received: {}", order);
}
```

### 7.3. MapMessage

```java
public void sendMap(Map<String, Object> data) {
    jmsTemplate.send("map-queue", session -> {
        MapMessage message = session.createMapMessage();
        data.forEach((key, value) -> {
            try {
                message.setObject(key, value);
            } catch (JMSException e) {
                throw new RuntimeException(e);
            }
        });
        return message;
    });
}

@JmsListener(destination = "map-queue")
public void receiveMap(MapMessage message) throws JMSException {
    Enumeration<?> names = message.getMapNames();
    while (names.hasMoreElements()) {
        String name = (String) names.nextElement();
        log.info("{} = {}", name, message.getObject(name));
    }
}
```

### 7.4. BytesMessage

```java
public void sendBytes(byte[] data) {
    jmsTemplate.send("bytes-queue", session -> {
        BytesMessage message = session.createBytesMessage();
        message.writeBytes(data);
        return message;
    });
}

@JmsListener(destination = "bytes-queue")
public void receiveBytes(BytesMessage message) throws JMSException {
    byte[] data = new byte[(int) message.getBodyLength()];
    message.readBytes(data);
    log.info("Received {} bytes", data.length);
}
```

---

## 8. Transactions

### 8.1. JMS Transaction

```yaml
spring:
  jms:
    listener:
      session-transacted: true
```

```java
@JmsListener(destination = "order-queue")
public void receive(Order order) {
    processOrder(order);
    // Automatically committed if no exception
    // Rolled back if exception thrown
}
```

### 8.2. JTA Transaction (Distributed)

```java
@Service
public class TransactionalService {
    
    @Autowired
    private JmsTemplate jmsTemplate;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Transactional
    public void processOrder(Order order) {
        // Database operation
        orderRepository.save(order);
        
        // JMS send
        jmsTemplate.convertAndSend("confirmation-queue", createConfirmation(order));
        
        // Both committed or rolled back together
    }
}
```

---

## 9. Concurrency

### 9.1. Configuration

```yaml
spring:
  jms:
    listener:
      concurrency: 3      # Initial consumers
      max-concurrency: 10 # Maximum consumers
```

### 9.2. Container Factory

```java
@Bean
public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
    ConnectionFactory connectionFactory
) {
    DefaultJmsListenerContainerFactory factory = 
        new DefaultJmsListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setConcurrency("3-10");  // Min-Max
    factory.setSessionTransacted(true);
    return factory;
}

@JmsListener(
    destination = "order-queue",
    concurrency = "5-15"  // Override default
)
public void receive(Order order) {
    processOrder(order);
}
```

---

## 10. Error Handling

### 10.1. Default Error Handler

```java
@Bean
public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
    ConnectionFactory connectionFactory
) {
    DefaultJmsListenerContainerFactory factory = 
        new DefaultJmsListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    
    factory.setErrorHandler(throwable -> {
        log.error("JMS error occurred", throwable);
    });
    
    return factory;
}
```

### 10.2. Retry with Backoff

```java
@Bean
public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
    ConnectionFactory connectionFactory
) {
    DefaultJmsListenerContainerFactory factory = 
        new DefaultJmsListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    factory.setSessionTransacted(true);
    
    // Retry template
    RetryTemplate retryTemplate = new RetryTemplate();
    
    SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
    retryPolicy.setMaxAttempts(3);
    retryTemplate.setRetryPolicy(retryPolicy);
    
    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
    backOffPolicy.setInitialInterval(1000);
    backOffPolicy.setMultiplier(2.0);
    retryTemplate.setBackOffPolicy(backOffPolicy);
    
    factory.setRecoveryCallback(context -> {
        log.error("Max retries reached, sending to DLQ");
        return null;
    });
    
    return factory;
}
```

---

## 11. Request-Reply Pattern

### 11.1. Synchronous Request-Reply

```java
public OrderResponse sendAndReceive(OrderRequest request) {
    return (OrderResponse) jmsTemplate.convertSendAndReceive(
        "request-queue",
        request
    );
}
```

### 11.2. Reply Listener

```java
@JmsListener(destination = "request-queue")
@SendTo("response-queue")
public OrderResponse handleRequest(OrderRequest request) {
    log.info("Processing request: {}", request);
    return processRequest(request);
}
```

---

## 12. Message Converters

### 12.1. JSON Message Converter

```java
@Bean
public MessageConverter jacksonJmsMessageConverter() {
    MappingJackson2MessageConverter converter = 
        new MappingJackson2MessageConverter();
    converter.setTargetType(MessageType.TEXT);
    converter.setTypeIdPropertyName("_type");
    return converter;
}

@Bean
public JmsTemplate jmsTemplate(ConnectionFactory connectionFactory) {
    JmsTemplate template = new JmsTemplate(connectionFactory);
    template.setMessageConverter(jacksonJmsMessageConverter());
    return template;
}
```

---

## 13. Testing

### 13.1. Embedded ActiveMQ

```xml
<dependency>
    <groupId>org.apache.activemq</groupId>
    <artifactId>activemq-broker</artifactId>
    <scope>test</scope>
</dependency>
```

```java
@SpringBootTest
public class JmsIntegrationTest {
    
    @Autowired
    private JmsTemplate jmsTemplate;
    
    @BeforeAll
    public static void setup() {
        BrokerService broker = new BrokerService();
        broker.addConnector("tcp://localhost:61616");
        broker.setPersistent(false);
        broker.start();
    }
    
    @Test
    public void testSendAndReceive() {
        Order order = new Order("123", "Product");
        jmsTemplate.convertAndSend("test-queue", order);
        
        Order received = (Order) jmsTemplate.receiveAndConvert("test-queue");
        assertEquals(order.getId(), received.getId());
    }
}
```

---

## 14. Best Practices

1. **Use connection pooling** for efficiency
2. **Enable transactions** for reliability
3. **Configure appropriate concurrency** based on load
4. **Use message selectors** for filtering
5. **Implement error handling** with retry and DLQ
6. **Monitor queue depths** and consumer lag
7. **Use durable subscriptions** for topics if needed
8. **Set message TTL** to prevent buildup
9. **Secure with authentication** and SSL
10. **Test with embedded brokers** for reliability

---

## 15. Interview Questions

**Q1: What is JMS?**
**A:** Java API specification for asynchronous messaging between distributed systems.

**Q2: Queue vs Topic?**
**A:** Queue: Point-to-point, one consumer. Topic: Pub-sub, multiple subscribers.

**Q3: What is message selector?**
**A:** SQL-like filter to receive only matching messages based on properties.

**Q4: What is durable subscription?**
**A:** Topic subscription that persists messages even when subscriber is offline.

**Q5: What is JmsTemplate?**
**A:** Spring abstraction for sending JMS messages with simplified API.

**Q6: What is @JmsListener?**
**A:** Annotation for declarative message consumption in Spring applications.

**Q7: Message types in JMS?**
**A:** TextMessage, ObjectMessage, MapMessage, BytesMessage, StreamMessage.

**Q8: What is ConnectionFactory?**
**A:** Factory for creating connections to JMS provider.

**Q9: What is session-transacted?**
**A:** JMS session where messages are committed/rolled back together.

**Q10: What is @SendTo?**
**A:** Annotation to send listener method return value to specified destination.

**Q11: JMS vs AMQP?**
**A:** JMS: Java-specific API. AMQP: Wire protocol, language-agnostic.

**Q12: What is message TTL?**
**A:** Time-to-live - how long message is valid before expiring.

**Q13: How to implement request-reply?**
**A:** Use convertSendAndReceive() or @SendTo annotation.

**Q14: What is pub-sub domain?**
**A:** Topic-based messaging where messages broadcast to all subscribers.

**Q15: How to scale JMS consumers?**
**A:** Increase concurrency or deploy multiple consumer instances.

**Q16: What is message priority?**
**A:** Priority level (0-9) affecting delivery order, 9 being highest.

**Q17: ActiveMQ vs Artemis?**
**A:** Artemis: Newer, high-performance successor to ActiveMQ Classic.

**Q18: What is client acknowledgment?**
**A:** Consumer manually acknowledges message after processing.

**Q19: How to handle poison messages?**
**A:** Configure max redelivery attempts and dead letter queue.

**Q20: What is virtual topic?**
**A:** ActiveMQ feature combining topic broadcast with queue load balancing.

---

## 16. Summary

JMS provides a standard Java API for messaging with vendor independence, support for queues and topics, transactions, message selectors, and reliable delivery. Spring Boot simplifies JMS with auto-configuration, JmsTemplate, and @JmsListener annotations. Understanding messaging models, acknowledgment modes, and error handling is essential for building robust JMS applications.

---

**Next:** Module README →
