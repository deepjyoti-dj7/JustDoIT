# RabbitMQ Integration with Spring Boot - Complete Guide

---

## 1. Introduction to RabbitMQ

RabbitMQ is an open-source message broker implementing the Advanced Message Queuing Protocol (AMQP). It provides reliable, flexible messaging with support for multiple messaging patterns, routing strategies, and high availability.

### Key Features
- **Multiple protocols**: AMQP, MQTT, STOMP
- **Flexible routing**: Exchanges and bindings
- **Reliability**: Message persistence, acknowledgments
- **Clustering**: High availability and scalability
- **Management UI**: Web-based monitoring
- **Plugin system**: Extensible functionality

---

## 2. RabbitMQ Core Concepts

### 2.1. Architecture

```
Producer → Exchange → Queue → Consumer
             ↓
          Binding (Routing Key)
```

| Component       | Description                                           |
|-----------------|-------------------------------------------------------|
| **Producer**    | Sends messages to exchanges                           |
| **Exchange**    | Routes messages to queues based on rules              |
| **Queue**       | Stores messages for consumers                         |
| **Binding**     | Link between exchange and queue with routing key      |
| **Consumer**    | Receives and processes messages from queues           |
| **Virtual Host** | Logical grouping of resources                        |

### 2.2. Exchange Types

| Type        | Description                                      | Use Case                    |
|-------------|--------------------------------------------------|-----------------------------|
| **Direct**  | Routes based on exact routing key match          | Task distribution           |
| **Fanout**  | Broadcasts to all bound queues                   | Notifications, logging      |
| **Topic**   | Routes based on pattern matching                 | Event categories            |
| **Headers** | Routes based on message headers                  | Complex routing logic       |

---

## 3. Spring Boot Setup

### 3.1. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

### 3.2. Configuration

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    virtual-host: /
    
    # Connection pooling
    connection-timeout: 60000
    requested-heartbeat: 60
    
    # Publisher confirms
    publisher-confirm-type: correlated
    publisher-returns: true
    
    # Template configuration
    template:
      mandatory: true
      retry:
        enabled: true
        initial-interval: 1000
        max-attempts: 3
        multiplier: 2
    
    # Listener configuration
    listener:
      simple:
        acknowledge-mode: manual
        concurrency: 3
        max-concurrency: 10
        prefetch: 10
        retry:
          enabled: true
          initial-interval: 1000
          max-attempts: 3
```

---

## 4. Queue, Exchange, and Binding Configuration

### 4.1. Java Configuration

```java
@Configuration
public class RabbitMQConfig {
    
    // Queues
    @Bean
    public Queue orderQueue() {
        return QueueBuilder.durable("order.queue")
                .withArgument("x-message-ttl", 60000)  // 60 seconds TTL
                .withArgument("x-max-length", 10000)    // Max 10k messages
                .build();
    }
    
    @Bean
    public Queue deadLetterQueue() {
        return new Queue("order.dlq", true);
    }
    
    // Exchange
    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange("order.exchange");
    }
    
    @Bean
    public TopicExchange notificationExchange() {
        return new TopicExchange("notification.exchange");
    }
    
    @Bean
    public FanoutExchange logExchange() {
        return new FanoutExchange("log.exchange");
    }
    
    // Bindings
    @Bean
    public Binding orderBinding(Queue orderQueue, DirectExchange orderExchange) {
        return BindingBuilder.bind(orderQueue)
                .to(orderExchange)
                .with("order.created");
    }
    
    @Bean
    public Binding notificationBinding(TopicExchange notificationExchange) {
        Queue queue = new Queue("email.queue");
        return BindingBuilder.bind(queue)
                .to(notificationExchange)
                .with("notification.email.*");
    }
}
```

### 4.2. Queue with Dead Letter Exchange

```java
@Bean
public Queue orderQueueWithDLX() {
    return QueueBuilder.durable("order.queue")
            .withArgument("x-dead-letter-exchange", "order.dlx")
            .withArgument("x-dead-letter-routing-key", "order.failed")
            .withArgument("x-message-ttl", 60000)
            .build();
}

@Bean
public DirectExchange deadLetterExchange() {
    return new DirectExchange("order.dlx");
}

@Bean
public Queue deadLetterQueue() {
    return new Queue("order.dlq");
}

@Bean
public Binding deadLetterBinding() {
    return BindingBuilder.bind(deadLetterQueue())
            .to(deadLetterExchange())
            .with("order.failed");
}
```

---

## 5. Sending Messages with RabbitTemplate

### 5.1. Basic Send

```java
@Service
public class OrderProducer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendOrder(Order order) {
        rabbitTemplate.convertAndSend("order.exchange", "order.created", order);
    }
}
```

### 5.2. Send with Message Properties

```java
public void sendWithProperties(Order order) {
    MessageProperties properties = new MessageProperties();
    properties.setContentType("application/json");
    properties.setPriority(5);
    properties.setExpiration("60000");  // 60 seconds
    properties.setHeader("source", "order-service");
    properties.setCorrelationId(UUID.randomUUID().toString());
    
    Message message = new Message(
        objectMapper.writeValueAsBytes(order),
        properties
    );
    
    rabbitTemplate.send("order.exchange", "order.created", message);
}
```

### 5.3. Send with Confirmation

```java
@Service
public class ConfirmedProducer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    @PostConstruct
    public void init() {
        rabbitTemplate.setConfirmCallback((correlation, ack, reason) -> {
            if (ack) {
                log.info("Message confirmed: {}", correlation);
            } else {
                log.error("Message rejected: {} - {}", correlation, reason);
            }
        });
        
        rabbitTemplate.setReturnsCallback(returned -> {
            log.error("Message returned: {} - {}", 
                returned.getMessage(), returned.getReplyText());
        });
    }
    
    public void sendWithConfirmation(Order order) {
        CorrelationData correlationData = 
            new CorrelationData(UUID.randomUUID().toString());
        
        rabbitTemplate.convertAndSend(
            "order.exchange", 
            "order.created", 
            order, 
            correlationData
        );
    }
}
```

---

## 6. Receiving Messages with @RabbitListener

### 6.1. Basic Listener

```java
@Component
public class OrderConsumer {
    
    @RabbitListener(queues = "order.queue")
    public void receiveOrder(Order order) {
        log.info("Received order: {}", order);
        processOrder(order);
    }
}
```

### 6.2. Listener with Message and Headers

```java
@RabbitListener(queues = "order.queue")
public void receiveWithMetadata(
    Order order,
    Message message,
    Channel channel,
    @Header(AmqpHeaders.DELIVERY_TAG) long tag,
    @Header(AmqpHeaders.RECEIVED_ROUTING_KEY) String routingKey
) throws IOException {
    log.info("Routing key: {}, Delivery tag: {}", routingKey, tag);
    log.info("Order: {}", order);
    
    try {
        processOrder(order);
        channel.basicAck(tag, false);  // Acknowledge
    } catch (Exception e) {
        channel.basicNack(tag, false, true);  // Reject and requeue
    }
}
```

### 6.3. Multiple Queues

```java
@RabbitListener(queues = {"order.queue", "payment.queue"})
public void receiveMultiple(String message, 
                           @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {
    log.info("Received from {}: {}", queue, message);
}
```

### 6.4. Dynamic Queue Declaration

```java
@RabbitListener(bindings = @QueueBinding(
    value = @Queue(value = "email.queue", durable = "true"),
    exchange = @Exchange(value = "notification.exchange", type = "topic"),
    key = "notification.email.*"
))
public void receiveEmail(EmailNotification notification) {
    sendEmail(notification);
}
```

---

## 7. Message Acknowledgment

### 7.1. Auto Acknowledgment

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto
```

### 7.2. Manual Acknowledgment

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: manual
```

```java
@RabbitListener(queues = "order.queue")
public void receive(Order order, Channel channel, 
                   @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException {
    try {
        processOrder(order);
        channel.basicAck(tag, false);  // Acknowledge
    } catch (RecoverableException e) {
        channel.basicNack(tag, false, true);  // Requeue
    } catch (Exception e) {
        channel.basicNack(tag, false, false);  // Send to DLQ
    }
}
```

---

## 8. Error Handling and Retry

### 8.1. Retry Configuration

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        retry:
          enabled: true
          initial-interval: 1000
          max-attempts: 3
          multiplier: 2
          max-interval: 10000
```

### 8.2. Custom Retry Interceptor

```java
@Bean
public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
    ConnectionFactory connectionFactory
) {
    SimpleRabbitListenerContainerFactory factory = 
        new SimpleRabbitListenerContainerFactory();
    factory.setConnectionFactory(connectionFactory);
    
    RetryTemplate retryTemplate = new RetryTemplate();
    
    // Retry policy
    SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
    retryPolicy.setMaxAttempts(3);
    retryTemplate.setRetryPolicy(retryPolicy);
    
    // Backoff policy
    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
    backOffPolicy.setInitialInterval(1000);
    backOffPolicy.setMultiplier(2.0);
    backOffPolicy.setMaxInterval(10000);
    retryTemplate.setBackOffPolicy(backOffPolicy);
    
    factory.setRetryTemplate(retryTemplate);
    
    return factory;
}
```

### 8.3. Dead Letter Queue

```java
@RabbitListener(queues = "order.dlq")
public void handleDeadLetter(Message message) {
    log.error("Dead letter: {}", new String(message.getBody()));
    
    // Extract original exception info
    String reason = (String) message.getMessageProperties()
        .getHeaders().get("x-exception-message");
    
    log.error("Reason: {}", reason);
    alertAdministrator(message, reason);
}
```

---

## 9. Priority Queues

```java
@Bean
public Queue priorityQueue() {
    return QueueBuilder.durable("priority.queue")
            .maxPriority(10)  // 0-10 priority levels
            .build();
}

public void sendWithPriority(Order order, int priority) {
    rabbitTemplate.convertAndSend("priority.queue", order, message -> {
        message.getMessageProperties().setPriority(priority);
        return message;
    });
}
```

---

## 10. Delayed Messages

### 10.1. Using RabbitMQ Delayed Message Plugin

```java
@Bean
public CustomExchange delayedExchange() {
    Map<String, Object> args = new HashMap<>();
    args.put("x-delayed-type", "direct");
    return new CustomExchange("delayed.exchange", "x-delayed-message", true, false, args);
}

public void sendDelayed(Order order, long delayMillis) {
    rabbitTemplate.convertAndSend("delayed.exchange", "delayed.key", order, message -> {
        message.getMessageProperties().setDelay((int) delayMillis);
        return message;
    });
}
```

### 10.2. Using TTL and Dead Letter

```java
@Bean
public Queue delayQueue() {
    return QueueBuilder.durable("delay.queue")
            .withArgument("x-message-ttl", 10000)  // 10 seconds
            .withArgument("x-dead-letter-exchange", "processing.exchange")
            .withArgument("x-dead-letter-routing-key", "process")
            .build();
}
```

---

## 11. Request-Reply Pattern

### 11.1. Sync Request-Reply

```java
public OrderResponse sendAndReceive(OrderRequest request) {
    return (OrderResponse) rabbitTemplate.convertSendAndReceive(
        "request.exchange",
        "request.key",
        request
    );
}
```

### 11.2. Reply Listener

```java
@RabbitListener(queues = "request.queue")
public OrderResponse handleRequest(OrderRequest request) {
    log.info("Processing request: {}", request);
    return processRequest(request);
}
```

---

## 12. Message Conversion

### 12.1. Jackson2JsonMessageConverter

```java
@Bean
public Jackson2JsonMessageConverter messageConverter() {
    return new Jackson2JsonMessageConverter();
}

@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate template = new RabbitTemplate(connectionFactory);
    template.setMessageConverter(messageConverter());
    return template;
}
```

---

## 13. Monitoring and Management

### 13.1. Enable Management Plugin

```bash
rabbitmq-plugins enable rabbitmq_management
```

Access at: http://localhost:15672

### 13.2. Actuator Integration

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  health:
    rabbit:
      enabled: true
```

---

## 14. Best Practices

1. **Use durable queues and exchanges** for reliability
2. **Enable publisher confirms** for guaranteed delivery
3. **Implement manual acknowledgment** for critical messages
4. **Configure dead letter queues** for failed messages
5. **Set appropriate prefetch count** for fair distribution
6. **Use message TTL** to prevent queue buildup
7. **Monitor queue depths** and consumer lag
8. **Secure with SSL/TLS** in production
9. **Use virtual hosts** for isolation
10. **Configure connection pooling** for efficiency

---

## 15. Interview Questions

**Q1: What is RabbitMQ?**
**A:** Open-source message broker implementing AMQP for reliable, flexible messaging.

**Q2: Exchange types?**
**A:** Direct (exact match), Fanout (broadcast), Topic (pattern), Headers (header-based).

**Q3: What is binding?**
**A:** Link between exchange and queue, defined by routing key.

**Q4: Dead letter queue?**
**A:** Queue for messages that failed processing or exceeded TTL.

**Q5: What is prefetch count?**
**A:** Maximum number of unacknowledged messages a consumer can receive.

**Q6: Publisher confirms vs transactions?**
**A:** Confirms: Async acknowledgment. Transactions: Sync, slower, guarantees delivery.

**Q7: Manual vs auto acknowledgment?**
**A:** Manual: Application controls. Auto: RabbitMQ acks on delivery.

**Q8: What is virtual host?**
**A:** Logical grouping of resources for isolation and multi-tenancy.

**Q9: How to implement delayed messages?**
**A:** Use delayed message plugin or TTL + dead letter exchange.

**Q10: Priority queues?**
**A:** Queues that process messages based on priority (0-10).

**Q11: RabbitMQ vs Kafka?**
**A:** RabbitMQ: Queue-based, flexible routing. Kafka: Log-based, high throughput, replay.

**Q12: What is message TTL?**
**A:** Time-to-live - how long message stays in queue before expiring.

**Q13: How to ensure message durability?**
**A:** Durable queues, persistent messages, publisher confirms.

**Q14: What is fanout exchange?**
**A:** Broadcasts messages to all bound queues, ignoring routing key.

**Q15: How to scale consumers?**
**A:** Increase concurrency or deploy multiple consumer instances.

**Q16: What is topic exchange?**
**A:** Routes based on pattern matching with wildcards (* and #).

**Q17: Request-reply pattern?**
**A:** convertSendAndReceive() for sync request-response messaging.

**Q18: What is channel?**
**A:** Virtual connection within physical TCP connection for messaging.

**Q19: How to handle poison messages?**
**A:** Use dead letter queues with max retry limits.

**Q20: What is quorum queue?**
**A:** Replicated queue for high availability and data safety.

---

## 16. Summary

RabbitMQ provides powerful, flexible messaging with Spring AMQP integration. Understanding exchanges, queues, bindings, acknowledgment modes, and error handling is essential for building reliable messaging applications. Proper configuration, monitoring, and best practices ensure production-ready RabbitMQ deployments.

---

**Next:** JMS →
