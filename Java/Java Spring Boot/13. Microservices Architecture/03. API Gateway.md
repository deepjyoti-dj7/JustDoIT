# ğŸšª API Gateway - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [What is API Gateway](#what-is-api-gateway)
- [Spring Cloud Gateway](#spring-cloud-gateway)
- [Routing](#routing)
- [Filters](#filters)
- [Security](#security)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**API Gateway** is a single entry point for all client requests that routes requests to appropriate microservices, handles cross-cutting concerns, and aggregates responses.

### Why API Gateway?

```
Problems without API Gateway:
âŒ Clients know all service endpoints
âŒ Cross-cutting concerns in each service
âŒ Multiple authentication points
âŒ Complex client logic
âŒ Security vulnerabilities

Solutions with API Gateway:
âœ… Single entry point
âœ… Centralized routing
âœ… Authentication & authorization
âœ… Rate limiting
âœ… Request/response transformation
âœ… Load balancing
âœ… Caching
```

---

## ğŸ“š What is API Gateway

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Client (Web/Mobile/Third-party)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  API Gateway                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  - Routing                                 â”‚ â”‚
â”‚  â”‚  - Authentication                          â”‚ â”‚
â”‚  â”‚  - Rate Limiting                           â”‚ â”‚
â”‚  â”‚  - Request/Response Transformation         â”‚ â”‚
â”‚  â”‚  - Caching                                 â”‚ â”‚
â”‚  â”‚  - Load Balancing                          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“              â†“              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User       â”‚ â”‚   Order      â”‚ â”‚   Payment    â”‚
â”‚   Service    â”‚ â”‚   Service    â”‚ â”‚   Service    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Responsibilities

```
1. Request Routing
   - Route /api/users/* â†’ User Service
   - Route /api/orders/* â†’ Order Service
   - Route /api/payments/* â†’ Payment Service

2. Cross-Cutting Concerns
   - Authentication & Authorization
   - Rate limiting
   - Logging & Monitoring
   - CORS handling

3. Protocol Translation
   - HTTP â†’ gRPC
   - REST â†’ GraphQL
   - WebSocket support

4. Response Aggregation
   - Combine multiple service responses
   - Reduce client round trips
```

---

## ğŸš€ Spring Cloud Gateway

### Maven Dependencies

```xml
<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    
    <!-- Eureka Client for service discovery -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    
    <!-- Redis for rate limiting (optional) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
</dependencies>
```

### Main Application

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

### Basic Configuration

```yaml
server:
  port: 8080

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        # User Service Route
        - id: user-service
          uri: lb://user-service  # Load balanced
          predicates:
            - Path=/api/users/**
          
        # Order Service Route
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
        
        # Payment Service Route
        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payments/**

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

---

## ğŸ›£ï¸ Routing

### Path-Based Routing

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
```

### Header-Based Routing

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service-v2
          uri: lb://user-service-v2
          predicates:
            - Path=/api/users/**
            - Header=X-API-Version, v2
```

### Query Parameter Routing

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: premium-user-service
          uri: lb://premium-user-service
          predicates:
            - Path=/api/users/**
            - Query=premium, true
```

### Method-Based Routing

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-read-service
          uri: lb://user-read-service
          predicates:
            - Path=/api/users/**
            - Method=GET
        
        - id: user-write-service
          uri: lb://user-write-service
          predicates:
            - Path=/api/users/**
            - Method=POST,PUT,DELETE
```

### Java Configuration

```java
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // User Service
            .route("user-service", r -> r
                .path("/api/users/**")
                .uri("lb://user-service"))
            
            // Order Service with filter
            .route("order-service", r -> r
                .path("/api/orders/**")
                .filters(f -> f
                    .addRequestHeader("X-Gateway", "API-Gateway")
                    .addResponseHeader("X-Response-Time", LocalDateTime.now().toString()))
                .uri("lb://order-service"))
            
            // Payment Service with predicate
            .route("payment-service", r -> r
                .path("/api/payments/**")
                .and()
                .header("Authorization")
                .uri("lb://payment-service"))
            
            .build();
    }
}
```

---

## ğŸ”§ Filters

### Built-in Filters

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            # Add request header
            - AddRequestHeader=X-Request-ID, ${random.uuid}
            
            # Add response header
            - AddResponseHeader=X-Response-Time, ${timestamp}
            
            # Remove request header
            - RemoveRequestHeader=Cookie
            
            # Remove response header
            - RemoveResponseHeader=X-Internal-Header
            
            # Rewrite path
            - RewritePath=/api/users/(?<segment>.*), /${segment}
            
            # Prefix path
            - PrefixPath=/v1
            
            # Strip prefix
            - StripPrefix=1  # Remove first path segment
            
            # Set status
            - SetStatus=200
            
            # Retry
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE
                methods: GET,POST
```

### Custom Filter

```java
@Component
public class LoggingFilter implements GlobalFilter, Ordered {
    
    private static final Logger log = LoggerFactory.getLogger(LoggingFilter.class);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        log.info("Request: {} {}", request.getMethod(), request.getURI());
        log.info("Headers: {}", request.getHeaders());
        
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            ServerHttpResponse response = exchange.getResponse();
            log.info("Response Status: {}", response.getStatusCode());
        }));
    }
    
    @Override
    public int getOrder() {
        return -1;  // High priority
    }
}
```

### Authentication Filter

```java
@Component
public class AuthenticationFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // Skip authentication for public endpoints
        if (isPublicEndpoint(request.getPath().toString())) {
            return chain.filter(exchange);
        }
        
        // Get Authorization header
        String authHeader = request.getHeaders().getFirst("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        String token = authHeader.substring(7);
        
        try {
            // Validate token
            if (!jwtUtil.validateToken(token)) {
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }
            
            // Add user info to headers
            String userId = jwtUtil.getUserIdFromToken(token);
            ServerHttpRequest mutatedRequest = exchange.getRequest()
                .mutate()
                .header("X-User-ID", userId)
                .build();
            
            return chain.filter(exchange.mutate().request(mutatedRequest).build());
            
        } catch (Exception e) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
    }
    
    private boolean isPublicEndpoint(String path) {
        return path.startsWith("/api/auth/") || 
               path.equals("/actuator/health");
    }
    
    @Override
    public int getOrder() {
        return -100;  // Execute early
    }
}
```

### Rate Limiting Filter

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter:
                  replenishRate: 10  # Tokens per second
                  burstCapacity: 20  # Max tokens
                  requestedTokens: 1  # Tokens per request
                key-resolver: "#{@userKeyResolver}"
```

```java
@Component("userKeyResolver")
public class UserKeyResolver implements KeyResolver {
    
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        // Rate limit by user ID from header
        String userId = exchange.getRequest().getHeaders().getFirst("X-User-ID");
        return Mono.just(userId != null ? userId : "anonymous");
    }
}
```

---

## ğŸ” Security

### JWT Authentication

```java
@Component
public class JwtAuthenticationFilter implements GlobalFilter {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    private static final List<String> PUBLIC_ENDPOINTS = Arrays.asList(
        "/api/auth/login",
        "/api/auth/register",
        "/actuator/health"
    );
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().toString();
        
        // Allow public endpoints
        if (PUBLIC_ENDPOINTS.stream().anyMatch(path::startsWith)) {
            return chain.filter(exchange);
        }
        
        String token = extractToken(exchange.getRequest());
        
        if (token == null) {
            return onError(exchange, "No token provided", HttpStatus.UNAUTHORIZED);
        }
        
        try {
            Claims claims = jwtUtil.validateAndGetClaims(token);
            
            // Add user info to request
            ServerHttpRequest mutatedRequest = exchange.getRequest()
                .mutate()
                .header("X-User-ID", claims.getSubject())
                .header("X-User-Roles", claims.get("roles", String.class))
                .build();
            
            return chain.filter(exchange.mutate().request(mutatedRequest).build());
            
        } catch (Exception e) {
            return onError(exchange, "Invalid token", HttpStatus.UNAUTHORIZED);
        }
    }
    
    private String extractToken(ServerHttpRequest request) {
        String authHeader = request.getHeaders().getFirst("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
    
    private Mono<Void> onError(ServerWebExchange exchange, String message, HttpStatus status) {
        exchange.getResponse().setStatusCode(status);
        return exchange.getResponse().setComplete();
    }
}
```

### CORS Configuration

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("http://localhost:3000");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        
        UrlBasedCorsConfigurationSource source = 
            new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        
        return new CorsWebFilter(source);
    }
}
```

---

## ğŸš€ Advanced Features

### Circuit Breaker Integration

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - name: CircuitBreaker
              args:
                name: userServiceCircuitBreaker
                fallbackUri: forward:/fallback/users
```

```java
@RestController
@RequestMapping("/fallback")
public class FallbackController {
    
    @GetMapping("/users")
    public ResponseEntity<Map<String, String>> userFallback() {
        Map<String, String> response = new HashMap<>();
        response.put("message", "User service is temporarily unavailable");
        response.put("status", "503");
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }
}
```

### Request/Response Modification

```java
@Component
public class ModifyRequestFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // Modify request
        ServerHttpRequest modifiedRequest = exchange.getRequest()
            .mutate()
            .header("X-Gateway-Timestamp", String.valueOf(System.currentTimeMillis()))
            .header("X-Gateway-Version", "1.0")
            .build();
        
        // Modify response
        ServerHttpResponse response = exchange.getResponse();
        response.getHeaders().add("X-Processed-By", "API-Gateway");
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }
}
```

### Response Caching

```java
@Component
public class CachingFilter implements GlobalFilter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String cacheKey = generateCacheKey(exchange.getRequest());
        
        // Check cache
        String cachedResponse = redisTemplate.opsForValue().get(cacheKey);
        if (cachedResponse != null) {
            // Return cached response
            exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
            DataBuffer buffer = exchange.getResponse().bufferFactory()
                .wrap(cachedResponse.getBytes());
            return exchange.getResponse().writeWith(Mono.just(buffer));
        }
        
        // Continue to service and cache response
        return chain.filter(exchange);
    }
    
    private String generateCacheKey(ServerHttpRequest request) {
        return request.getMethod() + ":" + request.getPath();
    }
}
```

### Load Balancing Strategy

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
    
    loadbalancer:
      ribbon:
        enabled: false
      configurations: default
```

```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        return new RandomLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

---

## ğŸ’¡ Best Practices

### 1. Use Service Discovery

```yaml
# âœ… Good - Use service names
uri: lb://user-service

# âŒ Bad - Hard-coded URLs
uri: http://192.168.1.10:8081
```

### 2. Implement Health Checks

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,gateway
  endpoint:
    health:
      show-details: always
```

### 3. Add Request ID for Tracing

```java
@Component
public class RequestIdFilter implements GlobalFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String requestId = UUID.randomUUID().toString();
        
        ServerHttpRequest request = exchange.getRequest()
            .mutate()
            .header("X-Request-ID", requestId)
            .build();
        
        return chain.filter(exchange.mutate().request(request).build());
    }
}
```

### 4. Configure Timeouts

```yaml
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
```

### 5. Use Circuit Breakers

```yaml
resilience4j:
  circuitbreaker:
    instances:
      user-service:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000
        permitted-number-of-calls-in-half-open-state: 3
```

---

## ğŸ¤ Interview Questions

### Q1: What is API Gateway?
**Answer:** Single entry point for all client requests that routes to appropriate microservices and handles cross-cutting concerns.

### Q2: Benefits of API Gateway?
**Answer:** Single entry point, centralized routing, authentication, rate limiting, request transformation, load balancing, caching.

### Q3: Spring Cloud Gateway vs Zuul?
**Answer:** Gateway is non-blocking (WebFlux), Zuul 1 is blocking. Gateway is more performant and modern.

### Q4: What are predicates?
**Answer:** Conditions that must be met for a route to be matched (path, method, headers, etc.).

### Q5: What are filters?
**Answer:** Modify requests and responses before/after routing to services.

### Q6: Types of filters?
**Answer:** Pre-filters (before routing), post-filters (after routing), global filters (all routes).

### Q7: How to implement authentication in Gateway?
**Answer:** Create GlobalFilter to validate JWT token, extract user info, add to headers for downstream services.

### Q8: How to implement rate limiting?
**Answer:** Use RequestRateLimiter filter with Redis, define replenishRate and burstCapacity.

### Q9: How to handle service failures?
**Answer:** Use Circuit Breaker pattern with fallback endpoints.

### Q10: What is lb:// prefix?
**Answer:** Load-balanced URI scheme using service discovery (Eureka) to find service instances.

### Q11: How to add custom headers?
**Answer:** Use AddRequestHeader/AddResponseHeader filters or custom GlobalFilter.

### Q12: How to implement CORS?
**Answer:** Configure CorsWebFilter bean with allowed origins, methods, and headers.

### Q13: How to modify request/response?
**Answer:** Create GlobalFilter, mutate ServerHttpRequest/ServerHttpResponse.

### Q14: What is route predicate factory?
**Answer:** Factory that creates predicates for route matching (PathRoutePredicateFactory, etc.).

### Q15: How to configure timeout?
**Answer:** Set `spring.cloud.gateway.httpclient.connect-timeout` and `response-timeout`.

### Q16: Can Gateway aggregate responses?
**Answer:** Yes, create custom endpoint that calls multiple services and combines responses.

### Q17: How to version APIs in Gateway?
**Answer:** Use path-based (/v1/, /v2/) or header-based (X-API-Version) routing.

### Q18: What is order of filter execution?
**Answer:** Determined by Ordered interface, lower number = higher priority (executes first).

### Q19: How to cache responses?
**Answer:** Implement caching filter with Redis/Caffeine to store responses by cache key.

### Q20: Monitoring API Gateway?
**Answer:** Use Spring Boot Actuator, export metrics to Prometheus, visualize in Grafana, enable distributed tracing.

---

## ğŸ“š Summary

### Key Concepts

```
1. Single Entry Point
   - All client requests â†’ API Gateway
   - Gateway routes to services
   - Centralized management

2. Routing
   - Path-based
   - Header-based
   - Method-based
   - Query parameter-based

3. Filters
   - Pre-filters (before routing)
   - Post-filters (after routing)
   - Global filters (all routes)

4. Cross-Cutting Concerns
   - Authentication
   - Rate limiting
   - Logging
   - CORS
```

### Configuration Template

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: service-name
          uri: lb://service-name
          predicates:
            - Path=/api/path/**
          filters:
            - AddRequestHeader=X-Header, value
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
```

**Next:** Load Balancing â†’

