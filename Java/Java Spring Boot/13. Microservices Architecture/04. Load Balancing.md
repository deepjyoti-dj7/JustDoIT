# âš–ï¸ Load Balancing - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [What is Load Balancing](#what-is-load-balancing)
- [Client-Side Load Balancing](#client-side-load-balancing)
- [Server-Side Load Balancing](#server-side-load-balancing)
- [Load Balancing Algorithms](#load-balancing-algorithms)
- [Spring Cloud LoadBalancer](#spring-cloud-loadbalancer)
- [Health Checks](#health-checks)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**Load Balancing** distributes incoming network traffic across multiple servers to ensure no single server becomes overwhelmed, improving application availability and responsiveness.

### Why Load Balancing?

```
Benefits:
âœ… High availability
âœ… Scalability
âœ… Better resource utilization
âœ… Fault tolerance
âœ… Performance optimization
âœ… No single point of failure
```

---

## ğŸ“š What is Load Balancing

### Architecture

```
         Client Requests
               â†“
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Load Balancer  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“    â†“    â†“
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â†“         â†“         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Server 1â”‚ â”‚Server 2â”‚ â”‚Server 3â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Types

| Type | Description | Example |
|------|-------------|---------|
| **Client-Side** | Client chooses server | Ribbon, Spring Cloud LoadBalancer |
| **Server-Side** | Load balancer chooses server | Nginx, HAProxy, AWS ELB |
| **DNS** | DNS returns different IPs | Route 53 |

---

## ğŸ”µ Client-Side Load Balancing

### Spring Cloud LoadBalancer

**Maven Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

### Basic Setup

```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;  // Load-balanced
    
    public PaymentResponse processPayment(Order order) {
        // Automatically load-balanced across payment-service instances
        return restTemplate.postForObject(
            "http://payment-service/api/payments",
            new PaymentRequest(order),
            PaymentResponse.class
        );
    }
}
```

### WebClient with Load Balancing

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    @LoadBalanced
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }
}

@Service
public class OrderService {
    
    private final WebClient webClient;
    
    public OrderService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.build();
    }
    
    public Mono<PaymentResponse> processPayment(Order order) {
        return webClient.post()
            .uri("http://payment-service/api/payments")
            .bodyValue(new PaymentRequest(order))
            .retrieve()
            .bodyToMono(PaymentResponse.class);
    }
}
```

---

## ğŸŸ¢ Server-Side Load Balancing

### Nginx Configuration

```nginx
upstream payment_service {
    server 192.168.1.10:8081;
    server 192.168.1.11:8081;
    server 192.168.1.12:8081;
}

server {
    listen 80;
    
    location /api/payments/ {
        proxy_pass http://payment_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

### HAProxy Configuration

```
frontend http_front
    bind *:80
    default_backend payment_servers

backend payment_servers
    balance roundrobin
    server server1 192.168.1.10:8081 check
    server server2 192.168.1.11:8081 check
    server server3 192.168.1.12:8081 check
```

---

## ğŸ² Load Balancing Algorithms

### 1. Round Robin

```java
public class RoundRobinLoadBalancer {
    private AtomicInteger position = new AtomicInteger(0);
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances.isEmpty()) {
            return null;
        }
        
        int pos = Math.abs(position.incrementAndGet());
        return instances.get(pos % instances.size());
    }
}

// Example: 3 servers
// Request 1 â†’ Server 1
// Request 2 â†’ Server 2
// Request 3 â†’ Server 3
// Request 4 â†’ Server 1
```

### 2. Random

```java
public class RandomLoadBalancer {
    private Random random = new Random();
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        if (instances.isEmpty()) {
            return null;
        }
        
        int index = random.nextInt(instances.size());
        return instances.get(index);
    }
}

// Randomly selects server for each request
```

### 3. Weighted Round Robin

```java
public class WeightedRoundRobinLoadBalancer {
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        // Server 1: weight = 5
        // Server 2: weight = 3
        // Server 3: weight = 2
        
        int totalWeight = instances.stream()
            .mapToInt(this::getWeight)
            .sum();
        
        int randomWeight = ThreadLocalRandom.current().nextInt(totalWeight);
        
        for (ServiceInstance instance : instances) {
            randomWeight -= getWeight(instance);
            if (randomWeight < 0) {
                return instance;
            }
        }
        
        return instances.get(0);
    }
    
    private int getWeight(ServiceInstance instance) {
        return Integer.parseInt(
            instance.getMetadata().getOrDefault("weight", "1")
        );
    }
}
```

### 4. Least Connections

```java
public class LeastConnectionsLoadBalancer {
    private Map<String, Integer> connections = new ConcurrentHashMap<>();
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        return instances.stream()
            .min(Comparator.comparingInt(instance -> 
                connections.getOrDefault(getInstanceId(instance), 0)))
            .orElse(null);
    }
    
    public void incrementConnections(ServiceInstance instance) {
        connections.merge(getInstanceId(instance), 1, Integer::sum);
    }
    
    public void decrementConnections(ServiceInstance instance) {
        connections.merge(getInstanceId(instance), -1, Integer::sum);
    }
    
    private String getInstanceId(ServiceInstance instance) {
        return instance.getHost() + ":" + instance.getPort();
    }
}
```

### 5. Weighted Response Time

```java
public class WeightedResponseTimeLoadBalancer {
    private Map<String, Double> responseTimes = new ConcurrentHashMap<>();
    
    public ServiceInstance choose(List<ServiceInstance> instances) {
        // Calculate weights (inverse of response time)
        double totalWeight = instances.stream()
            .mapToDouble(instance -> 1.0 / getResponseTime(instance))
            .sum();
        
        double random = Math.random() * totalWeight;
        
        for (ServiceInstance instance : instances) {
            random -= 1.0 / getResponseTime(instance);
            if (random <= 0) {
                return instance;
            }
        }
        
        return instances.get(0);
    }
    
    private double getResponseTime(ServiceInstance instance) {
        return responseTimes.getOrDefault(
            getInstanceId(instance), 
            100.0  // Default 100ms
        );
    }
    
    public void recordResponseTime(ServiceInstance instance, long timeMs) {
        String id = getInstanceId(instance);
        responseTimes.compute(id, (k, oldTime) -> {
            if (oldTime == null) return (double) timeMs;
            // Exponential moving average
            return 0.7 * oldTime + 0.3 * timeMs;
        });
    }
    
    private String getInstanceId(ServiceInstance instance) {
        return instance.getHost() + ":" + instance.getPort();
    }
}
```

### 6. IP Hash

```java
public class IpHashLoadBalancer {
    
    public ServiceInstance choose(List<ServiceInstance> instances, String clientIp) {
        if (instances.isEmpty()) {
            return null;
        }
        
        int hash = Math.abs(clientIp.hashCode());
        int index = hash % instances.size();
        
        return instances.get(index);
    }
}

// Same client IP always goes to same server (sticky sessions)
```

### 7. Zone-Aware Load Balancing

```java
public class ZoneAwareLoadBalancer {
    
    public ServiceInstance choose(List<ServiceInstance> instances, String clientZone) {
        // Prefer instances in same zone
        List<ServiceInstance> sameZoneInstances = instances.stream()
            .filter(instance -> clientZone.equals(instance.getMetadata().get("zone")))
            .collect(Collectors.toList());
        
        if (!sameZoneInstances.isEmpty()) {
            // Use round robin within same zone
            return roundRobin(sameZoneInstances);
        }
        
        // Fallback to any available instance
        return roundRobin(instances);
    }
    
    private ServiceInstance roundRobin(List<ServiceInstance> instances) {
        // Round robin logic
        return instances.get(0);
    }
}
```

---

## ğŸŒ± Spring Cloud LoadBalancer

### Custom Load Balancer

```java
@Configuration
public class CustomLoadBalancerConfiguration {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        return new RandomLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### Service-Specific Load Balancer

```java
@Configuration
@LoadBalancerClient(name = "payment-service", configuration = PaymentServiceLoadBalancerConfig.class)
public class LoadBalancerConfig {
}

class PaymentServiceLoadBalancerConfig {
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> reactorServiceInstanceLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        
        return new RoundRobinLoadBalancer(
            loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### Health Check Integration

```java
@Configuration
public class HealthCheckLoadBalancerConfiguration {
    
    @Bean
    public ServiceInstanceListSupplier discoveryClientServiceInstanceListSupplier(
            ConfigurableApplicationContext context) {
        return ServiceInstanceListSupplier.builder()
            .withDiscoveryClient()
            .withHealthChecks()  // Filter out unhealthy instances
            .build(context);
    }
}
```

---

## ğŸ¥ Health Checks

### Actuator Health Endpoint

```java
@RestController
public class HealthController {
    
    @Autowired
    private DataSource dataSource;
    
    @GetMapping("/actuator/health")
    public HealthResponse health() {
        boolean dbHealthy = checkDatabase();
        boolean cacheHealthy = checkCache();
        
        return new HealthResponse(
            dbHealthy && cacheHealthy ? "UP" : "DOWN",
            Map.of(
                "database", dbHealthy ? "UP" : "DOWN",
                "cache", cacheHealthy ? "UP" : "DOWN"
            )
        );
    }
    
    private boolean checkDatabase() {
        try {
            Connection conn = dataSource.getConnection();
            return conn.isValid(1);
        } catch (Exception e) {
            return false;
        }
    }
    
    private boolean checkCache() {
        // Check cache connectivity
        return true;
    }
}
```

**Configuration:**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info
  endpoint:
    health:
      show-details: always
  health:
    circuitbreakers:
      enabled: true
```

### Custom Health Indicator

```java
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try {
            Connection connection = dataSource.getConnection();
            
            if (connection.isValid(1)) {
                return Health.up()
                    .withDetail("database", "Available")
                    .withDetail("validationQuery", "isValid")
                    .build();
            } else {
                return Health.down()
                    .withDetail("database", "Unavailable")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("database", "Error")
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

---

## ğŸ’¡ Best Practices

### 1. Choose Right Algorithm

```
Use Round Robin when:
âœ… All servers have similar capacity
âœ… Requests have similar processing time

Use Weighted Response Time when:
âœ… Servers have different capacities
âœ… Want to optimize performance

Use Least Connections when:
âœ… Requests have varying processing times
âœ… Long-lived connections

Use IP Hash when:
âœ… Need session affinity
âœ… Stateful applications
```

### 2. Enable Health Checks

```yaml
spring:
  cloud:
    loadbalancer:
      health-check:
        initial-delay: 0
        interval: 25s
```

### 3. Configure Retry Logic

```java
@Configuration
public class RetryConfig {
    
    @Bean
    public RetryTemplate retryTemplate() {
        return RetryTemplate.builder()
            .maxAttempts(3)
            .fixedBackoff(1000)
            .retryOn(ServiceUnavailableException.class)
            .build();
    }
}

@Service
public class OrderService {
    
    @Autowired
    private RetryTemplate retryTemplate;
    
    @Autowired
    private RestTemplate restTemplate;
    
    public PaymentResponse processPayment(Order order) {
        return retryTemplate.execute(context -> {
            return restTemplate.postForObject(
                "http://payment-service/api/payments",
                new PaymentRequest(order),
                PaymentResponse.class
            );
        });
    }
}
```

### 4. Monitor Load Distribution

```java
@Component
public class LoadBalancerMetrics {
    
    private final MeterRegistry registry;
    private final Map<String, Counter> counters = new ConcurrentHashMap<>();
    
    public LoadBalancerMetrics(MeterRegistry registry) {
        this.registry = registry;
    }
    
    public void recordRequest(String serviceName, String instanceId) {
        String key = serviceName + ":" + instanceId;
        
        counters.computeIfAbsent(key, k -> 
            Counter.builder("loadbalancer.requests")
                .tag("service", serviceName)
                .tag("instance", instanceId)
                .register(registry)
        ).increment();
    }
}
```

### 5. Graceful Shutdown

```yaml
server:
  shutdown: graceful

spring:
  lifecycle:
    timeout-per-shutdown-phase: 20s
```

---

## ğŸ¤ Interview Questions

### Q1: What is load balancing?
**Answer:** Distributing network traffic across multiple servers to ensure high availability and performance.

### Q2: Client-side vs server-side load balancing?
**Answer:** Client-side: client chooses server (Ribbon). Server-side: load balancer chooses (Nginx, ELB).

### Q3: Load balancing algorithms?
**Answer:** Round Robin, Random, Least Connections, Weighted Response Time, IP Hash, Zone-Aware.

### Q4: What is @LoadBalanced?
**Answer:** Annotation enabling client-side load balancing for RestTemplate/WebClient.

### Q5: How does Round Robin work?
**Answer:** Distributes requests sequentially: Server1 â†’ Server2 â†’ Server3 â†’ Server1...

### Q6: What is sticky session?
**Answer:** Same client always routed to same server (using IP Hash or session cookies).

### Q7: How to implement custom load balancer?
**Answer:** Implement ReactorLoadBalancer interface, define choose() logic, register as bean.

### Q8: What is health check in load balancing?
**Answer:** Periodic checks to ensure server is healthy before routing requests to it.

### Q9: How Spring Cloud LoadBalancer works?
**Answer:** Intercepts RestTemplate/WebClient calls, discovers service instances from registry, chooses instance using algorithm.

### Q10: Difference between Ribbon and Spring Cloud LoadBalancer?
**Answer:** Ribbon is in maintenance mode. Spring Cloud LoadBalancer is modern, reactive replacement.

### Q11: What is zone-aware load balancing?
**Answer:** Prefers instances in same availability zone to reduce latency and cross-zone traffic costs.

### Q12: How to configure timeout for load-balanced requests?
**Answer:** Configure RestTemplate/WebClient timeout or use resilience4j.

### Q13: What happens when all instances are down?
**Answer:** Load balancer throws ServiceUnavailableException or returns circuit breaker fallback.

### Q14: How to distribute load unevenly?
**Answer:** Use weighted algorithms where servers have different weights based on capacity.

### Q15: What is session affinity?
**Answer:** Ensuring requests from same client go to same server (sticky sessions).

### Q16: How to monitor load balancer?
**Answer:** Track metrics: request count per instance, response times, failure rates using Micrometer.

### Q17: What is least connections algorithm?
**Answer:** Routes request to server with fewest active connections.

### Q18: Can you combine load balancing strategies?
**Answer:** Yes, e.g., zone-aware first, then round robin within zone.

### Q19: How to handle server failures?
**Answer:** Health checks remove unhealthy servers, retry failed requests on different server.

### Q20: Load balancing in Kubernetes?
**Answer:** Kubernetes Service provides built-in load balancing across pods.

---

## ğŸ“š Summary

### Algorithms Comparison

| Algorithm | Use Case | Pros | Cons |
|-----------|----------|------|------|
| **Round Robin** | Equal servers | Simple, fair | Ignores server load |
| **Random** | Stateless apps | Simple | Uneven distribution |
| **Weighted** | Different capacities | Considers capacity | Requires configuration |
| **Least Connections** | Long requests | Optimizes utilization | More complex |
| **IP Hash** | Sticky sessions | Session affinity | Uneven if few clients |

### Configuration Template

```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    public ReactorLoadBalancer<ServiceInstance> loadBalancer(
            Environment environment,
            LoadBalancerClientFactory factory) {
        
        String name = environment.getProperty(
            LoadBalancerClientFactory.PROPERTY_NAME
        );
        
        return new RoundRobinLoadBalancer(
            factory.getLazyProvider(name, ServiceInstanceListSupplier.class),
            name
        );
    }
}
```

### Best Practices

```
âœ… Choose algorithm based on workload
âœ… Enable health checks
âœ… Configure retries
âœ… Monitor load distribution
âœ… Use graceful shutdown
âœ… Consider zone-awareness
âœ… Test failover scenarios
```

**Next:** Circuit Breaker â†’

