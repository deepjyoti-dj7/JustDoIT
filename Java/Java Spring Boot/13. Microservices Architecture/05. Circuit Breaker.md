# ğŸ”Œ Circuit Breaker - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [What is Circuit Breaker](#what-is-circuit-breaker)
- [Resilience4j](#resilience4j)
- [Circuit Breaker States](#circuit-breaker-states)
- [Configuration](#configuration)
- [Fallback Methods](#fallback-methods)
- [Advanced Patterns](#advanced-patterns)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**Circuit Breaker** is a design pattern that prevents cascading failures in distributed systems by failing fast when a service is down.

### Why Circuit Breaker?

```
Problems without Circuit Breaker:
âŒ Cascading failures
âŒ Resource exhaustion
âŒ Long timeout waits
âŒ System-wide outages

Solutions with Circuit Breaker:
âœ… Fail fast
âœ… Prevent cascade
âœ… Automatic recovery
âœ… Graceful degradation
âœ… System stability
```

---

## ğŸ“š What is Circuit Breaker

### Circuit Breaker Pattern

```
Similar to electrical circuit breaker:
- Monitors for failures
- Opens circuit when threshold reached
- Prevents further calls
- Periodically attempts recovery
```

### States

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLOSED    â”‚ â† Normal operation
â”‚ (Allowing)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“ Failure threshold reached
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    OPEN     â”‚ â† Failing fast
â”‚ (Blocking)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“ Wait duration elapsed
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HALF_OPEN   â”‚ â† Testing recovery
â”‚  (Testing)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“ Success â†’ CLOSED
      â†“ Failure â†’ OPEN
```

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Order Serviceâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Circuit       â”‚
â”‚Breaker       â”‚ â†’ Monitors failures
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Payment      â”‚
â”‚ Service      â”‚ â†’ May be slow/down
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

If payment service fails:
1. Circuit opens
2. Future calls fail fast
3. Return fallback response
4. Periodically test recovery
```

---

## ğŸš€ Resilience4j

### Maven Dependencies

```xml
<dependencies>
    <!-- Resilience4j Circuit Breaker -->
    <dependency>
        <groupId>io.github.resilience4j</groupId>
        <artifactId>resilience4j-spring-boot2</artifactId>
        <version>2.1.0</version>
    </dependency>
    
    <!-- Spring Boot Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    
    <!-- AOP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
</dependencies>
```

### Basic Usage

```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentClient paymentClient;
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    public PaymentResponse processPayment(Order order) {
        // Call payment service
        return paymentClient.charge(order.getTotal());
    }
    
    // Fallback method - same parameters + Throwable
    private PaymentResponse paymentFallback(Order order, Throwable throwable) {
        log.error("Payment service unavailable: {}", throwable.getMessage());
        
        // Return default response
        return new PaymentResponse(
            null,
            PaymentStatus.PENDING,
            "Payment service temporarily unavailable. Order will be processed later."
        );
    }
}
```

---

## ğŸ”„ Circuit Breaker States

### State Details

```
CLOSED (Normal Operation):
- Requests pass through
- Failures are counted
- If failure rate > threshold â†’ OPEN

OPEN (Failing Fast):
- All requests rejected immediately
- Fallback method called
- After wait duration â†’ HALF_OPEN

HALF_OPEN (Testing Recovery):
- Limited requests allowed
- If requests succeed â†’ CLOSED
- If requests fail â†’ OPEN
```

### State Transitions

```java
@Slf4j
@Service
public class MonitoringService {
    
    @EventListener
    public void onCircuitBreakerEvent(CircuitBreakerEvent event) {
        log.info("Circuit Breaker Event: {}", event);
        
        if (event instanceof CircuitBreakerOnStateTransitionEvent) {
            CircuitBreakerOnStateTransitionEvent stateEvent = 
                (CircuitBreakerOnStateTransitionEvent) event;
            
            log.info("State transition: {} -> {}",
                stateEvent.getStateTransition().getFromState(),
                stateEvent.getStateTransition().getToState());
        }
    }
}
```

---

## âš™ï¸ Configuration

### Application YAML

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        # Failure rate threshold (percentage)
        failure-rate-threshold: 50
        
        # Minimum number of calls before calculating failure rate
        minimum-number-of-calls: 5
        
        # Number of permitted calls in HALF_OPEN state
        permitted-number-of-calls-in-half-open-state: 3
        
        # Wait duration in OPEN state (ms)
        wait-duration-in-open-state: 10000
        
        # Sliding window size
        sliding-window-size: 10
        
        # Sliding window type (COUNT_BASED or TIME_BASED)
        sliding-window-type: COUNT_BASED
        
        # Record exceptions
        record-exceptions:
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        
        # Ignore exceptions
        ignore-exceptions:
          - com.example.BusinessException
```

### Multiple Circuit Breakers

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000
      
      inventoryService:
        failure-rate-threshold: 60
        wait-duration-in-open-state: 5000
      
      notificationService:
        failure-rate-threshold: 70
        wait-duration-in-open-state: 15000
```

### Java Configuration

```java
@Configuration
public class CircuitBreakerConfig {
    
    @Bean
    public CircuitBreakerConfigCustomizer circuitBreakerCustomizer() {
        return CircuitBreakerConfigCustomizer.of("paymentService", builder -> 
            builder
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(10))
                .permittedNumberOfCallsInHalfOpenState(3)
                .slidingWindowSize(10)
                .recordExceptions(IOException.class, TimeoutException.class)
                .ignoreExceptions(BusinessException.class)
        );
    }
}
```

---

## ğŸ›¡ï¸ Fallback Methods

### Simple Fallback

```java
@Service
public class UserService {
    
    @CircuitBreaker(name = "userService", fallbackMethod = "getUserFallback")
    public User getUser(Long id) {
        return restTemplate.getForObject(
            "http://user-service/api/users/" + id,
            User.class
        );
    }
    
    private User getUserFallback(Long id, Throwable t) {
        log.error("User service unavailable for user {}: {}", id, t.getMessage());
        
        // Return cached data or default
        return new User(id, "Unknown User", "N/A");
    }
}
```

### Cached Fallback

```java
@Service
public class ProductService {
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;
    
    @CircuitBreaker(name = "productService", fallbackMethod = "getProductFallback")
    public Product getProduct(Long id) {
        Product product = restTemplate.getForObject(
            "http://product-service/api/products/" + id,
            Product.class
        );
        
        // Cache successful response
        redisTemplate.opsForValue().set("product:" + id, product, 1, TimeUnit.HOURS);
        
        return product;
    }
    
    private Product getProductFallback(Long id, Throwable t) {
        // Try cache first
        Product cached = redisTemplate.opsForValue().get("product:" + id);
        
        if (cached != null) {
            log.info("Returning cached product for id: {}", id);
            return cached;
        }
        
        // Return default
        return new Product(id, "Product Unavailable", BigDecimal.ZERO);
    }
}
```

### Multiple Fallback Levels

```java
@Service
public class OrderService {
    
    @CircuitBreaker(name = "primaryService", fallbackMethod = "secondaryServiceFallback")
    public OrderResponse createOrder(OrderRequest request) {
        return primaryService.createOrder(request);
    }
    
    @CircuitBreaker(name = "secondaryService", fallbackMethod = "finalFallback")
    private OrderResponse secondaryServiceFallback(OrderRequest request, Throwable t) {
        log.warn("Primary service failed, trying secondary");
        return secondaryService.createOrder(request);
    }
    
    private OrderResponse finalFallback(OrderRequest request, Throwable t) {
        log.error("All services failed: {}", t.getMessage());
        return new OrderResponse(null, OrderStatus.PENDING, 
            "Order will be processed later");
    }
}
```

---

## ğŸš€ Advanced Patterns

### Circuit Breaker + Retry

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50
  
  retry:
    instances:
      paymentService:
        max-attempts: 3
        wait-duration: 1000
```

```java
@Service
public class PaymentService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    @Retry(name = "paymentService")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
    
    private PaymentResponse paymentFallback(PaymentRequest request, Throwable t) {
        return new PaymentResponse(PaymentStatus.PENDING);
    }
}
```

### Circuit Breaker + Time Limiter

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50
  
  timelimiter:
    instances:
      paymentService:
        timeout-duration: 3s
```

```java
@Service
public class PaymentService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    @TimeLimiter(name = "paymentService")
    public CompletableFuture<PaymentResponse> processPaymentAsync(PaymentRequest request) {
        return CompletableFuture.supplyAsync(() -> 
            paymentClient.charge(request)
        );
    }
    
    private CompletableFuture<PaymentResponse> paymentFallback(
            PaymentRequest request, Throwable t) {
        return CompletableFuture.completedFuture(
            new PaymentResponse(PaymentStatus.PENDING)
        );
    }
}
```

### Circuit Breaker + Bulkhead

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50
  
  bulkhead:
    instances:
      paymentService:
        max-concurrent-calls: 10
        max-wait-duration: 1000
```

```java
@Service
public class PaymentService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    @Bulkhead(name = "paymentService")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
}
```

### Event Monitoring

```java
@Configuration
public class CircuitBreakerEventConfig {
    
    @Bean
    public CircuitBreakerEventListener circuitBreakerEventListener(
            CircuitBreakerRegistry registry) {
        
        return new CircuitBreakerEventListener(registry);
    }
}

@Slf4j
public class CircuitBreakerEventListener {
    
    public CircuitBreakerEventListener(CircuitBreakerRegistry registry) {
        registry.circuitBreaker("paymentService")
            .getEventPublisher()
            .onStateTransition(event -> 
                log.info("State transition: {}", event.getStateTransition()))
            .onFailureRateExceeded(event -> 
                log.warn("Failure rate exceeded: {}%", event.getFailureRate()))
            .onError(event -> 
                log.error("Error occurred: {}", event.getThrowable().getMessage()))
            .onSuccess(event -> 
                log.debug("Success: {}", event.getElapsedDuration()));
    }
}
```

### Health Endpoint

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,circuitbreakers,circuitbreakerevents
  
  health:
    circuitbreakers:
      enabled: true
  
  endpoint:
    health:
      show-details: always
```

**Access:**
```
GET /actuator/health
GET /actuator/circuitbreakers
GET /actuator/circuitbreakerevents
```

---

## ğŸ’¡ Best Practices

### 1. Configure Appropriate Thresholds

```yaml
# âœ… Good - Reasonable thresholds
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 50  # 50% failures
        minimum-number-of-calls: 5   # Need 5 calls first
        wait-duration-in-open-state: 10000  # 10 seconds

# âŒ Bad - Too sensitive
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        failure-rate-threshold: 10  # Opens too easily
        minimum-number-of-calls: 1   # Not enough data
        wait-duration-in-open-state: 60000  # Too long
```

### 2. Provide Meaningful Fallbacks

```java
// âœ… Good - Useful fallback
private User getUserFallback(Long id, Throwable t) {
    // Try cache
    User cached = cache.get("user:" + id);
    if (cached != null) return cached;
    
    // Return partial data
    return new User(id, "User data temporarily unavailable", null);
}

// âŒ Bad - Useless fallback
private User getUserFallback(Long id, Throwable t) {
    return null;  // Not helpful
}
```

### 3. Log Circuit Breaker Events

```java
@EventListener
public void onCircuitBreakerEvent(CircuitBreakerEvent event) {
    if (event instanceof CircuitBreakerOnErrorEvent) {
        log.error("Circuit Breaker error: {}", event);
        // Alert ops team
        alertingService.sendAlert("Circuit Breaker error in " + 
            event.getCircuitBreakerName());
    }
}
```

### 4. Monitor Metrics

```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public MeterBinder circuitBreakerMetrics(CircuitBreakerRegistry registry) {
        return new CircuitBreakerMetrics(registry);
    }
}
```

### 5. Test Circuit Breaker

```java
@Test
public void testCircuitBreaker() {
    // Simulate failures
    for (int i = 0; i < 10; i++) {
        try {
            orderService.processPayment(order);
        } catch (Exception e) {
            // Expected
        }
    }
    
    // Verify circuit is open
    CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("paymentService");
    assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);
    
    // Verify fallback is called
    PaymentResponse response = orderService.processPayment(order);
    assertThat(response.getStatus()).isEqualTo(PaymentStatus.PENDING);
}
```

---

## ğŸ¤ Interview Questions

### Q1: What is Circuit Breaker pattern?
**Answer:** Design pattern that prevents cascading failures by failing fast when a service is down.

### Q2: Circuit Breaker states?
**Answer:** CLOSED (normal), OPEN (failing fast), HALF_OPEN (testing recovery).

### Q3: When does circuit open?
**Answer:** When failure rate exceeds threshold after minimum number of calls.

### Q4: What is fallback method?
**Answer:** Alternative method called when circuit is open, providing graceful degradation.

### Q5: Resilience4j vs Hystrix?
**Answer:** Resilience4j is modern, lightweight, functional. Hystrix is in maintenance mode.

### Q6: What is failure rate threshold?
**Answer:** Percentage of failures that triggers circuit to open (e.g., 50%).

### Q7: What is wait duration?
**Answer:** Time circuit stays OPEN before transitioning to HALF_OPEN.

### Q8: What is HALF_OPEN state?
**Answer:** Testing state allowing limited requests to check if service recovered.

### Q9: Can you combine Circuit Breaker with Retry?
**Answer:** Yes, retry first, then circuit breaker if all retries fail.

### Q10: How to monitor Circuit Breaker?
**Answer:** Use Spring Boot Actuator endpoints: /actuator/circuitbreakers, metrics, event listeners.

### Q11: What is sliding window?
**Answer:** Moving window of recent calls used to calculate failure rate (COUNT_BASED or TIME_BASED).

### Q12: Difference between record-exceptions and ignore-exceptions?
**Answer:** record-exceptions count as failures, ignore-exceptions don't affect circuit breaker.

### Q13: How to test Circuit Breaker?
**Answer:** Simulate failures, verify state transitions, test fallback methods.

### Q14: What is minimum-number-of-calls?
**Answer:** Minimum calls required before circuit breaker calculates failure rate.

### Q15: Can fallback call another service?
**Answer:** Yes, can have fallback chain or call alternative service.

### Q16: How to disable Circuit Breaker for testing?
**Answer:** Set `resilience4j.circuitbreaker.enabled: false` in test profile.

### Q17: What happens to queued requests when circuit opens?
**Answer:** They fail fast and call fallback method immediately.

### Q18: Can you have different thresholds for different services?
**Answer:** Yes, configure separate circuit breaker instance for each service.

### Q19: How to manually transition circuit state?
**Answer:** Use `circuitBreaker.transitionToOpenState()` or `transitionToClosedState()`.

### Q20: Best practices for fallback?
**Answer:** Provide cached data, partial data, or informative error message; never return null.

---

## ğŸ“š Summary

### Key Concepts

```
1. Circuit Breaker States
   CLOSED â†’ OPEN â†’ HALF_OPEN â†’ CLOSED

2. Configuration
   - failure-rate-threshold
   - minimum-number-of-calls
   - wait-duration-in-open-state

3. Fallback
   - Same parameters + Throwable
   - Provide meaningful alternative
   - Use cache or defaults

4. Monitoring
   - Event listeners
   - Actuator endpoints
   - Metrics
```

### Configuration Template

```yaml
resilience4j:
  circuitbreaker:
    instances:
      serviceName:
        failure-rate-threshold: 50
        minimum-number-of-calls: 5
        permitted-number-of-calls-in-half-open-state: 3
        wait-duration-in-open-state: 10000
        sliding-window-size: 10
        sliding-window-type: COUNT_BASED
```

### Usage Template

```java
@CircuitBreaker(name = "serviceName", fallbackMethod = "fallback")
public Response callService(Request request) {
    return client.call(request);
}

private Response fallback(Request request, Throwable t) {
    return new Response(Status.PENDING);
}
```

**Next:** Distributed Tracing â†’

