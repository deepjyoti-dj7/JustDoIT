# ğŸ—ï¸ Microservices Principles - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [What are Microservices](#what-are-microservices)
- [Core Principles](#core-principles)
- [Monolith vs Microservices](#monolith-vs-microservices)
- [Design Patterns](#design-patterns)
- [Challenges](#challenges)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**Microservices Architecture** is an architectural style that structures an application as a collection of loosely coupled, independently deployable services.

### Why Microservices?

```
Benefits:
âœ… Independent deployment
âœ… Technology diversity
âœ… Scalability
âœ… Fault isolation
âœ… Team autonomy
âœ… Faster development
âœ… Easy maintenance
```

### Evolution of Architecture

```
Monolith (1990s-2000s)
    â†“
SOA - Service-Oriented Architecture (2000s)
    â†“
Microservices (2010s-Present)
    â†“
Serverless/Functions (Present)
```

---

## ğŸ“š What are Microservices

### Definition

> "Microservices are small, autonomous services that work together, modeled around a business domain."
> â€” Sam Newman, Building Microservices

### Key Characteristics

```java
1. Single Responsibility
   - Each service does ONE thing well
   - Focused on specific business capability

2. Autonomous
   - Can be deployed independently
   - Own its own data store
   - Versioned independently

3. Decentralized
   - No central orchestrator
   - Decentralized governance
   - Decentralized data management

4. Resilient
   - Designed for failure
   - Graceful degradation
   - Circuit breakers

5. Observable
   - Centralized logging
   - Distributed tracing
   - Health monitoring
```

### Microservices Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client/Browser                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway                           â”‚
â”‚          (Routing, Authentication, Rate Limiting)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“                  â†“                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User       â”‚  â”‚   Order      â”‚  â”‚   Product    â”‚
â”‚   Service    â”‚  â”‚   Service    â”‚  â”‚   Service    â”‚
â”‚              â”‚  â”‚              â”‚  â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚User DB â”‚  â”‚  â”‚  â”‚Order DBâ”‚  â”‚  â”‚  â”‚Prod DB â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ Core Principles

### 1. Single Responsibility Principle

```java
// âŒ Bad - Monolithic Service
@Service
public class OrderService {
    public Order createOrder(OrderRequest request) {
        // Create order
        // Process payment
        // Update inventory
        // Send email
        // Generate invoice
        // Update analytics
    }
}

// âœ… Good - Separate Microservices
@Service
public class OrderService {
    private final PaymentClient paymentClient;
    private final InventoryClient inventoryClient;
    private final NotificationClient notificationClient;
    
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // Call other services
        paymentClient.processPayment(order);
        inventoryClient.reduceStock(order.getItems());
        notificationClient.sendOrderConfirmation(order);
        
        return order;
    }
}
```

### 2. Database per Service

```
Each service owns its data:

User Service         Order Service        Product Service
    â†“                    â†“                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User DB â”‚         â”‚Order DB â”‚          â”‚Product  â”‚
â”‚         â”‚         â”‚         â”‚          â”‚  DB     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… Benefits:
- Service independence
- Different database types
- Easier scaling

âŒ Challenges:
- Data consistency
- Joins across services
- Distributed transactions
```

### 3. Decentralized Governance

```java
// Different services can use different technologies

// User Service - Java/Spring Boot + PostgreSQL
@SpringBootApplication
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

// Order Service - Node.js + MongoDB
const express = require('express');
const app = express();
app.listen(3000);

// Analytics Service - Python + Cassandra
from flask import Flask
app = Flask(__name__)
app.run(port=5000)
```

### 4. Smart Endpoints, Dumb Pipes

```java
// âœ… Good - Smart Services, Simple Communication
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        // Business logic in service
        Order order = orderService.createOrder(request);
        
        // Simple HTTP call to other service
        PaymentResponse payment = restTemplate.postForObject(
            "http://payment-service/api/payments",
            new PaymentRequest(order),
            PaymentResponse.class
        );
        
        return ResponseEntity.ok(order);
    }
}

// Use simple protocols: REST, gRPC, messaging
// Avoid ESB (Enterprise Service Bus) complexity
```

### 5. Design for Failure

```java
// Circuit Breaker Pattern
@Service
public class OrderService {
    
    @CircuitBreaker(name = "payment-service", fallbackMethod = "paymentFallback")
    public PaymentResponse processPayment(Order order) {
        return paymentClient.processPayment(order);
    }
    
    // Fallback when payment service is down
    public PaymentResponse paymentFallback(Order order, Exception e) {
        log.error("Payment service unavailable", e);
        return new PaymentResponse(PaymentStatus.PENDING);
    }
}
```

### 6. Eventual Consistency

```java
// Event-driven architecture for data consistency

// Order Service publishes event
@Service
public class OrderService {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // Publish event
        OrderEvent event = new OrderEvent(order.getId(), OrderStatus.CREATED);
        kafkaTemplate.send("order-events", event);
        
        return order;
    }
}

// Inventory Service consumes event
@Service
public class InventoryEventConsumer {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderEvent(OrderEvent event) {
        if (event.getStatus() == OrderStatus.CREATED) {
            inventoryService.reduceStock(event.getOrderId());
        }
    }
}
```

---

## ğŸ†š Monolith vs Microservices

### Architecture Comparison

| Aspect | Monolith | Microservices |
|--------|----------|---------------|
| **Structure** | Single codebase | Multiple services |
| **Deployment** | Deploy entire app | Deploy individual services |
| **Scaling** | Scale entire app | Scale specific services |
| **Technology** | Single tech stack | Polyglot architecture |
| **Database** | Single database | Database per service |
| **Development** | Faster initially | Slower initially |
| **Complexity** | Lower | Higher |
| **Team Structure** | Single team | Multiple teams |
| **Failure Impact** | Entire app down | Isolated failures |

### Monolithic Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Monolithic Application        â”‚
â”‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Presentation Layer      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Business Logic          â”‚ â”‚
â”‚  â”‚  - User Management           â”‚ â”‚
â”‚  â”‚  - Order Processing          â”‚ â”‚
â”‚  â”‚  - Payment Processing        â”‚ â”‚
â”‚  â”‚  - Inventory Management      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚      Data Access Layer       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                â†“                   â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚       â”‚    Database    â”‚          â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Microservices Architecture

```
                  API Gateway
                       â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“                 â†“                  â†“
User Service     Order Service    Payment Service
    â†“                 â†“                  â†“
  User DB          Order DB          Payment DB
```

### When to Use Each

```
Use Monolith When:
âœ… Small team (< 10 developers)
âœ… Simple application
âœ… Rapid prototyping
âœ… Limited resources
âœ… Predictable scaling needs

Use Microservices When:
âœ… Large team (> 10 developers)
âœ… Complex application
âœ… Independent scaling needed
âœ… Technology diversity required
âœ… Frequent deployments
âœ… High availability critical
```

---

## ğŸ¨ Design Patterns

### 1. API Gateway Pattern

```java
// Single entry point for all clients
@RestController
public class ApiGateway {
    
    @Autowired
    private UserServiceClient userService;
    
    @Autowired
    private OrderServiceClient orderService;
    
    @GetMapping("/api/user-orders/{userId}")
    public UserOrdersResponse getUserOrders(@PathVariable Long userId) {
        // Aggregate data from multiple services
        User user = userService.getUser(userId);
        List<Order> orders = orderService.getUserOrders(userId);
        
        return new UserOrdersResponse(user, orders);
    }
}
```

### 2. Service Discovery Pattern

```java
// Services register themselves and discover others

@SpringBootApplication
@EnableEurekaClient
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

// Discover and call services
@Service
public class OrderService {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    public PaymentResponse processPayment(Order order) {
        // Discover payment service instances
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("payment-service");
        
        ServiceInstance instance = instances.get(0);
        String url = instance.getUri() + "/api/payments";
        
        return restTemplate.postForObject(url, order, PaymentResponse.class);
    }
}
```

### 3. Circuit Breaker Pattern

```java
@Service
public class OrderService {
    
    @CircuitBreaker(
        name = "payment-service",
        fallbackMethod = "paymentFallback"
    )
    @Retry(name = "payment-service", fallbackMethod = "paymentFallback")
    public PaymentResponse processPayment(Order order) {
        return paymentClient.charge(order.getTotal());
    }
    
    private PaymentResponse paymentFallback(Order order, Exception e) {
        // Fallback: Mark payment as pending
        return new PaymentResponse(PaymentStatus.PENDING);
    }
}
```

### 4. Saga Pattern (Distributed Transactions)

```java
// Choreography-based Saga
@Service
public class OrderSaga {
    
    // Step 1: Create Order
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        eventPublisher.publish(new OrderCreatedEvent(order));
        return order;
    }
    
    // Step 2: Process Payment (listener in Payment Service)
    @EventListener
    public void onOrderCreated(OrderCreatedEvent event) {
        try {
            paymentService.processPayment(event.getOrder());
            eventPublisher.publish(new PaymentSuccessEvent(event.getOrder()));
        } catch (Exception e) {
            eventPublisher.publish(new PaymentFailedEvent(event.getOrder()));
        }
    }
    
    // Step 3: Update Inventory (listener in Inventory Service)
    @EventListener
    public void onPaymentSuccess(PaymentSuccessEvent event) {
        inventoryService.reduceStock(event.getOrder().getItems());
    }
    
    // Compensating transaction
    @EventListener
    public void onPaymentFailed(PaymentFailedEvent event) {
        orderRepository.updateStatus(event.getOrderId(), OrderStatus.CANCELLED);
    }
}
```

### 5. Event Sourcing Pattern

```java
// Store all changes as sequence of events
@Service
public class OrderEventStore {
    
    @Autowired
    private EventRepository eventRepository;
    
    public void createOrder(OrderRequest request) {
        // Store event instead of current state
        OrderCreatedEvent event = new OrderCreatedEvent(
            UUID.randomUUID(),
            request.getUserId(),
            request.getItems(),
            LocalDateTime.now()
        );
        
        eventRepository.save(event);
        eventPublisher.publish(event);
    }
    
    // Rebuild state from events
    public Order getOrder(UUID orderId) {
        List<OrderEvent> events = eventRepository.findByOrderId(orderId);
        
        Order order = new Order();
        for (OrderEvent event : events) {
            order.apply(event);  // Replay events
        }
        return order;
    }
}
```

### 6. CQRS Pattern (Command Query Responsibility Segregation)

```java
// Separate read and write models

// Write Model (Command)
@Service
public class OrderCommandService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    public Order createOrder(CreateOrderCommand command) {
        Order order = new Order(command);
        orderRepository.save(order);
        
        // Publish event for read model
        eventPublisher.publish(new OrderCreatedEvent(order));
        
        return order;
    }
}

// Read Model (Query)
@Service
public class OrderQueryService {
    
    @Autowired
    private OrderReadRepository readRepository;
    
    public OrderView getOrder(UUID orderId) {
        // Optimized for reads
        return readRepository.findById(orderId);
    }
    
    @EventListener
    public void onOrderCreated(OrderCreatedEvent event) {
        // Update read model
        OrderView view = new OrderView(event);
        readRepository.save(view);
    }
}
```

---

## âš ï¸ Challenges

### 1. Distributed Transactions

```
Problem: No ACID transactions across services

Solutions:
- Saga Pattern
- Event Sourcing
- Two-Phase Commit (2PC)
- Eventual Consistency
```

### 2. Data Consistency

```java
// Challenge: User data in multiple services
// User Service has: name, email
// Order Service has: userName (denormalized)
// Payment Service has: userEmail (denormalized)

// Solution: Event-driven updates
@Service
public class UserService {
    
    public void updateUser(Long userId, UserRequest request) {
        User user = userRepository.findById(userId).orElseThrow();
        user.setName(request.getName());
        user.setEmail(request.getEmail());
        userRepository.save(user);
        
        // Publish event
        eventPublisher.publish(new UserUpdatedEvent(user));
    }
}

// Other services update their copies
@EventListener
public void onUserUpdated(UserUpdatedEvent event) {
    orderRepository.updateUserName(event.getUserId(), event.getName());
}
```

### 3. Network Latency

```java
// Challenge: Multiple network calls
// Order â†’ Payment â†’ Inventory â†’ Notification
// Total latency = sum of all calls

// Solution 1: Async processing
@Async
public CompletableFuture<PaymentResponse> processPayment(Order order) {
    return CompletableFuture.completedFuture(
        paymentClient.charge(order.getTotal())
    );
}

// Solution 2: Event-driven
eventPublisher.publish(new OrderCreatedEvent(order));
// Don't wait for payment/inventory
```

### 4. Service Discovery

```
Problem: How do services find each other?

Solutions:
- Eureka (Netflix)
- Consul (HashiCorp)
- Kubernetes Service Discovery
- Zookeeper
```

### 5. Monitoring & Debugging

```java
// Challenge: Tracing requests across services

// Solution: Distributed Tracing
@RestController
public class OrderController {
    
    @GetMapping("/api/orders/{id}")
    public Order getOrder(@PathVariable Long id) {
        // Trace ID propagated across all services
        // Order Service â†’ Payment Service â†’ Inventory Service
        
        log.info("TraceId: {} - Fetching order {}", 
            MDC.get("traceId"), id);
        
        return orderService.getOrder(id);
    }
}

// Use: Zipkin, Jaeger, Spring Cloud Sleuth
```

---

## ğŸ’¡ Best Practices

### 1. Domain-Driven Design

```java
// âœ… Good - Services aligned with business domains
User Service (User Management Domain)
Order Service (Order Management Domain)
Payment Service (Payment Domain)
Inventory Service (Inventory Domain)

// âŒ Bad - Technical separation
Database Service
Business Logic Service
API Service
```

### 2. API Versioning

```java
// âœ… Good - Version your APIs
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 {
    // Version 1 implementation
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
    // Version 2 with breaking changes
}
```

### 3. Backward Compatibility

```java
// âœ… Good - Add fields, don't remove
public class UserResponse {
    private Long id;
    private String name;
    private String email;
    private String phone;  // New field (OK)
    
    @Deprecated
    private String username;  // Old field (keep for backward compatibility)
}

// âŒ Bad - Remove fields
public class UserResponse {
    private Long id;
    private String name;
    // Removed email field - breaks old clients!
}
```

### 4. Health Checks

```java
@RestController
public class HealthController {
    
    @Autowired
    private DatabaseHealthIndicator dbHealth;
    
    @GetMapping("/actuator/health")
    public HealthResponse health() {
        boolean isHealthy = dbHealth.check().isUp() &&
                          cacheHealth.check().isUp();
        
        return new HealthResponse(isHealthy ? "UP" : "DOWN");
    }
}
```

### 5. Independent Deployment

```
âœ… Each service should be deployable independently
âœ… Use feature flags for gradual rollout
âœ… Implement blue-green deployment
âœ… Use canary releases
```

---

## ğŸ¤ Interview Questions

### Q1: What are microservices?
**Answer:** Architectural style structuring an application as collection of loosely coupled, independently deployable services, each focused on specific business capability.

### Q2: Benefits of microservices?
**Answer:** Independent deployment, scalability, technology diversity, fault isolation, team autonomy, faster development.

### Q3: Challenges of microservices?
**Answer:** Distributed transactions, data consistency, network latency, complexity, monitoring, testing.

### Q4: Database per service principle?
**Answer:** Each microservice owns its database, ensuring loose coupling and independent deployment.

### Q5: How to handle distributed transactions?
**Answer:** Use Saga pattern (choreography or orchestration), event sourcing, or eventual consistency.

### Q6: What is API Gateway?
**Answer:** Single entry point for all clients, handling routing, authentication, rate limiting, request aggregation.

### Q7: What is service discovery?
**Answer:** Mechanism for services to find and communicate with each other dynamically (Eureka, Consul).

### Q8: What is circuit breaker pattern?
**Answer:** Prevents cascading failures by failing fast when a service is down, with fallback mechanism.

### Q9: Monolith vs Microservices?
**Answer:** Monolith = single deployment unit; Microservices = multiple independent services. Trade-offs in complexity vs scalability.

### Q10: What is eventual consistency?
**Answer:** Data consistency achieved over time through async events, instead of immediate ACID transactions.

### Q11: How to ensure data consistency?
**Answer:** Use event-driven architecture, publish events when data changes, other services update their copies.

### Q12: What is Saga pattern?
**Answer:** Managing distributed transactions as sequence of local transactions with compensating transactions for rollback.

### Q13: What is CQRS?
**Answer:** Command Query Responsibility Segregation - separate read and write models for better performance.

### Q14: What is event sourcing?
**Answer:** Storing all changes as sequence of events instead of current state, allows event replay.

### Q15: How to handle inter-service communication?
**Answer:** Synchronous (REST, gRPC) or asynchronous (messaging queues, events).

### Q16: What is bounded context?
**Answer:** DDD concept - each microservice has its own domain model with clear boundaries.

### Q17: How to handle service failures?
**Answer:** Circuit breakers, retries, timeouts, fallbacks, bulkheads, rate limiting.

### Q18: What is polyglot persistence?
**Answer:** Using different database types for different services based on their needs.

### Q19: How to version microservices APIs?
**Answer:** URL versioning (/v1/, /v2/), header versioning, or content negotiation.

### Q20: When NOT to use microservices?
**Answer:** Small applications, small teams, simple domains, when consistency > scalability, limited DevOps maturity.

---

## ğŸ“š Summary

### Core Principles

```
1. Single Responsibility - One service, one job
2. Database per Service - Own your data
3. Decentralized Governance - Technology freedom
4. Smart Endpoints, Dumb Pipes - Simple communication
5. Design for Failure - Resilience built-in
6. Eventual Consistency - Accept async updates
```

### Key Patterns

```
âœ… API Gateway - Single entry point
âœ… Service Discovery - Dynamic service location
âœ… Circuit Breaker - Failure handling
âœ… Saga - Distributed transactions
âœ… Event Sourcing - Event-based state
âœ… CQRS - Separate read/write models
```

### Decision Framework

```
Choose Microservices if:
âœ… Large, complex application
âœ… Independent scaling needed
âœ… Multiple teams
âœ… Technology diversity required
âœ… Frequent deployments
âœ… High availability critical

Stick with Monolith if:
âœ… Small application
âœ… Small team
âœ… Simple domain
âœ… Rapid prototyping
âœ… Limited resources
```

**Next:** Service Discovery â†’

