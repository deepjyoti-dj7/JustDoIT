# üîç Distributed Tracing - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [What is Distributed Tracing](#what-is-distributed-tracing)
- [Spring Cloud Sleuth](#spring-cloud-sleuth)
- [Zipkin](#zipkin)
- [Trace Context Propagation](#trace-context-propagation)
- [Integration](#integration)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Distributed Tracing** tracks requests as they flow through multiple microservices, helping identify performance bottlenecks and debug issues in distributed systems.

### Why Distributed Tracing?

```
Problems without Tracing:
‚ùå Hard to debug multi-service requests
‚ùå Unknown performance bottlenecks
‚ùå Difficult to track request flow
‚ùå No visibility into latency

Solutions with Tracing:
‚úÖ Complete request visibility
‚úÖ Performance analysis
‚úÖ Error diagnosis
‚úÖ Service dependency mapping
‚úÖ Latency identification
```

---

## üìö What is Distributed Tracing

### Request Flow

```
Client Request
    ‚Üì [Trace ID: abc123]
API Gateway (Span: gateway)
    ‚Üì [Trace ID: abc123, Span ID: 001]
Order Service (Span: order)
    ‚îú‚Üí Payment Service (Span: payment)
    ‚îÇ   ‚îî‚Üí [Trace ID: abc123, Span ID: 003]
    ‚îî‚Üí Inventory Service (Span: inventory)
        ‚îî‚Üí [Trace ID: abc123, Span ID: 004]

All spans share same Trace ID
```

### Key Concepts

```
Trace: Complete request journey
‚îú‚îÄ Span: Single operation
‚îÇ  ‚îú‚îÄ Span ID: Unique identifier
‚îÇ  ‚îú‚îÄ Parent Span ID: Parent operation
‚îÇ  ‚îú‚îÄ Start Time: When started
‚îÇ  ‚îú‚îÄ Duration: How long it took
‚îÇ  ‚îî‚îÄ Tags: Metadata (service, method, status)
‚îî‚îÄ Trace ID: Links all spans together
```

---

## üå± Spring Cloud Sleuth

### Maven Dependencies

```xml
<dependencies>
    <!-- Spring Cloud Sleuth -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    
    <!-- Zipkin for visualization -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin</artifactId>
    </dependency>
</dependencies>
```

### Auto-Configuration

```java
@SpringBootApplication
public class OrderServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}

// Sleuth automatically instruments:
// - RestTemplate
// - WebClient
// - Feign Clients
// - Message queues (Kafka, RabbitMQ)
// - Async methods
// - Scheduled tasks
```

### Configuration

```yaml
spring:
  application:
    name: order-service
  
  sleuth:
    sampler:
      probability: 1.0  # Sample 100% of requests (reduce in production)
    
    # Baggage propagation
    baggage:
      remote-fields: user-id, request-id
      correlation-fields: user-id
  
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web  # or kafka/rabbit
```

---

## üéØ Zipkin

### Running Zipkin

**Docker:**

```bash
docker run -d -p 9411:9411 openzipkin/zipkin
```

**Access UI:**
```
http://localhost:9411
```

### Zipkin UI Features

```
1. Search Traces
   - By service name
   - By span name
   - By trace ID
   - By time range

2. Trace View
   - Visual timeline
   - Service dependencies
   - Span duration
   - Error spans

3. Dependencies
   - Service dependency graph
   - Call counts
   - Error rates
```

---

## üì® Trace Context Propagation

### Automatic Propagation

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order createOrder(OrderRequest request) {
        log.info("Creating order");  // Includes trace ID
        
        // Trace ID automatically propagated
        PaymentResponse payment = restTemplate.postForObject(
            "http://payment-service/api/payments",
            new PaymentRequest(request),
            PaymentResponse.class
        );
        
        return new Order(request, payment);
    }
}
```

### Logging with Trace ID

```java
// Logback configuration (logback-spring.xml)
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - [TraceId: %X{traceId}] [SpanId: %X{spanId}] - %msg%n
            </pattern>
        </encoder>
    </appender>
</configuration>
```

**Log Output:**
```
2024-12-20 10:15:30 [http-nio-8081-exec-1] INFO  o.e.OrderService - [TraceId: abc123] [SpanId: 001] - Creating order
2024-12-20 10:15:31 [http-nio-8082-exec-1] INFO  o.e.PaymentService - [TraceId: abc123] [SpanId: 003] - Processing payment
```

### Custom Spans

```java
@Service
public class OrderService {
    
    @Autowired
    private Tracer tracer;
    
    public Order createOrder(OrderRequest request) {
        // Create custom span
        Span customSpan = tracer.nextSpan().name("validate-order");
        
        try (Tracer.SpanInScope ws = tracer.withSpan(customSpan.start())) {
            // Add custom tags
            customSpan.tag("order.type", request.getType());
            customSpan.tag("user.id", request.getUserId().toString());
            
            // Business logic
            validateOrder(request);
            
        } finally {
            customSpan.end();
        }
        
        return orderRepository.save(new Order(request));
    }
}
```

### Baggage

**Propagating Custom Data:**

```java
@RestController
public class OrderController {
    
    @Autowired
    private BaggageField userIdField;
    
    @PostMapping("/api/orders")
    public Order createOrder(@RequestBody OrderRequest request) {
        // Set baggage (propagated to all downstream services)
        userIdField.updateValue(request.getUserId().toString());
        
        return orderService.createOrder(request);
    }
}
```

**Configuration:**

```yaml
spring:
  sleuth:
    baggage:
      remote-fields: user-id, session-id
      correlation-fields: user-id  # Also available in logs
```

**Accessing Baggage:**

```java
@Service
public class PaymentService {
    
    @Autowired
    private BaggageField userIdField;
    
    public PaymentResponse processPayment(PaymentRequest request) {
        String userId = userIdField.get();
        log.info("Processing payment for user: {}", userId);
        
        return new PaymentResponse();
    }
}
```

---

## üîó Integration

### RestTemplate

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
        // Sleuth automatically adds tracing interceptor
    }
}

@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public PaymentResponse callPaymentService(PaymentRequest request) {
        // Trace context automatically propagated
        return restTemplate.postForObject(
            "http://payment-service/api/payments",
            request,
            PaymentResponse.class
        );
    }
}
```

### WebClient

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder().build();
        // Sleuth automatically adds tracing filter
    }
}

@Service
public class OrderService {
    
    @Autowired
    private WebClient webClient;
    
    public Mono<PaymentResponse> callPaymentService(PaymentRequest request) {
        return webClient.post()
            .uri("http://payment-service/api/payments")
            .bodyValue(request)
            .retrieve()
            .bodyToMono(PaymentResponse.class);
    }
}
```

### Feign Client

```java
@FeignClient(name = "payment-service")
public interface PaymentClient {
    
    @PostMapping("/api/payments")
    PaymentResponse processPayment(@RequestBody PaymentRequest request);
    // Trace context automatically propagated
}
```

### Kafka

```yaml
spring:
  kafka:
    producer:
      properties:
        spring.sleuth.baggage.remote-fields: user-id
```

```java
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderEvent(Order order) {
        OrderEvent event = new OrderEvent(order);
        
        // Trace context automatically added to message headers
        kafkaTemplate.send("order-events", event);
    }
}

@Service
public class OrderEventConsumer {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderEvent(OrderEvent event) {
        // Trace context automatically extracted from headers
        log.info("Processing order event");
    }
}
```

### Async Methods

```java
@Service
public class OrderService {
    
    @Async
    public CompletableFuture<PaymentResponse> processPaymentAsync(Order order) {
        // Trace context automatically propagated to async thread
        log.info("Processing payment asynchronously");
        
        PaymentResponse response = paymentClient.charge(order.getTotal());
        return CompletableFuture.completedFuture(response);
    }
}
```

---

## üöÄ Advanced Features

### Custom Trace Exporter

```java
@Component
public class CustomSpanHandler extends SpanHandler {
    
    @Override
    public boolean end(TraceContext context, MutableSpan span, Cause cause) {
        // Custom logic when span ends
        log.info("Span ended: {} - Duration: {}ms", 
            span.name(), 
            span.finishTimestamp() - span.startTimestamp());
        
        // Send to custom backend
        if (span.tag("error") != null) {
            alertingService.sendAlert("Error in span: " + span.name());
        }
        
        return true;
    }
}
```

### Performance Sampling

```yaml
spring:
  sleuth:
    sampler:
      # Sample 10% of requests in production
      probability: 0.1
      
      # Sample specific patterns
      rate: 10  # per second
```

```java
@Component
public class CustomSampler extends Sampler {
    
    @Override
    public SamplingDecision trySample(SamplingInput input) {
        String path = input.request().path();
        
        // Always sample error requests
        if (path.contains("/error")) {
            return SamplingDecision.SAMPLE;
        }
        
        // Never sample health checks
        if (path.contains("/health")) {
            return SamplingDecision.NO_SAMPLE;
        }
        
        // Sample 10% of other requests
        return Math.random() < 0.1 ? 
            SamplingDecision.SAMPLE : 
            SamplingDecision.NO_SAMPLE;
    }
}
```

### Trace Filtering

```java
@Component
public class TraceFilter implements Filter {
    
    @Autowired
    private Tracer tracer;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        Span span = tracer.currentSpan();
        if (span != null) {
            // Add custom tags
            span.tag("http.url", httpRequest.getRequestURL().toString());
            span.tag("http.method", httpRequest.getMethod());
            span.tag("user.agent", httpRequest.getHeader("User-Agent"));
        }
        
        chain.doFilter(request, response);
    }
}
```

---

## üí° Best Practices

### 1. Use Appropriate Sampling

```yaml
# ‚úÖ Good - Different sampling for different environments
---
spring:
  config:
    activate:
      on-profile: dev
  sleuth:
    sampler:
      probability: 1.0  # 100% in dev

---
spring:
  config:
    activate:
      on-profile: prod
  sleuth:
    sampler:
      probability: 0.1  # 10% in production
```

### 2. Add Meaningful Tags

```java
// ‚úÖ Good - Descriptive tags
span.tag("user.id", userId);
span.tag("order.type", orderType);
span.tag("payment.method", paymentMethod);
span.tag("order.total", total.toString());

// ‚ùå Bad - Generic tags
span.tag("data", "value");
```

### 3. Use Correlation IDs

```java
@RestController
public class OrderController {
    
    @Autowired
    private Tracer tracer;
    
    @PostMapping("/api/orders")
    public Order createOrder(@RequestBody OrderRequest request) {
        Span span = tracer.currentSpan();
        
        // Add correlation ID for logging
        MDC.put("correlationId", span.context().traceIdString());
        
        try {
            return orderService.createOrder(request);
        } finally {
            MDC.remove("correlationId");
        }
    }
}
```

### 4. Monitor Trace Metrics

```yaml
management:
  metrics:
    export:
      prometheus:
        enabled: true
  endpoints:
    web:
      exposure:
        include: prometheus,metrics
```

### 5. Handle Errors Properly

```java
@Service
public class OrderService {
    
    @Autowired
    private Tracer tracer;
    
    public Order createOrder(OrderRequest request) {
        Span span = tracer.nextSpan().name("create-order");
        
        try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {
            // Business logic
            return orderRepository.save(new Order(request));
            
        } catch (Exception e) {
            span.tag("error", e.getMessage());
            span.tag("error.type", e.getClass().getName());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

---

## üé§ Interview Questions

### Q1: What is distributed tracing?
**Answer:** Tracking requests as they flow through multiple microservices to identify performance issues and debug problems.

### Q2: What is a trace?
**Answer:** Complete journey of a request through all microservices, composed of multiple spans.

### Q3: What is a span?
**Answer:** Single operation/unit of work within a trace (e.g., HTTP request, database query).

### Q4: What is trace ID?
**Answer:** Unique identifier linking all spans of a single request across services.

### Q5: What is Spring Cloud Sleuth?
**Answer:** Library that automatically adds distributed tracing to Spring Boot applications.

### Q6: What is Zipkin?
**Answer:** Distributed tracing system for collecting and visualizing trace data.

### Q7: How does trace context propagate?
**Answer:** Through HTTP headers (B3 propagation), message headers (Kafka), automatically by Sleuth.

### Q8: What is baggage?
**Answer:** Key-value pairs propagated with trace context to all downstream services.

### Q9: What is sampling?
**Answer:** Collecting only a percentage of traces to reduce overhead (e.g., 10% in production).

### Q10: How to add custom spans?
**Answer:** Use `Tracer.nextSpan()` to create span, add tags, start/end manually.

### Q11: What is span ID?
**Answer:** Unique identifier for a specific span within a trace.

### Q12: What is parent span ID?
**Answer:** ID of the span that initiated this span, creating parent-child relationship.

### Q13: Sleuth vs Zipkin?
**Answer:** Sleuth generates trace data, Zipkin collects and visualizes it.

### Q14: How to trace async operations?
**Answer:** Sleuth automatically propagates context to async threads (@Async, CompletableFuture).

### Q15: What is B3 propagation?
**Answer:** Standard for propagating trace context via HTTP headers (X-B3-TraceId, X-B3-SpanId).

### Q16: How to exclude endpoints from tracing?
**Answer:** Use custom sampler to skip specific patterns (e.g., /health, /metrics).

### Q17: Performance impact of tracing?
**Answer:** Minimal with sampling. Use lower sampling rate (10-20%) in production.

### Q18: How to correlate logs with traces?
**Answer:** Include trace ID and span ID in log pattern using %X{traceId}, %X{spanId}.

### Q19: Can you trace message queues?
**Answer:** Yes, Sleuth supports Kafka, RabbitMQ, SQS with automatic context propagation.

### Q20: Alternatives to Zipkin?
**Answer:** Jaeger, AWS X-Ray, Google Cloud Trace, Datadog APM, New Relic.

---

## üìö Summary

### Key Concepts

```
1. Trace
   - Complete request journey
   - Unique trace ID
   - Multiple spans

2. Span
   - Single operation
   - Unique span ID
   - Parent span ID
   - Tags and annotations

3. Propagation
   - HTTP headers (B3)
   - Message headers
   - Automatic by Sleuth

4. Sampling
   - Reduce overhead
   - Production: 10-20%
   - Development: 100%
```

### Configuration Template

```yaml
spring:
  application:
    name: service-name
  sleuth:
    sampler:
      probability: 0.1  # 10% sampling
    baggage:
      remote-fields: user-id
      correlation-fields: user-id
  zipkin:
    base-url: http://localhost:9411
```

### Usage Template

```java
// Automatic tracing
@Autowired
private RestTemplate restTemplate;

// Custom span
Span span = tracer.nextSpan().name("operation");
try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {
    span.tag("key", "value");
    // Business logic
} finally {
    span.end();
}
```

**Next:** Config Server ‚Üí

