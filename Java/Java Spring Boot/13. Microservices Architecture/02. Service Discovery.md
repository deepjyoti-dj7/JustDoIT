# ğŸ” Service Discovery - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [What is Service Discovery](#what-is-service-discovery)
- [Netflix Eureka](#netflix-eureka)
- [Service Registration](#service-registration)
- [Service Discovery Client](#service-discovery-client)
- [Load Balancing](#load-balancing)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**Service Discovery** is a mechanism that allows services in a microservices architecture to find and communicate with each other dynamically without hard-coded addresses.

### Why Service Discovery?

```
Problems without Service Discovery:
âŒ Hard-coded service URLs
âŒ Manual configuration updates
âŒ No dynamic scaling
âŒ Complex load balancing
âŒ Service health unknown

Solutions with Service Discovery:
âœ… Dynamic service registration
âœ… Automatic service location
âœ… Health monitoring
âœ… Load balancing
âœ… Failover support
```

---

## ğŸ“š What is Service Discovery

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Service Registry (Eureka Server)          â”‚
â”‚                                                      â”‚
â”‚  Registered Services:                                â”‚
â”‚  - order-service: [192.168.1.10:8081]              â”‚
â”‚  - payment-service: [192.168.1.11:8082]            â”‚
â”‚  - inventory-service: [192.168.1.12:8083]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘ Registration          â†“ Discovery
         â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ Service â”‚            â”‚ Service â”‚
    â”‚    A    â”‚ â†â”€â”€â”€â”€â”€â”€â†’  â”‚    B    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Service Discovery Patterns

```
1. Client-Side Discovery
   - Client queries registry
   - Client chooses instance
   - Client calls service directly
   
   Client â†’ Registry â†’ Get Instances â†’ Choose â†’ Call Service

2. Server-Side Discovery
   - Client calls load balancer
   - LB queries registry
   - LB chooses instance
   
   Client â†’ Load Balancer â†’ Registry â†’ Choose â†’ Call Service
```

### Types of Service Discovery

| Type | Example | Description |
|------|---------|-------------|
| **Client-Side** | Eureka + Ribbon | Client discovers and calls service |
| **Server-Side** | Kubernetes, AWS ELB | Load balancer handles discovery |
| **DNS-Based** | Consul DNS | Uses DNS for service lookup |
| **Configuration** | Spring Cloud Config | Centralized configuration |

---

## ğŸš€ Netflix Eureka

### What is Eureka?

Netflix Eureka is a **service registry** for resilient mid-tier load balancing and failover.

### Components

```
1. Eureka Server
   - Service registry
   - Stores service instances
   - Health checks

2. Eureka Client
   - Registers with server
   - Discovers other services
   - Sends heartbeats
```

### Eureka Server Setup

**Maven Dependencies:**

```xml
<dependencies>
    <!-- Eureka Server -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>2023.0.0</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

**Main Application:**

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

**Configuration (application.yml):**

```yaml
server:
  port: 8761

spring:
  application:
    name: eureka-server

eureka:
  client:
    # Don't register itself as a client
    register-with-eureka: false
    fetch-registry: false
  server:
    # Disable self-preservation in development
    enable-self-preservation: false
    # Eviction interval
    eviction-interval-timer-in-ms: 5000
```

### Eureka Dashboard

```
Access: http://localhost:8761

Dashboard shows:
- Registered instances
- Instance status
- Uptime
- Lease expiration
- Renewals threshold
```

---

## ğŸ“ Service Registration

### Eureka Client Setup

**Maven Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

### Order Service Registration

**Main Application:**

```java
@SpringBootApplication
@EnableDiscoveryClient  // or @EnableEurekaClient
public class OrderServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

**Configuration (application.yml):**

```yaml
server:
  port: 8081

spring:
  application:
    name: order-service  # Service name in registry

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/  # Eureka server URL
    # Fetch registry from server
    fetch-registry: true
    # Register this service
    register-with-eureka: true
  instance:
    # Prefer IP address over hostname
    prefer-ip-address: true
    # Instance ID
    instance-id: ${spring.application.name}:${random.value}
    # Heartbeat interval (default 30s)
    lease-renewal-interval-in-seconds: 30
    # Lease expiration (default 90s)
    lease-expiration-duration-in-seconds: 90
```

### Multiple Instances

```yaml
# Instance 1
server:
  port: 8081
spring:
  application:
    name: order-service

# Instance 2
server:
  port: 8082
spring:
  application:
    name: order-service

# Instance 3
server:
  port: 8083
spring:
  application:
    name: order-service

# All register as "order-service" with different ports
```

---

## ğŸ” Service Discovery Client

### Using DiscoveryClient

```java
@Service
public class OrderService {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    public PaymentResponse processPayment(Order order) {
        // Discover payment service instances
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("payment-service");
        
        if (instances.isEmpty()) {
            throw new ServiceUnavailableException("Payment service not available");
        }
        
        // Get first instance
        ServiceInstance instance = instances.get(0);
        
        // Build URL
        String url = instance.getUri() + "/api/payments";
        
        // Call service
        return restTemplate.postForObject(
            url,
            new PaymentRequest(order),
            PaymentResponse.class
        );
    }
}
```

### Using @LoadBalanced RestTemplate

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // Enable client-side load balancing
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;  // Load-balanced
    
    public PaymentResponse processPayment(Order order) {
        // Use service name instead of URL
        // Ribbon automatically discovers and load balances
        return restTemplate.postForObject(
            "http://payment-service/api/payments",
            new PaymentRequest(order),
            PaymentResponse.class
        );
    }
}
```

### Using OpenFeign

```java
// Feign Client Interface
@FeignClient(name = "payment-service")
public interface PaymentClient {
    
    @PostMapping("/api/payments")
    PaymentResponse processPayment(@RequestBody PaymentRequest request);
    
    @GetMapping("/api/payments/{id}")
    PaymentResponse getPayment(@PathVariable("id") Long id);
}

// Service using Feign
@Service
public class OrderService {
    
    @Autowired
    private PaymentClient paymentClient;  // Injected by Spring
    
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // Simple call - discovery handled automatically
        PaymentResponse payment = paymentClient.processPayment(
            new PaymentRequest(order)
        );
        
        order.setPaymentId(payment.getId());
        return orderRepository.save(order);
    }
}
```

---

## âš–ï¸ Load Balancing

### Client-Side Load Balancing with Ribbon

**Configuration:**

```yaml
payment-service:
  ribbon:
    # Load balancing strategy
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    # Server list refresh interval
    ServerListRefreshInterval: 5000
    # Max auto retries
    MaxAutoRetries: 1
    # Max auto retries next server
    MaxAutoRetriesNextServer: 1
```

**Load Balancing Strategies:**

```java
// 1. Round Robin (Default)
public class RoundRobinExample {
    // Requests: S1 â†’ S2 â†’ S3 â†’ S1 â†’ S2 â†’ S3
}

// 2. Random
@Bean
public IRule randomRule() {
    return new RandomRule();
}

// 3. Weighted Response Time
@Bean
public IRule weightedRule() {
    return new WeightedResponseTimeRule();
    // Faster servers get more requests
}

// 4. Availability Filtering
@Bean
public IRule availabilityRule() {
    return new AvailabilityFilteringRule();
    // Skip failing servers and high concurrent servers
}

// 5. Custom Rule
public class CustomLoadBalancerRule extends AbstractLoadBalancerRule {
    
    @Override
    public Server choose(Object key) {
        List<Server> servers = getLoadBalancer().getAllServers();
        
        // Custom logic - e.g., choose server in same zone
        return servers.stream()
            .filter(server -> server.getZone().equals("us-east-1"))
            .findFirst()
            .orElse(servers.get(0));
    }
}
```

### Spring Cloud LoadBalancer

```java
// Modern alternative to Ribbon

@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public ServiceInstanceListSupplier instanceSupplier(
            ConfigurableApplicationContext context) {
        return ServiceInstanceListSupplier.builder()
            .withDiscoveryClient()
            .withHealthChecks()
            .build(context);
    }
}
```

---

## ğŸš€ Advanced Features

### Health Checks

```java
@RestController
public class HealthController {
    
    @GetMapping("/actuator/health")
    public HealthResponse health() {
        // Custom health check logic
        boolean dbHealthy = checkDatabase();
        boolean cacheHealthy = checkCache();
        
        return new HealthResponse(
            dbHealthy && cacheHealthy ? "UP" : "DOWN"
        );
    }
    
    private boolean checkDatabase() {
        try {
            dataSource.getConnection().isValid(1);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

**Configuration:**

```yaml
eureka:
  instance:
    health-check-url-path: /actuator/health
    status-page-url-path: /actuator/info
    
management:
  endpoints:
    web:
      exposure:
        include: health,info
```

### Service Metadata

```yaml
eureka:
  instance:
    metadata-map:
      zone: us-east-1
      version: 1.0.0
      environment: production
      team: order-team
```

```java
@Service
public class MetadataService {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    public void printServiceMetadata() {
        List<ServiceInstance> instances = 
            discoveryClient.getInstances("payment-service");
        
        for (ServiceInstance instance : instances) {
            Map<String, String> metadata = instance.getMetadata();
            
            System.out.println("Zone: " + metadata.get("zone"));
            System.out.println("Version: " + metadata.get("version"));
        }
    }
}
```

### Eureka Self-Preservation

```
Self-Preservation Mode:
- Eureka stops evicting instances when renewals fall below threshold
- Protects against network partitions
- "EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP"

Configuration:
```

```yaml
eureka:
  server:
    # Enable in production
    enable-self-preservation: true
    # Renewal threshold (default 85%)
    renewal-percent-threshold: 0.85
    
    # Disable in development
    enable-self-preservation: false
```

### High Availability Eureka

```yaml
# Eureka Server 1 (peer1)
server:
  port: 8761

eureka:
  instance:
    hostname: peer1
  client:
    service-url:
      defaultZone: http://peer2:8762/eureka/

---
# Eureka Server 2 (peer2)
server:
  port: 8762

eureka:
  instance:
    hostname: peer2
  client:
    service-url:
      defaultZone: http://peer1:8761/eureka/

# Servers replicate registry with each other
```

### Secure Eureka

```yaml
# Eureka Server with Security
spring:
  security:
    user:
      name: admin
      password: secret

# Eureka Client
eureka:
  client:
    service-url:
      defaultZone: http://admin:secret@localhost:8761/eureka/
```

---

## ğŸ’¡ Best Practices

### 1. Use Service Names, Not URLs

```java
// âœ… Good - Use service name
restTemplate.getForObject(
    "http://payment-service/api/payments/1",
    PaymentResponse.class
);

// âŒ Bad - Hard-coded URL
restTemplate.getForObject(
    "http://192.168.1.10:8082/api/payments/1",
    PaymentResponse.class
);
```

### 2. Configure Proper Timeouts

```yaml
# Connection timeout
ribbon:
  ConnectTimeout: 3000
  ReadTimeout: 10000

# Circuit breaker
resilience4j:
  circuitbreaker:
    instances:
      payment-service:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000
```

### 3. Enable Health Checks

```yaml
eureka:
  instance:
    health-check-url-path: /actuator/health
    
management:
  endpoint:
    health:
      show-details: always
```

### 4. Use Zones for Fault Tolerance

```yaml
eureka:
  instance:
    metadata-map:
      zone: us-east-1a
  client:
    prefer-same-zone-eureka: true
```

### 5. Monitor Eureka Dashboard

```
Regular Checks:
âœ… Number of registered instances
âœ… Renewal threshold
âœ… Self-preservation status
âœ… Last 1000 cancelled leases
âœ… Last 1000 registered leases
```

---

## ğŸ¤ Interview Questions

### Q1: What is service discovery?
**Answer:** Mechanism allowing services to find and communicate with each other dynamically without hard-coded addresses.

### Q2: What is Netflix Eureka?
**Answer:** Service registry for mid-tier load balancing and failover in microservices architecture.

### Q3: Components of Eureka?
**Answer:** Eureka Server (registry) and Eureka Client (registers and discovers services).

### Q4: How does service registration work?
**Answer:** Service starts, registers with Eureka Server, sends heartbeats every 30s to maintain lease.

### Q5: What is @EnableEurekaServer?
**Answer:** Annotation to make Spring Boot application act as Eureka Server.

### Q6: What is @EnableDiscoveryClient?
**Answer:** Annotation to make application a Eureka Client for service registration and discovery.

### Q7: Client-side vs server-side discovery?
**Answer:** Client-side: client queries registry and chooses instance. Server-side: load balancer handles discovery.

### Q8: What is @LoadBalanced?
**Answer:** Annotation enabling client-side load balancing for RestTemplate.

### Q9: How to discover service instances?
**Answer:** Use `DiscoveryClient.getInstances("service-name")` or `@LoadBalanced RestTemplate` or Feign.

### Q10: What is Ribbon?
**Answer:** Client-side load balancer that works with Eureka for service discovery and load balancing.

### Q11: Load balancing strategies in Ribbon?
**Answer:** Round Robin, Random, Weighted Response Time, Availability Filtering, Zone Avoidance.

### Q12: What is Eureka self-preservation?
**Answer:** Mode where Eureka stops evicting instances when renewals fall below threshold to protect against network issues.

### Q13: How often do services send heartbeats?
**Answer:** Every 30 seconds by default (`lease-renewal-interval-in-seconds`).

### Q14: What happens if service stops sending heartbeats?
**Answer:** Eureka waits 90 seconds (lease expiration), then evicts the instance.

### Q15: How to configure multiple Eureka instances?
**Answer:** Set different ports, configure them as peers in `defaultZone`, they replicate registry.

### Q16: What is prefer-ip-address?
**Answer:** Configuration to use IP address instead of hostname for service registration.

### Q17: How to add metadata to service instance?
**Answer:** Use `eureka.instance.metadata-map` in application.yml.

### Q18: What is OpenFeign?
**Answer:** Declarative HTTP client that integrates with Eureka for service discovery.

### Q19: How to secure Eureka Server?
**Answer:** Add Spring Security dependency, configure username/password, clients use credentials in URL.

### Q20: Alternatives to Eureka?
**Answer:** Consul, Zookeeper, Kubernetes Service Discovery, AWS Cloud Map, etcd.

---

## ğŸ“š Summary

### Key Concepts

```
1. Service Registry
   - Central registry (Eureka Server)
   - Stores service instances
   - Health monitoring

2. Service Registration
   - Services register on startup
   - Send heartbeats (30s)
   - Evicted if no heartbeat (90s)

3. Service Discovery
   - DiscoveryClient
   - @LoadBalanced RestTemplate
   - OpenFeign

4. Load Balancing
   - Client-side (Ribbon)
   - Multiple strategies
   - Automatic failover
```

### Configuration Template

```yaml
# Eureka Server
server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  client:
    register-with-eureka: false
    fetch-registry: false

# Eureka Client
server:
  port: 8081
spring:
  application:
    name: order-service
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true
    lease-renewal-interval-in-seconds: 30
    lease-expiration-duration-in-seconds: 90
```

### Best Practices

```
âœ… Use service names, not URLs
âœ… Configure proper timeouts
âœ… Enable health checks
âœ… Use zones for fault tolerance
âœ… Monitor Eureka dashboard
âœ… Disable self-preservation in dev
âœ… Enable self-preservation in prod
âœ… Use multiple Eureka instances in prod
```

**Next:** API Gateway â†’

