# ðŸ”— Inter-service Communication - Complete Guide

## ðŸ“‹ Table of Contents
- [Introduction](#introduction)
- [Communication Patterns](#communication-patterns)
- [Synchronous Communication](#synchronous-communication)
- [Asynchronous Communication](#asynchronous-communication)
- [Message Brokers](#message-brokers)
- [Communication Strategies](#communication-strategies)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ðŸŽ¯ Introduction

**Inter-service Communication** defines how microservices interact with each other to accomplish business operations.

### Communication Types

```
Synchronous (Request-Response):
â”œâ”€ REST (HTTP)
â”œâ”€ gRPC
â””â”€ GraphQL

Asynchronous (Event-Driven):
â”œâ”€ Message Queues (RabbitMQ)
â”œâ”€ Event Streams (Kafka)
â””â”€ Pub-Sub (Redis, SNS)
```

---

## ðŸ“Š Communication Patterns

### 1. Request-Response (Synchronous)

```
Order Service â†’ [HTTP POST] â†’ Payment Service
      â†“                             â†“
   Waiting...              Process Payment
      â†“                             â†“
   Response â† [HTTP 200] â† Payment Result
```

**Use When:**
- Need immediate response
- Strong consistency required
- Simple workflows

### 2. Event-Driven (Asynchronous)

```
Order Service â†’ [Publish Event] â†’ Message Broker
      â†“                                 â†“
   Continue                      [Subscribe]
                                       â†“
                              Payment Service
                              Inventory Service
                              Notification Service
```

**Use When:**
- Fire and forget operations
- Multiple consumers
- Eventual consistency acceptable
- Decoupling services

### 3. Choreography

```
Order Created â†’ Order Service
                    â†“ (Publish OrderCreated event)
               Message Broker
                    â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“           â†“           â†“
   Payment     Inventory    Notification
   Service     Service      Service
   (React)     (React)      (React)
```

### 4. Orchestration

```
Order Service (Orchestrator)
    â”œâ†’ Call Payment Service
    â”œâ†’ Call Inventory Service
    â”œâ†’ Call Shipping Service
    â””â†’ Call Notification Service
```

---

## ðŸŒ Synchronous Communication

### REST with RestTemplate

**Configuration:**

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // Client-side load balancing
    public RestTemplate restTemplate() {
        return new RestTemplateBuilder()
            .setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(30))
            .errorHandler(new CustomErrorHandler())
            .build();
    }
}

@Component
public class CustomErrorHandler extends DefaultResponseErrorHandler {
    
    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        HttpStatus status = response.getStatusCode();
        
        if (status.is5xxServerError()) {
            throw new ServiceUnavailableException("Service unavailable");
        }
        
        super.handleError(response);
    }
}
```

**Usage:**

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order createOrder(OrderRequest request) {
        // POST request
        PaymentRequest paymentRequest = new PaymentRequest(request.getTotal());
        PaymentResponse payment = restTemplate.postForObject(
            "http://payment-service/api/payments",
            paymentRequest,
            PaymentResponse.class
        );
        
        // GET request
        InventoryResponse inventory = restTemplate.getForObject(
            "http://inventory-service/api/inventory/{productId}",
            InventoryResponse.class,
            request.getProductId()
        );
        
        return new Order(request, payment, inventory);
    }
}
```

### REST with WebClient (Reactive)

**Configuration:**

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder()
            .baseUrl("http://payment-service")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .filter(ExchangeFilterFunction.ofRequestProcessor(
                request -> {
                    log.info("Request: {} {}", request.method(), request.url());
                    return Mono.just(request);
                }
            ));
    }
}
```

**Usage:**

```java
@Service
public class OrderService {
    
    @Autowired
    private WebClient.Builder webClientBuilder;
    
    public Mono<Order> createOrder(OrderRequest request) {
        WebClient webClient = webClientBuilder.build();
        
        return webClient.post()
            .uri("/api/payments")
            .bodyValue(new PaymentRequest(request.getTotal()))
            .retrieve()
            .onStatus(
                HttpStatus::is5xxServerError,
                response -> Mono.error(new ServiceException("Payment service error"))
            )
            .bodyToMono(PaymentResponse.class)
            .flatMap(payment -> processOrder(request, payment));
    }
    
    private Mono<Order> processOrder(OrderRequest request, PaymentResponse payment) {
        return Mono.just(new Order(request, payment));
    }
}
```

### OpenFeign

**Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

**Configuration:**

```java
@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

**Client Interface:**

```java
@FeignClient(
    name = "payment-service",
    fallback = PaymentClientFallback.class,
    configuration = FeignConfig.class
)
public interface PaymentClient {
    
    @PostMapping("/api/payments")
    PaymentResponse processPayment(@RequestBody PaymentRequest request);
    
    @GetMapping("/api/payments/{paymentId}")
    PaymentResponse getPayment(@PathVariable String paymentId);
}

@Component
public class PaymentClientFallback implements PaymentClient {
    
    @Override
    public PaymentResponse processPayment(PaymentRequest request) {
        log.error("Payment service unavailable, using fallback");
        return PaymentResponse.failed("Service unavailable");
    }
    
    @Override
    public PaymentResponse getPayment(String paymentId) {
        return PaymentResponse.failed("Service unavailable");
    }
}

@Configuration
public class FeignConfig {
    
    @Bean
    public RequestInterceptor requestInterceptor() {
        return template -> {
            template.header("X-Request-ID", UUID.randomUUID().toString());
        };
    }
    
    @Bean
    public Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
```

**Usage:**

```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentClient paymentClient;
    
    public Order createOrder(OrderRequest request) {
        PaymentResponse payment = paymentClient.processPayment(
            new PaymentRequest(request.getTotal())
        );
        
        return new Order(request, payment);
    }
}
```

### gRPC

**Proto Definition:**

```protobuf
syntax = "proto3";

package payment;

service PaymentService {
  rpc ProcessPayment (PaymentRequest) returns (PaymentResponse);
  rpc GetPayment (GetPaymentRequest) returns (PaymentResponse);
}

message PaymentRequest {
  string order_id = 1;
  double amount = 2;
  string currency = 3;
  string payment_method = 4;
}

message PaymentResponse {
  string payment_id = 1;
  string status = 2;
  string transaction_id = 3;
}

message GetPaymentRequest {
  string payment_id = 1;
}
```

**Server Implementation:**

```java
@GrpcService
public class PaymentGrpcService extends PaymentServiceGrpc.PaymentServiceImplBase {
    
    @Autowired
    private PaymentService paymentService;
    
    @Override
    public void processPayment(PaymentRequest request, 
                              StreamObserver<PaymentResponse> responseObserver) {
        try {
            Payment payment = paymentService.process(
                request.getOrderId(),
                request.getAmount(),
                request.getPaymentMethod()
            );
            
            PaymentResponse response = PaymentResponse.newBuilder()
                .setPaymentId(payment.getId())
                .setStatus(payment.getStatus())
                .setTransactionId(payment.getTransactionId())
                .build();
            
            responseObserver.onNext(response);
            responseObserver.onCompleted();
            
        } catch (Exception e) {
            responseObserver.onError(
                Status.INTERNAL
                    .withDescription(e.getMessage())
                    .asRuntimeException()
            );
        }
    }
}
```

**Client:**

```java
@Component
public class PaymentGrpcClient {
    
    @GrpcClient("payment-service")
    private PaymentServiceBlockingStub paymentStub;
    
    public PaymentResponse processPayment(String orderId, double amount) {
        PaymentRequest request = PaymentRequest.newBuilder()
            .setOrderId(orderId)
            .setAmount(amount)
            .setCurrency("USD")
            .setPaymentMethod("CREDIT_CARD")
            .build();
        
        return paymentStub.processPayment(request);
    }
}
```

---

## ðŸ“¨ Asynchronous Communication

### Apache Kafka

**Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
```

**Configuration:**

```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      acks: all
      retries: 3
    
    consumer:
      group-id: order-consumer-group
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: com.example.events
      auto-offset-reset: earliest
```

**Producer:**

```java
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderEvent event = OrderEvent.builder()
            .orderId(order.getId())
            .customerId(order.getCustomerId())
            .total(order.getTotal())
            .status("CREATED")
            .timestamp(Instant.now())
            .build();
        
        kafkaTemplate.send("order-events", order.getId(), event)
            .addCallback(
                result -> log.info("Event published: {}", event),
                ex -> log.error("Failed to publish event", ex)
            );
    }
}
```

**Consumer:**

```java
@Service
public class PaymentEventConsumer {
    
    @Autowired
    private PaymentService paymentService;
    
    @KafkaListener(topics = "order-events", groupId = "payment-service")
    public void handleOrderCreated(OrderEvent event) {
        log.info("Received order event: {}", event);
        
        if ("CREATED".equals(event.getStatus())) {
            paymentService.initiatePayment(
                event.getOrderId(),
                event.getTotal()
            );
        }
    }
    
    @KafkaListener(topics = "payment-events", groupId = "order-service")
    public void handlePaymentCompleted(PaymentEvent event) {
        if ("COMPLETED".equals(event.getStatus())) {
            orderService.completeOrder(event.getOrderId());
        }
    }
}
```

### RabbitMQ

**Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

**Configuration:**

```java
@Configuration
public class RabbitMQConfig {
    
    public static final String ORDER_EXCHANGE = "order.exchange";
    public static final String PAYMENT_QUEUE = "payment.queue";
    public static final String INVENTORY_QUEUE = "inventory.queue";
    public static final String ORDER_ROUTING_KEY = "order.created";
    
    @Bean
    public TopicExchange orderExchange() {
        return new TopicExchange(ORDER_EXCHANGE);
    }
    
    @Bean
    public Queue paymentQueue() {
        return QueueBuilder.durable(PAYMENT_QUEUE)
            .withArgument("x-dead-letter-exchange", "dlx.exchange")
            .build();
    }
    
    @Bean
    public Queue inventoryQueue() {
        return QueueBuilder.durable(INVENTORY_QUEUE).build();
    }
    
    @Bean
    public Binding paymentBinding() {
        return BindingBuilder
            .bind(paymentQueue())
            .to(orderExchange())
            .with(ORDER_ROUTING_KEY);
    }
    
    @Bean
    public Binding inventoryBinding() {
        return BindingBuilder
            .bind(inventoryQueue())
            .to(orderExchange())
            .with(ORDER_ROUTING_KEY);
    }
    
    @Bean
    public Jackson2JsonMessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}
```

**Publisher:**

```java
@Service
public class OrderEventPublisher {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(order);
        
        rabbitTemplate.convertAndSend(
            RabbitMQConfig.ORDER_EXCHANGE,
            RabbitMQConfig.ORDER_ROUTING_KEY,
            event
        );
        
        log.info("Published order event: {}", event);
    }
}
```

**Consumer:**

```java
@Service
public class PaymentEventListener {
    
    @Autowired
    private PaymentService paymentService;
    
    @RabbitListener(queues = RabbitMQConfig.PAYMENT_QUEUE)
    public void handleOrderEvent(OrderEvent event) {
        log.info("Received order event: {}", event);
        
        try {
            paymentService.processPayment(event);
        } catch (Exception e) {
            log.error("Payment processing failed", e);
            throw new AmqpRejectAndDontRequeueException("Payment failed", e);
        }
    }
}
```

---

## ðŸ”„ Communication Strategies

### Saga Pattern (Choreography)

```java
// Order Service
@Service
public class OrderService {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // Publish event
        kafkaTemplate.send("order-events", 
            OrderEvent.created(order));
        
        return order;
    }
    
    @KafkaListener(topics = "payment-events")
    public void handlePaymentCompleted(PaymentEvent event) {
        Order order = orderRepository.findById(event.getOrderId())
            .orElseThrow();
        
        order.setStatus(OrderStatus.PAID);
        orderRepository.save(order);
        
        // Publish next event
        kafkaTemplate.send("order-events", 
            OrderEvent.paid(order));
    }
    
    @KafkaListener(topics = "inventory-events")
    public void handleInventoryReserved(InventoryEvent event) {
        Order order = orderRepository.findById(event.getOrderId())
            .orElseThrow();
        
        order.setStatus(OrderStatus.CONFIRMED);
        orderRepository.save(order);
    }
}

// Payment Service
@Service
public class PaymentService {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderCreated(OrderEvent event) {
        if (event.getType() == EventType.ORDER_CREATED) {
            Payment payment = processPayment(event);
            
            kafkaTemplate.send("payment-events",
                PaymentEvent.completed(payment));
        }
    }
}

// Inventory Service
@Service
public class InventoryService {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderPaid(OrderEvent event) {
        if (event.getType() == EventType.ORDER_PAID) {
            reserveInventory(event);
            
            kafkaTemplate.send("inventory-events",
                InventoryEvent.reserved(event.getOrderId()));
        }
    }
}
```

### Saga Pattern (Orchestration)

```java
@Service
public class OrderOrchestrator {
    
    @Autowired
    private PaymentClient paymentClient;
    
    @Autowired
    private InventoryClient inventoryClient;
    
    @Autowired
    private ShippingClient shippingClient;
    
    public Order processOrder(OrderRequest request) {
        Order order = createOrder(request);
        
        try {
            // Step 1: Payment
            PaymentResponse payment = paymentClient.charge(
                order.getId(), order.getTotal());
            
            if (!payment.isSuccess()) {
                throw new PaymentFailedException();
            }
            
            // Step 2: Inventory
            InventoryResponse inventory = inventoryClient.reserve(
                order.getProductId(), order.getQuantity());
            
            if (!inventory.isSuccess()) {
                // Compensate: Refund payment
                paymentClient.refund(payment.getPaymentId());
                throw new InventoryUnavailableException();
            }
            
            // Step 3: Shipping
            ShippingResponse shipping = shippingClient.createShipment(order);
            
            if (!shipping.isSuccess()) {
                // Compensate: Release inventory and refund
                inventoryClient.release(inventory.getReservationId());
                paymentClient.refund(payment.getPaymentId());
                throw new ShippingFailedException();
            }
            
            order.setStatus(OrderStatus.CONFIRMED);
            return orderRepository.save(order);
            
        } catch (Exception e) {
            order.setStatus(OrderStatus.FAILED);
            orderRepository.save(order);
            throw e;
        }
    }
}
```

### Request-Reply Pattern

```java
// Sender
@Service
public class OrderService {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public PaymentResponse requestPayment(PaymentRequest request) {
        // Send request and wait for reply
        PaymentResponse response = (PaymentResponse) rabbitTemplate
            .convertSendAndReceive(
                "payment.request.queue",
                request
            );
        
        return response;
    }
}

// Receiver
@Service
public class PaymentService {
    
    @RabbitListener(queues = "payment.request.queue")
    public PaymentResponse handlePaymentRequest(PaymentRequest request) {
        // Process payment
        Payment payment = processPayment(request);
        
        // Return response (automatically sent to reply queue)
        return new PaymentResponse(payment);
    }
}
```

---

## ðŸ’¡ Best Practices

### 1. Choose Appropriate Pattern

```java
// âœ… Synchronous for immediate needs
PaymentResponse payment = paymentClient.charge(order);
if (payment.isSuccess()) {
    order.setStatus(PAID);
}

// âœ… Asynchronous for fire-and-forget
kafkaTemplate.send("notifications", 
    new OrderConfirmationEvent(order));
```

### 2. Implement Timeouts

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        HttpClient httpClient = HttpClient.create()
            .responseTimeout(Duration.ofSeconds(30))
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);
        
        return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
    }
}
```

### 3. Use Circuit Breakers

```java
@Service
public class OrderService {
    
    @CircuitBreaker(name = "payment-service", fallbackMethod = "paymentFallback")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
    
    private PaymentResponse paymentFallback(PaymentRequest request, Exception ex) {
        log.error("Payment service unavailable", ex);
        return PaymentResponse.failed("Service temporarily unavailable");
    }
}
```

### 4. Idempotency

```java
@Service
public class PaymentService {
    
    @Autowired
    private PaymentRepository paymentRepository;
    
    public Payment processPayment(String idempotencyKey, PaymentRequest request) {
        // Check if already processed
        Optional<Payment> existing = paymentRepository
            .findByIdempotencyKey(idempotencyKey);
        
        if (existing.isPresent()) {
            return existing.get();  // Return cached result
        }
        
        // Process payment
        Payment payment = chargeCard(request);
        payment.setIdempotencyKey(idempotencyKey);
        
        return paymentRepository.save(payment);
    }
}
```

### 5. Dead Letter Queues

```java
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public Queue mainQueue() {
        return QueueBuilder.durable("payment.queue")
            .withArgument("x-dead-letter-exchange", "dlx.exchange")
            .withArgument("x-dead-letter-routing-key", "payment.dlq")
            .build();
    }
    
    @Bean
    public Queue deadLetterQueue() {
        return QueueBuilder.durable("payment.dlq").build();
    }
}

@Service
public class DeadLetterHandler {
    
    @RabbitListener(queues = "payment.dlq")
    public void handleFailedMessage(Message message) {
        log.error("Message failed after retries: {}", message);
        // Alert, manual intervention, or alternative processing
    }
}
```

---

## ðŸŽ¤ Interview Questions

### Q1: Synchronous vs Asynchronous communication?
**Answer:** Synchronous waits for response (REST, gRPC), Asynchronous doesn't wait (Kafka, RabbitMQ).

### Q2: When to use REST?
**Answer:** Simple request-response, immediate response needed, strong consistency required.

### Q3: When to use Kafka?
**Answer:** Event streaming, multiple consumers, audit logs, eventual consistency acceptable.

### Q4: What is OpenFeign?
**Answer:** Declarative REST client simplifying HTTP calls with annotation-based interface.

### Q5: REST vs gRPC?
**Answer:** REST uses JSON/HTTP (human-readable), gRPC uses Protocol Buffers/HTTP2 (faster, binary).

### Q6: What is Saga pattern?
**Answer:** Managing distributed transactions across services using compensating transactions.

### Q7: Choreography vs Orchestration?
**Answer:** Choreography: Services react to events independently. Orchestration: Central coordinator controls flow.

### Q8: What is idempotency?
**Answer:** Multiple identical requests produce same result without side effects.

### Q9: How to handle failures in async communication?
**Answer:** Dead letter queues, retry mechanisms, circuit breakers, compensating transactions.

### Q10: Kafka vs RabbitMQ?
**Answer:** Kafka: High throughput, event streaming, log retention. RabbitMQ: Complex routing, traditional messaging.

### Q11: What is request-reply pattern?
**Answer:** Asynchronous request with correlation ID, reply sent to specific queue.

### Q12: How to ensure message delivery?
**Answer:** Acknowledgments, retries, dead letter queues, idempotency, transactional outbox.

### Q13: What is transactional outbox?
**Answer:** Saving events in database with business data, separate process publishes to message broker.

### Q14: How to handle duplicate messages?
**Answer:** Idempotency keys, deduplication tracking, unique message IDs.

### Q15: What is eventual consistency?
**Answer:** System eventually reaches consistent state after async operations complete.

### Q16: How to trace async requests?
**Answer:** Correlation IDs, distributed tracing (Sleuth), message headers propagation.

### Q17: What is circuit breaker in communication?
**Answer:** Stops calling failing service, returns fallback, prevents cascade failures.

### Q18: How to version APIs?
**Answer:** URL versioning (/v1/), header versioning, content negotiation, backward compatibility.

### Q19: What is backpressure?
**Answer:** Consumer signals producer to slow down when overwhelmed (reactive streams).

### Q20: Best practices for inter-service communication?
**Answer:** Timeouts, retries, circuit breakers, idempotency, correlation IDs, monitoring, fallbacks.

---

## ðŸ“š Summary

### Communication Comparison

| Feature | REST | gRPC | Kafka | RabbitMQ |
|---------|------|------|-------|----------|
| **Type** | Sync | Sync | Async | Async |
| **Protocol** | HTTP | HTTP/2 | TCP | AMQP |
| **Format** | JSON/XML | Protobuf | Binary | Binary |
| **Speed** | Moderate | Fast | Fast | Fast |
| **Use Case** | CRUD | Microservices | Event streaming | Task queues |
| **Learning Curve** | Easy | Moderate | Moderate | Easy |

### Pattern Selection

```
Use Synchronous When:
âœ… Need immediate response
âœ… Strong consistency required
âœ… Simple request-response
âœ… User-facing operations

Use Asynchronous When:
âœ… Fire and forget
âœ… Multiple consumers
âœ… Eventual consistency OK
âœ… Background processing
âœ… High throughput needed
```

### Configuration Templates

**Feign Client:**

```java
@FeignClient(name = "service-name", fallback = Fallback.class)
public interface ServiceClient {
    @GetMapping("/api/resource")
    Response getResource();
}
```

**Kafka Producer:**

```java
kafkaTemplate.send("topic", key, event)
    .addCallback(success, failure);
```

**Kafka Consumer:**

```java
@KafkaListener(topics = "topic", groupId = "group")
public void handle(Event event) { }
```

**Next:** Complete Microservices Architecture Module â†’

