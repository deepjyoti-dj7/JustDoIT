# ‚öôÔ∏è Config Server - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Spring Cloud Config Server](#spring-cloud-config-server)
- [Git Backend](#git-backend)
- [Config Clients](#config-clients)
- [Refresh Configuration](#refresh-configuration)
- [Encryption](#encryption)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Config Server** provides centralized external configuration management for distributed systems, eliminating hardcoded configuration in each service.

### Why Config Server?

```
Problems without Config Server:
‚ùå Configuration scattered across services
‚ùå Restart required for config changes
‚ùå No version control for configuration
‚ùå Environment-specific configs duplicated
‚ùå Secrets hardcoded in code

Solutions with Config Server:
‚úÖ Centralized configuration
‚úÖ Dynamic refresh without restart
‚úÖ Version controlled (Git)
‚úÖ Environment-specific profiles
‚úÖ Encrypted secrets
‚úÖ Configuration audit trail
```

---

## üìö Spring Cloud Config Server

### Architecture

```
                   Git Repository
                   (Configuration Files)
                          ‚Üë
                          |
                    Config Server
                   (Port: 8888)
                          ‚Üë
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                |         |         |
           Service-1  Service-2  Service-3
           (Client)   (Client)   (Client)
```

### Maven Dependencies (Config Server)

```xml
<dependencies>
    <!-- Config Server -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
    </dependency>
    
    <!-- Actuator for refresh endpoint -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### Config Server Application

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
```

### Config Server Configuration

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
  
  cloud:
    config:
      server:
        git:
          uri: https://github.com/your-org/config-repo
          # Clone on startup
          clone-on-start: true
          # Search paths
          search-paths: '{application}'
          # Default label (branch)
          default-label: main
          # Authentication
          username: ${GIT_USERNAME}
          password: ${GIT_PASSWORD}
          # Timeout
          timeout: 4

# Actuator endpoints
management:
  endpoints:
    web:
      exposure:
        include: health,info,refresh
```

---

## üìÇ Git Backend

### Repository Structure

```
config-repo/
‚îú‚îÄ‚îÄ application.yml              # Default for all services
‚îú‚îÄ‚îÄ application-dev.yml          # Dev profile for all services
‚îú‚îÄ‚îÄ application-prod.yml         # Prod profile for all services
‚îÇ
‚îú‚îÄ‚îÄ order-service.yml            # Order service default
‚îú‚îÄ‚îÄ order-service-dev.yml        # Order service dev
‚îú‚îÄ‚îÄ order-service-prod.yml       # Order service prod
‚îÇ
‚îú‚îÄ‚îÄ payment-service.yml          # Payment service default
‚îú‚îÄ‚îÄ payment-service-dev.yml      # Payment service dev
‚îî‚îÄ‚îÄ payment-service-prod.yml     # Payment service prod
```

### Configuration Files

**application.yml (Global defaults):**

```yaml
# Common configuration for all services
logging:
  level:
    root: INFO
    org.springframework: INFO

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus

spring:
  jpa:
    show-sql: false
    hibernate:
      ddl-auto: validate
```

**application-dev.yml (Dev profile):**

```yaml
logging:
  level:
    root: DEBUG
    org.springframework: DEBUG

spring:
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
```

**order-service.yml (Service-specific):**

```yaml
server:
  port: 8081

spring:
  datasource:
    driver-class-name: org.postgresql.Driver
  
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

order:
  max-items: 100
  timeout: 30000
```

**order-service-dev.yml (Service + Profile):**

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/order_db_dev
    username: dev_user
    password: '{cipher}AQA...'  # Encrypted

logging:
  level:
    com.example.order: DEBUG
```

**order-service-prod.yml (Production):**

```yaml
spring:
  datasource:
    url: jdbc:postgresql://prod-db.example.com:5432/order_db
    username: prod_user
    password: '{cipher}AQB...'  # Encrypted
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5

logging:
  level:
    com.example.order: WARN
```

---

## üîå Config Clients

### Maven Dependencies (Client)

```xml
<dependencies>
    <!-- Config Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    
    <!-- Bootstrap for early config loading -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-bootstrap</artifactId>
    </dependency>
    
    <!-- Actuator for refresh -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### Client Configuration (bootstrap.yml)

```yaml
spring:
  application:
    name: order-service  # Matches order-service.yml in Git
  
  cloud:
    config:
      uri: http://localhost:8888  # Config Server URL
      fail-fast: true  # Fail if config server unavailable
      retry:
        initial-interval: 1000
        max-attempts: 6
        max-interval: 2000
        multiplier: 1.1
  
  profiles:
    active: dev  # Loads order-service-dev.yml
```

### Alternative: application.yml (Spring Boot 2.4+)

```yaml
spring:
  application:
    name: order-service
  
  config:
    import: optional:configserver:http://localhost:8888
  
  profiles:
    active: dev
```

### Using Configuration

```java
@RestController
@RefreshScope  // Enables dynamic refresh
public class OrderController {
    
    @Value("${order.max-items}")
    private int maxItems;
    
    @Value("${order.timeout}")
    private long timeout;
    
    @GetMapping("/api/orders/config")
    public Map<String, Object> getConfig() {
        return Map.of(
            "maxItems", maxItems,
            "timeout", timeout
        );
    }
}
```

### Configuration Properties

```java
@Component
@ConfigurationProperties(prefix = "order")
@RefreshScope  // For dynamic refresh
@Data
public class OrderProperties {
    
    private int maxItems;
    private long timeout;
    private boolean enableCache;
    private List<String> allowedPaymentMethods;
}

@RestController
public class OrderController {
    
    @Autowired
    private OrderProperties orderProperties;
    
    @PostMapping("/api/orders")
    public Order createOrder(@RequestBody OrderRequest request) {
        if (request.getItems().size() > orderProperties.getMaxItems()) {
            throw new IllegalArgumentException("Too many items");
        }
        
        return orderService.createOrder(request);
    }
}
```

---

## üîÑ Refresh Configuration

### Manual Refresh

**Update configuration in Git, then:**

```bash
# Refresh specific service
curl -X POST http://localhost:8081/actuator/refresh
```

**Enable refresh endpoint:**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info
```

### Automatic Refresh with Spring Cloud Bus

**Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```

**Configuration:**

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
  
  cloud:
    bus:
      enabled: true
      refresh:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: busrefresh
```

**Refresh all services:**

```bash
# Single request refreshes ALL services
curl -X POST http://localhost:8888/actuator/busrefresh
```

### Webhook Integration (GitHub)

```java
@RestController
@RequestMapping("/webhook")
public class GitWebhookController {
    
    @Autowired
    private RefreshEndpoint refreshEndpoint;
    
    @PostMapping("/refresh")
    public ResponseEntity<?> handleGitWebhook(@RequestBody Map<String, Object> payload) {
        // Validate webhook signature
        String ref = (String) payload.get("ref");
        
        if ("refs/heads/main".equals(ref)) {
            // Trigger refresh
            Collection<String> keys = refreshEndpoint.refresh();
            return ResponseEntity.ok(Map.of("refreshed", keys));
        }
        
        return ResponseEntity.ok("No refresh needed");
    }
}
```

**GitHub Webhook:**
```
URL: http://your-config-server/webhook/refresh
Content type: application/json
Events: Push
```

---

## üîê Encryption

### Symmetric Encryption

**Config Server Configuration:**

```yaml
encrypt:
  key: mySecretKey123  # Symmetric key
```

**Encrypt a value:**

```bash
# Encrypt
curl http://localhost:8888/encrypt -d "myPassword123"
# Output: AQA1e2...encrypted-value...

# Decrypt
curl http://localhost:8888/decrypt -d "AQA1e2...encrypted-value..."
# Output: myPassword123
```

**Use encrypted value in Git:**

```yaml
spring:
  datasource:
    password: '{cipher}AQA1e2...encrypted-value...'
```

### Asymmetric Encryption (RSA)

**Generate key pair:**

```bash
keytool -genkeypair -alias config-server -keyalg RSA \
  -keystore config-server.jks -keysize 2048 -storepass changeit
```

**Config Server Configuration:**

```yaml
encrypt:
  key-store:
    location: classpath:/config-server.jks
    password: changeit
    alias: config-server
    secret: changeit
```

### Environment Variables

**Instead of encrypting, use environment variables:**

```yaml
# In Git repository
spring:
  datasource:
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
```

**Set on service startup:**

```bash
export DB_USERNAME=admin
export DB_PASSWORD=secret
java -jar order-service.jar
```

---

## üöÄ Advanced Features

### Multiple Repositories

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/default-config
          repos:
            order:
              pattern: order-service*
              uri: https://github.com/org/order-config
            
            payment:
              pattern: payment-service*
              uri: https://github.com/org/payment-config
```

### Vault Backend

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-vault-config</artifactId>
</dependency>
```

```yaml
spring:
  cloud:
    config:
      server:
        vault:
          host: localhost
          port: 8200
          authentication: TOKEN
          token: ${VAULT_TOKEN}
          kv-version: 2
```

### Composite Configuration

```yaml
spring:
  cloud:
    config:
      server:
        composite:
          - type: git
            uri: https://github.com/org/common-config
          - type: vault
            host: localhost
            port: 8200
          - type: native
            search-locations: file:/config
```

### Native File System

```yaml
spring:
  profiles:
    active: native  # Use local filesystem
  cloud:
    config:
      server:
        native:
          search-locations: file:/config,classpath:/config
```

### Fail Fast & Retry

```yaml
spring:
  cloud:
    config:
      fail-fast: true  # Fail if config server unavailable
      retry:
        initial-interval: 1000  # First retry after 1s
        max-attempts: 6         # Try 6 times
        max-interval: 2000      # Max 2s between retries
        multiplier: 1.1         # Exponential backoff
```

---

## üí° Best Practices

### 1. Use Profiles

```yaml
# ‚úÖ Good - Separate profiles
application-dev.yml
application-test.yml
application-prod.yml

# ‚ùå Bad - One file with conditionals
application.yml (with if/else logic)
```

### 2. Encrypt Sensitive Data

```yaml
# ‚úÖ Good - Encrypted passwords
spring:
  datasource:
    password: '{cipher}AQA...'

# ‚ùå Bad - Plain text passwords
spring:
  datasource:
    password: admin123
```

### 3. Version Configuration

```bash
# ‚úÖ Good - Use Git tags
git tag -a v1.0.0 -m "Release 1.0.0"
git push origin v1.0.0

# Reference in client
spring:
  cloud:
    config:
      label: v1.0.0
```

### 4. Fail Fast in Production

```yaml
# ‚úÖ Good - Fail if config unavailable
spring:
  cloud:
    config:
      fail-fast: true

# ‚ùå Bad - Continue with defaults
spring:
  cloud:
    config:
      fail-fast: false
```

### 5. Monitor Configuration Changes

```java
@Component
public class ConfigChangeListener {
    
    @EventListener
    public void handleRefresh(RefreshScopeRefreshedEvent event) {
        log.info("Configuration refreshed: {}", event.getName());
        // Send alert or metrics
    }
}
```

### 6. Separate Common Configuration

```
config-repo/
‚îú‚îÄ‚îÄ application.yml          # Common to all services
‚îú‚îÄ‚îÄ database-common.yml      # Database defaults
‚îú‚îÄ‚îÄ logging-common.yml       # Logging defaults
‚îî‚îÄ‚îÄ order-service.yml        # Service-specific
```

---

## üé§ Interview Questions

### Q1: What is Config Server?
**Answer:** Centralized configuration management system for distributed applications, backed by Git.

### Q2: Why use Config Server?
**Answer:** Centralized config, version control, dynamic refresh, environment-specific configs, encrypted secrets.

### Q3: How does Config Server work?
**Answer:** Stores config in Git, exposes REST API, clients fetch config on startup, can refresh dynamically.

### Q4: What is @RefreshScope?
**Answer:** Annotation enabling beans to be refreshed when configuration changes via /actuator/refresh.

### Q5: What is bootstrap.yml?
**Answer:** Configuration file loaded before application.yml to configure Config Server connection.

### Q6: How to refresh configuration?
**Answer:** POST to /actuator/refresh endpoint or use Spring Cloud Bus for broadcast refresh.

### Q7: What is Spring Cloud Bus?
**Answer:** Message bus linking services for broadcast events like configuration refresh.

### Q8: How to encrypt passwords?
**Answer:** Use /encrypt endpoint, store as `{cipher}...` in config files, Config Server decrypts.

### Q9: Symmetric vs Asymmetric encryption?
**Answer:** Symmetric uses single key (faster), Asymmetric uses key pair (more secure, slower).

### Q10: What is fail-fast?
**Answer:** Property making application fail on startup if Config Server unavailable.

### Q11: How to version configuration?
**Answer:** Use Git branches/tags, specify with `spring.cloud.config.label`.

### Q12: Can Config Server use databases?
**Answer:** Yes, supports JDBC backend, but Git is recommended for version control.

### Q13: What is Vault backend?
**Answer:** HashiCorp Vault integration for storing encrypted secrets with advanced access control.

### Q14: Profile resolution order?
**Answer:** `application.yml` ‚Üí `application-{profile}.yml` ‚Üí `{service}.yml` ‚Üí `{service}-{profile}.yml`

### Q15: How to handle config changes without restart?
**Answer:** Use @RefreshScope on beans, call /actuator/refresh after Git update.

### Q16: What is native profile?
**Answer:** Uses local filesystem instead of Git for configuration files.

### Q17: Can multiple services share config?
**Answer:** Yes, use `application.yml` for common config, service-specific files for overrides.

### Q18: How to secure Config Server?
**Answer:** Spring Security, encrypt properties, use HTTPS, restrict Git access, use Vault.

### Q19: What is composite configuration?
**Answer:** Combining multiple configuration sources (Git + Vault + Native).

### Q20: Config Server alternatives?
**Answer:** Consul, etcd, ZooKeeper, AWS Parameter Store, Azure App Configuration.

---

## üìö Summary

### Key Concepts

```
1. Config Server
   - Centralized configuration
   - Git-backed storage
   - REST API exposure
   - Environment-specific profiles

2. Config Client
   - Fetches config on startup
   - @RefreshScope for updates
   - bootstrap.yml configuration
   - Fail-fast option

3. Encryption
   - Symmetric (single key)
   - Asymmetric (key pair)
   - {cipher} prefix
   - /encrypt, /decrypt endpoints

4. Refresh
   - Manual: /actuator/refresh
   - Automatic: Spring Cloud Bus
   - Webhook integration
   - @RefreshScope annotation
```

### Configuration Template

**Config Server (application.yml):**

```yaml
server:
  port: 8888

spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/config-repo
          default-label: main

encrypt:
  key: ${ENCRYPT_KEY}
```

**Config Client (bootstrap.yml):**

```yaml
spring:
  application:
    name: order-service
  cloud:
    config:
      uri: http://localhost:8888
      fail-fast: true
  profiles:
    active: dev
```

**Usage:**

```java
@Component
@ConfigurationProperties(prefix = "order")
@RefreshScope
@Data
public class OrderProperties {
    private int maxItems;
    private long timeout;
}
```

**Next:** Inter-service Communication ‚Üí

