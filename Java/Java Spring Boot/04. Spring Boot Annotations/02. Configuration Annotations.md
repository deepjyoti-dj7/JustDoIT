# ‚öôÔ∏è Configuration Annotations - Complete Guide

## üìã Table of Contents
- [@Configuration](#configuration)
- [@Bean](#bean)
- [@ComponentScan](#componentscan)
- [@Import](#import)
- [@PropertySource](#propertysource)
- [@Value](#value)
- [@ConfigurationProperties](#configurationproperties)
- [@Profile](#profile)
- [Configuration Best Practices](#configuration-best-practices)
- [Interview Questions](#interview-questions)

---

## üèóÔ∏è @Configuration

Indicates that a class declares one or more **@Bean** methods and may be processed by Spring container to generate bean definitions.

### Basic Usage

```java
@Configuration
public class AppConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

### @Configuration vs @Component

```java
// @Configuration - Full mode (CGLIB proxy)
@Configuration
public class FullConfig {
    @Bean
    public ServiceA serviceA() {
        return new ServiceA();
    }
    
    @Bean
    public ServiceB serviceB() {
        return new ServiceB(serviceA());  // Same instance
    }
}

// @Component - Lite mode (No CGLIB proxy)
@Component
public class LiteConfig {
    @Bean
    public ServiceA serviceA() {
        return new ServiceA();
    }
    
    @Bean
    public ServiceB serviceB() {
        return new ServiceB(serviceA());  // Different instance!
    }
}
```

### Lite Mode with @Configuration(proxyBeanMethods = false)

```java
@Configuration(proxyBeanMethods = false)
public class LiteConfiguration {
    // Faster startup, less memory
    // Use when beans don't call each other
    
    @Bean
    public ServiceA serviceA() {
        return new ServiceA();
    }
    
    @Bean
    public ServiceB serviceB() {
        return new ServiceB();  // Don't call serviceA()
    }
}
```

### Real-World Example: Database Configuration

```java
@Configuration
public class DatabaseConfig {
    
    @Value("${spring.datasource.url}")
    private String url;
    
    @Value("${spring.datasource.username}")
    private String username;
    
    @Value("${spring.datasource.password}")
    private String password;
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setMaximumPoolSize(10);
        dataSource.setMinimumIdle(2);
        dataSource.setConnectionTimeout(30000);
        return dataSource;
    }
    
    @Bean
    public EntityManagerFactory entityManagerFactory(DataSource dataSource) {
        LocalContainerEntityManagerFactoryBean factory = 
            new LocalContainerEntityManagerFactoryBean();
        factory.setDataSource(dataSource);
        factory.setPackagesToScan("com.example.entity");
        factory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        factory.afterPropertiesSet();
        return factory.getObject();
    }
    
    @Bean
    public PlatformTransactionManager transactionManager(
            EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }
}
```

---

## ü´ò @Bean

Indicates that a method produces a **bean** to be managed by Spring container.

### Basic Usage

```java
@Configuration
public class AppConfig {
    
    @Bean
    public UserService userService() {
        return new UserService();
    }
    
    @Bean
    public EmailService emailService() {
        return new EmailService("smtp.gmail.com", 587);
    }
}
```

### Bean Name

```java
@Configuration
public class AppConfig {
    
    // Default name: "userService"
    @Bean
    public UserService userService() {
        return new UserService();
    }
    
    // Custom name: "myUserService"
    @Bean(name = "myUserService")
    public UserService userService2() {
        return new UserService();
    }
    
    // Multiple names
    @Bean(name = {"userService", "userSvc", "usrService"})
    public UserService userService3() {
        return new UserService();
    }
}
```

### Bean Dependencies

```java
@Configuration
public class AppConfig {
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    // Method 1: Direct method call (in @Configuration)
    @Bean
    public UserService userService() {
        return new UserService(userRepository());
    }
    
    // Method 2: Method parameter injection (preferred)
    @Bean
    public EmailService emailService(UserRepository userRepository) {
        return new EmailService(userRepository);
    }
}
```

### Bean Scope

```java
@Configuration
public class AppConfig {
    
    // Singleton (default)
    @Bean
    @Scope("singleton")
    public UserService userService() {
        return new UserService();
    }
    
    // Prototype
    @Bean
    @Scope("prototype")
    public ShoppingCart shoppingCart() {
        return new ShoppingCart();
    }
    
    // Request scope (web applications)
    @Bean
    @Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
    public UserPreferences userPreferences() {
        return new UserPreferences();
    }
    
    // Session scope
    @Bean
    @Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
    public ShoppingCart sessionCart() {
        return new ShoppingCart();
    }
}
```

### Lifecycle Callbacks

```java
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public DataSource dataSource() {
        return new CustomDataSource();
    }
}

class CustomDataSource {
    public void init() {
        System.out.println("Initializing DataSource...");
    }
    
    public void cleanup() {
        System.out.println("Cleaning up DataSource...");
    }
}
```

### Conditional Beans

```java
@Configuration
public class AppConfig {
    
    @Bean
    @ConditionalOnProperty(name = "cache.enabled", havingValue = "true")
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users", "products");
    }
    
    @Bean
    @ConditionalOnMissingBean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}
```

---

## üîé @ComponentScan

Configures component scanning directives for use with **@Configuration** classes.

### Basic Usage

```java
@Configuration
@ComponentScan(basePackages = "com.example.app")
public class AppConfig {
}
```

### Multiple Base Packages

```java
@Configuration
@ComponentScan(basePackages = {
    "com.example.service",
    "com.example.repository",
    "com.example.component"
})
public class AppConfig {
}
```

### Type-Safe Package Scanning

```java
@Configuration
@ComponentScan(basePackageClasses = {
    UserService.class,
    ProductRepository.class
})
public class AppConfig {
    // Scans packages containing these classes
}
```

### Include/Exclude Filters

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.ANNOTATION,
        classes = Service.class
    ),
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*Test.*"
    )
)
public class AppConfig {
}
```

### Filter Types

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = {
        // Annotation type
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = {Service.class, Repository.class}
        ),
        // Assignable type
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = UserService.class
        ),
        // Regex pattern
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = ".*Service"
        ),
        // AspectJ pattern
        @ComponentScan.Filter(
            type = FilterType.ASPECTJ,
            pattern = "com.example..*Service"
        ),
        // Custom filter
        @ComponentScan.Filter(
            type = FilterType.CUSTOM,
            classes = CustomTypeFilter.class
        )
    }
)
public class AppConfig {
}

// Custom filter implementation
public class CustomTypeFilter implements TypeFilter {
    @Override
    public boolean match(MetadataReader metadataReader, 
                        MetadataReaderFactory metadataReaderFactory) {
        // Custom logic
        return metadataReader.getClassMetadata()
            .getClassName().endsWith("Impl");
    }
}
```

---

## üì• @Import

Imports one or more **@Configuration** classes.

### Basic Usage

```java
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}

@Configuration
public class SecurityConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

@Configuration
@Import({DatabaseConfig.class, SecurityConfig.class})
public class AppConfig {
    // Now has access to beans from both configs
}
```

### Import Multiple Configurations

```java
@Configuration
@Import({
    DatabaseConfig.class,
    SecurityConfig.class,
    CacheConfig.class,
    MessagingConfig.class
})
public class MainConfig {
}
```

### Import with @ImportResource (XML)

```java
@Configuration
@ImportResource("classpath:applicationContext.xml")
public class AppConfig {
    // Import legacy XML configuration
}
```

### Conditional Import

```java
@Configuration
@Import({
    DatabaseConfig.class,
    RedisConfig.class
})
@Profile("production")
public class ProductionConfig {
}

@Configuration
@Import({
    H2Config.class
})
@Profile("dev")
public class DevelopmentConfig {
}
```

---

## üìÑ @PropertySource

Adds a property source to Spring's **Environment**.

### Basic Usage

```java
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String appVersion;
}
```

### Multiple Property Files

```java
@Configuration
@PropertySource("classpath:application.properties")
@PropertySource("classpath:database.properties")
@PropertySource("classpath:cache.properties")
public class AppConfig {
}

// Or use array
@Configuration
@PropertySources({
    @PropertySource("classpath:application.properties"),
    @PropertySource("classpath:database.properties"),
    @PropertySource("classpath:cache.properties")
})
public class AppConfig {
}
```

### With Environment

```java
@Configuration
@PropertySource("classpath:app.properties")
public class AppConfig {
    
    @Autowired
    private Environment env;
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl(env.getProperty("db.url"));
        ds.setUsername(env.getProperty("db.username"));
        ds.setPassword(env.getProperty("db.password"));
        return ds;
    }
}
```

### Ignore Resource Not Found

```java
@Configuration
@PropertySource(value = "classpath:optional.properties", ignoreResourceNotFound = true)
public class AppConfig {
    // Won't fail if file doesn't exist
}
```

### Property Placeholder

```java
// app.properties
app.name=MyApp
app.version=1.0.0
db.url=jdbc:mysql://localhost:3306/mydb

// Configuration
@Configuration
@PropertySource("classpath:app.properties")
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String appVersion;
    
    @Value("${db.url}")
    private String dbUrl;
    
    @Bean
    public AppInfo appInfo() {
        return new AppInfo(appName, appVersion);
    }
}
```

---

## üí∞ @Value

Injects values from **properties files** into fields.

### Basic Usage

```java
@Component
public class AppProperties {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String version;
    
    @Value("${app.max-users:100}")  // Default value: 100
    private int maxUsers;
}
```

### Default Values

```java
@Component
public class Config {
    
    @Value("${server.port:8080}")
    private int port;
    
    @Value("${app.name:MyApp}")
    private String appName;
    
    @Value("${cache.enabled:true}")
    private boolean cacheEnabled;
}
```

### Collections

```java
// application.properties
app.servers=server1,server2,server3
app.features=feature1,feature2,feature3

@Component
public class AppConfig {
    
    @Value("${app.servers}")
    private List<String> servers;
    
    @Value("${app.features}")
    private Set<String> features;
    
    @Value("#{${app.port-mapping}}")
    private Map<String, Integer> portMapping;
}
```

### SpEL Expressions

```java
@Component
public class SpELExample {
    
    // System properties
    @Value("#{systemProperties['java.home']}")
    private String javaHome;
    
    // Mathematical expressions
    @Value("#{10 * 2}")
    private int number;
    
    // Boolean expressions
    @Value("#{${app.max-users} > 100}")
    private boolean hasMany Users;
    
    // Ternary operator
    @Value("#{${app.environment} == 'prod' ? 'Production' : 'Development'}")
    private String environmentName;
    
    // Bean property
    @Value("#{appConfig.appName}")
    private String appName;
}
```

### Constructor Injection with @Value

```java
@Component
public class UserService {
    
    private final String apiUrl;
    private final int timeout;
    
    public UserService(
        @Value("${api.url}") String apiUrl,
        @Value("${api.timeout:5000}") int timeout
    ) {
        this.apiUrl = apiUrl;
        this.timeout = timeout;
    }
}
```

---

## üéØ @ConfigurationProperties

Type-safe configuration properties binding.

### Basic Usage

```java
// application.yml
app:
  name: MyApplication
  version: 1.0.0
  max-users: 1000
  features:
    - feature1
    - feature2
    - feature3

@Configuration
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    
    private String name;
    private String version;
    private int maxUsers;
    private List<String> features;
    
    // Getters and setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }
    
    public int getMaxUsers() { return maxUsers; }
    public void setMaxUsers(int maxUsers) { this.maxUsers = maxUsers; }
    
    public List<String> getFeatures() { return features; }
    public void setFeatures(List<String> features) { this.features = features; }
}
```

### Nested Properties

```java
// application.yml
database:
  url: jdbc:mysql://localhost:3306/mydb
  username: root
  password: secret
  pool:
    max-size: 10
    min-idle: 2
    timeout: 30000

@Configuration
@ConfigurationProperties(prefix = "database")
public class DatabaseProperties {
    
    private String url;
    private String username;
    private String password;
    private Pool pool;
    
    // Getters and setters
    
    public static class Pool {
        private int maxSize;
        private int minIdle;
        private int timeout;
        
        // Getters and setters
    }
}
```

### With Validation

```java
@Configuration
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {
    
    @NotBlank
    private String name;
    
    @Min(1)
    @Max(10000)
    private int maxUsers;
    
    @Email
    private String adminEmail;
    
    @Pattern(regexp = "^\\d+\\.\\d+\\.\\d+$")
    private String version;
    
    // Getters and setters
}
```

### Enable ConfigurationProperties

```java
// Method 1: @EnableConfigurationProperties
@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class Application {
}

// Method 2: @ConfigurationPropertiesScan
@SpringBootApplication
@ConfigurationPropertiesScan("com.example.config")
public class Application {
}

// Method 3: @Component (on properties class)
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {
}
```

### Constructor Binding

```java
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    
    private final String name;
    private final String version;
    
    // Constructor binding (immutable)
    public AppProperties(String name, String version) {
        this.name = name;
        this.version = version;
    }
    
    // Only getters needed
    public String getName() { return name; }
    public String getVersion() { return version; }
}

// Enable with
@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class Application {
}
```

### Complex Example

```java
// application.yml
server:
  endpoints:
    - name: api
      url: http://api.example.com
      timeout: 5000
    - name: auth
      url: http://auth.example.com
      timeout: 3000

@Configuration
@ConfigurationProperties(prefix = "server")
public class ServerProperties {
    
    private List<Endpoint> endpoints;
    
    public List<Endpoint> getEndpoints() { return endpoints; }
    public void setEndpoints(List<Endpoint> endpoints) { 
        this.endpoints = endpoints; 
    }
    
    public static class Endpoint {
        private String name;
        private String url;
        private int timeout;
        
        // Getters and setters
    }
}
```

---

## üé≠ @Profile

Activates beans based on **active profiles**.

### Basic Usage

```java
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://prod-server:3306/mydb");
        return ds;
    }
}
```

### Multiple Profiles

```java
@Configuration
@Profile({"dev", "test"})
public class NonProdConfig {
    // Active in dev OR test
}

@Configuration
@Profile("prod & cloud")
public class ProdCloudConfig {
    // Active in prod AND cloud
}

@Configuration
@Profile("!prod")
public class NotProdConfig {
    // Active when prod is NOT active
}
```

### Bean-Level Profile

```java
@Configuration
public class DatabaseConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder().build();
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource() {
        return new HikariDataSource();
    }
}
```

### Activate Profiles

```java
// application.properties
spring.profiles.active=dev

// application.yml
spring:
  profiles:
    active: dev

// Command line
java -jar app.jar --spring.profiles.active=prod

// Programmatically
SpringApplication app = new SpringApplication(Application.class);
app.setAdditionalProfiles("dev");
app.run(args);
```

### Profile-Specific Configuration Files

```
application.properties          # Default
application-dev.properties      # Dev profile
application-test.properties     # Test profile
application-prod.properties     # Prod profile
```

---

## üìå Configuration Best Practices

### 1. Organize Configurations by Concern

```java
// ‚úÖ Separate configs
@Configuration
public class DatabaseConfig { }

@Configuration
public class SecurityConfig { }

@Configuration
public class CacheConfig { }

// ‚ùå Everything in one config
@Configuration
public class AppConfig {
    // Database beans
    // Security beans
    // Cache beans
    // ... too many concerns
}
```

### 2. Use @ConfigurationProperties over @Value

```java
// ‚úÖ Type-safe and organized
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String name;
    private int maxUsers;
    // Getters and setters
}

// ‚ùå Scattered @Value annotations
@Component
public class SomeService {
    @Value("${app.name}")
    private String name;
    
    @Value("${app.max-users}")
    private int maxUsers;
}
```

### 3. Use Constructor Injection in @Configuration

```java
// ‚úÖ Constructor injection
@Configuration
@RequiredArgsConstructor
public class ServiceConfig {
    private final DatabaseConfig databaseConfig;
    
    @Bean
    public UserService userService() {
        return new UserService(databaseConfig.dataSource());
    }
}
```

### 4. Avoid @Bean Method Calls in Lite Mode

```java
// ‚úÖ Proper dependency injection
@Configuration
public class Config {
    @Bean
    public ServiceA serviceA() {
        return new ServiceA();
    }
    
    @Bean
    public ServiceB serviceB(ServiceA serviceA) {
        return new ServiceB(serviceA);
    }
}

// ‚ùå In lite mode
@Configuration(proxyBeanMethods = false)
public class LiteConfig {
    @Bean
    public ServiceB serviceB() {
        return new ServiceB(serviceA());  // Creates new instance!
    }
}
```

### 5. Use Profiles for Environment-Specific Config

```java
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        return h2DataSource();
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        return productionDataSource();
    }
}
```

---

## üé§ Interview Questions

### Q1: What is @Configuration?
**Answer:** Indicates a class contains bean definitions. Creates CGLIB proxies to ensure singleton beans when methods call each other.

### Q2: Difference between @Bean and @Component?
**Answer:**
- **@Bean**: Method-level, used in @Configuration classes, manual bean creation
- **@Component**: Class-level, auto-detected by component scanning

### Q3: What is proxyBeanMethods in @Configuration?
**Answer:** When `true` (default), creates CGLIB proxy ensuring singleton. When `false` (lite mode), faster startup but no singleton guarantee for inter-bean calls.

### Q4: @Value vs @ConfigurationProperties?
**Answer:**
- **@Value**: Simple properties, SpEL expressions, less type-safe
- **@ConfigurationProperties**: Complex nested properties, type-safe, validation support

### Q5: How to activate a profile?
**Answer:**
- Properties: `spring.profiles.active=dev`
- Command line: `--spring.profiles.active=dev`
- Programmatically: `app.setAdditionalProfiles("dev")`

### Q6: Can @Bean methods have parameters?
**Answer:** Yes, parameters are autowired by Spring. Preferred over calling @Bean methods directly.

### Q7: What is @ComponentScan?
**Answer:** Scans specified packages for stereotype annotations (@Component, @Service, @Repository, @Controller) and registers them as beans.

### Q8: What is @Import used for?
**Answer:** Imports one or more @Configuration classes, allowing modular configuration organization.

### Q9: Difference between @PropertySource and application.properties?
**Answer:** application.properties is automatically loaded by Spring Boot. @PropertySource explicitly loads additional property files.

### Q10: How to provide default values with @Value?
**Answer:**
```java
@Value("${property.name:defaultValue}")
private String property;
```

---

## üìö Summary

### Key Annotations
- **@Configuration**: Bean definition class
- **@Bean**: Bean factory method
- **@ComponentScan**: Auto-detect components
- **@Import**: Import configurations
- **@PropertySource**: Load properties
- **@Value**: Inject property values
- **@ConfigurationProperties**: Type-safe properties
- **@Profile**: Environment-specific beans

### Best Practices
1. Organize configs by **concern**
2. Use **@ConfigurationProperties** for complex properties
3. Use **constructor injection** in configs
4. Use **profiles** for environments
5. **Validate** configuration properties

### Complete Example

```java
// Properties
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {
    @NotBlank
    private String name;
    private int maxUsers;
    // Getters/setters
}

// Configuration
@Configuration
@EnableConfigurationProperties(AppProperties.class)
@PropertySource("classpath:custom.properties")
public class AppConfig {
    
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        return h2DataSource();
    }
    
    @Bean
    @Profile("prod")
    public DataSource prodDataSource(AppProperties props) {
        return hikariDataSource(props);
    }
}
```

**Next:** Web Annotations ‚Üí

