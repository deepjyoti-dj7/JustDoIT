# üíæ Data Annotations - Complete Guide

## üìã Table of Contents
- [JPA Entity Annotations](#jpa-entity-annotations)
- [Table Mapping](#table-mapping)
- [Column Mapping](#column-mapping)
- [Primary Key Annotations](#primary-key-annotations)
- [Relationship Annotations](#relationship-annotations)
- [Query Annotations](#query-annotations)
- [Spring Data Annotations](#spring-data-annotations)
- [Transaction Annotations](#transaction-annotations)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üèõÔ∏è JPA Entity Annotations

### @Entity

Marks a class as a **JPA entity** (database table).

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String email;
    private LocalDateTime createdAt;
}
```

### @Table

Specifies table details.

```java
@Entity
@Table(
    name = "users",
    schema = "public",
    uniqueConstraints = {
        @UniqueConstraint(columnNames = "username"),
        @UniqueConstraint(columnNames = "email")
    },
    indexes = {
        @Index(name = "idx_username", columnList = "username"),
        @Index(name = "idx_email", columnList = "email")
    }
)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String email;
}
```

### Complete Entity Example

```java
@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(nullable = false)
    private Integer stock = 0;
    
    @Enumerated(EnumType.STRING)
    private ProductStatus status;
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    private LocalDateTime updatedAt;
}
```

---

## üìä Table Mapping

### @Table Attributes

```java
@Entity
@Table(
    name = "orders",                    // Table name
    schema = "ecommerce",               // Database schema
    catalog = "mydb",                   // Database catalog
    uniqueConstraints = {               // Unique constraints
        @UniqueConstraint(
            name = "UK_order_number",
            columnNames = "order_number"
        )
    },
    indexes = {                         // Indexes
        @Index(name = "idx_user_id", columnList = "user_id"),
        @Index(name = "idx_status", columnList = "status"),
        @Index(name = "idx_created_at", columnList = "created_at")
    }
)
public class Order {
    @Id
    private Long id;
    
    @Column(name = "order_number", unique = true)
    private String orderNumber;
    
    @Column(name = "user_id")
    private Long userId;
    
    private OrderStatus status;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
}
```

### Composite Unique Constraints

```java
@Entity
@Table(
    name = "enrollments",
    uniqueConstraints = {
        @UniqueConstraint(
            name = "UK_student_course",
            columnNames = {"student_id", "course_id"}
        )
    }
)
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "student_id")
    private Long studentId;
    
    @Column(name = "course_id")
    private Long courseId;
    
    private LocalDateTime enrolledAt;
}
```

---

## üìù Column Mapping

### @Column

Maps field to database column.

```java
@Entity
public class User {
    
    @Id
    private Long id;
    
    // Basic column
    @Column(name = "user_name")
    private String username;
    
    // Not null
    @Column(nullable = false)
    private String email;
    
    // Length constraint
    @Column(length = 500)
    private String bio;
    
    // Unique
    @Column(unique = true)
    private String phoneNumber;
    
    // Not updatable
    @Column(updatable = false)
    private LocalDateTime createdAt;
    
    // Not insertable
    @Column(insertable = false)
    private String generatedField;
    
    // Custom column definition
    @Column(columnDefinition = "TEXT")
    private String description;
    
    // Precision and scale (for decimals)
    @Column(precision = 10, scale = 2)
    private BigDecimal salary;
}
```

### @Transient

Excludes field from database.

```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String firstName;
    private String lastName;
    
    // Not stored in database
    @Transient
    private String fullName;
    
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

### @Lob

Large objects (BLOB/CLOB).

```java
@Entity
public class Document {
    @Id
    private Long id;
    
    // Large text
    @Lob
    @Column(columnDefinition = "TEXT")
    private String content;
    
    // Binary data
    @Lob
    @Column(columnDefinition = "BLOB")
    private byte[] fileData;
}
```

### @Enumerated

Maps enum types.

```java
public enum UserStatus {
    ACTIVE, INACTIVE, BANNED
}

@Entity
public class User {
    @Id
    private Long id;
    
    // STRING - stores enum name
    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private UserStatus status;
    
    // ORDINAL - stores enum position (0, 1, 2) - NOT RECOMMENDED
    @Enumerated(EnumType.ORDINAL)
    private UserRole role;
}
```

### @Temporal

Date/time mapping (for java.util.Date).

```java
@Entity
public class Event {
    @Id
    private Long id;
    
    // Date only
    @Temporal(TemporalType.DATE)
    private Date eventDate;
    
    // Time only
    @Temporal(TemporalType.TIME)
    private Date eventTime;
    
    // Date and time
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdAt;
    
    // Modern way (Java 8+)
    private LocalDate date;
    private LocalTime time;
    private LocalDateTime timestamp;
}
```

---

## üîë Primary Key Annotations

### @Id

Marks primary key field.

```java
@Entity
public class User {
    @Id
    private Long id;
}
```

### @GeneratedValue

Auto-generates primary key.

```java
@Entity
public class User {
    
    // AUTO - JPA chooses strategy
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    
    // IDENTITY - Auto-increment
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // SEQUENCE - Database sequence
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
    @SequenceGenerator(name = "user_seq", sequenceName = "user_sequence", allocationSize = 1)
    private Long id;
    
    // TABLE - Sequence table
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "user_gen")
    @TableGenerator(name = "user_gen", table = "id_gen", pkColumnName = "gen_name", valueColumnName = "gen_val")
    private Long id;
}
```

### UUID Primary Key

```java
@Entity
public class Order {
    
    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(updatable = false, nullable = false)
    private UUID id;
}
```

### @EmbeddedId (Composite Key)

```java
@Embeddable
@Data
public class OrderItemId implements Serializable {
    private Long orderId;
    private Long productId;
}

@Entity
public class OrderItem {
    
    @EmbeddedId
    private OrderItemId id;
    
    private Integer quantity;
    private BigDecimal price;
}
```

### @IdClass (Composite Key Alternative)

```java
@Data
public class EnrollmentId implements Serializable {
    private Long studentId;
    private Long courseId;
}

@Entity
@IdClass(EnrollmentId.class)
public class Enrollment {
    
    @Id
    private Long studentId;
    
    @Id
    private Long courseId;
    
    private LocalDateTime enrolledAt;
}
```

---

## üîó Relationship Annotations

### @OneToOne

One-to-one relationship.

```java
// User entity
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    // Owning side
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private UserProfile profile;
}

// UserProfile entity
@Entity
public class UserProfile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String bio;
    private String avatarUrl;
    
    // Non-owning side
    @OneToOne(mappedBy = "profile")
    private User user;
}
```

### @OneToMany & @ManyToOne

One-to-many relationship.

```java
// User entity (One side)
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders = new ArrayList<>();
    
    public void addOrder(Order order) {
        orders.add(order);
        order.setUser(this);
    }
    
    public void removeOrder(Order order) {
        orders.remove(order);
        order.setUser(null);
    }
}

// Order entity (Many side)
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String orderNumber;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}
```

### @ManyToMany

Many-to-many relationship.

```java
// Student entity
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();
    
    public void enrollCourse(Course course) {
        courses.add(course);
        course.getStudents().add(this);
    }
    
    public void withdrawCourse(Course course) {
        courses.remove(course);
        course.getStudents().remove(this);
    }
}

// Course entity
@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}
```

### Cascade Types

```java
@Entity
public class User {
    
    // Persist children when persisting parent
    @OneToMany(cascade = CascadeType.PERSIST)
    private List<Order> orders;
    
    // Merge children when merging parent
    @OneToMany(cascade = CascadeType.MERGE)
    private List<Order> orders;
    
    // Remove children when removing parent
    @OneToMany(cascade = CascadeType.REMOVE)
    private List<Order> orders;
    
    // Refresh children when refreshing parent
    @OneToMany(cascade = CascadeType.REFRESH)
    private List<Order> orders;
    
    // Detach children when detaching parent
    @OneToMany(cascade = CascadeType.DETACH)
    private List<Order> orders;
    
    // All cascade operations
    @OneToMany(cascade = CascadeType.ALL)
    private List<Order> orders;
    
    // Orphan removal
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders;
}
```

### Fetch Types

```java
@Entity
public class Order {
    
    // LAZY - Load when accessed (default for collections)
    @ManyToOne(fetch = FetchType.LAZY)
    private User user;
    
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "order")
    private List<OrderItem> items;
    
    // EAGER - Load immediately (default for single entities)
    @ManyToOne(fetch = FetchType.EAGER)
    private User user;
}
```

---

## üîç Query Annotations

### @Query

Custom JPQL/SQL queries.

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // JPQL query
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    // JPQL with multiple parameters
    @Query("SELECT u FROM User u WHERE u.status = :status AND u.createdAt >= :date")
    List<User> findByStatusAndCreatedAfter(
        @Param("status") UserStatus status,
        @Param("date") LocalDateTime date
    );
    
    // Native SQL query
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmailNative(String email);
    
    // Native query with named parameters
    @Query(value = "SELECT * FROM users WHERE username = :username", nativeQuery = true)
    User findByUsernameNative(@Param("username") String username);
}
```

### @Modifying

Modifying queries (UPDATE/DELETE).

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Modifying
    @Transactional
    @Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
    int updateStatus(@Param("id") Long id, @Param("status") UserStatus status);
    
    @Modifying
    @Transactional
    @Query("DELETE FROM User u WHERE u.status = :status")
    int deleteByStatus(@Param("status") UserStatus status);
    
    @Modifying
    @Transactional
    @Query("UPDATE User u SET u.lastLogin = :date WHERE u.id IN :ids")
    int updateLastLogin(@Param("ids") List<Long> ids, @Param("date") LocalDateTime date);
}
```

### @Param

Names query parameters.

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query("SELECT p FROM Product p WHERE p.name LIKE %:name% AND p.price <= :maxPrice")
    List<Product> search(@Param("name") String name, @Param("maxPrice") BigDecimal maxPrice);
}
```

---

## üóÇÔ∏è Spring Data Annotations

### @Repository

Marks as repository (data access layer).

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    List<User> findByStatus(UserStatus status);
}
```

### Query Method Keywords

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find by field
    Optional<User> findByUsername(String username);
    List<User> findByStatus(UserStatus status);
    
    // Multiple conditions
    List<User> findByUsernameAndStatus(String username, UserStatus status);
    List<User> findByUsernameOrEmail(String username, String email);
    
    // Comparison
    List<User> findByAgeLessThan(Integer age);
    List<User> findByAgeGreaterThan(Integer age);
    List<User> findByAgeBetween(Integer start, Integer end);
    
    // String operations
    List<User> findByUsernameStartingWith(String prefix);
    List<User> findByUsernameEndingWith(String suffix);
    List<User> findByUsernameContaining(String keyword);
    List<User> findByUsernameLike(String pattern);
    
    // Null checks
    List<User> findByEmailIsNull();
    List<User> findByEmailIsNotNull();
    
    // Collection operations
    List<User> findByIdIn(List<Long> ids);
    List<User> findByIdNotIn(List<Long> ids);
    
    // Boolean
    List<User> findByActiveTrue();
    List<User> findByActiveFalse();
    
    // Ordering
    List<User> findByStatusOrderByCreatedAtDesc(UserStatus status);
    List<User> findByStatusOrderByUsernameAscCreatedAtDesc(UserStatus status);
    
    // Limiting results
    User findFirstByOrderByCreatedAtDesc();
    List<User> findTop10ByOrderByCreatedAtDesc();
    
    // Distinct
    List<String> findDistinctByStatus(UserStatus status);
    
    // Count, exists, delete
    long countByStatus(UserStatus status);
    boolean existsByUsername(String username);
    void deleteByStatus(UserStatus status);
}
```

### @EntityGraph

Solves N+1 query problem.

```java
@Entity
@NamedEntityGraph(
    name = "User.orders",
    attributeNodes = @NamedAttributeNode("orders")
)
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @EntityGraph(value = "User.orders", type = EntityGraph.EntityGraphType.LOAD)
    Optional<User> findWithOrdersById(Long id);
    
    @EntityGraph(attributePaths = {"orders", "orders.items"})
    Optional<User> findWithOrdersAndItemsById(Long id);
}
```

---

## üíº Transaction Annotations

### @Transactional

Manages transactions.

```java
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // All methods in transaction by default
    
    // Read-only transaction
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
    
    // Custom timeout
    @Transactional(timeout = 10)
    public User createUser(UserDto dto) {
        User user = new User();
        user.setUsername(dto.getUsername());
        
        User saved = userRepository.save(user);
        emailService.sendWelcomeEmail(saved.getEmail());
        
        return saved;
    }
    
    // Custom propagation
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logActivity(Long userId, String activity) {
        // Always creates new transaction
    }
    
    // Rollback configuration
    @Transactional(rollbackFor = Exception.class)
    public void processOrder(OrderDto dto) {
        // Rolls back on any Exception
    }
    
    @Transactional(noRollbackFor = ValidationException.class)
    public void validateAndSave(User user) {
        // Doesn't rollback for ValidationException
    }
}
```

### Propagation Types

```java
public class TransactionService {
    
    // REQUIRED (default) - Join existing or create new
    @Transactional(propagation = Propagation.REQUIRED)
    public void method1() { }
    
    // REQUIRES_NEW - Always create new transaction
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void method2() { }
    
    // MANDATORY - Must be called within existing transaction
    @Transactional(propagation = Propagation.MANDATORY)
    public void method3() { }
    
    // SUPPORTS - Join if exists, non-transactional otherwise
    @Transactional(propagation = Propagation.SUPPORTS)
    public void method4() { }
    
    // NOT_SUPPORTED - Execute non-transactionally
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void method5() { }
    
    // NEVER - Must NOT be called within transaction
    @Transactional(propagation = Propagation.NEVER)
    public void method6() { }
    
    // NESTED - Nested transaction with savepoint
    @Transactional(propagation = Propagation.NESTED)
    public void method7() { }
}
```

### Isolation Levels

```java
public class IsolationService {
    
    // READ_UNCOMMITTED - Dirty reads possible
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void method1() { }
    
    // READ_COMMITTED - Prevents dirty reads
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void method2() { }
    
    // REPEATABLE_READ - Prevents dirty & non-repeatable reads
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void method3() { }
    
    // SERIALIZABLE - Prevents all concurrency issues
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void method4() { }
}
```

---

## üìå Best Practices

### 1. Use Appropriate Fetch Type

```java
// ‚úÖ LAZY for collections (avoid N+1)
@OneToMany(mappedBy = "user", fetch = FetchType.LAZY)
private List<Order> orders;

// ‚ùå EAGER for collections (causes N+1)
@OneToMany(mappedBy = "user", fetch = FetchType.EAGER)
private List<Order> orders;
```

### 2. Use @EntityGraph for Optimization

```java
// ‚úÖ Fetch associations in single query
@EntityGraph(attributePaths = {"orders", "profile"})
Optional<User> findWithDetailsById(Long id);

// ‚ùå Multiple queries (N+1 problem)
Optional<User> findById(Long id);
```

### 3. Use @Transactional(readOnly = true) for Queries

```java
// ‚úÖ Read-only optimization
@Transactional(readOnly = true)
public List<User> findAll() {
    return userRepository.findAll();
}
```

### 4. Use Enums with STRING

```java
// ‚úÖ String - safe for refactoring
@Enumerated(EnumType.STRING)
private UserStatus status;

// ‚ùå Ordinal - breaks when enum order changes
@Enumerated(EnumType.ORDINAL)
private UserStatus status;
```

### 5. Always Use @Param in @Query

```java
// ‚úÖ Named parameters (clear & safe)
@Query("SELECT u FROM User u WHERE u.name = :name")
User find(@Param("name") String name);

// ‚ùå Positional parameters (error-prone)
@Query("SELECT u FROM User u WHERE u.name = ?1")
User find(String name);
```

---

## üé§ Interview Questions

### Q1: What is @Entity?
**Answer:** Marks a class as JPA entity representing a database table.

### Q2: Difference between @Id and @GeneratedValue?
**Answer:**
- **@Id**: Marks primary key field
- **@GeneratedValue**: Specifies how primary key is generated (IDENTITY, SEQUENCE, TABLE, AUTO)

### Q3: What is @Column used for?
**Answer:** Maps entity field to database column with constraints (name, nullable, unique, length, precision, scale).

### Q4: Difference between LAZY and EAGER fetching?
**Answer:**
- **LAZY**: Loads data when accessed (default for collections)
- **EAGER**: Loads data immediately (default for single entities)

### Q5: What is @Transactional?
**Answer:** Manages transactions. Ensures operations execute within transaction boundary with commit/rollback.

### Q6: What is cascade in JPA?
**Answer:** Propagates operations from parent to child entities (PERSIST, MERGE, REMOVE, REFRESH, DETACH, ALL).

### Q7: Difference between @OneToMany and @ManyToOne?
**Answer:** Two sides of same relationship. @ManyToOne is owning side (has foreign key), @OneToMany is inverse side.

### Q8: What is @Query annotation?
**Answer:** Defines custom JPQL or native SQL queries in Spring Data repositories.

### Q9: What is N+1 query problem?
**Answer:** One query for parent + N queries for children. Solve with @EntityGraph, JOIN FETCH, or batch fetching.

### Q10: What is orphanRemoval?
**Answer:** Automatically deletes child entities when removed from parent collection.

```java
@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
private List<Order> orders;
```

---

## üìö Summary

### Key Annotations
- **@Entity**: JPA entity
- **@Table**: Table mapping
- **@Id**: Primary key
- **@GeneratedValue**: Auto-generate ID
- **@Column**: Column mapping
- **@OneToOne/@OneToMany/@ManyToOne/@ManyToMany**: Relationships
- **@Query**: Custom queries
- **@Transactional**: Transaction management

### Best Practices
1. Use **LAZY** fetch for collections
2. Use **@EntityGraph** to avoid N+1
3. Use **@Transactional(readOnly = true)** for queries
4. Use **EnumType.STRING** for enums
5. Use **named parameters** in @Query

### Complete Entity Example

```java
@Entity
@Table(name = "users", uniqueConstraints = {
    @UniqueConstraint(columnNames = "username"),
    @UniqueConstraint(columnNames = "email")
})
@Data
@NoArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 50)
    private String username;
    
    @Column(nullable = false, length = 100)
    private String email;
    
    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private UserStatus status;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<Order> orders = new ArrayList<>();
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    @EntityGraph(attributePaths = "orders")
    Optional<User> findWithOrdersById(Long id);
}

@Service
@Transactional
public class UserService {
    
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
}
```

**Next:** Security Annotations ‚Üí

