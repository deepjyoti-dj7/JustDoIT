# üí≥ Transaction Annotations - Complete Guide

## üìã Table of Contents
- [@Transactional](#transactional)
- [Propagation Levels](#propagation-levels)
- [Isolation Levels](#isolation-levels)
- [Rollback Rules](#rollback-rules)
- [Read-Only Transactions](#read-only-transactions)
- [Transaction Timeout](#transaction-timeout)
- [Transaction Events](#transaction-events)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üíº @Transactional

Manages database transactions declaratively.

### Basic Usage

```java
@Service
@Transactional
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public User createUser(UserDto dto) {
        User user = new User();
        user.setUsername(dto.getUsername());
        user.setEmail(dto.getEmail());
        
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser.getEmail());
        
        return savedUser;  // Both operations in one transaction
    }
}
```

### Method-Level Transaction

```java
@Service
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final InventoryService inventoryService;
    
    // Transactional method
    @Transactional
    public Order createOrder(OrderDto dto) {
        Order order = new Order();
        order.setItems(dto.getItems());
        
        Order savedOrder = orderRepository.save(order);
        inventoryService.updateStock(savedOrder.getItems());
        
        return savedOrder;
    }
    
    // Non-transactional method
    public List<Order> getAllOrders() {
        return orderRepository.findAll();
    }
}
```

### Class vs Method Level

```java
// Class-level (all methods transactional)
@Service
@Transactional
public class ProductService {
    
    public Product create(ProductDto dto) {
        // Transactional
    }
    
    public void update(Long id, ProductDto dto) {
        // Transactional
    }
    
    // Override class-level setting
    @Transactional(readOnly = true)
    public Product findById(Long id) {
        // Read-only transaction
    }
}
```

---

## üîÑ Propagation Levels

Controls transaction behavior when a transactional method calls another transactional method.

### REQUIRED (Default)

```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentService paymentService;
    
    // Creates transaction if none exists
    // Joins existing transaction if present
    @Transactional(propagation = Propagation.REQUIRED)
    public void processOrder(Order order) {
        orderRepository.save(order);
        paymentService.processPayment(order);  // Joins this transaction
    }
}

@Service
public class PaymentService {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void processPayment(Order order) {
        // Executes in same transaction as processOrder
        paymentRepository.save(new Payment(order));
    }
}
```

### REQUIRES_NEW

```java
@Service
public class OrderService {
    
    @Autowired
    private AuditService auditService;
    
    @Transactional
    public void processOrder(Order order) {
        orderRepository.save(order);
        
        try {
            auditService.logOrder(order);  // Executes in new transaction
        } catch (Exception e) {
            // Audit failure doesn't affect order transaction
        }
    }
}

@Service
public class AuditService {
    
    // Always creates new transaction
    // Suspends current transaction
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logOrder(Order order) {
        auditRepository.save(new AuditLog(order));
        // Commits independently
    }
}
```

### MANDATORY

```java
@Service
public class PaymentService {
    
    // Must be called within existing transaction
    // Throws exception if no transaction exists
    @Transactional(propagation = Propagation.MANDATORY)
    public void processPayment(Payment payment) {
        paymentRepository.save(payment);
    }
}

@Service
public class OrderService {
    
    @Transactional
    public void createOrder(OrderDto dto) {
        Order order = orderRepository.save(dto.toEntity());
        paymentService.processPayment(order.getPayment());  // OK - transaction exists
    }
    
    public void someMethod() {
        paymentService.processPayment(payment);  // FAILS - no transaction
    }
}
```

### SUPPORTS

```java
@Service
public class ReportService {
    
    // Executes in transaction if exists
    // Executes non-transactionally if no transaction
    @Transactional(propagation = Propagation.SUPPORTS)
    public Report generateReport() {
        return new Report(dataRepository.findAll());
    }
}
```

### NOT_SUPPORTED

```java
@Service
public class CacheService {
    
    // Always executes non-transactionally
    // Suspends current transaction if exists
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void updateCache(String key, Object value) {
        cache.put(key, value);
    }
}
```

### NEVER

```java
@Service
public class ValidationService {
    
    // Must NOT be called within transaction
    // Throws exception if transaction exists
    @Transactional(propagation = Propagation.NEVER)
    public void validateData(Data data) {
        // Validation logic
    }
}
```

### NESTED

```java
@Service
public class OrderService {
    
    @Transactional
    public void processOrder(OrderDto dto) {
        Order order = orderRepository.save(dto.toEntity());
        
        try {
            bonusService.awardBonus(order);  // Nested transaction
        } catch (Exception e) {
            // Nested transaction rolled back
            // Main transaction continues
        }
    }
}

@Service
public class BonusService {
    
    // Creates nested transaction (savepoint)
    // Can rollback independently
    @Transactional(propagation = Propagation.NESTED)
    public void awardBonus(Order order) {
        bonusRepository.save(new Bonus(order));
    }
}
```

### Propagation Comparison

| Propagation | Behavior | Use Case |
|-------------|----------|----------|
| **REQUIRED** | Join or create | Default, most common |
| **REQUIRES_NEW** | Always new | Independent operations (audit, logging) |
| **MANDATORY** | Must exist | Enforce transactional context |
| **SUPPORTS** | Optional | Read operations |
| **NOT_SUPPORTED** | Never use | Non-transactional operations |
| **NEVER** | Forbidden | Must be non-transactional |
| **NESTED** | Savepoint | Partial rollback scenarios |

---

## üîí Isolation Levels

Controls data visibility between concurrent transactions.

### READ_UNCOMMITTED

```java
@Service
public class ReportService {
    
    // Lowest isolation - allows dirty reads
    // Fastest but least safe
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public List<Order> getDailyReport() {
        return orderRepository.findToday();
        // May read uncommitted changes from other transactions
    }
}
```

### READ_COMMITTED

```java
@Service
public class OrderService {
    
    // Prevents dirty reads
    // Default for most databases (PostgreSQL, SQL Server, Oracle)
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public Order getOrder(Long id) {
        return orderRepository.findById(id).orElseThrow();
        // Only reads committed data
        // But data may change during transaction (non-repeatable read)
    }
}
```

### REPEATABLE_READ

```java
@Service
public class InventoryService {
    
    // Prevents dirty & non-repeatable reads
    // Default for MySQL
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void updateStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId).orElseThrow();
        // If we read product again, values will be same
        
        product.setStock(product.getStock() - quantity);
        productRepository.save(product);
        
        // Phantom reads still possible
    }
}
```

### SERIALIZABLE

```java
@Service
public class AccountService {
    
    // Highest isolation - prevents all anomalies
    // Slowest - locks tables
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        Account from = accountRepository.findById(fromId).orElseThrow();
        Account to = accountRepository.findById(toId).orElseThrow();
        
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        accountRepository.save(from);
        accountRepository.save(to);
        // Complete isolation - no other transaction can interfere
    }
}
```

### Isolation Comparison

| Isolation | Dirty Read | Non-Repeatable Read | Phantom Read | Performance |
|-----------|------------|---------------------|--------------|-------------|
| **READ_UNCOMMITTED** | ‚úÖ Possible | ‚úÖ Possible | ‚úÖ Possible | ‚ö° Fastest |
| **READ_COMMITTED** | ‚ùå Prevented | ‚úÖ Possible | ‚úÖ Possible | ‚ö°‚ö° Fast |
| **REPEATABLE_READ** | ‚ùå Prevented | ‚ùå Prevented | ‚úÖ Possible | ‚ö°‚ö°‚ö° Moderate |
| **SERIALIZABLE** | ‚ùå Prevented | ‚ùå Prevented | ‚ùå Prevented | üêå Slowest |

---

## üîô Rollback Rules

Controls which exceptions trigger rollback.

### Default Rollback Behavior

```java
@Service
public class OrderService {
    
    @Transactional
    public void createOrder(OrderDto dto) {
        orderRepository.save(dto.toEntity());
        
        // RuntimeException - ROLLS BACK
        throw new IllegalStateException("Error");
        
        // Checked Exception - COMMITS
        // throw new Exception("Error");
    }
}
```

### Rollback on Checked Exceptions

```java
@Service
public class PaymentService {
    
    // Rollback on any Exception (including checked)
    @Transactional(rollbackFor = Exception.class)
    public void processPayment(Payment payment) throws PaymentException {
        paymentRepository.save(payment);
        
        if (payment.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new PaymentException("Invalid amount");  // ROLLS BACK
        }
    }
}
```

### No Rollback for Specific Exceptions

```java
@Service
public class UserService {
    
    // Don't rollback for ValidationException
    @Transactional(noRollbackFor = ValidationException.class)
    public User createUser(UserDto dto) throws ValidationException {
        User user = userRepository.save(dto.toEntity());
        
        if (!isValid(user)) {
            throw new ValidationException("Invalid user");  // COMMITS
        }
        
        return user;
    }
}
```

### Multiple Rollback Rules

```java
@Service
public class OrderService {
    
    @Transactional(
        rollbackFor = {PaymentException.class, StockException.class},
        noRollbackFor = {ValidationException.class, LoggingException.class}
    )
    public Order processOrder(OrderDto dto) 
            throws PaymentException, StockException, ValidationException {
        
        Order order = orderRepository.save(dto.toEntity());
        
        // These exceptions cause rollback
        if (paymentFails()) throw new PaymentException();
        if (outOfStock()) throw new StockException();
        
        // These exceptions don't cause rollback
        if (invalidData()) throw new ValidationException();
        
        return order;
    }
}
```

---

## üìñ Read-Only Transactions

Optimization for read operations.

### Basic Read-Only

```java
@Service
public class ProductService {
    
    // Optimization: no flush, no dirty checking
    @Transactional(readOnly = true)
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
    
    @Transactional(readOnly = true)
    public Product findById(Long id) {
        return productRepository.findById(id).orElseThrow();
    }
}
```

### Class-Level with Override

```java
@Service
@Transactional(readOnly = true)
public class UserService {
    
    // All methods read-only by default
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    public User findById(Long id) {
        return userRepository.findById(id).orElseThrow();
    }
    
    // Override for write operations
    @Transactional
    public User create(UserDto dto) {
        return userRepository.save(dto.toEntity());
    }
    
    @Transactional
    public void delete(Long id) {
        userRepository.deleteById(id);
    }
}
```

### Benefits of Read-Only

```java
@Service
public class ReportService {
    
    @Transactional(readOnly = true)
    public Report generate() {
        // Benefits:
        // 1. No entity flush - performance improvement
        // 2. No dirty checking - memory savings
        // 3. Database can optimize (read replicas, caching)
        // 4. Prevents accidental writes
        
        List<Order> orders = orderRepository.findAll();
        return new Report(orders);
    }
}
```

---

## ‚è±Ô∏è Transaction Timeout

Sets maximum time for transaction execution.

### Basic Timeout

```java
@Service
public class OrderService {
    
    // Timeout after 10 seconds
    @Transactional(timeout = 10)
    public void processOrder(OrderDto dto) {
        orderRepository.save(dto.toEntity());
        // If this takes > 10 seconds, transaction rolls back
    }
}
```

### Long-Running Transactions

```java
@Service
public class BatchService {
    
    // Timeout after 5 minutes (300 seconds)
    @Transactional(timeout = 300)
    public void processBatch(List<Data> dataList) {
        for (Data data : dataList) {
            dataRepository.save(data);
        }
    }
}
```

### Short Timeout for Critical Operations

```java
@Service
public class PaymentService {
    
    // Fast timeout for payment processing
    @Transactional(timeout = 5)
    public void processPayment(Payment payment) {
        paymentGateway.charge(payment);
        paymentRepository.save(payment);
        // Must complete within 5 seconds
    }
}
```

---

## üéØ Transaction Events

Listen to transaction lifecycle events.

### Transaction Event Listeners

```java
@Component
public class TransactionEventListener {
    
    // Before transaction commit
    @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
    public void handleBeforeCommit(OrderCreatedEvent event) {
        log.info("Before commit: Order {}", event.getOrderId());
        // Validation, final checks
    }
    
    // After successful commit
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleAfterCommit(OrderCreatedEvent event) {
        log.info("After commit: Order {}", event.getOrderId());
        // Send notifications, update cache
        emailService.sendOrderConfirmation(event.getOrderId());
    }
    
    // After rollback
    @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK)
    public void handleAfterRollback(OrderCreatedEvent event) {
        log.error("Rollback: Order {}", event.getOrderId());
        // Cleanup, notify about failure
    }
    
    // After transaction completion (commit or rollback)
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)
    public void handleAfterCompletion(OrderCreatedEvent event) {
        log.info("Completed: Order {}", event.getOrderId());
        // Logging, metrics
    }
}

@Service
@Transactional
public class OrderService {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public Order createOrder(OrderDto dto) {
        Order order = orderRepository.save(dto.toEntity());
        
        // Publish event
        eventPublisher.publishEvent(new OrderCreatedEvent(order.getId()));
        
        return order;
    }
}

public class OrderCreatedEvent {
    private final Long orderId;
    
    public OrderCreatedEvent(Long orderId) {
        this.orderId = orderId;
    }
    
    public Long getOrderId() {
        return orderId;
    }
}
```

---

## üìå Best Practices

### 1. Use Read-Only for Queries

```java
// ‚úÖ Optimized
@Transactional(readOnly = true)
public List<User> findAll() {
    return userRepository.findAll();
}

// ‚ùå Unnecessary overhead
@Transactional
public List<User> findAll() {
    return userRepository.findAll();
}
```

### 2. Keep Transactions Short

```java
// ‚úÖ Short transaction
@Transactional
public Order createOrder(OrderDto dto) {
    Order order = orderRepository.save(dto.toEntity());
    return order;
}

public void notifyCustomer(Order order) {
    // Non-transactional
    emailService.send(order.getUserEmail());
}

// ‚ùå Long transaction
@Transactional
public Order createOrder(OrderDto dto) {
    Order order = orderRepository.save(dto.toEntity());
    emailService.send(order.getUserEmail());  // Slow operation in transaction
    return order;
}
```

### 3. Use Appropriate Propagation

```java
// ‚úÖ Independent audit logging
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void logActivity(String activity) {
    auditRepository.save(new AuditLog(activity));
}

// ‚ùå Audit fails = business operation fails
@Transactional
public void logActivity(String activity) {
    auditRepository.save(new AuditLog(activity));
}
```

### 4. Be Explicit About Rollback Rules

```java
// ‚úÖ Clear rollback behavior
@Transactional(rollbackFor = Exception.class)
public void processPayment(Payment payment) throws PaymentException {
    // Rolls back on any exception
}

// ‚ùå Unclear - checked exceptions don't rollback
@Transactional
public void processPayment(Payment payment) throws PaymentException {
    // PaymentException doesn't trigger rollback!
}
```

### 5. Avoid @Transactional on Private Methods

```java
// ‚úÖ Works - public method
@Service
public class UserService {
    @Transactional
    public void createUser(UserDto dto) {
        // Transaction works
    }
}

// ‚ùå Doesn't work - private method
@Service
public class UserService {
    @Transactional
    private void createUser(UserDto dto) {
        // Transaction ignored (Spring uses proxies)
    }
}
```

---

## üé§ Interview Questions

### Q1: What is @Transactional?
**Answer:** Annotation that manages database transactions declaratively. Ensures atomicity, consistency, isolation, durability (ACID) properties.

### Q2: What is transaction propagation?
**Answer:** Controls transaction behavior when one transactional method calls another. Types: REQUIRED, REQUIRES_NEW, MANDATORY, SUPPORTS, NOT_SUPPORTED, NEVER, NESTED.

### Q3: What is default propagation level?
**Answer:** REQUIRED - joins existing transaction or creates new one.

### Q4: What is difference between REQUIRED and REQUIRES_NEW?
**Answer:**
- **REQUIRED**: Joins existing or creates new
- **REQUIRES_NEW**: Always creates new, suspends current

### Q5: What is transaction isolation?
**Answer:** Controls data visibility between concurrent transactions. Levels: READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE.

### Q6: What exceptions cause rollback?
**Answer:** By default, RuntimeException and Error rollback. Checked exceptions commit. Use rollbackFor to change.

### Q7: What is readOnly transaction?
**Answer:** Optimization for read operations. Skips flush, dirty checking. Database can optimize with replicas.

### Q8: What is transaction timeout?
**Answer:** Maximum time (in seconds) for transaction execution. Rolls back if exceeded.

### Q9: Why doesn't @Transactional work on private methods?
**Answer:** Spring uses proxies for @Transactional. Proxies intercept public methods only.

### Q10: What is @TransactionalEventListener?
**Answer:** Listens to transaction lifecycle events (BEFORE_COMMIT, AFTER_COMMIT, AFTER_ROLLBACK, AFTER_COMPLETION).

---

## üìö Summary

### Key Concepts
- **@Transactional**: Transaction management
- **Propagation**: Transaction behavior (REQUIRED, REQUIRES_NEW, etc.)
- **Isolation**: Data visibility (READ_COMMITTED, REPEATABLE_READ, etc.)
- **Rollback**: Exception handling (rollbackFor, noRollbackFor)
- **Read-Only**: Query optimization
- **Timeout**: Maximum execution time

### Propagation Levels
1. **REQUIRED** (default): Join or create
2. **REQUIRES_NEW**: Always new
3. **MANDATORY**: Must exist
4. **SUPPORTS**: Optional
5. **NOT_SUPPORTED**: Never
6. **NEVER**: Forbidden
7. **NESTED**: Savepoint

### Complete Example

```java
@Service
@Transactional(readOnly = true)
public class OrderService {
    
    private final OrderRepository orderRepository;
    private final AuditService auditService;
    
    // Read-only (inherited from class)
    public Order findById(Long id) {
        return orderRepository.findById(id).orElseThrow();
    }
    
    // Write operation
    @Transactional(
        rollbackFor = Exception.class,
        timeout = 10
    )
    public Order createOrder(OrderDto dto) throws OrderException {
        Order order = orderRepository.save(dto.toEntity());
        
        // Independent audit logging
        auditService.logOrder(order);
        
        return order;
    }
}

@Service
public class AuditService {
    
    // Always creates new transaction
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logOrder(Order order) {
        auditRepository.save(new AuditLog(order));
    }
}

@Component
class OrderEventListener {
    
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void onOrderCreated(OrderCreatedEvent event) {
        emailService.sendConfirmation(event.getOrderId());
    }
}
```

**Next:** Conditional Annotations ‚Üí

