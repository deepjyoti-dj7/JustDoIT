# üè∑Ô∏è Core Spring Boot Annotations - Complete Guide

## üìã Table of Contents
- [@SpringBootApplication](#springbootapplication)
- [@Component](#component)
- [@Service](#service)
- [@Repository](#repository)
- [@Controller](#controller)
- [@RestController](#restcontroller)
- [Stereotype Annotations Comparison](#stereotype-annotations-comparison)
- [Component Scanning](#component-scanning)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üöÄ @SpringBootApplication

The **main annotation** that combines three essential annotations to bootstrap a Spring Boot application.

### Composition

```java
@SpringBootApplication = 
    @SpringBootConfiguration +
    @EnableAutoConfiguration +
    @ComponentScan
```

### Basic Usage

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Equivalent Explicit Configuration

```java
@SpringBootConfiguration  // Same as @Configuration
@EnableAutoConfiguration  // Auto-configure based on dependencies
@ComponentScan(basePackages = "com.example")  // Scan for components
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Customizing @SpringBootApplication

```java
@SpringBootApplication(
    scanBasePackages = {"com.example.app", "com.example.utils"},
    exclude = {DataSourceAutoConfiguration.class},
    excludeName = {"org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration"}
)
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Key Features

| Feature | Description |
|---------|-------------|
| **@SpringBootConfiguration** | Marks class as configuration source |
| **@EnableAutoConfiguration** | Auto-configures beans based on classpath |
| **@ComponentScan** | Scans for @Component, @Service, @Repository, @Controller |

### Example with Custom Configuration

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }
}
```

---

## üîß @Component

Generic stereotype annotation for **any Spring-managed component**.

### Basic Usage

```java
@Component
public class EmailValidator {
    public boolean isValid(String email) {
        return email != null && email.contains("@");
    }
}
```

### With Bean Name

```java
@Component("emailChecker")
public class EmailValidator {
    // Bean name: "emailChecker"
}

// Default bean name would be: "emailValidator"
```

### Use Cases

```java
// 1. Utility classes
@Component
public class StringUtils {
    public String capitalize(String str) {
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}

// 2. Helper classes
@Component
public class DateFormatter {
    public String format(LocalDateTime date) {
        return date.format(DateTimeFormatter.ISO_DATE_TIME);
    }
}

// 3. Generic components (when no specific stereotype fits)
@Component
public class ApplicationEventListener {
    @EventListener
    public void handleEvent(CustomEvent event) {
        // Process event
    }
}
```

### Scanning and Discovery

```java
// Spring scans for @Component
@SpringBootApplication
public class Application {
    // Automatically finds all @Component classes
}

// Explicit scanning
@Configuration
@ComponentScan(basePackages = "com.example.components")
public class AppConfig {
}
```

---

## üíº @Service

Stereotype annotation for **business logic layer** (service layer).

### Basic Usage

```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public User registerUser(UserDto userDto) {
        User user = new User();
        user.setUsername(userDto.getUsername());
        user.setEmail(userDto.getEmail());
        
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser.getEmail());
        
        return savedUser;
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

### Service Layer Patterns

```java
// 1. Transaction management
@Service
@Transactional
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;
    
    public Order createOrder(OrderDto orderDto) {
        Order order = new Order();
        order.setItems(orderDto.getItems());
        
        Order savedOrder = orderRepository.save(order);
        paymentService.processPayment(savedOrder);
        
        return savedOrder;  // Both operations in one transaction
    }
}

// 2. Business validation
@Service
public class ProductService {
    public Product createProduct(ProductDto dto) {
        validateProduct(dto);
        
        Product product = new Product();
        product.setName(dto.getName());
        product.setPrice(dto.getPrice());
        
        return productRepository.save(product);
    }
    
    private void validateProduct(ProductDto dto) {
        if (dto.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidProductException("Price must be positive");
        }
    }
}

// 3. Complex business logic
@Service
public class DiscountService {
    public BigDecimal calculateDiscount(User user, Order order) {
        BigDecimal discount = BigDecimal.ZERO;
        
        // VIP customers get 10% discount
        if (user.isVip()) {
            discount = discount.add(order.getTotal().multiply(new BigDecimal("0.10")));
        }
        
        // Orders over $100 get additional 5%
        if (order.getTotal().compareTo(new BigDecimal("100")) > 0) {
            discount = discount.add(order.getTotal().multiply(new BigDecimal("0.05")));
        }
        
        return discount;
    }
}
```

### Why @Service vs @Component?

```java
// Semantically indicates business logic
@Service  // Clear intent: This is a service layer component
public class PaymentService { }

// Generic component
@Component  // Less clear: What does this do?
public class PaymentService { }
```

**Benefits:**
- ‚úÖ Clear architectural intent
- ‚úÖ Better code organization
- ‚úÖ Easier to understand codebase
- ‚úÖ Future-proof for AOP (can target @Service specifically)

---

## üóÑÔ∏è @Repository

Stereotype annotation for **data access layer** (persistence layer).

### Basic Usage

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    List<User> findByEmailContaining(String email);
    
    @Query("SELECT u FROM User u WHERE u.active = true")
    List<User> findActiveUsers();
}
```

### Custom Repository Implementation

```java
@Repository
public class CustomUserRepository {
    private final EntityManager entityManager;
    
    public CustomUserRepository(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
    
    public List<User> findUsersByComplexCriteria(String name, Integer age) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> user = query.from(User.class);
        
        List<Predicate> predicates = new ArrayList<>();
        if (name != null) {
            predicates.add(cb.like(user.get("name"), "%" + name + "%"));
        }
        if (age != null) {
            predicates.add(cb.equal(user.get("age"), age));
        }
        
        query.where(predicates.toArray(new Predicate[0]));
        return entityManager.createQuery(query).getResultList();
    }
}
```

### Exception Translation

**Key Feature:** @Repository automatically translates persistence exceptions to Spring's DataAccessException hierarchy.

```java
@Repository
public class JdbcUserRepository {
    private final JdbcTemplate jdbcTemplate;
    
    public JdbcUserRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public User findById(Long id) {
        try {
            return jdbcTemplate.queryForObject(
                "SELECT * FROM users WHERE id = ?",
                new BeanPropertyRowMapper<>(User.class),
                id
            );
        } catch (EmptyResultDataAccessException e) {
            // Spring's exception (translated from JDBC SQLException)
            return null;
        }
    }
}

// Without @Repository, you'd get raw SQLExceptions
// With @Repository, you get Spring's DataAccessException
```

### Repository Patterns

```java
// 1. Simple CRUD
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
}

// 2. Custom queries
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("SELECT o FROM Order o WHERE o.user.id = :userId AND o.status = :status")
    List<Order> findUserOrdersByStatus(@Param("userId") Long userId, 
                                       @Param("status") OrderStatus status);
}

// 3. Native queries
@Repository
public interface ReportRepository extends JpaRepository<Report, Long> {
    @Query(value = "SELECT * FROM reports WHERE created_at > :date", nativeQuery = true)
    List<Report> findRecentReports(@Param("date") LocalDateTime date);
}

// 4. Specifications
@Repository
public interface UserRepository extends JpaRepository<User, Long>, 
                                       JpaSpecificationExecutor<User> {
    // Can use Specifications for dynamic queries
}
```

---

## üåê @Controller

Stereotype annotation for **MVC controllers** (web layer).

### Basic Usage

```java
@Controller
public class UserController {
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/users")
    public String listUsers(Model model) {
        List<User> users = userService.getAllUsers();
        model.addAttribute("users", users);
        return "users/list";  // Returns view name
    }
    
    @GetMapping("/users/{id}")
    public String viewUser(@PathVariable Long id, Model model) {
        User user = userService.getUser(id);
        model.addAttribute("user", user);
        return "users/view";
    }
    
    @PostMapping("/users")
    public String createUser(@ModelAttribute UserDto userDto) {
        userService.createUser(userDto);
        return "redirect:/users";
    }
}
```

### Form Handling

```java
@Controller
@RequestMapping("/products")
public class ProductController {
    private final ProductService productService;
    
    public ProductController(ProductService productService) {
        this.productService = productService;
    }
    
    @GetMapping("/new")
    public String showCreateForm(Model model) {
        model.addAttribute("product", new ProductDto());
        return "products/form";
    }
    
    @PostMapping
    public String createProduct(@Valid @ModelAttribute ProductDto productDto,
                               BindingResult result,
                               Model model) {
        if (result.hasErrors()) {
            return "products/form";
        }
        
        productService.createProduct(productDto);
        return "redirect:/products";
    }
    
    @GetMapping("/{id}/edit")
    public String showEditForm(@PathVariable Long id, Model model) {
        Product product = productService.getProduct(id);
        model.addAttribute("product", product);
        return "products/form";
    }
}
```

### @Controller vs @RestController

```java
// @Controller - Returns views (HTML)
@Controller
public class WebController {
    @GetMapping("/home")
    public String home() {
        return "home";  // Returns view name
    }
}

// @RestController - Returns data (JSON/XML)
@RestController
public class ApiController {
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.findAll();  // Returns JSON
    }
}
```

---

## üîÑ @RestController

Combination of **@Controller + @ResponseBody** for building RESTful APIs.

### Composition

```java
@RestController = @Controller + @ResponseBody
```

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserRestController {
    private final UserService userService;
    
    public UserRestController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.getAllUsers();  // Automatically converted to JSON
    }
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
    
    @PostMapping
    public User createUser(@RequestBody UserDto userDto) {
        return userService.createUser(userDto);
    }
    
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UserDto userDto) {
        return userService.updateUser(id, userDto);
    }
    
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
    }
}
```

### ResponseEntity for Fine Control

```java
@RestController
@RequestMapping("/api/products")
public class ProductRestController {
    private final ProductService productService;
    
    public ProductRestController(ProductService productService) {
        this.productService = productService;
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable Long id) {
        return productService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public ResponseEntity<Product> createProduct(@Valid @RequestBody ProductDto dto) {
        Product product = productService.createProduct(dto);
        return ResponseEntity
            .created(URI.create("/api/products/" + product.getId()))
            .body(product);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build();
    }
}
```

### Exception Handling

```java
@RestController
@RequestMapping("/api/orders")
public class OrderRestController {
    private final OrderService orderService;
    
    @GetMapping("/{id}")
    public Order getOrder(@PathVariable Long id) {
        return orderService.findById(id)
            .orElseThrow(() -> new OrderNotFoundException(id));
    }
    
    @ExceptionHandler(OrderNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(OrderNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
}
```

---

## üìä Stereotype Annotations Comparison

### Hierarchy

```
@Component (Generic)
    ‚îú‚îÄ‚îÄ @Service (Business Logic)
    ‚îú‚îÄ‚îÄ @Repository (Data Access)
    ‚îî‚îÄ‚îÄ @Controller (Web Layer)
            ‚îî‚îÄ‚îÄ @RestController (@Controller + @ResponseBody)
```

### Comparison Table

| Annotation | Layer | Purpose | Exception Translation | Response Type |
|------------|-------|---------|----------------------|---------------|
| **@Component** | Any | Generic component | No | N/A |
| **@Service** | Business | Business logic | No | N/A |
| **@Repository** | Persistence | Data access | **Yes** | N/A |
| **@Controller** | Web | MVC controller | No | View name |
| **@RestController** | Web | REST API | No | JSON/XML |

### When to Use Each

```java
// @Component - Generic utilities
@Component
public class FileUploader {
    public void upload(MultipartFile file) { }
}

// @Service - Business logic
@Service
public class OrderProcessingService {
    public Order processOrder(OrderDto dto) { }
}

// @Repository - Database operations
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
}

// @Controller - Web pages (returns views)
@Controller
public class HomeController {
    @GetMapping("/")
    public String home() {
        return "index";  // HTML view
    }
}

// @RestController - REST APIs (returns data)
@RestController
public class ApiController {
    @GetMapping("/api/data")
    public Data getData() {
        return data;  // JSON
    }
}
```

### Functional Differences

```java
// 1. @Repository - Exception translation
@Repository
public class UserRepositoryImpl {
    public User save(User user) {
        // SQLException ‚Üí DataAccessException
    }
}

// 2. @Controller - View resolution
@Controller
public class WebController {
    @GetMapping("/page")
    public String page() {
        return "view";  // Resolved to view
    }
}

// 3. @RestController - Automatic @ResponseBody
@RestController
public class ApiController {
    @GetMapping("/data")
    public Data data() {
        return new Data();  // Automatic JSON conversion
    }
}
```

---

## üîç Component Scanning

### Default Scanning

```java
@SpringBootApplication  // Scans current package and sub-packages
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// Scans:
// com.example.app.*
// com.example.app.service.*
// com.example.app.repository.*
// etc.
```

### Custom Base Packages

```java
@SpringBootApplication(scanBasePackages = {
    "com.example.app",
    "com.example.shared",
    "com.example.utils"
})
public class Application {
}
```

### Type-Safe Scanning

```java
@SpringBootApplication(scanBasePackageClasses = {
    UserService.class,
    ProductService.class
})
public class Application {
    // Scans packages containing these classes
}
```

### Include/Exclude Filters

```java
@SpringBootApplication
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*Service"
    ),
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*Test.*"
    )
)
public class Application {
}
```

---

## üìå Best Practices

### 1. Use Appropriate Stereotype

```java
// ‚úÖ Correct - semantic meaning
@Service
public class OrderService { }

@Repository
public interface OrderRepository { }

@RestController
public class OrderApiController { }

// ‚ùå Avoid - all work but less clear
@Component
public class OrderService { }

@Component
public interface OrderRepository { }

@Component
public class OrderApiController { }
```

### 2. Constructor Injection with Stereotypes

```java
// ‚úÖ Best practice
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
}
```

### 3. Single Responsibility

```java
// ‚úÖ Good - focused service
@Service
public class UserRegistrationService {
    public User register(UserDto dto) { }
}

// ‚ùå Bad - too many responsibilities
@Service
public class UserEverythingService {
    public User register(UserDto dto) { }
    public void sendEmail(String email) { }
    public void generateReport() { }
    public void processPayment() { }
}
```

### 4. Package Organization

```
com.example.app/
‚îú‚îÄ‚îÄ Application.java (@SpringBootApplication)
‚îú‚îÄ‚îÄ controller/ (@Controller, @RestController)
‚îú‚îÄ‚îÄ service/ (@Service)
‚îú‚îÄ‚îÄ repository/ (@Repository)
‚îî‚îÄ‚îÄ component/ (@Component)
```

### 5. Avoid Circular Dependencies

```java
// ‚ùå Circular dependency
@Service
public class ServiceA {
    public ServiceA(ServiceB serviceB) { }
}

@Service
public class ServiceB {
    public ServiceB(ServiceA serviceA) { }
}

// ‚úÖ Extract common logic
@Service
public class CommonService { }

@Service
public class ServiceA {
    public ServiceA(CommonService common) { }
}
```

---

## üé§ Interview Questions

### Q1: What is @SpringBootApplication?
**Answer:** Combination of @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan. Bootstraps a Spring Boot application with auto-configuration and component scanning.

### Q2: Difference between @Component, @Service, @Repository?
**Answer:**
- **@Component**: Generic stereotype for any component
- **@Service**: Business logic layer (semantic)
- **@Repository**: Data access layer (semantic + exception translation)

All are functionally similar but have semantic differences.

### Q3: What is exception translation in @Repository?
**Answer:** @Repository automatically translates persistence exceptions (like SQLException) to Spring's DataAccessException hierarchy, providing consistent exception handling.

### Q4: @Controller vs @RestController?
**Answer:**
- **@Controller**: Returns view names (HTML pages)
- **@RestController**: Returns data (JSON/XML) - combines @Controller + @ResponseBody

### Q5: Can you use @Service instead of @Component?
**Answer:** Yes, @Service is a specialization of @Component. Functionally identical but @Service clearly indicates business logic layer.

### Q6: How does component scanning work?
**Answer:** Spring scans specified packages for classes annotated with @Component (and specializations like @Service, @Repository, @Controller), then registers them as beans in the application context.

### Q7: What is @SpringBootConfiguration?
**Answer:** Equivalent to @Configuration. Indicates that a class provides bean definitions. Used in @SpringBootApplication.

### Q8: Can you have multiple @SpringBootApplication classes?
**Answer:** Yes, but only one should be used as the main entry point. Multiple are useful for testing or modular applications.

### Q9: What does @EnableAutoConfiguration do?
**Answer:** Automatically configures Spring beans based on classpath dependencies. For example, if H2 is on classpath, it auto-configures DataSource.

### Q10: How to exclude auto-configuration?
**Answer:**
```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class
})
```

---

## üìö Summary

### Core Annotations
- **@SpringBootApplication**: Main entry point (combines 3 annotations)
- **@Component**: Generic component
- **@Service**: Business logic layer
- **@Repository**: Data access layer (+ exception translation)
- **@Controller**: MVC web layer (returns views)
- **@RestController**: REST API layer (returns data)

### Key Takeaways
1. Use **appropriate stereotype** for clarity
2. **@Repository** provides exception translation
3. **@RestController** = @Controller + @ResponseBody
4. **Component scanning** finds and registers beans
5. Organize by **layers**: controller, service, repository

### Best Practice
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
class UserController {
    private final UserService userService;
}

@Service
@RequiredArgsConstructor
class UserService {
    private final UserRepository userRepository;
}

@Repository
interface UserRepository extends JpaRepository<User, Long> {
}
```

**Next:** Configuration Annotations ‚Üí

