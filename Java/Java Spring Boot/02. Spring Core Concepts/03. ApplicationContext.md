# üì¶ ApplicationContext in Spring

## üìã Table of Contents
- [What is ApplicationContext?](#what-is-applicationcontext)
- [ApplicationContext vs BeanFactory](#applicationcontext-vs-beanfactory)
- [Types of ApplicationContext](#types-of-applicationcontext)
- [Features & Capabilities](#features--capabilities)
- [Creating ApplicationContext](#creating-applicationcontext)
- [Working with ApplicationContext](#working-with-applicationcontext)
- [ApplicationContext Events](#applicationcontext-events)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is ApplicationContext?

### Definition
**ApplicationContext** is the central interface for providing configuration information to a Spring application. It's an advanced Spring container that extends BeanFactory with enterprise-specific functionality.

### Key Characteristics
```
‚úÖ Bean lifecycle management
‚úÖ Automatic BeanPostProcessor registration
‚úÖ Event publication mechanism
‚úÖ Internationalization (i18n) support
‚úÖ Resource loading capabilities
‚úÖ Application-layer specific contexts (WebApplicationContext)
‚úÖ Built-in environment abstraction
```

### Container Hierarchy

```
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ BeanFactory ‚îÇ  (Basic container)
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇApplicationContext  ‚îÇ  (Advanced container)
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ             ‚îÇ
        ‚ñº             ‚ñº
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇConfigurableWeb‚îÇ  ‚îÇStandalone   ‚îÇ
 ‚îÇApplicationContext‚îÇ ‚îÇContext      ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚öñÔ∏è ApplicationContext vs BeanFactory

### Comparison Table

| Feature | BeanFactory | ApplicationContext |
|---------|-------------|-------------------|
| **Bean Instantiation** | Lazy (on-demand) | Eager (at startup) |
| **BeanPostProcessor** | Manual registration | Automatic registration |
| **Event Publishing** | ‚ùå Not supported | ‚úÖ Supported |
| **Internationalization** | ‚ùå Not supported | ‚úÖ Supported (MessageSource) |
| **AOP** | Manual setup | Automatic proxy creation |
| **Resource Loading** | ‚ùå Not supported | ‚úÖ Supported (ResourceLoader) |
| **Environment** | ‚ùå Not supported | ‚úÖ Supported |
| **Use Case** | Lightweight apps, IoT | Enterprise applications |
| **Memory** | Lower footprint | Higher footprint |

### Code Comparison

```java
// BeanFactory - Basic container
BeanFactory factory = new XmlBeanFactory(
    new ClassPathResource("beans.xml")
);
UserService service = (UserService) factory.getBean("userService");

// ApplicationContext - Advanced container (PREFERRED)
ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
UserService service = context.getBean(UserService.class); // Type-safe
```

### When to Use What?

```
‚úÖ Use ApplicationContext:
   - Enterprise applications
   - Web applications
   - Need AOP, events, i18n
   - Spring Boot (default)

‚ö†Ô∏è Use BeanFactory:
   - Resource-constrained environments (IoT, mobile)
   - Legacy applications
   - Minimal overhead required
```

---

## üèóÔ∏è Types of ApplicationContext

### 1. **AnnotationConfigApplicationContext**

For Java-based configuration.

```java
// Configuration class
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    
    @Bean
    public UserService userService() {
        return new UserServiceImpl();
    }
}

// Usage
public class Application {
    public static void main(String[] args) {
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        UserService service = context.getBean(UserService.class);
        service.doWork();
        
        ((ConfigurableApplicationContext) context).close();
    }
}
```

**Multiple Configuration Classes:**
```java
ApplicationContext context = new AnnotationConfigApplicationContext(
    AppConfig.class,
    DataConfig.class,
    SecurityConfig.class
);
```

**Register and Refresh:**
```java
AnnotationConfigApplicationContext context = 
    new AnnotationConfigApplicationContext();
context.register(AppConfig.class);
context.scan("com.example.services");
context.refresh(); // Trigger bean initialization
```

### 2. **ClassPathXmlApplicationContext**

For XML-based configuration.

```java
// beans.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    <bean id="userService" class="com.example.UserServiceImpl">
        <property name="repository" ref="userRepository"/>
    </bean>
    
    <bean id="userRepository" class="com.example.UserRepositoryImpl"/>
</beans>

// Usage
ApplicationContext context = 
    new ClassPathXmlApplicationContext("beans.xml");
```

**Multiple XML Files:**
```java
ApplicationContext context = new ClassPathXmlApplicationContext(
    "classpath:app-config.xml",
    "classpath:data-config.xml",
    "classpath:security-config.xml"
);
```

### 3. **FileSystemXmlApplicationContext**

Load configuration from file system path.

```java
ApplicationContext context = new FileSystemXmlApplicationContext(
    "/path/to/config/beans.xml"
);

// Relative path
ApplicationContext context = new FileSystemXmlApplicationContext(
    "file:./config/beans.xml"
);
```

### 4. **WebApplicationContext**

For Spring MVC web applications.

```java
// In web.xml or ServletInitializer
public class WebAppInitializer implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext container) {
        AnnotationConfigWebApplicationContext context = 
            new AnnotationConfigWebApplicationContext();
        context.register(WebConfig.class);
        context.setServletContext(container);
        
        ServletRegistration.Dynamic servlet = 
            container.addServlet("dispatcher", new DispatcherServlet(context));
        servlet.setLoadOnStartup(1);
        servlet.addMapping("/");
    }
}

// Accessing in Controller
@RestController
public class UserController {
    
    @Autowired
    private WebApplicationContext webContext;
    
    @GetMapping("/context-info")
    public String getContextInfo() {
        ServletContext servletContext = webContext.getServletContext();
        return "Servlet context path: " + servletContext.getContextPath();
    }
}
```

### 5. **AnnotationConfigWebApplicationContext**

Combines annotation config with web support.

```java
@Configuration
@EnableWebMvc
@ComponentScan("com.example.web")
public class WebConfig {
    
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = 
            new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}
```

### 6. **GenericApplicationContext**

Generic, flexible context for custom scenarios.

```java
GenericApplicationContext context = new GenericApplicationContext();

// Register beans programmatically
context.registerBean(UserService.class);
context.registerBean("customBean", CustomService.class, 
    () -> new CustomService("custom"));

context.refresh();
```

### 7. **Spring Boot: SpringApplication**

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        // SpringApplication creates AnnotationConfigApplicationContext
        ApplicationContext context = 
            SpringApplication.run(Application.class, args);
        
        UserService service = context.getBean(UserService.class);
    }
}
```

---

## ‚öôÔ∏è Features & Capabilities

### 1. **Bean Management**

```java
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// Get bean by name
UserService service1 = (UserService) context.getBean("userService");

// Get bean by type (preferred)
UserService service2 = context.getBean(UserService.class);

// Get bean by name and type
UserService service3 = context.getBean("userService", UserService.class);

// Check if bean exists
boolean exists = context.containsBean("userService");

// Get all bean names
String[] allBeans = context.getBeanDefinitionNames();

// Get beans of specific type
Map<String, UserService> services = 
    context.getBeansOfType(UserService.class);

// Get beans with specific annotation
Map<String, Object> components = 
    context.getBeansWithAnnotation(Component.class);
```

### 2. **Event Publication**

```java
// Custom event
public class UserCreatedEvent extends ApplicationEvent {
    private final String username;
    
    public UserCreatedEvent(Object source, String username) {
        super(source);
        this.username = username;
    }
    
    public String getUsername() {
        return username;
    }
}

// Event publisher
@Service
public class UserService {
    
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void createUser(String username) {
        // Create user logic
        
        // Publish event
        publisher.publishEvent(new UserCreatedEvent(this, username));
    }
}

// Event listener
@Component
public class UserEventListener {
    
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        System.out.println("User created: " + event.getUsername());
        // Send welcome email
        // Log analytics
    }
    
    // Async event handling
    @EventListener
    @Async
    public void handleAsyncUserCreated(UserCreatedEvent event) {
        // Non-blocking processing
    }
}
```

### 3. **Internationalization (i18n)**

```properties
# messages.properties
greeting=Hello
welcome=Welcome, {0}!

# messages_es.properties
greeting=Hola
welcome=¬°Bienvenido, {0}!
```

```java
@Configuration
public class I18nConfig {
    
    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource source = 
            new ResourceBundleMessageSource();
        source.setBasename("messages");
        source.setDefaultEncoding("UTF-8");
        return source;
    }
}

@Service
public class GreetingService {
    
    @Autowired
    private MessageSource messageSource;
    
    public String getGreeting(String name, Locale locale) {
        return messageSource.getMessage(
            "welcome", 
            new Object[]{name}, 
            locale
        );
    }
}

// Usage
String greeting = greetingService.getGreeting("John", Locale.ENGLISH);
// Output: "Welcome, John!"

String greetingEs = greetingService.getGreeting("Juan", new Locale("es"));
// Output: "¬°Bienvenido, Juan!"
```

### 4. **Resource Loading**

```java
@Service
public class ResourceService {
    
    @Autowired
    private ApplicationContext context;
    
    public void loadResources() throws IOException {
        // Load from classpath
        Resource resource1 = context.getResource("classpath:config.properties");
        
        // Load from file system
        Resource resource2 = context.getResource("file:/path/to/file.txt");
        
        // Load from URL
        Resource resource3 = context.getResource("https://example.com/data.json");
        
        // Multiple resources with wildcards
        Resource[] resources = context.getResources("classpath*:/*.xml");
        
        // Read resource
        try (InputStream is = resource1.getInputStream()) {
            Properties props = new Properties();
            props.load(is);
        }
    }
}
```

### 5. **Environment Abstraction**

```java
@Component
public class EnvironmentService {
    
    @Autowired
    private Environment environment;
    
    @PostConstruct
    public void printEnvironmentInfo() {
        // Get active profiles
        String[] profiles = environment.getActiveProfiles();
        System.out.println("Active profiles: " + Arrays.toString(profiles));
        
        // Get default profiles
        String[] defaultProfiles = environment.getDefaultProfiles();
        
        // Get properties
        String dbUrl = environment.getProperty("spring.datasource.url");
        Integer port = environment.getProperty("server.port", Integer.class, 8080);
        
        // Check if profile is active
        boolean isDev = environment.acceptsProfiles(Profiles.of("dev"));
        
        // Get required property (throws if missing)
        String apiKey = environment.getRequiredProperty("api.key");
    }
}
```

### 6. **Application Startup/Shutdown Hooks**

```java
@Component
public class LifecycleBean implements ApplicationListener<ContextRefreshedEvent> {
    
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        System.out.println("ApplicationContext started/refreshed");
    }
}

@Component
public class ShutdownBean implements ApplicationListener<ContextClosedEvent> {
    
    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        System.out.println("ApplicationContext is shutting down");
    }
}

// Or use @EventListener
@Component
public class StartupListener {
    
    @EventListener(ContextRefreshedEvent.class)
    public void onStartup() {
        System.out.println("Application started");
    }
    
    @EventListener(ContextClosedEvent.class)
    public void onShutdown() {
        System.out.println("Application stopping");
    }
}
```

---

## üöÄ Creating ApplicationContext

### Standalone Application

```java
public class StandaloneApp {
    public static void main(String[] args) {
        // Create context
        ApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        // Use beans
        UserService service = context.getBean(UserService.class);
        service.processUsers();
        
        // Close context (important!)
        ((ConfigurableApplicationContext) context).close();
    }
}
```

### With Try-With-Resources

```java
public class CleanApp {
    public static void main(String[] args) {
        try (AnnotationConfigApplicationContext context = 
                new AnnotationConfigApplicationContext(AppConfig.class)) {
            
            UserService service = context.getBean(UserService.class);
            service.processUsers();
            
            // Context automatically closed
        }
    }
}
```

### Spring Boot Application

```java
@SpringBootApplication
public class BootApp {
    public static void main(String[] args) {
        // Returns ConfigurableApplicationContext
        ConfigurableApplicationContext context = 
            SpringApplication.run(BootApp.class, args);
        
        // Access context if needed
        String[] beanNames = context.getBeanDefinitionNames();
    }
}
```

---

## üîß Working with ApplicationContext

### Programmatic Bean Registration

```java
public class DynamicBeanRegistration {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext();
        
        // Register configuration classes
        context.register(AppConfig.class);
        
        // Register individual beans
        context.registerBean(UserService.class);
        context.registerBean("customService", CustomService.class,
            () -> new CustomService("dynamic"));
        
        // Scan packages
        context.scan("com.example.services");
        
        // Refresh to initialize beans
        context.refresh();
        
        // Use beans
        UserService service = context.getBean(UserService.class);
        
        context.close();
    }
}
```

### Parent-Child Context Hierarchy

```java
// Parent context
AnnotationConfigApplicationContext parentContext = 
    new AnnotationConfigApplicationContext(ParentConfig.class);

// Child context
AnnotationConfigApplicationContext childContext = 
    new AnnotationConfigApplicationContext();
childContext.setParent(parentContext);
childContext.register(ChildConfig.class);
childContext.refresh();

// Child can access parent beans, but not vice versa
UserService service = childContext.getBean(UserService.class);

childContext.close();
parentContext.close();
```

### Accessing ApplicationContext in Beans

```java
// Method 1: Implement ApplicationContextAware
@Component
public class ContextAwareBean implements ApplicationContextAware {
    private ApplicationContext context;
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }
}

// Method 2: @Autowired (preferred)
@Component
public class MyBean {
    @Autowired
    private ApplicationContext context;
}

// Method 3: Constructor injection (best)
@Component
public class MyService {
    private final ApplicationContext context;
    
    public MyService(ApplicationContext context) {
        this.context = context;
    }
}
```

---

## üì° ApplicationContext Events

### Built-in Events

```java
@Component
public class ApplicationEventListener {
    
    // Application started/refreshed
    @EventListener
    public void onContextRefreshed(ContextRefreshedEvent event) {
        System.out.println("Context refreshed");
    }
    
    // Application started (Spring Boot)
    @EventListener
    public void onApplicationReady(ApplicationReadyEvent event) {
        System.out.println("Application is ready to serve requests");
    }
    
    // Application stopping
    @EventListener
    public void onContextClosing(ContextClosedEvent event) {
        System.out.println("Context closing");
    }
    
    // Request handled (web apps)
    @EventListener
    public void onRequestHandled(RequestHandledEvent event) {
        System.out.println("Request processed: " + event.getDescription());
    }
}
```

### Custom Events

```java
// Event
public class OrderPlacedEvent extends ApplicationEvent {
    private final String orderId;
    
    public OrderPlacedEvent(Object source, String orderId) {
        super(source);
        this.orderId = orderId;
    }
    
    public String getOrderId() { return orderId; }
}

// Publisher
@Service
public class OrderService {
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void placeOrder(String orderId) {
        // Business logic
        publisher.publishEvent(new OrderPlacedEvent(this, orderId));
    }
}

// Listener
@Component
public class OrderEventListener {
    
    @EventListener
    @Order(1) // Execution order
    public void handleOrderPlaced(OrderPlacedEvent event) {
        System.out.println("Order placed: " + event.getOrderId());
    }
    
    @EventListener
    @Async
    @Order(2)
    public void sendConfirmationEmail(OrderPlacedEvent event) {
        // Async email sending
    }
    
    // Conditional listening
    @EventListener(condition = "#event.orderId.startsWith('VIP')")
    public void handleVipOrder(OrderPlacedEvent event) {
        // Special handling for VIP orders
    }
}
```

---

## ‚úÖ Best Practices

### 1. **Use Type-Safe Bean Retrieval**

```java
// ‚ùå Avoid - requires casting, not type-safe
UserService service = (UserService) context.getBean("userService");

// ‚úÖ Good - type-safe
UserService service = context.getBean(UserService.class);

// ‚úÖ Also good - explicit name and type
UserService service = context.getBean("userService", UserService.class);
```

### 2. **Always Close Standalone Contexts**

```java
// ‚ùå Bad - resource leak
public void processData() {
    ApplicationContext context = 
        new AnnotationConfigApplicationContext(AppConfig.class);
    // ... use context ...
    // Forgot to close!
}

// ‚úÖ Good - try-with-resources
public void processData() {
    try (AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class)) {
        // ... use context ...
    } // Automatically closed
}
```

### 3. **Prefer Dependency Injection Over Context Lookup**

```java
// ‚ùå Avoid - service locator anti-pattern
@Service
public class OrderService {
    @Autowired
    private ApplicationContext context;
    
    public void processOrder() {
        PaymentService payment = context.getBean(PaymentService.class);
        payment.process();
    }
}

// ‚úÖ Good - proper dependency injection
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void processOrder() {
        paymentService.process();
    }
}
```

### 4. **Use Events for Loose Coupling**

```java
// ‚úÖ Good - decoupled using events
@Service
public class UserService {
    @Autowired
    private ApplicationEventPublisher publisher;
    
    public void registerUser(User user) {
        // Save user
        publisher.publishEvent(new UserRegisteredEvent(this, user));
        // No direct coupling to email, analytics, etc.
    }
}

@Component
public class EmailService {
    @EventListener
    public void sendWelcomeEmail(UserRegisteredEvent event) {
        // Send email
    }
}
```

### 5. **Use Profiles for Environment-Specific Contexts**

```java
@Configuration
@Profile("development")
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile("production")
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:postgresql://prod-db:5432/app");
        return ds;
    }
}
```

---

## üéì Interview Questions

### Q1: What is ApplicationContext?
**Answer:**
ApplicationContext is the central interface in Spring Framework that provides:
- Bean factory functionality (bean creation and management)
- Automatic BeanPostProcessor registration
- Event publication mechanism
- Internationalization support
- Resource loading capabilities
- Environment abstraction

It's a more feature-rich container than BeanFactory and is preferred for enterprise applications.

### Q2: Difference between BeanFactory and ApplicationContext?
**Answer:**
| Feature | BeanFactory | ApplicationContext |
|---------|-------------|-------------------|
| Bean loading | Lazy | Eager |
| BeanPostProcessor | Manual | Automatic |
| Events | No | Yes |
| i18n | No | Yes |
| AOP | Manual | Automatic |

**Example:**
```java
// BeanFactory - beans created on-demand
BeanFactory factory = new XmlBeanFactory(...);

// ApplicationContext - all singleton beans created at startup
ApplicationContext context = new ClassPathXmlApplicationContext(...);
```

### Q3: What are the different types of ApplicationContext?
**Answer:**
1. **AnnotationConfigApplicationContext** - Java-based configuration
2. **ClassPathXmlApplicationContext** - XML from classpath
3. **FileSystemXmlApplicationContext** - XML from file system
4. **WebApplicationContext** - Web applications
5. **AnnotationConfigWebApplicationContext** - Web with Java config
6. **GenericApplicationContext** - Programmatic bean registration

### Q4: How do you create ApplicationContext?
**Answer:**
```java
// Java config
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// XML config
ApplicationContext context = 
    new ClassPathXmlApplicationContext("beans.xml");

// Spring Boot
ConfigurableApplicationContext context = 
    SpringApplication.run(Application.class, args);
```

### Q5: What is the event mechanism in ApplicationContext?
**Answer:**
ApplicationContext provides event publication for loose coupling:

```java
// Publish event
publisher.publishEvent(new CustomEvent(this, data));

// Listen to event
@EventListener
public void handleEvent(CustomEvent event) {
    // Handle event
}
```

Built-in events: ContextRefreshedEvent, ContextClosedEvent, RequestHandledEvent

### Q6: How to access ApplicationContext in a Spring bean?
**Answer:**
Three ways:
```java
// 1. Implement ApplicationContextAware
public class MyBean implements ApplicationContextAware {
    public void setApplicationContext(ApplicationContext ctx) { }
}

// 2. @Autowired (preferred)
@Autowired
private ApplicationContext context;

// 3. Constructor injection (best)
public MyBean(ApplicationContext context) {
    this.context = context;
}
```

### Q7: What is the difference between ClassPathXmlApplicationContext and FileSystemXmlApplicationContext?
**Answer:**
- **ClassPathXmlApplicationContext**: Loads config from classpath
  ```java
  new ClassPathXmlApplicationContext("beans.xml");
  ```
- **FileSystemXmlApplicationContext**: Loads config from file system path
  ```java
  new FileSystemXmlApplicationContext("/path/to/beans.xml");
  ```

### Q8: Can you have multiple ApplicationContexts?
**Answer:**
Yes, you can have parent-child context hierarchy:
```java
// Parent context
ApplicationContext parent = new AnnotationConfigApplicationContext(ParentConfig.class);

// Child context
AnnotationConfigApplicationContext child = new AnnotationConfigApplicationContext();
child.setParent(parent);
child.refresh();

// Child can access parent beans, but not vice versa
```

Common in Spring MVC: root context (services) + servlet context (controllers).

### Q9: What is ConfigurableApplicationContext?
**Answer:**
ConfigurableApplicationContext extends ApplicationContext with lifecycle methods:
```java
ConfigurableApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

context.refresh(); // Initialize/refresh context
context.start();   // Start lifecycle processors
context.stop();    // Stop lifecycle processors
context.close();   // Shutdown context
```

### Q10: How does ApplicationContext support internationalization?
**Answer:**
Through MessageSource:
```java
@Bean
public MessageSource messageSource() {
    ResourceBundleMessageSource source = new ResourceBundleMessageSource();
    source.setBasename("messages");
    return source;
}

// Usage
String msg = messageSource.getMessage("welcome", 
    new Object[]{"John"}, Locale.ENGLISH);
```

---

## üìö Summary

ApplicationContext is the cornerstone of Spring applications:

1. **Advanced Container**: Extends BeanFactory with enterprise features
2. **Types**: Annotation, XML, Web, Generic contexts for different use cases
3. **Features**: Event publishing, i18n, resource loading, environment abstraction
4. **Lifecycle**: Eager initialization, automatic BeanPostProcessor registration
5. **Best Practices**: DI over lookup, always close standalone contexts, use events for loose coupling

---

**Next Topic:** [Bean Scopes ‚Üí](./04.%20Bean%20Scopes.md)
