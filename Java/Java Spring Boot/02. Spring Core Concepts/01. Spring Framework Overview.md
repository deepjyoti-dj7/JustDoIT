# ğŸŒ± Spring Framework Overview

## ğŸ“‹ Table of Contents
- [What is Spring Framework?](#what-is-spring-framework)
- [History & Evolution](#history--evolution)
- [Spring Ecosystem](#spring-ecosystem)
- [Core Architecture](#core-architecture)
- [Spring Modules](#spring-modules)
- [Core Principles](#core-principles)
- [Spring vs Java EE](#spring-vs-java-ee)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ What is Spring Framework?

### Definition
Spring is an **open-source application framework** for building enterprise Java applications. It provides comprehensive infrastructure support, allowing developers to focus on business logic rather than boilerplate code.

### Key Characteristics
```
âœ… Lightweight & Non-invasive
âœ… Dependency Injection Container
âœ… Aspect-Oriented Programming
âœ… Transaction Management
âœ… Data Access Abstraction
âœ… MVC Web Framework
âœ… Testability Support
```

### Philosophy
**"Spring makes Java simple, modern, and productive"**

---

## ğŸ“œ History & Evolution

### Timeline
```
2002 - Rod Johnson publishes "Expert One-on-One J2EE Design and Development"
2003 - Spring Framework 0.9 released
2004 - Spring 1.0 released (XML configuration)
2006 - Spring 2.0 (namespace support)
2009 - Spring 3.0 (Java-based configuration, REST)
2013 - Spring 4.0 (Java 8, WebSocket)
2014 - Spring Boot 1.0 released
2017 - Spring 5.0 (Reactive programming)
2020 - Spring 5.3 (Java 17 support)
2022 - Spring 6.0 & Spring Boot 3.0 (Jakarta EE, Java 17 baseline)
```

### Evolution Highlights
| Version | Year | Key Features |
|---------|------|--------------|
| Spring 1.x | 2004 | IoC, AOP, JDBC abstraction |
| Spring 2.x | 2006 | XML namespaces, @AspectJ |
| Spring 3.x | 2009 | Java Config, REST, SpEL |
| Spring 4.x | 2013 | Java 8, WebSocket, @Conditional |
| Spring 5.x | 2017 | Reactive, Kotlin, JUnit 5 |
| Spring 6.x | 2022 | Jakarta EE, Native compilation |

---

## ğŸŒ Spring Ecosystem

### The Spring Portfolio

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SPRING ECOSYSTEM                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Spring Boot  â”‚  â”‚ Spring Cloud â”‚  â”‚ Spring Data  â”‚  â”‚
â”‚  â”‚ Auto-config  â”‚  â”‚ Microservicesâ”‚  â”‚ Data Access  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Spring Securityâ”‚ â”‚ Spring Batch â”‚  â”‚Spring Integrationâ”‚
â”‚  â”‚ Auth & AuthZ â”‚  â”‚ Batch Processâ”‚  â”‚ EIP Patterns â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Spring MVC  â”‚  â”‚ Spring WebFluxâ”‚ â”‚ Spring AMQP  â”‚  â”‚
â”‚  â”‚  Web Apps    â”‚  â”‚ Reactive Web â”‚  â”‚  Messaging   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                           â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚         â”‚    SPRING FRAMEWORK (CORE)       â”‚            â”‚
â”‚         â”‚   IoC, AOP, Data Access, MVC     â”‚            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Major Projects

#### 1. **Spring Framework** (Core)
```java
// The foundation - IoC, AOP, Data Access
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserServiceImpl();
    }
}
```

#### 2. **Spring Boot**
```java
// Rapid application development with auto-configuration
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

#### 3. **Spring Data**
```java
// Simplified data access
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByLastName(String lastName);
}
```

#### 4. **Spring Cloud**
```java
// Microservices patterns
@EnableEurekaServer
@SpringBootApplication
public class DiscoveryServerApplication { }
```

#### 5. **Spring Security**
```java
// Authentication & Authorization
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // Security configuration
}
```

#### 6. **Spring Batch**
```java
// Batch processing
@EnableBatchProcessing
@Configuration
public class BatchConfiguration {
    @Bean
    public Job importUserJob() { }
}
```

---

## ğŸ—ï¸ Core Architecture

### Layered Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              APPLICATION LAYER                    â”‚
â”‚         (Business Logic & Services)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              SPRING CONTAINER                     â”‚
â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Core      â”‚  â”‚   AOP       â”‚  â”‚  Data    â”‚ â”‚
â”‚  â”‚ (IoC, DI)   â”‚  â”‚ (Aspects)   â”‚  â”‚ (Access) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    Web      â”‚  â”‚Integration  â”‚  â”‚  Test    â”‚ â”‚
â”‚  â”‚  (MVC)      â”‚  â”‚ (Messaging) â”‚  â”‚(Support) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚              JVM & INFRASTRUCTURE                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Spring Container Workflow

```
1. Read Configuration
   â”œâ”€ XML files
   â”œâ”€ Java @Configuration classes
   â””â”€ Component scanning

2. Create Bean Definitions
   â””â”€ Parse metadata into BeanDefinition objects

3. Instantiate Beans
   â”œâ”€ Constructor injection
   â”œâ”€ Setter injection
   â””â”€ Field injection

4. Populate Bean Properties
   â””â”€ Resolve dependencies

5. Apply BeanPostProcessors
   â”œâ”€ Before initialization
   â””â”€ After initialization

6. Ready for Use
   â””â”€ Beans available in ApplicationContext

7. Destruction
   â””â”€ Call @PreDestroy methods
```

---

## ğŸ“¦ Spring Modules

### Core Container Modules

#### 1. **spring-core**
```java
// Fundamental utilities and core abstractions
// - IoC Container
// - Type conversion
// - Resource loading
```

#### 2. **spring-beans**
```java
// Bean factory and bean wiring
@Component
public class UserService {
    @Autowired
    private UserRepository repository;
}
```

#### 3. **spring-context**
```java
// ApplicationContext, events, i18n
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);
UserService service = context.getBean(UserService.class);
```

#### 4. **spring-expression (SpEL)**
```java
// Spring Expression Language
@Value("#{systemProperties['user.name']}")
private String userName;
```

### Data Access Modules

#### 5. **spring-jdbc**
```java
// JDBC abstraction
@Repository
public class UserDao {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public List<User> findAll() {
        return jdbcTemplate.query(
            "SELECT * FROM users",
            new UserRowMapper()
        );
    }
}
```

#### 6. **spring-tx**
```java
// Transaction management
@Transactional
public void transferMoney(Account from, Account to, BigDecimal amount) {
    from.debit(amount);
    to.credit(amount);
}
```

#### 7. **spring-orm**
```java
// Integration with JPA, Hibernate
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}
```

### Web Modules

#### 8. **spring-web**
```java
// Web utilities, HTTP clients
RestTemplate restTemplate = new RestTemplate();
User user = restTemplate.getForObject(url, User.class);
```

#### 9. **spring-webmvc**
```java
// MVC framework
@RestController
@RequestMapping("/api/users")
public class UserController {
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

#### 10. **spring-webflux**
```java
// Reactive web framework
@RestController
public class ReactiveController {
    @GetMapping("/users")
    public Flux<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

### AOP Module

#### 11. **spring-aop**
```java
// Aspect-Oriented Programming
@Aspect
@Component
public class LoggingAspect {
    @Around("@annotation(Loggable)")
    public Object logExecution(ProceedingJoinPoint joinPoint) {
        // Logging logic
    }
}
```

### Test Module

#### 12. **spring-test**
```java
// Testing support
@SpringBootTest
@AutoConfigureMockMvc
public class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testGetUser() throws Exception {
        mockMvc.perform(get("/api/users/1"))
               .andExpect(status().isOk());
    }
}
```

---

## ğŸ’¡ Core Principles

### 1. **Inversion of Control (IoC)**

#### Traditional Approach
```java
// Tight coupling - class creates its own dependencies
public class UserService {
    private UserRepository repository = new UserRepositoryImpl();
    
    public User findUser(Long id) {
        return repository.findById(id);
    }
}
```

#### Spring Approach
```java
// IoC - dependencies injected by container
@Service
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

**Benefits:**
- âœ… Loose coupling
- âœ… Easy testing (mock injection)
- âœ… Flexibility (swap implementations)

### 2. **Dependency Injection (DI)**

Three types of DI:

```java
// 1. Constructor Injection (Recommended)
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// 2. Setter Injection
@Service
public class OrderService {
    private PaymentService paymentService;
    
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// 3. Field Injection (Not recommended)
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
}
```

### 3. **Aspect-Oriented Programming (AOP)**

```java
// Cross-cutting concerns separated from business logic
@Aspect
@Component
public class SecurityAspect {
    
    @Before("@annotation(Secured)")
    public void checkSecurity(JoinPoint joinPoint) {
        // Security check before method execution
    }
}

@Service
public class BankService {
    
    @Secured
    @Transactional
    public void transferFunds(Account from, Account to, BigDecimal amount) {
        // Business logic - clean and focused
    }
}
```

### 4. **POJO-Based Development**

```java
// No need to extend framework classes
// Plain Old Java Objects
public class User {
    private String name;
    private String email;
    
    // Just POJOs with annotations
}
```

### 5. **Convention Over Configuration**

```java
// Sensible defaults reduce configuration
@SpringBootApplication
public class Application {
    // No XML, minimal configuration needed
}
```

---

## âš–ï¸ Spring vs Java EE

### Comparison Table

| Aspect | Spring Framework | Java EE |
|--------|------------------|---------|
| **Container** | Lightweight IoC container | Heavy application server required |
| **Configuration** | Annotations, Java Config | XML descriptors, annotations |
| **Deployment** | Embedded servers (Tomcat, Jetty) | Application servers (WildFly, WebLogic) |
| **Testing** | Easy with DI and mocking | Complex, often requires container |
| **Learning Curve** | Moderate | Steep |
| **Startup Time** | Fast | Slow |
| **Innovation** | Rapid releases, modern features | Slower standardization process |
| **Modularity** | Pick what you need | Full-stack, less flexible |

### When to Use Spring

```
âœ… Microservices architecture
âœ… Cloud-native applications
âœ… Rapid development cycles
âœ… Modern Java development
âœ… Need for embedded servers
âœ… Extensive third-party integrations
```

### When to Use Java EE

```
âœ… Enterprise standards compliance required
âœ… Legacy system integration
âœ… Long-term vendor support needed
âœ… Full Jakarta EE stack required
```

---

## ğŸ¯ Best Practices

### 1. **Favor Constructor Injection**
```java
// âœ… Good - immutable, testable
@Service
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// âŒ Avoid - mutable, harder to test
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
}
```

### 2. **Use Interface-Based Design**
```java
// âœ… Good - loosely coupled
public interface PaymentService {
    void processPayment(Order order);
}

@Service
public class StripePaymentService implements PaymentService {
    // Implementation
}

// Easy to swap implementations
@Service
public class PayPalPaymentService implements PaymentService {
    // Different implementation
}
```

### 3. **Proper Component Scanning**
```java
@SpringBootApplication
@ComponentScan(basePackages = {
    "com.example.service",
    "com.example.repository"
})
public class Application {
    // Explicit scanning reduces startup time
}
```

### 4. **Profile-Based Configuration**
```java
@Configuration
@Profile("production")
public class ProductionConfig {
    @Bean
    public DataSource dataSource() {
        // Production database
    }
}

@Configuration
@Profile("development")
public class DevelopmentConfig {
    @Bean
    public DataSource dataSource() {
        // H2 in-memory database
    }
}
```

---

## ğŸ“ Interview Questions

### Q1: What is Spring Framework and why is it popular?
**Answer:**
Spring is a comprehensive application framework for Java enterprise development. It's popular because:
- **Lightweight:** No need for heavy application servers
- **Non-invasive:** POJOs, no framework inheritance required
- **Modular:** Use only what you need
- **Testable:** DI makes unit testing easy
- **Production-ready:** Battle-tested in enterprise environments
- **Active community:** Regular updates, extensive documentation

### Q2: Explain Inversion of Control (IoC)?
**Answer:**
IoC is a design principle where the control of object creation and dependency management is transferred from the application code to a framework (Spring Container).

```java
// Without IoC - you control object creation
UserRepository repo = new UserRepositoryImpl();
UserService service = new UserService(repo);

// With IoC - Spring controls object creation
@Autowired
UserService service; // Spring injects the dependency
```

### Q3: What are the different modules in Spring Framework?
**Answer:**
Spring has 20+ modules organized into layers:
- **Core Container:** spring-core, spring-beans, spring-context, spring-expression
- **Data Access:** spring-jdbc, spring-tx, spring-orm, spring-oxm
- **Web:** spring-web, spring-webmvc, spring-websocket, spring-webflux
- **AOP:** spring-aop, spring-aspects
- **Instrumentation:** spring-instrument
- **Messaging:** spring-messaging
- **Test:** spring-test

### Q4: What is the difference between Spring and Spring Boot?
**Answer:**
| Spring Framework | Spring Boot |
|------------------|-------------|
| Application framework | Opinionated framework on top of Spring |
| Manual configuration required | Auto-configuration |
| No embedded server | Embedded Tomcat/Jetty/Undertow |
| Need to manage dependencies | Starter dependencies |
| XML or Java config | Convention over configuration |
| More control, more complexity | Rapid development, less boilerplate |

### Q5: What are the advantages of Spring Framework?
**Answer:**
1. **Lightweight:** ~2MB core JAR, runs in any JVM
2. **Dependency Injection:** Loose coupling, easier testing
3. **AOP Support:** Separate cross-cutting concerns
4. **Transaction Management:** Unified API for JTA, JDBC, Hibernate, JPA
5. **Exception Handling:** Consistent exception hierarchy
6. **Integration:** Easy integration with ORM, web frameworks, cloud services
7. **Testability:** Mock injection, test utilities
8. **Modularity:** Use only required modules

### Q6: Explain the Spring Container?
**Answer:**
The Spring Container is the core of Spring Framework. It:
- Creates and manages objects (beans)
- Injects dependencies
- Manages bean lifecycle
- Provides infrastructure services

Two types:
```java
// 1. BeanFactory - basic container
BeanFactory factory = new XmlBeanFactory(
    new FileSystemResource("beans.xml")
);

// 2. ApplicationContext - advanced container (preferred)
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);
```

### Q7: What is Dependency Injection?
**Answer:**
DI is a pattern where objects receive their dependencies from external sources rather than creating them.

Types:
```java
// Constructor Injection (Recommended)
public UserService(UserRepository repository) {
    this.repository = repository;
}

// Setter Injection
public void setRepository(UserRepository repository) {
    this.repository = repository;
}

// Field Injection (Not recommended)
@Autowired
private UserRepository repository;
```

### Q8: What are the benefits of using Spring?
**Answer:**
- **Productivity:** Reduce boilerplate code
- **Testability:** Easy mocking and dependency injection
- **Flexibility:** Modular architecture, pick components
- **Integration:** Works with all major frameworks
- **Community:** Large ecosystem, extensive documentation
- **Cloud-Ready:** Native cloud support with Spring Cloud
- **Performance:** Optimized for production workloads

### Q9: What is AOP in Spring?
**Answer:**
Aspect-Oriented Programming allows separation of cross-cutting concerns (logging, security, transactions) from business logic.

```java
@Aspect
@Component
public class LoggingAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - start;
        log.info("{} executed in {}ms", 
            joinPoint.getSignature(), executionTime);
        return result;
    }
}
```

### Q10: Explain Spring's support for testing?
**Answer:**
Spring provides comprehensive testing support:

```java
// Unit Testing - Mock injection
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    @Mock
    private UserRepository repository;
    
    @InjectMocks
    private UserService service;
}

// Integration Testing - Load Spring context
@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void testEndpoint() throws Exception {
        mockMvc.perform(get("/api/users"))
               .andExpect(status().isOk());
    }
}
```

---

## ğŸ“š Summary

Spring Framework is a comprehensive, modular framework that simplifies Java enterprise development through:

1. **Core Principles:** IoC, DI, AOP, POJO-based development
2. **Modular Architecture:** Use only what you need
3. **Rich Ecosystem:** Boot, Cloud, Data, Security, Batch
4. **Production-Ready:** Transaction management, exception handling, testing
5. **Modern Development:** Reactive programming, cloud-native, microservices

The framework continues to evolve, embracing modern paradigms while maintaining backward compatibility and enterprise-grade reliability.

---

**Next Topic:** [Bean Lifecycle â†’](./02.%20Bean%20Lifecycle.md)
