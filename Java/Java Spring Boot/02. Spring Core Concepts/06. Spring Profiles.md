# üé≠ Spring Profiles

## üìã Table of Contents
- [What are Spring Profiles?](#what-are-spring-profiles)
- [Defining Profiles](#defining-profiles)
- [Activating Profiles](#activating-profiles)
- [Profile-Specific Configuration](#profile-specific-configuration)
- [Profile Expressions](#profile-expressions)
- [Default Profile](#default-profile)
- [Multiple Profiles](#multiple-profiles)
- [Profile Groups](#profile-groups)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What are Spring Profiles?

### Definition
**Spring Profiles** provide a way to segregate parts of your application configuration and make it available only in certain environments (development, testing, production, etc.).

### Why Use Profiles?

```
‚úÖ Environment-specific configuration
‚úÖ Feature toggles
‚úÖ Database configuration per environment
‚úÖ Different bean implementations
‚úÖ Enable/disable components
‚úÖ Testing scenarios
```

### Common Use Cases

```
Development ‚Üí H2 database, debug logging, mock services
Testing     ‚Üí Test database, specific test beans
Staging     ‚Üí Near-production settings, limited resources
Production  ‚Üí Production database, optimized settings, monitoring
```

---

## üìù Defining Profiles

### 1. **@Profile on Beans**

```java
// Development configuration
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("schema.sql")
            .build();
    }
    
    @Bean
    public MailSender mailSender() {
        return new ConsoleMailSender(); // Logs to console
    }
}

// Production configuration
@Configuration
@Profile("prod")
public class ProdConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:postgresql://prod-db:5432/app");
        ds.setUsername("prod_user");
        ds.setPassword("secure_password");
        return ds;
    }
    
    @Bean
    public MailSender mailSender() {
        JavaMailSenderImpl sender = new JavaMailSenderImpl();
        sender.setHost("smtp.gmail.com");
        return sender;
    }
}
```

### 2. **@Profile on Components**

```java
@Service
@Profile("dev")
public class MockPaymentService implements PaymentService {
    @Override
    public void processPayment(Order order) {
        System.out.println("Mock payment: " + order.getTotal());
    }
}

@Service
@Profile("prod")
public class StripePaymentService implements PaymentService {
    @Override
    public void processPayment(Order order) {
        // Real Stripe API integration
    }
}
```

### 3. **@Profile on Methods**

```java
@Configuration
public class CacheConfig {
    
    @Bean
    @Profile("dev")
    public CacheManager devCacheManager() {
        // Simple cache for development
        return new ConcurrentMapCacheManager("users", "products");
    }
    
    @Bean
    @Profile("prod")
    public CacheManager prodCacheManager() {
        // Redis cache for production
        RedisCacheManager cacheManager = RedisCacheManager
            .builder(redisConnectionFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10)))
            .build();
        return cacheManager;
    }
}
```

### 4. **@Profile on Nested Classes**

```java
@Configuration
public class AppConfig {
    
    @Configuration
    @Profile("dev")
    static class DevConfig {
        @Bean
        public DebugService debugService() {
            return new DebugService();
        }
    }
    
    @Configuration
    @Profile("prod")
    static class ProdConfig {
        @Bean
        public MonitoringService monitoringService() {
            return new MonitoringService();
        }
    }
}
```

---

## üöÄ Activating Profiles

### Method 1: application.properties/yml

```properties
# application.properties
spring.profiles.active=dev

# Multiple profiles
spring.profiles.active=dev,mysql,cache
```

```yaml
# application.yml
spring:
  profiles:
    active: dev
```

### Method 2: Command Line Arguments

```bash
# Single profile
java -jar myapp.jar --spring.profiles.active=prod

# Multiple profiles
java -jar myapp.jar --spring.profiles.active=prod,mysql

# JVM system property
java -Dspring.profiles.active=prod -jar myapp.jar
```

### Method 3: Environment Variable

```bash
# Linux/Mac
export SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar

# Windows
set SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar

# Docker
docker run -e SPRING_PROFILES_ACTIVE=prod myapp:latest
```

### Method 4: Programmatically

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setAdditionalProfiles("dev");
        app.run(args);
    }
}

// Or using SpringApplicationBuilder
new SpringApplicationBuilder(Application.class)
    .profiles("dev", "mysql")
    .run(args);
```

### Method 5: @ActiveProfiles (Testing)

```java
@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    public void testUser() {
        // Test with "test" profile active
    }
}
```

### Method 6: WebApplicationInitializer (Web Apps)

```java
public class MyWebAppInitializer implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext servletContext) {
        AnnotationConfigWebApplicationContext context = 
            new AnnotationConfigWebApplicationContext();
        
        context.getEnvironment().setActiveProfiles("prod");
        context.register(AppConfig.class);
        
        servletContext.addListener(new ContextLoaderListener(context));
    }
}
```

---

## ‚öôÔ∏è Profile-Specific Configuration

### Profile-Specific Property Files

```
src/main/resources/
‚îú‚îÄ‚îÄ application.properties          # Default
‚îú‚îÄ‚îÄ application-dev.properties      # Dev profile
‚îú‚îÄ‚îÄ application-test.properties     # Test profile
‚îú‚îÄ‚îÄ application-prod.properties     # Prod profile
‚îî‚îÄ‚îÄ application.yml                 # Default YAML
    application-dev.yml             # Dev profile YAML
    application-prod.yml            # Prod profile YAML
```

**application.properties** (default):
```properties
app.name=My Application
logging.level.root=INFO
```

**application-dev.properties**:
```properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
logging.level.root=DEBUG
logging.level.com.example=TRACE
```

**application-prod.properties**:
```properties
spring.datasource.url=jdbc:postgresql://prod-db:5432/app
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
logging.level.root=WARN
```

### Profile-Specific YAML

```yaml
# application.yml
spring:
  application:
    name: My App

---
# Dev profile
spring:
  config:
    activate:
      on-profile: dev
  datasource:
    url: jdbc:h2:mem:testdb
  logging:
    level:
      root: DEBUG

---
# Prod profile
spring:
  config:
    activate:
      on-profile: prod
  datasource:
    url: jdbc:postgresql://prod-db:5432/app
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  logging:
    level:
      root: WARN
```

---

## üîÄ Profile Expressions

### NOT Operator

```java
@Configuration
@Profile("!prod")
public class NonProdConfig {
    // Active when NOT in production
    @Bean
    public MockService mockService() {
        return new MockService();
    }
}
```

### AND Operator

```java
@Configuration
@Profile("prod & cloud")
public class ProdCloudConfig {
    // Active when BOTH prod AND cloud are active
}
```

### OR Operator

```java
@Configuration
@Profile("dev | test")
public class DevOrTestConfig {
    // Active when dev OR test is active
}
```

### Complex Expressions

```java
@Configuration
@Profile("(prod | staging) & cloud")
public class CloudConfig {
    // Active when (prod OR staging) AND cloud
}

@Configuration
@Profile("!prod & !staging")
public class DevelopmentConfig {
    // Active when NOT prod AND NOT staging
}
```

---

## üîß Default Profile

### Setting Default Profile

```properties
# application.properties
spring.profiles.default=dev
```

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setDefaultProperties(
            Collections.singletonMap("spring.profiles.default", "dev")
        );
        app.run(args);
    }
}
```

### @Profile("default")

```java
@Configuration
@Profile("default")
public class DefaultConfig {
    // Used when no profile is active
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}
```

---

## üì¶ Multiple Profiles

### Activating Multiple Profiles

```properties
# application.properties
spring.profiles.active=dev,mysql,cache,swagger
```

```bash
# Command line
java -jar app.jar --spring.profiles.active=dev,mysql,cache
```

### Profile Precedence

Later profiles override earlier ones:
```properties
# dev properties loaded first
# mysql properties can override dev
# cache properties can override both
spring.profiles.active=dev,mysql,cache
```

### Use Cases

```java
// Base profiles
@Profile("dev")    // Development mode
@Profile("test")   // Testing mode
@Profile("prod")   // Production mode

// Database profiles
@Profile("mysql")     // MySQL database
@Profile("postgres")  // PostgreSQL database
@Profile("h2")        // H2 database

// Feature profiles
@Profile("cache")     // Enable caching
@Profile("swagger")   // Enable Swagger docs
@Profile("monitoring")// Enable monitoring

// Cloud profiles
@Profile("aws")       // AWS deployment
@Profile("azure")     // Azure deployment
@Profile("gcp")       // Google Cloud deployment
```

### Example Configuration

```java
@Configuration
@Profile("prod & aws")
public class AwsProdConfig {
    @Bean
    public DataSource dataSource() {
        // AWS RDS configuration
    }
}

@Configuration
@Profile("prod & azure")
public class AzureProdConfig {
    @Bean
    public DataSource dataSource() {
        // Azure SQL configuration
    }
}

@Configuration
@Profile("dev & mysql")
public class DevMySqlConfig {
    @Bean
    public DataSource dataSource() {
        // Local MySQL for development
    }
}
```

---

## üë• Profile Groups

### Spring Boot 2.4+ Feature

```properties
# application.properties
# Define profile groups
spring.profiles.group.development=dev,mysql,swagger,debug
spring.profiles.group.production=prod,postgres,monitoring

# Activate group
spring.profiles.active=development
```

```yaml
# application.yml
spring:
  profiles:
    group:
      development:
        - dev
        - mysql
        - swagger
        - debug
      production:
        - prod
        - postgres
        - monitoring
    active: development
```

### Benefits

```
‚úÖ Simpler activation (one group vs multiple profiles)
‚úÖ Consistent environment setup
‚úÖ Easy to manage related configurations
‚úÖ Reduced configuration errors
```

---

## üîç Checking Active Profiles

### Programmatically

```java
@Service
public class ConfigService {
    
    @Autowired
    private Environment environment;
    
    public void printActiveProfiles() {
        String[] profiles = environment.getActiveProfiles();
        System.out.println("Active profiles: " + Arrays.toString(profiles));
        
        // Check if specific profile is active
        boolean isDev = environment.acceptsProfiles(Profiles.of("dev"));
        System.out.println("Dev profile active: " + isDev);
        
        // Check profile expression
        boolean isProdOrStaging = environment.acceptsProfiles(
            Profiles.of("prod | staging")
        );
    }
}
```

### Using @Value

```java
@Component
public class ProfileAwareBean {
    
    @Value("${spring.profiles.active:default}")
    private String activeProfiles;
    
    @PostConstruct
    public void init() {
        System.out.println("Running with profiles: " + activeProfiles);
    }
}
```

### Logging on Startup

```java
@SpringBootApplication
public class Application {
    
    @Autowired
    private Environment environment;
    
    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(Application.class, args);
        
        Environment env = context.getEnvironment();
        System.out.println("Active profiles: " + 
            Arrays.toString(env.getActiveProfiles()));
        System.out.println("Default profiles: " + 
            Arrays.toString(env.getDefaultProfiles()));
    }
}
```

---

## ‚úÖ Best Practices

### 1. **Use Semantic Profile Names**

```java
// ‚úÖ Good - clear purpose
@Profile("dev")
@Profile("production")
@Profile("cloud-aws")
@Profile("feature-new-checkout")

// ‚ùå Avoid - unclear
@Profile("profile1")
@Profile("config-a")
```

### 2. **Separate Environment and Feature Profiles**

```properties
# Environment profiles
spring.profiles.active=dev

# Feature profiles (combine with environment)
spring.profiles.active=dev,cache,swagger

# Use profile groups for clarity
spring.profiles.group.development=dev,cache,swagger,debug
spring.profiles.active=development
```

### 3. **Don't Hardcode Sensitive Data**

```properties
# ‚ùå Bad - hardcoded credentials
spring.datasource.password=secret123

# ‚úÖ Good - use environment variables
spring.datasource.password=${DB_PASSWORD}

# ‚úÖ Good - use external config
spring.config.import=optional:file:.env[.properties]
```

### 4. **Use Default Profile for Local Development**

```properties
# Set sensible defaults
spring.profiles.default=dev

# Developers don't need to set anything
# Production explicitly sets: --spring.profiles.active=prod
```

### 5. **Profile-Specific Beans Should Implement Same Interface**

```java
// ‚úÖ Good - interface-based
public interface PaymentService {
    void processPayment(Order order);
}

@Service
@Profile("dev")
public class MockPaymentService implements PaymentService {
    // Mock implementation
}

@Service
@Profile("prod")
public class StripePaymentService implements PaymentService {
    // Real implementation
}

// ‚ùå Avoid - different types for different profiles
@Component
@Profile("dev")
public class DevBean {
    public void doDevStuff() { }
}

@Component
@Profile("prod")
public class ProdBean {
    public void doProdStuff() { }
}
```

### 6. **Testing with Profiles**

```java
@SpringBootTest
@ActiveProfiles("test")
public class UserServiceTest {
    
    @MockBean
    private ExternalService externalService;
    
    @Autowired
    private UserService userService;
    
    @Test
    public void testUser() {
        // Test with test profile configuration
    }
}
```

### 7. **Document Profile Usage**

```markdown
# Application Profiles

## Environment Profiles
- **dev**: Local development (H2 database, debug logging)
- **test**: Integration testing (Test database, mock services)
- **staging**: Staging environment (Prod-like config, limited resources)
- **prod**: Production environment (Full config, monitoring)

## Feature Profiles
- **cache**: Enable Redis caching
- **swagger**: Enable Swagger documentation
- **monitoring**: Enable monitoring and metrics

## Usage
```bash
# Development
java -jar app.jar --spring.profiles.active=dev,swagger

# Production
java -jar app.jar --spring.profiles.active=prod,cache,monitoring
```
```

---

## üéì Interview Questions

### Q1: What are Spring Profiles?
**Answer:**
Spring Profiles provide a way to segregate application configuration and make it available only in certain environments.

```java
@Configuration
@Profile("dev")
public class DevConfig {
    // Only loaded when "dev" profile is active
}
```

Use cases: Environment-specific config, feature toggles, different database configurations.

### Q2: How do you activate a Spring Profile?
**Answer:**
Multiple ways:

```properties
# 1. application.properties
spring.profiles.active=dev

# 2. Command line
java -jar app.jar --spring.profiles.active=prod

# 3. Environment variable
export SPRING_PROFILES_ACTIVE=prod

# 4. Programmatically
app.setAdditionalProfiles("dev");

# 5. @ActiveProfiles (testing)
@ActiveProfiles("test")
```

### Q3: What is the default profile?
**Answer:**
The default profile is activated when no other profile is active. Set using:

```properties
spring.profiles.default=dev
```

Use `@Profile("default")` for beans that should only load when no profile is set.

### Q4: How do profile-specific property files work?
**Answer:**
Spring loads properties based on active profiles:

```
application.properties           # Base properties
application-dev.properties       # Loaded when dev profile active
application-prod.properties      # Loaded when prod profile active
```

Profile-specific properties override base properties.

### Q5: Can you use multiple profiles simultaneously?
**Answer:**
Yes:

```properties
spring.profiles.active=dev,mysql,cache,swagger
```

Later profiles can override properties from earlier ones.

### Q6: What are profile expressions?
**Answer:**
Profile expressions allow complex conditions:

```java
@Profile("!prod")           // NOT prod
@Profile("prod & cloud")    // prod AND cloud
@Profile("dev | test")      // dev OR test
@Profile("(prod | staging) & cloud") // Complex expression
```

### Q7: What are profile groups (Spring Boot 2.4+)?
**Answer:**
Profile groups allow activating multiple related profiles together:

```properties
spring.profiles.group.development=dev,mysql,swagger,debug
spring.profiles.active=development
# Activates: dev, mysql, swagger, debug
```

### Q8: How to check active profiles programmatically?
**Answer:**
```java
@Autowired
private Environment environment;

String[] profiles = environment.getActiveProfiles();
boolean isDev = environment.acceptsProfiles(Profiles.of("dev"));
```

### Q9: Difference between @Profile on class vs method?
**Answer:**
- **Class-level**: Entire configuration class is conditional
  ```java
  @Configuration
  @Profile("dev")
  public class DevConfig { }
  ```
- **Method-level**: Individual beans are conditional
  ```java
  @Bean
  @Profile("prod")
  public DataSource prodDataSource() { }
  ```

### Q10: Best practices for using profiles?
**Answer:**
1. Use semantic names (dev, prod, not profile1)
2. Set default profile for local development
3. Don't hardcode sensitive data
4. Profile-specific beans should implement same interface
5. Use profile groups for related configurations
6. Document profile usage
7. Separate environment and feature profiles

---

## üìö Summary

Spring Profiles enable flexible, environment-specific configuration:

1. **Definition**: Use @Profile on beans, configurations, or methods
2. **Activation**: Properties, command line, environment variables, programmatic
3. **Profile Files**: application-{profile}.properties/yml
4. **Expressions**: Support NOT (!), AND (&), OR (|) operators
5. **Groups**: Activate multiple related profiles together (Spring Boot 2.4+)
6. **Best Practices**: Semantic names, interface-based design, externalized config

Profiles are essential for managing different environments and feature toggles!

---

**Next Topic:** [Property Sources ‚Üí](./07.%20Property%20Sources.md)
