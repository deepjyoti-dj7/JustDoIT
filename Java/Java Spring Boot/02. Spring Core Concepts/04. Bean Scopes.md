# üîç Spring Bean Scopes

## üìã Table of Contents
- [What are Bean Scopes?](#what-are-bean-scopes)
- [Types of Bean Scopes](#types-of-bean-scopes)
- [Singleton Scope](#singleton-scope)
- [Prototype Scope](#prototype-scope)
- [Request Scope](#request-scope)
- [Session Scope](#session-scope)
- [Application Scope](#application-scope)
- [WebSocket Scope](#websocket-scope)
- [Custom Scopes](#custom-scopes)
- [Scoped Proxies](#scoped-proxies)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What are Bean Scopes?

### Definition
**Bean Scope** defines the lifecycle and visibility of a bean instance within the Spring IoC container. It determines how many instances of a bean are created and how long they live.

### Why Scopes Matter
```
‚úÖ Control bean lifecycle
‚úÖ Manage memory efficiently
‚úÖ Handle stateful vs stateless beans
‚úÖ Support different use cases (singleton services, per-request data)
‚úÖ Enable proper resource management
```

---

## üì¶ Types of Bean Scopes

### Overview

| Scope | Instances | Lifecycle | Use Case |
|-------|-----------|-----------|----------|
| **singleton** | One per container | Container lifetime | Stateless services, DAOs |
| **prototype** | New every time | Per request | Stateful beans, commands |
| **request** | One per HTTP request | Request duration | Web request data |
| **session** | One per HTTP session | Session duration | User session data |
| **application** | One per ServletContext | Application lifetime | Global web app state |
| **websocket** | One per WebSocket | WebSocket lifetime | WebSocket handlers |

### Scope Availability

```
Singleton & Prototype:
‚úÖ Available in all Spring applications

Request, Session, Application, WebSocket:
‚úÖ Only available in web-aware ApplicationContext
   (e.g., WebApplicationContext)
```

---

## üî∑ Singleton Scope

### Overview
**Default scope**. Spring creates only **one instance** per bean definition in the container.

### Configuration

```java
// Method 1: Default (no annotation needed)
@Component
public class UserService {
    // Singleton by default
}

// Method 2: Explicit annotation
@Component
@Scope("singleton")
public class ProductService {
}

// Method 3: Using constant
@Component
@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
public class OrderService {
}

// Method 4: XML configuration
<bean id="userService" class="com.example.UserService" scope="singleton"/>

// Method 5: Java config
@Configuration
public class AppConfig {
    @Bean
    @Scope("singleton")
    public UserService userService() {
        return new UserService();
    }
}
```

### Behavior

```java
@Component
public class UserService {
    private int counter = 0;
    
    public void incrementCounter() {
        counter++;
    }
    
    public int getCounter() {
        return counter;
    }
}

// Usage
ApplicationContext context = ...;

UserService service1 = context.getBean(UserService.class);
UserService service2 = context.getBean(UserService.class);

System.out.println(service1 == service2); // true (same instance)

service1.incrementCounter();
System.out.println(service2.getCounter()); // 1 (shared state!)
```

### When to Use

```
‚úÖ Stateless services
‚úÖ DAOs/Repositories
‚úÖ Configuration beans
‚úÖ Utility classes
‚úÖ Thread-safe beans

‚ùå Stateful beans
‚ùå Thread-unsafe operations
‚ùå Per-request data
```

### Thread Safety

```java
// ‚ùå NOT thread-safe (mutable state)
@Component
public class CounterService {
    private int count = 0; // Shared across threads!
    
    public void increment() {
        count++; // Race condition
    }
}

// ‚úÖ Thread-safe (immutable or synchronized)
@Component
public class SafeCounterService {
    private final AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet(); // Thread-safe
    }
}

// ‚úÖ Best - Stateless
@Component
public class UserService {
    @Autowired
    private UserRepository repository;
    
    public User findUser(Long id) {
        return repository.findById(id).orElse(null);
    }
}
```

---

## üî∂ Prototype Scope

### Overview
Creates a **new instance** every time the bean is requested from the container.

### Configuration

```java
// Annotation
@Component
@Scope("prototype")
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
}

// Or using constant
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class Command {
}

// Java config
@Configuration
public class AppConfig {
    @Bean
    @Scope("prototype")
    public ShoppingCart shoppingCart() {
        return new ShoppingCart();
    }
}
```

### Behavior

```java
@Component
@Scope("prototype")
public class ShoppingCart {
    private List<String> items = new ArrayList<>();
    
    public void addItem(String item) {
        items.add(item);
    }
    
    public List<String> getItems() {
        return items;
    }
}

// Usage
ApplicationContext context = ...;

ShoppingCart cart1 = context.getBean(ShoppingCart.class);
ShoppingCart cart2 = context.getBean(ShoppingCart.class);

System.out.println(cart1 == cart2); // false (different instances)

cart1.addItem("Item 1");
System.out.println(cart2.getItems().size()); // 0 (separate state)
```

### Important: No Destruction Callbacks

```java
@Component
@Scope("prototype")
public class FileProcessor {
    
    @PreDestroy
    public void cleanup() {
        // ‚ö†Ô∏è This will NEVER be called for prototype beans!
        // Spring doesn't manage destruction
    }
}

// Solution: Manual cleanup
public class FileProcessorManager {
    private List<FileProcessor> processors = new ArrayList<>();
    
    public FileProcessor createProcessor() {
        FileProcessor processor = context.getBean(FileProcessor.class);
        processors.add(processor);
        return processor;
    }
    
    @PreDestroy
    public void cleanupAll() {
        processors.forEach(FileProcessor::cleanup);
    }
}
```

### When to Use

```
‚úÖ Stateful beans
‚úÖ Per-operation beans (commands, tasks)
‚úÖ Expensive object creation (use sparingly)
‚úÖ Beans with request-specific data

‚ùå Shared services
‚ùå Expensive beans (created frequently)
```

### Prototype in Singleton Problem

```java
// ‚ùå Problem: Singleton holds one prototype instance
@Component
public class SingletonService {
    @Autowired
    private PrototypeBean prototypeBean; // Only injected once!
    
    public void doWork() {
        prototypeBean.execute(); // Always same instance
    }
}

// ‚úÖ Solution 1: Method injection
@Component
public class SingletonService {
    @Autowired
    private ApplicationContext context;
    
    public void doWork() {
        PrototypeBean bean = context.getBean(PrototypeBean.class);
        bean.execute(); // New instance each time
    }
}

// ‚úÖ Solution 2: Lookup method injection
@Component
public abstract class SingletonService {
    
    public void doWork() {
        PrototypeBean bean = getPrototypeBean();
        bean.execute();
    }
    
    @Lookup
    protected abstract PrototypeBean getPrototypeBean();
}

// ‚úÖ Solution 3: ObjectFactory
@Component
public class SingletonService {
    @Autowired
    private ObjectFactory<PrototypeBean> prototypeBeanFactory;
    
    public void doWork() {
        PrototypeBean bean = prototypeBeanFactory.getObject();
        bean.execute();
    }
}

// ‚úÖ Solution 4: Scoped proxy (see below)
@Component
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class PrototypeBean {
}
```

---

## üåê Request Scope

### Overview
Creates **one instance per HTTP request**. Only available in web applications.

### Configuration

```java
@Component
@Scope("request")
// Or
@Scope(value = WebApplicationContext.SCOPE_REQUEST)
// Or
@RequestScope // Shorthand
public class RequestData {
    private String requestId;
    private LocalDateTime requestTime;
    
    @PostConstruct
    public void init() {
        this.requestId = UUID.randomUUID().toString();
        this.requestTime = LocalDateTime.now();
    }
}
```

### Usage

```java
@RestController
@RequestMapping("/api")
public class UserController {
    
    @Autowired
    private RequestData requestData; // Proxied bean
    
    @GetMapping("/info")
    public String getRequestInfo() {
        return "Request ID: " + requestData.getRequestId() + 
               ", Time: " + requestData.getRequestTime();
    }
}

@Service
public class UserService {
    
    @Autowired
    private RequestData requestData; // Same instance as in controller
    
    public void processUser() {
        System.out.println("Processing request: " + 
            requestData.getRequestId());
    }
}
```

### When to Use

```
‚úÖ Request-specific data (user info, request ID, timestamp)
‚úÖ Tracking request metadata
‚úÖ Request-scoped caching
‚úÖ Audit logging per request

‚ùå Shared application state
‚ùå Non-web applications
```

---

## üë§ Session Scope

### Overview
Creates **one instance per HTTP session**. Survives multiple requests from same user.

### Configuration

```java
@Component
@Scope("session")
// Or
@Scope(value = WebApplicationContext.SCOPE_SESSION)
// Or
@SessionScope // Shorthand
public class UserSession {
    private String username;
    private LocalDateTime loginTime;
    private List<String> visitedPages = new ArrayList<>();
    
    public void addVisitedPage(String page) {
        visitedPages.add(page);
    }
}
```

### Usage

```java
@RestController
@RequestMapping("/api")
public class SessionController {
    
    @Autowired
    private UserSession userSession; // Proxied, one per HTTP session
    
    @PostMapping("/login")
    public String login(@RequestBody LoginRequest request) {
        userSession.setUsername(request.getUsername());
        userSession.setLoginTime(LocalDateTime.now());
        return "Logged in: " + userSession.getUsername();
    }
    
    @GetMapping("/visit/{page}")
    public String visitPage(@PathVariable String page) {
        userSession.addVisitedPage(page);
        return "Pages visited: " + userSession.getVisitedPages().size();
    }
    
    @GetMapping("/session-info")
    public Map<String, Object> getSessionInfo() {
        return Map.of(
            "username", userSession.getUsername(),
            "loginTime", userSession.getLoginTime(),
            "pagesVisited", userSession.getVisitedPages()
        );
    }
}
```

### When to Use

```
‚úÖ User session data (logged-in user info)
‚úÖ Shopping cart
‚úÖ User preferences
‚úÖ Multi-step wizards
‚úÖ Session-level caching

‚ùå Stateless APIs
‚ùå Shared application data
```

---

## üåç Application Scope

### Overview
Creates **one instance per ServletContext**. Similar to singleton but specific to web applications.

### Configuration

```java
@Component
@Scope("application")
// Or
@Scope(value = WebApplicationContext.SCOPE_APPLICATION)
// Or
@ApplicationScope // Shorthand
public class ApplicationCache {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        return cache.get(key);
    }
}
```

### Singleton vs Application Scope

```java
// Singleton - One per Spring ApplicationContext
@Component
@Scope("singleton")
public class SingletonBean {
}

// Application - One per ServletContext
// In multi-context web app, different from singleton
@Component
@Scope("application")
public class ApplicationBean {
}
```

### When to Use

```
‚úÖ Global application cache
‚úÖ Application-wide counters/metrics
‚úÖ Shared configuration
‚úÖ Connection pools (though prefer singleton)

‚ùå Most cases (use singleton instead)
```

---

## üîå WebSocket Scope

### Overview
Creates **one instance per WebSocket session**.

### Configuration

```java
@Component
@Scope("websocket")
public class WebSocketHandler {
    private String sessionId;
    private List<String> messages = new ArrayList<>();
    
    public void addMessage(String message) {
        messages.add(message);
    }
}
```

---

## üé® Custom Scopes

### Creating Custom Scope

```java
// 1. Implement Scope interface
public class ThreadScope implements Scope {
    
    private final ThreadLocal<Map<String, Object>> threadScope = 
        ThreadLocal.withInitial(HashMap::new);
    
    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Map<String, Object> scope = threadScope.get();
        Object obj = scope.get(name);
        if (obj == null) {
            obj = objectFactory.getObject();
            scope.put(name, obj);
        }
        return obj;
    }
    
    @Override
    public Object remove(String name) {
        Map<String, Object> scope = threadScope.get();
        return scope.remove(name);
    }
    
    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        // Optional: register cleanup
    }
    
    @Override
    public Object resolveContextualObject(String key) {
        return null;
    }
    
    @Override
    public String getConversationId() {
        return Thread.currentThread().getName();
    }
}

// 2. Register custom scope
@Configuration
public class CustomScopeConfig {
    
    @Bean
    public CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        configurer.addScope("thread", new ThreadScope());
        return configurer;
    }
}

// 3. Use custom scope
@Component
@Scope("thread")
public class ThreadScopedBean {
    // One instance per thread
}
```

---

## üé≠ Scoped Proxies

### The Problem

```java
// Singleton depends on request-scoped bean
@Component
public class SingletonService {
    
    @Autowired
    private RequestData requestData; // Problem: Singleton injected once!
    
    public void doWork() {
        // Always gets the FIRST request's data
        System.out.println(requestData.getRequestId());
    }
}
```

### Solution: Scoped Proxy

```java
// Option 1: proxyMode in @Scope
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestData {
    // Spring creates a CGLIB proxy
    // Proxy delegates to actual request-scoped instance
}

// Option 2: @RequestScope with proxy
@Component
@RequestScope(proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestData {
}

// Option 3: For interfaces, use INTERFACES mode
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)
public class RequestDataImpl implements RequestDataInterface {
}
```

### How It Works

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SingletonService ‚îÇ
‚îÇ                  ‚îÇ
‚îÇ  @Autowired      ‚îÇ
‚îÇ  RequestData ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ‚îÇ        ‚îÇ CGLIB PROXY     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ                 ‚îÇ
                            ‚îÇ delegates to    ‚îÇ
                            ‚îÇ       ‚Üì         ‚îÇ
                            ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
                            ‚îÇ ‚îÇRequestData  ‚îÇ ‚îÇ
                            ‚îÇ ‚îÇ(current req)‚îÇ ‚îÇ
                            ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Proxy Modes

```java
// TARGET_CLASS - Use CGLIB proxy (for classes)
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)

// INTERFACES - Use JDK proxy (for interfaces)
@Scope(value = "request", proxyMode = ScopedProxyMode.INTERFACES)

// NO - No proxy (default, can cause issues)
@Scope(value = "request", proxyMode = ScopedProxyMode.NO)

// DEFAULT - Let Spring decide (usually NO)
@Scope(value = "request", proxyMode = ScopedProxyMode.DEFAULT)
```

---

## ‚úÖ Best Practices

### 1. **Use Appropriate Scope**

```java
// ‚úÖ Stateless services - Singleton
@Component
public class UserService {
    @Autowired
    private UserRepository repository;
    
    public User findUser(Long id) {
        return repository.findById(id).orElse(null);
    }
}

// ‚úÖ Stateful beans - Prototype
@Component
@Scope("prototype")
public class OrderCommand {
    private Order order;
    
    public void execute() {
        // Process order
    }
}

// ‚úÖ Request data - Request scope
@Component
@RequestScope(proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestContext {
    private String requestId;
    private User currentUser;
}
```

### 2. **Always Use Scoped Proxy for Narrow Scopes**

```java
// ‚ùå Bad - singleton injecting request bean
@Component
public class MyService {
    @Autowired
    private RequestData requestData; // Without proxy - WRONG!
}

// ‚úÖ Good - with scoped proxy
@Component
@RequestScope(proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestData {
}
```

### 3. **Prototype Bean Cleanup**

```java
@Component
@Scope("prototype")
public class ResourceBean implements DisposableBean {
    
    @Override
    public void destroy() {
        // ‚ö†Ô∏è Never called by Spring
    }
}

// ‚úÖ Solution: Manual tracking
@Component
public class ResourceManager {
    private Set<ResourceBean> beans = new HashSet<>();
    
    public ResourceBean getBean() {
        ResourceBean bean = context.getBean(ResourceBean.class);
        beans.add(bean);
        return bean;
    }
    
    @PreDestroy
    public void cleanup() {
        beans.forEach(ResourceBean::destroy);
    }
}
```

### 4. **Thread Safety for Singleton**

```java
// ‚ùå Not thread-safe
@Component
public class CounterService {
    private int count = 0;
    
    public void increment() {
        count++; // Race condition
    }
}

// ‚úÖ Thread-safe
@Component
public class CounterService {
    private final AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
}

// ‚úÖ Better - stateless
@Component
public class CounterService {
    public int increment(int currentValue) {
        return currentValue + 1;
    }
}
```

### 5. **Avoid Overusing Prototype**

```java
// ‚ùå Overusing prototype - performance hit
@Component
@Scope("prototype")
public class HeavyService {
    // Created every time - expensive!
}

// ‚úÖ Better - use singleton with method parameters
@Component
public class HeavyService {
    public Result process(InputData data) {
        // Stateless processing
        return new Result(data);
    }
}
```

---

## üéì Interview Questions

### Q1: What are the different bean scopes in Spring?
**Answer:**
1. **singleton** (default) - One instance per container
2. **prototype** - New instance every time
3. **request** - One per HTTP request (web only)
4. **session** - One per HTTP session (web only)
5. **application** - One per ServletContext (web only)
6. **websocket** - One per WebSocket session

### Q2: What is the default bean scope?
**Answer:**
**Singleton**. Spring creates one instance of the bean and shares it across all requests.

```java
@Component // singleton by default
public class UserService {
}
```

### Q3: Difference between singleton and prototype scope?
**Answer:**
| Singleton | Prototype |
|-----------|-----------|
| One instance per container | New instance every request |
| Shared state | Independent state |
| Container manages full lifecycle | No destruction callbacks |
| Thread-safety concerns | Thread-safe (separate instances) |
| Default scope | Explicit @Scope needed |

```java
// Singleton - same instance
UserService s1 = context.getBean(UserService.class);
UserService s2 = context.getBean(UserService.class);
System.out.println(s1 == s2); // true

// Prototype - different instances
@Scope("prototype")
Cart c1 = context.getBean(Cart.class);
Cart c2 = context.getBean(Cart.class);
System.out.println(c1 == c2); // false
```

### Q4: Does Spring call @PreDestroy for prototype beans?
**Answer:**
**NO!** Spring doesn't manage the destruction of prototype beans. You must manually cleanup.

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    @PreDestroy
    public void cleanup() {
        // Never called!
    }
}
```

### Q5: What is a scoped proxy?
**Answer:**
A scoped proxy is a proxy that delegates to the actual scoped bean instance. Required when injecting narrow-scoped beans into wider-scoped beans.

```java
// Without proxy - WRONG
@Component
public class SingletonService {
    @Autowired
    private RequestData requestData; // Injected once!
}

// With proxy - CORRECT
@Component
@RequestScope(proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestData {
}
```

The proxy looks up the correct instance based on current request.

### Q6: When to use request scope?
**Answer:**
Use request scope for data specific to an HTTP request:
- Request metadata (ID, timestamp)
- Current user info for this request
- Request-specific configuration
- Temporary request data

```java
@Component
@RequestScope
public class RequestContext {
    private User currentUser;
    private String requestId;
}
```

### Q7: How to inject prototype bean into singleton?
**Answer:**
Four solutions:

```java
// 1. Method injection (ApplicationContext)
@Autowired
private ApplicationContext context;
PrototypeBean bean = context.getBean(PrototypeBean.class);

// 2. @Lookup method injection
@Lookup
protected abstract PrototypeBean getPrototypeBean();

// 3. ObjectFactory
@Autowired
private ObjectFactory<PrototypeBean> factory;
PrototypeBean bean = factory.getObject();

// 4. Scoped proxy
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
```

### Q8: What is session scope used for?
**Answer:**
Session scope creates one bean instance per HTTP session:
- User login information
- Shopping cart
- User preferences
- Multi-step wizard data

```java
@Component
@SessionScope
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
}
```

### Q9: Can you create custom scopes?
**Answer:**
Yes, implement `Scope` interface and register:

```java
public class CustomScope implements Scope {
    public Object get(String name, ObjectFactory<?> factory) {
        // Custom logic
    }
    // ... other methods
}

@Bean
public CustomScopeConfigurer configurer() {
    CustomScopeConfigurer cfg = new CustomScopeConfigurer();
    cfg.addScope("custom", new CustomScope());
    return cfg;
}
```

### Q10: What are the proxy modes in scoped proxies?
**Answer:**
- **TARGET_CLASS** - CGLIB proxy for classes
- **INTERFACES** - JDK dynamic proxy for interfaces
- **NO** - No proxy (default, can cause issues)
- **DEFAULT** - Let Spring decide

```java
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
```

---

## üìö Summary

Bean scopes control the lifecycle and visibility of Spring beans:

1. **Singleton** - Default, one instance per container, use for stateless services
2. **Prototype** - New instance per request, no destruction callbacks, use for stateful beans
3. **Web Scopes** - request, session, application, websocket for web applications
4. **Scoped Proxies** - Essential when injecting narrow scopes into wider scopes
5. **Custom Scopes** - Implement Scope interface for specialized use cases

**Key Takeaway:** Choose scope based on statefulness and lifecycle requirements!

---

**Next Topic:** [Component Scanning ‚Üí](./05.%20Component%20Scanning.md)
