# ðŸ”® Spring Expression Language (SpEL)

## ðŸ“‹ Table of Contents
- [What is SpEL?](#what-is-spel)
- [Basic Syntax](#basic-syntax)
- [Literal Expressions](#literal-expressions)
- [Property Access](#property-access)
- [Method Invocation](#method-invocation)
- [Operators](#operators)
- [Collection Selection](#collection-selection)
- [Bean References](#bean-references)
- [Practical Use Cases](#practical-use-cases)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ðŸŽ¯ What is SpEL?

### Definition
**Spring Expression Language (SpEL)** is a powerful expression language that supports querying and manipulating object graphs at runtime. It's used throughout the Spring portfolio.

### Key Features

```
âœ… Literal expressions
âœ… Boolean and relational operators
âœ… Regular expressions
âœ… Class expressions
âœ… Accessing properties, arrays, lists, maps
âœ… Method invocation
âœ… Relational operators
âœ… Assignment
âœ… Calling constructors
âœ… Bean references
âœ… Array construction
âœ… Inline lists and maps
âœ… Ternary operator
âœ… Variables
âœ… User-defined functions
âœ… Collection selection and projection
âœ… Template expressions
```

### Where SpEL is Used

```
@Value annotations
@Conditional expressions
Security expressions (@PreAuthorize, @PostAuthorize)
Spring Data query methods
Spring Integration
Spring Batch
Spring Web Flow
Thymeleaf templates
```

---

## ðŸ“– Basic Syntax

### Expression Delimiters

```java
// In annotations
@Value("#{expression}")

// In XML
<property name="field" value="#{expression}"/>

// Programmatic
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("expression");
Object value = exp.getValue();
```

### Simple Example

```java
@Component
public class SpELExample {
    
    // Literal
    @Value("#{1 + 1}")
    private int result; // 2
    
    // String concatenation
    @Value("#{'Hello' + ' ' + 'World'}")
    private String greeting; // "Hello World"
    
    // Boolean
    @Value("#{true and false}")
    private boolean flag; // false
    
    // Math
    @Value("#{10 * 2 + 3}")
    private int calculation; // 23
}
```

---

## ðŸ”¤ Literal Expressions

### String Literals

```java
@Component
public class StringLiterals {
    
    @Value("#{'Hello World'}")
    private String text;
    
    @Value("#{'It''s a beautiful day'}") // Escape quote with double quote
    private String withQuote;
    
    @Value("#{new String('Hello')}")
    private String constructed;
}
```

### Numeric Literals

```java
@Component
public class NumericLiterals {
    
    // Integer
    @Value("#{42}")
    private int intValue;
    
    // Hexadecimal
    @Value("#{0x2A}")
    private int hexValue; // 42
    
    // Long
    @Value("#{1000000L}")
    private long longValue;
    
    // Double
    @Value("#{3.14159}")
    private double pi;
    
    // Scientific notation
    @Value("#{6.022e23}")
    private double avogadro;
}
```

### Boolean Literals

```java
@Value("#{true}")
private boolean trueValue;

@Value("#{false}")
private boolean falseValue;
```

### Null Literal

```java
@Value("#{null}")
private String nullValue;
```

---

## ðŸ”‘ Property Access

### Accessing Properties

```java
@Component
public class PropertyAccess {
    
    // System properties
    @Value("#{systemProperties['user.name']}")
    private String userName;
    
    @Value("#{systemProperties['java.home']}")
    private String javaHome;
    
    // Environment variables
    @Value("#{systemEnvironment['PATH']}")
    private String path;
    
    @Value("#{systemEnvironment['HOME']}")
    private String home;
}
```

### Accessing Bean Properties

```java
@Component
public class ConfigBean {
    private String apiUrl = "https://api.example.com";
    private int timeout = 30;
    
    public String getApiUrl() { return apiUrl; }
    public int getTimeout() { return timeout; }
}

@Component
public class ServiceBean {
    
    // Access bean property
    @Value("#{configBean.apiUrl}")
    private String apiUrl;
    
    @Value("#{configBean.timeout}")
    private int timeout;
    
    // Nested property access
    @Value("#{configBean.apiUrl.concat('/v1')}")
    private String apiEndpoint; // https://api.example.com/v1
}
```

### Safe Navigation Operator (?.)

```java
@Component
public class SafeNavigation {
    
    // Avoids NullPointerException
    @Value("#{userBean?.address?.city}")
    private String city; // null if userBean or address is null
    
    // Without safe navigation
    @Value("#{userBean.address.city}")
    private String unsafeCity; // Throws NPE if userBean is null
}
```

---

## ðŸŽ¯ Method Invocation

### Calling Methods

```java
@Component
public class MethodInvocation {
    
    // String methods
    @Value("#{'hello'.toUpperCase()}")
    private String upper; // "HELLO"
    
    @Value("#{'HELLO'.toLowerCase()}")
    private String lower; // "hello"
    
    @Value("#{'  trim me  '.trim()}")
    private String trimmed; // "trim me"
    
    @Value("#{'hello'.substring(0, 4)}")
    private String sub; // "hell"
    
    @Value("#{'hello'.concat(' world')}")
    private String concat; // "hello world"
    
    // Math methods
    @Value("#{T(java.lang.Math).random()}")
    private double random;
    
    @Value("#{T(java.lang.Math).max(10, 20)}")
    private int max; // 20
    
    @Value("#{T(java.lang.Math).PI}")
    private double pi; // 3.14159...
}
```

### Bean Method Invocation

```java
@Component
public class UtilityBean {
    public String formatMessage(String msg) {
        return "[" + msg.toUpperCase() + "]";
    }
    
    public int multiply(int a, int b) {
        return a * b;
    }
}

@Component
public class ConsumerBean {
    
    @Value("#{utilityBean.formatMessage('hello')}")
    private String formatted; // "[HELLO]"
    
    @Value("#{utilityBean.multiply(5, 10)}")
    private int result; // 50
}
```

### Static Method Calls

```java
@Component
public class StaticCalls {
    
    // Type reference with T()
    @Value("#{T(java.lang.Math).random()}")
    private double random;
    
    @Value("#{T(java.lang.Math).sqrt(144)}")
    private double sqrt; // 12.0
    
    @Value("#{T(java.util.UUID).randomUUID().toString()}")
    private String uuid;
    
    @Value("#{T(java.time.LocalDateTime).now()}")
    private LocalDateTime now;
}
```

---

## âž• Operators

### Arithmetic Operators

```java
@Component
public class ArithmeticOperators {
    
    @Value("#{10 + 5}")
    private int addition; // 15
    
    @Value("#{10 - 5}")
    private int subtraction; // 5
    
    @Value("#{10 * 5}")
    private int multiplication; // 50
    
    @Value("#{10 / 5}")
    private int division; // 2
    
    @Value("#{10 % 3}")
    private int modulo; // 1
    
    @Value("#{2 ^ 3}")
    private int power; // 8
}
```

### Relational Operators

```java
@Component
public class RelationalOperators {
    
    @Value("#{10 > 5}")
    private boolean greaterThan; // true
    
    @Value("#{10 < 5}")
    private boolean lessThan; // false
    
    @Value("#{10 >= 10}")
    private boolean greaterOrEqual; // true
    
    @Value("#{10 <= 5}")
    private boolean lessOrEqual; // false
    
    @Value("#{10 == 10}")
    private boolean equal; // true
    
    @Value("#{10 != 5}")
    private boolean notEqual; // true
}
```

### Logical Operators

```java
@Component
public class LogicalOperators {
    
    @Value("#{true and true}")
    private boolean and; // true
    
    @Value("#{true or false}")
    private boolean or; // true
    
    @Value("#{!true}")
    private boolean not; // false
    
    @Value("#{(10 > 5) and (5 > 2)}")
    private boolean combined; // true
}
```

### String Operators

```java
@Component
public class StringOperators {
    
    @Value("#{'Hello' + ' ' + 'World'}")
    private String concat; // "Hello World"
    
    @Value("#{'abc' matches '[a-z]+'}")
    private boolean matches; // true
    
    @Value("#{'hello'.length()}")
    private int length; // 5
}
```

### Ternary Operator

```java
@Component
public class TernaryOperator {
    
    @Value("#{someBean.enabled ? 'Active' : 'Inactive'}")
    private String status;
    
    @Value("#{userBean.age >= 18 ? 'Adult' : 'Minor'}")
    private String ageGroup;
    
    // Elvis operator (shorthand for ternary)
    @Value("#{userBean.name ?: 'Guest'}")
    private String name; // userBean.name if not null, else "Guest"
}
```

### Regex Operator

```java
@Component
public class RegexOperator {
    
    @Value("#{'test@example.com' matches '.*@.*'}")
    private boolean isEmail; // true
    
    @Value("#{'12345' matches '\\d+'}")
    private boolean isNumeric; // true
    
    @Value("#{'hello123' matches '[a-z]+\\d+'}")
    private boolean pattern; // true
}
```

---

## ðŸ“‹ Collection Selection

### Lists

```java
@Component
public class ListOperations {
    
    private List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
    // Access by index
    @Value("#{listBean.numbers[0]}")
    private int first; // 1
    
    @Value("#{listBean.numbers[listBean.numbers.size() - 1]}")
    private int last; // 5
    
    // Selection (filter)
    @Value("#{listBean.numbers.?[#this > 3]}")
    private List<Integer> filtered; // [4, 5]
    
    // First match
    @Value("#{listBean.numbers.^[#this > 2]}")
    private Integer firstMatch; // 3
    
    // Last match
    @Value("#{listBean.numbers.$[#this < 4]}")
    private Integer lastMatch; // 3
    
    // Projection (map)
    @Value("#{listBean.numbers.![#this * 2]}")
    private List<Integer> doubled; // [2, 4, 6, 8, 10]
}
```

### Maps

```java
@Component
public class MapOperations {
    
    private Map<String, Integer> scores = Map.of(
        "Alice", 95,
        "Bob", 87,
        "Charlie", 92
    );
    
    // Access by key
    @Value("#{mapBean.scores['Alice']}")
    private int aliceScore; // 95
    
    @Value("#{mapBean.scores.Bob}")
    private int bobScore; // 87
    
    // Filter map
    @Value("#{mapBean.scores.?[value > 90]}")
    private Map<String, Integer> highScores; // {Alice=95, Charlie=92}
}
```

### Complex Objects

```java
public class User {
    private String name;
    private int age;
    private String city;
    
    // Constructor, getters, setters
}

@Component
public class UserService {
    
    private List<User> users = Arrays.asList(
        new User("Alice", 30, "NYC"),
        new User("Bob", 25, "LA"),
        new User("Charlie", 35, "NYC")
    );
    
    // Filter users
    @Value("#{userService.users.?[age > 28]}")
    private List<User> olderUsers; // Alice, Charlie
    
    @Value("#{userService.users.?[city == 'NYC']}")
    private List<User> nycUsers; // Alice, Charlie
    
    // Project to names
    @Value("#{userService.users.![name]}")
    private List<String> names; // [Alice, Bob, Charlie]
    
    // Complex selection
    @Value("#{userService.users.?[age > 28 and city == 'NYC'].![name]}")
    private List<String> filteredNames; // [Alice, Charlie]
}
```

---

## ðŸ”— Bean References

### Referencing Beans

```java
@Component("userService")
public class UserService {
    public String getServiceName() {
        return "User Service";
    }
}

@Component
public class ConsumerBean {
    
    // Reference bean by name
    @Value("#{userService}")
    private UserService service;
    
    // Call bean method
    @Value("#{userService.getServiceName()}")
    private String serviceName; // "User Service"
    
    // Reference with @
    @Value("#{@userService}")
    private UserService serviceAlt;
}
```

### Factory Bean Access

```java
@Component
public class FactoryConfig {
    
    // Access factory bean itself
    @Value("#{&myFactoryBean}")
    private FactoryBean<?> factory;
    
    // Access object produced by factory
    @Value("#{myFactoryBean}")
    private Object product;
}
```

---

## ðŸ’¼ Practical Use Cases

### 1. Conditional Bean Creation

```java
@Configuration
public class ConditionalConfig {
    
    @Bean
    @ConditionalOnExpression("#{environment['app.feature.enabled'] == 'true'}")
    public FeatureService featureService() {
        return new FeatureService();
    }
    
    @Bean
    @ConditionalOnExpression("#{systemProperties['os.name'].contains('Windows')}")
    public WindowsSpecificService windowsService() {
        return new WindowsSpecificService();
    }
}
```

### 2. Security Expressions

```java
@RestController
public class SecureController {
    
    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping("/admin")
    public String admin() {
        return "Admin page";
    }
    
    @PreAuthorize("#username == authentication.principal.username")
    @GetMapping("/user/{username}")
    public String userProfile(@PathVariable String username) {
        return "User profile: " + username;
    }
    
    @PreAuthorize("hasPermission(#order, 'write')")
    @PostMapping("/orders/{id}")
    public void updateOrder(@PathVariable Long id, @RequestBody Order order) {
        // Only owner can update
    }
}
```

### 3. Dynamic Configuration

```java
@Component
public class DynamicConfig {
    
    // Environment-based URL
    @Value("#{environment['app.env'] == 'prod' ? 'https://api.prod.com' : 'http://localhost:8080'}")
    private String apiUrl;
    
    // Feature toggle
    @Value("#{systemProperties['feature.new-ui'] ?: false}")
    private boolean useNewUI;
    
    // Dynamic timeout
    @Value("#{environment['app.timeout'] ?: 30}")
    private int timeout;
}
```

### 4. Collection Manipulation

```java
@Component
public class ReportService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Get active users
    @Value("#{userRepository.findAll().?[active == true]}")
    private List<User> activeUsers;
    
    // Get user emails
    @Value("#{userRepository.findAll().![email]}")
    private List<String> emails;
    
    // Filter and project
    @Value("#{userRepository.findAll().?[age >= 18].![name]}")
    private List<String> adultNames;
}
```

### 5. Template Expressions

```java
@Component
public class TemplateExample {
    
    @Value("Welcome #{userBean.name}! Your ID is #{userBean.id}")
    private String welcomeMessage;
    
    @Value("Server: #{systemProperties['server.name']} - Port: #{environment['server.port']}")
    private String serverInfo;
}
```

---

## ðŸ“ Programmatic SpEL Usage

### Basic Usage

```java
public class SpELProgrammatic {
    
    public static void main(String[] args) {
        // Create parser
        ExpressionParser parser = new SpelExpressionParser();
        
        // Parse expression
        Expression exp = parser.parseExpression("'Hello World'.toUpperCase()");
        
        // Evaluate
        String message = (String) exp.getValue();
        System.out.println(message); // "HELLO WORLD"
    }
}
```

### With Context

```java
public class User {
    private String name;
    private int age;
    
    // Constructor, getters, setters
}

public class SpELWithContext {
    
    public static void main(String[] args) {
        ExpressionParser parser = new SpelExpressionParser();
        
        User user = new User("Alice", 30);
        
        // Create evaluation context
        StandardEvaluationContext context = new StandardEvaluationContext(user);
        
        // Access properties
        Expression exp1 = parser.parseExpression("name");
        String name = (String) exp1.getValue(context);
        System.out.println(name); // "Alice"
        
        // Call methods
        Expression exp2 = parser.parseExpression("name.toUpperCase()");
        String upperName = (String) exp2.getValue(context);
        System.out.println(upperName); // "ALICE"
        
        // Complex expression
        Expression exp3 = parser.parseExpression("age >= 18 ? 'Adult' : 'Minor'");
        String ageGroup = (String) exp3.getValue(context);
        System.out.println(ageGroup); // "Adult"
    }
}
```

### Variables

```java
public class SpELVariables {
    
    public static void main(String[] args) {
        ExpressionParser parser = new SpelExpressionParser();
        StandardEvaluationContext context = new StandardEvaluationContext();
        
        // Set variables
        context.setVariable("discount", 0.15);
        context.setVariable("price", 100.0);
        
        // Use variables
        Expression exp = parser.parseExpression("#price * (1 - #discount)");
        Double finalPrice = exp.getValue(context, Double.class);
        System.out.println(finalPrice); // 85.0
    }
}
```

---

## âœ… Best Practices

### 1. **Keep Expressions Simple**

```java
// âœ… Good - simple and readable
@Value("#{configBean.apiUrl}")
private String apiUrl;

// âŒ Avoid - too complex
@Value("#{configBean.apiUrl != null ? configBean.apiUrl.concat('/v1').concat('/users').toUpperCase() : 'DEFAULT'}")
private String endpoint;

// âœ… Better - move complex logic to Java method
@Value("#{configBean.buildEndpoint()}")
private String endpoint;
```

### 2. **Use for Configuration, Not Business Logic**

```java
// âœ… Good - configuration
@Value("#{environment['app.timeout'] ?: 30}")
private int timeout;

// âŒ Avoid - business logic in SpEL
@Value("#{userService.findAll().?[age > 18 and active == true].![calculateBonus()]}")
private List<Double> bonuses;

// âœ… Better - Java method
public List<Double> calculateBonusesForActiveAdults() {
    return userService.findAll().stream()
        .filter(u -> u.getAge() > 18 && u.isActive())
        .map(User::calculateBonus)
        .collect(Collectors.toList());
}
```

### 3. **Null Safety**

```java
// âœ… Use safe navigation operator
@Value("#{userBean?.address?.city ?: 'Unknown'}")
private String city;

// âœ… Use Elvis operator for defaults
@Value("#{configBean.timeout ?: 30}")
private int timeout;
```

### 4. **Performance Considerations**

```java
// âŒ Avoid - evaluated every time accessed
@Value("#{expensiveBean.heavyComputation()}")
private String result;

// âœ… Better - cache in a @PostConstruct
private String result;

@PostConstruct
public void init() {
    result = expensiveBean.heavyComputation();
}
```

### 5. **Testing with SpEL**

```java
@SpringBootTest
public class SpELTest {
    
    @Value("#{2 + 2}")
    private int result;
    
    @Test
    public void testSpEL() {
        assertEquals(4, result);
    }
    
    @Test
    public void testProgrammaticSpEL() {
        ExpressionParser parser = new SpelExpressionParser();
        Expression exp = parser.parseExpression("'Hello' + ' ' + 'World'");
        assertEquals("Hello World", exp.getValue());
    }
}
```

---

## ðŸŽ“ Interview Questions

### Q1: What is SpEL (Spring Expression Language)?
**Answer:**
SpEL is a powerful expression language that supports querying and manipulating object graphs at runtime. It's used for:
- Property injection with @Value
- Conditional bean creation
- Security expressions
- Collection manipulation

```java
@Value("#{systemProperties['user.name']}")
private String userName;

@Value("#{configBean.timeout ?: 30}")
private int timeout;
```

### Q2: What is the syntax for SpEL expressions?
**Answer:**
SpEL expressions use `#{...}` delimiters:

```java
// Literal
@Value("#{42}")

// Property access
@Value("#{systemProperties['java.home']}")

// Method call
@Value("#{'hello'.toUpperCase()}")

// Bean reference
@Value("#{userService.findUser(1)}")

// Operators
@Value("#{10 > 5 ? 'Yes' : 'No'}")
```

### Q3: How do you access bean properties using SpEL?
**Answer:**
```java
@Component
public class ConfigBean {
    private String apiUrl = "https://api.example.com";
    public String getApiUrl() { return apiUrl; }
}

@Component
public class ServiceBean {
    @Value("#{configBean.apiUrl}")
    private String apiUrl;
    
    @Value("#{configBean.apiUrl.concat('/v1')}")
    private String endpoint;
}
```

### Q4: What is the safe navigation operator in SpEL?
**Answer:**
The safe navigation operator `?.` prevents NullPointerException:

```java
// Without safe navigation - throws NPE if userBean is null
@Value("#{userBean.address.city}")

// With safe navigation - returns null if userBean is null
@Value("#{userBean?.address?.city}")

// With default value
@Value("#{userBean?.address?.city ?: 'Unknown'}")
```

### Q5: How to filter collections in SpEL?
**Answer:**
Use selection operators:

```java
// .?[] - filter (all matches)
@Value("#{userList.?[age > 18]}")
private List<User> adults;

// .^[] - first match
@Value("#{userList.^[age > 18]}")
private User firstAdult;

// .$[] - last match
@Value("#{userList.$[age > 18]}")
private User lastAdult;

// .![] - projection (map)
@Value("#{userList.![name]}")
private List<String> names;
```

### Q6: What are SpEL operators?
**Answer:**
SpEL supports various operators:

**Arithmetic:** `+, -, *, /, %, ^`
```java
@Value("#{10 + 5}") // 15
```

**Relational:** `<, >, <=, >=, ==, !=`
```java
@Value("#{10 > 5}") // true
```

**Logical:** `and, or, not`
```java
@Value("#{true and false}") // false
```

**Ternary:** `? :`
```java
@Value("#{user.age >= 18 ? 'Adult' : 'Minor'}")
```

**Elvis:** `?:`
```java
@Value("#{user.name ?: 'Guest'}")
```

**Regex:** `matches`
```java
@Value("#{'test@example.com' matches '.*@.*'}") // true
```

### Q7: How to call static methods in SpEL?
**Answer:**
Use `T()` operator:

```java
// Static method
@Value("#{T(java.lang.Math).random()}")
private double random;

@Value("#{T(java.lang.Math).max(10, 20)}")
private int max;

// Static field
@Value("#{T(java.lang.Math).PI}")
private double pi;

// UUID
@Value("#{T(java.util.UUID).randomUUID().toString()}")
private String uuid;
```

### Q8: What is the difference between #{} and ${}?
**Answer:**
- **`#{expression}`** - SpEL expression, evaluated at runtime
- **`${property}`** - Property placeholder, resolved from properties files

```java
// Property placeholder - from application.properties
@Value("${app.name}")
private String appName;

// SpEL expression - evaluated at runtime
@Value("#{systemProperties['user.name']}")
private String userName;

// Combined - first resolve ${}, then evaluate #{}
@Value("#{environment['${app.property.name}']}")
private String value;
```

### Q9: How to use SpEL in security annotations?
**Answer:**
```java
@PreAuthorize("hasRole('ADMIN')")
public void adminOnly() { }

@PreAuthorize("#username == authentication.principal.username")
public void ownProfile(@PathVariable String username) { }

@PreAuthorize("hasPermission(#order, 'write')")
public void updateOrder(@RequestBody Order order) { }

@PostAuthorize("returnObject.owner == authentication.principal.username")
public Order getOrder(Long id) { }
```

### Q10: How to use SpEL programmatically?
**Answer:**
```java
ExpressionParser parser = new SpelExpressionParser();

// Simple expression
Expression exp = parser.parseExpression("'Hello World'.toUpperCase()");
String result = (String) exp.getValue(); // "HELLO WORLD"

// With context
User user = new User("Alice", 30);
StandardEvaluationContext context = new StandardEvaluationContext(user);

Expression exp2 = parser.parseExpression("name");
String name = (String) exp2.getValue(context); // "Alice"

// With variables
context.setVariable("discount", 0.15);
Expression exp3 = parser.parseExpression("#discount * 100");
Double percent = exp3.getValue(context, Double.class); // 15.0
```

---

## ðŸ“š Summary

SpEL is a powerful runtime expression language in Spring:

1. **Syntax:** `#{expression}` for runtime evaluation
2. **Features:** Property access, method calls, operators, collection manipulation
3. **Use Cases:** @Value injection, security, conditional beans, collection filtering
4. **Operators:** Arithmetic, relational, logical, ternary, Elvis, regex
5. **Collection:** Selection (`.?[]`), projection (`.![]`), first (`.^[]`), last (`.$[]`)
6. **Safety:** Safe navigation (`?.`), Elvis operator (`?:`)
7. **Best Practices:** Keep simple, use for config not business logic, null-safe

SpEL provides powerful runtime expression evaluation throughout the Spring ecosystem!

---

**End of Spring Core Concepts Topics**
