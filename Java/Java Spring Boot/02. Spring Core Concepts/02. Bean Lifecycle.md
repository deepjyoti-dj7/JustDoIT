# ğŸ”„ Spring Bean Lifecycle

## ğŸ“‹ Table of Contents
- [What is Bean Lifecycle?](#what-is-bean-lifecycle)
- [Lifecycle Phases](#lifecycle-phases)
- [Lifecycle Callbacks](#lifecycle-callbacks)
- [Initialization Methods](#initialization-methods)
- [Destruction Methods](#destruction-methods)
- [BeanPostProcessor](#beanpostprocessor)
- [Aware Interfaces](#aware-interfaces)
- [Lifecycle Flow Diagram](#lifecycle-flow-diagram)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ What is Bean Lifecycle?

### Definition
The **Bean Lifecycle** refers to the complete journey of a Spring bean from its instantiation to its destruction, managed entirely by the Spring IoC container.

### Why It Matters
```
âœ… Resource initialization (database connections, file handles)
âœ… Cleanup operations (closing connections, releasing resources)
âœ… Custom business logic execution at specific points
âœ… Integration with Spring container events
âœ… Performance optimization (lazy initialization, caching)
```

### Lifecycle Summary
```
1. Instantiation     â†’ Bean object created
2. Population        â†’ Dependencies injected
3. Initialization    â†’ Custom setup logic
4. Ready to Use      â†’ Bean available in container
5. Destruction       â†’ Cleanup before shutdown
```

---

## ğŸ”„ Lifecycle Phases

### Complete Bean Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SPRING CONTAINER STARTUP                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 1: INSTANTIATION                                  â”‚
â”‚  â”œâ”€ Load Bean Definitions                                â”‚
â”‚  â”œâ”€ Create Bean Instance (Constructor call)              â”‚
â”‚  â””â”€ Allocate memory for bean                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 2: POPULATE PROPERTIES                            â”‚
â”‚  â”œâ”€ Inject dependencies (@Autowired)                     â”‚
â”‚  â”œâ”€ Set property values                                  â”‚
â”‚  â””â”€ Resolve bean references                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 3: AWARE INTERFACES (if implemented)              â”‚
â”‚  â”œâ”€ BeanNameAware.setBeanName()                          â”‚
â”‚  â”œâ”€ BeanClassLoaderAware.setBeanClassLoader()            â”‚
â”‚  â”œâ”€ BeanFactoryAware.setBeanFactory()                    â”‚
â”‚  â”œâ”€ EnvironmentAware.setEnvironment()                    â”‚
â”‚  â”œâ”€ ApplicationContextAware.setApplicationContext()      â”‚
â”‚  â””â”€ ... (other Aware interfaces)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 4: BEANPOSTPROCESSOR - BEFORE INITIALIZATION      â”‚
â”‚  â””â”€ postProcessBeforeInitialization()                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 5: INITIALIZATION                                 â”‚
â”‚  â”œâ”€ @PostConstruct annotated methods                     â”‚
â”‚  â”œâ”€ InitializingBean.afterPropertiesSet()                â”‚
â”‚  â””â”€ Custom init-method                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 6: BEANPOSTPROCESSOR - AFTER INITIALIZATION       â”‚
â”‚  â””â”€ postProcessAfterInitialization()                     â”‚
â”‚     (AOP proxies created here)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 7: READY FOR USE                                  â”‚
â”‚  â””â”€ Bean is fully initialized and ready                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
                  (Bean in use)
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 8: DESTRUCTION (Container shutdown)               â”‚
â”‚  â”œâ”€ @PreDestroy annotated methods                        â”‚
â”‚  â”œâ”€ DisposableBean.destroy()                             â”‚
â”‚  â””â”€ Custom destroy-method                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¬ Lifecycle Callbacks

### Complete Example

```java
import org.springframework.beans.factory.BeanNameAware;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class UserService implements BeanNameAware, 
                                    ApplicationContextAware,
                                    InitializingBean,
                                    DisposableBean {
    
    private UserRepository repository;
    private String beanName;
    private ApplicationContext applicationContext;
    
    // 1. Constructor (Instantiation)
    public UserService() {
        System.out.println("1. Constructor called");
    }
    
    // 2. Dependency Injection
    @Autowired
    public void setRepository(UserRepository repository) {
        System.out.println("2. Dependencies injected");
        this.repository = repository;
    }
    
    // 3. BeanNameAware
    @Override
    public void setBeanName(String name) {
        System.out.println("3. BeanNameAware: " + name);
        this.beanName = name;
    }
    
    // 4. ApplicationContextAware
    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        System.out.println("4. ApplicationContextAware");
        this.applicationContext = ctx;
    }
    
    // 5. @PostConstruct
    @PostConstruct
    public void postConstruct() {
        System.out.println("5. @PostConstruct called");
        // Initialize resources, caches
    }
    
    // 6. InitializingBean interface
    @Override
    public void afterPropertiesSet() {
        System.out.println("6. afterPropertiesSet() called");
        // Validate configuration
    }
    
    // 7. Custom init method (if configured)
    public void customInit() {
        System.out.println("7. Custom init method called");
    }
    
    // Bean is now ready to use!
    
    // 8. @PreDestroy
    @PreDestroy
    public void preDestroy() {
        System.out.println("8. @PreDestroy called");
        // Cleanup, close connections
    }
    
    // 9. DisposableBean interface
    @Override
    public void destroy() {
        System.out.println("9. destroy() called");
        // Release resources
    }
    
    // 10. Custom destroy method (if configured)
    public void customDestroy() {
        System.out.println("10. Custom destroy method called");
    }
}
```

### Configuration
```java
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public UserService userService() {
        return new UserService();
    }
}
```

### Output
```
1. Constructor called
2. Dependencies injected
3. BeanNameAware: userService
4. ApplicationContextAware
5. @PostConstruct called
6. afterPropertiesSet() called
7. Custom init method called
--- Bean Ready ---
8. @PreDestroy called
9. destroy() called
10. Custom destroy method called
```

---

## ğŸš€ Initialization Methods

### Method 1: @PostConstruct (Recommended)

```java
import javax.annotation.PostConstruct;

@Component
public class DatabaseService {
    
    @Autowired
    private DataSource dataSource;
    
    @PostConstruct
    public void initialize() {
        System.out.println("Initializing database connection pool");
        // Setup connection pool
        // Validate database schema
        // Warm up caches
    }
}
```

**Advantages:**
- âœ… Standard JSR-250 annotation
- âœ… No framework dependency
- âœ… Clear and explicit
- âœ… Works with all bean creation methods

### Method 2: InitializingBean Interface

```java
import org.springframework.beans.factory.InitializingBean;

@Component
public class CacheService implements InitializingBean {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("All properties set, initializing cache");
        // Verify Redis connection
        // Preload frequently accessed data
        // Set expiration policies
    }
}
```

**Advantages:**
- âœ… Guaranteed all properties are set
- âœ… Can throw exceptions
- âŒ Couples code to Spring framework

### Method 3: Custom Init Method

```java
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "init")
    public EmailService emailService() {
        return new EmailService();
    }
}

public class EmailService {
    
    public void init() {
        System.out.println("Initializing email service");
        // Connect to SMTP server
        // Verify authentication
        // Load email templates
    }
}
```

**Advantages:**
- âœ… No annotations needed
- âœ… Framework-agnostic
- âœ… Flexible method naming
- âŒ Requires explicit configuration

### Method 4: @Bean with Lambda

```java
@Configuration
public class AppConfig {
    
    @Bean(initMethod = "connect")
    public MessageBroker messageBroker() {
        MessageBroker broker = new MessageBroker();
        broker.setHost("localhost");
        broker.setPort(5672);
        return broker;
    }
}
```

### Initialization Order

When multiple initialization methods exist:
```
1. @PostConstruct
2. InitializingBean.afterPropertiesSet()
3. Custom init-method
```

---

## ğŸ’¥ Destruction Methods

### Method 1: @PreDestroy (Recommended)

```java
import javax.annotation.PreDestroy;

@Component
public class FileService {
    
    private BufferedWriter writer;
    
    @PostConstruct
    public void init() throws IOException {
        writer = new BufferedWriter(
            new FileWriter("application.log")
        );
    }
    
    @PreDestroy
    public void cleanup() {
        System.out.println("Closing file handles");
        try {
            if (writer != null) {
                writer.flush();
                writer.close();
            }
        } catch (IOException e) {
            System.err.println("Error closing writer: " + e.getMessage());
        }
    }
}
```

### Method 2: DisposableBean Interface

```java
import org.springframework.beans.factory.DisposableBean;

@Component
public class ConnectionPoolService implements DisposableBean {
    
    private HikariDataSource dataSource;
    
    @Override
    public void destroy() {
        System.out.println("Shutting down connection pool");
        if (dataSource != null) {
            dataSource.close();
        }
    }
}
```

### Method 3: Custom Destroy Method

```java
@Configuration
public class AppConfig {
    
    @Bean(destroyMethod = "shutdown")
    public SchedulerService schedulerService() {
        return new SchedulerService();
    }
}

public class SchedulerService {
    
    private ScheduledExecutorService executor;
    
    public void init() {
        executor = Executors.newScheduledThreadPool(5);
    }
    
    public void shutdown() {
        System.out.println("Shutting down scheduler");
        if (executor != null) {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
            }
        }
    }
}
```

### Destruction Order

When multiple destruction methods exist:
```
1. @PreDestroy
2. DisposableBean.destroy()
3. Custom destroy-method
```

### Auto-Detection of Close/Shutdown

```java
@Configuration
public class AppConfig {
    
    // Spring auto-detects close() or shutdown() methods
    @Bean(destroyMethod = "(inferred)")
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        // Spring will call ds.close() automatically
        return ds;
    }
    
    // Disable auto-destruction
    @Bean(destroyMethod = "")
    public DataSource manualDataSource() {
        // close() won't be called
        return new HikariDataSource();
    }
}
```

---

## ğŸ”§ BeanPostProcessor

### What is BeanPostProcessor?

A powerful interface that allows custom modification of new bean instances **before and after** initialization.

### Implementation

```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;

@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(
            Object bean, String beanName) throws BeansException {
        
        System.out.println("Before Initialization: " + beanName);
        
        // Custom logic before initialization
        if (bean instanceof UserService) {
            System.out.println("Processing UserService bean");
        }
        
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(
            Object bean, String beanName) throws BeansException {
        
        System.out.println("After Initialization: " + beanName);
        
        // This is where AOP proxies are created!
        // Wrap bean in a proxy if needed
        
        return bean;
    }
}
```

### Real-World Example: Logging Proxy

```java
@Component
public class LoggingBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessAfterInitialization(
            Object bean, String beanName) throws BeansException {
        
        // Add logging to all service beans
        if (bean.getClass().isAnnotationPresent(Service.class)) {
            return Proxy.newProxyInstance(
                bean.getClass().getClassLoader(),
                bean.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    System.out.println("Calling: " + method.getName());
                    long start = System.currentTimeMillis();
                    Object result = method.invoke(bean, args);
                    long duration = System.currentTimeMillis() - start;
                    System.out.println("Execution time: " + duration + "ms");
                    return result;
                }
            );
        }
        
        return bean;
    }
}
```

### Built-in BeanPostProcessors

Spring provides several built-in processors:

```java
// 1. AutowiredAnnotationBeanPostProcessor
//    - Processes @Autowired, @Value, @Inject

// 2. CommonAnnotationBeanPostProcessor
//    - Processes @PostConstruct, @PreDestroy, @Resource

// 3. PersistenceAnnotationBeanPostProcessor
//    - Processes @PersistenceContext, @PersistenceUnit

// 4. ApplicationContextAwareProcessor
//    - Invokes Aware interface methods

// 5. AbstractAutoProxyCreator
//    - Creates AOP proxies
```

---

## ğŸ¯ Aware Interfaces

Spring provides several `Aware` interfaces to give beans access to Spring infrastructure.

### Common Aware Interfaces

```java
@Component
public class ApplicationBean implements 
    BeanNameAware,              // Get bean name
    BeanClassLoaderAware,       // Get class loader
    BeanFactoryAware,           // Get bean factory
    EnvironmentAware,           // Get environment
    ApplicationEventPublisherAware,  // Publish events
    MessageSourceAware,         // Get message source (i18n)
    ApplicationContextAware,    // Get application context
    ResourceLoaderAware {       // Load resources
    
    private String beanName;
    private ApplicationContext context;
    private Environment environment;
    
    @Override
    public void setBeanName(String name) {
        this.beanName = name;
        System.out.println("Bean name: " + name);
    }
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
        System.out.println("Got ApplicationContext");
    }
    
    @Override
    public void setEnvironment(Environment env) {
        this.environment = env;
        String profile = env.getProperty("spring.profiles.active");
        System.out.println("Active profile: " + profile);
    }
    
    // Other Aware implementations...
}
```

### BeanNameAware Example

```java
@Component
public class NameAwareService implements BeanNameAware {
    
    private String beanIdentifier;
    
    @Override
    public void setBeanName(String name) {
        this.beanIdentifier = name;
    }
    
    public void printBeanName() {
        System.out.println("I am: " + beanIdentifier);
    }
}
```

### ApplicationContextAware Example

```java
@Component
public class DynamicBeanRetriever implements ApplicationContextAware {
    
    private ApplicationContext context;
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }
    
    public <T> T getBean(Class<T> beanClass) {
        return context.getBean(beanClass);
    }
    
    public void printAllBeanNames() {
        String[] beans = context.getBeanDefinitionNames();
        Arrays.stream(beans).forEach(System.out::println);
    }
}
```

### EnvironmentAware Example

```java
@Component
public class ConfigurationService implements EnvironmentAware {
    
    private Environment environment;
    
    @Override
    public void setEnvironment(Environment env) {
        this.environment = env;
    }
    
    @PostConstruct
    public void init() {
        String dbUrl = environment.getProperty("spring.datasource.url");
        String[] profiles = environment.getActiveProfiles();
        
        System.out.println("Database URL: " + dbUrl);
        System.out.println("Active profiles: " + 
            Arrays.toString(profiles));
    }
}
```

### âš ï¸ Best Practice

**Prefer Dependency Injection over Aware interfaces when possible:**

```java
// âŒ Avoid - couples to Spring
@Component
public class MyService implements ApplicationContextAware {
    private ApplicationContext context;
    
    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        this.context = ctx;
    }
}

// âœ… Better - use @Autowired
@Component
public class MyService {
    @Autowired
    private ApplicationContext context;
}

// âœ… Best - don't access context directly
@Component
public class MyService {
    @Autowired
    private UserRepository repository; // Inject what you need
}
```

---

## ğŸ“Š Lifecycle Flow Diagram

### Detailed Execution Flow

```java
public class LifecycleDemo {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        System.out.println("\n=== BEAN IS READY ===\n");
        
        // Use the bean
        UserService service = context.getBean(UserService.class);
        service.doWork();
        
        System.out.println("\n=== SHUTTING DOWN ===\n");
        context.close();
    }
}
```

### Output Flow

```
--- Container Starting ---
1. Loading bean definitions
2. Creating bean: userService
   â”œâ”€ Constructor called
   â”œâ”€ Setting properties
   â”œâ”€ Calling BeanNameAware
   â”œâ”€ Calling ApplicationContextAware
   â”œâ”€ BeanPostProcessor.before (all processors)
   â”œâ”€ @PostConstruct
   â”œâ”€ afterPropertiesSet()
   â”œâ”€ init-method
   â””â”€ BeanPostProcessor.after (all processors, AOP proxies)

=== BEAN IS READY ===
User service doing work...

=== SHUTTING DOWN ===
   â”œâ”€ @PreDestroy
   â”œâ”€ destroy()
   â””â”€ destroy-method
--- Container Stopped ---
```

---

## âœ… Best Practices

### 1. **Choose the Right Initialization Method**

```java
// âœ… Good - Use @PostConstruct for most cases
@Component
public class MyService {
    @PostConstruct
    public void init() {
        // Standard, clean, framework-agnostic
    }
}

// âš ï¸ Use InitializingBean when you need to throw checked exceptions
@Component
public class DatabaseService implements InitializingBean {
    @Override
    public void afterPropertiesSet() throws SQLException {
        // Can throw checked exceptions
        validateDatabaseConnection();
    }
}

// âš ï¸ Use custom init-method for legacy code integration
@Bean(initMethod = "setup")
public LegacyService legacyService() {
    return new LegacyService();
}
```

### 2. **Proper Resource Cleanup**

```java
@Component
public class ResourceService {
    private ExecutorService executor;
    private Connection connection;
    
    @PostConstruct
    public void init() {
        executor = Executors.newFixedThreadPool(10);
        connection = dataSource.getConnection();
    }
    
    @PreDestroy
    public void cleanup() {
        // Always cleanup in reverse order of creation
        if (connection != null) {
            try { connection.close(); } 
            catch (SQLException e) { /* log */ }
        }
        
        if (executor != null) {
            executor.shutdown();
            try {
                executor.awaitTermination(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                executor.shutdownNow();
            }
        }
    }
}
```

### 3. **Avoid Heavy Operations in Constructor**

```java
// âŒ Bad - heavy work in constructor
@Component
public class ReportService {
    public ReportService() {
        // Blocks container startup!
        generateMonthlyReports();
        sendEmailNotifications();
    }
}

// âœ… Good - heavy work in @PostConstruct or async
@Component
public class ReportService {
    
    @Autowired
    private ApplicationEventPublisher publisher;
    
    @PostConstruct
    public void init() {
        // Publish event for async processing
        publisher.publishEvent(new ApplicationReadyEvent());
    }
    
    @EventListener(ApplicationReadyEvent.class)
    @Async
    public void onApplicationReady() {
        // Heavy work happens asynchronously
        generateMonthlyReports();
    }
}
```

### 4. **Handle Exceptions Gracefully**

```java
@Component
public class CacheService {
    
    @PostConstruct
    public void initialize() {
        try {
            connectToRedis();
            warmUpCache();
        } catch (Exception e) {
            // Log but allow application to start
            log.error("Cache initialization failed, using fallback", e);
            useFallbackCache();
        }
    }
    
    @PreDestroy
    public void shutdown() {
        try {
            flushCache();
            disconnectFromRedis();
        } catch (Exception e) {
            // Log but don't prevent shutdown
            log.error("Error during cache shutdown", e);
        }
    }
}
```

### 5. **Prototype Beans Don't Get Destroy Callbacks**

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    
    @PreDestroy
    public void destroy() {
        // âš ï¸ This will NEVER be called for prototype beans!
    }
}

// Solution: Manual cleanup
@Component
public class PrototypeBeanManager implements DisposableBean {
    private List<PrototypeBean> beans = new ArrayList<>();
    
    public PrototypeBean createBean() {
        PrototypeBean bean = context.getBean(PrototypeBean.class);
        beans.add(bean);
        return bean;
    }
    
    @Override
    public void destroy() {
        // Manually cleanup prototype beans
        beans.forEach(PrototypeBean::cleanup);
    }
}
```

---

## ğŸ“ Interview Questions

### Q1: What are the phases of Spring Bean Lifecycle?
**Answer:**
The Spring bean lifecycle consists of these phases:
1. **Instantiation:** Container creates bean instance using constructor
2. **Population:** Dependencies are injected (@Autowired)
3. **Aware Interfaces:** Container calls Aware interface methods (BeanNameAware, ApplicationContextAware, etc.)
4. **Pre-Initialization:** BeanPostProcessor.postProcessBeforeInitialization()
5. **Initialization:** @PostConstruct â†’ afterPropertiesSet() â†’ custom init-method
6. **Post-Initialization:** BeanPostProcessor.postProcessAfterInitialization() (AOP proxies created)
7. **Ready to Use:** Bean is fully initialized
8. **Destruction:** @PreDestroy â†’ destroy() â†’ custom destroy-method

### Q2: What are the different ways to initialize a bean?
**Answer:**
Three ways to initialize beans:

```java
// 1. @PostConstruct (Recommended)
@PostConstruct
public void init() { }

// 2. InitializingBean interface
public void afterPropertiesSet() throws Exception { }

// 3. Custom init-method
@Bean(initMethod = "customInit")
```

**Execution order:** @PostConstruct â†’ afterPropertiesSet() â†’ custom init-method

### Q3: What is BeanPostProcessor?
**Answer:**
BeanPostProcessor is a factory hook that allows custom modification of bean instances. It has two methods:
- `postProcessBeforeInitialization()` - called before init methods
- `postProcessAfterInitialization()` - called after init methods (creates AOP proxies)

```java
@Component
public class MyBeanPostProcessor implements BeanPostProcessor {
    public Object postProcessAfterInitialization(Object bean, String name) {
        // Wrap bean in proxy, add logging, etc.
        return bean;
    }
}
```

### Q4: Difference between @PostConstruct and InitializingBean?
**Answer:**
| @PostConstruct | InitializingBean |
|----------------|------------------|
| JSR-250 standard | Spring-specific interface |
| No framework coupling | Couples code to Spring |
| Cannot throw checked exceptions | Can throw checked exceptions |
| Method can have any name | Must implement afterPropertiesSet() |
| Recommended approach | Use when checked exceptions needed |

### Q5: What are Aware interfaces?
**Answer:**
Aware interfaces allow beans to access Spring infrastructure:
- `BeanNameAware` - Get bean name
- `ApplicationContextAware` - Get ApplicationContext
- `BeanFactoryAware` - Get BeanFactory
- `EnvironmentAware` - Get Environment
- `ResourceLoaderAware` - Load resources

**Best Practice:** Prefer @Autowired over Aware interfaces when possible.

### Q6: How to perform cleanup when bean is destroyed?
**Answer:**
Three ways:

```java
// 1. @PreDestroy
@PreDestroy
public void cleanup() { }

// 2. DisposableBean interface
public void destroy() throws Exception { }

// 3. Custom destroy-method
@Bean(destroyMethod = "customDestroy")
```

**Order:** @PreDestroy â†’ destroy() â†’ custom destroy-method

### Q7: Do prototype beans have destruction callbacks?
**Answer:**
**NO!** Spring does not manage the complete lifecycle of prototype beans. The container creates and injects them but doesn't call destruction callbacks. You must manually manage cleanup for prototype beans.

```java
@Scope("prototype")
public class PrototypeBean {
    @PreDestroy
    public void destroy() {
        // Never called!
    }
}
```

### Q8: When is BeanPostProcessor called?
**Answer:**
- `postProcessBeforeInitialization()` - After Aware interfaces, before @PostConstruct
- `postProcessAfterInitialization()` - After all initialization methods

This is where Spring creates AOP proxies around beans.

### Q9: Can you have multiple initialization methods?
**Answer:**
Yes, and they execute in this order:
1. @PostConstruct
2. afterPropertiesSet()
3. custom init-method

But it's better to use only one to avoid confusion.

### Q10: How does Spring manage bean lifecycle for different scopes?
**Answer:**
- **Singleton:** Full lifecycle management (creation to destruction)
- **Prototype:** Creation and injection only, no destruction callbacks
- **Request/Session:** Full lifecycle within HTTP request/session scope
- **Custom scopes:** Depends on scope implementation

---

## ğŸ“š Summary

The Spring Bean Lifecycle provides powerful hooks for resource management and custom initialization:

1. **Phases:** Instantiation â†’ Population â†’ Aware â†’ Pre-Init â†’ Initialization â†’ Post-Init â†’ Ready â†’ Destruction
2. **Initialization:** Use @PostConstruct (recommended), InitializingBean, or custom init-method
3. **Destruction:** Use @PreDestroy, DisposableBean, or custom destroy-method
4. **BeanPostProcessor:** Intercept and modify beans before/after initialization (AOP happens here)
5. **Aware Interfaces:** Access Spring infrastructure (prefer @Autowired when possible)
6. **Scope Impact:** Only singleton beans get full lifecycle management

---

**Next Topic:** [ApplicationContext â†’](./03.%20ApplicationContext.md)
