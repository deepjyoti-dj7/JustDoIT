# üîç Component Scanning in Spring

## üìã Table of Contents
- [What is Component Scanning?](#what-is-component-scanning)
- [Stereotype Annotations](#stereotype-annotations)
- [Enabling Component Scanning](#enabling-component-scanning)
- [Scanning Configuration](#scanning-configuration)
- [Include & Exclude Filters](#include--exclude-filters)
- [Component Detection](#component-detection)
- [Custom Components](#custom-components)
- [Performance Optimization](#performance-optimization)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is Component Scanning?

### Definition
**Component Scanning** is Spring's mechanism to automatically detect and register beans by scanning specified packages for classes annotated with stereotype annotations (@Component, @Service, @Repository, @Controller).

### How It Works

```
1. Scan specified packages
2. Detect classes with stereotype annotations
3. Create bean definitions
4. Register in ApplicationContext
5. Manage bean lifecycle
```

### Benefits

```
‚úÖ Eliminates XML configuration
‚úÖ Reduces boilerplate code
‚úÖ Convention over configuration
‚úÖ Automatic dependency injection
‚úÖ Faster development
```

---

## üè∑Ô∏è Stereotype Annotations

### Core Annotations

```java
// 1. @Component - Generic component
@Component
public class UtilityService {
    public String process(String data) {
        return data.toUpperCase();
    }
}

// 2. @Service - Business logic layer
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
    
    public User findUser(Long id) {
        return repository.findById(id).orElse(null);
    }
}

// 3. @Repository - Data access layer
@Repository
public class UserRepositoryImpl implements UserRepository {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findById(Long id) {
        return jdbcTemplate.queryForObject(
            "SELECT * FROM users WHERE id = ?",
            new UserRowMapper(),
            id
        );
    }
}

// 4. @Controller - MVC controller
@Controller
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/users/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        model.addAttribute("user", userService.findUser(id));
        return "user-details";
    }
}

// 5. @RestController - REST API controller
@RestController
@RequestMapping("/api/users")
public class UserRestController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findUser(id);
    }
}

// 6. @Configuration - Configuration class
@Configuration
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}
```

### Annotation Hierarchy

```
         @Component
              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         ‚îÇ         ‚îÇ
@Service  @Repository @Controller
                         ‚îÇ
                  @RestController
```

### Special Features

```java
// @Repository - Exception translation
@Repository
public class UserDao {
    // SQLException automatically translated to DataAccessException
    public void save(User user) throws SQLException {
        // JDBC code
    }
}

// @Service - No special features, semantic clarity
@Service
public class UserService {
    // Business logic
}

// @Controller - Request mapping support
@Controller
public class UserController {
    // MVC support
}
```

---

## üöÄ Enabling Component Scanning

### Method 1: @ComponentScan (Java Config)

```java
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    // Scans com.example and all subpackages
}

// Multiple packages
@Configuration
@ComponentScan(basePackages = {
    "com.example.service",
    "com.example.repository",
    "com.example.controller"
})
public class AppConfig {
}

// Type-safe package scanning
@Configuration
@ComponentScan(basePackageClasses = {
    UserService.class,
    ProductService.class
})
public class AppConfig {
    // Scans packages containing these classes
}
```

### Method 2: @SpringBootApplication

```java
@SpringBootApplication
// Equivalent to:
// @Configuration
// @EnableAutoConfiguration
// @ComponentScan (current package + subpackages)
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Method 3: XML Configuration

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">
    
    <!-- Enable component scanning -->
    <context:component-scan base-package="com.example"/>
    
</beans>
```

### Method 4: Programmatic Registration

```java
public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext();
        
        // Programmatic scanning
        context.scan("com.example.service", "com.example.repository");
        context.refresh();
        
        UserService service = context.getBean(UserService.class);
        context.close();
    }
}
```

---

## ‚öôÔ∏è Scanning Configuration

### Base Package Scanning

```java
// Single package
@ComponentScan("com.example")

// Multiple packages
@ComponentScan({"com.example.service", "com.example.repository"})

// Type-safe with classes
@ComponentScan(basePackageClasses = {ServiceMarker.class})

// Current package and subpackages (default)
@ComponentScan
```

### Naming Beans

```java
// Default naming - class name with lowercase first letter
@Component
public class UserService {} // Bean name: userService

// Custom bean name
@Component("customUserService")
public class UserService {} // Bean name: customUserService

@Service("userBusinessService")
public class UserService {} // Bean name: userBusinessService
```

### Lazy Initialization

```java
// Lazy single bean
@Component
@Lazy
public class HeavyService {
    // Created only when first requested
}

// Lazy all scanned beans
@Configuration
@ComponentScan(
    basePackages = "com.example",
    lazyInit = true
)
public class AppConfig {
}
```

### Scope Configuration

```java
@Component
@Scope("prototype")
public class PrototypeBean {
}

@Service
@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)
public class SingletonService {
}
```

---

## üéõÔ∏è Include & Exclude Filters

### Filter Types

```java
public enum FilterType {
    ANNOTATION,        // Filter by annotation
    ASSIGNABLE_TYPE,   // Filter by class/interface
    ASPECTJ,          // AspectJ type patterns
    REGEX,            // Regular expression patterns
    CUSTOM            // Custom TypeFilter implementation
}
```

### Include Filters

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = {
        // Include specific annotation
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = MyCustomAnnotation.class
        ),
        
        // Include specific class
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = SpecialService.class
        ),
        
        // Include by regex
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = ".*Service.*"
        )
    },
    useDefaultFilters = false // Disable default @Component detection
)
public class AppConfig {
}
```

### Exclude Filters

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = {
        // Exclude @Configuration classes
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = Configuration.class
        ),
        
        // Exclude specific classes
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = {LegacyService.class, TestService.class}
        ),
        
        // Exclude by package pattern
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = "com\\.example\\.test\\..*"
        ),
        
        // Exclude by AspectJ pattern
        @ComponentScan.Filter(
            type = FilterType.ASPECTJ,
            pattern = "com.example..*Test"
        )
    }
)
public class AppConfig {
}
```

### Custom Filter

```java
// Custom TypeFilter implementation
public class CustomTypeFilter implements TypeFilter {
    
    @Override
    public boolean match(MetadataReader metadataReader,
                        MetadataReaderFactory metadataReaderFactory) {
        
        // Get class metadata
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        String className = classMetadata.getClassName();
        
        // Custom logic - exclude classes ending with "Impl"
        return !className.endsWith("Impl");
    }
}

// Use custom filter
@Configuration
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.CUSTOM,
        classes = CustomTypeFilter.class
    )
)
public class AppConfig {
}
```

### Real-World Examples

```java
// Example 1: Only scan services and repositories
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, 
            classes = {Service.class, Repository.class})
    },
    excludeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, 
            classes = {Controller.class})
    },
    useDefaultFilters = false
)
public class ServiceConfig {
}

// Example 2: Exclude test classes
@Configuration
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*Test.*"
    )
)
public class ProductionConfig {
}

// Example 3: Include only specific package
@Configuration
@ComponentScan(
    basePackages = "com.example",
    includeFilters = @ComponentScan.Filter(
        type = FilterType.ASPECTJ,
        pattern = "com.example.service..*"
    ),
    useDefaultFilters = false
)
public class ServiceLayerConfig {
}
```

---

## üîé Component Detection

### Detection Process

```java
// 1. Class must be in scanned package
package com.example.service;

// 2. Must have stereotype annotation
@Service
public class UserService {
    
    // 3. Dependencies are auto-wired
    @Autowired
    private UserRepository repository;
    
    // 4. Bean registered with name "userService"
}
```

### Component Index (Spring 5+)

```xml
<!-- pom.xml - Generates component index at compile time -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-indexer</artifactId>
    <optional>true</optional>
</dependency>
```

```
Generates: META-INF/spring.components

Benefits:
‚úÖ Faster startup (no classpath scanning)
‚úÖ Better for large applications
‚úÖ AOT (Ahead-of-Time) compilation support
```

### Conditional Component Registration

```java
// Register only if condition is true
@Component
@Conditional(OnDevelopmentProfileCondition.class)
public class DevOnlyService {
}

public class OnDevelopmentProfileCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, 
                          AnnotatedTypeMetadata metadata) {
        return Arrays.asList(context.getEnvironment().getActiveProfiles())
                    .contains("development");
    }
}

// Spring Boot provides many built-in conditionals
@Service
@ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
public class FeatureService {
}

@Repository
@ConditionalOnClass(name = "org.postgresql.Driver")
public class PostgresRepository {
}
```

---

## üé® Custom Components

### Creating Custom Stereotype Annotation

```java
// 1. Define custom annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component // Meta-annotation - makes it a component
public @interface ExternalService {
    
    @AliasFor(annotation = Component.class)
    String value() default "";
    
    String apiUrl() default "";
    
    int timeout() default 30;
}

// 2. Use custom annotation
@ExternalService(
    value = "paymentService",
    apiUrl = "https://api.payment.com",
    timeout = 60
)
public class PaymentService {
    
    @Value("#{@paymentService.apiUrl}")
    private String apiUrl;
    
    public void processPayment() {
        // Use apiUrl
    }
}

// 3. Scan will automatically detect it
@Configuration
@ComponentScan("com.example")
public class AppConfig {
}
```

### Meta-Annotations

```java
// Custom service annotation with transaction support
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Service
@Transactional
public @interface TransactionalService {
    
    @AliasFor(annotation = Service.class)
    String value() default "";
    
    @AliasFor(annotation = Transactional.class, attribute = "readOnly")
    boolean readOnly() default false;
}

// Usage
@TransactionalService(readOnly = true)
public class QueryService {
    // Automatically @Service + @Transactional(readOnly=true)
}
```

---

## ‚ö° Performance Optimization

### 1. Limit Scan Scope

```java
// ‚ùå Slow - scans too many packages
@ComponentScan("com")

// ‚úÖ Fast - specific packages
@ComponentScan({
    "com.example.service",
    "com.example.repository"
})

// ‚úÖ Better - type-safe scanning
@ComponentScan(basePackageClasses = {
    ServicePackage.class,
    RepositoryPackage.class
})
```

### 2. Use Component Index

```xml
<!-- Add spring-context-indexer -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-indexer</artifactId>
    <scope>optional</scope>
</dependency>
```

### 3. Lazy Initialization

```java
// Lazy init all beans
@Configuration
@ComponentScan(
    basePackages = "com.example",
    lazyInit = true
)
public class AppConfig {
}

// Or in application.properties
spring.main.lazy-initialization=true
```

### 4. Exclude Unnecessary Classes

```java
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = ".*Test.*|.*Mock.*|.*Stub.*"
        )
    }
)
```

### 5. Avoid Circular Dependencies

```java
// ‚ùå Circular dependency
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA; // Circular!
}

// ‚úÖ Solution 1: Constructor injection + @Lazy
@Service
public class ServiceA {
    private final ServiceB serviceB;
    
    public ServiceA(@Lazy ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}

// ‚úÖ Solution 2: Refactor to remove circular dependency
@Service
public class ServiceA {
    @Autowired
    private CommonService commonService;
}

@Service
public class ServiceB {
    @Autowired
    private CommonService commonService;
}
```

---

## ‚úÖ Best Practices

### 1. **Use Type-Safe Package Scanning**

```java
// ‚ùå String-based - typo-prone, refactoring issues
@ComponentScan("com.example.service")

// ‚úÖ Type-safe - refactoring-safe
@ComponentScan(basePackageClasses = ServiceMarker.class)

// Marker interface/class
package com.example.service;
public interface ServiceMarker {
}
```

### 2. **Follow Package Structure**

```
com.example
‚îú‚îÄ‚îÄ config/          ‚Üí @Configuration
‚îú‚îÄ‚îÄ controller/      ‚Üí @Controller, @RestController
‚îú‚îÄ‚îÄ service/         ‚Üí @Service
‚îú‚îÄ‚îÄ repository/      ‚Üí @Repository
‚îî‚îÄ‚îÄ util/           ‚Üí @Component
```

### 3. **Use Meaningful Bean Names**

```java
// ‚ùå Generic names
@Service("service1")

// ‚úÖ Descriptive names
@Service("userRegistrationService")
@Service // Auto-generated: userService
public class UserService {
}
```

### 4. **Prefer Constructor Injection**

```java
// ‚ùå Field injection
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
}

// ‚úÖ Constructor injection
@Service
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

### 5. **Use Proper Stereotypes**

```java
// ‚úÖ Semantic clarity
@Repository
public class UserRepository {
    // Data access
}

@Service
public class UserService {
    // Business logic
}

@Controller
public class UserController {
    // Web layer
}

// ‚ùå Don't use @Component for everything
@Component // Should be @Service
public class UserService {
}
```

### 6. **Avoid Component Scanning for Configuration**

```java
// ‚úÖ Good - explicit @Configuration
@Configuration
@ComponentScan("com.example")
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}

// ‚ùå Avoid - scanning for @Configuration
// Can cause issues with component order
```

---

## üéì Interview Questions

### Q1: What is component scanning in Spring?
**Answer:**
Component scanning is Spring's mechanism to automatically detect and register beans by scanning specified packages for classes annotated with stereotype annotations (@Component, @Service, @Repository, @Controller).

```java
@ComponentScan("com.example")
public class AppConfig {
    // Automatically scans and registers annotated classes
}
```

### Q2: What are stereotype annotations?
**Answer:**
Stereotype annotations are specializations of @Component that indicate specific roles:
- **@Component** - Generic component
- **@Service** - Business logic layer
- **@Repository** - Data access layer (exception translation)
- **@Controller** - MVC controller
- **@RestController** - REST API controller
- **@Configuration** - Configuration class

### Q3: What is the difference between @Component and @Service?
**Answer:**
- **Functionally**: No difference, both create beans
- **Semantically**: @Service indicates business logic layer
- **Special features**: @Repository provides exception translation, others are purely semantic

```java
@Component // Generic
public class UtilityClass {
}

@Service // Business logic (semantic)
public class UserService {
}
```

### Q4: How do you enable component scanning?
**Answer:**
Three ways:

```java
// 1. @ComponentScan
@Configuration
@ComponentScan("com.example")
public class AppConfig {
}

// 2. @SpringBootApplication (includes @ComponentScan)
@SpringBootApplication
public class Application {
}

// 3. XML
<context:component-scan base-package="com.example"/>
```

### Q5: What is the default bean name for scanned components?
**Answer:**
The class name with the first letter in lowercase.

```java
@Component
public class UserService {} // Bean name: userService

@Service("customName")
public class UserService {} // Bean name: customName
```

### Q6: How to exclude certain classes from component scanning?
**Answer:**
Use excludeFilters:

```java
@ComponentScan(
    basePackages = "com.example",
    excludeFilters = @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*Test.*"
    )
)
```

Filter types: ANNOTATION, ASSIGNABLE_TYPE, REGEX, ASPECTJ, CUSTOM

### Q7: What is the difference between @ComponentScan basePackages and basePackageClasses?
**Answer:**
- **basePackages**: String-based, prone to typos, not refactoring-safe
  ```java
  @ComponentScan(basePackages = "com.example")
  ```
- **basePackageClasses**: Type-safe, refactoring-safe
  ```java
  @ComponentScan(basePackageClasses = ServiceMarker.class)
  ```

### Q8: How does @Repository differ from @Component?
**Answer:**
@Repository provides automatic exception translation - converts database exceptions (SQLException) into Spring's DataAccessException hierarchy.

```java
@Repository
public class UserDao {
    public void save() throws SQLException {
        // SQLException auto-converted to DataAccessException
    }
}
```

### Q9: Can you create custom stereotype annotations?
**Answer:**
Yes, by meta-annotating with @Component:

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface MyService {
    String value() default "";
}

@MyService
public class CustomService {
    // Automatically detected as component
}
```

### Q10: What is component index and why use it?
**Answer:**
Component index (spring.components) is a compile-time generated index of components that speeds up startup by avoiding runtime classpath scanning.

```xml
<!-- Add dependency -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-indexer</artifactId>
</dependency>
```

Benefits: Faster startup, especially for large applications.

---

## üìö Summary

Component scanning automates bean discovery and registration:

1. **Stereotype Annotations**: @Component, @Service, @Repository, @Controller indicate bean roles
2. **Enable Scanning**: @ComponentScan, @SpringBootApplication, or XML configuration
3. **Filters**: Include/exclude classes based on annotation, type, regex, AspectJ, or custom logic
4. **Performance**: Use type-safe scanning, component index, lazy initialization, limit scope
5. **Best Practices**: Proper package structure, meaningful names, constructor injection

Component scanning is the foundation of Spring's convention-over-configuration approach!

---

**Next Topic:** [Spring Profiles ‚Üí](./06.%20Spring%20Profiles.md)
