# âš™ï¸ Security Configuration - Complete Guide

## ðŸ“‹ Table of Contents
- [Introduction](#introduction)
- [Basic Configuration](#basic-configuration)
- [SecurityFilterChain](#securityfilterchain)
- [Custom Configuration](#custom-configuration)
- [Multiple Security Configurations](#multiple-security-configurations)
- [CSRF Configuration](#csrf-configuration)
- [Session Management](#session-management)
- [Remember Me](#remember-me)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ðŸŽ¯ Introduction

**Security Configuration** defines how Spring Security protects your application through the `SecurityFilterChain`.

### Configuration Evolution

```java
// Spring Security 5.x (Deprecated)
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/public/**").permitAll()
        .anyRequest().authenticated();
}

// Spring Security 6.x (Current)
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/public/**").permitAll()
            .anyRequest().authenticated()
        );
    return http.build();
}
```

---

## ðŸ”§ Basic Configuration

### Minimal Setup

```java
@Configuration
@EnableWebSecurity
public class BasicSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults())
            .httpBasic(Customizer.withDefaults());
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### In-Memory Users

```java
@Bean
public InMemoryUserDetailsManager userDetailsService() {
    UserDetails user = User.builder()
        .username("user")
        .password(passwordEncoder().encode("password"))
        .roles("USER")
        .build();
    
    UserDetails admin = User.builder()
        .username("admin")
        .password(passwordEncoder().encode("admin"))
        .roles("ADMIN", "USER")
        .build();
    
    return new InMemoryUserDetailsManager(user, admin);
}
```

---

## ðŸ”— SecurityFilterChain

### Complete Configuration

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig {
    
    @Autowired
    private CustomUserDetailsService userDetailsService;
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // CSRF
            .csrf(csrf -> csrf
                .ignoringRequestMatchers("/api/public/**")
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            
            // CORS
            .cors(cors -> cors
                .configurationSource(corsConfigurationSource())
            )
            
            // Session Management
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            )
            
            // Authorization
            .authorizeHttpRequests(auth -> auth
                // Public endpoints
                .requestMatchers("/", "/login", "/register").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/css/**", "/js/**", "/images/**").permitAll()
                
                // Swagger/OpenAPI
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // Admin endpoints
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers(HttpMethod.DELETE, "/api/users/**").hasRole("ADMIN")
                
                // User endpoints
                .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                .requestMatchers(HttpMethod.GET, "/api/products/**").hasRole("USER")
                
                // Authenticated endpoints
                .anyRequest().authenticated()
            )
            
            // Exception Handling
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler())
            )
            
            // Form Login
            .formLogin(form -> form
                .loginPage("/login")
                .loginProcessingUrl("/perform_login")
                .defaultSuccessUrl("/home", true)
                .failureUrl("/login?error=true")
                .permitAll()
            )
            
            // HTTP Basic (for REST API)
            .httpBasic(Customizer.withDefaults())
            
            // Logout
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/login?logout=true")
                .deleteCookies("JSESSIONID")
                .invalidateHttpSession(true)
                .clearAuthentication(true)
                .permitAll()
            )
            
            // Remember Me
            .rememberMe(remember -> remember
                .key("uniqueAndSecret")
                .tokenValiditySeconds(86400) // 24 hours
                .userDetailsService(userDetailsService)
            )
            
            // Custom Filters
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
    
    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint() {
        return (request, response, authException) -> {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            response.getWriter().write("{\"error\":\"Unauthorized\",\"message\":\"" + 
                authException.getMessage() + "\"}");
        };
    }
    
    @Bean
    public AccessDeniedHandler accessDeniedHandler() {
        return (request, response, accessDeniedException) -> {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.setContentType("application/json");
            response.getWriter().write("{\"error\":\"Forbidden\",\"message\":\"" + 
                accessDeniedException.getMessage() + "\"}");
        };
    }
}
```

---

## ðŸŽ¨ Custom Configuration

### Custom Login Page

```java
@Configuration
public class CustomLoginConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .formLogin(form -> form
                .loginPage("/login")                    // Custom login page URL
                .loginProcessingUrl("/perform_login")   // Form POST URL
                .usernameParameter("email")             // Custom username field
                .passwordParameter("pass")              // Custom password field
                .defaultSuccessUrl("/dashboard", true)
                .failureUrl("/login?error=true")
                .successHandler(authenticationSuccessHandler())
                .failureHandler(authenticationFailureHandler())
                .permitAll()
            );
        
        return http.build();
    }
    
    @Bean
    public AuthenticationSuccessHandler authenticationSuccessHandler() {
        return (request, response, authentication) -> {
            // Custom success logic
            String username = authentication.getName();
            log.info("User {} logged in successfully", username);
            
            // Redirect based on role
            if (authentication.getAuthorities().stream()
                    .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))) {
                response.sendRedirect("/admin/dashboard");
            } else {
                response.sendRedirect("/user/dashboard");
            }
        };
    }
    
    @Bean
    public AuthenticationFailureHandler authenticationFailureHandler() {
        return (request, response, exception) -> {
            // Custom failure logic
            log.warn("Login failed: {}", exception.getMessage());
            response.sendRedirect("/login?error=true&message=" + 
                URLEncoder.encode(exception.getMessage(), "UTF-8"));
        };
    }
}
```

### Custom Logout

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .logout(logout -> logout
            .logoutUrl("/custom-logout")
            .logoutSuccessUrl("/goodbye")
            .addLogoutHandler(customLogoutHandler())
            .logoutSuccessHandler(logoutSuccessHandler())
            .deleteCookies("JSESSIONID", "remember-me")
            .invalidateHttpSession(true)
            .clearAuthentication(true)
        );
    
    return http.build();
}

@Bean
public LogoutHandler customLogoutHandler() {
    return (request, response, authentication) -> {
        if (authentication != null) {
            String username = authentication.getName();
            log.info("User {} logged out", username);
            // Additional cleanup
        }
    };
}

@Bean
public LogoutSuccessHandler logoutSuccessHandler() {
    return (request, response, authentication) -> {
        response.setStatus(HttpServletResponse.SC_OK);
        response.getWriter().write("{\"message\":\"Logged out successfully\"}");
    };
}
```

---

## ðŸ”„ Multiple Security Configurations

### API and Web Security

```java
@Configuration
@EnableWebSecurity
public class MultipleSecurityConfig {
    
    @Bean
    @Order(1)
    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher("/api/**")
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .addFilterBefore(jwtAuthFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    @Order(2)
    public SecurityFilterChain webFilterChain(HttpSecurity http) throws Exception {
        http
            .securityMatcher("/**")
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login", "/register").permitAll()
                .requestMatchers("/css/**", "/js/**").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .defaultSuccessUrl("/home")
                .permitAll()
            )
            .logout(logout -> logout
                .logoutSuccessUrl("/login?logout=true")
                .permitAll()
            );
        
        return http.build();
    }
}
```

### Actuator Security

```java
@Bean
@Order(1)
public SecurityFilterChain actuatorFilterChain(HttpSecurity http) throws Exception {
    http
        .securityMatcher("/actuator/**")
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/actuator/health", "/actuator/info").permitAll()
            .requestMatchers("/actuator/**").hasRole("ACTUATOR_ADMIN")
        )
        .httpBasic(Customizer.withDefaults());
    
    return http.build();
}
```

---

## ðŸ›¡ï¸ CSRF Configuration

### Enable CSRF (Default)

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
        );
    
    return http.build();
}
```

### Disable CSRF for Stateless APIs

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
            .disable() // Only for stateless JWT APIs
        );
    
    return http.build();
}
```

### Ignore Specific Endpoints

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
            .ignoringRequestMatchers("/api/public/**", "/webhook/**")
        );
    
    return http.build();
}
```

### Custom CSRF Token Repository

```java
@Bean
public CsrfTokenRepository csrfTokenRepository() {
    CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();
    repository.setCookieName("XSRF-TOKEN");
    repository.setHeaderName("X-XSRF-TOKEN");
    return repository;
}
```

---

## ðŸ•’ Session Management

### Session Creation Policy

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .sessionManagement(session -> session
            // ALWAYS: Always create session
            // NEVER: Never create session
            // IF_REQUIRED: Create session if needed (default)
            // STATELESS: Never create or use session (JWT)
            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        );
    
    return http.build();
}
```

### Concurrent Session Control

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .sessionManagement(session -> session
            .maximumSessions(1) // Max 1 session per user
            .maxSessionsPreventsLogin(true) // Prevent new login
            .expiredUrl("/login?expired=true")
            .sessionRegistry(sessionRegistry())
        );
    
    return http.build();
}

@Bean
public SessionRegistry sessionRegistry() {
    return new SessionRegistryImpl();
}

@Bean
public HttpSessionEventPublisher httpSessionEventPublisher() {
    return new HttpSessionEventPublisher();
}
```

### Session Fixation Protection

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .sessionManagement(session -> session
            // NONE: No protection
            // MIGRATE_SESSION: Migrate existing attributes (default)
            // NEW_SESSION: Create new session
            // CHANGE_SESSION_ID: Change session ID only
            .sessionFixation().changeSessionId()
        );
    
    return http.build();
}
```

### Session Timeout

```properties
# application.properties
server.servlet.session.timeout=30m
```

---

## ðŸ”‘ Remember Me

### Basic Remember Me

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .rememberMe(remember -> remember
            .key("uniqueAndSecret")
            .tokenValiditySeconds(604800) // 7 days
            .userDetailsService(userDetailsService)
        );
    
    return http.build();
}
```

### Persistent Token Remember Me

```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .rememberMe(remember -> remember
            .key("uniqueAndSecret")
            .tokenRepository(persistentTokenRepository())
            .userDetailsService(userDetailsService)
            .tokenValiditySeconds(604800)
        );
    
    return http.build();
}

@Bean
public PersistentTokenRepository persistentTokenRepository() {
    JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
    tokenRepository.setDataSource(dataSource);
    return tokenRepository;
}
```

### Database Schema for Persistent Tokens

```sql
CREATE TABLE persistent_logins (
    username VARCHAR(64) NOT NULL,
    series VARCHAR(64) PRIMARY KEY,
    token VARCHAR(64) NOT NULL,
    last_used TIMESTAMP NOT NULL
);
```

### Custom Remember Me Parameter

```java
http
    .rememberMe(remember -> remember
        .rememberMeParameter("remember-me-checkbox") // Default: "remember-me"
        .rememberMeCookieName("my-remember-me") // Default: "remember-me"
    );
```

---

## ðŸ“Œ Best Practices

### 1. Disable CSRF Only for Stateless APIs

```java
// âœ… Good - Disable for JWT APIs
@Bean
@Order(1)
public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
    http
        .securityMatcher("/api/**")
        .csrf(csrf -> csrf.disable())
        .sessionManagement(session -> 
            session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
    return http.build();
}

// âŒ Bad - Disabling globally
http.csrf(csrf -> csrf.disable());
```

### 2. Use HTTPS in Production

```java
// âœ… Good - Force HTTPS
http.requiresChannel(channel -> 
    channel.anyRequest().requiresSecure());
```

### 3. Configure Session Timeout

```properties
# âœ… Good - Appropriate timeout
server.servlet.session.timeout=30m

# âŒ Bad - Too long
server.servlet.session.timeout=24h
```

### 4. Limit Concurrent Sessions

```java
// âœ… Good - Prevent multiple logins
.sessionManagement(session -> session
    .maximumSessions(1)
    .maxSessionsPreventsLogin(true)
)
```

### 5. Use Strong Keys for Remember Me

```java
// âœ… Good - Strong, unique key
.rememberMe(remember -> remember
    .key("c0mpl3x_r4nd0m_k3y_2024")
)

// âŒ Bad - Weak key
.rememberMe(remember -> remember
    .key("secret")
)
```

### 6. Separate Public and Protected Routes

```java
// âœ… Good - Clear separation
.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/public/**").permitAll()
    .requestMatchers("/api/admin/**").hasRole("ADMIN")
    .anyRequest().authenticated()
)
```

### 7. Use Custom Error Handlers

```java
// âœ… Good - Custom handlers
.exceptionHandling(ex -> ex
    .authenticationEntryPoint(customEntryPoint())
    .accessDeniedHandler(customAccessDeniedHandler())
)
```

---

## ðŸŽ¤ Interview Questions

### Q1: What is SecurityFilterChain?
**Answer:** Bean that defines security configuration, replacing deprecated WebSecurityConfigurerAdapter.

### Q2: How to disable CSRF?
**Answer:**
```java
http.csrf(csrf -> csrf.disable());
```
Only for stateless JWT APIs.

### Q3: What is SessionCreationPolicy?
**Answer:** Defines when session should be created:
- ALWAYS: Always create
- NEVER: Never create
- IF_REQUIRED: Default
- STATELESS: For JWT

### Q4: How to enable method security?
**Answer:**
```java
@EnableMethodSecurity(prePostEnabled = true)
```

### Q5: What is @Order in security configuration?
**Answer:** Defines execution order when multiple SecurityFilterChain beans exist.

### Q6: How to configure multiple security chains?
**Answer:** Create multiple @Bean methods with @Order and different securityMatcher.

### Q7: What is Remember Me?
**Answer:** Persistent authentication allowing users to stay logged in across sessions using cookies.

### Q8: How to limit concurrent sessions?
**Answer:**
```java
.sessionManagement(session -> session
    .maximumSessions(1)
    .maxSessionsPreventsLogin(true)
)
```

### Q9: What is session fixation?
**Answer:** Attack where attacker sets victim's session ID. Spring Security prevents by changing session ID after authentication.

### Q10: How to force HTTPS?
**Answer:**
```java
http.requiresChannel(channel -> 
    channel.anyRequest().requiresSecure());
```

### Q11: What is AuthenticationEntryPoint?
**Answer:** Handles unauthenticated requests, typically redirects to login or returns 401.

### Q12: What is AccessDeniedHandler?
**Answer:** Handles authorized but insufficient permission requests, returns 403.

### Q13: How to customize login URL?
**Answer:**
```java
.formLogin(form -> form
    .loginPage("/custom-login")
    .loginProcessingUrl("/perform-login")
)
```

### Q14: What is CorsConfigurationSource?
**Answer:** Bean defining CORS settings (allowed origins, methods, headers).

### Q15: How to permit specific endpoints?
**Answer:**
```java
.requestMatchers("/public/**").permitAll()
```

### Q16: What is CSRF token?
**Answer:** Unique token preventing Cross-Site Request Forgery attacks.

### Q17: Where is SecurityContext stored?
**Answer:** ThreadLocal storage, accessible via SecurityContextHolder.

### Q18: How to disable security for testing?
**Answer:**
```java
@SpringBootTest
@AutoConfigureMockMvc(addFilters = false)
```

### Q19: What is logout handler?
**Answer:** Custom logic executed during logout (e.g., logging, cleanup).

### Q20: Best practice for session timeout?
**Answer:** 15-30 minutes for regular apps, shorter for sensitive operations.

---

## ðŸ“š Summary

### Basic Configuration

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .formLogin(Customizer.withDefaults())
            .logout(Customizer.withDefaults());
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### Key Components

- **SecurityFilterChain:** Main security configuration
- **AuthenticationManager:** Processes authentication
- **PasswordEncoder:** Encodes passwords
- **UserDetailsService:** Loads user data
- **SessionManagement:** Controls session behavior
- **CSRF Protection:** Prevents CSRF attacks

**Next:** User Details Service â†’

