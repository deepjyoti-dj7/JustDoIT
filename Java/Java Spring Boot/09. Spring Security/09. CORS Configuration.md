# üåê CORS Configuration - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [CORS Basics](#cors-basics)
- [Spring Boot CORS](#spring-boot-cors)
- [Global CORS Configuration](#global-cors-configuration)
- [Controller-Level CORS](#controller-level-cors)
- [CORS with Security](#cors-with-security)
- [Preflight Requests](#preflight-requests)
- [Common Issues](#common-issues)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**CORS (Cross-Origin Resource Sharing)** is a security mechanism that allows or restricts resources requested from another domain.

### Same-Origin Policy

```
Same Origin (Allowed):
http://example.com/page1 ‚Üí http://example.com/page2
‚úÖ Same protocol, domain, port

Different Origin (Blocked):
http://example.com ‚Üí https://example.com  (Different protocol)
http://example.com ‚Üí http://api.example.com  (Different subdomain)
http://example.com ‚Üí http://example.com:8080  (Different port)
http://example.com ‚Üí http://other.com  (Different domain)
```

### CORS Purpose

```
Frontend:                  Backend:
http://localhost:3000  ‚Üí  http://localhost:8080
    (React)                   (Spring Boot)

Without CORS:
‚ùå Browser blocks request (Same-Origin Policy)

With CORS:
‚úÖ Server allows specific origins
‚úÖ Browser permits request
```

---

## üìö CORS Basics

### How CORS Works

```
1. Browser sends request with Origin header:
   Origin: http://localhost:3000

2. Server responds with CORS headers:
   Access-Control-Allow-Origin: http://localhost:3000
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE
   Access-Control-Allow-Headers: Content-Type, Authorization

3. Browser checks headers:
   - If origin allowed ‚Üí Request succeeds
   - If origin not allowed ‚Üí Request blocked
```

### CORS Headers

| Header | Description | Example |
|--------|-------------|---------|
| Access-Control-Allow-Origin | Allowed origins | * or http://localhost:3000 |
| Access-Control-Allow-Methods | Allowed HTTP methods | GET, POST, PUT, DELETE |
| Access-Control-Allow-Headers | Allowed request headers | Content-Type, Authorization |
| Access-Control-Allow-Credentials | Allow cookies/auth | true |
| Access-Control-Max-Age | Preflight cache duration | 3600 |
| Access-Control-Expose-Headers | Headers accessible to client | X-Custom-Header |

---

## üîß Spring Boot CORS

### Method 1: @CrossOrigin Annotation

```java
@RestController
@RequestMapping("/api/products")
@CrossOrigin(origins = "http://localhost:3000")
public class ProductController {
    
    @GetMapping
    public List<Product> getAllProducts() {
        return productService.findAll();
    }
    
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return productService.save(product);
    }
}
```

### Method 2: Global Configuration

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins("http://localhost:3000")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true)
                    .maxAge(3600);
            }
        };
    }
}
```

### Method 3: CorsConfigurationSource Bean

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000", "https://myapp.com"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }
}
```

---

## üåç Global CORS Configuration

### Complete Configuration

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(
                "http://localhost:3000",
                "http://localhost:4200",
                "https://myapp.com"
            )
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
            .allowedHeaders(
                "Content-Type",
                "Authorization",
                "X-Requested-With",
                "Accept",
                "Origin"
            )
            .exposedHeaders("X-Total-Count", "X-Page-Number")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

### Environment-Specific Origins

```java
@Configuration
public class CorsConfig {
    
    @Value("${cors.allowed-origins}")
    private String[] allowedOrigins;
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins(allowedOrigins)
                    .allowedMethods("*")
                    .allowedHeaders("*")
                    .allowCredentials(true);
            }
        };
    }
}
```

```properties
# application-dev.properties
cors.allowed-origins=http://localhost:3000,http://localhost:4200

# application-prod.properties
cors.allowed-origins=https://myapp.com,https://www.myapp.com
```

### Multiple Mappings

```java
@Override
public void addCorsMappings(CorsRegistry registry) {
    // Public API - Allow all origins
    registry.addMapping("/api/public/**")
        .allowedOrigins("*")
        .allowedMethods("GET")
        .allowedHeaders("*")
        .allowCredentials(false);
    
    // Protected API - Specific origins
    registry.addMapping("/api/private/**")
        .allowedOrigins("http://localhost:3000", "https://myapp.com")
        .allowedMethods("GET", "POST", "PUT", "DELETE")
        .allowedHeaders("*")
        .allowCredentials(true);
}
```

---

## üéØ Controller-Level CORS

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "http://localhost:3000")
public class UserController {
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.findAll();
    }
}
```

### Detailed Configuration

```java
@RestController
@RequestMapping("/api/orders")
@CrossOrigin(
    origins = {"http://localhost:3000", "https://myapp.com"},
    methods = {RequestMethod.GET, RequestMethod.POST},
    allowedHeaders = {"Content-Type", "Authorization"},
    exposedHeaders = {"X-Total-Count"},
    allowCredentials = "true",
    maxAge = 3600
)
public class OrderController {
    
    @GetMapping
    public List<Order> getAllOrders() {
        return orderService.findAll();
    }
    
    @PostMapping
    public Order createOrder(@RequestBody Order order) {
        return orderService.save(order);
    }
}
```

### Method-Level CORS

```java
@RestController
@RequestMapping("/api/data")
public class DataController {
    
    @GetMapping("/public")
    @CrossOrigin(origins = "*")
    public String getPublicData() {
        return "Public data - accessible from anywhere";
    }
    
    @GetMapping("/private")
    @CrossOrigin(origins = "http://localhost:3000", allowCredentials = "true")
    public String getPrivateData() {
        return "Private data - only from localhost:3000";
    }
}
```

---

## üîê CORS with Security

### Security Configuration

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors
                .configurationSource(corsConfigurationSource())
            )
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            );
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }
}
```

### With JWT Authentication

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .cors(Customizer.withDefaults())
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        configuration.setAllowedOrigins(Arrays.asList(
            "http://localhost:3000",
            "https://myapp.com"
        ));
        configuration.setAllowedMethods(Arrays.asList("*"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }
}
```

---

## ‚úàÔ∏è Preflight Requests

### What is Preflight?

```
Simple Request (No Preflight):
- GET, HEAD, POST
- Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain
- No custom headers

Complex Request (Preflight Required):
- PUT, DELETE, PATCH
- Content-Type: application/json
- Custom headers (Authorization, X-Custom-Header)
```

### Preflight Flow

```
1. Browser sends OPTIONS request:
   OPTIONS /api/users HTTP/1.1
   Origin: http://localhost:3000
   Access-Control-Request-Method: DELETE
   Access-Control-Request-Headers: Authorization

2. Server responds:
   Access-Control-Allow-Origin: http://localhost:3000
   Access-Control-Allow-Methods: DELETE
   Access-Control-Allow-Headers: Authorization
   Access-Control-Max-Age: 3600

3. Browser caches response (3600 seconds)

4. Browser sends actual request:
   DELETE /api/users/123 HTTP/1.1
   Authorization: Bearer token...
```

### Handle Preflight

```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    
    configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
    configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
    configuration.setAllowedHeaders(Arrays.asList("*"));
    configuration.setAllowCredentials(true);
    configuration.setMaxAge(3600L); // Cache preflight for 1 hour
    
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    
    return source;
}
```

---

## ‚ö†Ô∏è Common Issues

### Issue 1: CORS Error Despite Configuration

```
Error: Access to fetch at 'http://localhost:8080/api/users' from origin 
'http://localhost:3000' has been blocked by CORS policy
```

**Solution:**

```java
// ‚ùå Wrong - CORS configured but Security overrides
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) {
    http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    // CORS not configured in Security!
    return http.build();
}

// ‚úÖ Correct - Enable CORS in Security
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) {
    http
        .cors(Customizer.withDefaults()) // Enable CORS
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    return http.build();
}
```

### Issue 2: Credentials Not Allowed

```
Error: Response to preflight request doesn't pass access control check: 
The value of the 'Access-Control-Allow-Credentials' header in the response 
is '' which must be 'true' when the request's credentials mode is 'include'.
```

**Solution:**

```java
// ‚ùå Wrong - allowedOrigins("*") conflicts with allowCredentials(true)
configuration.setAllowedOrigins(Arrays.asList("*"));
configuration.setAllowCredentials(true);

// ‚úÖ Correct - Specific origins with credentials
configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
configuration.setAllowCredentials(true);

// ‚úÖ Alternative - Use origin patterns
configuration.setAllowedOriginPatterns(Arrays.asList("*"));
configuration.setAllowCredentials(true);
```

### Issue 3: Custom Headers Not Allowed

```
Error: Request header field authorization is not allowed by 
Access-Control-Allow-Headers in preflight response.
```

**Solution:**

```java
// ‚úÖ Explicitly allow custom headers
configuration.setAllowedHeaders(Arrays.asList(
    "Content-Type",
    "Authorization",
    "X-Requested-With",
    "X-Custom-Header"
));

// OR allow all headers
configuration.setAllowedHeaders(Arrays.asList("*"));
```

### Issue 4: Method Not Allowed

```
Error: Method DELETE is not allowed by Access-Control-Allow-Methods in 
preflight response.
```

**Solution:**

```java
// ‚úÖ Include all needed methods
configuration.setAllowedMethods(Arrays.asList(
    "GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"
));

// OR allow all methods
configuration.setAllowedMethods(Arrays.asList("*"));
```

---

## üìå Best Practices

### 1. Never Use * in Production with Credentials

```java
// ‚ùå Bad - Security risk
configuration.setAllowedOrigins(Arrays.asList("*"));
configuration.setAllowCredentials(true);

// ‚úÖ Good - Specific origins
configuration.setAllowedOrigins(Arrays.asList(
    "https://myapp.com",
    "https://www.myapp.com"
));
configuration.setAllowCredentials(true);
```

### 2. Use Environment-Specific Configuration

```java
@Configuration
public class CorsConfig {
    
    @Value("${app.cors.allowed-origins}")
    private List<String> allowedOrigins;
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        // ... other config
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

```yaml
# application-dev.yml
app:
  cors:
    allowed-origins:
      - http://localhost:3000
      - http://localhost:4200

# application-prod.yml
app:
  cors:
    allowed-origins:
      - https://myapp.com
      - https://www.myapp.com
```

### 3. Set Appropriate MaxAge

```java
// ‚úÖ Good - Cache preflight for 1 hour
configuration.setMaxAge(3600L);

// ‚ö†Ô∏è Too long - Changes require browser restart
configuration.setMaxAge(86400L); // 24 hours

// ‚ö†Ô∏è Too short - Excessive preflight requests
configuration.setMaxAge(10L); // 10 seconds
```

### 4. Expose Custom Headers

```java
// ‚úÖ Good - Expose headers needed by frontend
configuration.setExposedHeaders(Arrays.asList(
    "Authorization",
    "X-Total-Count",
    "X-Page-Number",
    "X-Request-Id"
));
```

### 5. Different CORS for Different Endpoints

```java
@Override
public void addCorsMappings(CorsRegistry registry) {
    // Public API - More permissive
    registry.addMapping("/api/public/**")
        .allowedOrigins("*")
        .allowedMethods("GET")
        .allowCredentials(false);
    
    // Admin API - Restrictive
    registry.addMapping("/api/admin/**")
        .allowedOrigins("https://admin.myapp.com")
        .allowedMethods("GET", "POST", "PUT", "DELETE")
        .allowCredentials(true);
}
```

### 6. Handle CORS Before Security

```java
// ‚úÖ Good - CORS filter before security
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) {
    http
        .cors(Customizer.withDefaults()) // CORS first
        .csrf(csrf -> csrf.disable())
        .authorizeHttpRequests(auth -> auth
            .anyRequest().authenticated()
        );
    return http.build();
}
```

### 7. Log CORS Requests (Development)

```java
@Component
public class CorsLoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        if ("OPTIONS".equalsIgnoreCase(httpRequest.getMethod())) {
            log.info("CORS Preflight Request: {} from {}", 
                httpRequest.getRequestURI(), 
                httpRequest.getHeader("Origin"));
        }
        
        chain.doFilter(request, response);
    }
}
```

---

## üé§ Interview Questions

### Q1: What is CORS?
**Answer:** Cross-Origin Resource Sharing - mechanism allowing/restricting resources from different origins.

### Q2: What is Same-Origin Policy?
**Answer:** Browser security feature blocking requests to different origin (protocol, domain, port).

### Q3: How to enable CORS in Spring Boot?
**Answer:**
```java
@CrossOrigin(origins = "http://localhost:3000")
// OR
@Bean
public WebMvcConfigurer corsConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/**").allowedOrigins("*");
        }
    };
}
```

### Q4: What is preflight request?
**Answer:** OPTIONS request sent by browser before actual request to check if CORS is allowed.

### Q5: When is preflight sent?
**Answer:** For non-simple requests (PUT, DELETE, PATCH, custom headers, JSON content-type).

### Q6: What is Access-Control-Allow-Origin?
**Answer:** Response header specifying which origins can access the resource.

### Q7: Can you use * with credentials?
**Answer:** No, must specify exact origins when allowCredentials is true.

### Q8: What is MaxAge?
**Answer:** How long (seconds) browser caches preflight response.

### Q9: Difference between @CrossOrigin and global config?
**Answer:** @CrossOrigin is controller/method level, global config applies to all endpoints.

### Q10: How to allow credentials?
**Answer:**
```java
configuration.setAllowCredentials(true);
configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
```

### Q11: What headers are allowed by default?
**Answer:** Simple headers (Content-Type, Accept, Accept-Language), custom headers need explicit permission.

### Q12: How to expose custom response headers?
**Answer:**
```java
configuration.setExposedHeaders(Arrays.asList("X-Custom-Header"));
```

### Q13: CORS vs CSRF?
**Answer:** CORS controls cross-origin access, CSRF prevents unauthorized actions from trusted users.

### Q14: Does CORS protect backend?
**Answer:** No, it's browser-enforced. Backend still needs authentication/authorization.

### Q15: How to debug CORS issues?
**Answer:** Check browser console, verify Origin header, check preflight response headers.

### Q16: Can you disable CORS?
**Answer:** Not in browser, but can allow all origins (*) on server (not recommended for production).

### Q17: What is allowedOriginPatterns?
**Answer:** Allows origin patterns with wildcards, works with allowCredentials(true).

### Q18: How CORS works with Spring Security?
**Answer:** Must enable CORS in SecurityFilterChain: `http.cors(Customizer.withDefaults())`

### Q19: Common CORS errors?
**Answer:**
1. Origin not allowed
2. Method not allowed
3. Header not allowed
4. Credentials conflict with *
5. Missing CORS in Security config

### Q20: Production CORS best practices?
**Answer:**
1. Specific origins (no *)
2. Environment-specific config
3. Appropriate MaxAge
4. Only necessary methods/headers
5. Enable in Spring Security
6. HTTPS in production

---

## üìö Summary

### Quick Setup

```java
// 1. Global Configuration
@Configuration
public class CorsConfig {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                    .allowedOrigins("http://localhost:3000")
                    .allowedMethods("*")
                    .allowedHeaders("*")
                    .allowCredentials(true);
            }
        };
    }
}

// 2. Security Configuration
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) {
    http.cors(Customizer.withDefaults());
    return http.build();
}

// 3. Controller Annotation (Optional)
@CrossOrigin(origins = "http://localhost:3000")
@RestController
public class MyController { }
```

### Key Headers

- **Access-Control-Allow-Origin:** Allowed origins
- **Access-Control-Allow-Methods:** Allowed HTTP methods
- **Access-Control-Allow-Headers:** Allowed request headers
- **Access-Control-Allow-Credentials:** Allow cookies/auth
- **Access-Control-Max-Age:** Preflight cache duration

### Common Configuration

```java
configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
configuration.setAllowedHeaders(Arrays.asList("*"));
configuration.setAllowCredentials(true);
configuration.setMaxAge(3600L);
```

**End of Spring Security Module** ‚úÖ

