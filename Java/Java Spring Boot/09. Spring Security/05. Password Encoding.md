# üîê Password Encoding - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [PasswordEncoder Interface](#passwordencoder-interface)
- [BCryptPasswordEncoder](#bcryptpasswordencoder)
- [Password Strength Validation](#password-strength-validation)
- [Password Migration](#password-migration)
- [DelegatingPasswordEncoder](#delegatingpasswordencoder)
- [Custom Password Encoder](#custom-password-encoder)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Password Encoding** ensures passwords are securely hashed before storage, protecting against breaches.

### Why Password Encoding?

```
‚ùå Plain Text Storage:
Database: users
| username | password  |
| john     | secret123 |  <- Visible if database breached

‚úÖ Hashed Storage:
| username | password                                                      |
| john     | $2a$10$N9qo8uLOickgx2ZMRZoMye.aBdPLHdVnCqGSy3k5kYnRGdCj7hYzm |  <- Safe
```

### Never Store Plain Text

```java
// ‚ùå NEVER DO THIS
user.setPassword("password123");

// ‚úÖ ALWAYS DO THIS
user.setPassword(passwordEncoder.encode("password123"));
```

---

## üîß PasswordEncoder Interface

### Interface Definition

```java
public interface PasswordEncoder {
    String encode(CharSequence rawPassword);
    boolean matches(CharSequence rawPassword, String encodedPassword);
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}
```

### Basic Configuration

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### Usage in Service

```java
@Service
public class UserService {
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(UserRegistrationRequest request) {
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        
        // Encode password before saving
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        
        return userRepository.save(user);
    }
    
    public boolean changePassword(String username, String oldPassword, String newPassword) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new RuntimeException("User not found"));
        
        // Verify old password
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new RuntimeException("Old password is incorrect");
        }
        
        // Encode and save new password
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
        
        return true;
    }
}
```

---

## üîí BCryptPasswordEncoder

### What is BCrypt?

- Adaptive hash function
- Built-in salt
- Configurable strength (4-31)
- Industry standard

### Configuration

```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// With custom strength
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(12); // Default is 10
}

// With custom BCryptVersion
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(BCryptPasswordEncoder.BCryptVersion.$2B, 12);
}
```

### Strength Levels

| Strength | Rounds | Time       | Use Case                    |
|----------|--------|------------|-----------------------------|
| 4-7      | 16-128 | Fast       | Testing only                |
| 8-10     | 256-1024| Moderate  | Standard applications       |
| 11-13    | 2048-8192| Slow     | High-security applications  |
| 14+      | 16384+ | Very Slow  | Maximum security            |

```java
// Testing: Fast but less secure
new BCryptPasswordEncoder(4);

// Production: Recommended
new BCryptPasswordEncoder(10);

// High Security: Banking, Healthcare
new BCryptPasswordEncoder(12);
```

### How BCrypt Works

```java
String rawPassword = "mySecretPassword";
PasswordEncoder encoder = new BCryptPasswordEncoder();

// Encode
String encodedPassword = encoder.encode(rawPassword);
// Result: $2a$10$N9qo8uLOickgx2ZMRZoMye.aBdPLHdVnCqGSy3k5kYnRGdCj7hYzm

// Same password, different hash (random salt)
String encodedPassword2 = encoder.encode(rawPassword);
// Result: $2a$10$XptfkjlkzZ6/L8k0JB4mYuwXBBqN0wTIq9QpN5nNDGkRE3nkTqVhi

// Verify
boolean matches = encoder.matches(rawPassword, encodedPassword); // true
```

### BCrypt Format

```
$2a$10$N9qo8uLOickgx2ZMRZoMye.aBdPLHdVnCqGSy3k5kYnRGdCj7hYzm
 ‚îÇ  ‚îÇ  ‚îÇ                          ‚îÇ
 ‚îÇ  ‚îÇ  ‚îÇ                          ‚îî‚îÄ Hash (31 chars)
 ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Salt (22 chars)
 ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Strength (10 rounds)
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Algorithm version ($2a, $2b, $2y)
```

---

## üìè Password Strength Validation

### Validation Annotation

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordConstraintValidator.class)
public @interface ValidPassword {
    String message() default "Invalid Password";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### Validator Implementation

```java
public class PasswordConstraintValidator implements ConstraintValidator<ValidPassword, String> {
    
    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return false;
        }
        
        // Minimum 8 characters
        if (password.length() < 8) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "Password must be at least 8 characters"
            ).addConstraintViolation();
            return false;
        }
        
        // Contains uppercase
        if (!password.matches(".*[A-Z].*")) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "Password must contain at least one uppercase letter"
            ).addConstraintViolation();
            return false;
        }
        
        // Contains lowercase
        if (!password.matches(".*[a-z].*")) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "Password must contain at least one lowercase letter"
            ).addConstraintViolation();
            return false;
        }
        
        // Contains digit
        if (!password.matches(".*\\d.*")) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "Password must contain at least one digit"
            ).addConstraintViolation();
            return false;
        }
        
        // Contains special character
        if (!password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*")) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                "Password must contain at least one special character"
            ).addConstraintViolation();
            return false;
        }
        
        return true;
    }
}
```

### Usage in DTO

```java
@Data
public class UserRegistrationRequest {
    
    @NotBlank(message = "Username is required")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @ValidPassword
    private String password;
    
    @NotBlank(message = "Confirm password is required")
    private String confirmPassword;
}
```

### Password Strength Service

```java
@Service
public class PasswordStrengthService {
    
    public enum PasswordStrength {
        WEAK, MEDIUM, STRONG, VERY_STRONG
    }
    
    public PasswordStrength checkStrength(String password) {
        int score = 0;
        
        // Length
        if (password.length() >= 8) score++;
        if (password.length() >= 12) score++;
        if (password.length() >= 16) score++;
        
        // Complexity
        if (password.matches(".*[a-z].*")) score++;
        if (password.matches(".*[A-Z].*")) score++;
        if (password.matches(".*\\d.*")) score++;
        if (password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*")) score++;
        
        if (score <= 3) return PasswordStrength.WEAK;
        if (score <= 5) return PasswordStrength.MEDIUM;
        if (score <= 6) return PasswordStrength.STRONG;
        return PasswordStrength.VERY_STRONG;
    }
    
    public Map<String, Object> analyzePassword(String password) {
        Map<String, Object> analysis = new HashMap<>();
        
        analysis.put("length", password.length());
        analysis.put("hasLowerCase", password.matches(".*[a-z].*"));
        analysis.put("hasUpperCase", password.matches(".*[A-Z].*"));
        analysis.put("hasDigit", password.matches(".*\\d.*"));
        analysis.put("hasSpecialChar", password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*"));
        analysis.put("strength", checkStrength(password));
        
        return analysis;
    }
}
```

---

## üîÑ Password Migration

### Scenario: Migrating from Plain Text

```java
@Service
public class PasswordMigrationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Transactional
    public void migratePasswords() {
        List<User> users = userRepository.findAll();
        
        for (User user : users) {
            // Check if password is plain text (not starting with $2a)
            if (!user.getPassword().startsWith("$2a")) {
                String encodedPassword = passwordEncoder.encode(user.getPassword());
                user.setPassword(encodedPassword);
                userRepository.save(user);
            }
        }
    }
}
```

### Migrating from MD5 to BCrypt

```java
@Component
public class MD5ToBCryptMigration {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public void migrateOnLogin(String username, String rawPassword) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        // Check if password is MD5 (32 hex characters)
        if (user.getPassword().matches("^[a-f0-9]{32}$")) {
            // Verify MD5
            String md5Hash = DigestUtils.md5Hex(rawPassword);
            
            if (md5Hash.equals(user.getPassword())) {
                // Migrate to BCrypt
                user.setPassword(passwordEncoder.encode(rawPassword));
                userRepository.save(user);
                log.info("Migrated password for user: {}", username);
            }
        }
    }
}
```

---

## üéõÔ∏è DelegatingPasswordEncoder

### What is DelegatingPasswordEncoder?

Supports multiple encoding algorithms, useful for password migration.

### Configuration

```java
@Bean
public PasswordEncoder passwordEncoder() {
    String encodingId = "bcrypt";
    
    Map<String, PasswordEncoder> encoders = new HashMap<>();
    encoders.put("bcrypt", new BCryptPasswordEncoder());
    encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());
    encoders.put("scrypt", new SCryptPasswordEncoder());
    encoders.put("argon2", new Argon2PasswordEncoder());
    encoders.put("sha256", new StandardPasswordEncoder()); // Deprecated
    encoders.put("noop", NoOpPasswordEncoder.getInstance()); // For testing only
    
    return new DelegatingPasswordEncoder(encodingId, encoders);
}

// Or use factory method
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
```

### Password Format

```
{bcrypt}$2a$10$N9qo8uLOickgx2ZMRZoMye.aBdPLHdVnCqGSy3k5kYnRGdCj7hYzm
{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc
{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=
```

### Usage Example

```java
@Service
public class AuthService {
    
    @Autowired
    private PasswordEncoder delegatingPasswordEncoder;
    
    @Autowired
    private UserRepository userRepository;
    
    public void authenticate(String username, String rawPassword) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        // Automatically detects encoding type from prefix
        if (delegatingPasswordEncoder.matches(rawPassword, user.getPassword())) {
            
            // Check if password needs upgrade
            if (delegatingPasswordEncoder.upgradeEncoding(user.getPassword())) {
                // Re-encode with current default (bcrypt)
                user.setPassword(delegatingPasswordEncoder.encode(rawPassword));
                userRepository.save(user);
            }
            
            log.info("Authentication successful for user: {}", username);
        } else {
            throw new BadCredentialsException("Invalid credentials");
        }
    }
}
```

---

## üõ†Ô∏è Custom Password Encoder

### Simple Custom Encoder

```java
public class CustomPasswordEncoder implements PasswordEncoder {
    
    private final PasswordEncoder primaryEncoder = new BCryptPasswordEncoder();
    
    @Override
    public String encode(CharSequence rawPassword) {
        // Add custom logic before encoding
        String processedPassword = rawPassword.toString().trim().toLowerCase();
        return primaryEncoder.encode(processedPassword);
    }
    
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        String processedPassword = rawPassword.toString().trim().toLowerCase();
        return primaryEncoder.matches(processedPassword, encodedPassword);
    }
}
```

### With Pepper (Additional Secret)

```java
@Component
public class PepperedPasswordEncoder implements PasswordEncoder {
    
    @Value("${password.pepper}")
    private String pepper;
    
    private final PasswordEncoder bcryptEncoder = new BCryptPasswordEncoder();
    
    @Override
    public String encode(CharSequence rawPassword) {
        String pepperedPassword = rawPassword + pepper;
        return bcryptEncoder.encode(pepperedPassword);
    }
    
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        String pepperedPassword = rawPassword + pepper;
        return bcryptEncoder.matches(pepperedPassword, encodedPassword);
    }
}
```

```properties
# application.properties
password.pepper=mySecretPepperKey123!@#
```

---

## üìå Best Practices

### 1. Always Use BCrypt or Stronger

```java
// ‚úÖ Good - BCrypt
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// ‚úÖ Better - Argon2 (winner of Password Hashing Competition)
@Bean
public PasswordEncoder passwordEncoder() {
    return new Argon2PasswordEncoder();
}

// ‚ùå Bad - Plain text
@Bean
public PasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
```

### 2. Set Appropriate BCrypt Strength

```java
// ‚úÖ Good - Production
new BCryptPasswordEncoder(10); // 2^10 = 1024 rounds

// ‚úÖ Good - High security
new BCryptPasswordEncoder(12); // 2^12 = 4096 rounds

// ‚ùå Bad - Too weak
new BCryptPasswordEncoder(4);
```

### 3. Enforce Strong Passwords

```java
// ‚úÖ Good - Validation
@ValidPassword
private String password;

// ‚ùå Bad - No validation
private String password;
```

### 4. Never Log Passwords

```java
// ‚ùå NEVER DO THIS
log.info("User password: {}", password);
log.debug("Encoded password: {}", encodedPassword);

// ‚úÖ Good - Log without password
log.info("Password updated for user: {}", username);
```

### 5. Use DelegatingPasswordEncoder for Migration

```java
// ‚úÖ Good - Supports multiple algorithms
PasswordEncoderFactories.createDelegatingPasswordEncoder();
```

### 6. Implement Password History

```java
@Entity
public class PasswordHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private User user;
    
    private String password;
    private LocalDateTime createdAt;
}

@Service
public class PasswordHistoryService {
    
    public boolean isPasswordReused(User user, String newPassword) {
        List<PasswordHistory> history = passwordHistoryRepository
            .findTop5ByUserOrderByCreatedAtDesc(user);
        
        for (PasswordHistory ph : history) {
            if (passwordEncoder.matches(newPassword, ph.getPassword())) {
                return true;
            }
        }
        return false;
    }
}
```

### 7. Implement Rate Limiting

```java
@Service
public class LoginAttemptService {
    
    private final Map<String, Integer> attemptsCache = new ConcurrentHashMap<>();
    
    public void loginFailed(String username) {
        attemptsCache.merge(username, 1, Integer::sum);
    }
    
    public boolean isBlocked(String username) {
        return attemptsCache.getOrDefault(username, 0) >= 5;
    }
    
    public void loginSucceeded(String username) {
        attemptsCache.remove(username);
    }
}
```

---

## üé§ Interview Questions

### Q1: What is BCrypt?
**Answer:** Adaptive hash function with built-in salt, industry standard for password hashing.

### Q2: Why use BCrypt over MD5/SHA?
**Answer:** BCrypt is slower (intentional), has built-in salt, and is adaptive (strength can increase over time).

### Q3: What is password salt?
**Answer:** Random data added to password before hashing to prevent rainbow table attacks.

### Q4: Does BCrypt include salt?
**Answer:** Yes, BCrypt automatically generates and includes salt in the hash.

### Q5: What is BCrypt strength?
**Answer:** Number of hashing rounds (4-31), default is 10. Higher = slower but more secure.

### Q6: Can you decrypt BCrypt hash?
**Answer:** No, BCrypt is one-way. You verify by hashing input and comparing.

### Q7: What is PasswordEncoder interface?
**Answer:**
```java
String encode(CharSequence rawPassword);
boolean matches(CharSequence rawPassword, String encodedPassword);
```

### Q8: What is DelegatingPasswordEncoder?
**Answer:** Supports multiple password encoding algorithms, useful for migration.

### Q9: How to migrate from plain text to BCrypt?
**Answer:** During login, verify plain text, if match, encode with BCrypt and save.

### Q10: What is password pepper?
**Answer:** Secret key added to password before hashing, stored separately from database.

### Q11: Difference between salt and pepper?
**Answer:** 
- Salt: Random, unique per password, stored with hash
- Pepper: Secret, same for all, stored separately

### Q12: What is Argon2?
**Answer:** Winner of Password Hashing Competition, stronger than BCrypt.

### Q13: Best BCrypt strength for production?
**Answer:** 10-12 for standard apps, 12-14 for high security.

### Q14: How to enforce strong passwords?
**Answer:** Create custom @ValidPassword annotation with validator checking length, complexity.

### Q15: Should you log encoded passwords?
**Answer:** No, never log passwords (raw or encoded).

### Q16: What is NoOpPasswordEncoder?
**Answer:** Plain text encoder, ONLY for testing, never production.

### Q17: How to change user password?
**Answer:**
```java
// Verify old password
if (passwordEncoder.matches(oldPassword, user.getPassword())) {
    user.setPassword(passwordEncoder.encode(newPassword));
}
```

### Q18: What is upgradeEncoding()?
**Answer:** Checks if password should be re-encoded with newer/stronger algorithm.

### Q19: Can same password produce different hashes?
**Answer:** Yes, BCrypt generates random salt, so same password = different hash.

### Q20: Best practice for password storage?
**Answer:**
1. Use BCrypt/Argon2
2. Strength 10+
3. Validate password strength
4. Never log passwords
5. Implement password history
6. Rate limit login attempts

---

## üìö Summary

### Basic Usage

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(10);
    }
}

@Service
public class UserService {
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public void createUser(String username, String password) {
        // Encode before saving
        String encodedPassword = passwordEncoder.encode(password);
        user.setPassword(encodedPassword);
    }
    
    public boolean verifyPassword(String raw, String encoded) {
        // Verify password
        return passwordEncoder.matches(raw, encoded);
    }
}
```

### Key Points

- **BCrypt:** Industry standard, built-in salt, adaptive
- **Strength:** Default 10, higher = slower but more secure
- **Never Store Plain Text:** Always encode passwords
- **DelegatingPasswordEncoder:** Supports multiple algorithms
- **Validation:** Enforce strong password policies

**Next:** JWT Authentication ‚Üí

