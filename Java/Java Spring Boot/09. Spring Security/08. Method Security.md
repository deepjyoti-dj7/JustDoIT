# üîê Method Security - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Enable Method Security](#enable-method-security)
- [PreAuthorize](#preauthorize)
- [PostAuthorize](#postauthorize)
- [Secured](#secured)
- [RolesAllowed](#rolesallowed)
- [PreFilter & PostFilter](#prefilter--postfilter)
- [Custom Security Expressions](#custom-security-expressions)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Method Security** allows securing individual methods with annotations, providing fine-grained access control.

### Why Method Security?

```
URL-Based Security:
‚úÖ Good for: Public vs protected pages
‚ùå Limited: Can't secure specific operations

Method Security:
‚úÖ Fine-grained: Secure individual methods
‚úÖ Flexible: Complex authorization logic
‚úÖ Business logic: Check ownership, relationships
‚úÖ Reusable: Apply across controllers/services
```

### Security Levels

```
1. URL-Level (Coarse):
   /api/admin/** ‚Üí ROLE_ADMIN

2. Method-Level (Fine):
   deleteUser(id) ‚Üí ROLE_ADMIN
   updateOwnProfile(id) ‚Üí User owns resource

3. Domain-Level (Finest):
   Post.delete() ‚Üí User is author OR ADMIN
```

---

## ‚öôÔ∏è Enable Method Security

### Configuration

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(
    prePostEnabled = true,      // @PreAuthorize, @PostAuthorize
    securedEnabled = true,      // @Secured
    jsr250Enabled = true        // @RolesAllowed
)
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll() // Method security handles authorization
            );
        return http.build();
    }
}
```

### Annotations Overview

| Annotation | Spring | Supports SpEL | Use Case |
|------------|--------|---------------|----------|
| @PreAuthorize | ‚úÖ | ‚úÖ | Before method, complex logic |
| @PostAuthorize | ‚úÖ | ‚úÖ | After method, check result |
| @Secured | ‚úÖ | ‚ùå | Simple role check |
| @RolesAllowed | JSR-250 | ‚ùå | Java standard, simple roles |
| @PreFilter | ‚úÖ | ‚úÖ | Filter input collection |
| @PostFilter | ‚úÖ | ‚úÖ | Filter output collection |

---

## üîí PreAuthorize

### Basic Role Check

```java
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    
    @GetMapping("/users")
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        return userService.findAll();
    }
    
    @DeleteMapping("/users/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.ok().build();
    }
}
```

### Multiple Roles (OR)

```java
@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
public void manageEmployees() {
    // Only ADMIN or MANAGER
}
```

### Multiple Roles (AND)

```java
@PreAuthorize("hasRole('ADMIN') and hasRole('SUPER_USER')")
public void criticalOperation() {
    // Must have BOTH roles
}
```

### Authority Check

```java
@PreAuthorize("hasAuthority('DELETE_USER')")
public void deleteUser(Long id) {
    // Permission-based
}

@PreAuthorize("hasAnyAuthority('READ_USER', 'WRITE_USER')")
public void accessUser() {
    // Multiple permissions
}
```

### Parameter-Based Authorization

```java
@Service
public class PostService {
    
    @PreAuthorize("#userId == authentication.principal.id")
    public void updateProfile(Long userId, ProfileDTO profile) {
        // User can only update their own profile
    }
    
    @PreAuthorize("#post.author.id == authentication.principal.id")
    public void updatePost(Post post) {
        // User can only update their own posts
    }
    
    @PreAuthorize("#username == authentication.name")
    public void changePassword(String username, String newPassword) {
        // User can only change their own password
    }
}
```

### Complex Expressions

```java
@PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
public User getUser(Long userId) {
    // Admin can view anyone, user can view themselves
}

@PreAuthorize("hasRole('ADMIN') or " +
              "(hasRole('USER') and #order.userId == authentication.principal.id)")
public Order getOrder(Order order) {
    // Admin views all, user views own orders
}
```

### Custom Security Bean

```java
@Component("customSecurity")
public class CustomSecurityEvaluator {
    
    public boolean isOwner(Long userId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null || !auth.isAuthenticated()) {
            return false;
        }
        
        UserDetails userDetails = (UserDetails) auth.getPrincipal();
        return userDetails.getUsername().equals(userId.toString());
    }
    
    public boolean canAccessPost(Long postId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        // Custom logic to check post access
        return true;
    }
}

@Service
public class PostService {
    
    @PreAuthorize("@customSecurity.isOwner(#userId)")
    public void deletePost(Long userId, Long postId) {
        // Custom bean method
    }
    
    @PreAuthorize("@customSecurity.canAccessPost(#postId)")
    public Post getPost(Long postId) {
        return postRepository.findById(postId).orElseThrow();
    }
}
```

---

## ‚úÖ PostAuthorize

### Check Return Value

```java
@Service
public class DocumentService {
    
    @PostAuthorize("returnObject.author == authentication.name")
    public Document getDocument(Long id) {
        // Method executes
        // Then checks if returned document belongs to user
        return documentRepository.findById(id).orElseThrow();
    }
    
    @PostAuthorize("returnObject.isPublic or returnObject.owner.id == authentication.principal.id")
    public Post getPost(Long id) {
        Post post = postRepository.findById(id).orElseThrow();
        // Allowed if post is public OR user owns it
        return post;
    }
}
```

### Multiple Conditions

```java
@PostAuthorize("hasRole('ADMIN') or returnObject.userId == authentication.principal.id")
public UserProfile getUserProfile(Long id) {
    // Admin sees all profiles, users see their own
    return profileRepository.findById(id).orElseThrow();
}
```

### With Collections

```java
@PostAuthorize("returnObject.size() > 0")
public List<Order> getUserOrders(Long userId) {
    // Ensures at least one order returned
    return orderRepository.findByUserId(userId);
}
```

---

## üîê Secured

### Simple Role Check

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping
    @Secured("ROLE_USER")
    public List<Product> getAllProducts() {
        return productService.findAll();
    }
    
    @PostMapping
    @Secured("ROLE_ADMIN")
    public Product createProduct(@RequestBody Product product) {
        return productService.save(product);
    }
    
    @DeleteMapping("/{id}")
    @Secured("ROLE_ADMIN")
    public void deleteProduct(@PathVariable Long id) {
        productService.delete(id);
    }
}
```

### Multiple Roles

```java
@Secured({"ROLE_ADMIN", "ROLE_MANAGER"})
public void approveExpense(Long expenseId) {
    // ADMIN or MANAGER
}
```

### Limitations

```java
// ‚ùå @Secured doesn't support SpEL expressions
@Secured("#userId == authentication.principal.id") // Won't work!

// ‚úÖ Use @PreAuthorize instead
@PreAuthorize("#userId == authentication.principal.id")
public void updateUser(Long userId) { }
```

---

## üéØ RolesAllowed

### JSR-250 Standard

```java
@RestController
@RequestMapping("/api/employees")
public class EmployeeController {
    
    @GetMapping
    @RolesAllowed("USER")
    public List<Employee> getAllEmployees() {
        return employeeService.findAll();
    }
    
    @PostMapping
    @RolesAllowed({"ADMIN", "HR"})
    public Employee createEmployee(@RequestBody Employee employee) {
        return employeeService.save(employee);
    }
    
    @DeleteMapping("/{id}")
    @RolesAllowed("ADMIN")
    public void deleteEmployee(@PathVariable Long id) {
        employeeService.delete(id);
    }
}
```

### Note on Prefix

```java
// @RolesAllowed doesn't require ROLE_ prefix
@RolesAllowed("ADMIN")  // Checks for ROLE_ADMIN

// @Secured requires ROLE_ prefix
@Secured("ROLE_ADMIN")

// @PreAuthorize with hasRole() adds ROLE_ prefix
@PreAuthorize("hasRole('ADMIN')")  // Checks ROLE_ADMIN

// @PreAuthorize with hasAuthority() uses exact string
@PreAuthorize("hasAuthority('ROLE_ADMIN')")
```

---

## üîç PreFilter & PostFilter

### PreFilter - Filter Input

```java
@Service
public class TaskService {
    
    @PreFilter("filterObject.userId == authentication.principal.id")
    public void deleteTasks(List<Task> tasks) {
        // Only tasks owned by user are processed
        // Others are filtered out before method execution
        taskRepository.deleteAll(tasks);
    }
    
    @PreFilter("filterObject.status == 'PENDING'")
    public void processTasks(List<Task> tasks) {
        // Only PENDING tasks are processed
        tasks.forEach(task -> task.setStatus(Status.COMPLETED));
        taskRepository.saveAll(tasks);
    }
}
```

### PostFilter - Filter Output

```java
@Service
public class OrderService {
    
    @PostFilter("filterObject.userId == authentication.principal.id or hasRole('ADMIN')")
    public List<Order> getAllOrders() {
        List<Order> allOrders = orderRepository.findAll();
        // Users see only their orders
        // Admins see all orders
        return allOrders;
    }
    
    @PostFilter("filterObject.isPublic or filterObject.owner.id == authentication.principal.id")
    public List<Post> getPosts() {
        // Return only public posts or user's own posts
        return postRepository.findAll();
    }
}
```

### Combined Filters

```java
@PreFilter("filterObject.isActive")
@PostFilter("filterObject.score > 50")
public List<Submission> gradeSubmissions(List<Submission> submissions) {
    // PreFilter: Only active submissions are processed
    submissions.forEach(s -> s.setScore(calculateScore(s)));
    // PostFilter: Only submissions with score > 50 are returned
    return submissions;
}
```

---

## üé® Custom Security Expressions

### Custom Method Security Expression

```java
@Component("postSecurity")
public class PostSecurityExpression {
    
    @Autowired
    private PostRepository postRepository;
    
    public boolean isAuthor(Long postId, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        
        Post post = postRepository.findById(postId).orElse(null);
        if (post == null) {
            return false;
        }
        
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        return post.getAuthor().getEmail().equals(userDetails.getUsername());
    }
    
    public boolean canEdit(Long postId, Authentication authentication) {
        // Custom logic: author can edit, or admin, or moderator
        if (hasRole(authentication, "ADMIN")) {
            return true;
        }
        
        return isAuthor(postId, authentication);
    }
    
    public boolean canDelete(Long postId, Authentication authentication) {
        // Only author or admin can delete
        return isAuthor(postId, authentication) || hasRole(authentication, "ADMIN");
    }
    
    private boolean hasRole(Authentication authentication, String role) {
        return authentication.getAuthorities().stream()
            .anyMatch(auth -> auth.getAuthority().equals("ROLE_" + role));
    }
}
```

### Usage

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    @PutMapping("/{id}")
    @PreAuthorize("@postSecurity.canEdit(#id, authentication)")
    public Post updatePost(@PathVariable Long id, @RequestBody PostDTO postDTO) {
        return postService.update(id, postDTO);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("@postSecurity.canDelete(#id, authentication)")
    public ResponseEntity<?> deletePost(@PathVariable Long id) {
        postService.delete(id);
        return ResponseEntity.ok().build();
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("@postSecurity.isAuthor(#id, authentication) or hasRole('ADMIN')")
    public Post getPost(@PathVariable Long id) {
        return postService.findById(id);
    }
}
```

### Global Method Security Evaluator

```java
@Component
public class GlobalSecurityEvaluator implements MethodSecurityExpressionHandler {
    
    public boolean isBusinessHours() {
        LocalTime now = LocalTime.now();
        return now.isAfter(LocalTime.of(9, 0)) && now.isBefore(LocalTime.of(17, 0));
    }
    
    public boolean isWeekday() {
        DayOfWeek day = LocalDate.now().getDayOfWeek();
        return day != DayOfWeek.SATURDAY && day != DayOfWeek.SUNDAY;
    }
}

@PreAuthorize("@globalSecurityEvaluator.isBusinessHours() and @globalSecurityEvaluator.isWeekday()")
public void processPayroll() {
    // Only during business hours on weekdays
}
```

---

## üìå Best Practices

### 1. Use @PreAuthorize for Complex Logic

```java
// ‚úÖ Good - Complex authorization
@PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")
public void updateUser(Long userId, UserDTO dto) { }

// ‚ùå Bad - Use @Secured for simple checks
@Secured("ROLE_ADMIN")
public void simpleAdminOperation() { }
```

### 2. Validate Method Parameters

```java
// ‚úÖ Good - Parameter validation
@PreAuthorize("#userId != null and #userId == authentication.principal.id")
public void deleteAccount(Long userId) { }
```

### 3. Use Custom Security Beans

```java
// ‚úÖ Good - Reusable logic
@Component("security")
public class SecurityService {
    public boolean canAccess(Long resourceId) {
        // Complex reusable logic
    }
}

@PreAuthorize("@security.canAccess(#id)")
public Resource getResource(Long id) { }
```

### 4. Prefer @PreAuthorize Over URL Security

```java
// ‚úÖ Good - Method-level
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) { }

// ‚ùå Less flexible - URL-level only
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/admin/**").hasRole("ADMIN")
);
```

### 5. Use @PostFilter for Large Datasets Carefully

```java
// ‚ö†Ô∏è Performance issue - Loads all, then filters
@PostFilter("filterObject.userId == authentication.principal.id")
public List<Order> getAllOrders() {
    return orderRepository.findAll(); // Loads 1M records
}

// ‚úÖ Better - Query filtering
public List<Order> getAllOrders() {
    Long userId = getCurrentUserId();
    return orderRepository.findByUserId(userId);
}
```

### 6. Combine URL and Method Security

```java
// URL-level: Broad protection
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/api/admin/**").hasRole("ADMIN")
);

// Method-level: Fine-grained
@PreAuthorize("hasRole('ADMIN') and #userId != 1")
public void deleteUser(Long userId) {
    // Additional check: Can't delete super admin (ID=1)
}
```

### 7. Test Security Annotations

```java
@SpringBootTest
@WithMockUser(username = "user", roles = "USER")
class SecurityTest {
    
    @Test
    void testUserCanAccessOwnProfile() {
        // Test passes
        userService.getProfile(currentUserId);
    }
    
    @Test
    @WithMockUser(roles = "ADMIN")
    void testAdminCanAccessAllProfiles() {
        // Test with admin role
        userService.getProfile(anyUserId);
    }
    
    @Test
    @WithMockUser(roles = "USER")
    void testUserCannotAccessAdminEndpoint() {
        assertThrows(AccessDeniedException.class, () -> {
            adminService.deleteUser(1L);
        });
    }
}
```

---

## üé§ Interview Questions

### Q1: What is method security?
**Answer:** Securing individual methods with annotations for fine-grained access control.

### Q2: How to enable method security?
**Answer:**
```java
@EnableMethodSecurity(prePostEnabled = true)
```

### Q3: Difference between @PreAuthorize and @Secured?
**Answer:** @PreAuthorize supports SpEL expressions, @Secured only role names.

### Q4: What is @PostAuthorize?
**Answer:** Checks authorization AFTER method execution based on return value.

### Q5: What is SpEL?
**Answer:** Spring Expression Language - powerful expression language for runtime evaluation.

### Q6: How to check parameter ownership?
**Answer:**
```java
@PreAuthorize("#userId == authentication.principal.id")
```

### Q7: What is @PreFilter?
**Answer:** Filters input collection before method execution.

### Q8: What is @PostFilter?
**Answer:** Filters output collection after method execution.

### Q9: Difference between hasRole and hasAuthority?
**Answer:** hasRole adds ROLE_ prefix, hasAuthority uses exact string.

### Q10: Can you combine multiple roles?
**Answer:**
```java
@PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")
// OR
@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
```

### Q11: What is authentication.principal?
**Answer:** Currently authenticated user's UserDetails object.

### Q12: How to create custom security expression?
**Answer:** Create @Component bean with security methods, reference with @bean_name.

### Q13: What is returnObject?
**Answer:** In @PostAuthorize, refers to method's return value.

### Q14: What is filterObject?
**Answer:** In @PreFilter/@PostFilter, refers to current item in collection.

### Q15: Can @Secured use expressions?
**Answer:** No, only role names.

### Q16: What is @RolesAllowed?
**Answer:** JSR-250 annotation for role-based security.

### Q17: How to access method parameters in SpEL?
**Answer:** Use #parameterName (e.g., #userId, #post).

### Q18: Performance issue with @PostFilter?
**Answer:** Loads all data then filters, inefficient for large datasets.

### Q19: Can you combine @PreAuthorize and @PostAuthorize?
**Answer:** Yes, both execute (pre before, post after method).

### Q20: Best practice for method security?
**Answer:**
1. Use @PreAuthorize for complex logic
2. Custom beans for reusable logic
3. Avoid @PostFilter for large data
4. Test security annotations
5. Combine with URL security

---

## üìö Summary

### Quick Reference

```java
// Enable
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)

// Simple role
@Secured("ROLE_ADMIN")
@RolesAllowed("ADMIN")

// Complex authorization
@PreAuthorize("hasRole('ADMIN') or #userId == authentication.principal.id")

// Check return value
@PostAuthorize("returnObject.owner == authentication.name")

// Filter collections
@PreFilter("filterObject.status == 'ACTIVE'")
@PostFilter("filterObject.userId == authentication.principal.id")

// Custom security
@PreAuthorize("@customSecurity.canAccess(#id)")
```

### Key Annotations

- **@PreAuthorize:** Before method, supports SpEL
- **@PostAuthorize:** After method, check result
- **@Secured:** Simple role check
- **@RolesAllowed:** JSR-250 standard
- **@PreFilter:** Filter input collection
- **@PostFilter:** Filter output collection

**Next:** CORS Configuration ‚Üí

