# ğŸ« JWT Authentication - Complete Guide

## ğŸ“‹ Table of Contents
- [Introduction](#introduction)
- [JWT Structure](#jwt-structure)
- [JWT Dependencies](#jwt-dependencies)
- [JWT Utility Class](#jwt-utility-class)
- [JWT Authentication Filter](#jwt-authentication-filter)
- [Security Configuration](#security-configuration)
- [Authentication Controller](#authentication-controller)
- [Refresh Token](#refresh-token)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ğŸ¯ Introduction

**JWT (JSON Web Token)** is a compact, URL-safe token for secure information transmission between parties.

### Why JWT?

```
Traditional Session-Based:
Client â†’ Login â†’ Server creates session â†’ Session ID in cookie
Client â†’ Request with cookie â†’ Server looks up session â†’ Response

JWT Stateless:
Client â†’ Login â†’ Server creates JWT â†’ JWT returned
Client â†’ Request with JWT in header â†’ Server verifies JWT â†’ Response

Benefits:
âœ… Stateless (no server-side storage)
âœ… Scalable (works across multiple servers)
âœ… Mobile-friendly (no cookies needed)
âœ… Cross-domain authentication
```

### JWT vs Session

| Feature | JWT | Session |
|---------|-----|---------|
| Storage | Client-side | Server-side |
| Scalability | High | Limited |
| State | Stateless | Stateful |
| Size | Larger | Smaller |
| Revocation | Difficult | Easy |
| Best For | APIs, Microservices | Web apps |

---

## ğŸ“¦ JWT Structure

### Three Parts

```
JWT = Header.Payload.Signature

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Signature â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1. Header

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 2. Payload (Claims)

```json
{
  "sub": "1234567890",      // Subject (user ID)
  "name": "John Doe",       // Custom claim
  "email": "john@example.com",
  "roles": ["USER", "ADMIN"],
  "iat": 1516239022,        // Issued At
  "exp": 1516242622         // Expiration
}
```

### 3. Signature

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### Standard Claims

| Claim | Name | Description |
|-------|------|-------------|
| iss | Issuer | Who issued the token |
| sub | Subject | User identifier |
| aud | Audience | Token recipient |
| exp | Expiration | Token expiry time |
| nbf | Not Before | Token valid after |
| iat | Issued At | Token creation time |
| jti | JWT ID | Unique token ID |

---

## ğŸ“š JWT Dependencies

### Maven

```xml
<dependencies>
    <!-- Spring Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.12.3</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

### Gradle

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'
}
```

---

## ğŸ”§ JWT Utility Class

### Complete JWT Service

```java
@Service
public class JwtService {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long jwtExpiration;
    
    @Value("${jwt.refresh-token.expiration}")
    private Long refreshExpiration;
    
    private Key getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secret);
        return Keys.hmacShaKeyFor(keyBytes);
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }
    
    public String generateToken(Map<String, Object> extraClaims, UserDetails userDetails) {
        return buildToken(extraClaims, userDetails, jwtExpiration);
    }
    
    public String generateRefreshToken(UserDetails userDetails) {
        return buildToken(new HashMap<>(), userDetails, refreshExpiration);
    }
    
    private String buildToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails,
            long expiration
    ) {
        return Jwts.builder()
                .claims(extraClaims)
                .subject(userDetails.getUsername())
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), Jwts.SIG.HS256)
                .compact();
    }
    
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }
    
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith((SecretKey) getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
```

### Configuration Properties

```properties
# application.properties
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.expiration=86400000
jwt.refresh-token.expiration=604800000
```

```yaml
# application.yml
jwt:
  secret: 404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
  expiration: 86400000  # 1 day
  refresh-token:
    expiration: 604800000  # 7 days
```

### Generate Secret Key

```java
public class SecretKeyGenerator {
    public static void main(String[] args) {
        SecretKey key = Jwts.SIG.HS256.key().build();
        String secretString = Encoders.BASE64.encode(key.getEncoded());
        System.out.println("Secret Key: " + secretString);
    }
}
```

---

## ğŸ” JWT Authentication Filter

### JWT Filter Implementation

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtService jwtService;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {
        
        final String authHeader = request.getHeader("Authorization");
        final String jwt;
        final String userEmail;
        
        // Check if Authorization header exists and starts with "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }
        
        // Extract JWT token
        jwt = authHeader.substring(7);
        
        try {
            // Extract username from JWT
            userEmail = jwtService.extractUsername(jwt);
            
            // If username exists and user is not already authenticated
            if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);
                
                // Validate token
                if (jwtService.isTokenValid(jwt, userDetails)) {
                    UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities()
                    );
                    
                    authToken.setDetails(
                            new WebAuthenticationDetailsSource().buildDetails(request)
                    );
                    
                    // Update Security Context
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }
            }
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"Token expired\"}");
            return;
        } catch (JwtException e) {
            log.error("JWT validation failed: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("{\"error\":\"Invalid token\"}");
            return;
        }
        
        filterChain.doFilter(request, response);
    }
}
```

---

## âš™ï¸ Security Configuration

### Complete Security Config

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/api/public/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

## ğŸ® Authentication Controller

### DTOs

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthenticationRequest {
    private String email;
    private String password;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AuthenticationResponse {
    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";
    private Long expiresIn;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class RegisterRequest {
    private String firstName;
    private String lastName;
    private String email;
    private String password;
}
```

### Authentication Service

```java
@Service
public class AuthenticationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private JwtService jwtService;
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    public AuthenticationResponse register(RegisterRequest request) {
        // Check if user already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("Email already registered");
        }
        
        // Create user
        var user = User.builder()
                .firstName(request.getFirstName())
                .lastName(request.getLastName())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(Role.USER)
                .enabled(true)
                .build();
        
        userRepository.save(user);
        
        // Generate tokens
        var jwtToken = jwtService.generateToken(user);
        var refreshToken = jwtService.generateRefreshToken(user);
        
        return AuthenticationResponse.builder()
                .accessToken(jwtToken)
                .refreshToken(refreshToken)
                .expiresIn(86400000L) // 24 hours
                .build();
    }
    
    public AuthenticationResponse authenticate(AuthenticationRequest request) {
        // Authenticate user
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.getEmail(),
                        request.getPassword()
                )
        );
        
        // Load user
        var user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        // Generate tokens
        var jwtToken = jwtService.generateToken(user);
        var refreshToken = jwtService.generateRefreshToken(user);
        
        return AuthenticationResponse.builder()
                .accessToken(jwtToken)
                .refreshToken(refreshToken)
                .expiresIn(86400000L)
                .build();
    }
    
    public AuthenticationResponse refreshToken(String refreshToken) {
        // Extract username
        final String userEmail = jwtService.extractUsername(refreshToken);
        
        if (userEmail != null) {
            var user = userRepository.findByEmail(userEmail)
                    .orElseThrow(() -> new UsernameNotFoundException("User not found"));
            
            if (jwtService.isTokenValid(refreshToken, user)) {
                var accessToken = jwtService.generateToken(user);
                
                return AuthenticationResponse.builder()
                        .accessToken(accessToken)
                        .refreshToken(refreshToken)
                        .expiresIn(86400000L)
                        .build();
            }
        }
        
        throw new RuntimeException("Invalid refresh token");
    }
}
```

### REST Controller

```java
@RestController
@RequestMapping("/api/auth")
public class AuthenticationController {
    
    @Autowired
    private AuthenticationService authService;
    
    @PostMapping("/register")
    public ResponseEntity<AuthenticationResponse> register(
            @RequestBody RegisterRequest request
    ) {
        return ResponseEntity.ok(authService.register(request));
    }
    
    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> authenticate(
            @RequestBody AuthenticationRequest request
    ) {
        return ResponseEntity.ok(authService.authenticate(request));
    }
    
    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refreshToken(
            @RequestHeader("Authorization") String authHeader
    ) {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
        
        String refreshToken = authHeader.substring(7);
        return ResponseEntity.ok(authService.refreshToken(refreshToken));
    }
    
    @GetMapping("/me")
    public ResponseEntity<?> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return ResponseEntity.ok(userDetails);
    }
}
```

---

## ğŸ”„ Refresh Token

### Token Entity

```java
@Entity
@Table(name = "refresh_tokens")
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String token;
    
    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(nullable = false)
    private Instant expiryDate;
    
    private boolean revoked = false;
    
    // Getters and setters
}
```

### Refresh Token Service

```java
@Service
public class RefreshTokenService {
    
    @Value("${jwt.refresh-token.expiration}")
    private Long refreshTokenDuration;
    
    @Autowired
    private RefreshTokenRepository refreshTokenRepository;
    
    @Autowired
    private UserRepository userRepository;
    
    public RefreshToken createRefreshToken(Long userId) {
        RefreshToken refreshToken = new RefreshToken();
        
        refreshToken.setUser(userRepository.findById(userId).get());
        refreshToken.setExpiryDate(Instant.now().plusMillis(refreshTokenDuration));
        refreshToken.setToken(UUID.randomUUID().toString());
        
        refreshToken = refreshTokenRepository.save(refreshToken);
        return refreshToken;
    }
    
    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }
    
    public RefreshToken verifyExpiration(RefreshToken token) {
        if (token.getExpiryDate().compareTo(Instant.now()) < 0) {
            refreshTokenRepository.delete(token);
            throw new RuntimeException("Refresh token was expired. Please make a new signin request");
        }
        
        return token;
    }
    
    public void revokeToken(String token) {
        refreshTokenRepository.findByToken(token).ifPresent(rt -> {
            rt.setRevoked(true);
            refreshTokenRepository.save(rt);
        });
    }
    
    @Transactional
    public int deleteByUserId(Long userId) {
        return refreshTokenRepository.deleteByUser(userRepository.findById(userId).get());
    }
}
```

---

## ğŸ“Œ Best Practices

### 1. Use Strong Secret Key

```java
// âœ… Good - Strong, random secret (256-bit)
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

// âŒ Bad - Weak secret
jwt.secret=secret123
```

### 2. Set Appropriate Expiration

```java
// âœ… Good - Short-lived access token
jwt.expiration=900000  # 15 minutes

// âœ… Good - Longer refresh token
jwt.refresh-token.expiration=604800000  # 7 days
```

### 3. Validate Token on Every Request

```java
// âœ… Good - Filter validates all requests
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    // Validation logic
}
```

### 4. Use HTTPS in Production

```properties
# âœ… Good - Force HTTPS
server.ssl.enabled=true
```

### 5. Include Minimal Claims

```java
// âœ… Good - Only essential claims
Map<String, Object> claims = new HashMap<>();
claims.put("role", user.getRole());

// âŒ Bad - Sensitive data
claims.put("password", user.getPassword());
claims.put("creditCard", user.getCreditCard());
```

### 6. Implement Token Blacklist

```java
@Service
public class TokenBlacklistService {
    
    private final Set<String> blacklist = new ConcurrentHashSet<>();
    
    public void blacklistToken(String token) {
        blacklist.add(token);
    }
    
    public boolean isBlacklisted(String token) {
        return blacklist.contains(token);
    }
}
```

### 7. Handle Token Expiration Gracefully

```java
// âœ… Good - Return clear error
catch (ExpiredJwtException e) {
    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    response.getWriter().write("{\"error\":\"Token expired\"}");
}
```

---

## ğŸ¤ Interview Questions

### Q1: What is JWT?
**Answer:** JSON Web Token - compact, URL-safe token for secure information transmission.

### Q2: JWT structure?
**Answer:** Header.Payload.Signature (Base64 encoded)

### Q3: What are JWT claims?
**Answer:** Statements about entity (user), includes standard (iss, sub, exp) and custom claims.

### Q4: JWT vs Session?
**Answer:** JWT is stateless (client-side), Session is stateful (server-side). JWT better for APIs/microservices.

### Q5: How to verify JWT?
**Answer:** Extract signature, recompute using header+payload+secret, compare.

### Q6: Where to store JWT?
**Answer:** 
- Web: localStorage or sessionStorage
- Mobile: Secure storage
- Never in cookies (CSRF risk)

### Q7: What is refresh token?
**Answer:** Long-lived token to obtain new access token without re-authentication.

### Q8: How to revoke JWT?
**Answer:** Implement token blacklist or store tokens in database with revoked flag.

### Q9: JWT expiration best practice?
**Answer:** Access token: 15 min - 1 hour, Refresh token: 7-30 days

### Q10: What algorithm for JWT signature?
**Answer:** HS256 (HMAC-SHA256) for symmetric, RS256 (RSA) for asymmetric.

### Q11: Can JWT be tampered?
**Answer:** No, any change invalidates signature.

### Q12: Is JWT encrypted?
**Answer:** No, Base64 encoded (not encrypted). Use JWE for encryption.

### Q13: What is "Bearer" in Authorization header?
**Answer:** Authentication scheme indicating token-based authentication.

### Q14: How to send JWT?
**Answer:**
```
Authorization: Bearer <token>
```

### Q15: What is jti claim?
**Answer:** JWT ID - unique identifier for token, useful for revocation.

### Q16: Difference between HS256 and RS256?
**Answer:** HS256 uses shared secret (symmetric), RS256 uses public/private key (asymmetric).

### Q17: Can you decode JWT without secret?
**Answer:** Yes, can decode header and payload (Base64), but can't verify signature.

### Q18: What is token introspection?
**Answer:** Checking token validity, claims, and metadata.

### Q19: Best library for JWT in Spring Boot?
**Answer:** jjwt (io.jsonwebtoken) - most popular and actively maintained.

### Q20: Security concerns with JWT?
**Answer:**
1. Store secret securely
2. Use HTTPS
3. Short expiration
4. Validate on every request
5. Don't store sensitive data
6. Implement token blacklist

---

## ğŸ“š Summary

### Complete Flow

```
1. User Login:
   POST /api/auth/login
   Body: { "email": "user@example.com", "password": "pass123" }
   Response: { "accessToken": "...", "refreshToken": "..." }

2. Access Protected Resource:
   GET /api/users/profile
   Header: Authorization: Bearer <accessToken>
   Response: User data

3. Refresh Token:
   POST /api/auth/refresh
   Header: Authorization: Bearer <refreshToken>
   Response: { "accessToken": "...", "refreshToken": "..." }
```

### Key Components

- **JwtService:** Generate and validate tokens
- **JwtAuthenticationFilter:** Intercept requests, validate JWT
- **SecurityConfig:** Configure stateless session, add JWT filter
- **AuthenticationController:** Login, register, refresh endpoints

**Next:** OAuth2 & Social Login â†’

