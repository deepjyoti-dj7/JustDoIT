# ðŸ” Authentication vs Authorization - Complete Guide

## ðŸ“‹ Table of Contents
- [Introduction](#introduction)
- [Authentication](#authentication)
- [Authorization](#authorization)
- [Authentication Types](#authentication-types)
- [Authorization Strategies](#authorization-strategies)
- [Role vs Authority](#role-vs-authority)
- [Access Control](#access-control)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## ðŸŽ¯ Introduction

Understanding the distinction between **Authentication** and **Authorization** is fundamental to application security.

### Quick Comparison

| Aspect | Authentication | Authorization |
|--------|---------------|---------------|
| **Question** | Who are you? | What can you do? |
| **Purpose** | Verify identity | Check permissions |
| **Timing** | First step | Second step |
| **Method** | Credentials (username/password) | Roles, permissions |
| **Failure** | 401 Unauthorized | 403 Forbidden |
| **Example** | Login with username/password | Admin can delete users |

### Flow Diagram

```
Request â†’ Authentication â†’ Authorization â†’ Resource
          â†“                â†“
       Login?          Has Permission?
       âœ… Yes           âœ… Yes â†’ Access Granted
       âŒ No            âŒ No â†’ 403 Forbidden
       â†“
   401 Unauthorized
```

---

## ðŸ”‘ Authentication

**Authentication** is the process of verifying identity - proving you are who you claim to be.

### Authentication Process

```
1. User submits credentials (username + password)
   â†“
2. Spring Security filters intercept request
   â†“
3. AuthenticationManager validates credentials
   â†“
4. UserDetailsService loads user from database
   â†“
5. PasswordEncoder compares passwords
   â†“
6. If valid: Create Authentication object
   â†“
7. Store in SecurityContext
   â†“
8. Return success/failure
```

### Authentication Implementation

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getUsername())
            .password(user.getPassword()) // Already encoded
            .authorities(getAuthorities(user))
            .accountExpired(!user.isAccountNonExpired())
            .accountLocked(!user.isAccountNonLocked())
            .credentialsExpired(!user.isCredentialsNonExpired())
            .disabled(!user.isEnabled())
            .build();
    }
    
    private Collection<? extends GrantedAuthority> getAuthorities(User user) {
        return user.getRoles().stream()
            .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
            .collect(Collectors.toList());
    }
}
```

### AuthenticationManager Configuration

```java
@Configuration
@EnableWebSecurity
public class AuthenticationConfig {
    
    @Autowired
    private CustomUserDetailsService userDetailsService;
    
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### Manual Authentication

```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        try {
            // Authenticate user
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    request.getUsername(),
                    request.getPassword()
                )
            );
            
            // Set authentication in SecurityContext
            SecurityContextHolder.getContext().setAuthentication(authentication);
            
            return ResponseEntity.ok(new AuthResponse("Login successful"));
            
        } catch (AuthenticationException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse("Invalid credentials"));
        }
    }
}
```

---

## ðŸ›¡ï¸ Authorization

**Authorization** determines what an authenticated user is allowed to do.

### Authorization Levels

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Authorization Hierarchy         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  1. URL-based (HttpSecurity)        â”‚
â”‚     â””â”€ /api/admin/** â†’ ROLE_ADMIN   â”‚
â”‚                                     â”‚
â”‚  2. Method-based (@PreAuthorize)    â”‚
â”‚     â””â”€ @PreAuthorize("hasRole...")  â”‚
â”‚                                     â”‚
â”‚  3. Domain Object-based (ACL)       â”‚
â”‚     â””â”€ User can edit own posts      â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### URL-Based Authorization

```java
@Configuration
@EnableWebSecurity
public class AuthorizationConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                // Public endpoints
                .requestMatchers("/", "/login", "/register").permitAll()
                .requestMatchers("/css/**", "/js/**", "/images/**").permitAll()
                
                // User endpoints
                .requestMatchers("/api/user/**").hasRole("USER")
                
                // Admin endpoints
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/admin/users/**").hasAuthority("DELETE_USER")
                
                // Manager endpoints
                .requestMatchers("/api/manager/**").hasAnyRole("ADMIN", "MANAGER")
                
                // Any other request must be authenticated
                .anyRequest().authenticated()
            );
        
        return http.build();
    }
}
```

### Method-Based Authorization

```java
@Service
@EnableMethodSecurity(prePostEnabled = true)
public class UserService {
    
    // Only ADMIN can access
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
    
    // ADMIN or MANAGER can access
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    // Check specific authority
    @PreAuthorize("hasAuthority('DELETE_USER')")
    public void deleteUserByAuthority(Long id) {
        userRepository.deleteById(id);
    }
    
    // Check multiple conditions
    @PreAuthorize("hasRole('ADMIN') and #userId == authentication.principal.id")
    public void updateOwnProfile(Long userId, UserUpdateRequest request) {
        // Only admin can update their own profile
    }
    
    // Post-authorization (after method execution)
    @PostAuthorize("returnObject.username == authentication.name")
    public User getUserDetails(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

### Expression-Based Access Control

```java
@RestController
@RequestMapping("/api/posts")
public class PostController {
    
    // Complex expressions
    @PreAuthorize("hasRole('ADMIN') or " +
                  "(hasRole('USER') and #post.author.username == authentication.name)")
    public ResponseEntity<?> updatePost(Long id, @RequestBody Post post) {
        // Admin can update any post
        // User can update only their own posts
        return ResponseEntity.ok(postService.update(id, post));
    }
    
    // Using custom expression
    @PreAuthorize("@postSecurity.canEdit(#id)")
    public ResponseEntity<?> editPost(Long id, @RequestBody Post post) {
        return ResponseEntity.ok(postService.update(id, post));
    }
}

// Custom security expression
@Component("postSecurity")
public class PostSecurityExpression {
    
    @Autowired
    private PostRepository postRepository;
    
    public boolean canEdit(Long postId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();
        
        Post post = postRepository.findById(postId).orElse(null);
        
        if (post == null) return false;
        
        // User can edit their own post or admin can edit any
        return post.getAuthor().getUsername().equals(username) ||
               auth.getAuthorities().stream()
                   .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }
}
```

---

## ðŸ” Authentication Types

### 1. Form-Based Authentication

```java
http.formLogin(form -> form
    .loginPage("/login")
    .defaultSuccessUrl("/home")
    .failureUrl("/login?error=true")
);
```

### 2. HTTP Basic Authentication

```java
http.httpBasic(Customizer.withDefaults());
```

```bash
# Request
curl -u username:password http://localhost:8080/api/users
```

### 3. JWT Authentication

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                   HttpServletResponse response,
                                   FilterChain filterChain) throws ServletException, IOException {
        
        String token = extractToken(request);
        
        if (token != null && jwtTokenProvider.validateToken(token)) {
            Authentication auth = jwtTokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 4. OAuth2 Authentication

```java
http.oauth2Login(oauth -> oauth
    .loginPage("/oauth2/login")
    .defaultSuccessUrl("/home")
);
```

### 5. Remember-Me Authentication

```java
http.rememberMe(remember -> remember
    .key("uniqueAndSecret")
    .tokenValiditySeconds(86400) // 24 hours
    .userDetailsService(userDetailsService)
);
```

---

## ðŸŽ¯ Authorization Strategies

### Role-Based Access Control (RBAC)

```java
// Entity
@Entity
public class User {
    @Id
    private Long id;
    
    private String username;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
}

@Entity
public class Role {
    @Id
    private Long id;
    
    private String name; // ROLE_USER, ROLE_ADMIN
}

// Usage
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}
```

### Permission-Based Access Control

```java
@Entity
public class Role {
    @Id
    private Long id;
    
    private String name;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "role_permissions",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    private Set<Permission> permissions = new HashSet<>();
}

@Entity
public class Permission {
    @Id
    private Long id;
    
    private String name; // READ_USER, WRITE_USER, DELETE_USER
}

// Usage
@PreAuthorize("hasAuthority('DELETE_USER')")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}
```

### Attribute-Based Access Control (ABAC)

```java
@PreAuthorize("@userSecurity.canAccess(#userId)")
public User getUser(Long userId) {
    return userRepository.findById(userId).orElse(null);
}

@Component("userSecurity")
public class UserSecurity {
    
    public boolean canAccess(Long userId) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        CustomUserDetails user = (CustomUserDetails) auth.getPrincipal();
        
        // Check multiple attributes
        return user.getId().equals(userId) ||
               user.getDepartment().equals("HR") ||
               auth.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"));
    }
}
```

---

## ðŸ‘¥ Role vs Authority

### Understanding the Difference

| Aspect | Role | Authority |
|--------|------|-----------|
| **Prefix** | ROLE_ (auto-added) | None |
| **Granularity** | Coarse (ADMIN, USER) | Fine (READ_USER, DELETE_POST) |
| **Usage** | `hasRole('ADMIN')` | `hasAuthority('DELETE_USER')` |
| **Example** | ROLE_ADMIN | DELETE_USER, READ_POST |

### Implementation

```java
// User has ROLE_ADMIN
@PreAuthorize("hasRole('ADMIN')")  // Checks for "ROLE_ADMIN"
public void method1() { }

// User has authority DELETE_USER
@PreAuthorize("hasAuthority('DELETE_USER')")  // Checks for "DELETE_USER"
public void method2() { }

// Combining both
@PreAuthorize("hasRole('ADMIN') and hasAuthority('DELETE_USER')")
public void method3() { }
```

### Loading Roles and Authorities

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Override
    public UserDetails loadUserByUsername(String username) {
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // Add roles (with ROLE_ prefix)
        user.getRoles().forEach(role -> {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));
            
            // Add permissions from each role
            role.getPermissions().forEach(permission -> 
                authorities.add(new SimpleGrantedAuthority(permission.getName()))
            );
        });
        
        return new org.springframework.security.core.userdetails.User(
            user.getUsername(),
            user.getPassword(),
            authorities
        );
    }
}
```

---

## ðŸ” Access Control

### Hierarchical Roles

```java
@Bean
public RoleHierarchy roleHierarchy() {
    RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
    hierarchy.setHierarchy(
        "ROLE_ADMIN > ROLE_MANAGER\n" +
        "ROLE_MANAGER > ROLE_USER\n" +
        "ROLE_USER > ROLE_GUEST"
    );
    return hierarchy;
}

// Admin automatically has MANAGER, USER, GUEST permissions
@PreAuthorize("hasRole('USER')")  // Admin, Manager, User can access
public void method() { }
```

### Custom Access Decision Manager

```java
@Component
public class CustomAccessDecisionManager implements AccessDecisionManager {
    
    @Override
    public void decide(Authentication authentication, Object object,
                      Collection<ConfigAttribute> configAttributes) {
        
        if (configAttributes == null) return;
        
        for (ConfigAttribute attribute : configAttributes) {
            if (!"ROLE_USER".equals(attribute.getAttribute())) {
                continue;
            }
            
            // Custom logic
            if (authentication.getAuthorities().stream()
                    .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))) {
                return; // Admin can access
            }
            
            // Check custom conditions
            if (isBusinessHours()) {
                return; // Allow during business hours
            }
            
            throw new AccessDeniedException("Access denied");
        }
    }
    
    private boolean isBusinessHours() {
        LocalTime now = LocalTime.now();
        return now.isAfter(LocalTime.of(9, 0)) && 
               now.isBefore(LocalTime.of(17, 0));
    }
}
```

---

## ðŸŽ¯ Common Patterns

### 1. Protect by Ownership

```java
@PreAuthorize("#userId == authentication.principal.id or hasRole('ADMIN')")
public User updateUser(Long userId, User user) {
    return userRepository.save(user);
}
```

### 2. Method Parameter Security

```java
@PreAuthorize("@postService.isOwner(#postId, authentication.name)")
public void deletePost(Long postId) {
    postRepository.deleteById(postId);
}

@Service
public class PostService {
    public boolean isOwner(Long postId, String username) {
        Post post = postRepository.findById(postId).orElse(null);
        return post != null && post.getAuthor().getUsername().equals(username);
    }
}
```

### 3. Return Value Filtering

```java
@PostFilter("filterObject.author.username == authentication.name or hasRole('ADMIN')")
public List<Post> getAllPosts() {
    return postRepository.findAll();
    // Users see only their posts, admins see all
}
```

### 4. Securing Exceptions

```java
@ExceptionHandler(AccessDeniedException.class)
public ResponseEntity<?> handleAccessDenied(AccessDeniedException ex) {
    return ResponseEntity.status(HttpStatus.FORBIDDEN)
        .body(new ErrorResponse("Access denied: " + ex.getMessage()));
}
```

---

## ðŸ“Œ Best Practices

### 1. Use Specific Permissions

```java
// âœ… Good - Specific permission
@PreAuthorize("hasAuthority('DELETE_USER')")
public void deleteUser(Long id) { }

// âŒ Bad - Too broad
@PreAuthorize("hasRole('ADMIN')")
public void deleteUser(Long id) { }
```

### 2. Combine Roles and Permissions

```java
// âœ… Good - Flexible
@PreAuthorize("hasRole('ADMIN') or hasAuthority('DELETE_USER')")
public void deleteUser(Long id) { }
```

### 3. Fail Securely

```java
// âœ… Good - Default deny
.anyRequest().authenticated()

// âŒ Bad - Default allow
.anyRequest().permitAll()
```

### 4. Validate at Multiple Layers

```java
// Layer 1: URL
.requestMatchers("/api/admin/**").hasRole("ADMIN")

// Layer 2: Method
@PreAuthorize("hasRole('ADMIN')")
public void adminMethod() { }

// Layer 3: Business logic
if (!currentUser.isAdmin()) {
    throw new AccessDeniedException("Admin only");
}
```

### 5. Log Authorization Failures

```java
@EventListener
public void onAccessDenied(AuthorizationDeniedEvent event) {
    log.warn("Access denied for user {} to resource {}",
        event.getAuthentication().getName(),
        event.getSource());
}
```

---

## ðŸŽ¤ Interview Questions

### Q1: Authentication vs Authorization?
**Answer:**
- **Authentication:** Who are you? (Login) â†’ 401 if fails
- **Authorization:** What can you do? (Permissions) â†’ 403 if fails

### Q2: What is Principal?
**Answer:** Object representing authenticated user, contains user identity (username, email).

### Q3: hasRole() vs hasAuthority()?
**Answer:**
- **hasRole('ADMIN'):** Checks for "ROLE_ADMIN" (auto-prefixed)
- **hasAuthority('ADMIN'):** Checks for exact "ADMIN"

### Q4: What is @PreAuthorize?
**Answer:** Annotation for method-level security, checks authorization before method execution.

### Q5: What is @PostAuthorize?
**Answer:** Checks authorization after method execution, can access return value.

### Q6: Difference between @PreAuthorize and @Secured?
**Answer:**
- **@PreAuthorize:** Supports SpEL expressions
- **@Secured:** Simpler, only role checks

### Q7: What is GrantedAuthority?
**Answer:** Interface representing permission/role granted to user.

### Q8: How to check if user is authenticated?
**Answer:**
```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
boolean isAuthenticated = auth != null && auth.isAuthenticated();
```

### Q9: What is RoleHierarchy?
**Answer:** Defines role inheritance (ADMIN > MANAGER > USER), higher roles automatically have lower role permissions.

### Q10: How to combine multiple security expressions?
**Answer:**
```java
@PreAuthorize("hasRole('ADMIN') and hasAuthority('DELETE_USER')")
```

### Q11: What is @PostFilter?
**Answer:** Filters collection return values based on expression, removes items user can't access.

### Q12: What is AccessDeniedException?
**Answer:** Exception thrown when authenticated user lacks required permissions (403 Forbidden).

### Q13: How to secure by ownership?
**Answer:**
```java
@PreAuthorize("#userId == authentication.principal.id")
public User updateProfile(Long userId) { }
```

### Q14: What is custom security expression?
**Answer:** Bean method called in @PreAuthorize for complex authorization logic.

### Q15: HTTP status for auth failures?
**Answer:**
- **401 Unauthorized:** Not authenticated
- **403 Forbidden:** Authenticated but not authorized

### Q16: How to enable method security?
**Answer:**
```java
@EnableMethodSecurity(prePostEnabled = true)
```

### Q17: What is AccessDecisionManager?
**Answer:** Makes final authorization decision, can implement custom voting logic.

### Q18: How to get current user's roles?
**Answer:**
```java
Collection<? extends GrantedAuthority> authorities = 
    SecurityContextHolder.getContext().getAuthentication().getAuthorities();
```

### Q19: Can you have multiple @PreAuthorize?
**Answer:** No, use combined expressions:
```java
@PreAuthorize("hasRole('ADMIN') and hasAuthority('DELETE')")
```

### Q20: Best practice for authorization?
**Answer:**
1. Principle of least privilege
2. Combine URL and method security
3. Use specific permissions
4. Fail securely (default deny)
5. Log authorization events

---

## ðŸ“š Summary

### Authentication

```java
// Verify identity
Authentication auth = authenticationManager.authenticate(
    new UsernamePasswordAuthenticationToken(username, password)
);
SecurityContextHolder.getContext().setAuthentication(auth);
```

### Authorization

```java
// URL-based
.requestMatchers("/api/admin/**").hasRole("ADMIN")

// Method-based
@PreAuthorize("hasRole('ADMIN')")
public void adminMethod() { }

// Custom expression
@PreAuthorize("@postSecurity.canEdit(#id)")
public void editPost(Long id) { }
```

### Key Differences

| Authentication | Authorization |
|---------------|---------------|
| Login process | Permission check |
| UserDetailsService | @PreAuthorize, hasRole() |
| 401 Unauthorized | 403 Forbidden |
| Before authorization | After authentication |

**Next:** Security Configuration â†’

