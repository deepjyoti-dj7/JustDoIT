# üåê HTTP Methods - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [HTTP Methods Overview](#http-methods-overview)
- [GET Method](#get-method)
- [POST Method](#post-method)
- [PUT Method](#put-method)
- [PATCH Method](#patch-method)
- [DELETE Method](#delete-method)
- [HEAD Method](#head-method)
- [OPTIONS Method](#options-method)
- [Idempotency](#idempotency)
- [Method Selection Guide](#method-selection-guide)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**HTTP Methods** (verbs) define the action to perform on a resource in RESTful APIs.

### Standard HTTP Methods

| Method | Purpose | Idempotent | Safe |
|--------|---------|------------|------|
| **GET** | Retrieve resource | ‚úÖ Yes | ‚úÖ Yes |
| **POST** | Create resource | ‚ùå No | ‚ùå No |
| **PUT** | Update/Replace | ‚úÖ Yes | ‚ùå No |
| **PATCH** | Partial update | ‚ùå No | ‚ùå No |
| **DELETE** | Delete resource | ‚úÖ Yes | ‚ùå No |
| **HEAD** | Get headers only | ‚úÖ Yes | ‚úÖ Yes |
| **OPTIONS** | Get allowed methods | ‚úÖ Yes | ‚úÖ Yes |

---

## üìä HTTP Methods Overview

### CRUD Mapping

| Operation | HTTP Method | Example |
|-----------|-------------|---------|
| **Create** | POST | `POST /users` |
| **Read** | GET | `GET /users/{id}` |
| **Update** | PUT/PATCH | `PUT /users/{id}` |
| **Delete** | DELETE | `DELETE /users/{id}` |

### Safety and Idempotency

**Safe:** Method doesn't modify server state
- GET, HEAD, OPTIONS

**Idempotent:** Multiple identical requests have same effect as single request
- GET, PUT, DELETE, HEAD, OPTIONS

---

## üì• GET Method

### Purpose
Retrieve resource(s) without modifying server state.

### Characteristics
- ‚úÖ Safe
- ‚úÖ Idempotent
- ‚úÖ Cacheable
- ‚ùå No request body
- ‚úÖ Parameters in URL

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // Get all users
    @GetMapping
    public List<User> getAllUsers() {
        return userService.findAll();
    }
    
    // Get user by ID
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // Get users with query parameters
    @GetMapping("/search")
    public List<User> searchUsers(
            @RequestParam String name,
            @RequestParam(required = false) Integer minAge) {
        return userService.search(name, minAge);
    }
}
```

### Examples

```bash
# Get all users
GET /api/users

# Get specific user
GET /api/users/1

# Get with query parameters
GET /api/users/search?name=John&minAge=25

# Get nested resource
GET /api/users/1/orders
```

### Response

```java
@GetMapping("/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id) {
    return userService.findById(id)
        .map(user -> ResponseEntity.ok(user))               // 200 OK
        .orElse(ResponseEntity.notFound().build());         // 404 Not Found
}
```

### Query Parameters

```java
@GetMapping
public Page<User> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "id") String sortBy,
        @RequestParam(defaultValue = "asc") String sortDir) {
    
    Sort sort = sortDir.equalsIgnoreCase("asc") 
        ? Sort.by(sortBy).ascending() 
        : Sort.by(sortBy).descending();
    
    Pageable pageable = PageRequest.of(page, size, sort);
    return userService.findAll(pageable);
}
```

---

## üì§ POST Method

### Purpose
Create new resource.

### Characteristics
- ‚ùå Not safe
- ‚ùå Not idempotent
- ‚ùå Not cacheable
- ‚úÖ Request body
- Returns: 201 Created

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User created = userService.save(user);
        
        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(created.getId())
            .toUri();
        
        return ResponseEntity.created(location).body(created);
    }
}
```

### With Validation

```java
public class UserCreateDTO {
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50)
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email
    private String email;
    
    @Min(18)
    @Max(120)
    private int age;
    
    // Getters and setters
}

@PostMapping
public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateDTO dto) {
    User user = userService.create(dto);
    return ResponseEntity
        .status(HttpStatus.CREATED)
        .body(user);
}
```

### Examples

```bash
# Create user
POST /api/users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30
}

# Response: 201 Created
Location: /api/users/123

{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30
}
```

### Bulk Create

```java
@PostMapping("/bulk")
public ResponseEntity<List<User>> createUsers(@RequestBody List<UserCreateDTO> users) {
    List<User> created = userService.saveAll(users);
    return ResponseEntity
        .status(HttpStatus.CREATED)
        .body(created);
}
```

---

## üîÑ PUT Method

### Purpose
Update/replace existing resource completely.

### Characteristics
- ‚ùå Not safe
- ‚úÖ Idempotent
- ‚ùå Not cacheable
- ‚úÖ Request body (full resource)
- Returns: 200 OK or 204 No Content

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
            @PathVariable Long id,
            @RequestBody User user) {
        
        return userService.update(id, user)
            .map(updated -> ResponseEntity.ok(updated))       // 200 OK
            .orElse(ResponseEntity.notFound().build());       // 404 Not Found
    }
}
```

### Full Replacement

```java
@PutMapping("/{id}")
public ResponseEntity<User> replaceUser(
        @PathVariable Long id,
        @Valid @RequestBody UserUpdateDTO dto) {
    
    User user = userService.findById(id)
        .orElseThrow(() -> new UserNotFoundException(id));
    
    // Replace all fields
    user.setName(dto.getName());
    user.setEmail(dto.getEmail());
    user.setAge(dto.getAge());
    user.setAddress(dto.getAddress());
    user.setPhone(dto.getPhone());
    
    User updated = userService.save(user);
    return ResponseEntity.ok(updated);
}
```

### Examples

```bash
# Update user (full replacement)
PUT /api/users/1
Content-Type: application/json

{
  "name": "John Updated",
  "email": "john.new@example.com",
  "age": 31,
  "address": "123 Main St",
  "phone": "555-1234"
}

# Response: 200 OK
{
  "id": 1,
  "name": "John Updated",
  "email": "john.new@example.com",
  "age": 31,
  "address": "123 Main St",
  "phone": "555-1234"
}
```

### Create or Update (Upsert)

```java
@PutMapping("/{id}")
public ResponseEntity<User> upsertUser(
        @PathVariable Long id,
        @RequestBody User user) {
    
    Optional<User> existing = userService.findById(id);
    
    if (existing.isPresent()) {
        // Update existing
        User updated = userService.update(id, user);
        return ResponseEntity.ok(updated);  // 200 OK
    } else {
        // Create new
        user.setId(id);
        User created = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);  // 201 Created
    }
}
```

---

## üîß PATCH Method

### Purpose
Partially update resource (only specified fields).

### Characteristics
- ‚ùå Not safe
- ‚ùå Not idempotent
- ‚ùå Not cacheable
- ‚úÖ Request body (partial)
- Returns: 200 OK

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PatchMapping("/{id}")
    public ResponseEntity<User> patchUser(
            @PathVariable Long id,
            @RequestBody Map<String, Object> updates) {
        
        return userService.patch(id, updates)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
}
```

### Service Implementation

```java
@Service
public class UserService {
    
    public Optional<User> patch(Long id, Map<String, Object> updates) {
        return userRepository.findById(id)
            .map(user -> {
                updates.forEach((key, value) -> {
                    switch (key) {
                        case "name":
                            user.setName((String) value);
                            break;
                        case "email":
                            user.setEmail((String) value);
                            break;
                        case "age":
                            user.setAge((Integer) value);
                            break;
                        // Other fields...
                    }
                });
                return userRepository.save(user);
            });
    }
}
```

### Using DTOs

```java
public class UserPatchDTO {
    private String name;
    private String email;
    private Integer age;
    
    // Only fields that are present will be updated
    // Getters and setters
}

@PatchMapping("/{id}")
public ResponseEntity<User> patchUser(
        @PathVariable Long id,
        @RequestBody UserPatchDTO patchDTO) {
    
    User user = userService.findById(id)
        .orElseThrow(() -> new UserNotFoundException(id));
    
    // Update only non-null fields
    if (patchDTO.getName() != null) {
        user.setName(patchDTO.getName());
    }
    if (patchDTO.getEmail() != null) {
        user.setEmail(patchDTO.getEmail());
    }
    if (patchDTO.getAge() != null) {
        user.setAge(patchDTO.getAge());
    }
    
    User updated = userService.save(user);
    return ResponseEntity.ok(updated);
}
```

### Examples

```bash
# Partial update (only name)
PATCH /api/users/1
Content-Type: application/json

{
  "name": "John New Name"
}

# Partial update (name and email)
PATCH /api/users/1
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john.new@example.com"
}
```

### PUT vs PATCH

```bash
# PUT - Full replacement (all fields required)
PUT /api/users/1
{
  "name": "John",
  "email": "john@example.com",
  "age": 30,
  "address": "123 Main St",
  "phone": "555-1234"
}

# PATCH - Partial update (only changed fields)
PATCH /api/users/1
{
  "email": "john.new@example.com"
}
```

---

## üóëÔ∏è DELETE Method

### Purpose
Delete resource.

### Characteristics
- ‚ùå Not safe
- ‚úÖ Idempotent
- ‚ùå Not cacheable
- ‚ùå No request body
- Returns: 204 No Content or 200 OK

### Basic Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();  // 204 No Content
    }
}
```

### With Existence Check

```java
@DeleteMapping("/{id}")
public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
    if (!userService.exists(id)) {
        return ResponseEntity.notFound().build();  // 404 Not Found
    }
    
    userService.delete(id);
    return ResponseEntity.noContent().build();  // 204 No Content
}
```

### Return Deleted Resource

```java
@DeleteMapping("/{id}")
public ResponseEntity<User> deleteUser(@PathVariable Long id) {
    User user = userService.findById(id)
        .orElseThrow(() -> new UserNotFoundException(id));
    
    userService.delete(id);
    
    return ResponseEntity.ok(user);  // 200 OK with deleted user
}
```

### Soft Delete

```java
@DeleteMapping("/{id}")
public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
    userService.softDelete(id);  // Set deleted flag instead of actual deletion
    return ResponseEntity.noContent().build();
}

@Service
public class UserService {
    
    public void softDelete(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
        
        user.setDeleted(true);
        user.setDeletedAt(LocalDateTime.now());
        userRepository.save(user);
    }
}
```

### Bulk Delete

```java
@DeleteMapping
public ResponseEntity<Void> deleteUsers(@RequestBody List<Long> ids) {
    userService.deleteAll(ids);
    return ResponseEntity.noContent().build();
}
```

### Examples

```bash
# Delete user
DELETE /api/users/1

# Response: 204 No Content

# Delete with confirmation
DELETE /api/users/1?confirm=true

# Bulk delete
DELETE /api/users
Content-Type: application/json

[1, 2, 3, 4, 5]
```

---

## üìã HEAD Method

### Purpose
Same as GET but returns only headers (no body).

### Characteristics
- ‚úÖ Safe
- ‚úÖ Idempotent
- ‚úÖ Cacheable
- ‚ùå No response body

### Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @RequestMapping(value = "/{id}", method = RequestMethod.HEAD)
    public ResponseEntity<Void> checkUserExists(@PathVariable Long id) {
        if (userService.exists(id)) {
            return ResponseEntity.ok().build();  // 200 OK
        }
        return ResponseEntity.notFound().build();  // 404 Not Found
    }
}
```

### Example

```bash
# Check if user exists
HEAD /api/users/1

# Response: 200 OK (no body)
Content-Type: application/json
Content-Length: 85
```

---

## ‚öôÔ∏è OPTIONS Method

### Purpose
Get allowed HTTP methods for a resource.

### Characteristics
- ‚úÖ Safe
- ‚úÖ Idempotent
- ‚úÖ Used for CORS preflight

### Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @RequestMapping(method = RequestMethod.OPTIONS)
    public ResponseEntity<Void> options() {
        return ResponseEntity
            .ok()
            .allow(HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT, 
                   HttpMethod.DELETE, HttpMethod.OPTIONS)
            .build();
    }
}
```

### Example

```bash
# Get allowed methods
OPTIONS /api/users

# Response
Allow: GET, POST, PUT, DELETE, OPTIONS
```

### CORS Preflight

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                    .allowedOrigins("http://localhost:3000")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true);
            }
        };
    }
}
```

---

## üîÅ Idempotency

### Concept

**Idempotent:** Multiple identical requests have the same effect as a single request.

### Idempotent Methods

| Method | Idempotent | Explanation |
|--------|-----------|-------------|
| **GET** | ‚úÖ Yes | Reading doesn't change state |
| **PUT** | ‚úÖ Yes | Replacing resource N times = replacing once |
| **DELETE** | ‚úÖ Yes | Deleting N times = deleting once |
| **HEAD** | ‚úÖ Yes | Same as GET |
| **OPTIONS** | ‚úÖ Yes | Metadata request |
| **POST** | ‚ùå No | Creates new resource each time |
| **PATCH** | ‚ùå No | May have different effects |

### Examples

```bash
# DELETE is idempotent
DELETE /api/users/1  # First call: deletes user
DELETE /api/users/1  # Second call: user already deleted (same result)
DELETE /api/users/1  # Third call: still same result

# PUT is idempotent
PUT /api/users/1
{"name": "John", "age": 30}  # First call: updates user
PUT /api/users/1
{"name": "John", "age": 30}  # Second call: same update (same result)

# POST is NOT idempotent
POST /api/users
{"name": "John"}  # Creates user with ID 1
POST /api/users
{"name": "John"}  # Creates another user with ID 2 (different result!)
```

### Implementing Idempotency for POST

```java
@PostMapping
public ResponseEntity<User> createUser(
        @RequestHeader(value = "Idempotency-Key", required = true) String idempotencyKey,
        @RequestBody User user) {
    
    // Check if request with this key already processed
    Optional<User> existing = userService.findByIdempotencyKey(idempotencyKey);
    if (existing.isPresent()) {
        return ResponseEntity.ok(existing.get());  // Return existing
    }
    
    // Create new user
    User created = userService.createWithIdempotencyKey(user, idempotencyKey);
    return ResponseEntity.status(HttpStatus.CREATED).body(created);
}
```

---

## üéØ Method Selection Guide

### Decision Tree

```
Need to...

‚îú‚îÄ Read data?
‚îÇ  ‚îî‚îÄ Use GET
‚îÇ
‚îú‚îÄ Create new resource?
‚îÇ  ‚îî‚îÄ Use POST
‚îÇ
‚îú‚îÄ Update existing resource?
‚îÇ  ‚îú‚îÄ Full replacement?
‚îÇ  ‚îÇ  ‚îî‚îÄ Use PUT
‚îÇ  ‚îî‚îÄ Partial update?
‚îÇ     ‚îî‚îÄ Use PATCH
‚îÇ
‚îú‚îÄ Delete resource?
‚îÇ  ‚îî‚îÄ Use DELETE
‚îÇ
‚îú‚îÄ Check if resource exists?
‚îÇ  ‚îî‚îÄ Use HEAD
‚îÇ
‚îî‚îÄ Get allowed methods?
   ‚îî‚îÄ Use OPTIONS
```

### Common Patterns

```java
// List resources
GET /api/users

// Get single resource
GET /api/users/{id}

// Create resource
POST /api/users

// Update resource (full)
PUT /api/users/{id}

// Update resource (partial)
PATCH /api/users/{id}

// Delete resource
DELETE /api/users/{id}

// Nested resources
GET /api/users/{userId}/orders
POST /api/users/{userId}/orders
GET /api/users/{userId}/orders/{orderId}
```

---

## üìå Best Practices

### 1. Use Appropriate HTTP Methods

```java
// ‚úÖ Correct
@GetMapping("/users")           // Retrieve
@PostMapping("/users")          // Create
@PutMapping("/users/{id}")      // Full update
@PatchMapping("/users/{id}")    // Partial update
@DeleteMapping("/users/{id}")   // Delete

// ‚ùå Incorrect
@GetMapping("/createUser")
@PostMapping("/getUser/{id}")
@GetMapping("/deleteUser/{id}")
```

### 2. Return Appropriate Status Codes

```java
// GET
return ResponseEntity.ok(user);                    // 200 OK
return ResponseEntity.notFound().build();          // 404 Not Found

// POST
return ResponseEntity.status(HttpStatus.CREATED).body(user);  // 201 Created

// PUT/PATCH
return ResponseEntity.ok(user);                    // 200 OK
return ResponseEntity.notFound().build();          // 404 Not Found

// DELETE
return ResponseEntity.noContent().build();         // 204 No Content
return ResponseEntity.notFound().build();          // 404 Not Found
```

### 3. Use DTOs for Input/Output

```java
// ‚úÖ Use specific DTOs
@PostMapping
public UserResponseDTO createUser(@RequestBody UserCreateDTO dto) {
    User user = userService.create(dto);
    return UserMapper.toResponseDTO(user);
}

// ‚ùå Use entities directly
@PostMapping
public User createUser(@RequestBody User user) {
    return userService.save(user);
}
```

### 4. Validate Input

```java
@PostMapping
public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateDTO dto) {
    User created = userService.create(dto);
    return ResponseEntity.status(HttpStatus.CREATED).body(created);
}
```

### 5. Be Consistent

```java
// ‚úÖ Consistent API design
GET    /api/users           // List all
GET    /api/users/{id}      // Get one
POST   /api/users           // Create
PUT    /api/users/{id}      // Update
DELETE /api/users/{id}      // Delete

// ‚ùå Inconsistent
GET    /api/getAllUsers
POST   /api/user/create
PUT    /api/updateUser/{id}
DELETE /api/user/{id}/delete
```

### 6. Support Filtering and Pagination

```java
@GetMapping
public Page<User> getUsers(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) Integer minAge,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size) {
    
    Pageable pageable = PageRequest.of(page, size);
    return userService.findAll(name, minAge, pageable);
}
```

### 7. Version Your API

```java
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 {
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
}
```

---

## üé§ Interview Questions

### Q1: What are the main HTTP methods?
**Answer:** GET (retrieve), POST (create), PUT (update/replace), PATCH (partial update), DELETE (delete), HEAD (headers only), OPTIONS (allowed methods).

### Q2: Difference between PUT and PATCH?
**Answer:**
- **PUT**: Full replacement of resource (all fields required)
- **PATCH**: Partial update (only specified fields updated)

### Q3: What is idempotency?
**Answer:** Property where multiple identical requests have the same effect as a single request. GET, PUT, DELETE are idempotent. POST, PATCH are not.

### Q4: Which HTTP methods are safe?
**Answer:** GET, HEAD, OPTIONS - they don't modify server state.

### Q5: What status code should POST return?
**Answer:** **201 Created** for successful creation, with Location header pointing to new resource.

### Q6: What status code should DELETE return?
**Answer:** **204 No Content** (successful deletion, no body) or **200 OK** (with deleted resource in body).

### Q7: Can GET have a request body?
**Answer:** Technically yes, but it's not recommended and not widely supported. Use query parameters instead.

### Q8: What is HEAD method used for?
**Answer:** Check if resource exists or get metadata without transferring entire resource body.

### Q9: What is OPTIONS method used for?
**Answer:** Get list of allowed HTTP methods for a resource, commonly used in CORS preflight requests.

### Q10: How to make POST idempotent?
**Answer:** Use idempotency key in header:
```java
@PostMapping
public User create(@RequestHeader("Idempotency-Key") String key, @RequestBody User user) {
    // Check if key already processed
    // Return existing or create new
}
```

---

## üìö Summary

### HTTP Methods Quick Reference

| Method | Purpose | Idempotent | Safe | Request Body | Success Code |
|--------|---------|-----------|------|--------------|--------------|
| **GET** | Retrieve | ‚úÖ | ‚úÖ | ‚ùå | 200 OK |
| **POST** | Create | ‚ùå | ‚ùå | ‚úÖ | 201 Created |
| **PUT** | Replace | ‚úÖ | ‚ùå | ‚úÖ | 200 OK |
| **PATCH** | Update | ‚ùå | ‚ùå | ‚úÖ | 200 OK |
| **DELETE** | Delete | ‚úÖ | ‚ùå | ‚ùå | 204 No Content |
| **HEAD** | Headers | ‚úÖ | ‚úÖ | ‚ùå | 200 OK |
| **OPTIONS** | Methods | ‚úÖ | ‚úÖ | ‚ùå | 200 OK |

### Complete CRUD Example

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // READ - List
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        return ResponseEntity.ok(userService.findAll());
    }
    
    // READ - Single
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    // CREATE
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserCreateDTO dto) {
        User created = userService.create(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    // UPDATE - Full
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @Valid @RequestBody UserUpdateDTO dto) {
        return userService.update(id, dto)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    // UPDATE - Partial
    @PatchMapping("/{id}")
    public ResponseEntity<User> patchUser(@PathVariable Long id, @RequestBody UserPatchDTO dto) {
        return userService.patch(id, dto)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    // DELETE
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        if (!userService.exists(id)) {
            return ResponseEntity.notFound().build();
        }
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }
    
    // HEAD
    @RequestMapping(value = "/{id}", method = RequestMethod.HEAD)
    public ResponseEntity<Void> checkUser(@PathVariable Long id) {
        return userService.exists(id) 
            ? ResponseEntity.ok().build() 
            : ResponseEntity.notFound().build();
    }
}
```

**Next:** Request Mapping ‚Üí

