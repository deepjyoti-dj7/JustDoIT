# üóÉÔ∏è Auditing and Soft Delete - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [JPA Auditing](#jpa-auditing)
- [Audit Annotations](#audit-annotations)
- [AuditorAware](#auditoraware)
- [Soft Delete](#soft-delete)
- [Soft Delete Implementation](#soft-delete-implementation)
- [Filtering Deleted Records](#filtering-deleted-records)
- [Combining Auditing and Soft Delete](#combining-auditing-and-soft-delete)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Auditing** tracks who created/modified entities and when. **Soft Delete** marks records as deleted without actually removing them from the database.

### Benefits

**Auditing:**
- üìÖ Track creation/modification timestamps
- üë§ Track who made changes
- üîç Compliance and debugging
- üìä Historical analysis

**Soft Delete:**
- üîÑ Recoverable deletions
- üìà Data analytics on deleted records
- üîó Maintain referential integrity
- ‚è±Ô∏è Compliance with data retention

---

## üìù JPA Auditing

### Enable Auditing

```java
@Configuration
@EnableJpaAuditing
public class JpaConfig {
    // Auditing is now enabled
}

// Or in main application class
@SpringBootApplication
@EnableJpaAuditing
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Base Auditable Entity

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable {
    
    @CreatedDate
    @Column(name = "created_date", nullable = false, updatable = false)
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    @Column(name = "last_modified_date")
    private LocalDateTime lastModifiedDate;
    
    @CreatedBy
    @Column(name = "created_by", updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    @Column(name = "last_modified_by")
    private String lastModifiedBy;
    
    // Getters and setters
}
```

### Using Auditable Entity

```java
@Entity
@Table(name = "users")
public class User extends Auditable {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    // Other fields, getters, and setters
    // createdDate, lastModifiedDate, createdBy, lastModifiedBy 
    // are inherited from Auditable
}
```

---

## üè∑Ô∏è Audit Annotations

### @CreatedDate

```java
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdDate;
    
    // Automatically set when entity is first persisted
}
```

### @LastModifiedDate

```java
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @LastModifiedDate
    @Column(nullable = false)
    private LocalDateTime lastModifiedDate;
    
    // Automatically updated on every modification
}
```

### @CreatedBy

```java
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @CreatedBy
    @Column(updatable = false)
    private String createdBy;
    
    // Automatically set to current user when entity is created
}
```

### @LastModifiedBy

```java
@Entity
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @LastModifiedBy
    private String lastModifiedBy;
    
    // Automatically updated to current user on every modification
}
```

### Complete Example

```java
@Entity
@Table(name = "products")
@EntityListeners(AuditingEntityListener.class)
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
    
    @CreatedDate
    @Column(name = "created_date", nullable = false, updatable = false)
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    @Column(name = "last_modified_date", nullable = false)
    private LocalDateTime lastModifiedDate;
    
    @CreatedBy
    @Column(name = "created_by", length = 50, updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    @Column(name = "last_modified_by", length = 50)
    private String lastModifiedBy;
    
    @Version
    private Long version; // Optimistic locking
    
    // Getters and setters
}
```

---

## üë§ AuditorAware

### Implementing AuditorAware

```java
@Component
public class AuditorAwareImpl implements AuditorAware<String> {
    
    @Override
    public Optional<String> getCurrentAuditor() {
        // Get current user from SecurityContext
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.empty();
        }
        
        return Optional.of(authentication.getName());
    }
}
```

### Enable with Configuration

```java
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorAwareImpl")
public class JpaConfig {
    
    @Bean
    public AuditorAware<String> auditorAwareImpl() {
        return new AuditorAwareImpl();
    }
}
```

### Custom User Type

```java
// Using User entity as auditor
@Component
public class UserAuditorAware implements AuditorAware<User> {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public Optional<User> getCurrentAuditor() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.empty();
        }
        
        String username = authentication.getName();
        return userRepository.findByUsername(username);
    }
}

// Entity using User as auditor
@Entity
@EntityListeners(AuditingEntityListener.class)
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @CreatedBy
    @ManyToOne
    @JoinColumn(name = "created_by_user_id", updatable = false)
    private User createdBy;
    
    @LastModifiedBy
    @ManyToOne
    @JoinColumn(name = "last_modified_by_user_id")
    private User lastModifiedBy;
    
    @CreatedDate
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
}
```

### Multiple Auditor Types

```java
// Long ID auditor
@Component("longAuditorAware")
public class LongAuditorAware implements AuditorAware<Long> {
    
    @Override
    public Optional<Long> getCurrentAuditor() {
        // Return user ID
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            // Assuming UserDetails implementation has getId()
            return Optional.of(((CustomUserDetails) userDetails).getId());
        }
        return Optional.empty();
    }
}

// Configuration
@Configuration
@EnableJpaAuditing(auditorAwareRef = "longAuditorAware")
public class JpaConfig { }
```

---

## üóëÔ∏è Soft Delete

### Basic Soft Delete Entity

```java
@Entity
@Table(name = "users")
@SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ?")
@Where(clause = "deleted = false")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    @Column(name = "deleted")
    private boolean deleted = false;
    
    // Getters and setters
}
```

### With Deletion Timestamp

```java
@Entity
@Table(name = "users")
@SQLDelete(sql = "UPDATE users SET deleted_at = NOW() WHERE id = ?")
@Where(clause = "deleted_at IS NULL")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Transient
    public boolean isDeleted() {
        return deletedAt != null;
    }
    
    // Getters and setters
}
```

### With Deletion User

```java
@Entity
@Table(name = "users")
@SQLDelete(sql = "UPDATE users SET deleted = true, deleted_at = NOW(), deleted_by = ? WHERE id = ?")
@Where(clause = "deleted = false")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private String deletedBy;
    
    // Getters and setters
}
```

---

## üîß Soft Delete Implementation

### Custom Soft Delete

```java
// Base class for soft-deletable entities
@MappedSuperclass
public abstract class SoftDeletable {
    
    @Column(name = "deleted")
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private String deletedBy;
    
    public void softDelete(String deletedBy) {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.deletedBy = deletedBy;
    }
    
    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.deletedBy = null;
    }
    
    // Getters and setters
}

// Entity
@Entity
@Table(name = "users")
@Where(clause = "deleted = false")
public class User extends SoftDeletable {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    // Other fields
}
```

### Repository with Soft Delete

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find including deleted
    @Query("SELECT u FROM User u WHERE u.id = :id")
    Optional<User> findByIdIncludingDeleted(@Param("id") Long id);
    
    // Find only deleted
    @Query("SELECT u FROM User u WHERE u.deleted = true")
    List<User> findDeleted();
    
    // Restore deleted entity
    @Modifying
    @Query("UPDATE User u SET u.deleted = false, u.deletedAt = null, u.deletedBy = null WHERE u.id = :id")
    int restore(@Param("id") Long id);
}
```

### Service Layer

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public void softDelete(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        // Get current user from security context
        String currentUser = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        
        user.softDelete(currentUser);
        userRepository.save(user);
    }
    
    @Transactional
    public void restore(Long id) {
        userRepository.restore(id);
    }
    
    public List<User> findActiveUsers() {
        return userRepository.findAll(); // @Where clause filters deleted
    }
    
    public List<User> findDeletedUsers() {
        return userRepository.findDeleted();
    }
    
    @Transactional
    public void hardDelete(Long id) {
        // Physical deletion
        User user = userRepository.findByIdIncludingDeleted(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        userRepository.delete(user);
    }
}
```

---

## üîç Filtering Deleted Records

### @Where Annotation

```java
@Entity
@Table(name = "users")
@Where(clause = "deleted = false")
public class User {
    // Automatically filters deleted records in all queries
}

// All queries exclude deleted records
List<User> users = userRepository.findAll(); // Only active users
Optional<User> user = userRepository.findById(1L); // Only if not deleted
```

### @Filter Annotation (More Flexible)

```java
@Entity
@Table(name = "users")
@FilterDef(
    name = "deletedFilter",
    parameters = @ParamDef(name = "includeDeleted", type = "boolean")
)
@Filter(
    name = "deletedFilter",
    condition = "deleted = false or :includeDeleted = true"
)
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private boolean deleted = false;
    
    // Getters and setters
}

// Usage in service
@Service
public class UserService {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public List<User> findUsers(boolean includeDeleted) {
        Session session = entityManager.unwrap(Session.class);
        Filter filter = session.enableFilter("deletedFilter");
        filter.setParameter("includeDeleted", includeDeleted);
        
        List<User> users = entityManager
            .createQuery("SELECT u FROM User u", User.class)
            .getResultList();
        
        session.disableFilter("deletedFilter");
        return users;
    }
}
```

### Custom Repository Method

```java
@NoRepositoryBean
public interface SoftDeleteRepository<T, ID> extends JpaRepository<T, ID> {
    
    List<T> findAllIncludingDeleted();
    
    Optional<T> findByIdIncludingDeleted(ID id);
    
    List<T> findAllDeleted();
    
    void softDelete(ID id);
    
    void restore(ID id);
}

// Implementation
public class SoftDeleteRepositoryImpl<T extends SoftDeletable, ID> 
        extends SimpleJpaRepository<T, ID> implements SoftDeleteRepository<T, ID> {
    
    private final EntityManager entityManager;
    private final JpaEntityInformation<T, ?> entityInformation;
    
    public SoftDeleteRepositoryImpl(
        JpaEntityInformation<T, ?> entityInformation,
        EntityManager entityManager
    ) {
        super(entityInformation, entityManager);
        this.entityManager = entityManager;
        this.entityInformation = entityInformation;
    }
    
    @Override
    @Query
    public List<T> findAllIncludingDeleted() {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<T> query = cb.createQuery(getDomainClass());
        Root<T> root = query.from(getDomainClass());
        query.select(root);
        return entityManager.createQuery(query).getResultList();
    }
    
    @Override
    public Optional<T> findByIdIncludingDeleted(ID id) {
        T entity = entityManager.find(getDomainClass(), id);
        return Optional.ofNullable(entity);
    }
    
    @Override
    public List<T> findAllDeleted() {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<T> query = cb.createQuery(getDomainClass());
        Root<T> root = query.from(getDomainClass());
        query.select(root).where(cb.equal(root.get("deleted"), true));
        return entityManager.createQuery(query).getResultList();
    }
    
    @Override
    @Transactional
    public void softDelete(ID id) {
        findById(id).ifPresent(entity -> {
            String currentUser = SecurityContextHolder.getContext()
                .getAuthentication().getName();
            entity.softDelete(currentUser);
            save(entity);
        });
    }
    
    @Override
    @Transactional
    public void restore(ID id) {
        findByIdIncludingDeleted(id).ifPresent(entity -> {
            entity.restore();
            save(entity);
        });
    }
}
```

---

## üîÑ Combining Auditing and Soft Delete

### Complete Auditable and Soft-Deletable Entity

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableAndSoftDeletable {
    
    // Audit fields
    @CreatedDate
    @Column(name = "created_date", nullable = false, updatable = false)
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    @Column(name = "last_modified_date")
    private LocalDateTime lastModifiedDate;
    
    @CreatedBy
    @Column(name = "created_by", updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    @Column(name = "last_modified_by")
    private String lastModifiedBy;
    
    // Soft delete fields
    @Column(name = "deleted")
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private String deletedBy;
    
    // Version for optimistic locking
    @Version
    private Long version;
    
    public void softDelete(String deletedBy) {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.deletedBy = deletedBy;
    }
    
    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.deletedBy = null;
    }
    
    // Getters and setters
}
```

### Using the Base Class

```java
@Entity
@Table(name = "users")
@SQLDelete(sql = "UPDATE users SET deleted = true, deleted_at = NOW(), deleted_by = ? WHERE id = ? AND version = ?")
@Where(clause = "deleted = false")
public class User extends AuditableAndSoftDeletable {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private String phone;
    
    // Inherits:
    // - createdDate, lastModifiedDate, createdBy, lastModifiedBy
    // - deleted, deletedAt, deletedBy
    // - version
    
    // Getters and setters
}
```

### Complete Service Example

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User create(UserDTO userDTO) {
        User user = new User();
        user.setName(userDTO.getName());
        user.setEmail(userDTO.getEmail());
        
        // createdDate and createdBy automatically set
        return userRepository.save(user);
    }
    
    public User update(Long id, UserDTO userDTO) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        user.setName(userDTO.getName());
        user.setEmail(userDTO.getEmail());
        
        // lastModifiedDate and lastModifiedBy automatically updated
        return userRepository.save(user);
    }
    
    public void delete(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        String currentUser = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        
        user.softDelete(currentUser);
        userRepository.save(user);
        // Or use: userRepository.delete(user); // Triggers @SQLDelete
    }
    
    public void restore(Long id) {
        User user = userRepository.findByIdIncludingDeleted(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        user.restore();
        userRepository.save(user);
    }
    
    public List<User> findAll() {
        // Returns only non-deleted users (@Where clause)
        return userRepository.findAll();
    }
    
    public List<User> findDeleted() {
        return userRepository.findDeleted();
    }
    
    public UserAuditInfo getAuditInfo(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        
        return new UserAuditInfo(
            user.getCreatedDate(),
            user.getCreatedBy(),
            user.getLastModifiedDate(),
            user.getLastModifiedBy()
        );
    }
}
```

---

## üìå Best Practices

### 1. Use Base Classes for Auditing

```java
// ‚úÖ Good - Reusable base class
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class Auditable { ... }

@Entity
public class User extends Auditable { }

// ‚ùå Bad - Repeat in every entity
@Entity
@EntityListeners(AuditingEntityListener.class)
public class User {
    @CreatedDate
    private LocalDateTime createdDate;
    // ...repeat for every entity
}
```

### 2. Make Audit Fields Non-Updatable

```java
// ‚úÖ Good
@CreatedDate
@Column(updatable = false)
private LocalDateTime createdDate;

@CreatedBy
@Column(updatable = false)
private String createdBy;

// ‚ùå Bad - Can be modified
@CreatedDate
private LocalDateTime createdDate;
```

### 3. Use @Version with Soft Delete

```java
// ‚úÖ Good - Prevents concurrent deletions
@Entity
@SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ? AND version = ?")
public class User {
    @Version
    private Long version;
}
```

### 4. Provide Methods to Query Deleted Records

```java
// ‚úÖ Good
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.deleted = true")
    List<User> findDeleted();
    
    @Query("SELECT u FROM User u WHERE u.id = :id")
    Optional<User> findByIdIncludingDeleted(@Param("id") Long id);
}
```

### 5. Implement Restore Functionality

```java
// ‚úÖ Good
public void restore() {
    this.deleted = false;
    this.deletedAt = null;
    this.deletedBy = null;
}

@Transactional
public void restoreUser(Long id) {
    User user = userRepository.findByIdIncludingDeleted(id)
        .orElseThrow(() -> new ResourceNotFoundException("User not found"));
    user.restore();
    userRepository.save(user);
}
```

### 6. Index Soft Delete Column

```java
// ‚úÖ Good - Performance
@Entity
@Table(
    name = "users",
    indexes = @Index(name = "idx_user_deleted", columnList = "deleted")
)
public class User { }
```

### 7. Consider Data Retention Policies

```java
// ‚úÖ Good - Scheduled cleanup
@Component
public class DataCleanupScheduler {
    
    @Autowired
    private UserRepository userRepository;
    
    @Scheduled(cron = "0 0 2 * * ?") // Daily at 2 AM
    @Transactional
    public void cleanupOldDeletedRecords() {
        LocalDateTime cutoffDate = LocalDateTime.now().minusYears(1);
        
        List<User> oldDeletedUsers = userRepository
            .findByDeletedTrueAndDeletedAtBefore(cutoffDate);
        
        // Hard delete records deleted more than 1 year ago
        userRepository.deleteAll(oldDeletedUsers);
    }
}
```

---

## üé§ Interview Questions

### Q1: What is JPA Auditing?
**Answer:** Automatic tracking of entity creation/modification timestamps and users using annotations like @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy.

### Q2: How to enable JPA Auditing?
**Answer:**
```java
@Configuration
@EnableJpaAuditing
public class JpaConfig { }
```

### Q3: What is @CreatedDate?
**Answer:** Annotation that automatically sets timestamp when entity is first persisted.

### Q4: What is @LastModifiedDate?
**Answer:** Annotation that automatically updates timestamp whenever entity is modified.

### Q5: What is AuditorAware?
**Answer:** Interface to provide current auditor (user) for @CreatedBy and @LastModifiedBy:
```java
public interface AuditorAware<T> {
    Optional<T> getCurrentAuditor();
}
```

### Q6: What is soft delete?
**Answer:** Marking records as deleted (using flag/timestamp) without physically removing them from database.

### Q7: How to implement soft delete?
**Answer:** Use @SQLDelete and @Where:
```java
@SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ?")
@Where(clause = "deleted = false")
```

### Q8: Difference between soft delete and hard delete?
**Answer:**
- **Soft Delete**: Set flag, data remains in DB, recoverable
- **Hard Delete**: Physical removal, data lost, not recoverable

### Q9: What is @Where annotation?
**Answer:** Hibernate annotation to automatically filter queries:
```java
@Where(clause = "deleted = false")
```

### Q10: What is @SQLDelete?
**Answer:** Customizes SQL executed when entity.delete() is called:
```java
@SQLDelete(sql = "UPDATE users SET deleted = true WHERE id = ?")
```

### Q11: How to query deleted records?
**Answer:**
```java
@Query("SELECT u FROM User u WHERE u.deleted = true")
List<User> findDeleted();
```

### Q12: Can you restore soft-deleted records?
**Answer:** Yes, by setting deleted flag back to false:
```java
public void restore() {
    this.deleted = false;
    this.deletedAt = null;
}
```

### Q13: What is @EntityListeners?
**Answer:** Specifies callback listener class for entity:
```java
@EntityListeners(AuditingEntityListener.class)
```

### Q14: Should audit fields be updatable?
**Answer:** No, especially creation fields:
```java
@CreatedDate
@Column(updatable = false)
private LocalDateTime createdDate;
```

### Q15: How to track who deleted a record?
**Answer:** Add deletedBy field:
```java
@Column(name = "deleted_by")
private String deletedBy;

public void softDelete(String deletedBy) {
    this.deleted = true;
    this.deletedBy = deletedBy;
}
```

### Q16: Can you use entity as auditor type?
**Answer:** Yes:
```java
@CreatedBy
@ManyToOne
private User createdBy;
```

### Q17: What is @MappedSuperclass?
**Answer:** Base class whose properties are inherited by entity subclasses but is not itself an entity.

### Q18: How to find records modified in last 7 days?
**Answer:**
```java
@Query("SELECT u FROM User u WHERE u.lastModifiedDate >= :date")
List<User> findRecentlyModified(@Param("date") LocalDateTime date);
```

### Q19: Best practice for soft delete performance?
**Answer:** Add index on deleted column:
```java
@Table(indexes = @Index(columnList = "deleted"))
```

### Q20: Should you always use soft delete?
**Answer:** No, consider:
- ‚úÖ Use: Compliance, audit trails, recovery needed
- ‚ùå Avoid: Sensitive data (GDPR), very large tables, simple CRUD apps

---

## üìö Summary

### JPA Auditing Setup

```java
// Enable
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorAware")
public class JpaConfig { }

// Auditor
@Component
public class AuditorAwareImpl implements AuditorAware<String> {
    @Override
    public Optional<String> getCurrentAuditor() {
        return Optional.of(SecurityContextHolder.getContext()
            .getAuthentication().getName());
    }
}

// Entity
@Entity
@EntityListeners(AuditingEntityListener.class)
public class User {
    @CreatedDate
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
    
    @CreatedBy
    private String createdBy;
    
    @LastModifiedBy
    private String lastModifiedBy;
}
```

### Soft Delete Setup

```java
@Entity
@SQLDelete(sql = "UPDATE users SET deleted = true, deleted_at = NOW() WHERE id = ?")
@Where(clause = "deleted = false")
public class User {
    
    @Column(name = "deleted")
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private String deletedBy;
    
    public void softDelete(String deletedBy) {
        this.deleted = true;
        this.deletedAt = LocalDateTime.now();
        this.deletedBy = deletedBy;
    }
    
    public void restore() {
        this.deleted = false;
        this.deletedAt = null;
        this.deletedBy = null;
    }
}
```

### Complete Example

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableAndSoftDeletable {
    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
    
    @CreatedBy
    @Column(updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    private String lastModifiedBy;
    
    private boolean deleted = false;
    private LocalDateTime deletedAt;
    private String deletedBy;
    
    @Version
    private Long version;
    
    // Methods for soft delete and restore
}
```

**Folder 07 Complete!** üéâ

