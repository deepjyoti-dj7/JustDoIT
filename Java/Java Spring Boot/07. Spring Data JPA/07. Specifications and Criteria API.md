# üîç Specifications and Criteria API - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [JPA Criteria API](#jpa-criteria-api)
- [Spring Data JPA Specifications](#spring-data-jpa-specifications)
- [Building Specifications](#building-specifications)
- [Combining Specifications](#combining-specifications)
- [Dynamic Queries](#dynamic-queries)
- [Complex Queries](#complex-queries)
- [Specification Executor](#specification-executor)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Specifications** provide a type-safe, programmatic way to build dynamic queries using JPA Criteria API.

### When to Use

1. **Dynamic Queries**: Conditional where clauses
2. **Complex Filters**: Multiple optional search criteria
3. **Type Safety**: Compile-time checking
4. **Reusability**: Composable query fragments
5. **Advanced Search**: Complex search forms

### Benefits

- ‚úÖ Type-safe queries
- ‚úÖ Compile-time validation
- ‚úÖ Reusable query components
- ‚úÖ Programmatic query building
- ‚úÖ No string-based queries

---

## üèóÔ∏è JPA Criteria API

### Basic Concepts

```java
@Service
public class UserService {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public List<User> findUsersCriteria(String name, Integer minAge) {
        // Create CriteriaBuilder
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        
        // Create CriteriaQuery
        CriteriaQuery<User> query = cb.createQuery(User.class);
        
        // Define root (FROM clause)
        Root<User> user = query.from(User.class);
        
        // Build predicates (WHERE clause)
        List<Predicate> predicates = new ArrayList<>();
        
        if (name != null) {
            predicates.add(cb.equal(user.get("name"), name));
        }
        
        if (minAge != null) {
            predicates.add(cb.greaterThanOrEqualTo(user.get("age"), minAge));
        }
        
        // Apply predicates
        query.where(predicates.toArray(new Predicate[0]));
        
        // Execute query
        return entityManager.createQuery(query).getResultList();
    }
}
```

### Criteria Components

```java
// CriteriaBuilder - Factory for creating query components
CriteriaBuilder cb = entityManager.getCriteriaBuilder();

// CriteriaQuery - Defines query structure
CriteriaQuery<User> query = cb.createQuery(User.class);

// Root - Represents FROM clause
Root<User> root = query.from(User.class);

// Predicate - Represents WHERE conditions
Predicate predicate = cb.equal(root.get("name"), "John");

// Order - Represents ORDER BY
Order order = cb.asc(root.get("name"));

// Selection - Represents SELECT clause
query.select(root);
```

### Common Operations

```java
public List<User> criteriaExamples() {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<User> query = cb.createQuery(User.class);
    Root<User> user = query.from(User.class);
    
    // Equality
    Predicate nameEquals = cb.equal(user.get("name"), "John");
    
    // Comparison
    Predicate ageGreater = cb.greaterThan(user.get("age"), 18);
    Predicate ageLess = cb.lessThan(user.get("age"), 65);
    Predicate ageBetween = cb.between(user.get("age"), 18, 65);
    
    // Like
    Predicate nameLike = cb.like(user.get("name"), "%John%");
    
    // In
    Predicate statusIn = user.get("status").in("ACTIVE", "PENDING");
    
    // Null check
    Predicate emailNull = cb.isNull(user.get("email"));
    Predicate emailNotNull = cb.isNotNull(user.get("email"));
    
    // AND
    Predicate and = cb.and(nameEquals, ageGreater);
    
    // OR
    Predicate or = cb.or(nameEquals, emailNull);
    
    // NOT
    Predicate not = cb.not(nameEquals);
    
    query.where(and);
    return entityManager.createQuery(query).getResultList();
}
```

---

## üìê Spring Data JPA Specifications

### Specification Interface

```java
public interface Specification<T> extends Serializable {
    Predicate toPredicate(
        Root<T> root, 
        CriteriaQuery<?> query, 
        CriteriaBuilder criteriaBuilder
    );
}
```

### Simple Specification

```java
public class UserSpecifications {
    
    // Specification for name
    public static Specification<User> hasName(String name) {
        return (root, query, criteriaBuilder) -> 
            name == null ? null : criteriaBuilder.equal(root.get("name"), name);
    }
    
    // Specification for age greater than
    public static Specification<User> ageGreaterThan(Integer age) {
        return (root, query, criteriaBuilder) -> 
            age == null ? null : criteriaBuilder.greaterThan(root.get("age"), age);
    }
    
    // Specification for status
    public static Specification<User> hasStatus(String status) {
        return (root, query, criteriaBuilder) -> 
            status == null ? null : criteriaBuilder.equal(root.get("status"), status);
    }
    
    // Specification for active users
    public static Specification<User> isActive() {
        return (root, query, criteriaBuilder) -> 
            criteriaBuilder.equal(root.get("active"), true);
    }
    
    // Specification with LIKE
    public static Specification<User> nameContains(String keyword) {
        return (root, query, criteriaBuilder) -> 
            keyword == null ? null : 
            criteriaBuilder.like(
                criteriaBuilder.lower(root.get("name")), 
                "%" + keyword.toLowerCase() + "%"
            );
    }
}
```

### JpaSpecificationExecutor

```java
public interface UserRepository extends JpaRepository<User, Long>, 
                                         JpaSpecificationExecutor<User> {
    // Inherits specification methods:
    // Optional<T> findOne(Specification<T> spec)
    // List<T> findAll(Specification<T> spec)
    // Page<T> findAll(Specification<T> spec, Pageable pageable)
    // List<T> findAll(Specification<T> spec, Sort sort)
    // long count(Specification<T> spec)
}
```

### Using Specifications

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> findActiveUsersByName(String name) {
        Specification<User> spec = Specification
            .where(UserSpecifications.hasName(name))
            .and(UserSpecifications.isActive());
        
        return userRepository.findAll(spec);
    }
    
    public List<User> findUsers(String name, Integer minAge, String status) {
        Specification<User> spec = Specification
            .where(UserSpecifications.hasName(name))
            .and(UserSpecifications.ageGreaterThan(minAge))
            .and(UserSpecifications.hasStatus(status));
        
        return userRepository.findAll(spec);
    }
    
    public Page<User> searchUsers(String keyword, Pageable pageable) {
        Specification<User> spec = UserSpecifications.nameContains(keyword);
        return userRepository.findAll(spec, pageable);
    }
}
```

---

## üî® Building Specifications

### Property Access

```java
public class UserSpecifications {
    
    // Simple property
    public static Specification<User> hasEmail(String email) {
        return (root, query, cb) -> 
            cb.equal(root.get("email"), email);
    }
    
    // Nested property
    public static Specification<User> hasCity(String city) {
        return (root, query, cb) -> 
            cb.equal(root.get("address").get("city"), city);
    }
    
    // Join
    public static Specification<User> hasDepartmentName(String deptName) {
        return (root, query, cb) -> {
            Join<User, Department> department = root.join("department");
            return cb.equal(department.get("name"), deptName);
        };
    }
}
```

### Comparison Operators

```java
public class UserSpecifications {
    
    public static Specification<User> ageBetween(Integer min, Integer max) {
        return (root, query, cb) -> 
            cb.between(root.get("age"), min, max);
    }
    
    public static Specification<User> salaryGreaterThan(BigDecimal amount) {
        return (root, query, cb) -> 
            cb.greaterThan(root.get("salary"), amount);
    }
    
    public static Specification<User> createdBefore(LocalDate date) {
        return (root, query, cb) -> 
            cb.lessThan(root.get("createdDate"), date);
    }
}
```

### String Operations

```java
public class UserSpecifications {
    
    // Contains (case-insensitive)
    public static Specification<User> nameContains(String keyword) {
        return (root, query, cb) -> 
            cb.like(
                cb.lower(root.get("name")), 
                "%" + keyword.toLowerCase() + "%"
            );
    }
    
    // Starts with
    public static Specification<User> nameStartsWith(String prefix) {
        return (root, query, cb) -> 
            cb.like(root.get("name"), prefix + "%");
    }
    
    // Ends with
    public static Specification<User> nameEndsWith(String suffix) {
        return (root, query, cb) -> 
            cb.like(root.get("name"), "%" + suffix);
    }
    
    // Exact match (case-insensitive)
    public static Specification<User> nameEqualsIgnoreCase(String name) {
        return (root, query, cb) -> 
            cb.equal(cb.lower(root.get("name")), name.toLowerCase());
    }
}
```

### Collection Operations

```java
public class UserSpecifications {
    
    // In clause
    public static Specification<User> statusIn(List<String> statuses) {
        return (root, query, cb) -> 
            root.get("status").in(statuses);
    }
    
    // Collection membership
    public static Specification<User> hasRole(String roleName) {
        return (root, query, cb) -> {
            Join<User, Role> roles = root.join("roles");
            return cb.equal(roles.get("name"), roleName);
        };
    }
    
    // Collection size
    public static Specification<User> hasMinOrders(int minCount) {
        return (root, query, cb) -> 
            cb.greaterThanOrEqualTo(
                cb.size(root.get("orders")), 
                minCount
            );
    }
}
```

### Null Handling

```java
public class UserSpecifications {
    
    public static Specification<User> emailIsNull() {
        return (root, query, cb) -> 
            cb.isNull(root.get("email"));
    }
    
    public static Specification<User> emailIsNotNull() {
        return (root, query, cb) -> 
            cb.isNotNull(root.get("email"));
    }
    
    // Coalesce
    public static Specification<User> phoneOrDefault(String defaultPhone) {
        return (root, query, cb) -> 
            cb.equal(
                cb.coalesce(root.get("phone"), defaultPhone),
                defaultPhone
            );
    }
}
```

---

## üîó Combining Specifications

### AND Operations

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Using and()
    public List<User> findActiveAdults() {
        Specification<User> spec = Specification
            .where(UserSpecifications.isActive())
            .and(UserSpecifications.ageGreaterThan(18));
        
        return userRepository.findAll(spec);
    }
    
    // Chaining multiple ANDs
    public List<User> findUsers(String name, Integer age, String status) {
        Specification<User> spec = Specification.where(null);
        
        if (name != null) {
            spec = spec.and(UserSpecifications.hasName(name));
        }
        
        if (age != null) {
            spec = spec.and(UserSpecifications.ageGreaterThan(age));
        }
        
        if (status != null) {
            spec = spec.and(UserSpecifications.hasStatus(status));
        }
        
        return userRepository.findAll(spec);
    }
}
```

### OR Operations

```java
public class UserSpecifications {
    
    // OR specification
    public static Specification<User> nameOrEmailContains(String keyword) {
        return (root, query, cb) -> cb.or(
            cb.like(cb.lower(root.get("name")), "%" + keyword.toLowerCase() + "%"),
            cb.like(cb.lower(root.get("email")), "%" + keyword.toLowerCase() + "%")
        );
    }
}

// Usage
public List<User> searchUsers(String keyword) {
    Specification<User> spec = Specification
        .where(UserSpecifications.nameOrEmailContains(keyword));
    
    return userRepository.findAll(spec);
}
```

### NOT Operations

```java
public class UserSpecifications {
    
    public static Specification<User> statusNot(String status) {
        return (root, query, cb) -> 
            cb.not(cb.equal(root.get("status"), status));
    }
}

// Using not()
public List<User> findNonInactiveUsers() {
    Specification<User> spec = Specification
        .not(UserSpecifications.hasStatus("INACTIVE"));
    
    return userRepository.findAll(spec);
}
```

### Complex Combinations

```java
public List<User> complexSearch(UserSearchCriteria criteria) {
    Specification<User> spec = Specification.where(null);
    
    // (name LIKE ? OR email LIKE ?) AND status = ? AND age > ?
    if (criteria.getKeyword() != null) {
        spec = spec.and(
            Specification.where(UserSpecifications.nameContains(criteria.getKeyword()))
                .or(UserSpecifications.emailContains(criteria.getKeyword()))
        );
    }
    
    if (criteria.getStatus() != null) {
        spec = spec.and(UserSpecifications.hasStatus(criteria.getStatus()));
    }
    
    if (criteria.getMinAge() != null) {
        spec = spec.and(UserSpecifications.ageGreaterThan(criteria.getMinAge()));
    }
    
    return userRepository.findAll(spec);
}
```

---

## üéØ Dynamic Queries

### Dynamic Search

```java
@Data
public class UserSearchCriteria {
    private String name;
    private String email;
    private Integer minAge;
    private Integer maxAge;
    private String status;
    private Boolean active;
    private String city;
}

public class UserSpecifications {
    
    public static Specification<User> withCriteria(UserSearchCriteria criteria) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();
            
            if (criteria.getName() != null) {
                predicates.add(cb.like(
                    cb.lower(root.get("name")), 
                    "%" + criteria.getName().toLowerCase() + "%"
                ));
            }
            
            if (criteria.getEmail() != null) {
                predicates.add(cb.equal(root.get("email"), criteria.getEmail()));
            }
            
            if (criteria.getMinAge() != null) {
                predicates.add(cb.greaterThanOrEqualTo(
                    root.get("age"), 
                    criteria.getMinAge()
                ));
            }
            
            if (criteria.getMaxAge() != null) {
                predicates.add(cb.lessThanOrEqualTo(
                    root.get("age"), 
                    criteria.getMaxAge()
                ));
            }
            
            if (criteria.getStatus() != null) {
                predicates.add(cb.equal(root.get("status"), criteria.getStatus()));
            }
            
            if (criteria.getActive() != null) {
                predicates.add(cb.equal(root.get("active"), criteria.getActive()));
            }
            
            if (criteria.getCity() != null) {
                predicates.add(cb.equal(
                    root.get("address").get("city"), 
                    criteria.getCity()
                ));
            }
            
            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }
}

// Usage
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @PostMapping("/search")
    public Page<User> search(
        @RequestBody UserSearchCriteria criteria,
        Pageable pageable
    ) {
        Specification<User> spec = UserSpecifications.withCriteria(criteria);
        return userRepository.findAll(spec, pageable);
    }
}
```

### Generic Specification Builder

```java
public class SpecificationBuilder<T> {
    
    private List<Specification<T>> specifications = new ArrayList<>();
    
    public SpecificationBuilder<T> with(Specification<T> spec) {
        if (spec != null) {
            specifications.add(spec);
        }
        return this;
    }
    
    public Specification<T> build() {
        if (specifications.isEmpty()) {
            return null;
        }
        
        Specification<T> result = specifications.get(0);
        for (int i = 1; i < specifications.size(); i++) {
            result = Specification.where(result).and(specifications.get(i));
        }
        
        return result;
    }
}

// Usage
public List<User> findUsers(String name, Integer age, String status) {
    Specification<User> spec = new SpecificationBuilder<User>()
        .with(UserSpecifications.hasName(name))
        .with(UserSpecifications.ageGreaterThan(age))
        .with(UserSpecifications.hasStatus(status))
        .build();
    
    return userRepository.findAll(spec != null ? spec : Specification.where(null));
}
```

---

## üî¨ Complex Queries

### Joins

```java
public class UserSpecifications {
    
    // Inner join
    public static Specification<User> hasDepartmentName(String deptName) {
        return (root, query, cb) -> {
            Join<User, Department> department = root.join("department", JoinType.INNER);
            return cb.equal(department.get("name"), deptName);
        };
    }
    
    // Left join
    public static Specification<User> hasOrdersGreaterThan(BigDecimal amount) {
        return (root, query, cb) -> {
            Join<User, Order> orders = root.join("orders", JoinType.LEFT);
            return cb.greaterThan(orders.get("total"), amount);
        };
    }
    
    // Multiple joins
    public static Specification<User> hasCompanyName(String companyName) {
        return (root, query, cb) -> {
            Join<User, Department> department = root.join("department");
            Join<Department, Company> company = department.join("company");
            return cb.equal(company.get("name"), companyName);
        };
    }
}
```

### Subqueries

```java
public class UserSpecifications {
    
    // Users with above average age
    public static Specification<User> ageAboveAverage() {
        return (root, query, cb) -> {
            Subquery<Double> subquery = query.subquery(Double.class);
            Root<User> subRoot = subquery.from(User.class);
            subquery.select(cb.avg(subRoot.get("age")));
            
            return cb.greaterThan(root.get("age"), subquery);
        };
    }
    
    // Users with orders
    public static Specification<User> hasOrders() {
        return (root, query, cb) -> {
            Subquery<Long> subquery = query.subquery(Long.class);
            Root<Order> orderRoot = subquery.from(Order.class);
            subquery.select(orderRoot.get("user").get("id"));
            
            return root.get("id").in(subquery);
        };
    }
}
```

### Aggregations

```java
public class UserSpecifications {
    
    // Users with more than N orders
    public static Specification<User> hasMinOrders(int minCount) {
        return (root, query, cb) -> {
            Join<User, Order> orders = root.join("orders", JoinType.LEFT);
            
            query.groupBy(root.get("id"));
            query.having(cb.greaterThanOrEqualTo(cb.count(orders), (long) minCount));
            
            return cb.conjunction(); // Always true predicate
        };
    }
    
    // Users with total order amount greater than
    public static Specification<User> totalOrdersGreaterThan(BigDecimal amount) {
        return (root, query, cb) -> {
            Join<User, Order> orders = root.join("orders", JoinType.LEFT);
            
            query.groupBy(root.get("id"));
            query.having(cb.greaterThan(cb.sum(orders.get("total")), amount));
            
            return cb.conjunction();
        };
    }
}
```

### Distinct

```java
public class UserSpecifications {
    
    public static Specification<User> distinctUsers() {
        return (root, query, cb) -> {
            query.distinct(true);
            return cb.conjunction();
        };
    }
}
```

---

## ‚öôÔ∏è Specification Executor

### Complete Example

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Find one
    public Optional<User> findOne(String email) {
        return userRepository.findOne(UserSpecifications.hasEmail(email));
    }
    
    // Find all
    public List<User> findAll(String status) {
        return userRepository.findAll(UserSpecifications.hasStatus(status));
    }
    
    // Find all with sort
    public List<User> findAllSorted(String status) {
        Specification<User> spec = UserSpecifications.hasStatus(status);
        Sort sort = Sort.by("name").ascending();
        return userRepository.findAll(spec, sort);
    }
    
    // Find all with pagination
    public Page<User> findAllPaginated(String status, int page, int size) {
        Specification<User> spec = UserSpecifications.hasStatus(status);
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
        return userRepository.findAll(spec, pageable);
    }
    
    // Count
    public long count(String status) {
        return userRepository.count(UserSpecifications.hasStatus(status));
    }
    
    // Exists
    public boolean exists(String email) {
        return userRepository.count(UserSpecifications.hasEmail(email)) > 0;
    }
    
    // Delete
    @Transactional
    public void deleteInactive() {
        Specification<User> spec = UserSpecifications.hasStatus("INACTIVE");
        userRepository.delete(spec);
    }
}
```

---

## üìå Best Practices

### 1. Create Reusable Specifications

```java
// ‚úÖ Good - Reusable
public class UserSpecifications {
    public static Specification<User> isActive() {
        return (root, query, cb) -> cb.equal(root.get("active"), true);
    }
}

// ‚ùå Bad - Inline every time
Specification<User> spec = (root, query, cb) -> cb.equal(root.get("active"), true);
```

### 2. Handle Null Parameters

```java
// ‚úÖ Good - Null-safe
public static Specification<User> hasName(String name) {
    return (root, query, cb) -> 
        name == null ? null : cb.equal(root.get("name"), name);
}

// ‚ùå Bad - NullPointerException risk
public static Specification<User> hasName(String name) {
    return (root, query, cb) -> cb.equal(root.get("name"), name);
}
```

### 3. Use Metamodel for Type Safety

```java
// ‚úÖ Good - Type-safe with metamodel
public static Specification<User> hasName(String name) {
    return (root, query, cb) -> 
        cb.equal(root.get(User_.name), name);
}

// ‚ùå Bad - String-based (typo-prone)
public static Specification<User> hasName(String name) {
    return (root, query, cb) -> 
        cb.equal(root.get("name"), name);
}
```

### 4. Avoid N+1 with Fetch

```java
// ‚úÖ Good - Fetch eagerly
public static Specification<User> withOrders() {
    return (root, query, cb) -> {
        root.fetch("orders", JoinType.LEFT);
        query.distinct(true);
        return cb.conjunction();
    };
}
```

### 5. Use Specification Builder for Complex Queries

```java
// ‚úÖ Good - Clean builder
Specification<User> spec = new SpecificationBuilder<User>()
    .with(hasName(name))
    .with(ageGreaterThan(age))
    .with(hasStatus(status))
    .build();

// ‚ùå Bad - Nested ands
Specification<User> spec = Specification.where(hasName(name))
    .and(ageGreaterThan(age))
    .and(hasStatus(status))
    .and(...)
    .and(...);
```

### 6. Combine with Pagination

```java
// ‚úÖ Good
public Page<User> search(UserSearchCriteria criteria, Pageable pageable) {
    Specification<User> spec = UserSpecifications.withCriteria(criteria);
    return userRepository.findAll(spec, pageable);
}
```

### 7. Keep Specifications Simple

```java
// ‚úÖ Good - Simple, composable
public static Specification<User> isActive() { ... }
public static Specification<User> ageGreaterThan(int age) { ... }

// Combine when needed
Specification<User> spec = isActive().and(ageGreaterThan(18));

// ‚ùå Bad - Monolithic
public static Specification<User> activeAdults() {
    return (root, query, cb) -> cb.and(
        cb.equal(root.get("active"), true),
        cb.greaterThan(root.get("age"), 18)
    );
}
```

---

## üé§ Interview Questions

### Q1: What is JPA Criteria API?
**Answer:** Type-safe, programmatic API for building queries using Java objects instead of strings.

### Q2: What is a Specification?
**Answer:** Interface representing a single predicate that can be composed and reused to build dynamic queries.

### Q3: What is JpaSpecificationExecutor?
**Answer:** Repository interface providing methods to execute Specifications (findAll, findOne, count, etc.).

### Q4: How to combine Specifications?
**Answer:**
```java
Specification<User> spec = Specification.where(spec1)
    .and(spec2)
    .or(spec3)
    .not(spec4);
```

### Q5: What is CriteriaBuilder?
**Answer:** Factory for creating query components (predicates, expressions, orders, etc.).

### Q6: What is Root in Criteria API?
**Answer:** Represents the entity in the FROM clause, entry point for navigating entity attributes.

### Q7: How to handle null parameters in Specifications?
**Answer:**
```java
return (root, query, cb) -> 
    value == null ? null : cb.equal(root.get("field"), value);
```

### Q8: Difference between Specification and @Query?
**Answer:**
- **Specification**: Programmatic, type-safe, composable, dynamic
- **@Query**: String-based, static, less flexible

### Q9: How to do joins in Specifications?
**Answer:**
```java
Join<User, Department> dept = root.join("department", JoinType.LEFT);
return cb.equal(dept.get("name"), name);
```

### Q10: Can you paginate with Specifications?
**Answer:** Yes:
```java
repository.findAll(specification, pageable);
```

### Q11: What is Predicate?
**Answer:** Boolean expression (WHERE condition) created by CriteriaBuilder.

### Q12: How to implement OR condition?
**Answer:**
```java
return (root, query, cb) -> cb.or(predicate1, predicate2);
```

### Q13: What is conjunction()?
**Answer:** Always-true predicate:
```java
cb.conjunction(); // equivalent to "1=1"
```

### Q14: How to use LIKE in Specification?
**Answer:**
```java
cb.like(root.get("name"), "%" + keyword + "%");
```

### Q15: Can you use subqueries in Specifications?
**Answer:** Yes:
```java
Subquery<Long> subquery = query.subquery(Long.class);
Root<Order> subRoot = subquery.from(Order.class);
subquery.select(subRoot.get("user").get("id"));
```

### Q16: What is Metamodel?
**Answer:** Generated classes with static fields representing entity attributes, providing type safety.

### Q17: How to fetch associations in Specification?
**Answer:**
```java
root.fetch("orders", JoinType.LEFT);
query.distinct(true);
```

### Q18: Can you count with Specification?
**Answer:** Yes:
```java
long count = repository.count(specification);
```

### Q19: Difference between Join and Fetch?
**Answer:**
- **Join**: For WHERE/HAVING clauses
- **Fetch**: For eagerly loading associations (solve N+1)

### Q20: Best practice for dynamic search?
**Answer:** Create SpecificationBuilder or use Specification.where(null) and chain conditionally.

---

## üìö Summary

### Basic Specification

```java
public static Specification<User> hasName(String name) {
    return (root, query, cb) -> 
        name == null ? null : cb.equal(root.get("name"), name);
}
```

### Combining Specifications

```java
Specification<User> spec = Specification
    .where(UserSpecifications.hasName(name))
    .and(UserSpecifications.ageGreaterThan(age))
    .or(UserSpecifications.hasStatus(status));
```

### Using Specifications

```java
// Find all
List<User> users = repository.findAll(specification);

// With pagination
Page<User> page = repository.findAll(specification, pageable);

// With sort
List<User> users = repository.findAll(specification, sort);

// Count
long count = repository.count(specification);

// Find one
Optional<User> user = repository.findOne(specification);
```

### Dynamic Query

```java
public static Specification<User> withCriteria(SearchCriteria criteria) {
    return (root, query, cb) -> {
        List<Predicate> predicates = new ArrayList<>();
        
        if (criteria.getName() != null) {
            predicates.add(cb.equal(root.get("name"), criteria.getName()));
        }
        
        if (criteria.getAge() != null) {
            predicates.add(cb.greaterThan(root.get("age"), criteria.getAge()));
        }
        
        return cb.and(predicates.toArray(new Predicate[0]));
    };
}
```

**Next:** Auditing and Soft Delete ‚Üí

