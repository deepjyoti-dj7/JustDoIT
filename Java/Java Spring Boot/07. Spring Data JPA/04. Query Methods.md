# üîé Query Methods - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Method Naming Convention](#method-naming-convention)
- [Query Creation](#query-creation)
- [Return Types](#return-types)
- [Query Keywords](#query-keywords)
- [Property Expressions](#property-expressions)
- [Special Parameters](#special-parameters)
- [Limiting Results](#limiting-results)
- [Streaming Results](#streaming-results)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Query Methods** are repository methods whose implementation is automatically generated from method names.

### Benefits

1. **No Implementation**: Spring generates implementation
2. **Type-Safe**: Compile-time checking
3. **Readable**: Self-documenting code
4. **Maintainable**: Easy to understand and modify

### How It Works

```
Method Name ‚Üí Parser ‚Üí Query Generation ‚Üí Implementation
```

---

## üìù Method Naming Convention

### Structure

```
<action><Subject><Predicate>
```

### Actions

```java
// Query actions
find...By       // Returns result
read...By       // Returns result
query...By      // Returns result
get...By        // Returns result
search...By     // Returns result
stream...By     // Returns Stream

// Count actions
count...By      // Returns long

// Exists actions
exists...By     // Returns boolean

// Delete actions
delete...By     // Returns deleted count
remove...By     // Returns deleted count
```

### Subject (Optional)

```java
// With subject
findUserBy...
findAllUsersBy...
findActiveUsersBy...

// Without subject (same as with)
findBy...
findAllBy...
```

### Predicate

```java
// Property
findByName

// Multiple properties
findByNameAndEmail

// With comparison
findByAgeGreaterThan
```

---

## üîß Query Creation

### Simple Property Match

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find by single property
    List<User> findByName(String name);
    List<User> findByEmail(String email);
    Optional<User> findByUsername(String username);
    
    // Different query verbs (all equivalent)
    List<User> readByName(String name);
    List<User> queryByName(String name);
    List<User> getByName(String name);
}
```

### Multiple Properties

```java
// AND condition
List<User> findByNameAndEmail(String name, String email);
List<User> findByFirstNameAndLastNameAndAge(String firstName, String lastName, int age);

// OR condition
List<User> findByNameOrEmail(String name, String email);
List<User> findByFirstNameOrLastName(String firstName, String lastName);

// Complex combinations
List<User> findByNameAndEmailOrPhone(String name, String email, String phone);
// (name = ? AND email = ?) OR phone = ?

List<User> findByNameOrEmailAndActive(String name, String email, boolean active);
// name = ? OR (email = ? AND active = ?)
```

### Comparison Operators

```java
// Greater than
List<User> findByAgeGreaterThan(int age);
List<User> findByCreatedDateGreaterThan(LocalDate date);

// Greater than or equal
List<User> findByAgeGreaterThanEqual(int age);

// Less than
List<User> findByAgeLessThan(int age);

// Less than or equal
List<User> findByAgeLessThanEqual(int age);

// Between
List<User> findByAgeBetween(int minAge, int maxAge);
List<User> findByCreatedDateBetween(LocalDate start, LocalDate end);

// Not equal
List<User> findByStatusNot(String status);
```

### String Queries

```java
// Like (exact pattern)
List<User> findByNameLike(String pattern);
// Usage: findByNameLike("%John%")

// Not Like
List<User> findByNameNotLike(String pattern);

// Starts with
List<User> findByNameStartingWith(String prefix);
// Equivalent to: name LIKE 'prefix%'

// Ends with
List<User> findByNameEndingWith(String suffix);
// Equivalent to: name LIKE '%suffix'

// Containing
List<User> findByNameContaining(String infix);
// Equivalent to: name LIKE '%infix%'

// Ignore case
List<User> findByNameIgnoreCase(String name);
List<User> findByNameContainingIgnoreCase(String keyword);
List<User> findByFirstNameAndLastNameAllIgnoreCase(String firstName, String lastName);
```

### NULL Checks

```java
// Is null
List<User> findByEmailIsNull();
List<User> findByPhoneNull();

// Is not null
List<User> findByEmailIsNotNull();
List<User> findByPhoneNotNull();
```

### Boolean Properties

```java
// True
List<User> findByActiveTrue();
List<User> findByVerifiedTrue();

// False
List<User> findByActiveFalse();
List<User> findByVerifiedFalse();

// Boolean parameter
List<User> findByActive(boolean active);
```

### Collection Queries

```java
// IN clause
List<User> findByAgeIn(List<Integer> ages);
List<User> findByStatusIn(String... statuses);
List<User> findByIdIn(Collection<Long> ids);

// NOT IN clause
List<User> findByAgeNotIn(List<Integer> ages);
```

---

## üìä Return Types

### Collection Types

```java
// List
List<User> findByName(String name);

// Set
Set<User> findByStatus(String status);

// Collection
Collection<User> findByActive(boolean active);

// Iterable
Iterable<User> findByAge(int age);
```

### Single Result

```java
// Optional (preferred)
Optional<User> findByEmail(String email);
Optional<User> findByUsername(String username);

// Entity (can be null)
User findByEmail(String email);

// Throws exception if multiple results
User findFirstByName(String name);
```

### Primitive Types

```java
// Count
long countByStatus(String status);
int countByActive(boolean active);

// Boolean
boolean existsByEmail(String email);
boolean existsByUsername(String username);
```

### Page and Slice

```java
// Page (includes total count)
Page<User> findByStatus(String status, Pageable pageable);

// Slice (no total count, more efficient)
Slice<User> findByActive(boolean active, Pageable pageable);
```

### Stream

```java
// Stream (must close)
@Query("SELECT u FROM User u")
Stream<User> streamAll();

// Usage
try (Stream<User> stream = userRepository.streamAll()) {
    stream.forEach(user -> System.out.println(user.getName()));
}
```

### Future/CompletableFuture

```java
// Asynchronous query
@Async
Future<List<User>> findByName(String name);

@Async
CompletableFuture<User> findByEmail(String email);

// Usage
CompletableFuture<User> futureUser = userRepository.findByEmail("john@example.com");
User user = futureUser.get(); // Blocks until complete
```

---

## üî§ Query Keywords

### Complete Reference

| Keyword | Sample | JPQL |
|---------|--------|------|
| `And` | `findByNameAndEmail` | `... where x.name = ?1 and x.email = ?2` |
| `Or` | `findByNameOrEmail` | `... where x.name = ?1 or x.email = ?2` |
| `Is, Equals` | `findByName` | `... where x.name = ?1` |
| `Between` | `findByAgeBetween` | `... where x.age between ?1 and ?2` |
| `LessThan` | `findByAgeLessThan` | `... where x.age < ?1` |
| `LessThanEqual` | `findByAgeLessThanEqual` | `... where x.age <= ?1` |
| `GreaterThan` | `findByAgeGreaterThan` | `... where x.age > ?1` |
| `GreaterThanEqual` | `findByAgeGreaterThanEqual` | `... where x.age >= ?1` |
| `After` | `findByDateAfter` | `... where x.date > ?1` |
| `Before` | `findByDateBefore` | `... where x.date < ?1` |
| `IsNull` | `findByEmailIsNull` | `... where x.email is null` |
| `IsNotNull, NotNull` | `findByEmailIsNotNull` | `... where x.email is not null` |
| `Like` | `findByNameLike` | `... where x.name like ?1` |
| `NotLike` | `findByNameNotLike` | `... where x.name not like ?1` |
| `StartingWith` | `findByNameStartingWith` | `... where x.name like ?1%` |
| `EndingWith` | `findByNameEndingWith` | `... where x.name like %?1` |
| `Containing` | `findByNameContaining` | `... where x.name like %?1%` |
| `OrderBy` | `findByNameOrderByAgeAsc` | `... order by x.age asc` |
| `Not` | `findByNameNot` | `... where x.name <> ?1` |
| `In` | `findByAgeIn` | `... where x.age in ?1` |
| `NotIn` | `findByAgeNotIn` | `... where x.age not in ?1` |
| `True` | `findByActiveTrue` | `... where x.active = true` |
| `False` | `findByActiveFalse` | `... where x.active = false` |
| `IgnoreCase` | `findByNameIgnoreCase` | `... where UPPER(x.name) = UPPER(?1)` |

---

## üîó Property Expressions

### Nested Properties

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @Embedded
    private Address address;
    
    @ManyToOne
    private Department department;
}

@Embeddable
public class Address {
    private String street;
    private String city;
    private String state;
    private String zipCode;
}

// Repository methods
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Nested property (use underscore to disambiguate)
    List<User> findByAddress_City(String city);
    List<User> findByAddress_State(String state);
    List<User> findByAddress_CityAndAddress_State(String city, String state);
    
    // Related entity
    List<User> findByDepartment_Name(String departmentName);
    List<User> findByDepartment_Id(Long departmentId);
}
```

### Traversing Relationships

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    private User user;
    
    private BigDecimal total;
}

public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Traverse to user properties
    List<Order> findByUser_Name(String userName);
    List<Order> findByUser_Email(String email);
    List<Order> findByUser_Address_City(String city);
    
    // Complex traversal
    List<Order> findByUser_Department_Name(String departmentName);
}
```

---

## ‚öôÔ∏è Special Parameters

### Sort Parameter

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Method with Sort parameter
    List<User> findByStatus(String status, Sort sort);
    List<User> findByActive(boolean active, Sort sort);
}

// Usage
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> getActiveUsers() {
        // Single property
        Sort sort = Sort.by("name");
        
        // With direction
        Sort sort = Sort.by(Sort.Direction.DESC, "createdDate");
        
        // Multiple properties
        Sort sort = Sort.by("name").ascending()
                        .and(Sort.by("age").descending());
        
        // Complex sort
        Sort sort = Sort.by(
            Sort.Order.asc("name"),
            Sort.Order.desc("createdDate")
        );
        
        return userRepository.findByActive(true, sort);
    }
}
```

### Pageable Parameter

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Method with Pageable
    Page<User> findByStatus(String status, Pageable pageable);
    Slice<User> findByActive(boolean active, Pageable pageable);
}

// Usage
public Page<User> getActiveUsers(int page, int size) {
    // Basic pagination
    Pageable pageable = PageRequest.of(page, size);
    
    // With sorting
    Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
    
    // With complex sort
    Pageable pageable = PageRequest.of(
        page, 
        size,
        Sort.by("name").ascending()
            .and(Sort.by("createdDate").descending())
    );
    
    return userRepository.findByActive(true, pageable);
}
```

---

## üî¢ Limiting Results

### First/Top Keywords

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // First result
    User findFirstByName(String name);
    User findFirstByOrderByCreatedDateDesc();
    
    // Top result (same as First)
    User findTopByOrderByAgeDesc();
    
    // Top N results
    List<User> findTop3ByOrderByCreatedDateDesc();
    List<User> findTop10ByStatus(String status);
    List<User> findFirst5ByActive(boolean active);
    
    // With additional conditions
    List<User> findTop5ByStatusOrderByCreatedDateDesc(String status);
    List<User> findFirst10ByAgeGreaterThanOrderByNameAsc(int age);
}

// Usage
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User getNewestUser() {
        return userRepository.findFirstByOrderByCreatedDateDesc();
    }
    
    public User getOldestUser() {
        return userRepository.findTopByOrderByAgeDesc();
    }
    
    public List<User> getRecentUsers() {
        return userRepository.findTop10ByOrderByCreatedDateDesc();
    }
}
```

### Distinct Results

```java
// Find distinct
List<User> findDistinctByName(String name);
List<User> findDistinctByStatus(String status);

// User.findDistinctByLastnameOrderByFirstnameDesc
List<User> findDistinctUsersByLastnameOrderByFirstnameDesc(String lastname);
```

---

## üåä Streaming Results

### Stream Return Type

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u")
    Stream<User> streamAllUsers();
    
    Stream<User> findAllByStatus(String status);
    
    Stream<User> streamByActive(boolean active);
}

// Usage
@Service
@Transactional(readOnly = true)
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void processAllUsers() {
        // Must be within @Transactional and use try-with-resources
        try (Stream<User> stream = userRepository.streamAllUsers()) {
            stream
                .filter(user -> user.getAge() > 18)
                .map(User::getName)
                .forEach(System.out::println);
        }
    }
    
    public long countActiveAdults() {
        try (Stream<User> stream = userRepository.streamByActive(true)) {
            return stream
                .filter(user -> user.getAge() >= 18)
                .count();
        }
    }
}
```

---

## üìå Best Practices

### 1. Keep Method Names Readable

```java
// ‚úÖ Good - Clear and concise
List<User> findByName(String name);
List<User> findByAgeGreaterThan(int age);

// ‚ùå Bad - Too complex
List<User> findByNameAndEmailAndPhoneAndAddressAndStatusAndActiveAndCreatedDateBetween(...);

// Better - Use @Query for complex queries
@Query("SELECT u FROM User u WHERE ...")
List<User> findComplexCriteria(...);
```

### 2. Return Optional for Single Results

```java
// ‚úÖ Good
Optional<User> findByEmail(String email);

// ‚ùå Bad - Can return null
User findByEmail(String email);
```

### 3. Use Proper Return Types

```java
// ‚úÖ Good - Specific return type
List<User> findByStatus(String status);
long countByActive(boolean active);
boolean existsByEmail(String email);

// ‚ùå Bad - Generic Object
Object findByStatus(String status);
```

### 4. Limit Results When Appropriate

```java
// ‚úÖ Good - Limit results
List<User> findTop10ByOrderByCreatedDateDesc();

// ‚ùå Bad - Potentially returns millions
List<User> findAll();
```

### 5. Use Pagination for Large Datasets

```java
// ‚úÖ Good
Page<User> findByStatus(String status, Pageable pageable);

// ‚ùå Bad - Loading all at once
List<User> findByStatus(String status);
```

### 6. Close Streams Properly

```java
// ‚úÖ Good
try (Stream<User> stream = userRepository.streamAll()) {
    stream.forEach(System.out::println);
}

// ‚ùå Bad - Resource leak
Stream<User> stream = userRepository.streamAll();
stream.forEach(System.out::println);
// Stream never closed!
```

### 7. Use Method References

```java
// ‚úÖ Good
Optional<User> user = userRepository.findById(id);
user.ifPresent(System.out::println);

// ‚ùå Bad
Optional<User> user = userRepository.findById(id);
if (user.isPresent()) {
    System.out.println(user.get());
}
```

---

## üé§ Interview Questions

### Q1: What are query methods?
**Answer:** Repository methods whose implementation is automatically generated by Spring Data JPA from method names.

### Q2: What are the components of a query method name?
**Answer:**
1. **Action**: find, read, query, count, exists, delete
2. **Subject** (optional): User, AllUsers
3. **Predicate**: ByName, ByAgeGreaterThan

### Q3: Difference between findBy and readBy?
**Answer:** No functional difference. Both return results. Choose based on preference for readability.

### Q4: What does findByNameAndEmail do?
**Answer:** Finds entities where name equals parameter 1 AND email equals parameter 2.

### Q5: How to find users with age between 20 and 30?
**Answer:**
```java
List<User> findByAgeBetween(int min, int max);
// Usage: findByAgeBetween(20, 30)
```

### Q6: How to implement case-insensitive search?
**Answer:**
```java
List<User> findByNameIgnoreCase(String name);
List<User> findByNameContainingIgnoreCase(String keyword);
```

### Q7: How to access nested properties?
**Answer:** Use underscore to traverse relationships:
```java
List<User> findByAddress_City(String city);
```

### Q8: What is the difference between First and Top?
**Answer:** No difference. Both limit to first result(s). Interchangeable:
```java
User findFirstByName(String name);
User findTopByName(String name);
```

### Q9: How to get top 5 users by creation date?
**Answer:**
```java
List<User> findTop5ByOrderByCreatedDateDesc();
```

### Q10: What return type for optional single result?
**Answer:** Use `Optional<T>`:
```java
Optional<User> findByEmail(String email);
```

### Q11: How to check if email exists?
**Answer:**
```java
boolean existsByEmail(String email);
```

### Q12: Can you sort query method results?
**Answer:** Yes, add Sort parameter or use OrderBy in method name:
```java
List<User> findByStatus(String status, Sort sort);
List<User> findByStatusOrderByNameAsc(String status);
```

### Q13: Difference between Page and Slice?
**Answer:**
- **Page**: Includes total count (additional query)
- **Slice**: No total count, just knows if next page exists

### Q14: How to stream large datasets?
**Answer:**
```java
@Transactional(readOnly = true)
try (Stream<User> stream = repository.streamAll()) {
    stream.forEach(...);
}
```

### Q15: What is @Async in query methods?
**Answer:** Makes query execute asynchronously, returns Future/CompletableFuture:
```java
@Async
CompletableFuture<User> findByEmail(String email);
```

### Q16: How to delete with query method?
**Answer:**
```java
@Transactional
long deleteByStatus(String status);
```

### Q17: How to find distinct results?
**Answer:**
```java
List<User> findDistinctByName(String name);
```

### Q18: Can query methods use IN clause?
**Answer:** Yes:
```java
List<User> findByIdIn(List<Long> ids);
```

### Q19: How to find NULL values?
**Answer:**
```java
List<User> findByEmailIsNull();
List<User> findByEmailIsNotNull();
```

### Q20: Maximum recommended method name length?
**Answer:** No hard limit, but if method name becomes too long (>3-4 predicates), use @Query instead for better readability.

---

## üìö Summary

### Method Naming Pattern

```
[action][Subject][By][Property][Comparison][And|Or][Property]...
```

### Common Patterns

```java
// Simple equality
List<User> findByName(String name);

// Comparisons
List<User> findByAgeGreaterThan(int age);
List<User> findByAgeBetween(int min, int max);

// String matching
List<User> findByNameContaining(String keyword);
List<User> findByNameStartingWith(String prefix);

// Boolean
List<User> findByActiveTrue();

// NULL checks
List<User> findByEmailIsNull();

// Collections
List<User> findByIdIn(List<Long> ids);

// Sorting
List<User> findByStatusOrderByNameAsc(String status);

// Limiting
List<User> findTop10ByOrderByCreatedDateDesc();

// Nested properties
List<User> findByAddress_City(String city);

// With pagination
Page<User> findByStatus(String status, Pageable pageable);
```

### Return Types

```java
// Single
Optional<User> findByEmail(String email);

// Collection
List<User> findByName(String name);

// Page/Slice
Page<User> findAll(Pageable pageable);

// Stream
Stream<User> streamAll();

// Count
long countByStatus(String status);

// Exists
boolean existsByEmail(String email);
```

**Next:** Custom Queries with @Query ‚Üí

