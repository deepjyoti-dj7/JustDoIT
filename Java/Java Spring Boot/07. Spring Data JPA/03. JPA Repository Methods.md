# üìö JPA Repository Methods - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Repository Hierarchy](#repository-hierarchy)
- [Built-in Methods](#built-in-methods)
- [Query Methods](#query-methods)
- [Query Keywords](#query-keywords)
- [@Query Annotation](#query-annotation)
- [Named Queries](#named-queries)
- [Native Queries](#native-queries)
- [Projections](#projections)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**JPA Repository Methods** provide various ways to query data without writing implementation code.

### Method Types

1. **Built-in Methods**: Provided by Spring Data JPA
2. **Derived Query Methods**: Generated from method names
3. **@Query Methods**: Custom JPQL/SQL queries
4. **Named Queries**: Predefined queries in entity
5. **Native Queries**: Direct SQL queries

---

## üèóÔ∏è Repository Hierarchy

### Repository Interfaces

```
Repository<T, ID>
    ‚Üì
CrudRepository<T, ID>
    ‚Üì
PagingAndSortingRepository<T, ID>
    ‚Üì
JpaRepository<T, ID>
```

### Repository Interface

```java
// Marker interface - no methods
public interface Repository<T, ID> {
}
```

### CrudRepository

```java
public interface CrudRepository<T, ID> extends Repository<T, ID> {
    <S extends T> S save(S entity);
    <S extends T> Iterable<S> saveAll(Iterable<S> entities);
    Optional<T> findById(ID id);
    boolean existsById(ID id);
    Iterable<T> findAll();
    Iterable<T> findAllById(Iterable<ID> ids);
    long count();
    void deleteById(ID id);
    void delete(T entity);
    void deleteAllById(Iterable<? extends ID> ids);
    void deleteAll(Iterable<? extends T> entities);
    void deleteAll();
}
```

### PagingAndSortingRepository

```java
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
    Iterable<T> findAll(Sort sort);
    Page<T> findAll(Pageable pageable);
}
```

### JpaRepository

```java
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID> {
    List<T> findAll();
    List<T> findAll(Sort sort);
    List<T> findAllById(Iterable<ID> ids);
    <S extends T> List<S> saveAll(Iterable<S> entities);
    void flush();
    <S extends T> S saveAndFlush(S entity);
    <S extends T> List<S> saveAllAndFlush(Iterable<S> entities);
    void deleteAllInBatch(Iterable<T> entities);
    void deleteAllByIdInBatch(Iterable<ID> ids);
    void deleteAllInBatch();
    T getOne(ID id);
    T getById(ID id);
    <S extends T> List<S> findAll(Example<S> example);
    <S extends T> List<S> findAll(Example<S> example, Sort sort);
}
```

### Custom Repository

```java
// Using specific interface based on needs
public interface UserRepository extends JpaRepository<User, Long> {
    // Custom methods
}

// Or minimal interface
public interface UserRepository extends CrudRepository<User, Long> {
    // Fewer built-in methods
}
```

---

## üîß Built-in Methods

### Save Operations

```java
public interface UserRepository extends JpaRepository<User, Long> { }

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Save single entity
    public User save(User user) {
        return userRepository.save(user);
    }
    
    // Save multiple entities
    public List<User> saveAll(List<User> users) {
        return userRepository.saveAll(users);
    }
    
    // Save and flush immediately
    public User saveAndFlush(User user) {
        return userRepository.saveAndFlush(user);
    }
}
```

### Find Operations

```java
// Find by ID
public User findById(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("User not found"));
}

// Find all
public List<User> findAll() {
    return userRepository.findAll();
}

// Find all by IDs
public List<User> findAllByIds(List<Long> ids) {
    return userRepository.findAllById(ids);
}

// Find with sorting
public List<User> findAllSorted() {
    return userRepository.findAll(Sort.by(Sort.Direction.ASC, "name"));
}

// Find with pagination
public Page<User> findAllPaginated(int page, int size) {
    return userRepository.findAll(PageRequest.of(page, size));
}

// Find with pagination and sorting
public Page<User> findAllPaginatedAndSorted(int page, int size) {
    Pageable pageable = PageRequest.of(page, size, Sort.by("name").ascending());
    return userRepository.findAll(pageable);
}
```

### Delete Operations

```java
// Delete by ID
public void deleteById(Long id) {
    userRepository.deleteById(id);
}

// Delete entity
public void delete(User user) {
    userRepository.delete(user);
}

// Delete all by IDs
public void deleteAllByIds(List<Long> ids) {
    userRepository.deleteAllById(ids);
}

// Delete all entities
public void deleteAll() {
    userRepository.deleteAll();
}

// Delete in batch (more efficient)
public void deleteInBatch(List<User> users) {
    userRepository.deleteAllInBatch(users);
}
```

### Other Operations

```java
// Count
public long count() {
    return userRepository.count();
}

// Exists
public boolean exists(Long id) {
    return userRepository.existsById(id);
}

// Flush changes to database
public void flush() {
    userRepository.flush();
}
```

---

## üîç Query Methods

### Derived Query Methods

Spring Data JPA generates implementation from method name.

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find by property
    List<User> findByName(String name);
    
    // Find with multiple conditions
    List<User> findByNameAndEmail(String name, String email);
    
    // Find with OR
    List<User> findByNameOrEmail(String name, String email);
    
    // Find by property with comparison
    List<User> findByAgeGreaterThan(int age);
    List<User> findByAgeLessThan(int age);
    List<User> findByAgeGreaterThanEqual(int age);
    List<User> findByAgeLessThanEqual(int age);
    List<User> findByAgeBetween(int minAge, int maxAge);
    
    // Find with LIKE
    List<User> findByNameContaining(String keyword);
    List<User> findByNameStartingWith(String prefix);
    List<User> findByNameEndingWith(String suffix);
    List<User> findByNameLike(String pattern);
    
    // Find with IN
    List<User> findByAgeIn(List<Integer> ages);
    List<User> findByNameIn(List<String> names);
    
    // Find with NULL check
    List<User> findByEmailIsNull();
    List<User> findByEmailIsNotNull();
    
    // Find with boolean
    List<User> findByActiveTrue();
    List<User> findByActiveFalse();
    
    // Find with sorting
    List<User> findByNameOrderByAgeAsc(String name);
    List<User> findByNameOrderByAgeDesc(String name);
    
    // Find with ignore case
    List<User> findByNameIgnoreCase(String name);
    List<User> findByNameContainingIgnoreCase(String keyword);
    
    // Find distinct
    List<User> findDistinctByName(String name);
    
    // Find first/top
    User findFirstByName(String name);
    User findTopByOrderByAgeDesc();
    List<User> findTop5ByOrderByAgeDesc();
    List<User> findFirst10ByNameOrderByAgeAsc(String name);
    
    // Count
    long countByStatus(String status);
    
    // Exists
    boolean existsByEmail(String email);
    
    // Delete
    long deleteByStatus(String status);
    void deleteByName(String name);
}
```

### Usage Examples

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> searchUsers(String keyword) {
        return userRepository.findByNameContainingIgnoreCase(keyword);
    }
    
    public List<User> getUsersByAgeRange(int min, int max) {
        return userRepository.findByAgeBetween(min, max);
    }
    
    public User getOldestUser() {
        return userRepository.findTopByOrderByAgeDesc();
    }
    
    public boolean isEmailRegistered(String email) {
        return userRepository.existsByEmail(email);
    }
    
    @Transactional
    public long deleteInactiveUsers() {
        return userRepository.deleteByStatus("INACTIVE");
    }
}
```

---

## üî§ Query Keywords

### Complete List

| Keyword | Example | JPQL Snippet |
|---------|---------|--------------|
| `And` | `findByNameAndEmail` | `... where x.name = ?1 and x.email = ?2` |
| `Or` | `findByNameOrEmail` | `... where x.name = ?1 or x.email = ?2` |
| `Is, Equals` | `findByName` | `... where x.name = ?1` |
| `Between` | `findByAgeBetween` | `... where x.age between ?1 and ?2` |
| `LessThan` | `findByAgeLessThan` | `... where x.age < ?1` |
| `LessThanEqual` | `findByAgeLessThanEqual` | `... where x.age <= ?1` |
| `GreaterThan` | `findByAgeGreaterThan` | `... where x.age > ?1` |
| `GreaterThanEqual` | `findByAgeGreaterThanEqual` | `... where x.age >= ?1` |
| `After` | `findByCreatedDateAfter` | `... where x.createdDate > ?1` |
| `Before` | `findByCreatedDateBefore` | `... where x.createdDate < ?1` |
| `IsNull, Null` | `findByEmailIsNull` | `... where x.email is null` |
| `IsNotNull, NotNull` | `findByEmailIsNotNull` | `... where x.email is not null` |
| `Like` | `findByNameLike` | `... where x.name like ?1` |
| `NotLike` | `findByNameNotLike` | `... where x.name not like ?1` |
| `StartingWith` | `findByNameStartingWith` | `... where x.name like ?1%` |
| `EndingWith` | `findByNameEndingWith` | `... where x.name like %?1` |
| `Containing` | `findByNameContaining` | `... where x.name like %?1%` |
| `OrderBy` | `findByNameOrderByAgeAsc` | `... order by x.age asc` |
| `Not` | `findByNameNot` | `... where x.name <> ?1` |
| `In` | `findByAgeIn` | `... where x.age in ?1` |
| `NotIn` | `findByAgeNotIn` | `... where x.age not in ?1` |
| `True` | `findByActiveTrue` | `... where x.active = true` |
| `False` | `findByActiveFalse` | `... where x.active = false` |
| `IgnoreCase` | `findByNameIgnoreCase` | `... where UPPER(x.name) = UPPER(?1)` |

### Complex Examples

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Multiple conditions with AND/OR
    List<User> findByNameAndAgeGreaterThanAndEmailContaining(
        String name, int age, String emailKeyword);
    
    List<User> findByNameOrEmailAndActive(String name, String email, boolean active);
    
    // Nested properties
    List<User> findByAddress_City(String city);
    List<User> findByAddress_CityAndAddress_State(String city, String state);
    
    // Date comparisons
    List<User> findByCreatedDateBetween(LocalDate start, LocalDate end);
    List<User> findByCreatedDateAfter(LocalDate date);
    
    // Complex sorting
    List<User> findByStatusOrderByNameAscAgeDesc(String status);
    
    // Combination
    List<User> findTop10ByStatusAndAgeGreaterThanOrderByCreatedDateDesc(
        String status, int age);
}
```

---

## üìù @Query Annotation

### JPQL Queries

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Simple JPQL
    @Query("SELECT u FROM User u WHERE u.name = ?1")
    List<User> findByNameJPQL(String name);
    
    // Named parameters
    @Query("SELECT u FROM User u WHERE u.name = :name AND u.email = :email")
    List<User> findByNameAndEmail(@Param("name") String name, @Param("email") String email);
    
    // Join query
    @Query("SELECT u FROM User u JOIN u.orders o WHERE o.total > :amount")
    List<User> findUsersWithOrdersGreaterThan(@Param("amount") BigDecimal amount);
    
    // Aggregation
    @Query("SELECT COUNT(u) FROM User u WHERE u.status = :status")
    long countByStatus(@Param("status") String status);
    
    // Custom projection
    @Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) FROM User u WHERE u.id = :id")
    UserDTO findUserDTOById(@Param("id") Long id);
    
    // Subquery
    @Query("SELECT u FROM User u WHERE u.age > (SELECT AVG(u2.age) FROM User u2)")
    List<User> findUsersOlderThanAverage();
    
    // IN clause
    @Query("SELECT u FROM User u WHERE u.id IN :ids")
    List<User> findByIds(@Param("ids") List<Long> ids);
    
    // LIKE query
    @Query("SELECT u FROM User u WHERE LOWER(u.name) LIKE LOWER(CONCAT('%', :keyword, '%'))")
    List<User> searchByName(@Param("keyword") String keyword);
}
```

### Modifying Queries

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Update query
    @Modifying
    @Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
    int updateStatus(@Param("id") Long id, @Param("status") String status);
    
    // Bulk update
    @Modifying
    @Query("UPDATE User u SET u.active = false WHERE u.lastLoginDate < :date")
    int deactivateInactiveUsers(@Param("date") LocalDate date);
    
    // Delete query
    @Modifying
    @Query("DELETE FROM User u WHERE u.status = :status")
    int deleteByStatus(@Param("status") String status);
}

// Usage (must be in @Transactional method)
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public int activateUser(Long id) {
        return userRepository.updateStatus(id, "ACTIVE");
    }
}
```

---

## üìõ Named Queries

### Define in Entity

```java
@Entity
@NamedQuery(
    name = "User.findByStatus",
    query = "SELECT u FROM User u WHERE u.status = :status"
)
@NamedQueries({
    @NamedQuery(
        name = "User.findActiveUsers",
        query = "SELECT u FROM User u WHERE u.active = true"
    ),
    @NamedQuery(
        name = "User.countByStatus",
        query = "SELECT COUNT(u) FROM User u WHERE u.status = :status"
    )
})
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String status;
    private boolean active;
}
```

### Use in Repository

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Spring Data JPA automatically finds named query
    List<User> findByStatus(@Param("status") String status);
    
    List<User> findActiveUsers();
    
    long countByStatus(@Param("status") String status);
}
```

---

## üíæ Native Queries

### Basic Native Query

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Simple native query
    @Query(value = "SELECT * FROM users WHERE name = ?1", nativeQuery = true)
    List<User> findByNameNative(String name);
    
    // Named parameters
    @Query(value = "SELECT * FROM users WHERE name = :name AND email = :email", 
           nativeQuery = true)
    List<User> findByNameAndEmailNative(@Param("name") String name, @Param("email") String email);
    
    // Complex native query
    @Query(value = """
        SELECT u.* FROM users u
        JOIN orders o ON u.id = o.user_id
        WHERE o.total > :amount
        GROUP BY u.id
        HAVING COUNT(o.id) > :orderCount
        """, 
        nativeQuery = true)
    List<User> findUsersWithManyHighValueOrders(
        @Param("amount") BigDecimal amount,
        @Param("orderCount") int orderCount);
    
    // Scalar result
    @Query(value = "SELECT AVG(age) FROM users", nativeQuery = true)
    Double getAverageAge();
    
    // Multiple columns
    @Query(value = "SELECT name, COUNT(*) as count FROM users GROUP BY name", 
           nativeQuery = true)
    List<Object[]> getUserCountByName();
}
```

### Modifying Native Query

```java
@Modifying
@Query(value = "UPDATE users SET status = :status WHERE id = :id", nativeQuery = true)
int updateStatusNative(@Param("id") Long id, @Param("status") String status);

@Modifying
@Query(value = "DELETE FROM users WHERE created_date < :date", nativeQuery = true)
int deleteOldUsersNative(@Param("date") LocalDate date);
```

---

## üéØ Projections

### Interface-based Projections

```java
// Closed projection - only specified properties
public interface UserNameOnly {
    String getName();
    String getEmail();
}

// Open projection - SpEL expressions
public interface UserInfo {
    String getName();
    
    @Value("#{target.name + ' (' + target.email + ')'}")
    String getFullInfo();
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    List<UserNameOnly> findAllProjectedBy();
    
    UserNameOnly findProjectedById(Long id);
    
    List<UserInfo> findByStatus(String status);
}
```

### Class-based Projections (DTO)

```java
// DTO class
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    
    public UserDTO(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Getters
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) FROM User u")
    List<UserDTO> findAllDTO();
    
    @Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) FROM User u WHERE u.id = :id")
    UserDTO findDTOById(@Param("id") Long id);
}
```

### Dynamic Projections

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    <T> List<T> findByStatus(String status, Class<T> type);
}

// Usage
List<UserNameOnly> names = userRepository.findByStatus("ACTIVE", UserNameOnly.class);
List<UserDTO> dtos = userRepository.findByStatus("ACTIVE", UserDTO.class);
```

---

## üìå Best Practices

### 1. Use Derived Query Methods for Simple Queries

```java
// ‚úÖ Good - Simple and readable
List<User> findByName(String name);

// ‚ùå Bad - Unnecessary @Query for simple case
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> findByName(@Param("name") String name);
```

### 2. Use @Query for Complex Queries

```java
// ‚úÖ Good - Complex query with @Query
@Query("SELECT u FROM User u JOIN u.orders o WHERE o.total > :amount AND o.status = :status")
List<User> findUsersWithHighValueOrders(@Param("amount") BigDecimal amount, @Param("status") String status);

// ‚ùå Bad - Too complex method name
List<User> findByOrders_TotalGreaterThanAndOrders_Status(BigDecimal amount, String status);
```

### 3. Use Named Parameters

```java
// ‚úÖ Good - Clear parameter binding
@Query("SELECT u FROM User u WHERE u.name = :name AND u.email = :email")
List<User> find(@Param("name") String name, @Param("email") String email);

// ‚ùå Bad - Positional parameters hard to maintain
@Query("SELECT u FROM User u WHERE u.name = ?1 AND u.email = ?2")
List<User> find(String name, String email);
```

### 4. Return Optional for Single Results

```java
// ‚úÖ Good
Optional<User> findByEmail(String email);

// ‚ùå Bad - Can return null
User findByEmail(String email);
```

### 5. Use Projections to Reduce Data Transfer

```java
// ‚úÖ Good - Only needed fields
public interface UserSummary {
    String getName();
    String getEmail();
}
List<UserSummary> findAllProjectedBy();

// ‚ùå Bad - Loading entire entity when not needed
List<User> findAll(); // Returns all fields
```

### 6. Use @Transactional with Modifying Queries

```java
// ‚úÖ Good
@Transactional
public int deactivateUser(Long id) {
    return userRepository.updateStatus(id, "INACTIVE");
}

// ‚ùå Bad - Missing @Transactional
public int deactivateUser(Long id) {
    return userRepository.updateStatus(id, "INACTIVE"); // Will fail!
}
```

### 7. Avoid N+1 Queries

```java
// ‚úÖ Good - JOIN FETCH
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
Optional<User> findByIdWithOrders(@Param("id") Long id);

// ‚ùå Bad - Causes N+1
Optional<User> findById(Long id); // Then accessing user.getOrders() causes extra queries
```

---

## üé§ Interview Questions

### Q1: What is JpaRepository?
**Answer:** Interface extending PagingAndSortingRepository providing additional JPA-specific methods like flush(), saveAndFlush(), batch operations.

### Q2: Difference between CrudRepository and JpaRepository?
**Answer:**
- **CrudRepository**: Basic CRUD operations
- **JpaRepository**: Adds batch operations, flush, JPA-specific features

### Q3: How do derived query methods work?
**Answer:** Spring Data JPA parses method name and generates query implementation at runtime based on naming convention.

### Q4: What are query keywords?
**Answer:** Special words in method names that Spring Data JPA translates to query conditions: And, Or, Between, LessThan, GreaterThan, Like, In, etc.

### Q5: What is @Query annotation?
**Answer:** Annotation to define custom JPQL or native SQL queries on repository methods.

### Q6: Difference between JPQL and native query?
**Answer:**
- **JPQL**: Entity-based, database-independent, uses entity names
- **Native**: Table-based, database-specific, uses table/column names

### Q7: What is @Modifying?
**Answer:** Annotation for UPDATE/DELETE queries in @Query. Must be used with @Transactional.

### Q8: What are named queries?
**Answer:** Predefined queries declared in entity using @NamedQuery, reusable across repositories.

### Q9: What is projection?
**Answer:** Selecting only needed fields instead of entire entity using interfaces or DTOs.

### Q10: Types of projections?
**Answer:**
- **Interface-based**: Closed (specific fields) and Open (SpEL)
- **Class-based**: DTO with constructor
- **Dynamic**: Runtime type selection

### Q11: What is @Param?
**Answer:** Annotation to bind method parameter to named parameter in @Query.

### Q12: Difference between save() and saveAndFlush()?
**Answer:**
- **save()**: Persists to context, DB write happens at flush time
- **saveAndFlush()**: Persists and immediately flushes to database

### Q13: How to handle pagination?
**Answer:**
```java
Page<User> users = userRepository.findAll(PageRequest.of(0, 10));
```

### Q14: What is Sort in Spring Data JPA?
**Answer:** Class to specify sorting criteria:
```java
Sort sort = Sort.by(Sort.Direction.ASC, "name");
```

### Q15: Can you use native query with pagination?
**Answer:** Yes, but need to provide count query:
```java
@Query(value = "SELECT * FROM users", 
       countQuery = "SELECT COUNT(*) FROM users",
       nativeQuery = true)
Page<User> findAll(Pageable pageable);
```

### Q16: What is findById vs getById?
**Answer:**
- **findById()**: Returns Optional, queries database
- **getById()**: Returns proxy, lazy loading (deprecated in newer versions, use getReferenceById)

### Q17: How to return custom object from query?
**Answer:** Use constructor expression in JPQL:
```java
@Query("SELECT new com.example.UserDTO(u.id, u.name) FROM User u")
List<UserDTO> findAllDTO();
```

### Q18: What is orphanRemoval in repository context?
**Answer:** Automatically deletes child entities when removed from parent's collection (entity level, not repository).

### Q19: Can derived query methods use joins?
**Answer:** Yes, using property path:
```java
List<User> findByAddress_City(String city);
```

### Q20: What is @EntityGraph?
**Answer:** Annotation to solve N+1 problem by specifying fetch plan:
```java
@EntityGraph(attributePaths = {"orders"})
List<User> findAll();
```

---

## üìö Summary

### Repository Interfaces

```java
// Full-featured
public interface UserRepository extends JpaRepository<User, Long> { }

// Basic CRUD
public interface UserRepository extends CrudRepository<User, Long> { }

// With pagination
public interface UserRepository extends PagingAndSortingRepository<User, Long> { }
```

### Query Methods

```java
// Derived query methods
List<User> findByName(String name);
List<User> findByAgeGreaterThan(int age);
List<User> findByNameContainingIgnoreCase(String keyword);

// @Query JPQL
@Query("SELECT u FROM User u WHERE u.status = :status")
List<User> findByStatus(@Param("status") String status);

// Native query
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> findByNameNative(@Param("name") String name);

// Modifying query
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") String status);
```

### Common Patterns

- Use derived methods for simple queries
- Use @Query for complex queries
- Use projections to reduce data
- Always return Optional for single results
- Use @Transactional with @Modifying

**Next:** Query Methods Advanced ‚Üí

