# üìÑ Pagination and Sorting - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Pageable Interface](#pageable-interface)
- [PageRequest](#pagerequest)
- [Sort](#sort)
- [Page Interface](#page-interface)
- [Slice Interface](#slice-interface)
- [Sorting Strategies](#sorting-strategies)
- [Custom Pagination](#custom-pagination)
- [Performance Optimization](#performance-optimization)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Pagination and Sorting** are essential for handling large datasets efficiently by retrieving data in manageable chunks.

### Benefits

1. **Performance**: Load only needed data
2. **Memory**: Reduce memory consumption
3. **UX**: Better user experience
4. **Network**: Reduce data transfer

---

## üì¶ Pageable Interface

### Basic Concept

```java
public interface Pageable {
    int getPageNumber();      // Current page (0-indexed)
    int getPageSize();        // Number of items per page
    long getOffset();         // Starting position
    Sort getSort();          // Sort specification
    Pageable next();         // Next page
    Pageable previousOrFirst(); // Previous page
    boolean hasPrevious();   // Has previous page
}
```

### Repository Methods

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Built-in findAll with Pageable
    Page<User> findAll(Pageable pageable);
    
    // Custom query with Pageable
    Page<User> findByStatus(String status, Pageable pageable);
    
    // Multiple conditions
    Page<User> findByStatusAndActive(String status, boolean active, Pageable pageable);
    
    // With @Query
    @Query("SELECT u FROM User u WHERE u.department.name = :deptName")
    Page<User> findByDepartment(@Param("deptName") String deptName, Pageable pageable);
}
```

### Basic Usage

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public Page<User> getUsers(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return userRepository.findAll(pageable);
    }
    
    public Page<User> getActiveUsers(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        return userRepository.findByStatus("ACTIVE", pageable);
    }
}
```

---

## üî¢ PageRequest

### Creating PageRequest

```java
// Basic pagination (page 0, size 10)
Pageable pageable = PageRequest.of(0, 10);

// With sorting
Pageable pageable = PageRequest.of(0, 10, Sort.by("name"));

// With direction
Pageable pageable = PageRequest.of(0, 10, Sort.Direction.DESC, "createdDate");

// Multiple sort properties
Pageable pageable = PageRequest.of(0, 10, Sort.by("name", "age"));

// Complex sort
Pageable pageable = PageRequest.of(
    0, 
    10,
    Sort.by("name").ascending()
        .and(Sort.by("createdDate").descending())
);
```

### PageRequest Methods

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @GetMapping
    public Page<User> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "id") String sortBy,
        @RequestParam(defaultValue = "ASC") String direction
    ) {
        Sort.Direction sortDirection = Sort.Direction.fromString(direction);
        Pageable pageable = PageRequest.of(page, size, Sort.by(sortDirection, sortBy));
        
        return userRepository.findAll(pageable);
    }
}
```

### Unpaged

```java
// Get all records without pagination
Pageable unpaged = Pageable.unpaged();
Page<User> allUsers = userRepository.findAll(unpaged);
```

---

## üîÄ Sort

### Creating Sort

```java
// Single property ascending
Sort sort = Sort.by("name");

// Single property descending
Sort sort = Sort.by(Sort.Direction.DESC, "createdDate");

// Multiple properties
Sort sort = Sort.by("name", "age", "email");

// Using Sort.Order
Sort sort = Sort.by(
    Sort.Order.asc("name"),
    Sort.Order.desc("createdDate")
);

// Ignore case
Sort sort = Sort.by(Sort.Order.asc("name").ignoreCase());

// Null handling
Sort sort = Sort.by(
    Sort.Order.asc("name").nullsFirst(),
    Sort.Order.desc("age").nullsLast()
);
```

### Chaining Sorts

```java
// Chain multiple sorts
Sort sort = Sort.by("name").ascending()
    .and(Sort.by("age").descending())
    .and(Sort.by("createdDate").descending());

// Combine sorts
Sort sort1 = Sort.by("name");
Sort sort2 = Sort.by("age");
Sort combined = sort1.and(sort2);
```

### Sort in Repository

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Method accepting Sort
    List<User> findByStatus(String status, Sort sort);
    
    // Built-in findAll with Sort
    List<User> findAll(Sort sort);
}

// Usage
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> getActiveUsersSorted() {
        Sort sort = Sort.by("name").ascending()
                        .and(Sort.by("createdDate").descending());
        
        return userRepository.findByStatus("ACTIVE", sort);
    }
}
```

### Nested Property Sorting

```java
// Sort by nested property
Sort sort = Sort.by("address.city");
Sort sort = Sort.by("department.name");

// Multiple nested properties
Sort sort = Sort.by("address.city").ascending()
                .and(Sort.by("address.state").ascending());
```

---

## üìñ Page Interface

### Page Methods

```java
public interface Page<T> extends Slice<T> {
    int getTotalPages();           // Total number of pages
    long getTotalElements();       // Total number of elements
    
    // From Slice
    int getNumber();              // Current page number
    int getSize();                // Page size
    int getNumberOfElements();    // Number of elements in current page
    List<T> getContent();         // Content of current page
    boolean hasContent();         // Has content
    Sort getSort();              // Sort specification
    boolean isFirst();           // Is first page
    boolean isLast();            // Is last page
    boolean hasNext();           // Has next page
    boolean hasPrevious();       // Has previous page
    Pageable getPageable();      // Current pageable
    Pageable nextPageable();     // Next pageable
    Pageable previousPageable(); // Previous pageable
}
```

### Using Page

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void demonstratePage() {
        Pageable pageable = PageRequest.of(0, 10);
        Page<User> page = userRepository.findAll(pageable);
        
        // Page information
        int currentPage = page.getNumber();              // 0
        int pageSize = page.getSize();                   // 10
        int totalPages = page.getTotalPages();           // Total pages
        long totalElements = page.getTotalElements();    // Total records
        int elementsInPage = page.getNumberOfElements(); // Records in current page
        
        // Content
        List<User> users = page.getContent();
        
        // Navigation
        boolean hasNext = page.hasNext();
        boolean hasPrevious = page.hasPrevious();
        boolean isFirst = page.isFirst();
        boolean isLast = page.isLast();
        
        // Iterate
        page.forEach(user -> System.out.println(user.getName()));
        
        // Stream
        page.stream()
            .map(User::getName)
            .forEach(System.out::println);
    }
}
```

### Page Mapping

```java
// Map to DTO
@Service
public class UserService {
    
    public Page<UserDTO> getUsersAsDTO(Pageable pageable) {
        Page<User> userPage = userRepository.findAll(pageable);
        
        // Map Page<User> to Page<UserDTO>
        return userPage.map(user -> new UserDTO(
            user.getId(),
            user.getName(),
            user.getEmail()
        ));
    }
    
    // Method reference
    public Page<UserDTO> getUsersAsDTO2(Pageable pageable) {
        return userRepository.findAll(pageable)
                            .map(this::convertToDTO);
    }
    
    private UserDTO convertToDTO(User user) {
        return new UserDTO(user.getId(), user.getName(), user.getEmail());
    }
}
```

### REST Response

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @GetMapping
    public ResponseEntity<PageResponse<UserDTO>> getUsers(Pageable pageable) {
        Page<User> page = userRepository.findAll(pageable);
        
        PageResponse<UserDTO> response = new PageResponse<>();
        response.setContent(page.map(this::toDTO).getContent());
        response.setPageNumber(page.getNumber());
        response.setPageSize(page.getSize());
        response.setTotalElements(page.getTotalElements());
        response.setTotalPages(page.getTotalPages());
        response.setLast(page.isLast());
        response.setFirst(page.isFirst());
        
        return ResponseEntity.ok(response);
    }
    
    private UserDTO toDTO(User user) {
        return new UserDTO(user.getId(), user.getName(), user.getEmail());
    }
}

// Response DTO
@Data
public class PageResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean last;
    private boolean first;
}
```

---

## üîñ Slice Interface

### Slice vs Page

| Feature | Slice | Page |
|---------|-------|------|
| Total count query | ‚ùå No | ‚úÖ Yes |
| Total pages | ‚ùå No | ‚úÖ Yes |
| Total elements | ‚ùå No | ‚úÖ Yes |
| Performance | ‚úÖ Better | ‚ùå Slower |
| Use case | Infinite scroll | Traditional pagination |

### Using Slice

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    Slice<User> findByStatus(String status, Pageable pageable);
}

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public Slice<User> getUserSlice(int page, int size) {
        Pageable pageable = PageRequest.of(page, size);
        Slice<User> slice = userRepository.findByStatus("ACTIVE", pageable);
        
        // Slice information
        int number = slice.getNumber();
        int numberOfElements = slice.getNumberOfElements();
        boolean hasNext = slice.hasNext();
        boolean hasPrevious = slice.hasPrevious();
        
        // NO total elements/pages
        // slice.getTotalElements(); // Not available
        // slice.getTotalPages();    // Not available
        
        return slice;
    }
}
```

### Infinite Scroll

```java
@RestController
@RequestMapping("/api/feed")
public class FeedController {
    
    @Autowired
    private PostRepository postRepository;
    
    @GetMapping
    public SliceResponse<PostDTO> getFeed(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size
    ) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdDate").descending());
        Slice<Post> slice = postRepository.findAll(pageable);
        
        SliceResponse<PostDTO> response = new SliceResponse<>();
        response.setContent(slice.map(this::toDTO).getContent());
        response.setHasNext(slice.hasNext());
        response.setPageNumber(slice.getNumber());
        
        return response;
    }
    
    private PostDTO toDTO(Post post) {
        return new PostDTO(post.getId(), post.getTitle(), post.getContent());
    }
}

@Data
public class SliceResponse<T> {
    private List<T> content;
    private boolean hasNext;
    private int pageNumber;
}
```

---

## üéØ Sorting Strategies

### Dynamic Sorting

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserRepository userRepository;
    
    @GetMapping
    public Page<User> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(required = false) String[] sort
    ) {
        Pageable pageable;
        
        if (sort != null && sort.length > 0) {
            List<Sort.Order> orders = new ArrayList<>();
            
            for (String sortParam : sort) {
                // Format: "property,direction" e.g., "name,asc"
                String[] parts = sortParam.split(",");
                String property = parts[0];
                Sort.Direction direction = parts.length > 1 
                    ? Sort.Direction.fromString(parts[1])
                    : Sort.Direction.ASC;
                
                orders.add(new Sort.Order(direction, property));
            }
            
            pageable = PageRequest.of(page, size, Sort.by(orders));
        } else {
            pageable = PageRequest.of(page, size);
        }
        
        return userRepository.findAll(pageable);
    }
}

// Usage:
// GET /api/users?page=0&size=10&sort=name,asc&sort=age,desc
```

### Safe Sorting (Prevent SQL Injection)

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    private static final Set<String> ALLOWED_SORT_PROPERTIES = 
        Set.of("name", "email", "age", "createdDate");
    
    public Page<User> getUsers(int page, int size, String sortBy, String direction) {
        // Validate sort property
        if (!ALLOWED_SORT_PROPERTIES.contains(sortBy)) {
            sortBy = "id"; // Default
        }
        
        Sort.Direction sortDirection;
        try {
            sortDirection = Sort.Direction.fromString(direction);
        } catch (IllegalArgumentException e) {
            sortDirection = Sort.Direction.ASC; // Default
        }
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(sortDirection, sortBy));
        return userRepository.findAll(pageable);
    }
}
```

---

## ‚öôÔ∏è Custom Pagination

### Custom Pageable Resolver

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        // Custom page parameter names
        PageableHandlerMethodArgumentResolver resolver = 
            new PageableHandlerMethodArgumentResolver();
        
        resolver.setPageParameterName("pageNumber");
        resolver.setSizeParameterName("pageSize");
        resolver.setOneIndexedParameters(true); // 1-indexed instead of 0
        resolver.setMaxPageSize(100); // Max page size
        resolver.setFallbackPageable(PageRequest.of(0, 20)); // Default
        
        resolvers.add(resolver);
    }
}
```

### Custom Page Implementation

```java
public class CustomPage<T> implements Page<T> {
    
    private final List<T> content;
    private final Pageable pageable;
    private final long total;
    
    public CustomPage(List<T> content, Pageable pageable, long total) {
        this.content = content;
        this.pageable = pageable;
        this.total = total;
    }
    
    @Override
    public int getTotalPages() {
        return getSize() == 0 ? 1 : (int) Math.ceil((double) total / (double) getSize());
    }
    
    @Override
    public long getTotalElements() {
        return total;
    }
    
    @Override
    public List<T> getContent() {
        return content;
    }
    
    // Implement other methods...
}
```

---

## ‚ö° Performance Optimization

### Count Query Optimization

```java
// Expensive - Count query on every page
@Query("SELECT u FROM User u WHERE u.status = :status")
Page<User> findByStatus(@Param("status") String status, Pageable pageable);

// Optimized - Separate count query
@Query(value = "SELECT u FROM User u WHERE u.status = :status",
       countQuery = "SELECT COUNT(u.id) FROM User u WHERE u.status = :status")
Page<User> findByStatus(@Param("status") String status, Pageable pageable);

// Even better - Use Slice for infinite scroll
Slice<User> findByStatus(String status, Pageable pageable);
```

### Index Optimization

```java
@Entity
@Table(
    indexes = {
        @Index(name = "idx_user_status", columnList = "status"),
        @Index(name = "idx_user_created", columnList = "created_date DESC"),
        @Index(name = "idx_user_status_created", columnList = "status, created_date DESC")
    }
)
public class User {
    // Optimized for pagination queries
}
```

### Keyset Pagination

```java
// Traditional offset pagination (slow for large offsets)
// SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10000

// Keyset pagination (fast)
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.id > :lastId ORDER BY u.id")
    List<User> findNextPage(@Param("lastId") Long lastId, Pageable pageable);
}

// Usage
public List<User> getNextPage(Long lastId, int size) {
    Pageable pageable = PageRequest.of(0, size);
    return userRepository.findNextPage(lastId, pageable);
}
```

---

## üìå Best Practices

### 1. Use Slice for Infinite Scroll

```java
// ‚úÖ Good - No count query
Slice<User> findByStatus(String status, Pageable pageable);

// ‚ùå Bad - Unnecessary count for infinite scroll
Page<User> findByStatus(String status, Pageable pageable);
```

### 2. Set Maximum Page Size

```java
// ‚úÖ Good - Prevent abuse
@GetMapping
public Page<User> getUsers(
    @PageableDefault(size = 20, sort = "id")
    @SizeLimit(max = 100) Pageable pageable
) {
    return userRepository.findAll(pageable);
}

// Configuration
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        PageableHandlerMethodArgumentResolver resolver = 
            new PageableHandlerMethodArgumentResolver();
        resolver.setMaxPageSize(100);
        resolvers.add(resolver);
    }
}
```

### 3. Provide Default Values

```java
// ‚úÖ Good
@GetMapping
public Page<User> getUsers(
    @PageableDefault(size = 20, sort = "createdDate", direction = Sort.Direction.DESC)
    Pageable pageable
) {
    return userRepository.findAll(pageable);
}
```

### 4. Validate Sort Properties

```java
// ‚úÖ Good - Whitelist approach
private static final Set<String> ALLOWED_SORTS = Set.of("name", "email", "createdDate");

public Page<User> getUsers(String sortBy, Pageable pageable) {
    if (!ALLOWED_SORTS.contains(sortBy)) {
        throw new IllegalArgumentException("Invalid sort property");
    }
    return userRepository.findAll(pageable);
}
```

### 5. Map to DTOs

```java
// ‚úÖ Good - Don't expose entities
public Page<UserDTO> getUsers(Pageable pageable) {
    return userRepository.findAll(pageable)
                        .map(this::toDTO);
}

// ‚ùå Bad - Exposing entities
public Page<User> getUsers(Pageable pageable) {
    return userRepository.findAll(pageable);
}
```

### 6. Add Indexes for Sorted Columns

```java
// ‚úÖ Good
@Entity
@Table(indexes = @Index(columnList = "created_date DESC"))
public class User {
    // Sorted frequently, needs index
}
```

### 7. Use Keyset for Large Offsets

```java
// ‚úÖ Good for large datasets
List<User> findByIdGreaterThan(Long id, Pageable pageable);

// ‚ùå Bad for large offsets (slow)
Page<User> findAll(Pageable pageable); // With offset 1000000
```

---

## üé§ Interview Questions

### Q1: What is Pageable?
**Answer:** Interface representing pagination information: page number, page size, and sort specification.

### Q2: Difference between Page and Slice?
**Answer:**
- **Page**: Includes total count, total pages (extra query)
- **Slice**: Only knows if next page exists (no count query, faster)

### Q3: How to create Pageable?
**Answer:**
```java
Pageable pageable = PageRequest.of(page, size);
Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
```

### Q4: Is pagination 0-indexed or 1-indexed?
**Answer:** 0-indexed by default (first page is 0). Can configure to 1-indexed.

### Q5: How to sort in multiple directions?
**Answer:**
```java
Sort sort = Sort.by("name").ascending()
                .and(Sort.by("age").descending());
```

### Q6: What is unpaged()?
**Answer:** Returns all records without pagination:
```java
Pageable unpaged = Pageable.unpaged();
```

### Q7: How to map Page to DTO?
**Answer:**
```java
Page<UserDTO> dtoPage = userPage.map(user -> new UserDTO(user));
```

### Q8: Can you paginate @Query methods?
**Answer:** Yes, add Pageable parameter:
```java
@Query("SELECT u FROM User u WHERE u.status = :status")
Page<User> find(@Param("status") String status, Pageable pageable);
```

### Q9: What is the performance issue with Page?
**Answer:** Executes additional COUNT query to get total elements, which can be expensive for large tables.

### Q10: How to optimize pagination for large datasets?
**Answer:**
1. Use Slice instead of Page
2. Use keyset pagination
3. Add indexes on sorted columns
4. Optimize count query

### Q11: What is keyset pagination?
**Answer:** Using last record's ID instead of offset for better performance:
```java
SELECT * FROM users WHERE id > :lastId ORDER BY id LIMIT 20
```

### Q12: How to handle nested property sorting?
**Answer:**
```java
Sort.by("address.city")
```

### Q13: What is null handling in Sort?
**Answer:**
```java
Sort.Order.asc("name").nullsFirst()  // Nulls first
Sort.Order.desc("age").nullsLast()   // Nulls last
```

### Q14: Can you paginate native queries?
**Answer:** Yes, provide count query:
```java
@Query(value = "SELECT * FROM users",
       countQuery = "SELECT COUNT(*) FROM users",
       nativeQuery = true)
Page<User> findAll(Pageable pageable);
```

### Q15: What is @PageableDefault?
**Answer:** Sets default pagination parameters:
```java
@PageableDefault(size = 20, sort = "id")
Pageable pageable
```

### Q16: How to limit maximum page size?
**Answer:** Configure PageableHandlerMethodArgumentResolver:
```java
resolver.setMaxPageSize(100);
```

### Q17: Can you sort by calculated field?
**Answer:** Not directly. Use @Query with JPQL expression or database function.

### Q18: What is ignoreCase in Sort?
**Answer:** Case-insensitive sorting:
```java
Sort.Order.asc("name").ignoreCase()
```

### Q19: How to implement infinite scroll?
**Answer:** Use Slice and load more when hasNext() is true.

### Q20: Best practice for REST pagination?
**Answer:**
- Use DTOs
- Set max page size
- Provide defaults
- Validate sort properties
- Use HATEOAS links for navigation

---

## üìö Summary

### Pagination

```java
// Create Pageable
Pageable pageable = PageRequest.of(page, size);

// With sorting
Pageable pageable = PageRequest.of(page, size, Sort.by("name"));

// Use in repository
Page<User> page = userRepository.findAll(pageable);

// Page information
int totalPages = page.getTotalPages();
long totalElements = page.getTotalElements();
List<User> content = page.getContent();
boolean hasNext = page.hasNext();
```

### Sorting

```java
// Simple sort
Sort sort = Sort.by("name");

// With direction
Sort sort = Sort.by(Sort.Direction.DESC, "createdDate");

// Multiple properties
Sort sort = Sort.by("name").ascending()
                .and(Sort.by("age").descending());

// Complex sort
Sort sort = Sort.by(
    Sort.Order.asc("name").ignoreCase().nullsLast(),
    Sort.Order.desc("createdDate")
);
```

### Page vs Slice

```java
// Page - With total count
Page<User> page = repository.findAll(pageable);
long total = page.getTotalElements();

// Slice - No total count (faster)
Slice<User> slice = repository.findAll(pageable);
boolean hasNext = slice.hasNext();
```

**Next:** Specifications and Criteria API ‚Üí

