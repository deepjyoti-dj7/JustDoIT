# üîó Entity Relationships - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Relationship Types](#relationship-types)
- [@OneToOne](#onetoone)
- [@OneToMany and @ManyToOne](#onetomany-and-manytoone)
- [@ManyToMany](#manytomany)
- [Bidirectional vs Unidirectional](#bidirectional-vs-unidirectional)
- [Cascade Types](#cascade-types)
- [Fetch Types](#fetch-types)
- [Join Columns](#join-columns)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Entity Relationships** define how entities are related to each other in the database, mirroring real-world associations.

### Relationship Cardinality

- **One-to-One**: One entity relates to one other entity
- **One-to-Many**: One entity relates to many other entities
- **Many-to-One**: Many entities relate to one entity
- **Many-to-Many**: Many entities relate to many other entities

---

## üìä Relationship Types

### Overview

| Relationship | Example | Database Structure |
|--------------|---------|-------------------|
| **@OneToOne** | User ‚Üî Profile | Foreign key in either table |
| **@OneToMany** | Department ‚Üí Employees | Foreign key in "many" side |
| **@ManyToOne** | Employee ‚Üí Department | Foreign key in "many" side |
| **@ManyToMany** | Students ‚Üî Courses | Join table |

### Visual Representation

```
One-to-One:
User (id, name) ‚Üê‚Üí Profile (id, bio, user_id)

One-to-Many / Many-to-One:
Department (id, name) ‚Üê‚Üí Employee (id, name, department_id)
                           Employee (id, name, department_id)
                           Employee (id, name, department_id)

Many-to-Many:
Student (id, name) ‚Üê‚Üí student_course ‚Üê‚Üí Course (id, name)
                      (student_id, course_id)
```

---

## üë§ @OneToOne

### Unidirectional One-to-One

```java
// User entity
@Entity
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    private String email;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private UserProfile profile;
}

// UserProfile entity
@Entity
@Data
public class UserProfile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String bio;
    private String avatarUrl;
    private LocalDate dateOfBirth;
}
```

**Database Schema:**
```sql
CREATE TABLE user_profile (
    id BIGINT PRIMARY KEY,
    bio VARCHAR(255),
    avatar_url VARCHAR(255),
    date_of_birth DATE
);

CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    username VARCHAR(255),
    email VARCHAR(255),
    profile_id BIGINT UNIQUE,
    FOREIGN KEY (profile_id) REFERENCES user_profile(id)
);
```

### Bidirectional One-to-One

```java
// User entity (owning side)
@Entity
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private UserProfile profile;
}

// UserProfile entity (inverse side)
@Entity
@Data
public class UserProfile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String bio;
    
    @OneToOne(mappedBy = "profile")
    private User user;
}
```

### Shared Primary Key

```java
// User entity
@Entity
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String username;
    
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
    private UserProfile profile;
}

// UserProfile entity (shares user's ID)
@Entity
@Data
public class UserProfile {
    @Id
    private Long id;
    
    private String bio;
    
    @OneToOne
    @MapsId
    @JoinColumn(name = "id")
    private User user;
}
```

### Usage Example

```java
@Service
@Transactional
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUserWithProfile() {
        // Create profile
        UserProfile profile = new UserProfile();
        profile.setBio("Software Developer");
        profile.setAvatarUrl("https://example.com/avatar.jpg");
        
        // Create user
        User user = new User();
        user.setUsername("john_doe");
        user.setEmail("john@example.com");
        user.setProfile(profile);
        
        // Save (profile saved due to cascade)
        return userRepository.save(user);
    }
}
```

---

## üîó @OneToMany and @ManyToOne

### Unidirectional One-to-Many

```java
// Department entity
@Entity
@Data
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "department_id")
    private List<Employee> employees = new ArrayList<>();
}

// Employee entity
@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    // No reference to Department
}
```

### Bidirectional One-to-Many / Many-to-One

```java
// Department entity (One side)
@Entity
@Data
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Employee> employees = new ArrayList<>();
    
    // Helper methods
    public void addEmployee(Employee employee) {
        employees.add(employee);
        employee.setDepartment(this);
    }
    
    public void removeEmployee(Employee employee) {
        employees.remove(employee);
        employee.setDepartment(null);
    }
}

// Employee entity (Many side - owning side)
@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id")
    private Department department;
}
```

**Database Schema:**
```sql
CREATE TABLE department (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255)
);

CREATE TABLE employee (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255),
    department_id BIGINT,
    FOREIGN KEY (department_id) REFERENCES department(id)
);
```

### Usage Example

```java
@Service
@Transactional
public class DepartmentService {
    
    @Autowired
    private DepartmentRepository departmentRepository;
    
    public Department createDepartmentWithEmployees() {
        Department dept = new Department();
        dept.setName("Engineering");
        
        Employee emp1 = new Employee();
        emp1.setName("John Doe");
        emp1.setEmail("john@example.com");
        
        Employee emp2 = new Employee();
        emp2.setName("Jane Smith");
        emp2.setEmail("jane@example.com");
        
        // Use helper methods to maintain both sides
        dept.addEmployee(emp1);
        dept.addEmployee(emp2);
        
        return departmentRepository.save(dept);
    }
    
    public void removeEmployeeFromDepartment(Long deptId, Long empId) {
        Department dept = departmentRepository.findById(deptId).orElseThrow();
        Employee emp = dept.getEmployees().stream()
            .filter(e -> e.getId().equals(empId))
            .findFirst()
            .orElseThrow();
        
        dept.removeEmployee(emp);
        departmentRepository.save(dept);
    }
}
```

---

## üîÄ @ManyToMany

### Unidirectional Many-to-Many

```java
// Student entity
@Entity
@Data
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();
}

// Course entity
@Entity
@Data
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String code;
    
    // No reference to Student
}
```

### Bidirectional Many-to-Many

```java
// Student entity (owning side)
@Entity
@Data
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();
    
    // Helper methods
    public void addCourse(Course course) {
        courses.add(course);
        course.getStudents().add(this);
    }
    
    public void removeCourse(Course course) {
        courses.remove(course);
        course.getStudents().remove(this);
    }
}

// Course entity (inverse side)
@Entity
@Data
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String code;
    
    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}
```

**Database Schema:**
```sql
CREATE TABLE student (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255)
);

CREATE TABLE course (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    code VARCHAR(50)
);

CREATE TABLE student_course (
    student_id BIGINT,
    course_id BIGINT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES student(id),
    FOREIGN KEY (course_id) REFERENCES course(id)
);
```

### Many-to-Many with Extra Columns

```java
// Student entity
@Entity
@Data
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "student", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Enrollment> enrollments = new HashSet<>();
}

// Course entity
@Entity
@Data
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "course", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Enrollment> enrollments = new HashSet<>();
}

// Enrollment entity (join entity with extra fields)
@Entity
@Data
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id")
    private Student student;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "course_id")
    private Course course;
    
    private LocalDate enrollmentDate;
    private String grade;
    private Integer score;
}
```

### Usage Example

```java
@Service
@Transactional
public class StudentService {
    
    @Autowired
    private StudentRepository studentRepository;
    
    @Autowired
    private CourseRepository courseRepository;
    
    public void enrollStudentInCourses() {
        Student student = new Student();
        student.setName("John Doe");
        student.setEmail("john@example.com");
        
        Course java = new Course();
        java.setName("Java Programming");
        java.setCode("CS101");
        
        Course spring = new Course();
        spring.setName("Spring Boot");
        spring.setCode("CS201");
        
        // Enroll student in courses
        student.addCourse(java);
        student.addCourse(spring);
        
        studentRepository.save(student);
    }
}
```

---

## ‚ÜîÔ∏è Bidirectional vs Unidirectional

### Comparison

| Aspect | Unidirectional | Bidirectional |
|--------|----------------|---------------|
| **Navigation** | One direction only | Both directions |
| **Code** | Simpler | More complex |
| **Performance** | Better (fewer queries) | Can be worse |
| **Maintenance** | Easier | Need to sync both sides |
| **Use Case** | Simple relationships | Need to navigate both ways |

### Unidirectional Example

```java
// Only Department knows about Employee
@Entity
public class Department {
    @OneToMany
    private List<Employee> employees;
}

@Entity
public class Employee {
    // No reference to Department
}

// Can only go: Department ‚Üí Employee
```

### Bidirectional Example

```java
// Both know about each other
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}

@Entity
public class Employee {
    @ManyToOne
    private Department department;
}

// Can go both ways: Department ‚Üî Employee
```

### When to Use

**Unidirectional:**
- Simple relationships
- Only need one-way navigation
- Performance is critical

**Bidirectional:**
- Need to navigate both ways
- Query from either side
- More intuitive domain model

---

## üåä Cascade Types

### Cascade Operations

| Cascade Type | Description | Use Case |
|--------------|-------------|----------|
| `PERSIST` | Persist child when parent persisted | Save together |
| `MERGE` | Merge child when parent merged | Update together |
| `REMOVE` | Remove child when parent removed | Delete together |
| `REFRESH` | Refresh child when parent refreshed | Reload together |
| `DETACH` | Detach child when parent detached | Manage together |
| `ALL` | All of the above | Complete lifecycle management |

### Examples

#### CascadeType.PERSIST

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", cascade = CascadeType.PERSIST)
    private List<Employee> employees;
}

// Usage
Department dept = new Department();
Employee emp = new Employee();
dept.addEmployee(emp);

entityManager.persist(dept); // Also persists emp
```

#### CascadeType.REMOVE

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", cascade = CascadeType.REMOVE)
    private List<Employee> employees;
}

// Usage
entityManager.remove(dept); // Also removes all employees
```

#### CascadeType.ALL

```java
@Entity
public class User {
    @OneToOne(cascade = CascadeType.ALL)
    private UserProfile profile;
}

// All operations cascade to profile
```

### orphanRemoval

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", 
               cascade = CascadeType.ALL, 
               orphanRemoval = true)
    private List<Employee> employees;
}

// When employee removed from list, it's deleted from DB
dept.getEmployees().remove(emp); // emp deleted from database
```

### Cascade Best Practices

```java
// ‚úÖ Good - Cascade for composition (strong ownership)
@OneToOne(cascade = CascadeType.ALL)
private UserProfile profile;

@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
private List<OrderItem> items;

// ‚ùå Bad - Don't cascade for aggregation (shared entities)
@ManyToOne(cascade = CascadeType.ALL) // DON'T DO THIS
private Department department; // Department might be shared

// ‚úÖ Good - Selective cascade
@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
private Set<Course> courses;
```

---

## üì• Fetch Types

### FetchType.LAZY vs FetchType.EAGER

| Aspect | LAZY | EAGER |
|--------|------|-------|
| **Loading** | On-demand | Immediately |
| **Performance** | Better | Can be worse |
| **N+1 Problem** | Possible | Avoided |
| **Default (@OneToMany)** | LAZY | - |
| **Default (@ManyToOne)** | EAGER | - |
| **Default (@ManyToMany)** | LAZY | - |
| **Default (@OneToOne)** | EAGER | - |

### LAZY Loading

```java
@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List<Employee> employees; // Not loaded until accessed
}

// Usage
Department dept = deptRepository.findById(1L).get();
// Employees NOT loaded yet

List<Employee> emps = dept.getEmployees(); // NOW loaded
```

### EAGER Loading

```java
@Entity
public class Employee {
    @ManyToOne(fetch = FetchType.EAGER)
    private Department department; // Loaded immediately
}

// Usage
Employee emp = empRepository.findById(1L).get();
// Department ALREADY loaded
```

### N+1 Problem

```java
// Problem: N+1 queries
List<Department> depts = deptRepository.findAll(); // 1 query

for (Department dept : depts) {
    dept.getEmployees().size(); // N queries (one per department)
}

// Solution 1: JOIN FETCH
@Query("SELECT d FROM Department d JOIN FETCH d.employees")
List<Department> findAllWithEmployees();

// Solution 2: @EntityGraph
@EntityGraph(attributePaths = {"employees"})
List<Department> findAll();

// Solution 3: Batch fetching
@Entity
@BatchSize(size = 10)
public class Department {
    @OneToMany
    private List<Employee> employees;
}
```

### Best Practices

```java
// ‚úÖ Good - Use LAZY by default
@OneToMany(fetch = FetchType.LAZY)
@ManyToOne(fetch = FetchType.LAZY)
@ManyToMany(fetch = FetchType.LAZY)
@OneToOne(fetch = FetchType.LAZY)

// ‚ö†Ô∏è Override only when necessary
@ManyToOne(fetch = FetchType.EAGER) // Only if always needed

// ‚úÖ Good - Use JOIN FETCH for specific queries
@Query("SELECT d FROM Department d JOIN FETCH d.employees WHERE d.id = :id")
Optional<Department> findByIdWithEmployees(@Param("id") Long id);
```

---

## üîó Join Columns

### @JoinColumn

```java
@Entity
public class Employee {
    @ManyToOne
    @JoinColumn(
        name = "department_id",           // Column name in employee table
        referencedColumnName = "id",      // Column name in department table
        nullable = false,                  // NOT NULL constraint
        unique = false,                    // UNIQUE constraint
        insertable = true,                 // Include in INSERT
        updatable = true                   // Include in UPDATE
    )
    private Department department;
}
```

### @JoinTable (Many-to-Many)

```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(
        name = "student_course",                    // Join table name
        joinColumns = @JoinColumn(name = "student_id"),      // FK to Student
        inverseJoinColumns = @JoinColumn(name = "course_id") // FK to Course
    )
    private Set<Course> courses;
}
```

### Composite Join Columns

```java
@Entity
public class Employee {
    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "dept_id", referencedColumnName = "id"),
        @JoinColumn(name = "dept_code", referencedColumnName = "code")
    })
    private Department department;
}
```

---

## üìå Best Practices

### 1. Always Use Bidirectional for @OneToMany

```java
// ‚úÖ Good - Bidirectional with mappedBy
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}

@Entity
public class Employee {
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}

// ‚ùå Bad - Unidirectional @OneToMany creates extra join table
@Entity
public class Department {
    @OneToMany // Creates unnecessary join table!
    private List<Employee> employees;
}
```

### 2. Maintain Both Sides in Bidirectional

```java
// ‚úÖ Good - Helper methods maintain both sides
@Entity
public class Department {
    @OneToMany(mappedBy = "department")
    private List<Employee> employees = new ArrayList<>();
    
    public void addEmployee(Employee emp) {
        employees.add(emp);
        emp.setDepartment(this);
    }
    
    public void removeEmployee(Employee emp) {
        employees.remove(emp);
        emp.setDepartment(null);
    }
}
```

### 3. Use Set for @ManyToMany

```java
// ‚úÖ Good - Set avoids duplicates
@ManyToMany
private Set<Course> courses = new HashSet<>();

// ‚ùå Bad - List allows duplicates
@ManyToMany
private List<Course> courses = new ArrayList<>();
```

### 4. Override equals() and hashCode()

```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String email;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student student = (Student) o;
        return email != null && email.equals(student.email);
    }
    
    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
```

### 5. Use Lazy Loading by Default

```java
// ‚úÖ Good
@ManyToOne(fetch = FetchType.LAZY)
@OneToMany(fetch = FetchType.LAZY)
```

### 6. Avoid Cascade.ALL for @ManyToOne and @ManyToMany

```java
// ‚úÖ Good
@ManyToOne // No cascade for shared entities
private Department department;

@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
private Set<Course> courses;

// ‚ùå Bad
@ManyToOne(cascade = CascadeType.ALL) // Might delete shared department!
private Department department;
```

### 7. Use orphanRemoval for Composition

```java
// ‚úÖ Good - Order owns OrderItems (composition)
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
private List<OrderItem> items;

// ‚ùå Bad - Department doesn't own Employees (aggregation)
@OneToMany(mappedBy = "department", orphanRemoval = true) // Don't do this
private List<Employee> employees;
```

---

## üé§ Interview Questions

### Q1: What are the types of entity relationships?
**Answer:** @OneToOne, @OneToMany, @ManyToOne, @ManyToMany representing how entities are associated.

### Q2: Difference between @OneToMany and @ManyToOne?
**Answer:**
- **@OneToMany**: One entity has many related entities (parent side)
- **@ManyToOne**: Many entities relate to one entity (child side, owns FK)

### Q3: What is mappedBy?
**Answer:** Attribute specifying the owning side in bidirectional relationship. Non-owning side uses mappedBy:
```java
@OneToMany(mappedBy = "department")
```

### Q4: What is the owning side?
**Answer:** Side that contains the foreign key column and manages the relationship. In @OneToMany/@ManyToOne, @ManyToOne side is owning.

### Q5: How does @ManyToMany work?
**Answer:** Creates join table with foreign keys to both entities:
```java
@ManyToMany
@JoinTable(name = "student_course",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id"))
```

### Q6: What is cascade?
**Answer:** Propagates operations from parent to child:
- PERSIST, MERGE, REMOVE, REFRESH, DETACH, ALL

### Q7: Difference between CascadeType.REMOVE and orphanRemoval?
**Answer:**
- **CascadeType.REMOVE**: Removes child when parent removed
- **orphanRemoval**: Removes child when removed from collection

### Q8: What is FetchType.LAZY?
**Answer:** Loads associated entities only when accessed (on-demand), improving performance.

### Q9: What is FetchType.EAGER?
**Answer:** Loads associated entities immediately with parent entity.

### Q10: What is N+1 problem?
**Answer:** Issue where 1 query loads parents, then N queries load children (one per parent). Solved with JOIN FETCH or @EntityGraph.

### Q11: Default fetch types?
**Answer:**
- @OneToOne: EAGER
- @ManyToOne: EAGER
- @OneToMany: LAZY
- @ManyToMany: LAZY

### Q12: What is @JoinColumn?
**Answer:** Specifies foreign key column:
```java
@JoinColumn(name = "department_id")
```

### Q13: What is @JoinTable?
**Answer:** Specifies join table for @ManyToMany:
```java
@JoinTable(name = "student_course")
```

### Q14: Bidirectional vs Unidirectional?
**Answer:**
- **Unidirectional**: Relationship navigable from one side
- **Bidirectional**: Navigable from both sides

### Q15: How to maintain bidirectional relationship?
**Answer:** Use helper methods to update both sides:
```java
public void addEmployee(Employee emp) {
    employees.add(emp);
    emp.setDepartment(this);
}
```

### Q16: Can @OneToMany be unidirectional?
**Answer:** Yes, but creates extra join table. Bidirectional with @ManyToOne is better.

### Q17: How to add extra columns in @ManyToMany?
**Answer:** Create separate entity for join table:
```java
@Entity
class Enrollment {
    @ManyToOne Student student;
    @ManyToOne Course course;
    LocalDate enrollmentDate;
}
```

### Q18: What is @MapsId?
**Answer:** Shares primary key between entities in @OneToOne:
```java
@OneToOne
@MapsId
private User user; // Uses user's ID as profile's ID
```

### Q19: When to use orphanRemoval?
**Answer:** When child can't exist without parent (composition), like Order ‚Üí OrderItems.

### Q20: Best practice for @ManyToMany collection type?
**Answer:** Use Set instead of List to avoid duplicates and improve performance.

---

## üìö Summary

### Relationship Annotations

```java
// One-to-One
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "profile_id")
private UserProfile profile;

// One-to-Many (parent side)
@OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
private List<Employee> employees;

// Many-to-One (child side)
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "department_id")
private Department department;

// Many-to-Many
@ManyToMany
@JoinTable(name = "student_course",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id"))
private Set<Course> courses;
```

### Key Concepts

- **Owning Side**: Contains foreign key
- **Inverse Side**: Uses mappedBy
- **Cascade**: Propagate operations
- **Fetch Type**: LAZY (on-demand) vs EAGER (immediate)
- **orphanRemoval**: Delete when removed from collection

**Next:** JPA Repository Methods ‚Üí

