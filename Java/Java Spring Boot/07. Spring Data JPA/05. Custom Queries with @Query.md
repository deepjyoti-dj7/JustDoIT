# üìù Custom Queries with @Query - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [JPQL Queries](#jpql-queries)
- [Native SQL Queries](#native-sql-queries)
- [Named Parameters](#named-parameters)
- [Positional Parameters](#positional-parameters)
- [@Modifying Queries](#modifying-queries)
- [SpEL Expressions](#spel-expressions)
- [Named Queries](#named-queries)
- [Query By Example](#query-by-example)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**@Query** annotation allows custom JPQL or native SQL queries for complex scenarios beyond derived query methods.

### When to Use @Query

1. **Complex Queries**: Multiple joins, subqueries
2. **Performance**: Optimized queries with specific fetch strategies
3. **Aggregations**: SUM, AVG, COUNT, GROUP BY
4. **Update/Delete**: Bulk operations
5. **Native Features**: Database-specific functionality

---

## üî§ JPQL Queries

### Basic JPQL

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Simple select
    @Query("SELECT u FROM User u WHERE u.name = ?1")
    List<User> findByName(String name);
    
    // With multiple conditions
    @Query("SELECT u FROM User u WHERE u.name = ?1 AND u.email = ?2")
    List<User> findByNameAndEmail(String name, String email);
    
    // With OR
    @Query("SELECT u FROM User u WHERE u.name = ?1 OR u.email = ?1")
    List<User> findByNameOrEmail(String nameOrEmail);
}
```

### Joins

```java
// Inner join
@Query("SELECT u FROM User u JOIN u.orders o WHERE o.total > ?1")
List<User> findUsersWithHighValueOrders(BigDecimal amount);

// Left join
@Query("SELECT u FROM User u LEFT JOIN u.orders o WHERE u.status = ?1")
List<User> findByStatusWithOrders(String status);

// Fetch join (solve N+1 problem)
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = ?1")
Optional<User> findByIdWithOrders(Long id);

// Multiple joins
@Query("SELECT u FROM User u " +
       "JOIN u.department d " +
       "JOIN d.company c " +
       "WHERE c.name = ?1")
List<User> findByCompanyName(String companyName);

// Join with condition
@Query("SELECT u FROM User u " +
       "JOIN u.orders o " +
       "WHERE o.status = 'COMPLETED' AND o.total > :amount")
List<User> findUsersWithCompletedOrdersAbove(@Param("amount") BigDecimal amount);
```

### Aggregations

```java
// Count
@Query("SELECT COUNT(u) FROM User u WHERE u.status = ?1")
long countByStatus(String status);

// Sum
@Query("SELECT SUM(o.total) FROM Order o WHERE o.user.id = ?1")
BigDecimal getTotalOrderAmount(Long userId);

// Average
@Query("SELECT AVG(u.age) FROM User u")
Double getAverageAge();

// Max/Min
@Query("SELECT MAX(u.createdDate) FROM User u")
LocalDate getLatestUserCreationDate();

// Group by
@Query("SELECT u.status, COUNT(u) FROM User u GROUP BY u.status")
List<Object[]> countByEachStatus();

// Group by with having
@Query("SELECT u.department, COUNT(u) FROM User u " +
       "GROUP BY u.department " +
       "HAVING COUNT(u) > ?1")
List<Object[]> findDepartmentsWithUserCountGreaterThan(long count);
```

### Subqueries

```java
// Subquery in WHERE
@Query("SELECT u FROM User u WHERE u.age > " +
       "(SELECT AVG(u2.age) FROM User u2)")
List<User> findUsersOlderThanAverage();

// Subquery with IN
@Query("SELECT u FROM User u WHERE u.id IN " +
       "(SELECT o.user.id FROM Order o WHERE o.total > ?1)")
List<User> findUsersWithOrdersAbove(BigDecimal amount);

// Subquery with EXISTS
@Query("SELECT u FROM User u WHERE EXISTS " +
       "(SELECT o FROM Order o WHERE o.user = u AND o.status = 'PENDING')")
List<User> findUsersWithPendingOrders();

// Correlated subquery
@Query("SELECT u FROM User u WHERE u.salary > " +
       "(SELECT AVG(u2.salary) FROM User u2 WHERE u2.department = u.department)")
List<User> findUsersWithAboveAverageSalaryInDepartment();
```

### Distinct

```java
// Distinct results
@Query("SELECT DISTINCT u FROM User u JOIN u.roles r WHERE r.name = ?1")
List<User> findDistinctUsersByRoleName(String roleName);

// Distinct with count
@Query("SELECT COUNT(DISTINCT u.department) FROM User u")
long countDistinctDepartments();
```

### Constructor Expressions

```java
// DTO projection
@Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) " +
       "FROM User u WHERE u.id = ?1")
UserDTO findUserDTOById(Long id);

// With calculations
@Query("SELECT new com.example.dto.OrderSummary(o.id, o.user.name, SUM(o.total)) " +
       "FROM Order o " +
       "GROUP BY o.id, o.user.name")
List<OrderSummary> getOrderSummaries();

// DTO class
public class UserDTO {
    private Long id;
    private String name;
    private String email;
    
    public UserDTO(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
}
```

### Conditional Logic

```java
// CASE expression
@Query("SELECT u.name, " +
       "CASE WHEN u.age < 18 THEN 'Minor' " +
       "     WHEN u.age < 65 THEN 'Adult' " +
       "     ELSE 'Senior' END " +
       "FROM User u")
List<Object[]> getUsersWithAgeCategory();

// COALESCE
@Query("SELECT u.id, COALESCE(u.phone, 'No phone') FROM User u")
List<Object[]> getUsersWithPhoneOrDefault();

// NULLIF
@Query("SELECT u.name, NULLIF(u.status, 'UNKNOWN') FROM User u")
List<Object[]> getUsersWithNonUnknownStatus();
```

---

## üíæ Native SQL Queries

### Basic Native Query

```java
// Simple native query
@Query(value = "SELECT * FROM users WHERE name = ?1", nativeQuery = true)
List<User> findByNameNative(String name);

// With multiple parameters
@Query(value = "SELECT * FROM users WHERE name = ?1 AND email = ?2", 
       nativeQuery = true)
List<User> findByNameAndEmailNative(String name, String email);
```

### Complex Native Queries

```java
// Join query
@Query(value = """
    SELECT u.* FROM users u
    INNER JOIN orders o ON u.id = o.user_id
    WHERE o.total > ?1
    GROUP BY u.id
    HAVING COUNT(o.id) > ?2
    """, 
    nativeQuery = true)
List<User> findUsersWithManyHighValueOrders(BigDecimal amount, int orderCount);

// Window functions (PostgreSQL)
@Query(value = """
    SELECT u.*,
           ROW_NUMBER() OVER (PARTITION BY u.department_id ORDER BY u.salary DESC) as rank
    FROM users u
    WHERE u.active = true
    """,
    nativeQuery = true)
List<Object[]> findUsersWithDepartmentRank();

// CTE (Common Table Expression)
@Query(value = """
    WITH user_stats AS (
        SELECT user_id, COUNT(*) as order_count, SUM(total) as total_amount
        FROM orders
        GROUP BY user_id
    )
    SELECT u.*, s.order_count, s.total_amount
    FROM users u
    LEFT JOIN user_stats s ON u.id = s.user_id
    WHERE s.total_amount > ?1
    """,
    nativeQuery = true)
List<Object[]> findUsersWithOrderStats(BigDecimal minAmount);
```

### Database-Specific Features

```java
// PostgreSQL - JSONB
@Query(value = "SELECT * FROM users WHERE metadata->>'city' = ?1", 
       nativeQuery = true)
List<User> findByMetadataCity(String city);

// MySQL - Full-text search
@Query(value = "SELECT * FROM users WHERE MATCH(name, description) AGAINST(?1)", 
       nativeQuery = true)
List<User> fullTextSearch(String keyword);

// PostgreSQL - Array contains
@Query(value = "SELECT * FROM users WHERE ?1 = ANY(tags)", 
       nativeQuery = true)
List<User> findByTag(String tag);
```

### Pagination with Native Query

```java
@Query(value = "SELECT * FROM users WHERE status = :status",
       countQuery = "SELECT COUNT(*) FROM users WHERE status = :status",
       nativeQuery = true)
Page<User> findByStatusNative(@Param("status") String status, Pageable pageable);
```

---

## üè∑Ô∏è Named Parameters

### Using @Param

```java
// Named parameters (recommended)
@Query("SELECT u FROM User u WHERE u.name = :name AND u.email = :email")
List<User> findByNameAndEmail(@Param("name") String name, @Param("email") String email);

// Same parameter used multiple times
@Query("SELECT u FROM User u WHERE u.name = :keyword OR u.email LIKE %:keyword%")
List<User> searchByKeyword(@Param("keyword") String keyword);

// Collection parameter
@Query("SELECT u FROM User u WHERE u.id IN :ids")
List<User> findByIds(@Param("ids") List<Long> ids);

// Optional parameter handling
@Query("SELECT u FROM User u WHERE " +
       "(:name IS NULL OR u.name = :name) AND " +
       "(:email IS NULL OR u.email = :email)")
List<User> findByOptionalParams(@Param("name") String name, @Param("email") String email);
```

### Named Parameters in Native Queries

```java
@Query(value = "SELECT * FROM users WHERE name = :name AND email = :email",
       nativeQuery = true)
List<User> findByNameAndEmailNative(@Param("name") String name, @Param("email") String email);

// With LIKE
@Query(value = "SELECT * FROM users WHERE name LIKE CONCAT('%', :keyword, '%')",
       nativeQuery = true)
List<User> searchByNameNative(@Param("keyword") String keyword);
```

---

## üî¢ Positional Parameters

### Using ?n

```java
// Positional parameters
@Query("SELECT u FROM User u WHERE u.name = ?1 AND u.email = ?2")
List<User> findByNameAndEmail(String name, String email);

// Order matters
@Query("SELECT u FROM User u WHERE u.age BETWEEN ?1 AND ?2")
List<User> findByAgeBetween(int minAge, int maxAge);

// Native query with positional
@Query(value = "SELECT * FROM users WHERE name = ?1 AND email = ?2",
       nativeQuery = true)
List<User> findByNameAndEmailNative(String name, String email);
```

---

## ‚úèÔ∏è @Modifying Queries

### Update Queries

```java
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") String status);

@Modifying
@Query("UPDATE User u SET u.lastLoginDate = :date WHERE u.id = :id")
int updateLastLogin(@Param("id") Long id, @Param("date") LocalDate date);

// Bulk update
@Modifying
@Query("UPDATE User u SET u.active = false WHERE u.lastLoginDate < :date")
int deactivateInactiveUsers(@Param("date") LocalDate date);

// Update with calculations
@Modifying
@Query("UPDATE User u SET u.points = u.points + :points WHERE u.id = :id")
int addPoints(@Param("id") Long id, @Param("points") int points);
```

### Delete Queries

```java
@Modifying
@Query("DELETE FROM User u WHERE u.id = :id")
int deleteUser(@Param("id") Long id);

@Modifying
@Query("DELETE FROM User u WHERE u.status = :status")
int deleteByStatus(@Param("status") String status);

// Delete with condition
@Modifying
@Query("DELETE FROM User u WHERE u.active = false AND u.lastLoginDate < :date")
int deleteInactiveUsers(@Param("date") LocalDate date);
```

### Native Modifying Queries

```java
@Modifying
@Query(value = "UPDATE users SET status = :status WHERE id = :id", 
       nativeQuery = true)
int updateStatusNative(@Param("id") Long id, @Param("status") String status);

@Modifying
@Query(value = "DELETE FROM users WHERE created_date < :date", 
       nativeQuery = true)
int deleteOldUsersNative(@Param("date") LocalDate date);
```

### Usage with @Transactional

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public int activateUser(Long id) {
        return userRepository.updateStatus(id, "ACTIVE");
    }
    
    @Transactional
    public int cleanupInactiveUsers() {
        LocalDate cutoffDate = LocalDate.now().minusMonths(6);
        return userRepository.deleteInactiveUsers(cutoffDate);
    }
}
```

### clearAutomatically

```java
// Clear persistence context after execution
@Modifying(clearAutomatically = true)
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") String status);

// Flush before execution
@Modifying(flushAutomatically = true)
@Query("DELETE FROM User u WHERE u.status = :status")
int deleteByStatus(@Param("status") String status);
```

---

## üîß SpEL Expressions

### Using SpEL

```java
// Entity name
@Query("SELECT u FROM #{#entityName} u WHERE u.name = ?1")
List<User> findByName(String name);

// Custom logic in SpEL
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.name = :#{#user.name}")
    List<User> findByUserObject(@Param("user") User user);
    
    // With method call
    @Query("SELECT u FROM User u WHERE u.name = :#{#name.toUpperCase()}")
    List<User> findByNameUpperCase(@Param("name") String name);
}
```

### Dynamic Conditions

```java
@Query("SELECT u FROM User u WHERE " +
       "(:#{#filter.name} IS NULL OR u.name = :#{#filter.name}) AND " +
       "(:#{#filter.email} IS NULL OR u.email = :#{#filter.email}) AND " +
       "(:#{#filter.status} IS NULL OR u.status = :#{#filter.status})")
List<User> findByFilter(@Param("filter") UserFilter filter);

// Filter class
public class UserFilter {
    private String name;
    private String email;
    private String status;
    // Getters and setters
}
```

---

## üìõ Named Queries

### Define in Entity

```java
@Entity
@NamedQuery(
    name = "User.findByStatus",
    query = "SELECT u FROM User u WHERE u.status = :status"
)
@NamedQueries({
    @NamedQuery(
        name = "User.findActiveUsers",
        query = "SELECT u FROM User u WHERE u.active = true ORDER BY u.name"
    ),
    @NamedQuery(
        name = "User.countByDepartment",
        query = "SELECT COUNT(u) FROM User u WHERE u.department.id = :deptId"
    )
})
public class User {
    // Entity fields
}
```

### Use in Repository

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Spring Data JPA finds named query automatically
    List<User> findByStatus(@Param("status") String status);
    
    List<User> findActiveUsers();
    
    long countByDepartment(@Param("deptId") Long deptId);
}
```

### Named Native Queries

```java
@Entity
@NamedNativeQuery(
    name = "User.findAllNative",
    query = "SELECT * FROM users ORDER BY created_date DESC",
    resultClass = User.class
)
public class User {
    // Entity fields
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findAllNative();
}
```

---

## üîç Query By Example

### Basic QBE

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> findByExample() {
        // Create example
        User exampleUser = new User();
        exampleUser.setName("John");
        exampleUser.setStatus("ACTIVE");
        
        Example<User> example = Example.of(exampleUser);
        
        return userRepository.findAll(example);
    }
    
    // With matcher
    public List<User> findByExampleWithMatcher() {
        User exampleUser = new User();
        exampleUser.setName("john");
        
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withIgnoreCase()
            .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
        
        Example<User> example = Example.of(exampleUser, matcher);
        
        return userRepository.findAll(example);
    }
    
    // Custom matcher
    public List<User> findWithCustomMatcher() {
        User exampleUser = new User();
        exampleUser.setName("John");
        exampleUser.setEmail("john@example.com");
        
        ExampleMatcher matcher = ExampleMatcher.matching()
            .withIgnorePaths("id", "createdDate")
            .withIncludeNullValues()
            .withStringMatcher(ExampleMatcher.StringMatcher.STARTING);
        
        return userRepository.findAll(Example.of(exampleUser, matcher));
    }
}
```

---

## üìå Best Practices

### 1. Use Named Parameters

```java
// ‚úÖ Good - Clear and maintainable
@Query("SELECT u FROM User u WHERE u.name = :name AND u.email = :email")
List<User> find(@Param("name") String name, @Param("email") String email);

// ‚ùå Bad - Hard to maintain
@Query("SELECT u FROM User u WHERE u.name = ?1 AND u.email = ?2")
List<User> find(String name, String email);
```

### 2. Use JPQL for Portability

```java
// ‚úÖ Good - Database independent
@Query("SELECT u FROM User u WHERE u.name LIKE %:keyword%")
List<User> search(@Param("keyword") String keyword);

// ‚ùå Bad - Database specific (PostgreSQL)
@Query(value = "SELECT * FROM users WHERE name ILIKE %:keyword%", nativeQuery = true)
List<User> search(@Param("keyword") String keyword);
```

### 3. Use Fetch Joins to Avoid N+1

```java
// ‚úÖ Good - Single query
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
Optional<User> findByIdWithOrders(@Param("id") Long id);

// ‚ùå Bad - N+1 problem
Optional<User> findById(Long id); // Then accessing orders triggers N queries
```

### 4. Provide Count Query for Native Pagination

```java
// ‚úÖ Good - With count query
@Query(value = "SELECT * FROM users WHERE status = :status",
       countQuery = "SELECT COUNT(*) FROM users WHERE status = :status",
       nativeQuery = true)
Page<User> findByStatus(@Param("status") String status, Pageable pageable);

// ‚ùå Bad - Missing count query
@Query(value = "SELECT * FROM users WHERE status = :status", nativeQuery = true)
Page<User> findByStatus(@Param("status") String status, Pageable pageable);
```

### 5. Clear Context After Bulk Updates

```java
// ‚úÖ Good
@Modifying(clearAutomatically = true)
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") String status);

// ‚ùå Bad - Stale data in context
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") String status);
```

### 6. Use Constructor Expressions for DTOs

```java
// ‚úÖ Good - Type-safe
@Query("SELECT new com.example.dto.UserDTO(u.id, u.name) FROM User u")
List<UserDTO> findAllDTO();

// ‚ùå Bad - Requires casting
@Query("SELECT u.id, u.name FROM User u")
List<Object[]> findAllDTO();
```

### 7. Always Use @Transactional with @Modifying

```java
// ‚úÖ Good
@Transactional
public int activateUser(Long id) {
    return userRepository.updateStatus(id, "ACTIVE");
}

// ‚ùå Bad - Will throw exception
public int activateUser(Long id) {
    return userRepository.updateStatus(id, "ACTIVE");
}
```

---

## üé§ Interview Questions

### Q1: What is @Query annotation?
**Answer:** Annotation to define custom JPQL or native SQL queries on repository methods.

### Q2: Difference between JPQL and native query?
**Answer:**
- **JPQL**: Entity-based, database-independent, uses class/field names
- **Native**: Table-based, database-specific SQL, uses table/column names

### Q3: How to use native query?
**Answer:**
```java
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> find(@Param("name") String name);
```

### Q4: What is @Param?
**Answer:** Annotation to bind method parameter to named parameter in query.

### Q5: What is @Modifying?
**Answer:** Annotation for UPDATE/DELETE queries. Must be used with @Transactional.

### Q6: Why @Transactional needed with @Modifying?
**Answer:** Modifying queries change database state and require transaction context.

### Q7: What is clearAutomatically in @Modifying?
**Answer:** Clears persistence context after executing modifying query to prevent stale data.

### Q8: How to prevent N+1 problem?
**Answer:** Use JOIN FETCH in @Query:
```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();
```

### Q9: How to pass List parameter to query?
**Answer:**
```java
@Query("SELECT u FROM User u WHERE u.id IN :ids")
List<User> findByIds(@Param("ids") List<Long> ids);
```

### Q10: What is constructor expression?
**Answer:** Creating DTO in JPQL query:
```java
@Query("SELECT new com.example.UserDTO(u.id, u.name) FROM User u")
List<UserDTO> findAllDTO();
```

### Q11: Can you use named parameters in native query?
**Answer:** Yes:
```java
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> find(@Param("name") String name);
```

### Q12: How to paginate native query?
**Answer:** Provide count query:
```java
@Query(value = "SELECT * FROM users",
       countQuery = "SELECT COUNT(*) FROM users",
       nativeQuery = true)
Page<User> findAll(Pageable pageable);
```

### Q13: What are named queries?
**Answer:** Predefined queries in entity using @NamedQuery:
```java
@NamedQuery(name = "User.findByStatus", query = "SELECT u FROM User u WHERE u.status = ?1")
```

### Q14: What is SpEL in @Query?
**Answer:** Spring Expression Language for dynamic values:
```java
@Query("SELECT u FROM #{#entityName} u")
```

### Q15: Difference between ?1 and :name?
**Answer:**
- **?1**: Positional parameter (by index)
- **:name**: Named parameter (by name, recommended)

### Q16: How to use LIKE in JPQL?
**Answer:**
```java
@Query("SELECT u FROM User u WHERE u.name LIKE %:keyword%")
List<User> search(@Param("keyword") String keyword);
```

### Q17: Can @Query return Optional?
**Answer:** Yes:
```java
@Query("SELECT u FROM User u WHERE u.email = :email")
Optional<User> findByEmail(@Param("email") String email);
```

### Q18: How to aggregate in JPQL?
**Answer:**
```java
@Query("SELECT COUNT(u), AVG(u.age) FROM User u")
Object[] getStats();
```

### Q19: What is Query By Example?
**Answer:** Query using example entity instance:
```java
Example<User> example = Example.of(new User("John"));
repository.findAll(example);
```

### Q20: Can you mix JPQL and native queries?
**Answer:** No, a method can use either JPQL or native, not both. Choose based on use case.

---

## üìö Summary

### JPQL Query

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> find(@Param("name") String name);

// With join
@Query("SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
Optional<User> findWithOrders(@Param("id") Long id);

// Aggregation
@Query("SELECT COUNT(u) FROM User u WHERE u.status = :status")
long count(@Param("status") String status);
```

### Native Query

```java
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> find(@Param("name") String name);

// With pagination
@Query(value = "SELECT * FROM users",
       countQuery = "SELECT COUNT(*) FROM users",
       nativeQuery = true)
Page<User> findAll(Pageable pageable);
```

### Modifying Query

```java
@Modifying(clearAutomatically = true)
@Transactional
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int update(@Param("id") Long id, @Param("status") String status);
```

**Next:** Pagination and Sorting ‚Üí

