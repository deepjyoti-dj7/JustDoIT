# ‚ö° Database Performance Optimization - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Indexing Strategies](#indexing-strategies)
- [Query Optimization](#query-optimization)
- [N+1 Problem Solutions](#n1-problem-solutions)
- [Caching Strategies](#caching-strategies)
- [Batch Operations](#batch-operations)
- [Connection Pool Tuning](#connection-pool-tuning)
- [Database-Specific Optimizations](#database-specific-optimizations)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Database Performance Optimization** ensures fast, scalable, and efficient data access.

### Performance Metrics

| Metric | Target | Poor Performance |
|--------|--------|------------------|
| Query Time | < 100ms | > 1s |
| Throughput | > 1000 req/s | < 100 req/s |
| Connection Pool | 80% utilization | 100% exhausted |
| Cache Hit Rate | > 90% | < 50% |

### Optimization Hierarchy

```
1. Indexing (10-1000x improvement) ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
2. Query Optimization (5-50x)      ‚≠ê‚≠ê‚≠ê‚≠ê
3. Caching (2-10x)                 ‚≠ê‚≠ê‚≠ê
4. Connection Pooling (2-5x)       ‚≠ê‚≠ê
5. Hardware (1.5-2x)               ‚≠ê
```

---

## üìë Indexing Strategies

### What is an Index?

```sql
-- Without index: Full table scan (100,000 rows)
SELECT * FROM users WHERE email = 'john@example.com';
-- Scans: 100,000 rows | Time: ~500ms

-- With index: Direct lookup
CREATE INDEX idx_email ON users(email);
-- Scans: 1 row | Time: ~5ms (100x faster!)
```

### Single Column Index

```java
// Entity
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email"),
    @Index(name = "idx_username", columnList = "username")
})
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String email;
    
    private String username;
}
```

```sql
-- SQL equivalent
CREATE INDEX idx_email ON users(email);
CREATE INDEX idx_username ON users(username);
```

### Composite Index

```java
@Entity
@Table(name = "orders", indexes = {
    @Index(name = "idx_user_status", columnList = "user_id, status"),
    @Index(name = "idx_status_date", columnList = "status, created_date")
})
public class Order {
    @Id
    private Long id;
    
    private Long userId;
    private String status;
    private LocalDateTime createdDate;
}
```

**Index Usage:**
```sql
-- ‚úÖ Uses idx_user_status
SELECT * FROM orders WHERE user_id = 1 AND status = 'PENDING';

-- ‚úÖ Uses idx_user_status (prefix)
SELECT * FROM orders WHERE user_id = 1;

-- ‚ùå Does NOT use idx_user_status
SELECT * FROM orders WHERE status = 'PENDING';
```

### Unique Index

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @Column(unique = true) // Creates unique index
    private String email;
}
```

```sql
CREATE UNIQUE INDEX idx_unique_email ON users(email);
```

### Full-Text Index (MySQL)

```sql
-- Create full-text index
CREATE FULLTEXT INDEX idx_fulltext_content ON articles(title, content);

-- Query
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('spring boot' IN NATURAL LANGUAGE MODE);
```

### Index Selection Guidelines

| Query Pattern | Index Type | Example |
|--------------|------------|---------|
| Exact match | Single column | `WHERE email = ?` |
| Range query | Single column | `WHERE age > ?` |
| Multiple columns (AND) | Composite | `WHERE user_id = ? AND status = ?` |
| Sorting | Column in ORDER BY | `ORDER BY created_date` |
| Search | Full-text | `MATCH ... AGAINST` |

---

## üîç Query Optimization

### Use Specific Columns

```java
// ‚ùå Bad - Fetches all columns
@Query("SELECT u FROM User u WHERE u.status = :status")
List<User> findByStatus(String status);

// ‚úÖ Good - Fetch only needed columns
@Query("SELECT new com.example.dto.UserDTO(u.id, u.name) FROM User u WHERE u.status = :status")
List<UserDTO> findByStatus(String status);
```

### Avoid SELECT *

```sql
-- ‚ùå Bad - All columns
SELECT * FROM users WHERE status = 'ACTIVE';

-- ‚úÖ Good - Specific columns
SELECT id, name, email FROM users WHERE status = 'ACTIVE';
```

### Use Pagination

```java
// ‚úÖ Good - Paginated
@Query("SELECT u FROM User u")
Page<User> findAll(Pageable pageable);

// Usage
Pageable pageable = PageRequest.of(0, 20); // Page 0, 20 items
Page<User> users = userRepository.findAll(pageable);

// ‚ùå Bad - Fetch all
List<User> findAll(); // Could be millions of rows!
```

### Use EXISTS Instead of COUNT

```java
// ‚ùå Bad - Counts all rows
@Query("SELECT COUNT(u) > 0 FROM User u WHERE u.email = :email")
boolean existsByEmail(String email);

// ‚úÖ Good - Stops at first match
boolean existsByEmail(String email);
```

### Avoid Functions in WHERE Clause

```sql
-- ‚ùå Bad - Index not used
SELECT * FROM users WHERE LOWER(email) = 'john@example.com';

-- ‚úÖ Good - Index used
SELECT * FROM users WHERE email = 'john@example.com';
```

### Use UNION ALL Instead of UNION

```sql
-- ‚ùå Bad - Removes duplicates (expensive)
SELECT name FROM users WHERE status = 'ACTIVE'
UNION
SELECT name FROM users WHERE status = 'PENDING';

-- ‚úÖ Good - No duplicate removal
SELECT name FROM users WHERE status = 'ACTIVE'
UNION ALL
SELECT name FROM users WHERE status = 'PENDING';
```

### EXPLAIN Query Plan

```sql
EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';

-- Output:
-- id | select_type | table | type | possible_keys | key      | rows | Extra
-- 1  | SIMPLE      | users | ref  | idx_email     | idx_email| 1    | Using where
```

---

## ‚ö†Ô∏è N+1 Problem Solutions

### The N+1 Problem

```java
// ‚ùå Bad - N+1 queries
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders; // Lazy loaded
}

// Triggers N+1
List<User> users = userRepository.findAll(); // 1 query
for (User user : users) {
    user.getOrders().size(); // N queries (1 per user)
}
// Total: 1 + N queries
```

### Solution 1: JOIN FETCH

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u JOIN FETCH u.orders")
    List<User> findAllWithOrders();
}

// Single query with JOIN
```

### Solution 2: @EntityGraph

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @EntityGraph(attributePaths = {"orders"})
    List<User> findAll();
    
    @EntityGraph(attributePaths = {"orders", "orders.items"})
    List<User> findAllWithOrdersAndItems();
}
```

### Solution 3: Batch Fetching

```java
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "user")
    @BatchSize(size = 10) // Fetch 10 users' orders at once
    private List<Order> orders;
}
```

```properties
# application.properties
spring.jpa.properties.hibernate.default_batch_fetch_size=10
```

### Solution 4: DTO Projection

```java
// Fetch only needed data
@Query("SELECT new com.example.dto.UserOrderDTO(u.id, u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o " +
       "GROUP BY u.id, u.name")
List<UserOrderDTO> findUsersWithOrderCount();
```

---

## üíæ Caching Strategies

### Spring Cache Annotations

```java
@Service
public class ProductService {
    
    // Cache result
    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        return productRepository.findById(id).orElse(null);
    }
    
    // Update cache
    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        return productRepository.save(product);
    }
    
    // Evict from cache
    @CacheEvict(value = "products", key = "#id")
    public void delete(Long id) {
        productRepository.deleteById(id);
    }
}
```

### Second-Level Cache (Hibernate)

```properties
# application.properties
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.jcache.JCacheRegionFactory
spring.jpa.properties.hibernate.cache.use_query_cache=true
```

```java
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {
    @Id
    private Long id;
    private String name;
}
```

### Query Result Cache

```java
@Query("SELECT p FROM Product p WHERE p.category = :category")
@QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))
List<Product> findByCategory(@Param("category") String category);
```

### Cache Eviction Strategies

```java
@Service
public class CacheService {
    
    @Autowired
    private CacheManager cacheManager;
    
    // Evict all caches
    @Scheduled(cron = "0 0 2 * * ?") // 2 AM daily
    public void evictAllCaches() {
        cacheManager.getCacheNames()
            .forEach(cacheName -> cacheManager.getCache(cacheName).clear());
    }
    
    // Evict specific cache
    public void evictCache(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
        }
    }
}
```

---

## üì¶ Batch Operations

### Batch Insert

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public void batchInsert(List<User> users) {
        int batchSize = 50;
        
        for (int i = 0; i < users.size(); i++) {
            userRepository.save(users.get(i));
            
            if (i % batchSize == 0 && i > 0) {
                // Flush batch
                userRepository.flush();
            }
        }
    }
}
```

```properties
# application.properties
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.batch_versioned_data=true
```

### JDBC Batch Insert

```java
@Service
public class BatchService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public void batchInsert(List<User> users) {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        
        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                User user = users.get(i);
                ps.setString(1, user.getName());
                ps.setString(2, user.getEmail());
            }
            
            @Override
            public int getBatchSize() {
                return users.size();
            }
        });
    }
}
```

### Bulk Update

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Modifying
    @Query("UPDATE User u SET u.status = :newStatus WHERE u.status = :oldStatus")
    int updateStatusBulk(@Param("oldStatus") String oldStatus, 
                         @Param("newStatus") String newStatus);
}

// Usage
@Transactional
public void updateStatuses() {
    int updated = userRepository.updateStatusBulk("PENDING", "ACTIVE");
    // Single query updates all matching rows
}
```

---

## üèä Connection Pool Tuning

### HikariCP Optimization

```properties
# Optimal pool size: (core_count * 2) + disk_count
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5

# Connection timeout
spring.datasource.hikari.connection-timeout=30000

# Idle timeout
spring.datasource.hikari.idle-timeout=600000

# Max lifetime (less than DB timeout)
spring.datasource.hikari.max-lifetime=1800000

# MySQL optimizations
spring.datasource.hikari.data-source-properties.cachePrepStmts=true
spring.datasource.hikari.data-source-properties.prepStmtCacheSize=250
spring.datasource.hikari.data-source-properties.prepStmtCacheSqlLimit=2048
spring.datasource.hikari.data-source-properties.useServerPrepStmts=true
```

### Monitor Connection Pool

```java
@Component
public class PoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 30000)
    public void logPoolStats() {
        if (dataSource instanceof HikariDataSource) {
            HikariPoolMXBean pool = ((HikariDataSource) dataSource).getHikariPoolMXBean();
            
            int active = pool.getActiveConnections();
            int idle = pool.getIdleConnections();
            int total = pool.getTotalConnections();
            
            if (active > total * 0.8) {
                log.warn("Pool nearing capacity: {}/{}", active, total);
            }
        }
    }
}
```

---

## üóÑÔ∏è Database-Specific Optimizations

### MySQL Optimizations

```properties
# InnoDB settings
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# Query cache
spring.datasource.hikari.data-source-properties.useLocalSessionState=true
spring.datasource.hikari.data-source-properties.rewriteBatchedStatements=true
spring.datasource.hikari.data-source-properties.cacheResultSetMetadata=true
spring.datasource.hikari.data-source-properties.cacheServerConfiguration=true
spring.datasource.hikari.data-source-properties.elideSetAutoCommits=true
spring.datasource.hikari.data-source-properties.maintainTimeStats=false
```

### PostgreSQL Optimizations

```properties
# Dialect
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Prepared statements
spring.datasource.hikari.data-source-properties.prepareThreshold=3
spring.datasource.hikari.data-source-properties.preparedStatementCacheQueries=256
spring.datasource.hikari.data-source-properties.preparedStatementCacheSizeMiB=5

# Row fetching
spring.datasource.hikari.data-source-properties.defaultRowFetchSize=100
```

### Index Maintenance

```sql
-- MySQL: Analyze table
ANALYZE TABLE users;

-- PostgreSQL: Vacuum and analyze
VACUUM ANALYZE users;

-- Check index usage
SELECT * FROM pg_stat_user_indexes WHERE schemaname = 'public';
```

---

## üìå Best Practices

### 1. Always Use Indexes

```java
// ‚úÖ Good - Indexed column
@Entity
@Table(indexes = @Index(name = "idx_email", columnList = "email"))
public class User {
    @Column(unique = true)
    private String email;
}

// ‚ùå Bad - No index on frequently queried column
@Entity
public class User {
    private String email; // Queries will be slow!
}
```

### 2. Use Projections for Read-Only Queries

```java
// ‚úÖ Good - DTO projection
interface UserNameProjection {
    String getName();
    String getEmail();
}

List<UserNameProjection> findByStatus(String status);

// ‚ùå Bad - Full entity
List<User> findByStatus(String status);
```

### 3. Avoid Lazy Loading Traps

```java
// ‚ùå Bad - Lazy loading in loop
for (User user : users) {
    user.getOrders().size(); // N+1!
}

// ‚úÖ Good - Eager fetch
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();
```

### 4. Use Read-Only Transactions

```java
// ‚úÖ Good - Read-only optimization
@Transactional(readOnly = true)
public List<User> findAll() {
    return userRepository.findAll();
}
```

### 5. Monitor Slow Queries

```properties
# Log slow queries
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# MySQL slow query log
spring.datasource.hikari.data-source-properties.logger=com.mysql.cj.log.Slf4JLogger
spring.datasource.hikari.data-source-properties.profileSQL=true
```

### 6. Use Appropriate Fetch Types

```java
// ‚úÖ Good - Lazy for large collections
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;

// ‚úÖ Good - Eager for small, always-needed data
@ManyToOne(fetch = FetchType.EAGER)
private Category category;
```

### 7. Batch Size Configuration

```properties
# Hibernate batch size
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
```

---

## üé§ Interview Questions

### Q1: What is database indexing?
**Answer:** Data structure (B-tree, hash) that improves query performance by allowing fast data lookup, like a book index.

### Q2: When to create an index?
**Answer:** On columns used in WHERE, JOIN, ORDER BY clauses, and frequently queried fields.

### Q3: Downside of too many indexes?
**Answer:** Slower INSERT/UPDATE/DELETE operations, increased storage, index maintenance overhead.

### Q4: What is the N+1 problem?
**Answer:** 1 query fetches N entities, then N additional queries fetch related data (1 + N queries total).

### Q5: How to solve N+1 problem?
**Answer:** Use JOIN FETCH, @EntityGraph, batch fetching, or DTO projections.

### Q6: What is a composite index?
**Answer:** Index on multiple columns, useful for queries filtering on those columns together.

### Q7: Explain EXPLAIN command?
**Answer:** Shows query execution plan, including index usage, rows scanned, join types.

### Q8: What is query caching?
**Answer:** Storing query results in memory (Redis, Hibernate 2nd level cache) to avoid database hits.

### Q9: Difference between 1st and 2nd level cache?
**Answer:**
- **1st level:** Session-scoped (Hibernate), automatic
- **2nd level:** SessionFactory-scoped, manual configuration

### Q10: What is batch fetching?
**Answer:** Fetching multiple related entities in single query instead of N queries.

### Q11: How to optimize slow queries?
**Answer:**
1. Add indexes
2. Use EXPLAIN to analyze
3. Fetch only needed columns
4. Use pagination
5. Avoid functions in WHERE clause

### Q12: What is connection pool exhaustion?
**Answer:** All connections in use, new requests wait or timeout. Fix: increase pool size or fix connection leaks.

### Q13: Optimal connection pool size?
**Answer:** Formula: (core_count * 2) + disk_count. Example: 4 cores + 1 disk = 9 connections.

### Q14: What is a covering index?
**Answer:** Index containing all columns needed by query, avoiding table access.

### Q15: Difference between @Cacheable and @CachePut?
**Answer:**
- **@Cacheable:** Skip method if cached
- **@CachePut:** Always execute, update cache

### Q16: How to find unused indexes?
**Answer:** Query database statistics:
```sql
-- PostgreSQL
SELECT * FROM pg_stat_user_indexes WHERE idx_scan = 0;
```

### Q17: What is query plan?
**Answer:** Database's strategy to execute query, including index usage, join order, scan type.

### Q18: How to optimize batch inserts?
**Answer:**
1. Set `hibernate.jdbc.batch_size`
2. Use JDBC batch operations
3. Disable identity generation (use SEQUENCE)
4. Order inserts/updates

### Q19: What is read-only transaction?
**Answer:** Transaction that only reads data, enabling optimizations like disabling dirty checking.

### Q20: Best practices for performance?
**Answer:**
1. Index frequently queried columns
2. Use projections for read-only queries
3. Solve N+1 problems
4. Enable caching
5. Batch operations
6. Monitor slow queries
7. Optimize connection pool

---

## üìö Summary

### Performance Checklist

```
‚úÖ Create indexes on WHERE/JOIN columns
‚úÖ Use specific SELECT columns (not SELECT *)
‚úÖ Implement pagination for large results
‚úÖ Solve N+1 problems with JOIN FETCH
‚úÖ Enable caching for frequently accessed data
‚úÖ Use batch operations for bulk inserts/updates
‚úÖ Optimize connection pool size
‚úÖ Monitor slow queries with EXPLAIN
‚úÖ Use read-only transactions for queries
‚úÖ Configure Hibernate batch size
```

### Quick Optimization Guide

| Problem | Solution |
|---------|----------|
| Slow queries | Add indexes, use EXPLAIN |
| N+1 queries | JOIN FETCH, @EntityGraph |
| High latency | Enable caching (Redis) |
| Connection timeout | Increase pool size, fix leaks |
| Slow inserts | Batch operations, disable indexes temporarily |
| Large result sets | Use pagination, projections |

### Performance Gains

- **Indexing:** 10-1000x faster queries
- **Caching:** 2-10x faster reads
- **Batch operations:** 5-50x faster inserts
- **Connection pooling:** 2-5x faster connections

**Database Integration Module Complete!** ‚úÖ

