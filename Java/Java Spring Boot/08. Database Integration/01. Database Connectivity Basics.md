# üîå Database Connectivity Basics - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [JDBC Overview](#jdbc-overview)
- [DataSource Configuration](#datasource-configuration)
- [Connection Pooling](#connection-pooling)
- [HikariCP](#hikaricp)
- [Multiple DataSources](#multiple-datasources)
- [Database Drivers](#database-drivers)
- [Connection Testing](#connection-testing)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Database Connectivity** is the foundation of data persistence in Spring Boot applications, enabling communication between your application and databases.

### Key Concepts

1. **JDBC**: Java Database Connectivity API
2. **DataSource**: Factory for database connections
3. **Connection Pool**: Reusable connection management
4. **Driver**: Database-specific implementation

---

## üîó JDBC Overview

### JDBC Architecture

```
Application
    ‚Üì
JDBC API (java.sql.*)
    ‚Üì
JDBC Driver Manager
    ‚Üì
JDBC Driver (Database-specific)
    ‚Üì
Database
```

### Traditional JDBC Code

```java
// Without Spring Boot (manual JDBC)
public class TraditionalJdbcExample {
    
    public List<User> findAllUsers() {
        List<User> users = new ArrayList<>();
        
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        
        try {
            // 1. Load driver
            Class.forName("com.mysql.cj.jdbc.Driver");
            
            // 2. Create connection
            conn = DriverManager.getConnection(
                "jdbc:mysql://localhost:3306/mydb",
                "root",
                "password"
            );
            
            // 3. Create statement
            stmt = conn.prepareStatement("SELECT * FROM users");
            
            // 4. Execute query
            rs = stmt.executeQuery();
            
            // 5. Process results
            while (rs.next()) {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setName(rs.getString("name"));
                user.setEmail(rs.getString("email"));
                users.add(user);
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 6. Close resources
            try {
                if (rs != null) rs.close();
                if (stmt != null) stmt.close();
                if (conn != null) conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        
        return users;
    }
}
```

### Spring Boot Simplified

```java
// With Spring Boot (auto-configured)
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public List<User> findAllUsers() {
        return jdbcTemplate.query(
            "SELECT * FROM users",
            (rs, rowNum) -> {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setName(rs.getString("name"));
                user.setEmail(rs.getString("email"));
                return user;
            }
        );
    }
}
```

---

## ‚öôÔ∏è DataSource Configuration

### application.properties

```properties
# MySQL Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# PostgreSQL Configuration
# spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
# spring.datasource.username=postgres
# spring.datasource.password=password
# spring.datasource.driver-class-name=org.postgresql.Driver

# H2 Configuration (in-memory)
# spring.datasource.url=jdbc:h2:mem:testdb
# spring.datasource.driver-class-name=org.h2.Driver
# spring.datasource.username=sa
# spring.datasource.password=

# Oracle Configuration
# spring.datasource.url=jdbc:oracle:thin:@localhost:1521:orcl
# spring.datasource.username=system
# spring.datasource.password=oracle
# spring.datasource.driver-class-name=oracle.jdbc.OracleDriver

# SQL Server Configuration
# spring.datasource.url=jdbc:sqlserver://localhost:1433;databaseName=mydb
# spring.datasource.username=sa
# spring.datasource.password=password
# spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver
```

### application.yml

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
```

### Programmatic Configuration

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
}
```

### Custom DataSource

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
}
```

---

## üèä Connection Pooling

### Why Connection Pooling?

**Without Pool:**
```
Request ‚Üí Create Connection ‚Üí Execute Query ‚Üí Close Connection
(Expensive: ~100-200ms per connection)
```

**With Pool:**
```
Request ‚Üí Get Connection from Pool ‚Üí Execute Query ‚Üí Return to Pool
(Fast: ~1-5ms to get pooled connection)
```

### Benefits

1. **Performance**: Reuse existing connections
2. **Resource Management**: Limit concurrent connections
3. **Stability**: Prevent database overload
4. **Efficiency**: Reduce connection overhead

### Common Pools

| Pool | Default in Spring Boot | Performance | Features |
|------|----------------------|-------------|----------|
| HikariCP | ‚úÖ Yes (2.x+) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Fast, lightweight |
| Tomcat JDBC | ‚ùå No | ‚≠ê‚≠ê‚≠ê‚≠ê | Good for Tomcat |
| Apache DBCP2 | ‚ùå No | ‚≠ê‚≠ê‚≠ê | Mature, stable |
| C3P0 | ‚ùå No | ‚≠ê‚≠ê | Older, feature-rich |

---

## ‚ö° HikariCP

### Default Configuration

Spring Boot uses HikariCP by default (fastest connection pool).

```properties
# HikariCP is auto-configured, these are optional tuning parameters

# Pool size
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=10

# Connection timeout
spring.datasource.hikari.connection-timeout=30000

# Idle timeout
spring.datasource.hikari.idle-timeout=600000

# Max lifetime
spring.datasource.hikari.max-lifetime=1800000

# Pool name
spring.datasource.hikari.pool-name=HikariPool-MyApp

# Connection test query
spring.datasource.hikari.connection-test-query=SELECT 1

# Auto-commit
spring.datasource.hikari.auto-commit=true

# Leak detection threshold
spring.datasource.hikari.leak-detection-threshold=60000
```

### Programmatic Configuration

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        config.setUsername("root");
        config.setPassword("password");
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");
        
        // Pool configuration
        config.setMinimumIdle(5);
        config.setMaximumPoolSize(10);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);
        config.setPoolName("HikariPool-MyApp");
        
        // Performance optimizations
        config.setAutoCommit(true);
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        
        return new HikariDataSource(config);
    }
}
```

### Configuration Parameters Explained

```properties
# Minimum connections in pool (always maintained)
spring.datasource.hikari.minimum-idle=5

# Maximum connections in pool
spring.datasource.hikari.maximum-pool-size=10
# Formula: connections = ((core_count * 2) + effective_spindle_count)
# Example: 4 cores + 1 disk = (4 * 2) + 1 = 9 ‚Üí use 10

# Maximum time to wait for connection (ms)
spring.datasource.hikari.connection-timeout=30000
# Default: 30000 (30 seconds)

# Maximum time connection can sit idle (ms)
spring.datasource.hikari.idle-timeout=600000
# Default: 600000 (10 minutes)

# Maximum lifetime of connection (ms)
spring.datasource.hikari.max-lifetime=1800000
# Default: 1800000 (30 minutes)
# Should be less than database timeout

# Detect connection leaks (ms)
spring.datasource.hikari.leak-detection-threshold=60000
# Logs warning if connection held > 60 seconds
```

### Monitoring

```java
@Component
public class HikariMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void logPoolStats() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikari = (HikariDataSource) dataSource;
            HikariPoolMXBean pool = hikari.getHikariPoolMXBean();
            
            System.out.println("HikariCP Stats:");
            System.out.println("  Active Connections: " + pool.getActiveConnections());
            System.out.println("  Idle Connections: " + pool.getIdleConnections());
            System.out.println("  Total Connections: " + pool.getTotalConnections());
            System.out.println("  Threads Awaiting: " + pool.getThreadsAwaitingConnection());
        }
    }
}
```

---

## üîÄ Multiple DataSources

### Configuration

```properties
# Primary DataSource (MySQL)
spring.datasource.primary.url=jdbc:mysql://localhost:3306/db1
spring.datasource.primary.username=root
spring.datasource.primary.password=password
spring.datasource.primary.driver-class-name=com.mysql.cj.jdbc.Driver

# Secondary DataSource (PostgreSQL)
spring.datasource.secondary.url=jdbc:postgresql://localhost:5432/db2
spring.datasource.secondary.username=postgres
spring.datasource.secondary.password=password
spring.datasource.secondary.driver-class-name=org.postgresql.Driver
```

### Java Configuration

```java
@Configuration
public class DataSourceConfig {
    
    @Primary
    @Bean(name = "primaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean(name = "secondaryDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Primary
    @Bean(name = "primaryJdbcTemplate")
    public JdbcTemplate primaryJdbcTemplate(
        @Qualifier("primaryDataSource") DataSource dataSource
    ) {
        return new JdbcTemplate(dataSource);
    }
    
    @Bean(name = "secondaryJdbcTemplate")
    public JdbcTemplate secondaryJdbcTemplate(
        @Qualifier("secondaryDataSource") DataSource dataSource
    ) {
        return new JdbcTemplate(dataSource);
    }
}
```

### Usage

```java
@Repository
public class UserRepository {
    
    @Autowired
    @Qualifier("primaryJdbcTemplate")
    private JdbcTemplate primaryJdbcTemplate;
    
    @Autowired
    @Qualifier("secondaryJdbcTemplate")
    private JdbcTemplate secondaryJdbcTemplate;
    
    public List<User> findFromPrimary() {
        return primaryJdbcTemplate.query(
            "SELECT * FROM users",
            new BeanPropertyRowMapper<>(User.class)
        );
    }
    
    public List<User> findFromSecondary() {
        return secondaryJdbcTemplate.query(
            "SELECT * FROM users",
            new BeanPropertyRowMapper<>(User.class)
        );
    }
}
```

---

## üöó Database Drivers

### Maven Dependencies

```xml
<!-- MySQL -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>

<!-- PostgreSQL -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.6.0</version>
</dependency>

<!-- H2 (In-Memory) -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- Oracle -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>21.9.0.0</version>
</dependency>

<!-- SQL Server -->
<dependency>
    <groupId>com.microsoft.sqlserver</groupId>
    <artifactId>mssql-jdbc</artifactId>
    <version>12.2.0.jre11</version>
</dependency>

<!-- MariaDB -->
<dependency>
    <groupId>org.mariadb.jdbc</groupId>
    <artifactId>mariadb-java-client</artifactId>
    <version>3.1.4</version>
</dependency>
```

### JDBC URL Formats

```properties
# MySQL
jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC

# PostgreSQL
jdbc:postgresql://localhost:5432/mydb?ssl=false

# H2 (In-Memory)
jdbc:h2:mem:testdb

# H2 (File)
jdbc:h2:file:./data/mydb

# Oracle
jdbc:oracle:thin:@localhost:1521:orcl

# SQL Server
jdbc:sqlserver://localhost:1433;databaseName=mydb;encrypt=false

# MariaDB
jdbc:mariadb://localhost:3306/mydb
```

---

## üß™ Connection Testing

### Test Connection on Startup

```java
@Component
public class DatabaseConnectionTest implements CommandLineRunner {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public void run(String... args) {
        try (Connection connection = dataSource.getConnection()) {
            DatabaseMetaData metaData = connection.getMetaData();
            
            System.out.println("Database Connection Successful!");
            System.out.println("Database: " + metaData.getDatabaseProductName());
            System.out.println("Version: " + metaData.getDatabaseProductVersion());
            System.out.println("Driver: " + metaData.getDriverName());
            System.out.println("Driver Version: " + metaData.getDriverVersion());
            System.out.println("URL: " + metaData.getURL());
            System.out.println("Username: " + metaData.getUserName());
            
        } catch (SQLException e) {
            System.err.println("Database Connection Failed!");
            e.printStackTrace();
        }
    }
}
```

### Health Check Endpoint

```java
@RestController
@RequestMapping("/api/health")
public class DatabaseHealthController {
    
    @Autowired
    private DataSource dataSource;
    
    @GetMapping("/database")
    public ResponseEntity<Map<String, Object>> checkDatabase() {
        Map<String, Object> response = new HashMap<>();
        
        try (Connection connection = dataSource.getConnection()) {
            response.put("status", "UP");
            response.put("database", connection.getMetaData().getDatabaseProductName());
            response.put("version", connection.getMetaData().getDatabaseProductVersion());
            response.put("timestamp", LocalDateTime.now());
            
            return ResponseEntity.ok(response);
            
        } catch (SQLException e) {
            response.put("status", "DOWN");
            response.put("error", e.getMessage());
            response.put("timestamp", LocalDateTime.now());
            
            return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
        }
    }
}
```

### Spring Boot Actuator

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```properties
# Enable health endpoints
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=always
```

Access: `http://localhost:8080/actuator/health`

---

## üìå Best Practices

### 1. Use Connection Pooling Always

```properties
# ‚úÖ Good - HikariCP (default)
spring.datasource.hikari.maximum-pool-size=10

# ‚ùå Bad - No pooling
# Don't disable connection pooling in production
```

### 2. Configure Pool Size Appropriately

```properties
# ‚úÖ Good - Reasonable size
spring.datasource.hikari.maximum-pool-size=10
# Formula: (core_count * 2) + effective_spindle_count

# ‚ùå Bad - Too large
spring.datasource.hikari.maximum-pool-size=1000
# Can overwhelm database
```

### 3. Externalize Database Credentials

```properties
# ‚úÖ Good - Environment variables
spring.datasource.url=${DB_URL}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}

# ‚ùå Bad - Hardcoded
spring.datasource.password=mypassword123
```

### 4. Use Appropriate Driver

```xml
<!-- ‚úÖ Good - Latest stable version -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>

<!-- ‚ùå Bad - Old version -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.46</version>
</dependency>
```

### 5. Configure Connection Timeouts

```properties
# ‚úÖ Good
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.max-lifetime=1800000

# ‚ùå Bad - No timeouts
# Can cause hanging connections
```

### 6. Enable Connection Leak Detection

```properties
# ‚úÖ Good - Detect leaks in development
spring.datasource.hikari.leak-detection-threshold=60000
```

### 7. Use SSL for Production

```properties
# ‚úÖ Good
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useSSL=true&requireSSL=true

# ‚ùå Bad
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useSSL=false
```

---

## üé§ Interview Questions

### Q1: What is JDBC?
**Answer:** Java Database Connectivity - API for connecting and executing queries with databases.

### Q2: What is DataSource?
**Answer:** Factory interface for creating database connections, manages connection pooling and configuration.

### Q3: Why use connection pooling?
**Answer:** Reuse connections instead of creating new ones, reducing overhead and improving performance (connection creation takes 100-200ms vs 1-5ms from pool).

### Q4: What is HikariCP?
**Answer:** Fast, lightweight JDBC connection pool. Default in Spring Boot 2.x+. Fastest performance compared to other pools.

### Q5: How to configure multiple DataSources?
**Answer:**
```java
@Primary
@Bean
@ConfigurationProperties(prefix = "spring.datasource.primary")
public DataSource primaryDataSource() { ... }

@Bean
@ConfigurationProperties(prefix = "spring.datasource.secondary")
public DataSource secondaryDataSource() { ... }
```

### Q6: What is optimal pool size?
**Answer:** Formula: `(core_count * 2) + effective_spindle_count`. Example: 4 cores + 1 disk = 9-10 connections.

### Q7: Difference between minimum-idle and maximum-pool-size?
**Answer:**
- **minimum-idle**: Minimum connections always maintained
- **maximum-pool-size**: Maximum connections allowed

### Q8: What is connection timeout?
**Answer:** Maximum time to wait for available connection from pool. Default: 30 seconds.

### Q9: What is max-lifetime?
**Answer:** Maximum time a connection can live in pool. Should be less than database timeout to prevent stale connections.

### Q10: What is leak-detection-threshold?
**Answer:** Time threshold to detect connection leaks. Logs warning if connection held longer than threshold.

### Q11: How to test database connection?
**Answer:**
```java
try (Connection conn = dataSource.getConnection()) {
    DatabaseMetaData metaData = conn.getMetaData();
    System.out.println("Connected to: " + metaData.getDatabaseProductName());
}
```

### Q12: What is DriverManager?
**Answer:** JDBC class that manages database drivers and creates connections. Used in traditional JDBC, not needed with DataSource.

### Q13: Difference between DataSource and DriverManager?
**Answer:**
- **DataSource**: Connection pooling, JNDI support, better performance
- **DriverManager**: No pooling, creates new connections, legacy approach

### Q14: What is JDBC URL?
**Answer:** Connection string specifying database type, host, port, and database name. Format: `jdbc:dbtype://host:port/database`

### Q15: How to secure database credentials?
**Answer:** Use environment variables, externalized configuration, or secret management tools (Vault, AWS Secrets Manager).

### Q16: What is @Primary annotation?
**Answer:** Indicates primary bean when multiple candidates exist. Used for default DataSource in multi-datasource setup.

### Q17: What is auto-commit?
**Answer:** Automatically commit each SQL statement. Default: true. Set false for transaction control.

### Q18: What is prepared statement cache?
**Answer:** Caches compiled SQL statements for reuse, improving performance. Configure with `cachePrepStmts=true`.

### Q19: How to monitor connection pool?
**Answer:** Use HikariPoolMXBean to get active, idle, and total connections. Or use Spring Boot Actuator metrics.

### Q20: What happens when pool is exhausted?
**Answer:** New requests wait up to `connection-timeout`, then throw SQLException if no connection available.

---

## üìö Summary

### Basic Configuration

```properties
# DataSource
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# HikariCP
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```

### Common JDBC URLs

```properties
MySQL:      jdbc:mysql://localhost:3306/mydb
PostgreSQL: jdbc:postgresql://localhost:5432/mydb
H2:         jdbc:h2:mem:testdb
Oracle:     jdbc:oracle:thin:@localhost:1521:orcl
SQL Server: jdbc:sqlserver://localhost:1433;databaseName=mydb
```

### Connection Pool Sizing

```
Optimal Size = (core_count * 2) + effective_spindle_count
Example: 4 cores + 1 disk = 9-10 connections
```

**Next:** JDBC Template ‚Üí

