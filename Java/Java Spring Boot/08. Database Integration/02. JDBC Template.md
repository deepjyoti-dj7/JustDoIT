# üõ†Ô∏è JDBC Template - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [JdbcTemplate Basics](#jdbctemplate-basics)
- [CRUD Operations](#crud-operations)
- [Query Methods](#query-methods)
- [RowMapper](#rowmapper)
- [Batch Operations](#batch-operations)
- [Named Parameters](#named-parameters)
- [Stored Procedures](#stored-procedures)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**JdbcTemplate** is Spring's central class for simplified JDBC operations, eliminating boilerplate code and handling resource management automatically.

### Benefits

1. **Simplification**: No manual resource management
2. **Exception Handling**: Converts SQLExceptions to DataAccessException
3. **Code Reduction**: 80% less code than raw JDBC
4. **Thread-Safe**: Can be shared across application
5. **Flexibility**: Full SQL control

### JdbcTemplate vs Raw JDBC

| Feature | Raw JDBC | JdbcTemplate |
|---------|----------|--------------|
| Code Lines | ~30-40 | ~3-5 |
| Resource Management | Manual | Automatic |
| Exception Handling | Checked (SQLException) | Unchecked (DataAccessException) |
| Boilerplate | High | Low |
| Type Safety | Low | Medium |

---

## üîß JdbcTemplate Basics

### Auto-Configuration

```java
// Spring Boot auto-configures JdbcTemplate
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Ready to use!
}
```

### Manual Configuration

```java
@Configuration
public class JdbcConfig {
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

### Basic Operations

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Execute update
    public int create(User user) {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        return jdbcTemplate.update(sql, user.getName(), user.getEmail());
    }
    
    // Query single result
    public User findById(Long id) {
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
    }
    
    // Query multiple results
    public List<User> findAll() {
        String sql = "SELECT * FROM users";
        return jdbcTemplate.query(sql, new UserRowMapper());
    }
    
    // Query for single value
    public long count() {
        String sql = "SELECT COUNT(*) FROM users";
        return jdbcTemplate.queryForObject(sql, Long.class);
    }
}
```

---

## üìù CRUD Operations

### Create (INSERT)

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Simple insert
    public int create(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        return jdbcTemplate.update(sql, user.getName(), user.getEmail(), user.getAge());
    }
    
    // Insert and get generated key
    public long createAndGetId(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        
        KeyHolder keyHolder = new GeneratedKeyHolder();
        
        jdbcTemplate.update(connection -> {
            PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, user.getName());
            ps.setString(2, user.getEmail());
            ps.setInt(3, user.getAge());
            return ps;
        }, keyHolder);
        
        return keyHolder.getKey().longValue();
    }
    
    // Insert with timestamp
    public int createWithTimestamp(User user) {
        String sql = "INSERT INTO users (name, email, created_date) VALUES (?, ?, ?)";
        return jdbcTemplate.update(sql, 
            user.getName(), 
            user.getEmail(), 
            new Timestamp(System.currentTimeMillis())
        );
    }
}
```

### Read (SELECT)

```java
// Find by ID
public User findById(Long id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
}

// Find all
public List<User> findAll() {
    String sql = "SELECT * FROM users ORDER BY id";
    return jdbcTemplate.query(sql, new UserRowMapper());
}

// Find with condition
public List<User> findByStatus(String status) {
    String sql = "SELECT * FROM users WHERE status = ?";
    return jdbcTemplate.query(sql, new UserRowMapper(), status);
}

// Find with multiple conditions
public List<User> findByAgeRange(int minAge, int maxAge) {
    String sql = "SELECT * FROM users WHERE age BETWEEN ? AND ?";
    return jdbcTemplate.query(sql, new UserRowMapper(), minAge, maxAge);
}

// Find with LIKE
public List<User> searchByName(String keyword) {
    String sql = "SELECT * FROM users WHERE name LIKE ?";
    return jdbcTemplate.query(sql, new UserRowMapper(), "%" + keyword + "%");
}

// Check exists
public boolean exists(Long id) {
    String sql = "SELECT COUNT(*) FROM users WHERE id = ?";
    Integer count = jdbcTemplate.queryForObject(sql, Integer.class, id);
    return count != null && count > 0;
}
```

### Update

```java
// Simple update
public int update(User user) {
    String sql = "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?";
    return jdbcTemplate.update(sql, 
        user.getName(), 
        user.getEmail(), 
        user.getAge(), 
        user.getId()
    );
}

// Partial update
public int updateEmail(Long id, String email) {
    String sql = "UPDATE users SET email = ? WHERE id = ?";
    return jdbcTemplate.update(sql, email, id);
}

// Conditional update
public int updateStatus(Long id, String status) {
    String sql = "UPDATE users SET status = ?, updated_date = ? WHERE id = ?";
    return jdbcTemplate.update(sql, status, new Timestamp(System.currentTimeMillis()), id);
}

// Bulk update
public int updateStatusForAll(String oldStatus, String newStatus) {
    String sql = "UPDATE users SET status = ? WHERE status = ?";
    return jdbcTemplate.update(sql, newStatus, oldStatus);
}
```

### Delete

```java
// Delete by ID
public int delete(Long id) {
    String sql = "DELETE FROM users WHERE id = ?";
    return jdbcTemplate.update(sql, id);
}

// Delete by condition
public int deleteByStatus(String status) {
    String sql = "DELETE FROM users WHERE status = ?";
    return jdbcTemplate.update(sql, status);
}

// Delete all
public int deleteAll() {
    String sql = "DELETE FROM users";
    return jdbcTemplate.update(sql);
}

// Soft delete
public int softDelete(Long id) {
    String sql = "UPDATE users SET deleted = true, deleted_at = ? WHERE id = ?";
    return jdbcTemplate.update(sql, new Timestamp(System.currentTimeMillis()), id);
}
```

---

## üîç Query Methods

### queryForObject

```java
// Single primitive value
public String getNameById(Long id) {
    String sql = "SELECT name FROM users WHERE id = ?";
    return jdbcTemplate.queryForObject(sql, String.class, id);
}

// Single entity
public User findById(Long id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
}

// Aggregation
public long count() {
    String sql = "SELECT COUNT(*) FROM users";
    return jdbcTemplate.queryForObject(sql, Long.class);
}

public BigDecimal getTotalSalary() {
    String sql = "SELECT SUM(salary) FROM users";
    return jdbcTemplate.queryForObject(sql, BigDecimal.class);
}
```

### query

```java
// List of entities
public List<User> findAll() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, new UserRowMapper());
}

// List with parameters
public List<User> findByStatus(String status) {
    String sql = "SELECT * FROM users WHERE status = ?";
    return jdbcTemplate.query(sql, new UserRowMapper(), status);
}

// List with lambda RowMapper
public List<User> findAllLambda() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, (rs, rowNum) -> {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        return user;
    });
}
```

### queryForList

```java
// List of Maps
public List<Map<String, Object>> findAllAsMap() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.queryForList(sql);
}

// List of single column values
public List<String> findAllNames() {
    String sql = "SELECT name FROM users";
    return jdbcTemplate.queryForList(sql, String.class);
}

public List<Long> findAllIds() {
    String sql = "SELECT id FROM users";
    return jdbcTemplate.queryForList(sql, Long.class);
}
```

### queryForMap

```java
// Single row as Map
public Map<String, Object> findByIdAsMap(Long id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    return jdbcTemplate.queryForMap(sql, id);
}
```

### execute

```java
// Execute any SQL
public void createTable() {
    String sql = "CREATE TABLE IF NOT EXISTS users (" +
                 "id BIGINT PRIMARY KEY AUTO_INCREMENT, " +
                 "name VARCHAR(100), " +
                 "email VARCHAR(100))";
    jdbcTemplate.execute(sql);
}

// Execute with callback
public void executeDDL(String sql) {
    jdbcTemplate.execute((StatementCallback<Void>) stmt -> {
        stmt.execute(sql);
        return null;
    });
}
```

---

## üó∫Ô∏è RowMapper

### Custom RowMapper Class

```java
public class UserRowMapper implements RowMapper<User> {
    
    @Override
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        user.setAge(rs.getInt("age"));
        user.setCreatedDate(rs.getTimestamp("created_date").toLocalDateTime());
        return user;
    }
}

// Usage
List<User> users = jdbcTemplate.query(sql, new UserRowMapper());
```

### Lambda RowMapper

```java
public List<User> findAll() {
    String sql = "SELECT * FROM users";
    
    return jdbcTemplate.query(sql, (rs, rowNum) -> {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        return user;
    });
}
```

### BeanPropertyRowMapper

```java
// Automatic mapping (property names must match column names)
public List<User> findAll() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(User.class));
}

// With column aliases
public List<User> findAllWithAlias() {
    String sql = "SELECT id, name, email_address AS email FROM users";
    return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(User.class));
}
```

### Reusable RowMapper

```java
@Component
public class UserRowMapper implements RowMapper<User> {
    
    @Override
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        user.setAge(rs.getInt("age"));
        user.setStatus(UserStatus.valueOf(rs.getString("status")));
        
        Timestamp createdDate = rs.getTimestamp("created_date");
        if (createdDate != null) {
            user.setCreatedDate(createdDate.toLocalDateTime());
        }
        
        return user;
    }
}

@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private UserRowMapper userRowMapper;
    
    public List<User> findAll() {
        return jdbcTemplate.query("SELECT * FROM users", userRowMapper);
    }
}
```

---

## üì¶ Batch Operations

### Batch Update

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Batch insert
    public int[] batchInsert(List<User> users) {
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        
        return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                User user = users.get(i);
                ps.setString(1, user.getName());
                ps.setString(2, user.getEmail());
                ps.setInt(3, user.getAge());
            }
            
            @Override
            public int getBatchSize() {
                return users.size();
            }
        });
    }
    
    // Batch update
    public int[] batchUpdate(List<User> users) {
        String sql = "UPDATE users SET name = ?, email = ? WHERE id = ?";
        
        return jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                User user = users.get(i);
                ps.setString(1, user.getName());
                ps.setString(2, user.getEmail());
                ps.setLong(3, user.getId());
            }
            
            @Override
            public int getBatchSize() {
                return users.size();
            }
        });
    }
    
    // Batch insert with lambda
    public int[] batchInsertLambda(List<User> users) {
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        
        List<Object[]> batchArgs = users.stream()
            .map(user -> new Object[]{user.getName(), user.getEmail(), user.getAge()})
            .collect(Collectors.toList());
        
        return jdbcTemplate.batchUpdate(sql, batchArgs);
    }
}
```

### Large Batch Processing

```java
public void processBatches(List<User> users) {
    String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
    
    int batchSize = 1000;
    
    for (int i = 0; i < users.size(); i += batchSize) {
        int end = Math.min(i + batchSize, users.size());
        List<User> batch = users.subList(i, end);
        
        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int j) throws SQLException {
                User user = batch.get(j);
                ps.setString(1, user.getName());
                ps.setString(2, user.getEmail());
            }
            
            @Override
            public int getBatchSize() {
                return batch.size();
            }
        });
    }
}
```

---

## üè∑Ô∏è Named Parameters

### NamedParameterJdbcTemplate

```java
@Repository
public class UserRepository {
    
    @Autowired
    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    
    // Insert with named parameters
    public int create(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (:name, :email, :age)";
        
        Map<String, Object> params = new HashMap<>();
        params.put("name", user.getName());
        params.put("email", user.getEmail());
        params.put("age", user.getAge());
        
        return namedParameterJdbcTemplate.update(sql, params);
    }
    
    // Query with named parameters
    public List<User> findByStatus(String status) {
        String sql = "SELECT * FROM users WHERE status = :status";
        
        Map<String, Object> params = new HashMap<>();
        params.put("status", status);
        
        return namedParameterJdbcTemplate.query(sql, params, new UserRowMapper());
    }
    
    // Using SqlParameterSource
    public int createWithSource(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (:name, :email, :age)";
        
        SqlParameterSource params = new MapSqlParameterSource()
            .addValue("name", user.getName())
            .addValue("email", user.getEmail())
            .addValue("age", user.getAge());
        
        return namedParameterJdbcTemplate.update(sql, params);
    }
    
    // BeanPropertySqlParameterSource
    public int createWithBean(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (:name, :email, :age)";
        
        SqlParameterSource params = new BeanPropertySqlParameterSource(user);
        
        return namedParameterJdbcTemplate.update(sql, params);
    }
    
    // IN clause with named parameters
    public List<User> findByIds(List<Long> ids) {
        String sql = "SELECT * FROM users WHERE id IN (:ids)";
        
        Map<String, Object> params = new HashMap<>();
        params.put("ids", ids);
        
        return namedParameterJdbcTemplate.query(sql, params, new UserRowMapper());
    }
}
```

### Configuration

```java
@Configuration
public class JdbcConfig {
    
    @Bean
    public NamedParameterJdbcTemplate namedParameterJdbcTemplate(DataSource dataSource) {
        return new NamedParameterJdbcTemplate(dataSource);
    }
}
```

---

## üîß Stored Procedures

### Calling Stored Procedures

```java
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    // Simple stored procedure
    public void callProcedure(Long userId) {
        jdbcTemplate.execute((CallableStatementCallback<Void>) cs -> {
            cs = cs.getConnection().prepareCall("{call update_user_status(?)}");
            cs.setLong(1, userId);
            cs.execute();
            return null;
        });
    }
    
    // Stored procedure with OUT parameter
    public String getUserStatus(Long userId) {
        return jdbcTemplate.execute((CallableStatementCallback<String>) cs -> {
            cs = cs.getConnection().prepareCall("{call get_user_status(?, ?)}");
            cs.setLong(1, userId);
            cs.registerOutParameter(2, Types.VARCHAR);
            cs.execute();
            return cs.getString(2);
        });
    }
    
    // Stored function
    public int calculateTotal(Long userId) {
        return jdbcTemplate.execute((CallableStatementCallback<Integer>) cs -> {
            cs = cs.getConnection().prepareCall("{? = call calculate_user_total(?)}");
            cs.registerOutParameter(1, Types.INTEGER);
            cs.setLong(2, userId);
            cs.execute();
            return cs.getInt(1);
        });
    }
}
```

### SimpleJdbcCall

```java
@Repository
public class UserRepository {
    
    private SimpleJdbcCall simpleJdbcCall;
    
    @Autowired
    public UserRepository(DataSource dataSource) {
        this.simpleJdbcCall = new SimpleJdbcCall(dataSource)
            .withProcedureName("get_user_details");
    }
    
    public Map<String, Object> getUserDetails(Long userId) {
        SqlParameterSource in = new MapSqlParameterSource()
            .addValue("user_id", userId);
        
        return simpleJdbcCall.execute(in);
    }
}
```

---

## üìå Best Practices

### 1. Reuse JdbcTemplate Instance

```java
// ‚úÖ Good - Single instance
@Repository
public class UserRepository {
    @Autowired
    private JdbcTemplate jdbcTemplate;
}

// ‚ùå Bad - Creating new instances
public void query() {
    JdbcTemplate template = new JdbcTemplate(dataSource);
}
```

### 2. Use Named Parameters for Readability

```java
// ‚úÖ Good
String sql = "SELECT * FROM users WHERE name = :name AND age = :age";
namedParameterJdbcTemplate.query(sql, params, rowMapper);

// ‚ùå Bad - Hard to maintain
String sql = "SELECT * FROM users WHERE name = ? AND age = ?";
jdbcTemplate.query(sql, rowMapper, name, age);
```

### 3. Handle EmptyResultDataAccessException

```java
// ‚úÖ Good
public User findById(Long id) {
    try {
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), id);
    } catch (EmptyResultDataAccessException e) {
        return null; // or throw custom exception
    }
}

// Better with Optional
public Optional<User> findById(Long id) {
    try {
        String sql = "SELECT * FROM users WHERE id = ?";
        return Optional.of(jdbcTemplate.queryForObject(sql, new UserRowMapper(), id));
    } catch (EmptyResultDataAccessException e) {
        return Optional.empty();
    }
}
```

### 4. Use Batch Operations for Multiple Inserts

```java
// ‚úÖ Good - Batch (1 round trip)
jdbcTemplate.batchUpdate(sql, batchArgs);

// ‚ùå Bad - Individual updates (N round trips)
for (User user : users) {
    jdbcTemplate.update(sql, user.getName(), user.getEmail());
}
```

### 5. Use Appropriate Query Method

```java
// ‚úÖ Good - queryForObject for single result
User user = jdbcTemplate.queryForObject(sql, rowMapper, id);

// ‚ùå Bad - query for single result
List<User> users = jdbcTemplate.query(sql, rowMapper, id);
User user = users.get(0);
```

### 6. Close Resources in Callbacks

```java
// ‚úÖ Good - Try-with-resources
jdbcTemplate.execute((ConnectionCallback<Void>) conn -> {
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
        ps.execute();
    }
    return null;
});
```

### 7. Use Prepared Statements (Always)

```java
// ‚úÖ Good - Parameterized (safe from SQL injection)
jdbcTemplate.update("SELECT * FROM users WHERE name = ?", name);

// ‚ùå Bad - String concatenation (SQL injection risk!)
jdbcTemplate.update("SELECT * FROM users WHERE name = '" + name + "'");
```

---

## üé§ Interview Questions

### Q1: What is JdbcTemplate?
**Answer:** Spring's central class for simplified JDBC operations, handling resource management and exception translation automatically.

### Q2: Benefits of JdbcTemplate over raw JDBC?
**Answer:**
- Automatic resource management (no try-finally)
- Exception translation (unchecked exceptions)
- 80% less boilerplate code
- Thread-safe

### Q3: How is JdbcTemplate thread-safe?
**Answer:** Stateless design - doesn't hold connections. Each operation gets connection from pool and returns it.

### Q4: Difference between update() and query()?
**Answer:**
- **update()**: For INSERT, UPDATE, DELETE (returns affected rows)
- **query()**: For SELECT (returns ResultSet mapped to objects)

### Q5: What is RowMapper?
**Answer:** Interface for mapping ResultSet rows to objects. Converts each row to entity instance.

### Q6: Difference between queryForObject and query?
**Answer:**
- **queryForObject()**: Single result, throws exception if 0 or >1 rows
- **query()**: Multiple results, returns List

### Q7: What is EmptyResultDataAccessException?
**Answer:** Thrown by queryForObject when no rows found. Should catch and handle appropriately.

### Q8: How to get generated key after insert?
**Answer:**
```java
KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(connection -> {
    PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
    // set parameters
    return ps;
}, keyHolder);
return keyHolder.getKey().longValue();
```

### Q9: What is batch update?
**Answer:** Execute multiple SQL statements in single database round trip, improving performance.

### Q10: When to use NamedParameterJdbcTemplate?
**Answer:** When using named parameters (:name) instead of positional (?), improves readability and maintainability.

### Q11: What is BeanPropertyRowMapper?
**Answer:** RowMapper that automatically maps columns to bean properties by name.

### Q12: How to handle NULL values?
**Answer:** Use `wasNull()` method or handle in RowMapper:
```java
int age = rs.getInt("age");
if (rs.wasNull()) age = 0;
```

### Q13: What is SqlParameterSource?
**Answer:** Interface for named parameter values, alternatives: MapSqlParameterSource, BeanPropertySqlParameterSource.

### Q14: How to call stored procedures?
**Answer:** Use SimpleJdbcCall or CallableStatement callback:
```java
SimpleJdbcCall call = new SimpleJdbcCall(dataSource).withProcedureName("proc_name");
```

### Q15: Difference between execute and update?
**Answer:**
- **execute()**: Generic SQL execution, returns boolean
- **update()**: DML statements, returns affected row count

### Q16: How to execute DDL statements?
**Answer:**
```java
jdbcTemplate.execute("CREATE TABLE users (...)");
```

### Q17: Can JdbcTemplate handle transactions?
**Answer:** Yes, when used with @Transactional, Spring manages transactions automatically.

### Q18: What is queryForList used for?
**Answer:** Return List of Maps or List of primitive types:
```java
List<Map<String, Object>> = jdbcTemplate.queryForList(sql);
```

### Q19: How to prevent SQL injection?
**Answer:** Always use parameterized queries with placeholders (?) or named parameters (:param), never concatenate user input.

### Q20: Performance: batch vs individual updates?
**Answer:** Batch is 10-100x faster - single round trip vs N round trips. Use batch for >10 operations.

---

## üìö Summary

### Basic CRUD

```java
// Create
jdbcTemplate.update("INSERT INTO users (name, email) VALUES (?, ?)", name, email);

// Read
User user = jdbcTemplate.queryForObject("SELECT * FROM users WHERE id = ?", rowMapper, id);
List<User> users = jdbcTemplate.query("SELECT * FROM users", rowMapper);

// Update
jdbcTemplate.update("UPDATE users SET name = ? WHERE id = ?", name, id);

// Delete
jdbcTemplate.update("DELETE FROM users WHERE id = ?", id);

// Count
long count = jdbcTemplate.queryForObject("SELECT COUNT(*) FROM users", Long.class);
```

### RowMapper

```java
// Lambda
(rs, rowNum) -> {
    User user = new User();
    user.setId(rs.getLong("id"));
    user.setName(rs.getString("name"));
    return user;
}

// BeanPropertyRowMapper
new BeanPropertyRowMapper<>(User.class)
```

### Named Parameters

```java
String sql = "SELECT * FROM users WHERE name = :name";
Map<String, Object> params = Map.of("name", "John");
namedParameterJdbcTemplate.query(sql, params, rowMapper);
```

**Next:** Spring Data JDBC ‚Üí

