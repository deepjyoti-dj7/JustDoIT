# üóÑÔ∏è Spring Data JDBC - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Setup & Configuration](#setup--configuration)
- [Entity Mapping](#entity-mapping)
- [Repository Basics](#repository-basics)
- [CRUD Operations](#crud-operations)
- [Custom Queries](#custom-queries)
- [Relationships](#relationships)
- [Aggregate Design](#aggregate-design)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Spring Data JDBC** is a simpler alternative to JPA, offering direct database access without caching, lazy loading, or dirty checking complexity.

### Spring Data JDBC vs JPA

| Feature | Spring Data JDBC | Spring Data JPA |
|---------|------------------|-----------------|
| Complexity | Low ‚≠ê‚≠ê | High ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Learning Curve | Easy | Steep |
| Session/EntityManager | ‚ùå No | ‚úÖ Yes |
| Lazy Loading | ‚ùå No | ‚úÖ Yes |
| Dirty Checking | ‚ùå No | ‚úÖ Yes |
| 1st Level Cache | ‚ùå No | ‚úÖ Yes |
| Relationships | Simple | Complex |
| Performance Predictable | ‚úÖ Yes | ‚ùå No (N+1 issues) |
| Use Case | Simple CRUD, Microservices | Complex domain models |

### Key Differences

```java
// JPA Entity (Complex)
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private Set<Order> orders;
    // ... getters/setters
}

// Spring Data JDBC Entity (Simple)
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    
    @MappedCollection(idColumn = "user_id")
    private Set<Order> orders;
    // ... getters/setters
}
```

---

## ‚öôÔ∏è Setup & Configuration

### Maven Dependencies

```xml
<dependencies>
    <!-- Spring Data JDBC -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jdbc</artifactId>
    </dependency>
    
    <!-- Database Driver (example: MySQL) -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    
    <!-- Optional: For migrations -->
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>
</dependencies>
```

### Application Properties

```properties
# DataSource
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password

# Spring Data JDBC
spring.data.jdbc.repositories.enabled=true

# SQL Logging
logging.level.org.springframework.jdbc=DEBUG
```

### Enable Spring Data JDBC

```java
@SpringBootApplication
@EnableJdbcRepositories
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

---

## üó∫Ô∏è Entity Mapping

### Basic Entity

```java
import org.springframework.data.annotation.*;
import org.springframework.data.relational.core.mapping.*;

@Table("users")
public class User {
    
    @Id
    private Long id;
    
    private String name;
    private String email;
    private Integer age;
    
    @CreatedDate
    private LocalDateTime createdDate;
    
    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
    
    // Constructors
    public User() {}
    
    public User(String name, String email, Integer age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    // Getters and Setters
}
```

### Column Mapping

```java
@Table("users")
public class User {
    
    @Id
    private Long id;
    
    @Column("user_name")
    private String name;
    
    @Column("email_address")
    private String email;
    
    // Snake case to camel case (automatic)
    private String firstName;  // Maps to first_name
    private String lastName;   // Maps to last_name
}
```

### Transient Fields

```java
@Table("users")
public class User {
    
    @Id
    private Long id;
    
    private String name;
    
    @Transient
    private String fullName; // Not persisted to database
    
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

### Immutable Entities (Recommended)

```java
@Table("users")
public class User {
    
    @Id
    private final Long id;
    private final String name;
    private final String email;
    
    // Constructor-based creation
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Only getters, no setters
    public Long getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
    
    // Wither methods for updates
    public User withName(String newName) {
        return new User(this.id, newName, this.email);
    }
}
```

### Enums

```java
@Table("users")
public class User {
    
    @Id
    private Long id;
    
    private String name;
    
    // Stored as String
    private UserStatus status;
    
    public enum UserStatus {
        ACTIVE, INACTIVE, SUSPENDED
    }
}
```

---

## üì¶ Repository Basics

### CrudRepository

```java
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    // Inherited methods:
    // save(entity), saveAll(entities)
    // findById(id), findAll(), findAllById(ids)
    // existsById(id), count()
    // deleteById(id), delete(entity), deleteAll()
}
```

### PagingAndSortingRepository

```java
import org.springframework.data.repository.PagingAndSortingRepository;

@Repository
public interface UserRepository extends PagingAndSortingRepository<User, Long> {
    // Inherited methods:
    // findAll(Sort)
    // findAll(Pageable)
}
```

### Combined Repository

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long>, 
                                        PagingAndSortingRepository<User, Long> {
    // Custom query methods
    List<User> findByName(String name);
}
```

---

## üìù CRUD Operations

### Create

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Save single
    public User create(User user) {
        return userRepository.save(user);
    }
    
    // Save multiple
    public List<User> createAll(List<User> users) {
        return (List<User>) userRepository.saveAll(users);
    }
    
    // Insert vs Update
    public User createOrUpdate(User user) {
        // If id is null -> INSERT
        // If id exists -> UPDATE
        return userRepository.save(user);
    }
}
```

### Read

```java
// Find by ID
public Optional<User> findById(Long id) {
    return userRepository.findById(id);
}

// Find all
public List<User> findAll() {
    return (List<User>) userRepository.findAll();
}

// Find all by IDs
public List<User> findByIds(List<Long> ids) {
    return (List<User>) userRepository.findAllById(ids);
}

// Check exists
public boolean exists(Long id) {
    return userRepository.existsById(id);
}

// Count
public long count() {
    return userRepository.count();
}
```

### Update

```java
// Update entity
public User update(User user) {
    // Deletes old record and inserts new one (not true UPDATE)
    return userRepository.save(user);
}

// Update specific field
public User updateName(Long id, String newName) {
    User user = userRepository.findById(id)
        .orElseThrow(() -> new RuntimeException("User not found"));
    
    // For immutable entities
    User updated = user.withName(newName);
    return userRepository.save(updated);
}
```

### Delete

```java
// Delete by ID
public void delete(Long id) {
    userRepository.deleteById(id);
}

// Delete entity
public void delete(User user) {
    userRepository.delete(user);
}

// Delete all by IDs
public void deleteByIds(List<Long> ids) {
    userRepository.deleteAllById(ids);
}

// Delete all
public void deleteAll() {
    userRepository.deleteAll();
}
```

---

## üîç Custom Queries

### Query Methods (Derived Queries)

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    
    // Find by single field
    List<User> findByName(String name);
    
    // Find by multiple fields
    List<User> findByNameAndAge(String name, Integer age);
    
    // Like query
    List<User> findByNameContaining(String keyword);
    List<User> findByNameStartingWith(String prefix);
    List<User> findByNameEndingWith(String suffix);
    
    // Comparison
    List<User> findByAgeGreaterThan(Integer age);
    List<User> findByAgeLessThanEqual(Integer age);
    List<User> findByAgeBetween(Integer min, Integer max);
    
    // Ordering
    List<User> findByNameOrderByAgeDesc(String name);
    
    // Top/First
    User findFirstByOrderByIdDesc();
    List<User> findTop10ByOrderByCreatedDateDesc();
    
    // Count
    long countByStatus(String status);
    
    // Exists
    boolean existsByEmail(String email);
    
    // Delete
    long deleteByStatus(String status);
}
```

### @Query Annotation

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    
    // Simple query
    @Query("SELECT * FROM users WHERE name = :name")
    List<User> findUsersByName(@Param("name") String name);
    
    // With multiple parameters
    @Query("SELECT * FROM users WHERE age > :minAge AND age < :maxAge")
    List<User> findByAgeRange(@Param("minAge") Integer minAge, 
                              @Param("maxAge") Integer maxAge);
    
    // Projection (specific columns)
    @Query("SELECT id, name FROM users WHERE email = :email")
    UserNameProjection findNameByEmail(@Param("email") String email);
    
    // Join query
    @Query("SELECT u.* FROM users u JOIN orders o ON u.id = o.user_id WHERE o.status = :status")
    List<User> findUsersWithOrderStatus(@Param("status") String status);
    
    // Aggregation
    @Query("SELECT COUNT(*) FROM users WHERE status = :status")
    long countByStatus(@Param("status") String status);
}
```

### @Modifying Queries

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    
    @Modifying
    @Query("UPDATE users SET status = :status WHERE id = :id")
    int updateStatus(@Param("id") Long id, @Param("status") String status);
    
    @Modifying
    @Query("DELETE FROM users WHERE created_date < :date")
    int deleteOldUsers(@Param("date") LocalDateTime date);
    
    @Modifying
    @Query("UPDATE users SET login_count = login_count + 1 WHERE id = :id")
    void incrementLoginCount(@Param("id") Long id);
}

// Service usage with @Transactional
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Transactional
    public void updateUserStatus(Long id, String status) {
        userRepository.updateStatus(id, status);
    }
}
```

---

## üîó Relationships

### One-to-Many

```java
// Parent Entity
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    
    @MappedCollection(idColumn = "user_id")
    private Set<Address> addresses;
}

// Child Entity
@Table("addresses")
public class Address {
    @Id
    private Long id;
    private String street;
    private String city;
}

// SQL Schema
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100)
);

CREATE TABLE addresses (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    street VARCHAR(200),
    city VARCHAR(100),
    user_id BIGINT,  -- Foreign key
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### One-to-One

```java
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    
    // Embedded reference
    private ProfileRef profile;
}

@Table("profiles")
public class Profile {
    @Id
    private Long id;
    private String bio;
    private String avatar;
}

// Reference class
class ProfileRef {
    private Long id;
}
```

### Embedded Objects

```java
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    
    @Embedded.Nullable
    private Address address;
}

// Embedded class (not a separate table)
public class Address {
    private String street;
    private String city;
    private String zipCode;
}

// All columns in users table:
// id, name, street, city, zip_code
```

---

## üèõÔ∏è Aggregate Design

### Aggregate Root

```java
// Aggregate Root
@Table("orders")
public class Order {
    
    @Id
    private Long id;
    
    private String orderNumber;
    private LocalDateTime orderDate;
    
    // Owned by aggregate
    @MappedCollection(idColumn = "order_id")
    private Set<OrderItem> items;
    
    // Constructors, getters, methods
    
    public void addItem(OrderItem item) {
        if (items == null) {
            items = new HashSet<>();
        }
        items.add(item);
    }
}

// Part of aggregate (no separate repository)
@Table("order_items")
public class OrderItem {
    @Id
    private Long id;
    
    private String productName;
    private Integer quantity;
    private BigDecimal price;
}

// Only repository for aggregate root
@Repository
public interface OrderRepository extends CrudRepository<Order, Long> {
}
```

### Save Cascade

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    public Order createOrder() {
        Order order = new Order("ORD-001", LocalDateTime.now());
        
        // Add items
        order.addItem(new OrderItem("Product 1", 2, new BigDecimal("19.99")));
        order.addItem(new OrderItem("Product 2", 1, new BigDecimal("49.99")));
        
        // Saves order AND all items (cascade)
        return orderRepository.save(order);
    }
}
```

---

## üìå Best Practices

### 1. Use Aggregate Design

```java
// ‚úÖ Good - Aggregate root with owned entities
@Table("orders")
public class Order {
    @Id private Long id;
    
    @MappedCollection(idColumn = "order_id")
    private Set<OrderItem> items; // Owned, no separate repository
}

// ‚ùå Bad - Repository for every entity
public interface OrderItemRepository extends CrudRepository<OrderItem, Long> {
    // Violates aggregate pattern
}
```

### 2. Prefer Immutable Entities

```java
// ‚úÖ Good
public class User {
    private final Long id;
    private final String name;
    
    public User withName(String newName) {
        return new User(this.id, newName);
    }
}

// ‚ùå Bad
public class User {
    private Long id;
    private String name;
    
    public void setName(String name) {
        this.name = name;
    }
}
```

### 3. Use @Transactional for @Modifying

```java
// ‚úÖ Good
@Transactional
public void updateUser(Long id) {
    userRepository.updateStatus(id, "ACTIVE");
}

// ‚ùå Bad - No transaction
public void updateUser(Long id) {
    userRepository.updateStatus(id, "ACTIVE"); // May fail
}
```

### 4. Avoid Lazy Loading (Not Supported)

```java
// ‚úÖ Good - Fetch everything upfront
@Query("SELECT u.*, a.* FROM users u LEFT JOIN addresses a ON u.id = a.user_id WHERE u.id = :id")
User findByIdWithAddresses(@Param("id") Long id);

// ‚ùå Bad - JPA-style lazy loading (not supported)
// Spring Data JDBC loads all related entities eagerly
```

### 5. Keep Aggregates Small

```java
// ‚úÖ Good - Small aggregate
Order (root)
  ‚îî‚îÄ‚îÄ OrderItems (owned)

// ‚ùå Bad - Large aggregate
User (root)
  ‚îú‚îÄ‚îÄ Addresses
  ‚îú‚îÄ‚îÄ Orders
  ‚îÇ   ‚îî‚îÄ‚îÄ OrderItems
  ‚îî‚îÄ‚îÄ PaymentMethods
```

### 6. Use Projections for Queries

```java
// ‚úÖ Good - Only needed data
interface UserNameProjection {
    Long getId();
    String getName();
}

List<UserNameProjection> findAllProjectedBy();

// ‚ùå Bad - Fetching full entity when only name needed
List<User> findAll(); // Loads all columns
```

### 7. Explicit Column Mapping

```java
// ‚úÖ Good
@Table("users")
public class User {
    @Column("user_name")
    private String name;
}

// ‚ùå Bad - Relying on defaults can break
@Table("users")
public class User {
    private String name; // Assumes column is 'name'
}
```

---

## üé§ Interview Questions

### Q1: What is Spring Data JDBC?
**Answer:** Simpler alternative to JPA, providing direct database access without session management, lazy loading, or caching complexity.

### Q2: Key differences: Spring Data JDBC vs JPA?
**Answer:**
- No EntityManager/Session
- No lazy loading (eager by default)
- No dirty checking
- No 1st level cache
- Simpler relationship handling
- Save = DELETE + INSERT (not UPDATE)

### Q3: Does Spring Data JDBC support lazy loading?
**Answer:** No, all relationships are loaded eagerly. Plan queries carefully.

### Q4: How does save() work in Spring Data JDBC?
**Answer:** DELETE existing record (if id exists) + INSERT new record. Not a true UPDATE.

### Q5: What is an aggregate in Spring Data JDBC?
**Answer:** Domain concept where one entity (root) owns other entities, loaded/saved together. Only root has repository.

### Q6: Can you use @ManyToMany in Spring Data JDBC?
**Answer:** Not directly. Model with junction table and two @MappedCollections or use @Query.

### Q7: Difference between @Table and @Entity?
**Answer:** Spring Data JDBC uses @Table, JPA uses @Entity. @Table is simpler, no need for @Column on every field.

### Q8: How to handle soft delete?
**Answer:** Use custom @Query with @Modifying:
```java
@Modifying
@Query("UPDATE users SET deleted = true WHERE id = :id")
void softDelete(@Param("id") Long id);
```

### Q9: Does Spring Data JDBC support auditing?
**Answer:** Yes, use @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy with @EnableJdbcAuditing.

### Q10: Can you use native SQL queries?
**Answer:** Yes, all @Query methods use native SQL (not JPQL).

### Q11: How to map embedded objects?
**Answer:** Use @Embedded or @Embedded.Nullable:
```java
@Embedded.Nullable
private Address address;
```

### Q12: What is @MappedCollection?
**Answer:** Maps one-to-many relationships, specifies foreign key column in child table.

### Q13: Can you have bidirectional relationships?
**Answer:** No direct support. Spring Data JDBC follows unidirectional aggregate design.

### Q14: How to enable Spring Data JDBC?
**Answer:** Add spring-boot-starter-data-jdbc dependency, optionally @EnableJdbcRepositories (auto-enabled in Spring Boot).

### Q15: Difference between CrudRepository and JdbcRepository?
**Answer:** JdbcRepository extends CrudRepository, adds batch operations (saveAll, deleteAllById).

### Q16: Can you use Specifications like JPA?
**Answer:** No, Spring Data JDBC doesn't support Specifications. Use custom @Query methods.

### Q17: How to handle composite keys?
**Answer:** Not well supported. Workaround: create composite key class, use as @Id.

### Q18: Does Spring Data JDBC support caching?
**Answer:** No built-in caching. Use @Cacheable with Spring Cache manually.

### Q19: When to use Spring Data JDBC over JPA?
**Answer:**
- Simple CRUD operations
- Predictable performance needed
- Want to avoid JPA complexity
- Microservices with simple domain models

### Q20: Can you mix JPA and Spring Data JDBC?
**Answer:** Yes, but not recommended for same entities. Use separate entities/repositories for different persistence contexts.

---

## üìö Summary

### Quick Comparison

| Need | Use JPA | Use Spring Data JDBC |
|------|---------|---------------------|
| Simple CRUD | ‚ùå | ‚úÖ |
| Complex domain | ‚úÖ | ‚ùå |
| Lazy loading | ‚úÖ | ‚ùå |
| Predictability | ‚ùå | ‚úÖ |
| Learning curve | Hard | Easy |

### Basic Entity

```java
@Table("users")
public class User {
    @Id
    private Long id;
    private String name;
    
    @MappedCollection(idColumn = "user_id")
    private Set<Address> addresses;
}
```

### Repository

```java
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    List<User> findByName(String name);
    
    @Query("SELECT * FROM users WHERE age > :age")
    List<User> findByAgeGreaterThan(@Param("age") Integer age);
}
```

**Next:** Transaction Management ‚Üí

