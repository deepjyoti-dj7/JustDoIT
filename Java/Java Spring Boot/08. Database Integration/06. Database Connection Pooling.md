# üèä Database Connection Pooling - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [HikariCP Deep Dive](#hikaricp-deep-dive)
- [Pool Configuration](#pool-configuration)
- [Pool Monitoring](#pool-monitoring)
- [Connection Leak Detection](#connection-leak-detection)
- [Performance Tuning](#performance-tuning)
- [Troubleshooting](#troubleshooting)
- [Alternative Pools](#alternative-pools)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Connection Pooling** reuses database connections instead of creating new ones for each request, dramatically improving performance.

### Without vs With Pooling

```java
// ‚ùå Without pooling (every request)
DriverManager.getConnection(url, user, pass); // 100-200ms
// Execute query
connection.close();

// ‚úÖ With pooling (every request)
pool.getConnection(); // 1-5ms (reused connection)
// Execute query
connection.close(); // Returns to pool
```

### Performance Impact

| Connections/sec | Without Pool | With Pool | Improvement |
|----------------|--------------|-----------|-------------|
| 10 | ~2 seconds | ~50ms | **40x faster** |
| 100 | ~20 seconds | ~500ms | **40x faster** |
| 1000 | ~200 seconds | ~5 seconds | **40x faster** |

### Connection Lifecycle

```
Pool Startup
    ‚Üì
Create minimum-idle connections
    ‚Üì
Application requests connection ‚Üí Get from pool (1-5ms)
    ‚Üì
Application uses connection
    ‚Üì
Application closes connection ‚Üí Return to pool
    ‚Üì
If idle > max-lifetime ‚Üí Close & create new
```

---

## ‚ö° HikariCP Deep Dive

HikariCP is the **fastest** connection pool and **default** in Spring Boot.

### Why HikariCP?

| Feature | HikariCP | Tomcat JDBC | DBCP2 |
|---------|----------|-------------|-------|
| Speed | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| Size | 130KB | 400KB | 600KB |
| Dependencies | Zero | Few | Many |
| Bytecode | Optimized | Standard | Standard |
| Connection Testing | Fast | Medium | Slow |

### Auto-Configuration

```java
// Spring Boot auto-configures HikariCP
@SpringBootApplication
public class Application {
    // HikariCP ready to use!
}
```

### Manual Configuration

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.hikari")
    public HikariConfig hikariConfig() {
        return new HikariConfig();
    }
    
    @Bean
    public DataSource dataSource(HikariConfig hikariConfig) {
        return new HikariDataSource(hikariConfig);
    }
}
```

---

## ‚öôÔ∏è Pool Configuration

### Basic Configuration

```properties
# application.properties

# DataSource
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# HikariCP Pool Size
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=20

# Connection Timeout
spring.datasource.hikari.connection-timeout=30000

# Idle Timeout
spring.datasource.hikari.idle-timeout=600000

# Max Lifetime
spring.datasource.hikari.max-lifetime=1800000

# Pool Name
spring.datasource.hikari.pool-name=MyHikariPool
```

### Advanced Configuration

```properties
# Leak Detection
spring.datasource.hikari.leak-detection-threshold=60000

# Connection Test Query
spring.datasource.hikari.connection-test-query=SELECT 1

# Auto Commit
spring.datasource.hikari.auto-commit=true

# Read Only
spring.datasource.hikari.read-only=false

# Transaction Isolation
spring.datasource.hikari.transaction-isolation=TRANSACTION_READ_COMMITTED

# Validation Timeout
spring.datasource.hikari.validation-timeout=5000

# Initialization Fail Timeout
spring.datasource.hikari.initialization-fail-timeout=1
```

### MySQL Optimizations

```properties
# MySQL-specific optimizations
spring.datasource.hikari.data-source-properties.cachePrepStmts=true
spring.datasource.hikari.data-source-properties.prepStmtCacheSize=250
spring.datasource.hikari.data-source-properties.prepStmtCacheSqlLimit=2048
spring.datasource.hikari.data-source-properties.useServerPrepStmts=true
spring.datasource.hikari.data-source-properties.useLocalSessionState=true
spring.datasource.hikari.data-source-properties.rewriteBatchedStatements=true
spring.datasource.hikari.data-source-properties.cacheResultSetMetadata=true
spring.datasource.hikari.data-source-properties.cacheServerConfiguration=true
spring.datasource.hikari.data-source-properties.elideSetAutoCommits=true
spring.datasource.hikari.data-source-properties.maintainTimeStats=false
```

### PostgreSQL Optimizations

```properties
# PostgreSQL-specific
spring.datasource.hikari.data-source-properties.prepareThreshold=3
spring.datasource.hikari.data-source-properties.preparedStatementCacheQueries=256
spring.datasource.hikari.data-source-properties.preparedStatementCacheSizeMiB=5
spring.datasource.hikari.data-source-properties.defaultRowFetchSize=100
```

---

## üìä Pool Monitoring

### Metrics Exposure

```properties
# application.properties
management.endpoints.web.exposure.include=health,metrics,hikaricp
management.metrics.enable.hikari=true
```

### HikariPoolMXBean

```java
@Component
public class PoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 30000) // Every 30 seconds
    public void monitorPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDS = (HikariDataSource) dataSource;
            HikariPoolMXBean poolMXBean = hikariDS.getHikariPoolMXBean();
            
            log.info("Pool Stats:");
            log.info("  Active Connections: {}", poolMXBean.getActiveConnections());
            log.info("  Idle Connections: {}", poolMXBean.getIdleConnections());
            log.info("  Total Connections: {}", poolMXBean.getTotalConnections());
            log.info("  Threads Awaiting: {}", poolMXBean.getThreadsAwaitingConnection());
        }
    }
}
```

### Health Check Endpoint

```java
@Component
public class DataSourceHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up()
                    .withDetail("database", "MySQL")
                    .withDetail("validationQuery", "Connection is valid")
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
        return Health.down().build();
    }
}
```

### Micrometer Metrics

```java
@Component
public class HikariMetrics {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @Autowired
    private DataSource dataSource;
    
    @PostConstruct
    public void registerMetrics() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDS = (HikariDataSource) dataSource;
            
            Gauge.builder("hikari.connections.active", hikariDS.getHikariPoolMXBean(),
                    HikariPoolMXBean::getActiveConnections)
                .register(meterRegistry);
            
            Gauge.builder("hikari.connections.idle", hikariDS.getHikariPoolMXBean(),
                    HikariPoolMXBean::getIdleConnections)
                .register(meterRegistry);
            
            Gauge.builder("hikari.connections.total", hikariDS.getHikariPoolMXBean(),
                    HikariPoolMXBean::getTotalConnections)
                .register(meterRegistry);
        }
    }
}
```

### Prometheus Metrics

```
# Access at /actuator/prometheus

# HELP hikari_connections_active Active connections
# TYPE hikari_connections_active gauge
hikari_connections_active{pool="HikariPool-1"} 5.0

# HELP hikari_connections_idle Idle connections
# TYPE hikari_connections_idle gauge
hikari_connections_idle{pool="HikariPool-1"} 10.0

# HELP hikari_connections_total Total connections
# TYPE hikari_connections_total gauge
hikari_connections_total{pool="HikariPool-1"} 15.0
```

---

## üîç Connection Leak Detection

### Enable Leak Detection

```properties
# Warn after 60 seconds
spring.datasource.hikari.leak-detection-threshold=60000
```

### Leak Detection in Action

```java
// ‚ùå Connection leak
@Service
public class UserService {
    
    @Autowired
    private DataSource dataSource;
    
    public void badMethod() {
        try {
            Connection conn = dataSource.getConnection();
            // ... do work
            // ‚ùå Forgot to close!
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // Connection never returned to pool
        // After 60s: WARNING: Connection leak detected!
    }
}

// ‚úÖ Proper usage
@Service
public class UserService {
    
    @Autowired
    private DataSource dataSource;
    
    public void goodMethod() {
        try (Connection conn = dataSource.getConnection()) {
            // ... do work
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // ‚úÖ Auto-closed, returned to pool
    }
}
```

### Custom Leak Listener

```java
@Component
public class ConnectionLeakListener {
    
    @Autowired
    private DataSource dataSource;
    
    @PostConstruct
    public void setup() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDS = (HikariDataSource) dataSource;
            hikariDS.setLeakDetectionThreshold(30000); // 30 seconds
            
            // Custom logging
            hikariDS.getHikariPoolMXBean(); // Access MXBean for monitoring
        }
    }
}
```

---

## üöÄ Performance Tuning

### Pool Size Formula

```
connections = ((core_count * 2) + effective_spindle_count)

Examples:
- 4 cores + 1 disk = (4 * 2) + 1 = 9 connections
- 8 cores + 2 disks = (8 * 2) + 2 = 18 connections
```

### Optimal Configuration

```properties
# For most applications
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=10

# High traffic applications
spring.datasource.hikari.minimum-idle=10
spring.datasource.hikari.maximum-pool-size=20

# Read-heavy applications
spring.datasource.hikari.minimum-idle=20
spring.datasource.hikari.maximum-pool-size=50
```

### Connection Timeout Tuning

```properties
# Default: 30 seconds
spring.datasource.hikari.connection-timeout=30000

# High traffic: Fail fast
spring.datasource.hikari.connection-timeout=5000

# Low traffic: Be patient
spring.datasource.hikari.connection-timeout=60000
```

### Idle Timeout Optimization

```properties
# Keep connections alive for 10 minutes
spring.datasource.hikari.idle-timeout=600000

# Microservices: Shorter idle time
spring.datasource.hikari.idle-timeout=300000

# Long-running apps: Longer idle time
spring.datasource.hikari.idle-timeout=900000
```

### Max Lifetime Strategy

```properties
# Default: 30 minutes
spring.datasource.hikari.max-lifetime=1800000

# Must be less than database's connection timeout
# MySQL: wait_timeout=28800s (8 hours)
# Set max-lifetime to 25-28 minutes
spring.datasource.hikari.max-lifetime=1680000
```

---

## üõ†Ô∏è Troubleshooting

### Issue 1: Connection Pool Exhausted

**Symptom:**
```
java.sql.SQLTransientConnectionException: HikariPool - Connection is not available
```

**Solutions:**

```properties
# 1. Increase pool size
spring.datasource.hikari.maximum-pool-size=30

# 2. Reduce timeout
spring.datasource.hikari.connection-timeout=10000

# 3. Enable leak detection
spring.datasource.hikari.leak-detection-threshold=30000
```

### Issue 2: Connection Leaks

**Symptom:**
```
WARNING: Connection leak detected
```

**Solutions:**

```java
// ‚úÖ Always use try-with-resources
try (Connection conn = dataSource.getConnection()) {
    // work
}

// ‚úÖ Or use JdbcTemplate (auto-manages connections)
jdbcTemplate.query("SELECT * FROM users", rowMapper);
```

### Issue 3: Slow Connection Acquisition

**Symptom:**
```
Connection acquisition took more than 5000ms
```

**Solutions:**

```properties
# 1. Increase minimum idle
spring.datasource.hikari.minimum-idle=10

# 2. Check database performance
spring.datasource.hikari.connection-test-query=SELECT 1

# 3. Network latency - increase timeout
spring.datasource.hikari.connection-timeout=60000
```

### Issue 4: Too Many Connections on Database

**Symptom:**
```
ERROR: Too many connections (MySQL max_connections=151)
```

**Solutions:**

```properties
# Reduce pool size
spring.datasource.hikari.maximum-pool-size=10

# Multiple app instances:
# max_connections = instance_count * maximum-pool-size
# 151 / 10 instances = 15 connections per instance
spring.datasource.hikari.maximum-pool-size=15
```

### Issue 5: Stale Connections

**Symptom:**
```
Communications link failure
```

**Solutions:**

```properties
# Set max-lifetime less than DB timeout
spring.datasource.hikari.max-lifetime=1680000

# Enable connection testing
spring.datasource.hikari.connection-test-query=SELECT 1

# Validate on borrow
spring.datasource.hikari.validation-timeout=3000
```

---

## üîÑ Alternative Pools

### Tomcat JDBC Pool

```xml
<dependency>
    <groupId>org.apache.tomcat</groupId>
    <artifactId>tomcat-jdbc</artifactId>
</dependency>
```

```properties
spring.datasource.type=org.apache.tomcat.jdbc.pool.DataSource
spring.datasource.tomcat.max-active=20
spring.datasource.tomcat.max-idle=10
spring.datasource.tomcat.min-idle=5
```

### Apache DBCP2

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-dbcp2</artifactId>
</dependency>
```

```properties
spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource
spring.datasource.dbcp2.max-total=20
spring.datasource.dbcp2.max-idle=10
spring.datasource.dbcp2.min-idle=5
```

### C3P0

```xml
<dependency>
    <groupId>com.mchange</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.5.5</version>
</dependency>
```

```java
@Bean
public DataSource dataSource() {
    ComboPooledDataSource dataSource = new ComboPooledDataSource();
    dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
    dataSource.setUser("root");
    dataSource.setPassword("password");
    dataSource.setMinPoolSize(5);
    dataSource.setMaxPoolSize(20);
    return dataSource;
}
```

### Performance Comparison

| Pool | Avg Connection Time | Throughput | Memory |
|------|---------------------|------------|--------|
| HikariCP | 1-2ms | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Low |
| Tomcat JDBC | 2-3ms | ‚≠ê‚≠ê‚≠ê‚≠ê | Medium |
| DBCP2 | 3-5ms | ‚≠ê‚≠ê‚≠ê | Medium |
| C3P0 | 5-8ms | ‚≠ê‚≠ê | High |

---

## üìå Best Practices

### 1. Don't Over-Pool

```properties
# ‚ùå Bad - Too many connections
spring.datasource.hikari.maximum-pool-size=100

# ‚úÖ Good - Right-sized
spring.datasource.hikari.maximum-pool-size=10
```

### 2. Always Use Try-With-Resources

```java
// ‚úÖ Good
try (Connection conn = dataSource.getConnection();
     PreparedStatement ps = conn.prepareStatement(sql)) {
    // work
}

// ‚ùå Bad
Connection conn = dataSource.getConnection();
PreparedStatement ps = conn.prepareStatement(sql);
// Might leak!
```

### 3. Enable Leak Detection in Development

```properties
# application-dev.properties
spring.datasource.hikari.leak-detection-threshold=30000

# application-prod.properties
# Disable in production (performance overhead)
spring.datasource.hikari.leak-detection-threshold=0
```

### 4. Monitor Pool Metrics

```java
@Scheduled(fixedRate = 60000)
public void logPoolStats() {
    HikariPoolMXBean pool = hikariDataSource.getHikariPoolMXBean();
    
    if (pool.getActiveConnections() > pool.getTotalConnections() * 0.8) {
        log.warn("Pool nearing capacity!");
    }
}
```

### 5. Set Max Lifetime < Database Timeout

```properties
# MySQL wait_timeout = 28800s (8 hours)
# Set max-lifetime to 7 hours
spring.datasource.hikari.max-lifetime=25200000
```

### 6. Use JdbcTemplate for Connection Management

```java
// ‚úÖ Good - Automatic management
jdbcTemplate.query("SELECT * FROM users", rowMapper);

// ‚ùå Bad - Manual management
Connection conn = dataSource.getConnection();
// ... work
conn.close();
```

### 7. Configure Per Environment

```yaml
# application-dev.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 5
      leak-detection-threshold: 30000

# application-prod.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      leak-detection-threshold: 0
```

---

## üé§ Interview Questions

### Q1: What is connection pooling?
**Answer:** Reusing database connections instead of creating new ones, improving performance by 10-100x.

### Q2: Why is HikariCP the default in Spring Boot?
**Answer:** Fastest (1-2ms connection acquisition), smallest size (130KB), zero dependencies, bytecode-optimized.

### Q3: How to calculate optimal pool size?
**Answer:** Formula: `(core_count * 2) + effective_spindle_count`. Example: 4 cores + 1 disk = 9 connections.

### Q4: What is minimum-idle?
**Answer:** Minimum number of connections HikariCP maintains in the pool, even when idle.

### Q5: What is maximum-pool-size?
**Answer:** Maximum number of connections the pool can create, including active and idle.

### Q6: What is connection-timeout?
**Answer:** Maximum time (ms) to wait for connection from pool before throwing exception. Default: 30 seconds.

### Q7: What is idle-timeout?
**Answer:** Time (ms) a connection can sit idle before being removed from pool. Default: 10 minutes.

### Q8: What is max-lifetime?
**Answer:** Maximum lifetime (ms) of a connection in the pool. Should be less than database timeout. Default: 30 minutes.

### Q9: How to detect connection leaks?
**Answer:** Set `leak-detection-threshold` (e.g., 60000ms). HikariCP warns if connection not returned within threshold.

### Q10: What causes "Connection is not available" error?
**Answer:** Pool exhausted - all connections in use. Solutions: increase pool size, reduce timeout, fix leaks.

### Q11: How to monitor HikariCP?
**Answer:** Use HikariPoolMXBean or Spring Boot Actuator metrics (active/idle/total connections).

### Q12: Should you set minimum-idle = maximum-pool-size?
**Answer:** No, wastes resources. Set minimum-idle to handle typical load, maximum-pool-size for peaks.

### Q13: What is connection validation?
**Answer:** Testing if connection is alive before giving to application. Use `connection-test-query=SELECT 1`.

### Q14: HikariCP vs Tomcat JDBC Pool?
**Answer:** HikariCP faster (1-2ms vs 2-3ms), smaller, less overhead. Use HikariCP unless specific Tomcat features needed.

### Q15: Can you use multiple connection pools?
**Answer:** Yes, for multiple databases:
```java
@Bean("primaryDataSource")
public DataSource primaryDataSource() { ... }

@Bean("secondaryDataSource")
public DataSource secondaryDataSource() { ... }
```

### Q16: What is preparedStatement caching?
**Answer:** MySQL optimization: cache prepared statements to avoid re-parsing SQL. Set `cachePrepStmts=true`.

### Q17: How many connections for 5 app instances?
**Answer:** If max_connections=100, pool_size=100/5=20 per instance (leave margin for DBA connections).

### Q18: What is auto-commit?
**Answer:** Automatically commit each SQL statement. Default: true. Set false for manual transaction control.

### Q19: How to debug slow connection acquisition?
**Answer:**
1. Check pool size (increase minimum-idle)
2. Check database performance
3. Check network latency
4. Enable leak detection

### Q20: Best practices for production?
**Answer:**
1. Right-size pool (don't over-pool)
2. Set max-lifetime < DB timeout
3. Monitor metrics
4. Disable leak detection (performance)
5. Use environment-specific configs

---

## üìö Summary

### Optimal Configuration

```properties
# Pool Size (use formula: (core_count * 2) + spindle_count)
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=10

# Timeouts
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# Leak Detection (dev only)
spring.datasource.hikari.leak-detection-threshold=60000

# MySQL Optimizations
spring.datasource.hikari.data-source-properties.cachePrepStmts=true
spring.datasource.hikari.data-source-properties.prepStmtCacheSize=250
spring.datasource.hikari.data-source-properties.useServerPrepStmts=true
```

### Monitoring

```java
HikariPoolMXBean pool = hikariDataSource.getHikariPoolMXBean();
int active = pool.getActiveConnections();
int idle = pool.getIdleConnections();
int total = pool.getTotalConnections();
```

### Key Metrics

- **Active Connections**: Currently in use
- **Idle Connections**: Available in pool
- **Total Connections**: Active + Idle
- **Threads Awaiting**: Waiting for connection

**Next:** NoSQL Databases (MongoDB, Redis) ‚Üí

