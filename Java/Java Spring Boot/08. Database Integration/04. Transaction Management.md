# üîÑ Transaction Management - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [@Transactional Basics](#transactional-basics)
- [Propagation Levels](#propagation-levels)
- [Isolation Levels](#isolation-levels)
- [Rollback Rules](#rollback-rules)
- [Programmatic Transactions](#programmatic-transactions)
- [Transaction Configuration](#transaction-configuration)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Transaction Management** ensures database operations are **ACID** compliant: Atomic, Consistent, Isolated, and Durable.

### ACID Properties

| Property | Description | Example |
|----------|-------------|---------|
| **Atomicity** | All or nothing | Transfer money: debit AND credit both succeed or both fail |
| **Consistency** | Valid state to valid state | Balance cannot be negative |
| **Isolation** | Concurrent transactions don't interfere | Two users updating same record |
| **Durability** | Committed data persists | Data survives system crash |

### Why Transactions?

```java
// ‚ùå Without transaction - Partial update risk
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    accountRepository.debit(fromId, amount);  // ‚úÖ Success
    // üí• System crash here
    accountRepository.credit(toId, amount);   // ‚ùå Never executed
    // Money lost!
}

// ‚úÖ With transaction - All or nothing
@Transactional
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    accountRepository.debit(fromId, amount);  
    accountRepository.credit(toId, amount);   
    // Both succeed or both rollback
}
```

---

## üîß @Transactional Basics

### Class-Level Annotation

```java
@Service
@Transactional // Applies to all public methods
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        return userRepository.save(user); // Transactional
    }
    
    public void deleteUser(Long id) {
        userRepository.deleteById(id); // Transactional
    }
}
```

### Method-Level Annotation

```java
@Service
public class UserService {
    
    @Transactional // Only this method is transactional
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    // Not transactional
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

### Read-Only Transactions

```java
@Service
public class UserService {
    
    @Transactional(readOnly = true) // Performance optimization
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    @Transactional(readOnly = true)
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```

### Timeout Configuration

```java
@Transactional(timeout = 10) // 10 seconds
public void longRunningOperation() {
    // If exceeds 10 seconds, transaction rolls back
}
```

---

## üîÄ Propagation Levels

**Propagation** defines how transactions relate to each other when methods call other methods.

### REQUIRED (Default)

```java
@Transactional(propagation = Propagation.REQUIRED)
public void method1() {
    // Uses existing transaction or creates new one
    method2(); // Same transaction
}

@Transactional(propagation = Propagation.REQUIRED)
public void method2() {
    // Joins method1's transaction
}
```

**Use Case:** Most common, default behavior.

### REQUIRES_NEW

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void method1() {
    // Transaction 1
    method2(); // Suspends Transaction 1
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void method2() {
    // Transaction 2 (independent)
    // If fails, only this rolls back
}
```

**Use Case:** Audit logging, notifications (should succeed even if main transaction fails).

### NESTED

```java
@Transactional(propagation = Propagation.NESTED)
public void parentMethod() {
    // Parent transaction
    try {
        childMethod(); // Nested transaction (savepoint)
    } catch (Exception e) {
        // Can rollback to savepoint, continue parent
    }
}

@Transactional(propagation = Propagation.NESTED)
public void childMethod() {
    // Nested transaction (can rollback independently)
}
```

**Use Case:** Partial rollback scenarios.

### SUPPORTS

```java
@Transactional(propagation = Propagation.SUPPORTS)
public void readData() {
    // If transaction exists, joins it
    // If no transaction, executes non-transactionally
}
```

**Use Case:** Read-only operations that can work with or without transactions.

### NOT_SUPPORTED

```java
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void method() {
    // Suspends current transaction
    // Executes non-transactionally
}
```

**Use Case:** Operations that shouldn't be in transaction (e.g., file I/O).

### MANDATORY

```java
@Transactional(propagation = Propagation.MANDATORY)
public void method() {
    // Must be called within existing transaction
    // Throws exception if no transaction exists
}
```

**Use Case:** Ensure method is only called from transactional context.

### NEVER

```java
@Transactional(propagation = Propagation.NEVER)
public void method() {
    // Throws exception if transaction exists
}
```

**Use Case:** Operations that must NOT run in transaction.

### Propagation Comparison

| Propagation | Existing Transaction | No Transaction | New Transaction |
|-------------|---------------------|----------------|-----------------|
| REQUIRED | Join | Create | ‚ùå |
| REQUIRES_NEW | Suspend, Create new | Create | ‚úÖ |
| NESTED | Create savepoint | Create | ‚ùå |
| SUPPORTS | Join | Non-transactional | ‚ùå |
| NOT_SUPPORTED | Suspend | Non-transactional | ‚ùå |
| MANDATORY | Join | Exception | ‚ùå |
| NEVER | Exception | Non-transactional | ‚ùå |

---

## üîí Isolation Levels

**Isolation** defines how concurrent transactions interact.

### DEFAULT

```java
@Transactional(isolation = Isolation.DEFAULT)
public void method() {
    // Uses database default isolation level
}
```

### READ_UNCOMMITTED

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void method() {
    // Can read uncommitted changes from other transactions
    // ‚ö†Ô∏è Dirty reads possible
}
```

**Problems:** Dirty reads

### READ_COMMITTED

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void method() {
    // Only reads committed data
    // ‚ö†Ô∏è Non-repeatable reads possible
}
```

**Problems:** Non-repeatable reads

### REPEATABLE_READ

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void method() {
    // Same query returns same results
    // ‚ö†Ô∏è Phantom reads possible
}
```

**Problems:** Phantom reads

### SERIALIZABLE

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void method() {
    // Complete isolation
    // ‚úÖ No dirty, non-repeatable, or phantom reads
    // ‚ö†Ô∏è Lowest performance
}
```

**Problems:** Performance overhead

### Isolation Comparison

| Isolation Level | Dirty Read | Non-Repeatable Read | Phantom Read | Performance |
|-----------------|------------|---------------------|--------------|-------------|
| READ_UNCOMMITTED | ‚úÖ | ‚úÖ | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| READ_COMMITTED | ‚ùå | ‚úÖ | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê |
| REPEATABLE_READ | ‚ùå | ‚ùå | ‚úÖ | ‚≠ê‚≠ê‚≠ê |
| SERIALIZABLE | ‚ùå | ‚ùå | ‚ùå | ‚≠ê |

### Read Phenomena Explained

```java
// Dirty Read
Transaction A: UPDATE balance = 1000 WHERE id = 1; (not committed)
Transaction B: SELECT balance FROM accounts WHERE id = 1; // Reads 1000
Transaction A: ROLLBACK; // 1000 never existed!

// Non-Repeatable Read
Transaction A: SELECT balance FROM accounts WHERE id = 1; // Returns 500
Transaction B: UPDATE balance = 1000 WHERE id = 1; COMMIT;
Transaction A: SELECT balance FROM accounts WHERE id = 1; // Returns 1000 (changed!)

// Phantom Read
Transaction A: SELECT COUNT(*) FROM users WHERE age > 18; // Returns 10
Transaction B: INSERT INTO users VALUES (..., 19); COMMIT;
Transaction A: SELECT COUNT(*) FROM users WHERE age > 18; // Returns 11 (phantom row!)
```

---

## ‚ö†Ô∏è Rollback Rules

### Default Behavior

```java
@Transactional
public void method() {
    // Rolls back on: RuntimeException, Error
    // Does NOT rollback on: Checked exceptions
}
```

### Rollback on Checked Exceptions

```java
@Transactional(rollbackFor = Exception.class)
public void method() throws Exception {
    // Rolls back on ANY exception
}

@Transactional(rollbackFor = {IOException.class, SQLException.class})
public void method() throws IOException, SQLException {
    // Rolls back on specific checked exceptions
}
```

### No Rollback for Specific Exceptions

```java
@Transactional(noRollbackFor = IllegalArgumentException.class)
public void method() {
    // Does NOT rollback for IllegalArgumentException
}
```

### Practical Example

```java
@Service
public class OrderService {
    
    @Transactional(rollbackFor = Exception.class)
    public void processOrder(Order order) throws PaymentException {
        orderRepository.save(order);
        
        try {
            paymentService.charge(order.getAmount());
        } catch (PaymentException e) {
            // Rollback entire transaction
            throw e;
        }
        
        notificationService.sendConfirmation(order);
    }
}
```

---

## üíª Programmatic Transactions

### TransactionTemplate

```java
@Service
public class UserService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(User user) {
        return transactionTemplate.execute(status -> {
            try {
                return userRepository.save(user);
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }
    
    public void complexOperation() {
        transactionTemplate.execute(status -> {
            // Multiple operations
            userRepository.save(user1);
            userRepository.save(user2);
            
            if (someCondition) {
                status.setRollbackOnly(); // Manual rollback
                return null;
            }
            
            return null;
        });
    }
}
```

### PlatformTransactionManager

```java
@Service
public class UserService {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    @Autowired
    private UserRepository userRepository;
    
    public void createUser(User user) {
        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(def);
        
        try {
            userRepository.save(user);
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

### Custom TransactionTemplate

```java
@Configuration
public class TransactionConfig {
    
    @Bean
    public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
        template.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        template.setTimeout(30);
        return template;
    }
}
```

---

## ‚öôÔ∏è Transaction Configuration

### Enable Transaction Management

```java
@SpringBootApplication
@EnableTransactionManagement // Usually auto-enabled
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### Custom Transaction Manager

```java
@Configuration
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

### Multiple Transaction Managers

```java
@Configuration
public class TransactionConfig {
    
    @Bean
    @Primary
    public PlatformTransactionManager primaryTransactionManager(
            @Qualifier("primaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    
    @Bean
    public PlatformTransactionManager secondaryTransactionManager(
            @Qualifier("secondaryDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

// Usage
@Transactional("primaryTransactionManager")
public void method1() { }

@Transactional("secondaryTransactionManager")
public void method2() { }
```

### Global Transaction Settings

```properties
# application.properties
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Transaction timeout
spring.transaction.default-timeout=30
```

---

## üéØ Common Patterns

### Service Layer Transactions

```java
@Service
@Transactional
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Autowired
    private PaymentService paymentService;
    
    public Order createOrder(OrderRequest request) {
        // All operations in single transaction
        Order order = new Order();
        order.setItems(request.getItems());
        
        // Check inventory
        inventoryService.reserve(request.getItems());
        
        // Process payment
        paymentService.charge(request.getPaymentDetails());
        
        // Save order
        return orderRepository.save(order);
    }
}
```

### Read-Only Optimization

```java
@Service
@Transactional(readOnly = true)
public class UserQueryService {
    
    // All methods read-only by default
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    public User findById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    // Override for write operation
    @Transactional(readOnly = false)
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```

### Audit Logging Pattern

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private AuditService auditService;
    
    @Transactional
    public Order createOrder(Order order) {
        Order saved = orderRepository.save(order);
        
        // Log in separate transaction (always succeeds)
        auditService.logOrderCreation(saved);
        
        return saved;
    }
}

@Service
public class AuditService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logOrderCreation(Order order) {
        auditRepository.save(new AuditLog("ORDER_CREATED", order.getId()));
    }
}
```

### Retry Pattern

```java
@Service
public class PaymentService {
    
    @Retryable(
        value = {OptimisticLockingFailureException.class},
        maxAttempts = 3,
        backoff = @Backoff(delay = 1000)
    )
    @Transactional
    public void processPayment(Payment payment) {
        paymentRepository.save(payment);
    }
}
```

---

## üìå Best Practices

### 1. Keep Transactions Short

```java
// ‚úÖ Good - Short transaction
@Transactional
public Order createOrder(OrderRequest request) {
    return orderRepository.save(mapToOrder(request));
}

// ‚ùå Bad - Long transaction
@Transactional
public Order createOrder(OrderRequest request) {
    validateRequest(request); // External API call
    Order order = mapToOrder(request);
    sendEmail(order); // Email service
    return orderRepository.save(order);
}
```

### 2. Use Read-Only for Queries

```java
// ‚úÖ Good
@Transactional(readOnly = true)
public List<User> findAll() {
    return userRepository.findAll();
}

// ‚ùå Bad - Unnecessary overhead
@Transactional
public List<User> findAll() {
    return userRepository.findAll();
}
```

### 3. Specify Rollback Rules

```java
// ‚úÖ Good - Explicit rollback
@Transactional(rollbackFor = Exception.class)
public void method() throws Exception {
    // Rolls back on checked exceptions too
}

// ‚ùå Bad - Checked exceptions don't rollback
@Transactional
public void method() throws Exception {
    // Only RuntimeException rolls back
}
```

### 4. Avoid Transactions in Controllers

```java
// ‚úÖ Good - Transaction in service
@RestController
public class UserController {
    @Autowired
    private UserService userService;
    
    @PostMapping("/users")
    public User create(@RequestBody User user) {
        return userService.createUser(user); // Service handles transaction
    }
}

@Service
@Transactional
public class UserService {
    public User createUser(User user) {
        return userRepository.save(user);
    }
}

// ‚ùå Bad - Transaction in controller
@RestController
@Transactional
public class UserController {
    // Controllers shouldn't manage transactions
}
```

### 5. Be Careful with Self-Invocation

```java
// ‚ùå Bad - Self-invocation bypasses proxy
@Service
public class UserService {
    
    public void method1() {
        method2(); // @Transactional NOT applied!
    }
    
    @Transactional
    public void method2() {
        // Transaction not started!
    }
}

// ‚úÖ Good - Inject self
@Service
public class UserService {
    
    @Autowired
    private UserService self;
    
    public void method1() {
        self.method2(); // @Transactional works
    }
    
    @Transactional
    public void method2() {
        // Transaction started
    }
}
```

### 6. Use Propagation Wisely

```java
// ‚úÖ Good - Independent audit log
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void logAudit(String message) {
    auditRepository.save(new AuditLog(message));
}

// ‚ùå Bad - Audit fails with main transaction
@Transactional
public void logAudit(String message) {
    auditRepository.save(new AuditLog(message));
}
```

### 7. Handle Exceptions Properly

```java
// ‚úÖ Good
@Transactional
public void processOrder(Order order) {
    try {
        orderRepository.save(order);
        paymentService.charge(order);
    } catch (PaymentException e) {
        // Log and rethrow for rollback
        log.error("Payment failed", e);
        throw e;
    }
}

// ‚ùå Bad - Swallows exception
@Transactional
public void processOrder(Order order) {
    try {
        orderRepository.save(order);
        paymentService.charge(order);
    } catch (PaymentException e) {
        log.error("Payment failed", e);
        // Exception not propagated, no rollback!
    }
}
```

---

## üé§ Interview Questions

### Q1: What is @Transactional?
**Answer:** Spring annotation for declarative transaction management, ensuring ACID properties for database operations.

### Q2: Difference between declarative and programmatic transactions?
**Answer:**
- **Declarative:** @Transactional annotation, less code
- **Programmatic:** TransactionTemplate, more control

### Q3: Default rollback behavior of @Transactional?
**Answer:** Rolls back on RuntimeException and Error, does NOT rollback on checked exceptions.

### Q4: What is propagation in transactions?
**Answer:** Defines how transactions relate when one transactional method calls another. Default: REQUIRED.

### Q5: Explain REQUIRED vs REQUIRES_NEW?
**Answer:**
- **REQUIRED:** Join existing or create new
- **REQUIRES_NEW:** Always create new, suspend existing

### Q6: What are isolation levels?
**Answer:** Controls how concurrent transactions interact:
- READ_UNCOMMITTED: Allows dirty reads
- READ_COMMITTED: No dirty reads
- REPEATABLE_READ: Consistent reads
- SERIALIZABLE: Complete isolation

### Q7: What is dirty read?
**Answer:** Reading uncommitted data from another transaction that might rollback.

### Q8: readOnly=true benefit?
**Answer:** Performance optimization - tells database no writes expected, enables caching optimizations.

### Q9: Can you nest transactions?
**Answer:** Yes, with Propagation.NESTED (uses savepoints) or REQUIRES_NEW (independent transaction).

### Q10: What happens if @Transactional method calls another @Transactional method?
**Answer:** Depends on propagation. Default (REQUIRED) uses same transaction.

### Q11: Why doesn't @Transactional work with private methods?
**Answer:** Spring uses AOP proxies, which only intercept public method calls.

### Q12: What is transaction timeout?
**Answer:** Maximum time transaction can run before automatic rollback. Set with timeout attribute.

### Q13: How to rollback on checked exceptions?
**Answer:** Use rollbackFor:
```java
@Transactional(rollbackFor = Exception.class)
```

### Q14: What is TransactionTemplate?
**Answer:** Programmatic transaction management alternative to @Transactional.

### Q15: Can you have multiple transaction managers?
**Answer:** Yes, specify with @Transactional("transactionManagerName").

### Q16: What is phantom read?
**Answer:** New rows appearing in query results when query is repeated in same transaction.

### Q17: Best isolation level for banking?
**Answer:** SERIALIZABLE for critical operations (account balance), REPEATABLE_READ for most cases.

### Q18: What is optimistic locking?
**Answer:** Version-based locking, checks version before update, throws exception if changed.

### Q19: What is pessimistic locking?
**Answer:** Database-level locking, prevents concurrent access:
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
```

### Q20: Transaction best practices?
**Answer:**
1. Keep transactions short
2. Use readOnly for queries
3. Specify rollback rules
4. Avoid in controllers
5. Handle self-invocation carefully

---

## üìö Summary

### Basic Usage

```java
// Simple transaction
@Transactional
public User createUser(User user) {
    return userRepository.save(user);
}

// Read-only
@Transactional(readOnly = true)
public List<User> findAll() {
    return userRepository.findAll();
}

// With rollback rules
@Transactional(rollbackFor = Exception.class)
public void method() throws Exception { }
```

### Propagation

```java
REQUIRED      // Default, join or create
REQUIRES_NEW  // Always create new
NESTED        // Nested with savepoint
SUPPORTS      // Optional transaction
```

### Isolation

```java
READ_UNCOMMITTED  // Dirty reads allowed
READ_COMMITTED    // Default (PostgreSQL, SQL Server)
REPEATABLE_READ   // Default (MySQL)
SERIALIZABLE      // Strictest, slowest
```

**Next:** Database Migrations (Flyway & Liquibase) ‚Üí

