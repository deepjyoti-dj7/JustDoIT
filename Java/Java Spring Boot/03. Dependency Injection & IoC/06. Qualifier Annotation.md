# üè∑Ô∏è @Qualifier Annotation - Resolving Autowiring Ambiguity

## üìã Table of Contents
- [What is @Qualifier?](#what-is-qualifier)
- [The Ambiguity Problem](#the-ambiguity-problem)
- [Using @Qualifier](#using-qualifier)
- [Custom Qualifiers](#custom-qualifiers)
- [@Qualifier with Collections](#qualifier-with-collections)
- [@Qualifier on Bean Definitions](#qualifier-on-bean-definitions)
- [Meta-Annotations](#meta-annotations)
- [Qualifier vs @Primary](#qualifier-vs-primary)
- [Real-World Examples](#real-world-examples)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is @Qualifier?

**@Qualifier** is used to **resolve ambiguity** when multiple beans of the same type exist and Spring doesn't know which one to inject.

### Problem Without @Qualifier

```java
public interface PaymentGateway {
    void charge(BigDecimal amount);
}

@Component
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // ‚ùå Error: Which one to inject?
}

// NoUniqueBeanDefinitionException: expected single matching bean but found 2
```

### Solution With @Qualifier

```java
@Service
public class OrderService {
    private final PaymentGateway gateway;
    
    @Autowired
    public OrderService(@Qualifier("stripePayment") PaymentGateway gateway) {
        this.gateway = gateway;  // ‚úÖ Injects StripePayment
    }
}
```

---

## ‚ö†Ô∏è The Ambiguity Problem

### Multiple Implementations

```java
public interface NotificationService {
    void send(String message);
}

@Component
public class EmailNotification implements NotificationService {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

@Component
public class SmsNotification implements NotificationService {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}

@Component
public class PushNotification implements NotificationService {
    public void send(String message) {
        System.out.println("Push: " + message);
    }
}

@Service
public class UserService {
    @Autowired
    private NotificationService notification;  // ‚ùå Which one?
}

// Error: NoUniqueBeanDefinitionException
// expected single matching bean but found 3: 
// emailNotification, smsNotification, pushNotification
```

### Multiple Bean Definitions

```java
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource mysqlDataSource() {
        return new MysqlDataSource();
    }
    
    @Bean
    public DataSource postgresDataSource() {
        return new PostgresDataSource();
    }
}

@Service
public class UserRepository {
    @Autowired
    private DataSource dataSource;  // ‚ùå Which one?
}
```

---

## üè∑Ô∏è Using @Qualifier

### Constructor Injection with @Qualifier

```java
@Service
public class OrderService {
    private final PaymentGateway gateway;
    
    @Autowired
    public OrderService(@Qualifier("stripePayment") PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

### Field Injection with @Qualifier

```java
@Service
public class OrderService {
    @Autowired
    @Qualifier("paypalPayment")
    private PaymentGateway gateway;
}
```

### Setter Injection with @Qualifier

```java
@Service
public class OrderService {
    private PaymentGateway gateway;
    
    @Autowired
    public void setGateway(@Qualifier("stripePayment") PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

### Multiple Parameters with @Qualifier

```java
@Service
public class PaymentService {
    private final PaymentGateway primaryGateway;
    private final PaymentGateway backupGateway;
    
    @Autowired
    public PaymentService(
        @Qualifier("stripePayment") PaymentGateway primaryGateway,
        @Qualifier("paypalPayment") PaymentGateway backupGateway
    ) {
        this.primaryGateway = primaryGateway;
        this.backupGateway = backupGateway;
    }
    
    public void processPayment(BigDecimal amount) {
        try {
            primaryGateway.charge(amount);
        } catch (Exception e) {
            backupGateway.charge(amount);  // Fallback
        }
    }
}
```

---

## üé® Custom Qualifiers

### Creating Custom Qualifier Annotations

```java
// Custom qualifier for payment gateways
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface PaymentType {
    PaymentProvider value();
}

public enum PaymentProvider {
    STRIPE, PAYPAL, SQUARE
}
```

### Using Custom Qualifiers

```java
@Component
@PaymentType(PaymentProvider.STRIPE)
public class StripePayment implements PaymentGateway { }

@Component
@PaymentType(PaymentProvider.PAYPAL)
public class PayPalPayment implements PaymentGateway { }

@Component
@PaymentType(PaymentProvider.SQUARE)
public class SquarePayment implements PaymentGateway { }

@Service
public class OrderService {
    private final PaymentGateway gateway;
    
    @Autowired
    public OrderService(@PaymentType(PaymentProvider.STRIPE) PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

### Multiple Attribute Qualifiers

```java
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface DataSourceType {
    String environment();
    String database();
}

@Component
@DataSourceType(environment = "prod", database = "mysql")
public class ProductionMySQLDataSource implements DataSource { }

@Component
@DataSourceType(environment = "dev", database = "h2")
public class DevelopmentH2DataSource implements DataSource { }

@Service
public class UserRepository {
    @Autowired
    public UserRepository(
        @DataSourceType(environment = "prod", database = "mysql") DataSource dataSource
    ) {
        this.dataSource = dataSource;
    }
}
```

---

## üì¶ @Qualifier with Collections

### Injecting Specific Beans from Collection

```java
@Component
@Qualifier("important")
public class CriticalValidator implements Validator { }

@Component
@Qualifier("important")
public class SecurityValidator implements Validator { }

@Component
@Qualifier("optional")
public class OptionalValidator implements Validator { }

@Service
public class ValidationService {
    private final List<Validator> importantValidators;
    
    @Autowired
    public ValidationService(@Qualifier("important") List<Validator> validators) {
        this.importantValidators = validators;  // Only CriticalValidator & SecurityValidator
    }
}
```

### Map with Qualifiers

```java
@Service
public class NotificationDispatcher {
    private final Map<String, NotificationService> services;
    
    @Autowired
    public NotificationDispatcher(Map<String, NotificationService> services) {
        this.services = services;  // All NotificationService beans
    }
    
    public void send(String type, String message) {
        NotificationService service = services.get(type);
        if (service != null) {
            service.send(message);
        }
    }
}

// Usage
notificationDispatcher.send("emailNotification", "Hello");
notificationDispatcher.send("smsNotification", "Hello");
```

---

## üîß @Qualifier on Bean Definitions

### @Bean with @Qualifier

```java
@Configuration
public class DatabaseConfig {
    @Bean
    @Qualifier("primary")
    public DataSource primaryDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://primary-db:3306/app");
        return ds;
    }
    
    @Bean
    @Qualifier("replica")
    public DataSource replicaDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://replica-db:3306/app");
        return ds;
    }
}

@Service
public class UserRepository {
    private final DataSource primaryDs;
    private final DataSource replicaDs;
    
    @Autowired
    public UserRepository(
        @Qualifier("primary") DataSource primaryDs,
        @Qualifier("replica") DataSource replicaDs
    ) {
        this.primaryDs = primaryDs;
        this.replicaDs = replicaDs;
    }
    
    public User save(User user) {
        // Write to primary
        return jdbcTemplate(primaryDs).update(...);
    }
    
    public List<User> findAll() {
        // Read from replica
        return jdbcTemplate(replicaDs).query(...);
    }
}
```

### Named Beans

```java
@Configuration
public class AppConfig {
    @Bean("prodCache")
    public CacheManager prodCacheManager() {
        return new RedisCacheManager(...);
    }
    
    @Bean("devCache")
    public CacheManager devCacheManager() {
        return new SimpleCacheManager(...);
    }
}

@Service
public class CacheService {
    @Autowired
    public CacheService(@Qualifier("prodCache") CacheManager cacheManager) {
        this.cacheManager = cacheManager;
    }
}
```

---

## üèÖ Meta-Annotations

### Creating Semantic Qualifiers

```java
// Define meta-qualifiers
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Primary {
}

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Backup {
}

// Use on beans
@Component
@Primary
public class PrimaryDatabase implements Database { }

@Component
@Backup
public class BackupDatabase implements Database { }

// Inject
@Service
public class DataService {
    @Autowired
    public DataService(@Primary Database primary, @Backup Database backup) {
        this.primary = primary;
        this.backup = backup;
    }
}
```

### Environment-Specific Qualifiers

```java
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Environment {
    String value();
}

@Component
@Environment("dev")
public class DevEmailService implements EmailService { }

@Component
@Environment("prod")
public class ProdEmailService implements EmailService { }

@Service
public class NotificationService {
    @Autowired
    public NotificationService(@Environment("prod") EmailService emailService) {
        this.emailService = emailService;
    }
}
```

---

## ‚öñÔ∏è Qualifier vs @Primary

### @Qualifier (Explicit Selection)

```java
@Component
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    public OrderService(@Qualifier("stripePayment") PaymentGateway gateway) {
        this.gateway = gateway;  // Explicitly selects StripePayment
    }
}
```

### @Primary (Default Selection)

```java
@Component
@Primary  // Default choice
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // Automatically injects StripePayment
}
```

### Comparison

| Feature | @Qualifier | @Primary |
|---------|-----------|----------|
| **Selection** | Explicit | Default |
| **Location** | Injection point | Bean definition |
| **Multiple** | Different for each injection | One default for all |
| **Override** | Always respected | Overridden by @Qualifier |
| **Use Case** | Specific choice | Common default |

### Combining Both

```java
@Component
@Primary
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class DefaultOrderService {
    @Autowired
    private PaymentGateway gateway;  // Uses @Primary (StripePayment)
}

@Service
public class SpecialOrderService {
    @Autowired
    public SpecialOrderService(@Qualifier("paypalPayment") PaymentGateway gateway) {
        this.gateway = gateway;  // @Qualifier overrides @Primary
    }
}
```

---

## üåç Real-World Examples

### Example 1: Multi-Tenancy

```java
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Tenant {
    String value();
}

@Component
@Tenant("companyA")
public class CompanyADataSource implements DataSource { }

@Component
@Tenant("companyB")
public class CompanyBDataSource implements DataSource { }

@Service
public class TenantService {
    private final DataSource companyADs;
    private final DataSource companyBDs;
    
    @Autowired
    public TenantService(
        @Tenant("companyA") DataSource companyADs,
        @Tenant("companyB") DataSource companyBDs
    ) {
        this.companyADs = companyADs;
        this.companyBDs = companyBDs;
    }
    
    public Data getData(String tenant) {
        DataSource ds = tenant.equals("companyA") ? companyADs : companyBDs;
        return fetchData(ds);
    }
}
```

### Example 2: Feature Flags

```java
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface FeatureVersion {
    int value();
}

@Component
@FeatureVersion(1)
public class SearchV1 implements SearchService { }

@Component
@FeatureVersion(2)
public class SearchV2 implements SearchService { }

@Service
public class ProductService {
    @Autowired
    public ProductService(@FeatureVersion(2) SearchService searchService) {
        this.searchService = searchService;  // Uses v2
    }
}
```

### Example 3: Strategy Pattern

```java
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ShippingType {
    String value();
}

@Component
@ShippingType("standard")
public class StandardShipping implements ShippingStrategy { }

@Component
@ShippingType("express")
public class ExpressShipping implements ShippingStrategy { }

@Component
@ShippingType("overnight")
public class OvernightShipping implements ShippingStrategy { }

@Service
public class OrderService {
    private final Map<String, ShippingStrategy> strategies;
    
    @Autowired
    public OrderService(List<ShippingStrategy> strategies) {
        this.strategies = strategies.stream()
            .collect(Collectors.toMap(
                s -> s.getClass().getAnnotation(ShippingType.class).value(),
                s -> s
            ));
    }
    
    public BigDecimal calculateShipping(Order order, String type) {
        return strategies.get(type).calculate(order);
    }
}
```

---

## üìå Best Practices

### 1. **Use Descriptive Qualifier Names**

```java
// ‚ùå Unclear
@Qualifier("db1")
@Qualifier("impl2")

// ‚úÖ Clear
@Qualifier("primaryDatabase")
@Qualifier("replicaDatabase")
```

### 2. **Create Custom Qualifiers for Domain**

```java
// ‚úÖ Domain-specific
@PaymentType(PaymentProvider.STRIPE)
@Tenant("companyA")
@Environment("production")
```

### 3. **Prefer @Primary for Common Case**

```java
// ‚úÖ @Primary for 90% of cases
@Component
@Primary
public class DefaultEmailService implements EmailService { }

// ‚úÖ @Qualifier for special cases
@Autowired
public SpecialService(@Qualifier("smtpEmail") EmailService email) { }
```

### 4. **Use Constructor Injection with @Qualifier**

```java
// ‚úÖ Immutable, testable
@Service
public class UserService {
    private final PaymentGateway gateway;
    
    @Autowired
    public UserService(@Qualifier("stripe") PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

### 5. **Document Qualifier Usage**

```java
/**
 * Service for processing orders.
 * Uses Stripe as primary payment gateway.
 */
@Service
public class OrderService {
    @Autowired
    public OrderService(@Qualifier("stripePayment") PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

### 6. **Keep Qualifier Logic Simple**

```java
// ‚ùå Complex qualifier logic
@Qualifier("#{T(com.example.Config).getDbType()}")

// ‚úÖ Simple, static qualifiers
@Qualifier("primaryDb")
```

---

## üé§ Interview Questions

### Q1: What is @Qualifier used for?
**Answer:** Resolving ambiguity when multiple beans of the same type exist. It explicitly specifies which bean to inject.

### Q2: What happens without @Qualifier when multiple beans exist?
**Answer:** `NoUniqueBeanDefinitionException` is thrown at runtime.

### Q3: How to use @Qualifier?
**Answer:**
```java
@Autowired
public UserService(@Qualifier("beanName") UserRepository repo) {
    this.repo = repo;
}
```

### Q4: Can you create custom qualifiers?
**Answer:** Yes!
```java
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PaymentType {
    PaymentProvider value();
}
```

### Q5: @Qualifier vs @Primary?
**Answer:**
- **@Qualifier**: Explicit selection at injection point
- **@Primary**: Default selection at bean definition
- @Qualifier overrides @Primary

### Q6: Can @Qualifier be used with collections?
**Answer:** Yes!
```java
@Autowired
public MyService(@Qualifier("important") List<Validator> validators) {
    // Only beans with @Qualifier("important")
}
```

### Q7: Where can @Qualifier be applied?
**Answer:**
- Constructor parameters
- Setter parameters
- Fields
- Bean definitions (@Bean methods)

### Q8: How does bean name matching work?
**Answer:** If no @Qualifier, Spring matches parameter name to bean name:
```java
@Autowired
public UserService(PaymentGateway stripePayment) {
    // Injects bean named "stripePayment"
}
```

### Q9: Can you combine @Qualifier with @Primary?
**Answer:** Yes, @Qualifier always wins:
```java
@Component
@Primary
class A { }

@Autowired
public MyService(@Qualifier("b") Interface dep) {
    // Injects B, not A
}
```

### Q10: What's the default qualifier value?
**Answer:** Bean name (lowercase class name by default):
```java
@Component
public class StripePayment { }  // Bean name: "stripePayment"

@Qualifier("stripePayment")  // Matches default name
```

---

## üìö Summary

### Key Points

- **@Qualifier** resolves autowiring ambiguity
- **NoUniqueBeanDefinitionException** without qualifier when multiple beans match
- **Custom qualifiers** for domain-specific selection
- **@Qualifier overrides @Primary**
- **Works with collections** to filter beans
- **Applied at injection point** (constructor, setter, field)

### Decision Matrix

```
Single bean of type?
‚îî‚îÄ No qualifier needed

Multiple beans?
‚îú‚îÄ One is default ‚Üí Use @Primary on bean
‚îú‚îÄ Explicit choice ‚Üí Use @Qualifier at injection
‚îî‚îÄ Domain logic ‚Üí Create custom @Qualifier
```

### Best Practice Template

```java
// Custom qualifier
@Qualifier
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PaymentType {
    PaymentProvider value();
}

// Bean with qualifier
@Component
@PaymentType(PaymentProvider.STRIPE)
public class StripePayment implements PaymentGateway { }

// Injection with qualifier
@Service
public class OrderService {
    private final PaymentGateway gateway;
    
    @Autowired
    public OrderService(@PaymentType(PaymentProvider.STRIPE) PaymentGateway gateway) {
        this.gateway = gateway;
    }
}
```

**Next:** @Primary Annotation ‚Üí

