# ü•á @Primary Annotation - Setting Default Beans

## üìã Table of Contents
- [What is @Primary?](#what-is-primary)
- [The Default Bean Problem](#the-default-bean-problem)
- [Using @Primary](#using-primary)
- [@Primary with @Bean](#primary-with-bean)
- [@Primary with @Component](#primary-with-component)
- [@Primary vs @Qualifier](#primary-vs-qualifier)
- [Multiple @Primary (Anti-Pattern)](#multiple-primary-anti-pattern)
- [@Primary with Profiles](#primary-with-profiles)
- [Real-World Examples](#real-world-examples)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is @Primary?

**@Primary** indicates that a bean should be given **preference** when multiple candidates are qualified to autowire.

### Problem Without @Primary

```java
public interface PaymentGateway {
    void charge(BigDecimal amount);
}

@Component
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // ‚ùå Which one?
}

// Error: NoUniqueBeanDefinitionException
```

### Solution With @Primary

```java
@Component
@Primary  // Default choice
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // ‚úÖ Injects StripePayment
}
```

---

## ‚ö†Ô∏è The Default Bean Problem

### Multiple Implementations

```java
public interface EmailService {
    void send(String to, String message);
}

@Component
public class SmtpEmailService implements EmailService {
    public void send(String to, String message) {
        // SMTP implementation
    }
}

@Component
public class SendGridEmailService implements EmailService {
    public void send(String to, String message) {
        // SendGrid API implementation
    }
}

@Component
public class AwsSesEmailService implements EmailService {
    public void send(String to, String message) {
        // AWS SES implementation
    }
}

@Service
public class NotificationService {
    @Autowired
    private EmailService emailService;  // ‚ùå Which implementation?
}

// NoUniqueBeanDefinitionException:
// expected single matching bean but found 3
```

### Without @Primary - Must Use @Qualifier Everywhere

```java
@Service
public class NotificationService {
    @Autowired
    public NotificationService(@Qualifier("smtpEmailService") EmailService email) {
        this.emailService = email;
    }
}

@Service
public class UserService {
    @Autowired
    public UserService(@Qualifier("smtpEmailService") EmailService email) {
        this.emailService = email;
    }
}

@Service
public class OrderService {
    @Autowired
    public OrderService(@Qualifier("smtpEmailService") EmailService email) {
        this.emailService = email;
    }
}

// Repetitive! @Qualifier everywhere
```

### With @Primary - Cleaner

```java
@Component
@Primary  // Default implementation
public class SmtpEmailService implements EmailService { }

@Component
public class SendGridEmailService implements EmailService { }

@Component
public class AwsSesEmailService implements EmailService { }

@Service
public class NotificationService {
    @Autowired
    private EmailService emailService;  // ‚úÖ Uses SmtpEmailService
}

@Service
public class UserService {
    @Autowired
    private EmailService emailService;  // ‚úÖ Uses SmtpEmailService
}

// No @Qualifier needed for common case!
```

---

## üèÖ Using @Primary

### On @Component Classes

```java
@Component
@Primary
public class DefaultCacheService implements CacheService {
    public void put(String key, Object value) {
        // Default cache implementation
    }
}

@Component
public class RedisCacheService implements CacheService {
    public void put(String key, Object value) {
        // Redis cache implementation
    }
}

@Service
public class ProductService {
    @Autowired
    private CacheService cache;  // Uses DefaultCacheService
}
```

### On @Service Classes

```java
public interface UserRepository {
    User findById(Long id);
}

@Service
@Primary
public class JpaUserRepository implements UserRepository {
    public User findById(Long id) {
        // JPA implementation
    }
}

@Service
public class MongoUserRepository implements UserRepository {
    public User findById(Long id) {
        // MongoDB implementation
    }
}

@Service
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;  // Uses JpaUserRepository
    }
}
```

---

## üîß @Primary with @Bean

### In @Configuration Classes

```java
@Configuration
public class DatabaseConfig {
    @Bean
    @Primary
    public DataSource primaryDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://primary-db:3306/app");
        ds.setUsername("user");
        ds.setPassword("password");
        return ds;
    }
    
    @Bean
    public DataSource replicaDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://replica-db:3306/app");
        ds.setUsername("user");
        ds.setPassword("password");
        return ds;
    }
}

@Repository
public class UserRepository {
    private final DataSource dataSource;
    
    @Autowired
    public UserRepository(DataSource dataSource) {
        this.dataSource = dataSource;  // Uses primaryDataSource
    }
}
```

### Multiple Bean Methods

```java
@Configuration
public class CacheConfig {
    @Bean
    @Primary
    public CacheManager redisCacheManager() {
        RedisCacheManager cacheManager = RedisCacheManager
            .builder(redisConnectionFactory())
            .build();
        return cacheManager;
    }
    
    @Bean
    public CacheManager caffeineCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(10, TimeUnit.MINUTES));
        return cacheManager;
    }
    
    @Bean
    public CacheManager ehCacheManager() {
        return new EhCacheCacheManager(ehCacheManagerFactoryBean().getObject());
    }
}

@Service
public class ProductService {
    @Autowired
    private CacheManager cacheManager;  // Uses redisCacheManager
}
```

---

## üè∑Ô∏è @Primary with @Component

### Stereotype Annotations

```java
// Repository
@Repository
@Primary
public class JpaProductRepository implements ProductRepository { }

@Repository
public class MongoProductRepository implements ProductRepository { }

// Service
@Service
@Primary
public class DefaultPaymentService implements PaymentService { }

@Service
public class StripePaymentService implements PaymentService { }

// Controller
@RestController
@Primary
@RequestMapping("/api/v2")
public class UserControllerV2 { }

@RestController
@RequestMapping("/api/v1")
public class UserControllerV1 { }
```

---

## ‚öñÔ∏è @Primary vs @Qualifier

### Comparison Table

| Feature | @Primary | @Qualifier |
|---------|----------|-----------|
| **Location** | Bean definition | Injection point |
| **Purpose** | Default choice | Explicit choice |
| **Scope** | Global default | Per-injection |
| **Override** | Can be overridden by @Qualifier | Always wins |
| **Verbosity** | Less (set once) | More (repeat each time) |
| **Use Case** | 90% of injections | Special cases |

### @Primary Alone

```java
@Component
@Primary
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // StripePayment (primary)
}

@Service
public class InvoiceService {
    @Autowired
    private PaymentGateway gateway;  // StripePayment (primary)
}
```

### @Qualifier Overrides @Primary

```java
@Component
@Primary
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // StripePayment (primary)
}

@Service
public class SpecialOrderService {
    @Autowired
    public SpecialOrderService(@Qualifier("payPalPayment") PaymentGateway gateway) {
        this.gateway = gateway;  // PayPalPayment (@Qualifier wins)
    }
}
```

### When to Use Each

```java
// Use @Primary when:
// - 90% of injections need the same implementation
// - You have a clear "default" choice

@Component
@Primary
public class DefaultEmailService implements EmailService { }

// Use @Qualifier when:
// - No clear default
// - Different implementations for different use cases

@Service
public class AdminService {
    @Autowired
    public AdminService(@Qualifier("adminEmail") EmailService email) {
        this.emailService = email;
    }
}
```

---

## üö´ Multiple @Primary (Anti-Pattern)

### Problem: Multiple @Primary Annotations

```java
@Component
@Primary
public class StripePayment implements PaymentGateway { }

@Component
@Primary  // ‚ùå Second @Primary!
public class PayPalPayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // ‚ùå Which primary to use?
}

// Still throws NoUniqueBeanDefinitionException!
// Only ONE @Primary per type allowed
```

### Solution: Only One @Primary

```java
@Component
@Primary  // ‚úÖ Only one @Primary
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

@Component
public class SquarePayment implements PaymentGateway { }

@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // ‚úÖ Uses StripePayment
}
```

---

## üîÑ @Primary with Profiles

### Environment-Specific Primary Beans

```java
@Configuration
public class DataSourceConfig {
    @Bean
    @Primary
    @Profile("dev")
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    @Bean
    @Primary
    @Profile("prod")
    public DataSource prodDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:postgresql://prod-db:5432/app");
        return ds;
    }
}

// In dev: devDataSource is primary
// In prod: prodDataSource is primary
```

### Profile-Based Service Selection

```java
@Service
@Primary
@Profile("!cloud")
public class LocalFileStorage implements StorageService {
    public void store(byte[] data) {
        // Store locally
    }
}

@Service
@Primary
@Profile("cloud")
public class S3Storage implements StorageService {
    public void store(byte[] data) {
        // Store in S3
    }
}

@Service
public class DocumentService {
    @Autowired
    private StorageService storage;
    // Uses LocalFileStorage when profile != cloud
    // Uses S3Storage when profile == cloud
}
```

---

## üåç Real-World Examples

### Example 1: Payment Gateway

```java
public interface PaymentGateway {
    PaymentResult charge(Order order);
}

@Component
@Primary  // Default for most countries
public class StripePayment implements PaymentGateway {
    public PaymentResult charge(Order order) {
        // Stripe API
    }
}

@Component  // Specific for China
public class AlipayPayment implements PaymentGateway {
    public PaymentResult charge(Order order) {
        // Alipay API
    }
}

@Service
public class OrderService {
    private final PaymentGateway defaultGateway;
    private final PaymentGateway alipayGateway;
    
    @Autowired
    public OrderService(
        PaymentGateway defaultGateway,  // Stripe (primary)
        @Qualifier("alipayPayment") PaymentGateway alipayGateway
    ) {
        this.defaultGateway = defaultGateway;
        this.alipayGateway = alipayGateway;
    }
    
    public PaymentResult processPayment(Order order) {
        if (order.getCountry().equals("CN")) {
            return alipayGateway.charge(order);
        }
        return defaultGateway.charge(order);
    }
}
```

### Example 2: Database Read/Write

```java
@Configuration
public class DatabaseConfig {
    @Bean
    @Primary
    public DataSource writeDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://master-db:3306/app");
        return ds;
    }
    
    @Bean
    public DataSource readDataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://replica-db:3306/app");
        return ds;
    }
}

@Repository
public class UserRepository {
    private final JdbcTemplate writeTemplate;
    private final JdbcTemplate readTemplate;
    
    @Autowired
    public UserRepository(
        DataSource writeDataSource,  // Primary
        @Qualifier("readDataSource") DataSource readDataSource
    ) {
        this.writeTemplate = new JdbcTemplate(writeDataSource);
        this.readTemplate = new JdbcTemplate(readDataSource);
    }
    
    public void save(User user) {
        writeTemplate.update(...);  // Write to master
    }
    
    public List<User> findAll() {
        return readTemplate.query(...);  // Read from replica
    }
}
```

### Example 3: Caching Strategy

```java
@Configuration
public class CacheConfig {
    @Bean
    @Primary
    @Profile("!prod")
    public CacheManager simpleCacheManager() {
        SimpleCacheManager manager = new SimpleCacheManager();
        manager.setCaches(Arrays.asList(
            new ConcurrentMapCache("users"),
            new ConcurrentMapCache("products")
        ));
        return manager;
    }
    
    @Bean
    @Primary
    @Profile("prod")
    public CacheManager redisCacheManager(RedisConnectionFactory factory) {
        RedisCacheManager manager = RedisCacheManager
            .builder(factory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1)))
            .build();
        return manager;
    }
}

@Service
public class ProductService {
    @Autowired
    private CacheManager cacheManager;
    // Uses SimpleCacheManager in dev/test
    // Uses RedisCacheManager in prod
}
```

---

## üìå Best Practices

### 1. **Use @Primary for Clear Defaults**

```java
// ‚úÖ Clear default choice
@Component
@Primary
public class DefaultEmailService implements EmailService { }

@Component
public class BulkEmailService implements EmailService { }

@Component
public class TransactionalEmailService implements EmailService { }
```

### 2. **Combine with @Profile for Environments**

```java
// ‚úÖ Environment-specific primary
@Bean
@Primary
@Profile("dev")
public DataSource devDataSource() { }

@Bean
@Primary
@Profile("prod")
public DataSource prodDataSource() { }
```

### 3. **Document Why Bean is Primary**

```java
/**
 * Default payment gateway for most regions.
 * Stripe has the best international coverage and lowest fees.
 */
@Component
@Primary
public class StripePayment implements PaymentGateway { }
```

### 4. **Only One @Primary Per Type**

```java
// ‚ùå Multiple @Primary
@Component
@Primary
public class ServiceA implements MyService { }

@Component
@Primary  // Don't do this
public class ServiceB implements MyService { }

// ‚úÖ Only one @Primary
@Component
@Primary
public class ServiceA implements MyService { }

@Component
public class ServiceB implements MyService { }
```

### 5. **Override with @Qualifier When Needed**

```java
@Component
@Primary
public class DefaultCache implements CacheService { }

@Service
public class FastService {
    @Autowired
    public FastService(@Qualifier("redisCache") CacheService cache) {
        this.cache = cache;  // Override primary
    }
}
```

### 6. **Avoid @Primary if No Clear Default**

```java
// ‚ùå No clear default - don't use @Primary
public interface PaymentGateway { }

@Component
public class StripePayment implements PaymentGateway { }

@Component
public class PayPalPayment implements PaymentGateway { }

// ‚úÖ Use @Qualifier everywhere instead
@Autowired
public OrderService(@Qualifier("stripe") PaymentGateway gateway) { }
```

---

## üé§ Interview Questions

### Q1: What is @Primary used for?
**Answer:** Indicates the default bean to inject when multiple candidates of the same type exist. Avoids needing @Qualifier everywhere.

### Q2: Where can @Primary be used?
**Answer:**
- @Component, @Service, @Repository, @Controller classes
- @Bean methods in @Configuration classes

### Q3: @Primary vs @Qualifier?
**Answer:**
- **@Primary**: Default choice, set at bean definition, global
- **@Qualifier**: Explicit choice, set at injection point, per-injection
- @Qualifier overrides @Primary

### Q4: Can you have multiple @Primary for same type?
**Answer:** No! Only ONE @Primary per type. Multiple @Primary still throws `NoUniqueBeanDefinitionException`.

### Q5: Does @Qualifier override @Primary?
**Answer:** Yes, @Qualifier always takes precedence over @Primary.

### Q6: How to use @Primary with profiles?
**Answer:**
```java
@Bean
@Primary
@Profile("dev")
public DataSource devDataSource() { }

@Bean
@Primary
@Profile("prod")
public DataSource prodDataSource() { }
```

### Q7: When to use @Primary?
**Answer:** When:
- 90% of injections need the same implementation
- There's a clear "default" choice
- Want to avoid @Qualifier repetition

### Q8: When NOT to use @Primary?
**Answer:** When:
- No clear default exists
- Implementations are equally important
- Different use cases need different implementations

### Q9: What happens if no @Primary and multiple beans?
**Answer:** `NoUniqueBeanDefinitionException` at startup or injection point.

### Q10: Can @Primary work with constructor injection?
**Answer:** Yes!
```java
@Component
@Primary
public class ServiceA implements MyService { }

@Service
public class Consumer {
    public Consumer(MyService service) {
        // Injects ServiceA
    }
}
```

---

## üìö Summary

### Key Points

- **@Primary** marks the **default bean** when multiple candidates exist
- Applied at **bean definition** (not injection point)
- **@Qualifier overrides @Primary**
- **Only ONE @Primary** per type
- Reduces **@Qualifier repetition**
- Works with **@Profile** for environment-specific defaults

### Decision Tree

```
Multiple beans of same type?
‚îú‚îÄ Yes
‚îÇ  ‚îú‚îÄ Clear default? (90% use this)
‚îÇ  ‚îÇ  ‚îú‚îÄ Yes ‚Üí Use @Primary
‚îÇ  ‚îÇ  ‚îî‚îÄ No  ‚Üí Use @Qualifier everywhere
‚îÇ  ‚îî‚îÄ Environment-specific default?
‚îÇ     ‚îî‚îÄ Yes ‚Üí Use @Primary with @Profile
‚îî‚îÄ No ‚Üí No annotation needed
```

### Best Practice Template

```java
// Default implementation
@Component
@Primary
public class DefaultPaymentGateway implements PaymentGateway {
    // Used in 90% of cases
}

// Alternative implementation
@Component
public class SpecialPaymentGateway implements PaymentGateway {
    // Used in special cases with @Qualifier
}

// Consumer using default
@Service
public class OrderService {
    @Autowired
    private PaymentGateway gateway;  // Uses DefaultPaymentGateway
}

// Consumer using specific
@Service
public class SpecialOrderService {
    @Autowired
    public SpecialOrderService(
        @Qualifier("specialPaymentGateway") PaymentGateway gateway
    ) {
        this.gateway = gateway;  // Overrides @Primary
    }
}
```

### When to Use

| Scenario | Solution |
|----------|----------|
| Clear default | @Primary |
| No default | @Qualifier everywhere |
| Environment-specific | @Primary + @Profile |
| Special cases | @Primary + @Qualifier override |
| All equal | No @Primary, use @Qualifier |

**Next:** Circular Dependencies ‚Üí

