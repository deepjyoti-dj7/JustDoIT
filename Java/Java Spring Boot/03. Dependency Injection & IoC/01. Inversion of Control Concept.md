# üîÑ Inversion of Control (IoC) - Deep Dive

## üìã Table of Contents
- [What is Inversion of Control?](#what-is-inversion-of-control)
- [Traditional vs IoC Control Flow](#traditional-vs-ioc-control-flow)
- [The Hollywood Principle](#the-hollywood-principle)
- [Benefits of IoC](#benefits-of-ioc)
- [IoC Container](#ioc-container)
- [Types of IoC](#types-of-ioc)
- [IoC in Spring Framework](#ioc-in-spring-framework)
- [Real-World Examples](#real-world-examples)
- [Common Misconceptions](#common-misconceptions)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is Inversion of Control?

**Inversion of Control (IoC)** is a design principle where the **control flow** of a program is **inverted**: instead of the programmer controlling the flow, a **framework or container** controls it.

### Traditional Approach (You Call Framework)
```java
public class Application {
    public static void main(String[] args) {
        // YOU control the flow
        UserRepository repository = new UserRepositoryImpl();
        UserService service = new UserServiceImpl(repository);
        User user = service.findUser(1);
        System.out.println(user);
    }
}
```

### IoC Approach (Framework Calls You)
```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        // FRAMEWORK controls the flow
        SpringApplication.run(Application.class, args);
    }
}

@Service
public class UserService {
    private final UserRepository repository;
    
    // Framework calls your constructor
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

---

## üîÄ Traditional vs IoC Control Flow

### Traditional Control Flow (Procedural)

```java
public class OrderProcessor {
    public void processOrder(Long orderId) {
        // YOU create dependencies
        Database db = new MySQLDatabase();
        PaymentGateway payment = new StripePayment();
        EmailService email = new GmailService();
        
        // YOU control the flow
        Order order = db.getOrder(orderId);
        payment.charge(order.getAmount());
        email.sendConfirmation(order);
    }
}
```

**Problems:**
- ‚ùå Tight coupling to concrete implementations
- ‚ùå Hard to test (can't mock dependencies)
- ‚ùå Hard to change implementations
- ‚ùå No centralized configuration
- ‚ùå Difficult to manage object lifecycle

### IoC Control Flow

```java
@Service
public class OrderProcessor {
    private final Database database;
    private final PaymentGateway paymentGateway;
    private final EmailService emailService;
    
    // FRAMEWORK creates and injects dependencies
    public OrderProcessor(Database database, 
                         PaymentGateway paymentGateway,
                         EmailService emailService) {
        this.database = database;
        this.paymentGateway = paymentGateway;
        this.emailService = emailService;
    }
    
    public void processOrder(Long orderId) {
        // YOU just use the dependencies
        Order order = database.getOrder(orderId);
        paymentGateway.charge(order.getAmount());
        emailService.sendConfirmation(order);
    }
}
```

**Benefits:**
- ‚úÖ Loose coupling to interfaces
- ‚úÖ Easy to test (inject mocks)
- ‚úÖ Easy to change implementations
- ‚úÖ Centralized configuration
- ‚úÖ Framework manages lifecycle

---

## üé¨ The Hollywood Principle

> **"Don't call us, we'll call you"**

In traditional programming, **you call** the library/framework:
```java
// You call the library
List<String> list = new ArrayList<>();
list.add("item");
```

In IoC, **framework calls** your code:
```java
// Framework calls your method
@GetMapping("/users")
public List<User> getUsers() {
    return userService.findAll();
}
```

### Framework Callback Examples

```java
// 1. Lifecycle Callbacks
@PostConstruct
public void init() {
    // Framework calls this after construction
}

// 2. Event Listeners
@EventListener
public void handleUserCreated(UserCreatedEvent event) {
    // Framework calls this when event published
}

// 3. Bean Post Processors
public Object postProcessBeforeInitialization(Object bean, String name) {
    // Framework calls this before bean initialization
    return bean;
}

// 4. Request Handling
@GetMapping("/api/users/{id}")
public User getUser(@PathVariable Long id) {
    // Framework calls this when request received
    return userService.findById(id);
}
```

---

## ‚úÖ Benefits of IoC

### 1. **Loose Coupling**

```java
// Without IoC - Tightly coupled
public class UserService {
    private UserRepository repository = new MySQLUserRepository();
}

// With IoC - Loosely coupled
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository; // Can be ANY implementation
    }
}
```

### 2. **Easier Testing**

```java
// Easy to test with mocks
@Test
public void testUserService() {
    UserRepository mockRepo = Mockito.mock(UserRepository.class);
    when(mockRepo.findById(1L)).thenReturn(new User(1L, "John"));
    
    UserService service = new UserService(mockRepo);
    User user = service.findUser(1L);
    
    assertEquals("John", user.getName());
}
```

### 3. **Configuration Flexibility**

```java
@Configuration
public class AppConfig {
    @Bean
    @Profile("dev")
    public Database devDatabase() {
        return new H2Database();
    }
    
    @Bean
    @Profile("prod")
    public Database prodDatabase() {
        return new PostgreSQLDatabase();
    }
}
```

### 4. **Lifecycle Management**

```java
@Component
public class DatabaseConnection {
    @PostConstruct
    public void connect() {
        // Framework manages initialization
    }
    
    @PreDestroy
    public void disconnect() {
        // Framework manages cleanup
    }
}
```

### 5. **Aspect-Oriented Programming (AOP)**

```java
@Transactional  // Framework manages transaction
public void transferMoney(Account from, Account to, BigDecimal amount) {
    from.debit(amount);
    to.credit(amount);
}
```

---

## üèóÔ∏è IoC Container

An **IoC Container** is a framework that manages object creation, configuration, and lifecycle.

### Container Responsibilities

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       IoC Container                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Object Creation                  ‚îÇ
‚îÇ 2. Dependency Injection             ‚îÇ
‚îÇ 3. Lifecycle Management             ‚îÇ
‚îÇ 4. Configuration                    ‚îÇ
‚îÇ 5. Scope Management                 ‚îÇ
‚îÇ 6. AOP Proxy Creation               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Container Workflow

```java
// 1. Container starts
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// 2. Container reads configuration
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService(userRepository());
    }
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
}

// 3. Container creates beans
// 4. Container injects dependencies
// 5. Container manages lifecycle

// 6. You retrieve fully configured beans
UserService service = context.getBean(UserService.class);
```

---

## üé® Types of IoC

### 1. **Dependency Injection (Most Common)**

Framework injects dependencies into objects.

```java
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    // Constructor Injection
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

### 2. **Dependency Lookup (Less Common)**

Object looks up dependencies from container.

```java
public class OrderService {
    public void processOrder() {
        ApplicationContext context = ...; // Get context
        PaymentService paymentService = 
            context.getBean(PaymentService.class); // Lookup
    }
}
```

**Note:** Dependency Injection is preferred over Dependency Lookup.

### 3. **Template Method Pattern**

Framework defines algorithm structure, you provide implementations.

```java
// Framework provides template
@Transactional
public abstract class BaseService<T> {
    public void save(T entity) {
        validate(entity);        // Template step
        beforeSave(entity);      // Hook for subclass
        doSave(entity);          // Template step
        afterSave(entity);       // Hook for subclass
    }
    
    protected abstract void beforeSave(T entity);
    protected abstract void afterSave(T entity);
}

// You provide implementation
@Service
public class UserService extends BaseService<User> {
    @Override
    protected void beforeSave(User user) {
        user.setCreatedAt(LocalDateTime.now());
    }
    
    @Override
    protected void afterSave(User user) {
        eventPublisher.publish(new UserCreatedEvent(user));
    }
}
```

### 4. **Strategy Pattern**

Framework calls your strategies.

```java
public interface PaymentStrategy {
    void pay(BigDecimal amount);
}

@Component("creditCard")
public class CreditCardPayment implements PaymentStrategy {
    public void pay(BigDecimal amount) { }
}

@Component("paypal")
public class PayPalPayment implements PaymentStrategy {
    public void pay(BigDecimal amount) { }
}

@Service
public class PaymentService {
    private final Map<String, PaymentStrategy> strategies;
    
    public PaymentService(Map<String, PaymentStrategy> strategies) {
        this.strategies = strategies;
    }
    
    public void processPayment(String type, BigDecimal amount) {
        strategies.get(type).pay(amount);
    }
}
```

---

## üå± IoC in Spring Framework

### Spring IoC Container Types

```java
// 1. BeanFactory (Basic container)
BeanFactory factory = new XmlBeanFactory(
    new ClassPathResource("beans.xml")
);

// 2. ApplicationContext (Advanced - Recommended)
ApplicationContext context = 
    new AnnotationConfigApplicationContext(AppConfig.class);

// 3. WebApplicationContext (Web apps)
WebApplicationContext webContext = ...;
```

### Bean Definition Methods

#### Method 1: XML Configuration (Legacy)
```xml
<beans>
    <bean id="userService" class="com.example.UserService">
        <constructor-arg ref="userRepository"/>
    </bean>
    
    <bean id="userRepository" class="com.example.UserRepositoryImpl"/>
</beans>
```

#### Method 2: Java Configuration (Modern)
```java
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService(userRepository());
    }
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
}
```

#### Method 3: Annotation-Based (Most Common)
```java
@Service
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

@Repository
public class UserRepositoryImpl implements UserRepository {
}
```

### Spring IoC Lifecycle

```
1. Load Configuration
   ‚Üì
2. Create Bean Definitions
   ‚Üì
3. Instantiate Beans
   ‚Üì
4. Inject Dependencies
   ‚Üì
5. Aware Interfaces
   ‚Üì
6. BeanPostProcessor (Before)
   ‚Üì
7. Initialize Beans (@PostConstruct)
   ‚Üì
8. BeanPostProcessor (After)
   ‚Üì
9. Beans Ready for Use
   ‚Üì
10. Destroy Beans (@PreDestroy)
```

---

## üåç Real-World Examples

### Example 1: E-Commerce Order Processing

```java
// Without IoC
public class OrderProcessor {
    public void process(Order order) {
        MySQLDatabase db = new MySQLDatabase();
        StripePayment payment = new StripePayment();
        SMTPEmailService email = new SMTPEmailService();
        
        db.save(order);
        payment.charge(order.getTotal());
        email.send(order.getCustomer(), "Order confirmed");
    }
}
```

```java
// With IoC
@Service
public class OrderProcessor {
    private final Database database;
    private final PaymentGateway paymentGateway;
    private final EmailService emailService;
    
    public OrderProcessor(Database database,
                         PaymentGateway paymentGateway,
                         EmailService emailService) {
        this.database = database;
        this.paymentGateway = paymentGateway;
        this.emailService = emailService;
    }
    
    public void process(Order order) {
        database.save(order);
        paymentGateway.charge(order.getTotal());
        emailService.send(order.getCustomer(), "Order confirmed");
    }
}

@Configuration
public class AppConfig {
    @Bean
    public Database database() {
        return new MongoDatabase(); // Easy to change!
    }
    
    @Bean
    public PaymentGateway paymentGateway() {
        return new PayPalPayment(); // Easy to change!
    }
}
```

### Example 2: Notification System

```java
public interface NotificationService {
    void send(String message);
}

@Component
@Profile("dev")
public class ConsoleNotification implements NotificationService {
    public void send(String message) {
        System.out.println("Notification: " + message);
    }
}

@Component
@Profile("prod")
public class SmsNotification implements NotificationService {
    public void send(String message) {
        // Send actual SMS
    }
}

@Service
public class UserService {
    private final NotificationService notificationService;
    
    // IoC injects appropriate implementation based on profile
    public UserService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }
    
    public void registerUser(User user) {
        // Save user
        notificationService.send("Welcome " + user.getName());
    }
}
```

---

## ‚ö†Ô∏è Common Misconceptions

### Misconception 1: "IoC = Dependency Injection"
**Reality:** DI is a type of IoC. IoC is broader (includes template method, strategy pattern, etc.)

### Misconception 2: "IoC Container is Service Locator"
```java
// Service Locator (Anti-pattern)
public class UserService {
    public void doSomething() {
        PaymentService payment = 
            ServiceLocator.get(PaymentService.class); // BAD
    }
}

// Dependency Injection (Good)
public class UserService {
    private final PaymentService paymentService;
    
    public UserService(PaymentService paymentService) {
        this.paymentService = paymentService; // GOOD
    }
}
```

### Misconception 3: "IoC makes code slower"
**Reality:** Minimal overhead. Benefits (maintainability, testability) far outweigh small performance cost.

### Misconception 4: "Must use framework for IoC"
**Reality:** Can implement IoC manually, but frameworks provide convenience.

```java
// Manual IoC (Poor man's DI)
public class Main {
    public static void main(String[] args) {
        UserRepository repository = new UserRepositoryImpl();
        UserService service = new UserService(repository);
        OrderService orderService = new OrderService(service);
        
        // Manual dependency injection
    }
}
```

---

## üìå Best Practices

### 1. **Depend on Abstractions, Not Concretions**

```java
// ‚ùå Bad - Depends on concrete class
public class UserService {
    private final UserRepositoryImpl repository;
}

// ‚úÖ Good - Depends on interface
public class UserService {
    private final UserRepository repository;
}
```

### 2. **Use Constructor Injection (Preferred)**

```java
// ‚úÖ Immutable, testable, clear dependencies
@Service
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

### 3. **Keep Configuration Centralized**

```java
@Configuration
public class AppConfig {
    // All bean definitions in one place
    
    @Bean
    public UserService userService() { }
    
    @Bean
    public OrderService orderService() { }
}
```

### 4. **Use Profiles for Environment-Specific Beans**

```java
@Bean
@Profile("dev")
public DataSource devDataSource() {
    return new H2DataSource();
}

@Bean
@Profile("prod")
public DataSource prodDataSource() {
    return new PostgreSQLDataSource();
}
```

### 5. **Avoid Service Locator Pattern**

```java
// ‚ùå Avoid
public class UserService {
    public void doWork() {
        PaymentService payment = 
            ApplicationContextProvider.getBean(PaymentService.class);
    }
}

// ‚úÖ Use Dependency Injection
public class UserService {
    private final PaymentService paymentService;
    
    public UserService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

---

## üé§ Interview Questions

### Q1: What is Inversion of Control?
**Answer:** IoC is a design principle where the control flow is inverted - instead of your code controlling the program flow, a framework/container controls it. The framework calls your code ("Don't call us, we'll call you").

### Q2: What are the benefits of IoC?
**Answer:**
- Loose coupling
- Better testability
- Easier maintenance
- Flexible configuration
- Separation of concerns
- Lifecycle management

### Q3: Difference between IoC and Dependency Injection?
**Answer:** IoC is a broader concept - a design principle where control is inverted. DI is a specific implementation of IoC where dependencies are injected rather than created. DI is a type of IoC.

### Q4: What is the Hollywood Principle?
**Answer:** "Don't call us, we'll call you" - your code doesn't call the framework, the framework calls your code (callbacks, lifecycle methods, request handlers).

### Q5: Difference between BeanFactory and ApplicationContext?
**Answer:**
- BeanFactory: Basic container, lazy loading
- ApplicationContext: Advanced container, eager loading, supports events, i18n, AOP

ApplicationContext is preferred.

### Q6: How does Spring implement IoC?
**Answer:** Spring uses:
- DI (constructor, setter, field injection)
- IoC container (ApplicationContext)
- Bean definitions (@Component, @Bean)
- Lifecycle management (@PostConstruct, @PreDestroy)

### Q7: What is Service Locator pattern and why avoid it?
**Answer:** Service Locator looks up dependencies from a registry. Avoid because:
- Hides dependencies
- Hard to test
- Tight coupling to locator
- Violates IoC principle

Use DI instead.

### Q8: Can you implement IoC without a framework?
**Answer:** Yes, manually create and inject dependencies:
```java
UserRepository repo = new UserRepositoryImpl();
UserService service = new UserService(repo);
```
But frameworks provide convenience, lifecycle management, AOP, etc.

### Q9: What are the types of IoC?
**Answer:**
1. Dependency Injection (most common)
2. Dependency Lookup (less common)
3. Template Method Pattern
4. Strategy Pattern

### Q10: How does IoC improve testability?
**Answer:** Easy to inject mock/stub dependencies:
```java
UserRepository mockRepo = mock(UserRepository.class);
UserService service = new UserService(mockRepo);
// Test with controlled mock behavior
```

---

## üìö Summary

- **IoC** inverts control flow - framework calls your code
- **Hollywood Principle**: "Don't call us, we'll call you"
- **Benefits**: Loose coupling, testability, flexibility, lifecycle management
- **IoC Container**: Manages object creation, DI, and lifecycle
- **Spring IoC**: ApplicationContext, bean definitions, DI, AOP
- **Best Practice**: Use DI over Service Locator
- **DI is a type of IoC**, not the same thing

**Next:** Dependency Injection Types ‚Üí

