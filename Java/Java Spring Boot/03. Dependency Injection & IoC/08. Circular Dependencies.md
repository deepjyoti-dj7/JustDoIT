# üîÅ Circular Dependencies - Detection & Resolution

## üìã Table of Contents
- [What are Circular Dependencies?](#what-are-circular-dependencies)
- [How Spring Detects Circular Dependencies](#how-spring-detects-circular-dependencies)
- [Constructor Injection Problem](#constructor-injection-problem)
- [Resolution Strategies](#resolution-strategies)
- [Setter Injection Solution](#setter-injection-solution)
- [@Lazy Solution](#lazy-solution)
- [Redesign to Remove Circular Dependency](#redesign-to-remove-circular-dependency)
- [ObjectProvider and Provider](#objectprovider-and-provider)
- [ApplicationContextAware Solution](#applicationcontextaware-solution)
- [When Circular Dependencies are Acceptable](#when-circular-dependencies-are-acceptable)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What are Circular Dependencies?

**Circular dependency** occurs when two or more beans depend on each other, directly or indirectly.

### Direct Circular Dependency

```java
@Service
public class ServiceA {
    private final ServiceB serviceB;
    
    public ServiceA(ServiceB serviceB) {  // A depends on B
        this.serviceB = serviceB;
    }
}

@Service
public class ServiceB {
    private final ServiceA serviceA;
    
    public ServiceB(ServiceA serviceA) {  // B depends on A
        this.serviceA = serviceA;
    }
}

// Circular: A ‚Üí B ‚Üí A
```

### Indirect Circular Dependency

```java
@Service
public class ServiceA {
    public ServiceA(ServiceB serviceB) { }  // A ‚Üí B
}

@Service
public class ServiceB {
    public ServiceB(ServiceC serviceC) { }  // B ‚Üí C
}

@Service
public class ServiceC {
    public ServiceC(ServiceA serviceA) { }  // C ‚Üí A
}

// Circular: A ‚Üí B ‚Üí C ‚Üí A
```

---

## üîç How Spring Detects Circular Dependencies

### Bean Creation Process

```
1. Spring starts creating ServiceA
   ‚îú‚îÄ Constructor requires ServiceB
   ‚îú‚îÄ Spring starts creating ServiceB
   ‚îÇ  ‚îú‚îÄ Constructor requires ServiceA
   ‚îÇ  ‚îú‚îÄ ServiceA is already being created!
   ‚îÇ  ‚îî‚îÄ ‚ùå CIRCULAR DEPENDENCY DETECTED
   ‚îî‚îÄ Throws BeanCurrentlyInCreationException
```

### Error Message

```
Error creating bean with name 'serviceA': 
Requested bean is currently in creation: 
Is there an unresolvable circular reference?

***************************
APPLICATION FAILED TO START
***************************

Description:
The dependencies of some of the beans in the application context form a cycle:

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
|  serviceA defined in file [ServiceA.class]
‚Üë     ‚Üì
|  serviceB defined in file [ServiceB.class]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚õî Constructor Injection Problem

### The Problem

```java
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void createOrder(Order order) {
        paymentService.processPayment(order);
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    @Autowired
    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
    
    public void processPayment(Order order) {
        orderService.updateOrderStatus(order);
    }
}

// ‚ùå BeanCurrentlyInCreationException
```

### Why Constructor Injection Fails

```
Problem: Both beans need each other BEFORE construction completes

OrderService constructor needs PaymentService
   ‚Üì
PaymentService constructor needs OrderService
   ‚Üì
OrderService is still being constructed!
   ‚Üì
‚ùå Deadlock!
```

---

## üõ†Ô∏è Resolution Strategies

### 1. Setter Injection (Breaks the Cycle)
### 2. @Lazy (Defers Bean Creation)
### 3. Redesign (Best Solution)
### 4. ObjectProvider/Provider
### 5. ApplicationContextAware

---

## ‚öôÔ∏è Setter Injection Solution

### Converting to Setter Injection

```java
@Service
public class OrderService {
    private PaymentService paymentService;
    
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void createOrder(Order order) {
        paymentService.processPayment(order);
    }
}

@Service
public class PaymentService {
    private OrderService orderService;
    
    @Autowired
    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }
    
    public void processPayment(Order order) {
        orderService.updateOrderStatus(order);
    }
}

// ‚úÖ Works! Beans created first, then dependencies injected
```

### How It Works

```
1. Spring creates OrderService instance (no dependencies yet)
2. Spring creates PaymentService instance (no dependencies yet)
3. Spring injects PaymentService into OrderService via setter
4. Spring injects OrderService into PaymentService via setter
5. ‚úÖ Both beans ready
```

### Disadvantages

- ‚ùå Fields cannot be `final` (not immutable)
- ‚ùå Not thread-safe
- ‚ùå Object can exist in incomplete state
- ‚ö†Ô∏è Still a code smell - redesign is better

---

## üîÑ @Lazy Solution

### Using @Lazy Annotation

```java
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(@Lazy PaymentService paymentService) {
        this.paymentService = paymentService;  // Proxy injected
    }
    
    public void createOrder(Order order) {
        paymentService.processPayment(order);  // Real bean created here
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    @Autowired
    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
}

// ‚úÖ Works! @Lazy creates proxy, delaying actual bean creation
```

### How @Lazy Works

```
1. Spring starts creating OrderService
2. OrderService needs PaymentService
3. @Lazy creates a PROXY for PaymentService (not real bean)
4. OrderService created with proxy
5. Spring creates real PaymentService
6. PaymentService gets real OrderService (already created)
7. ‚úÖ Both beans ready
8. When OrderService calls paymentService.processPayment():
   - Proxy delegates to real PaymentService
```

### Advantages

- ‚úÖ Constructor injection (immutable)
- ‚úÖ Fields can be `final`
- ‚úÖ Minimal code changes

### Disadvantages

- ‚ùå Uses proxy (small overhead)
- ‚ùå Still a code smell
- ‚ö†Ô∏è First call creates bean (delayed initialization)

---

## üîß Redesign to Remove Circular Dependency

### The Root Problem

Circular dependencies usually indicate **poor design**:
- Tight coupling
- Single Responsibility Principle violation
- Incorrect abstraction

### Solution 1: Extract Common Logic

```java
// ‚ùå Bad: Circular dependency
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public void createOrder(Order order) {
        paymentService.processPayment(order);
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
    
    public void processPayment(Order order) {
        orderService.updateOrderStatus(order);
    }
}

// ‚úÖ Good: Extract common logic
@Service
public class OrderStatusService {
    public void updateStatus(Order order, OrderStatus status) {
        order.setStatus(status);
        // Save to database
    }
}

@Service
public class OrderService {
    private final OrderStatusService statusService;
    
    public OrderService(OrderStatusService statusService) {
        this.statusService = statusService;
    }
    
    public void createOrder(Order order) {
        statusService.updateStatus(order, OrderStatus.CREATED);
    }
}

@Service
public class PaymentService {
    private final OrderStatusService statusService;
    
    public PaymentService(OrderStatusService statusService) {
        this.statusService = statusService;
    }
    
    public void processPayment(Order order) {
        statusService.updateStatus(order, OrderStatus.PAID);
    }
}

// No circular dependency: OrderService ‚Üí StatusService ‚Üê PaymentService
```

### Solution 2: Event-Driven Architecture

```java
// ‚ùå Bad: Direct circular dependency
@Service
public class OrderService {
    private final PaymentService paymentService;
    
    public void createOrder(Order order) {
        paymentService.chargeCustomer(order);
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    public void chargeCustomer(Order order) {
        orderService.updateOrder(order);
    }
}

// ‚úÖ Good: Use events
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    
    public OrderService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public void createOrder(Order order) {
        // Create order
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Service
public class PaymentService {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = event.getOrder();
        chargeCustomer(order);
    }
    
    private void chargeCustomer(Order order) {
        // Process payment
    }
}

// No circular dependency!
```

### Solution 3: Use Interfaces

```java
// ‚ùå Bad: Concrete classes depend on each other
@Service
public class UserService {
    private final OrderService orderService;
    
    public UserService(OrderService orderService) {
        this.orderService = orderService;
    }
}

@Service
public class OrderService {
    private final UserService userService;
    
    public OrderService(UserService userService) {
        this.userService = userService;
    }
}

// ‚úÖ Good: Depend on interfaces
public interface UserProvider {
    User getUser(Long id);
}

public interface OrderProvider {
    List<Order> getUserOrders(Long userId);
}

@Service
public class UserService implements UserProvider {
    private final OrderProvider orderProvider;
    
    public UserService(OrderProvider orderProvider) {
        this.orderProvider = orderProvider;
    }
    
    public User getUser(Long id) {
        User user = findUser(id);
        List<Order> orders = orderProvider.getUserOrders(id);
        user.setOrders(orders);
        return user;
    }
}

@Service
public class OrderService implements OrderProvider {
    private final UserProvider userProvider;
    
    public OrderService(UserProvider userProvider) {
        this.userProvider = userProvider;
    }
    
    public List<Order> getUserOrders(Long userId) {
        User user = userProvider.getUser(userId);
        return findOrdersByUser(user);
    }
}

// Still circular, but cleaner separation
```

---

## üì¶ ObjectProvider and Provider

### Using ObjectProvider (Spring)

```java
@Service
public class OrderService {
    private final ObjectProvider<PaymentService> paymentServiceProvider;
    
    @Autowired
    public OrderService(ObjectProvider<PaymentService> paymentServiceProvider) {
        this.paymentServiceProvider = paymentServiceProvider;
    }
    
    public void createOrder(Order order) {
        PaymentService paymentService = paymentServiceProvider.getObject();
        paymentService.processPayment(order);
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    @Autowired
    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
}

// ‚úÖ Works! ObjectProvider defers bean resolution
```

### Using Provider (JSR-330)

```java
import javax.inject.Provider;

@Service
public class OrderService {
    private final Provider<PaymentService> paymentServiceProvider;
    
    @Autowired
    public OrderService(Provider<PaymentService> paymentServiceProvider) {
        this.paymentServiceProvider = paymentServiceProvider;
    }
    
    public void createOrder(Order order) {
        PaymentService paymentService = paymentServiceProvider.get();
        paymentService.processPayment(order);
    }
}
```

### Advantages

- ‚úÖ Constructor injection
- ‚úÖ Fields can be `final`
- ‚úÖ Lazy bean resolution

### Disadvantages

- ‚ùå Less readable
- ‚ùå Still a workaround, not a fix

---

## üîå ApplicationContextAware Solution

### Using ApplicationContextAware

```java
@Service
public class OrderService implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    
    public void createOrder(Order order) {
        PaymentService paymentService = 
            applicationContext.getBean(PaymentService.class);
        paymentService.processPayment(order);
    }
}

@Service
public class PaymentService {
    private final OrderService orderService;
    
    @Autowired
    public PaymentService(OrderService orderService) {
        this.orderService = orderService;
    }
}
```

### Disadvantages

- ‚ùå Service Locator anti-pattern
- ‚ùå Hides dependencies
- ‚ùå Hard to test
- ‚ùå **DO NOT USE** - worst solution!

---

## ‚ö†Ô∏è When Circular Dependencies are Acceptable

### Rarely Acceptable Cases

```java
// 1. Bidirectional JPA relationships
@Entity
public class User {
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Entity
public class Order {
    @ManyToOne
    private User user;
}

// 2. Parent-Child components in UI frameworks
@Component
public class ParentComponent {
    private ChildComponent child;
}

@Component
public class ChildComponent {
    private ParentComponent parent;
}

// 3. Event listener patterns
```

### Generally Unacceptable

- Service layer circular dependencies
- Business logic circular dependencies
- Repository circular dependencies

---

## üìå Best Practices

### 1. **Prefer Redesign Over Workarounds**

```java
// ‚ùå Workaround
@Service
public class ServiceA {
    @Autowired
    public ServiceA(@Lazy ServiceB serviceB) { }
}

// ‚úÖ Redesign - extract common logic
@Service
public class CommonService { }

@Service
public class ServiceA {
    @Autowired
    public ServiceA(CommonService common) { }
}

@Service
public class ServiceB {
    @Autowired
    public ServiceB(CommonService common) { }
}
```

### 2. **Use Events for Decoupling**

```java
// ‚úÖ Event-driven
@Service
public class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void createOrder(Order order) {
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

@Service
public class PaymentService {
    @EventListener
    public void onOrderCreated(OrderCreatedEvent event) {
        processPayment(event.getOrder());
    }
}
```

### 3. **Extract Interfaces**

```java
// ‚úÖ Depend on abstractions
public interface OrderRepository {
    Order save(Order order);
}

@Service
public class OrderService {
    private final OrderRepository repository;
    
    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }
}
```

### 4. **Identify Code Smells**

Circular dependencies often indicate:
- ‚ùå Tight coupling
- ‚ùå SRP violation
- ‚ùå Poor abstraction
- ‚ùå Missing intermediate layer

### 5. **Use @Lazy Only as Temporary Fix**

```java
// ‚ö†Ô∏è Temporary fix, plan to refactor
@Service
public class ServiceA {
    @Autowired
    public ServiceA(@Lazy ServiceB serviceB) {
        this.serviceB = serviceB;
    }
    // TODO: Refactor to remove circular dependency
}
```

### 6. **Document Circular Dependencies**

```java
/**
 * WARNING: Circular dependency with ServiceB
 * Using @Lazy as temporary workaround
 * JIRA ticket: TECH-1234 to refactor
 */
@Service
public class ServiceA {
    @Autowired
    public ServiceA(@Lazy ServiceB serviceB) { }
}
```

---

## üé§ Interview Questions

### Q1: What is a circular dependency?
**Answer:** When two or more beans depend on each other, directly or indirectly, creating a cycle in the dependency graph.

### Q2: How does Spring detect circular dependencies?
**Answer:** During bean creation, if Spring encounters a bean that's already being created, it throws `BeanCurrentlyInCreationException`.

### Q3: Why does constructor injection fail with circular dependencies?
**Answer:** Both constructors need their dependencies BEFORE construction completes, creating a deadlock. Spring can't create either bean.

### Q4: How to resolve circular dependencies?
**Answer:**
1. **Redesign** (best) - extract common logic, use events
2. **@Lazy** - inject proxy, defer bean creation
3. **Setter injection** - create beans first, inject later
4. **ObjectProvider** - lazy bean resolution
5. **ApplicationContextAware** (worst) - service locator pattern

### Q5: What is @Lazy solution?
**Answer:**
```java
@Autowired
public ServiceA(@Lazy ServiceB serviceB) {
    this.serviceB = serviceB;  // Proxy injected
}
```
Spring injects a proxy, deferring real bean creation.

### Q6: Setter injection vs @Lazy?
**Answer:**
| Setter Injection | @Lazy |
|-----------------|-------|
| Not immutable | Immutable (final) |
| No proxy | Uses proxy |
| Immediate injection | Deferred injection |

### Q7: Is circular dependency a code smell?
**Answer:** **Yes!** Usually indicates:
- Tight coupling
- Poor design
- Missing abstraction layer
- SRP violation

Redesign is better than workarounds.

### Q8: How to redesign to avoid circular dependencies?
**Answer:**
1. Extract common logic into third service
2. Use event-driven architecture
3. Introduce interfaces
4. Apply dependency inversion principle
5. Split responsibilities

### Q9: When are circular dependencies acceptable?
**Answer:** Rarely:
- JPA bidirectional relationships
- Parent-child UI components
- Framework-specific patterns

Never acceptable in business logic!

### Q10: What's the best solution?
**Answer:** **Redesign!**
```
Workarounds: @Lazy, setter injection, ObjectProvider
Best solution: Redesign to eliminate circular dependency
```

---

## üìö Summary

### Key Points

- **Circular dependency**: Beans depend on each other in a cycle
- **Constructor injection fails**: Deadlock during bean creation
- **Resolution strategies**: Setter, @Lazy, redesign, ObjectProvider
- **Best solution**: **Redesign** to eliminate circular dependency
- **Code smell**: Indicates poor design

### Resolution Strategies Ranked

```
1. ‚úÖ Redesign (BEST)
   - Extract common logic
   - Use events
   - Introduce interfaces

2. ‚ö†Ô∏è @Lazy (Temporary)
   - Quick fix
   - Plan to refactor

3. ‚ö†Ô∏è Setter Injection (Acceptable)
   - Loses immutability
   - Not thread-safe

4. ‚ö†Ô∏è ObjectProvider (Workaround)
   - Less readable
   - Defers problem

5. ‚ùå ApplicationContextAware (WORST)
   - Service Locator anti-pattern
   - Never use!
```

### Decision Tree

```
Circular dependency detected?
‚îú‚îÄ Can redesign?
‚îÇ  ‚îî‚îÄ ‚úÖ Redesign (extract logic, events, interfaces)
‚îú‚îÄ Temporary fix needed?
‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è Use @Lazy (plan refactoring)
‚îú‚îÄ Optional dependency?
‚îÇ  ‚îî‚îÄ ‚ö†Ô∏è Use setter injection
‚îî‚îÄ Framework constraint?
   ‚îî‚îÄ ‚ö†Ô∏è Use ObjectProvider
```

### Example: Best Solution

```java
// ‚ùå Circular dependency
@Service
public class OrderService {
    public OrderService(PaymentService payment) { }
}

@Service
public class PaymentService {
    public PaymentService(OrderService order) { }
}

// ‚úÖ Redesigned - extracted common logic
@Service
public class OrderStatusService {
    public void updateStatus(Order order) { }
}

@Service
public class OrderService {
    public OrderService(OrderStatusService status) { }
}

@Service
public class PaymentService {
    public PaymentService(OrderStatusService status) { }
}
```

**Circular dependencies are design problems. Fix the design, not the symptoms!**

---

**End of Topics** ‚Üí Now create comprehensive README

