# üíâ Dependency Injection Types - Complete Guide

## üìã Table of Contents
- [What is Dependency Injection?](#what-is-dependency-injection)
- [Types of Dependency Injection](#types-of-dependency-injection)
- [Constructor Injection](#constructor-injection)
- [Setter Injection](#setter-injection)
- [Field Injection](#field-injection)
- [Method Injection](#method-injection)
- [Interface Injection](#interface-injection)
- [Comparison Table](#comparison-table)
- [When to Use Each Type](#when-to-use-each-type)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ What is Dependency Injection?

**Dependency Injection (DI)** is a design pattern where an object receives its dependencies from external sources rather than creating them itself.

### Without DI (Tight Coupling)
```java
public class UserService {
    // Creates its own dependency - TIGHT COUPLING
    private UserRepository repository = new UserRepositoryImpl();
    
    public User findUser(Long id) {
        return repository.findById(id);
    }
}
```

**Problems:**
- ‚ùå Hard to test (can't mock repository)
- ‚ùå Hard to change implementation
- ‚ùå Violates Single Responsibility Principle

### With DI (Loose Coupling)
```java
public class UserService {
    private final UserRepository repository;
    
    // Dependency injected from outside - LOOSE COUPLING
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
    
    public User findUser(Long id) {
        return repository.findById(id);
    }
}
```

**Benefits:**
- ‚úÖ Easy to test (inject mocks)
- ‚úÖ Easy to change implementation
- ‚úÖ Follows SOLID principles
- ‚úÖ Better maintainability

---

## üî¢ Types of Dependency Injection

Spring supports **5 types** of dependency injection:

```
1. Constructor Injection (Recommended)
2. Setter Injection
3. Field Injection (Not Recommended)
4. Method Injection
5. Interface Injection (Rarely used)
```

---

## üèóÔ∏è Constructor Injection

Dependencies are provided through **class constructor**.

### Basic Example

```java
@Service
public class UserService {
    private final UserRepository repository;
    private final EmailService emailService;
    
    // Constructor injection
    @Autowired // Optional if single constructor
    public UserService(UserRepository repository, 
                      EmailService emailService) {
        this.repository = repository;
        this.emailService = emailService;
    }
    
    public void registerUser(User user) {
        repository.save(user);
        emailService.sendWelcomeEmail(user);
    }
}
```

### Spring 4.3+ - No @Autowired Required

```java
@Service
public class UserService {
    private final UserRepository repository;
    
    // @Autowired optional for single constructor
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

### Multiple Constructors

```java
@Service
public class UserService {
    private final UserRepository repository;
    private final EmailService emailService;
    
    // Primary constructor
    @Autowired
    public UserService(UserRepository repository, 
                      EmailService emailService) {
        this.repository = repository;
        this.emailService = emailService;
    }
    
    // Alternate constructor (not used by Spring)
    public UserService(UserRepository repository) {
        this(repository, new DefaultEmailService());
    }
}
```

### Lombok - Cleaner Syntax

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;
    private final EmailService emailService;
    
    // Constructor generated by Lombok
}
```

### Advantages ‚úÖ
- **Immutability**: Fields can be `final`
- **Mandatory Dependencies**: Clear which dependencies are required
- **Testability**: Easy to instantiate in tests
- **Fail-Fast**: Throws exception if dependency missing
- **Thread-Safe**: Immutable objects are thread-safe

### Disadvantages ‚ùå
- Many dependencies ‚Üí large constructor (code smell)
- Circular dependencies harder to resolve

---

## ‚öôÔ∏è Setter Injection

Dependencies are provided through **setter methods**.

### Basic Example

```java
@Service
public class UserService {
    private UserRepository repository;
    private EmailService emailService;
    
    // Setter injection
    @Autowired
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
    
    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

### Optional Dependencies

```java
@Service
public class UserService {
    private UserRepository repository;
    private EmailService emailService;
    
    @Autowired
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
    
    @Autowired(required = false)
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
    
    public void registerUser(User user) {
        repository.save(user);
        if (emailService != null) {
            emailService.sendWelcomeEmail(user);
        }
    }
}
```

### Java Config Style

```java
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        UserService service = new UserService();
        service.setRepository(userRepository());
        service.setEmailService(emailService());
        return service;
    }
}
```

### Advantages ‚úÖ
- **Optional Dependencies**: Can have default values
- **Reconfiguration**: Can change dependencies after creation
- **Readability**: Clear what's being set
- **Circular Dependencies**: Easier to resolve

### Disadvantages ‚ùå
- **Mutability**: Fields cannot be `final`
- **Incomplete Object**: Object can exist in invalid state
- **NullPointerException Risk**: If setter not called
- **Thread-Safety**: Need to handle synchronization

---

## üìå Field Injection

Dependencies are injected directly into **fields** using `@Autowired`.

### Basic Example

```java
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
    
    @Autowired
    private EmailService emailService;
    
    public void registerUser(User user) {
        repository.save(user);
        emailService.sendWelcomeEmail(user);
    }
}
```

### Optional Field Injection

```java
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
    
    @Autowired(required = false)
    private EmailService emailService;
}
```

### @Inject Alternative

```java
@Service
public class UserService {
    @Inject // JSR-330 standard
    private UserRepository repository;
}
```

### Advantages ‚úÖ
- **Concise**: Less boilerplate code
- **Quick**: Fast to write

### Disadvantages ‚ùå (Why You Should Avoid)
- **Hard to Test**: Cannot instantiate without Spring
- **Immutability**: Fields cannot be `final`
- **Hidden Dependencies**: Not visible in constructor
- **Tight Coupling**: Depends on Spring framework
- **IDE Warnings**: IntelliJ/Eclipse warn against it

### Testing Problem

```java
// Hard to test - requires Spring
@Test
public void testUserService() {
    UserService service = new UserService(); 
    // repository is NULL! Can't inject without Spring
}

// With constructor injection - easy to test
@Test
public void testUserService() {
    UserRepository mockRepo = mock(UserRepository.class);
    UserService service = new UserService(mockRepo); // Easy!
}
```

---

## üîß Method Injection

Dependencies are injected through **arbitrary methods** (not setters).

### Basic Example

```java
@Service
public class UserService {
    private UserRepository repository;
    private EmailService emailService;
    
    @Autowired
    public void initDependencies(UserRepository repository, 
                                EmailService emailService) {
        this.repository = repository;
        this.emailService = emailService;
    }
}
```

### Multiple Parameters

```java
@Service
public class OrderService {
    private UserRepository userRepository;
    private ProductRepository productRepository;
    private PaymentService paymentService;
    
    @Autowired
    public void configure(UserRepository userRepository,
                         ProductRepository productRepository,
                         PaymentService paymentService) {
        this.userRepository = userRepository;
        this.productRepository = productRepository;
        this.paymentService = paymentService;
    }
}
```

### Use Case: Complex Initialization

```java
@Service
public class ReportService {
    private DataSource dataSource;
    private TemplateEngine templateEngine;
    
    @Autowired
    public void setup(DataSource dataSource, 
                     TemplateEngine templateEngine) {
        this.dataSource = dataSource;
        this.templateEngine = templateEngine;
        
        // Additional initialization logic
        templateEngine.setDefaultEncoding("UTF-8");
        templateEngine.configure(dataSource);
    }
}
```

### Advantages ‚úÖ
- **Flexibility**: Can have initialization logic
- **Multiple Parameters**: Inject multiple dependencies at once
- **Semantic**: Method name conveys purpose

### Disadvantages ‚ùå
- **Unusual**: Less common, can confuse developers
- **Not Standard**: Constructor/Setter more conventional

---

## üîå Interface Injection

Dependencies implement an **injector interface** to receive dependencies.

### Example (Rarely Used in Spring)

```java
// Injector interface
public interface DatabaseInjector {
    void injectDatabase(Database database);
}

// Class implements injector
public class UserService implements DatabaseInjector {
    private Database database;
    
    @Override
    public void injectDatabase(Database database) {
        this.database = database;
    }
}
```

### Spring Aware Interfaces (Interface Injection)

```java
// Spring's built-in interface injection
@Service
public class CustomBean implements ApplicationContextAware {
    private ApplicationContext applicationContext;
    
    @Override
    public void setApplicationContext(ApplicationContext context) {
        this.applicationContext = context;
    }
}

// Other Aware interfaces
public class MyBean implements BeanNameAware, 
                               BeanFactoryAware,
                               EnvironmentAware {
    
    @Override
    public void setBeanName(String name) { }
    
    @Override
    public void setBeanFactory(BeanFactory beanFactory) { }
    
    @Override
    public void setEnvironment(Environment environment) { }
}
```

### Advantages ‚úÖ
- **Contract**: Interface defines injection contract
- **Type-Safe**: Compile-time checking

### Disadvantages ‚ùå
- **Intrusive**: Class must implement interface
- **Rarely Used**: Not common in modern Spring

---

## üìä Comparison Table

| Type | Immutability | Testability | Mandatory Deps | Optional Deps | Recommended |
|------|--------------|-------------|----------------|---------------|-------------|
| **Constructor** | ‚úÖ (final) | ‚úÖ Easy | ‚úÖ Clear | ‚ùå | ‚úÖ **YES** |
| **Setter** | ‚ùå | ‚úÖ Easy | ‚ùå | ‚úÖ Good | ‚ö†Ô∏è For optional |
| **Field** | ‚ùå | ‚ùå Hard | ‚ùå | ‚úÖ | ‚ùå **AVOID** |
| **Method** | ‚ùå | ‚úÖ Easy | ‚úÖ | ‚úÖ | ‚ö†Ô∏è Rare cases |
| **Interface** | ‚ùå | ‚úÖ Easy | ‚úÖ | ‚ùå | ‚ùå Rarely used |

### Detailed Comparison

```java
// 1. Constructor - RECOMMENDED
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository; // Immutable
    private final EmailService emailService;
}

// 2. Setter - For optional dependencies
@Service
public class UserService {
    private UserRepository repository;
    private EmailService emailService; // Optional
    
    @Autowired
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
    
    @Autowired(required = false)
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}

// 3. Field - AVOID
@Service
public class UserService {
    @Autowired
    private UserRepository repository; // Hard to test
}

// 4. Method - Rare
@Service
public class UserService {
    @Autowired
    public void configure(UserRepository repository) {
        this.repository = repository;
    }
}
```

---

## üéØ When to Use Each Type

### Use Constructor Injection When:
- ‚úÖ Dependency is **mandatory**
- ‚úÖ Want **immutability** (final fields)
- ‚úÖ Want **thread-safety**
- ‚úÖ Building **new objects**
- ‚úÖ **Most cases** - this is the default choice

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository repository;
    private final PaymentService paymentService;
}
```

### Use Setter Injection When:
- ‚úÖ Dependency is **optional**
- ‚úÖ Need **reconfiguration** after creation
- ‚úÖ Resolving **circular dependencies**
- ‚úÖ Framework requirements (e.g., legacy frameworks)

```java
@Service
public class EmailService {
    private TemplateEngine templateEngine;
    
    @Autowired(required = false)
    public void setTemplateEngine(TemplateEngine engine) {
        this.templateEngine = engine;
    }
}
```

### Avoid Field Injection (Use Constructor Instead)
```java
// ‚ùå Don't do this
@Service
public class UserService {
    @Autowired
    private UserRepository repository;
}

// ‚úÖ Do this instead
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;
}
```

### Use Method Injection When:
- ‚úÖ Need **complex initialization logic**
- ‚úÖ Injecting **multiple related dependencies**

```java
@Service
public class ReportService {
    @Autowired
    public void configureReporting(DataSource ds, 
                                  TemplateEngine te,
                                  EmailService email) {
        // Complex setup logic
    }
}
```

---

## üìå Best Practices

### 1. **Prefer Constructor Injection**

```java
// ‚úÖ Best Practice
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;
    private final EmailService emailService;
}
```

### 2. **Use Setter Only for Optional Dependencies**

```java
@Service
public class NotificationService {
    private final SmsService smsService; // Required
    private EmailService emailService;    // Optional
    
    public NotificationService(SmsService smsService) {
        this.smsService = smsService;
    }
    
    @Autowired(required = false)
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

### 3. **Avoid Field Injection**

```java
// ‚ùå Avoid
@Autowired
private UserRepository repository;

// ‚úÖ Use Constructor
private final UserRepository repository;

public UserService(UserRepository repository) {
    this.repository = repository;
}
```

### 4. **Keep Dependencies Minimal**

```java
// ‚ùå Too many dependencies - code smell
public UserService(A a, B b, C c, D d, E e, F f, G g) {
    // Consider refactoring
}

// ‚úÖ Reasonable number of dependencies
public UserService(UserRepository repo, EmailService email) {
    // Good
}
```

### 5. **Use @RequiredArgsConstructor (Lombok)**

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository repository;
    private final EmailService emailService;
    
    // Constructor auto-generated
}
```

### 6. **Validate Dependencies**

```java
@Service
public class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = Objects.requireNonNull(
            repository, "UserRepository cannot be null"
        );
    }
}
```

---

## üé§ Interview Questions

### Q1: What is Dependency Injection?
**Answer:** DI is a design pattern where objects receive dependencies from external sources rather than creating them. Promotes loose coupling, testability, and maintainability.

### Q2: What are the types of DI in Spring?
**Answer:**
1. Constructor Injection (recommended)
2. Setter Injection
3. Field Injection (avoid)
4. Method Injection
5. Interface Injection (rare)

### Q3: Constructor vs Setter Injection?
**Answer:**
| Constructor | Setter |
|-------------|--------|
| Immutable (final) | Mutable |
| Mandatory deps | Optional deps |
| Thread-safe | Not thread-safe |
| Fail-fast | Can be incomplete |

Use constructor for required, setter for optional.

### Q4: Why avoid Field Injection?
**Answer:**
- Hard to test (can't instantiate without Spring)
- Cannot be final (not immutable)
- Hidden dependencies
- Tight coupling to Spring
- IDE warnings

### Q5: How to inject optional dependencies?
**Answer:**
```java
@Autowired(required = false)
public void setEmailService(EmailService email) {
    this.emailService = email;
}

// Or use Optional
public UserService(UserRepository repo, 
                  Optional<EmailService> email) {
    this.emailService = email.orElse(new DefaultEmailService());
}
```

### Q6: Do you need @Autowired on constructor?
**Answer:** No, if there's only one constructor (Spring 4.3+). Required if multiple constructors.

### Q7: What is method injection?
**Answer:** Injecting dependencies through arbitrary methods (not setters). Useful for complex initialization but rarely used.

### Q8: Can constructor injection have circular dependencies?
**Answer:** Yes, causes BeanCurrentlyInCreationException. Solutions:
- Use setter injection
- Use @Lazy
- Redesign to remove circular dependency

### Q9: What is @RequiredArgsConstructor?
**Answer:** Lombok annotation that generates constructor for all `final` fields. Cleaner than writing constructor manually.

### Q10: How to test with Field Injection?
**Answer:** 
```java
// Hard - requires reflection
@Test
public void test() {
    UserService service = new UserService();
    ReflectionTestUtils.setField(service, "repository", mockRepo);
}

// Better - use constructor injection for easy testing
```

---

## üìö Summary

### Key Points
- **Constructor Injection**: Preferred for mandatory, immutable dependencies
- **Setter Injection**: For optional dependencies or reconfiguration
- **Field Injection**: **Avoid** - hard to test, not immutable
- **Method Injection**: For complex initialization (rare)
- **Interface Injection**: Rarely used in Spring

### Recommendation Matrix
```
Mandatory Dependency     ‚Üí Constructor Injection
Optional Dependency      ‚Üí Setter Injection
Quick Prototype         ‚Üí Field Injection (refactor later)
Complex Initialization  ‚Üí Method Injection
Spring Infrastructure   ‚Üí Interface Injection (Aware)
```

### Best Practice
```java
@Service
@RequiredArgsConstructor  // Lombok
public class UserService {
    private final UserRepository repository;  // Constructor injection
    private EmailService emailService;         // Optional
    
    @Autowired(required = false)
    public void setEmailService(EmailService email) {
        this.emailService = email;
    }
}
```

**Next:** Constructor vs Setter Injection ‚Üí

