# üíª Spring Boot CLI

## What is Spring Boot CLI?

**Spring Boot CLI (Command Line Interface)** is a command-line tool that allows you to quickly create, run, and test Spring Boot applications using Groovy scripts without the need for traditional project setup.

### Key Features
- **Rapid Prototyping** - Create apps in minutes
- **Groovy Support** - Less boilerplate than Java
- **Auto-imports** - Common Spring imports automatic
- **Embedded Dependencies** - Downloads dependencies on-the-fly
- **Quick Testing** - Test ideas without full project setup

## Installation

### Using SDKMAN (Recommended)
```bash
# Install SDKMAN
curl -s "https://get.sdkman.io" | bash

# Install Spring Boot CLI
sdk install springboot

# Verify installation
spring --version
```

### Using Homebrew (macOS)
```bash
# Add Spring tap
brew tap spring-io/tap

# Install Spring Boot CLI
brew install spring-boot

# Verify
spring --version
```

### Using Scoop (Windows)
```bash
scoop bucket add extras
scoop install springboot
```

### Manual Installation
1. Download from [spring.io](https://spring.io/tools)
2. Extract ZIP file
3. Add `bin` directory to PATH
4. Run `spring --version`

## Basic Commands

### Check Version
```bash
spring --version
# Spring CLI v3.2.0
```

### Help
```bash
spring help
spring help run
spring help init
```

### Run Groovy Script
```bash
spring run app.groovy
```

### Create New Project
```bash
spring init myproject
```

### Package as JAR
```bash
spring jar myapp.jar myapp.groovy
```

## Quick Start Example

### Hello World

**Create `hello.groovy`:**
```groovy
@RestController
class HelloController {
    
    @GetMapping("/")
    String hello() {
        "Hello from Spring Boot CLI!"
    }
}
```

**Run:**
```bash
spring run hello.groovy
```

**Access:** `http://localhost:8080`

### With Database

**Create `app.groovy`:**
```groovy
@Grab("h2")
@RestController
class UserController {
    
    @Autowired
    JdbcTemplate jdbc
    
    @PostConstruct
    void init() {
        jdbc.execute("CREATE TABLE users (id INT, name VARCHAR(50))")
        jdbc.execute("INSERT INTO users VALUES (1, 'John')")
    }
    
    @GetMapping("/users")
    List<Map<String, Object>> getUsers() {
        jdbc.queryForList("SELECT * FROM users")
    }
}
```

**Run:**
```bash
spring run app.groovy
```

## Spring Init (Project Generator)

### Basic Project
```bash
spring init myproject
cd myproject
./mvnw spring-boot:run
```

### With Dependencies
```bash
spring init --dependencies=web,data-jpa,h2 myproject
```

### List Available Dependencies
```bash
spring init --list
```

### Custom Configuration
```bash
spring init \
  --dependencies=web,data-jpa,security \
  --build=gradle \
  --java-version=17 \
  --packaging=jar \
  --groupId=com.example \
  --artifactId=myapp \
  --name=MyApplication \
  myapp
```

### Extract to Current Directory
```bash
spring init --extract demo
```

### Generate pom.xml Only
```bash
spring init --build=maven --format=project myproject
```

## Groovy Scripts

### Auto-imports
Spring CLI automatically imports common classes:

```groovy
// No need for imports!
@RestController
class MyController {
    
    @GetMapping("/")
    String home() {
        "Welcome!"
    }
}
```

**Automatically imported:**
- `org.springframework.web.bind.annotation.*`
- `org.springframework.stereotype.*`
- `org.springframework.boot.*`
- `javax.persistence.*`
- And many more...

### @Grab for Dependencies

```groovy
@Grab("h2")  // Add H2 database
@Grab("spring-boot-starter-actuator")  // Add Actuator

@RestController
class App {
    // Your code
}
```

### Multiple Files

```bash
spring run *.groovy
spring run app.groovy dao.groovy service.groovy
```

## Advanced Features

### Custom Port
```groovy
// app.groovy
@Configuration
@EnableAutoConfiguration
class App {
    @Bean
    WebServerFactoryCustomizer<ConfigurableWebServerFactory> portCustomizer() {
        return { factory -> factory.setPort(8081) }
    }
}

@RestController
class HelloController {
    @GetMapping("/")
    String hello() { "Hello on port 8081!" }
}
```

### With Properties
```groovy
// app.groovy
@Configuration
@ConfigurationProperties(prefix = "app")
class AppConfig {
    String name
    int version
}

@RestController
class InfoController {
    
    @Autowired
    AppConfig config
    
    @GetMapping("/info")
    String info() {
        "App: ${config.name}, Version: ${config.version}"
    }
}
```

**application.properties:**
```properties
app.name=MyApp
app.version=1
```

**Run:**
```bash
spring run app.groovy -- --app.name=CustomApp
```

### Testing Scripts

**test.groovy:**
```groovy
@SpringBootTest
class MyTests {
    
    @Autowired
    private TestRestTemplate rest
    
    @Test
    void testHome() {
        def response = rest.getForEntity("/", String.class)
        assert response.statusCode == HttpStatus.OK
        assert response.body == "Hello!"
    }
}
```

**Run tests:**
```bash
spring test test.groovy
```

## Packaging

### Create Executable JAR
```bash
spring jar myapp.jar myapp.groovy
```

### Run JAR
```bash
java -jar myapp.jar
```

### Include Multiple Files
```bash
spring jar myapp.jar *.groovy
```

### Include Resources
```bash
spring jar myapp.jar app.groovy static/ templates/
```

## Spring Shell Integration

### Interactive Mode
```bash
spring shell
```

**Inside shell:**
```bash
spring> run app.groovy
spring> grab spring-boot-starter-actuator
spring> jar myapp.jar app.groovy
spring> exit
```

## Real-World Examples

### REST API with CRUD

**app.groovy:**
```groovy
@Grab("h2")

@Entity
class User {
    @Id @GeneratedValue
    Long id
    String name
    String email
}

interface UserRepository extends JpaRepository<User, Long> {}

@RestController
@RequestMapping("/users")
class UserController {
    
    @Autowired
    UserRepository repo
    
    @GetMapping
    List<User> getAll() {
        repo.findAll()
    }
    
    @PostMapping
    User create(@RequestBody User user) {
        repo.save(user)
    }
    
    @GetMapping("/{id}")
    User getById(@PathVariable Long id) {
        repo.findById(id).orElseThrow()
    }
    
    @DeleteMapping("/{id}")
    void delete(@PathVariable Long id) {
        repo.deleteById(id)
    }
}
```

**Run:**
```bash
spring run app.groovy
```

### Scheduled Tasks

**scheduler.groovy:**
```groovy
@EnableScheduling
@Configuration
class SchedulerConfig {}

@Component
class ScheduledTasks {
    
    @Scheduled(fixedRate = 5000L)
    void reportCurrentTime() {
        println "The time is now ${new Date()}"
    }
    
    @Scheduled(cron = "0 0 * * * *")
    void hourlyTask() {
        println "Running hourly task"
    }
}
```

### File Upload

**upload.groovy:**
```groovy
@RestController
class FileController {
    
    @PostMapping("/upload")
    String upload(@RequestParam("file") MultipartFile file) {
        def filename = file.originalFilename
        file.transferTo(new File("/uploads/${filename}"))
        "Uploaded: ${filename}"
    }
}
```

## Configuration

### Custom Logging
```groovy
@Grab("spring-boot-starter-log4j2")

// logback.xml or log4j2.xml in classpath
```

### Profile-specific Scripts

**app.groovy:**
```groovy
@Profile("dev")
@Configuration
class DevConfig {
    @Bean
    String environment() { "Development" }
}

@Profile("prod")
@Configuration
class ProdConfig {
    @Bean
    String environment() { "Production" }
}
```

**Run with profile:**
```bash
spring run app.groovy -- --spring.profiles.active=dev
```

## Pros and Cons

### ‚úÖ Advantages
- **Rapid Prototyping** - Quick experimentation
- **Minimal Setup** - No project structure needed
- **Learning Tool** - Great for beginners
- **Scripting** - Automation tasks
- **Demos** - Quick demonstrations
- **Less Boilerplate** - Groovy syntax

### ‚ùå Disadvantages
- **Not Production-Ready** - Use for prototyping only
- **Limited IDE Support** - Less tooling
- **Groovy Dependency** - Need to learn Groovy
- **Performance** - Slower than compiled Java
- **Debugging** - Harder to debug
- **Team Collaboration** - Hard to maintain in teams

## When to Use Spring Boot CLI

### ‚úÖ Good For:
- Quick prototypes
- Learning Spring Boot
- Testing ideas
- Demos and presentations
- Simple automation scripts
- POC (Proof of Concept)

### ‚ùå Not Good For:
- Production applications
- Large projects
- Team development
- Applications requiring IDE support
- Complex business logic
- Long-term maintenance

## CLI vs Traditional Project

| Aspect | CLI (Groovy) | Traditional (Java) |
|--------|-------------|-------------------|
| **Setup Time** | Seconds | Minutes to hours |
| **Code Verbosity** | Low | Medium |
| **IDE Support** | Limited | Full |
| **Production Ready** | No | Yes |
| **Team Development** | Difficult | Easy |
| **Debugging** | Limited | Full |
| **Performance** | Lower | Higher |
| **Use Case** | Prototyping | Production |

## Common Commands Reference

```bash
# Version
spring --version

# Help
spring help
spring help init

# Run script
spring run app.groovy
spring run --watch app.groovy  # Auto-reload

# Initialize project
spring init myproject
spring init --list  # List options
spring init --dependencies=web,data-jpa myapp

# Create JAR
spring jar myapp.jar app.groovy

# Test
spring test test.groovy

# Grab dependencies
spring grab app.groovy

# Shell
spring shell

# Hints
spring hint
```

## Best Practices

1. ‚úÖ **Use for prototyping only** - Not for production
2. ‚úÖ **Keep scripts small** - One responsibility per file
3. ‚úÖ **Use @Grab wisely** - Don't overload dependencies
4. ‚úÖ **Add comments** - Groovy can be terse
5. ‚úÖ **Version control** - Track your scripts
6. ‚úÖ **Test ideas** - Perfect for experiments
7. ‚ùå **Don't use in production** - Migrate to Java project
8. ‚ùå **Don't over-engineer** - Keep it simple

## Interview Questions

**Q: What is Spring Boot CLI?**  
A: A command-line tool for rapid Spring Boot application development using Groovy scripts.

**Q: When to use Spring Boot CLI?**  
A: For prototyping, learning, demos, and quick testing. Not for production.

**Q: What language does CLI use?**  
A: Groovy, which has less boilerplate than Java.

**Q: Can CLI apps run in production?**  
A: Not recommended. Migrate to a traditional Java Spring Boot project.

**Q: How to create a project using CLI?**  
A: `spring init --dependencies=web myproject`

**Q: What is @Grab?**  
A: Groovy annotation to add dependencies dynamically.

## Key Takeaways

- CLI is for rapid prototyping, not production
- Uses Groovy for less boilerplate
- Auto-imports common Spring classes
- `spring init` generates traditional projects
- Great learning tool for beginners
- Limited IDE and debugging support
- Perfect for POCs and demos
- Migrate successful prototypes to Java projects
