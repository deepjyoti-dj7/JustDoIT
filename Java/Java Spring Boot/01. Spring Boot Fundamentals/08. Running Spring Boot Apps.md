# ▶️ Running Spring Boot Applications

## Running Methods

Spring Boot applications can be run in multiple ways depending on the environment and use case.

## 1. IDE (IntelliJ IDEA / Eclipse / VS Code)

### IntelliJ IDEA
```
1. Right-click on main class
2. Select "Run 'Application.main()'"
   OR
   Press Ctrl+Shift+F10 (Windows/Linux)
   Press Cmd+Shift+R (Mac)
```

### Eclipse
```
1. Right-click on main class
2. Select "Run As" → "Java Application"
   OR
   Press Ctrl+F11
```

### VS Code
```
1. Click "Run" button above main method
2. Or press F5
```

**Advantages:**
- ✅ Easy debugging
- ✅ Hot reload with DevTools
- ✅ Integrated console
- ✅ Best for development

## 2. Maven

### Run Directly (Development)
```bash
mvn spring-boot:run
```

### With Profiles
```bash
mvn spring-boot:run -Dspring-boot.run.profiles=dev
```

### With Arguments
```bash
mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=8081,--debug"
```

### With JVM Arguments
```bash
mvn spring-boot:run -Dspring-boot.run.jvmArguments="-Xmx1024m -Xdebug"
```

### Build and Run (Production)
```bash
# Clean and package
mvn clean package

# Run the JAR
java -jar target/myapp-1.0.0.jar
```

### Skip Tests
```bash
mvn clean package -DskipTests
```

## 3. Gradle

### Run Directly
```bash
./gradlew bootRun
```

### With Profiles
```bash
./gradlew bootRun --args='--spring.profiles.active=dev'
```

### Build and Run
```bash
# Build
./gradlew build

# Run
java -jar build/libs/myapp-1.0.0.jar
```

### Skip Tests
```bash
./gradlew build -x test
```

## 4. Command Line (JAR Execution)

### Basic Execution
```bash
java -jar myapp.jar
```

### With Profiles
```bash
java -jar myapp.jar --spring.profiles.active=prod
```

### With Properties
```bash
java -jar myapp.jar --server.port=8081 --logging.level.root=DEBUG
```

### With JVM Options
```bash
java -Xms512m -Xmx2048m -jar myapp.jar
```

### Background Execution (Linux/Mac)
```bash
# Run in background
nohup java -jar myapp.jar > app.log 2>&1 &

# Check process
ps aux | grep myapp

# Stop process
kill <PID>
```

### Background Execution (Windows)
```bash
# Using start
start /B java -jar myapp.jar

# Using PowerShell
Start-Process java -ArgumentList "-jar myapp.jar" -WindowStyle Hidden
```

## 5. Spring Boot DevTools

### Add Dependency
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

### Features
- **Automatic Restart** - On classpath changes
- **Live Reload** - Browser auto-refresh
- **Property Defaults** - Development-friendly defaults
- **H2 Console** - Enabled by default

### Configuration
```properties
# Disable restart
spring.devtools.restart.enabled=false

# Additional paths to watch
spring.devtools.restart.additional-paths=src/main/resources

# Exclude paths
spring.devtools.restart.exclude=static/**,public/**
```

## 6. Docker

### Dockerfile
```dockerfile
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/myapp-1.0.0.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Build Image
```bash
docker build -t myapp:1.0 .
```

### Run Container
```bash
docker run -p 8080:8080 myapp:1.0
```

### With Environment Variables
```bash
docker run -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -e SERVER_PORT=8080 \
  myapp:1.0
```

### Docker Compose
```yaml
version: '3.8'
services:
  app:
    image: myapp:1.0
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/mydb
    depends_on:
      - db
  db:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=secret
      - MYSQL_DATABASE=mydb
```

**Run:**
```bash
docker-compose up
```

## 7. Kubernetes

### Deployment YAML
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:1.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
---
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
  selector:
    app: myapp
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

**Deploy:**
```bash
kubectl apply -f deployment.yaml
```

## 8. Executable JAR/WAR

### Make JAR Executable (Linux/Mac)
```xml
<!-- pom.xml -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <executable>true</executable>
            </configuration>
        </plugin>
    </plugins>
</build>
```

**Run:**
```bash
chmod +x myapp.jar
./myapp.jar
```

### System Service (Linux)
```bash
# Create service file: /etc/systemd/system/myapp.service
[Unit]
Description=My Spring Boot App
After=syslog.target

[Service]
User=myapp
ExecStart=/var/myapp/myapp.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target
```

**Start service:**
```bash
sudo systemctl start myapp
sudo systemctl enable myapp  # Auto-start on boot
sudo systemctl status myapp
```

## 9. WAR Deployment (Traditional Server)

### Configure WAR Packaging
```xml
<packaging>war</packaging>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
    <scope>provided</scope>
</dependency>
```

### Extend SpringBootServletInitializer
```java
@SpringBootApplication
public class MyApplication extends SpringBootServletInitializer {
    
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(MyApplication.class);
    }
    
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

### Build WAR
```bash
mvn clean package
```

### Deploy to Tomcat
```bash
cp target/myapp.war /path/to/tomcat/webapps/
```

## Configuration by Environment

### Development
```bash
# Maven
mvn spring-boot:run -Dspring-boot.run.profiles=dev

# Java
java -jar myapp.jar --spring.profiles.active=dev
```

### Testing
```bash
java -jar myapp.jar --spring.profiles.active=test
```

### Production
```bash
java -jar \
  -Dspring.profiles.active=prod \
  -Xms512m -Xmx2048m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  myapp.jar
```

## Command-line Arguments

### Spring Boot Specific
```bash
java -jar myapp.jar \
  --server.port=8081 \
  --spring.datasource.url=jdbc:mysql://localhost/mydb \
  --logging.level.root=INFO
```

### Application Arguments
```bash
java -jar myapp.jar arg1 arg2 arg3
```

**Access in code:**
```java
@Component
public class MyRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) {
        List<String> nonOptionArgs = args.getNonOptionArgs();
        System.out.println("Args: " + nonOptionArgs);
    }
}
```

## Environment Variables

### Set Variables
```bash
# Linux/Mac
export SERVER_PORT=8081
export SPRING_PROFILES_ACTIVE=prod

# Windows
set SERVER_PORT=8081
set SPRING_PROFILES_ACTIVE=prod
```

### Use in Application
```bash
java -jar myapp.jar
# Reads SERVER_PORT and SPRING_PROFILES_ACTIVE
```

**Spring Boot converts:**
- `SERVER_PORT` → `server.port`
- `SPRING_PROFILES_ACTIVE` → `spring.profiles.active`

## JVM Tuning for Production

### Memory Settings
```bash
java -jar myapp.jar \
  -Xms512m              # Initial heap
  -Xmx2048m             # Max heap
  -XX:MetaspaceSize=128m \
  -XX:MaxMetaspaceSize=256m
```

### Garbage Collection
```bash
# G1GC (Recommended)
java -jar myapp.jar \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:InitiatingHeapOccupancyPercent=45

# ZGC (Low latency)
java -jar myapp.jar \
  -XX:+UseZGC \
  -XX:ZCollectionInterval=5
```

### GC Logging
```bash
java -jar myapp.jar \
  -Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=10M
```

### Debug Mode
```bash
java -jar myapp.jar \
  -Xdebug \
  -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005
```

## Health Check & Monitoring

### Actuator Endpoints
```bash
# Check health
curl http://localhost:8080/actuator/health

# Check info
curl http://localhost:8080/actuator/info

# Check metrics
curl http://localhost:8080/actuator/metrics
```

### Startup Check Script
```bash
#!/bin/bash
echo "Starting application..."
java -jar myapp.jar &
APP_PID=$!

# Wait for app to start
for i in {1..30}; do
  if curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; then
    echo "Application started successfully!"
    exit 0
  fi
  sleep 2
done

echo "Application failed to start"
kill $APP_PID
exit 1
```

## Comparison Table

| Method | Use Case | Pros | Cons |
|--------|----------|------|------|
| **IDE** | Development | Easy debug, hot reload | Not for production |
| **Maven/Gradle** | Dev/Build | Automated, clean | Slower than JAR |
| **JAR** | Production | Fast, portable | Manual setup |
| **Docker** | Containerized | Consistent env | Overhead |
| **Kubernetes** | Cloud/Scale | Auto-scaling, HA | Complex setup |
| **WAR** | Legacy servers | Existing infra | Not cloud-native |
| **Systemd** | Linux servers | Auto-restart | Linux only |

## Best Practices

1. ✅ **Use DevTools in development** - Fast feedback
2. ✅ **Run as JAR in production** - Lightweight
3. ✅ **Use profiles** - Different configs per environment
4. ✅ **Set JVM options** - Memory and GC tuning
5. ✅ **Use Docker** - Consistent deployments
6. ✅ **Monitor with Actuator** - Health checks
7. ✅ **Externalize configuration** - Don't hardcode
8. ❌ **Don't use IDE in production** - Not suitable
9. ❌ **Don't run without resource limits** - Can crash
10. ❌ **Don't ignore logs** - Monitor application logs

## Troubleshooting

### Port Already in Use
```bash
# Find process
lsof -i :8080  # Mac/Linux
netstat -ano | findstr :8080  # Windows

# Kill process
kill -9 <PID>  # Mac/Linux
taskkill /PID <PID> /F  # Windows

# Or change port
java -jar myapp.jar --server.port=8081
```

### Out of Memory
```bash
# Increase heap
java -Xmx2048m -jar myapp.jar
```

### Application Not Starting
```bash
# Enable debug
java -jar myapp.jar --debug

# Check logs
tail -f logs/spring.log
```

## Interview Questions

**Q: How to run Spring Boot application?**  
A: IDE, Maven/Gradle, JAR execution, Docker, Kubernetes, or as WAR on external server.

**Q: What is the recommended way for production?**  
A: Executable JAR with embedded server, ideally containerized with Docker.

**Q: How to change port?**  
A: `--server.port=8081` or `SERVER_PORT=8081` environment variable.

**Q: How to run with different profiles?**  
A: `--spring.profiles.active=prod` or `SPRING_PROFILES_ACTIVE=prod`

**Q: Difference between maven run and JAR execution?**  
A: Maven compiles and runs, JAR execution runs pre-built artifact (faster).

**Q: How to run in background on Linux?**  
A: `nohup java -jar myapp.jar &` or systemd service.

## Key Takeaways

- Multiple ways to run: IDE, Maven, JAR, Docker, Kubernetes
- Use DevTools for development (auto-restart)
- JAR execution is standard for production
- Docker provides environment consistency
- Use profiles for environment-specific configs
- Tune JVM for production (memory, GC)
- Monitor with Actuator endpoints
- Externalize configuration
- Use systemd for Linux services
