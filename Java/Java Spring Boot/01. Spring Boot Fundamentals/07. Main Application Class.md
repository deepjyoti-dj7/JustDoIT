# üöÄ Main Application Class

## What is the Main Application Class?

The **Main Application Class** is the entry point of every Spring Boot application. It contains the `main()` method that starts the Spring Boot application using `SpringApplication.run()`.

## Basic Structure

```java
package com.example.myapp;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

## @SpringBootApplication Annotation

This is a **convenience annotation** that combines three essential annotations:

```java
@SpringBootApplication = 
    @SpringBootConfiguration + 
    @EnableAutoConfiguration + 
    @ComponentScan
```

### Breakdown

#### 1. @SpringBootConfiguration
```java
@SpringBootConfiguration  // Equivalent to @Configuration
public class MyApplication {
    // This class can now define @Bean methods
}
```

**Purpose:** Indicates this is a configuration class.

#### 2. @EnableAutoConfiguration
```java
@EnableAutoConfiguration  // Enables auto-configuration magic
```

**Purpose:** Automatically configures beans based on classpath dependencies.

#### 3. @ComponentScan
```java
@ComponentScan  // Scans current package and sub-packages
```

**Purpose:** Scans for `@Component`, `@Service`, `@Repository`, `@Controller` classes.

### Explicit Declaration

```java
// These two are equivalent:

// Option 1: Using @SpringBootApplication
@SpringBootApplication
public class MyApplication { }

// Option 2: Using individual annotations
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
public class MyApplication { }
```

## SpringApplication.run()

### Simple Version
```java
public static void main(String[] args) {
    SpringApplication.run(MyApplication.class, args);
}
```

### Customized Version
```java
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MyApplication.class);
    
    // Customize application
    app.setBannerMode(Banner.Mode.OFF);
    app.setLogStartupInfo(false);
    app.setAdditionalProfiles("dev");
    
    // Run application
    app.run(args);
}
```

### With ConfigurableApplicationContext
```java
public static void main(String[] args) {
    ConfigurableApplicationContext context = 
        SpringApplication.run(MyApplication.class, args);
    
    // Access beans
    MyService service = context.getBean(MyService.class);
    service.doSomething();
    
    // Close context
    context.close();
}
```

## Customizing @SpringBootApplication

### Exclude Auto-configurations
```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    SecurityAutoConfiguration.class
})
public class MyApplication {
    // DataSource and Security won't be auto-configured
}
```

### Custom Component Scan
```java
@SpringBootApplication(scanBasePackages = {
    "com.example.myapp",
    "com.example.shared"
})
public class MyApplication {
    // Scans both packages
}
```

### Scan by Class
```java
@SpringBootApplication(scanBasePackageClasses = {
    MyController.class,
    MyService.class
})
public class MyApplication {
    // Scans packages of specified classes
}
```

### Exclude Components
```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@ComponentScan(excludeFilters = @Filter(
    type = FilterType.ASSIGNABLE_TYPE,
    classes = LegacyService.class
))
public class MyApplication {
    // LegacyService won't be scanned
}
```

## SpringApplication Customization

### 1. Banner Configuration

**Disable Banner:**
```java
app.setBannerMode(Banner.Mode.OFF);
```

**Custom Banner:**
Create `src/main/resources/banner.txt`:
```
  __  __                             
 |  \/  |_   _      /\               
 | |\/| | | | |    /  \   _ __  _ __ 
 | |  | | |_| |   / /\ \ | '_ \| '_ \
 |_|  |_|\__, |  / ____ \| |_) | |_) |
          __/ | /_/    \_\ .__/| .__/ 
         |___/           |_|   |_|    

Version: ${application.version}
Spring Boot: ${spring-boot.version}
```

**Programmatic Banner:**
```java
app.setBanner(new Banner() {
    @Override
    public void printBanner(Environment env, Class<?> sourceClass, PrintStream out) {
        out.println("=========================");
        out.println("   MY CUSTOM BANNER");
        out.println("=========================");
    }
});
```

### 2. Default Properties
```java
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MyApplication.class);
    
    Properties props = new Properties();
    props.setProperty("server.port", "8081");
    props.setProperty("spring.application.name", "myapp");
    app.setDefaultProperties(props);
    
    app.run(args);
}
```

### 3. Profiles
```java
app.setAdditionalProfiles("dev", "debug");
```

### 4. Lazy Initialization
```java
app.setLazyInitialization(true);  // Beans created on demand
```

### 5. Application Type
```java
// Force non-web application
app.setWebApplicationType(WebApplicationType.NONE);

// Reactive web
app.setWebApplicationType(WebApplicationType.REACTIVE);

// Servlet web (default)
app.setWebApplicationType(WebApplicationType.SERVLET);
```

### 6. Headless Mode
```java
app.setHeadless(true);  // For server applications
```

## SpringApplicationBuilder

**Fluent API** for building applications:

```java
public static void main(String[] args) {
    new SpringApplicationBuilder(MyApplication.class)
        .bannerMode(Banner.Mode.OFF)
        .profiles("dev")
        .properties("server.port=8081")
        .run(args);
}
```

### Parent-Child Contexts
```java
new SpringApplicationBuilder()
    .sources(ParentConfig.class)
    .child(WebConfig.class)
    .run(args);
```

## Application Events

### Built-in Events
```java
@Component
public class ApplicationStartupListener {
    
    @EventListener
    public void onApplicationStarting(ApplicationStartingEvent event) {
        System.out.println("Application is starting...");
    }
    
    @EventListener
    public void onApplicationReady(ApplicationReadyEvent event) {
        System.out.println("Application is ready!");
    }
    
    @EventListener
    public void onApplicationFailed(ApplicationFailedEvent event) {
        System.out.println("Application failed to start");
    }
}
```

### Event Sequence
```
1. ApplicationStartingEvent
2. ApplicationEnvironmentPreparedEvent
3. ApplicationContextInitializedEvent
4. ApplicationPreparedEvent
5. ContextRefreshedEvent
6. ApplicationStartedEvent
7. ApplicationReadyEvent
```

### Custom Listener
```java
public class MyApplicationListener implements ApplicationListener<ApplicationReadyEvent> {
    
    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        System.out.println("Application is ready!");
    }
}
```

**Register:**
```java
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MyApplication.class);
    app.addListeners(new MyApplicationListener());
    app.run(args);
}
```

## CommandLineRunner & ApplicationRunner

### CommandLineRunner
**Execute code after application starts:**

```java
@SpringBootApplication
public class MyApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
    
    @Bean
    public CommandLineRunner commandLineRunner() {
        return args -> {
            System.out.println("Application started!");
            System.out.println("Args: " + Arrays.toString(args));
        };
    }
}
```

### ApplicationRunner
**Better API for arguments:**

```java
@Component
public class MyApplicationRunner implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("Non-option args: " + args.getNonOptionArgs());
        System.out.println("Option names: " + args.getOptionNames());
        
        if (args.containsOption("debug")) {
            System.out.println("Debug mode enabled");
        }
    }
}
```

### Multiple Runners with Order
```java
@Component
@Order(1)
public class FirstRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("First runner");
    }
}

@Component
@Order(2)
public class SecondRunner implements CommandLineRunner {
    @Override
    public void run(String... args) {
        System.out.println("Second runner");
    }
}
```

## Exit Codes

### Custom Exit Code
```java
@SpringBootApplication
public class MyApplication implements ExitCodeGenerator {
    
    public static void main(String[] args) {
        System.exit(SpringApplication.exit(
            SpringApplication.run(MyApplication.class, args)
        ));
    }
    
    @Override
    public int getExitCode() {
        return 42;  // Custom exit code
    }
}
```

### Exception Exit Code
```java
@Component
public class MyExitCodeExceptionMapper 
        implements ExitCodeExceptionMapper {
    
    @Override
    public int getExitCode(Throwable exception) {
        if (exception instanceof DataAccessException) {
            return 100;
        }
        return 1;
    }
}
```

## Main Class Location

### ‚úÖ Correct: Root Package
```
com.example.myapp
‚îî‚îÄ‚îÄ MyApplication.java      # Main class here
    ‚îú‚îÄ‚îÄ controller/
    ‚îú‚îÄ‚îÄ service/
    ‚îî‚îÄ‚îÄ repository/
```

**Why?** Component scanning starts here and scans all sub-packages.

### ‚ùå Incorrect: Nested Package
```
com.example.myapp
‚îú‚îÄ‚îÄ controller/
‚îú‚îÄ‚îÄ service/
‚îî‚îÄ‚îÄ config/
    ‚îî‚îÄ‚îÄ MyApplication.java  # Wrong!
```

**Problem:** Components in sibling packages won't be scanned.

**Fix:**
```java
@SpringBootApplication(scanBasePackages = "com.example.myapp")
public class MyApplication {
    // Explicit scan from root
}
```

## Advanced Examples

### Multiple Data Sources
```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class MultiDataSourceApp {
    
    public static void main(String[] args) {
        SpringApplication.run(MultiDataSourceApp.class, args);
    }
}
```

### Web and Batch Application
```java
@SpringBootApplication
@EnableBatchProcessing
public class WebAndBatchApp {
    
    public static void main(String[] args) {
        SpringApplication.run(WebAndBatchApp.class, args);
    }
}
```

### Scheduled Tasks
```java
@SpringBootApplication
@EnableScheduling
public class ScheduledApp {
    
    public static void main(String[] args) {
        SpringApplication.run(ScheduledApp.class, args);
    }
}
```

### Async Processing
```java
@SpringBootApplication
@EnableAsync
public class AsyncApp {
    
    public static void main(String[] args) {
        SpringApplication.run(AsyncApp.class, args);
    }
}
```

## Common Patterns

### Configuration Class
```java
@SpringBootApplication
public class MyApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### Property Binding
```java
@SpringBootApplication
@ConfigurationPropertiesScan
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

## Best Practices

1. ‚úÖ **Place in root package** - Enables automatic component scanning
2. ‚úÖ **Keep it simple** - Minimal logic in main class
3. ‚úÖ **Use CommandLineRunner** - For startup tasks
4. ‚úÖ **Use @ConfigurationPropertiesScan** - For external configuration
5. ‚úÖ **Add @EnableXxx annotations** - As needed (scheduling, async, etc.)
6. ‚ùå **Don't add business logic** - Keep main class clean
7. ‚ùå **Don't create beans unnecessarily** - Use @Configuration classes
8. ‚ùå **Don't nest in sub-package** - Component scanning issues

## Interview Questions

**Q: What is the purpose of the main class?**  
A: Entry point of Spring Boot application that bootstraps the application context.

**Q: What does @SpringBootApplication do?**  
A: Combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.

**Q: Where should main class be located?**  
A: In the root package to enable automatic component scanning of sub-packages.

**Q: Difference between CommandLineRunner and ApplicationRunner?**  
A: Both execute code after startup, but ApplicationRunner provides better argument parsing API.

**Q: How to exclude auto-configuration?**  
A: Use `exclude` parameter in @SpringBootApplication.

**Q: Can we have multiple main classes?**  
A: Yes, but only one should be executed at runtime.

**Q: How to customize banner?**  
A: Create banner.txt in resources or use setBanner() method.

## Key Takeaways

- Main class = Entry point with `main()` method
- @SpringBootApplication = Meta-annotation combining 3 annotations
- Must be in root package for component scanning
- SpringApplication.run() bootstraps the application
- Customizable via SpringApplication or SpringApplicationBuilder
- CommandLineRunner for startup tasks
- Keep main class simple and clean
- Use @EnableXxx for enabling features
