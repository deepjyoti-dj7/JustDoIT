# ⚙️ Auto-configuration

## What is Auto-configuration?

**Auto-configuration** is Spring Boot's ability to automatically configure your application based on the JAR dependencies present on the classpath. It attempts to guess and configure beans that you are likely to need.

### Core Principle
> "If you have `spring-boot-starter-data-jpa` on classpath, Spring Boot will automatically configure a DataSource, EntityManagerFactory, and TransactionManager for you."

## How It Works

### 1. **Classpath Scanning**
Spring Boot scans the classpath for specific classes and libraries.

```java
// If this class is found on classpath:
org.springframework.jdbc.core.JdbcTemplate

// Then Spring Boot auto-configures:
// - DataSource
// - JdbcTemplate
// - Transaction Manager
```

### 2. **Conditional Configuration**
Uses `@Conditional` annotations to decide what to configure.

```java
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
public class DataSourceAutoConfiguration {
    
    @Bean
    public DataSource dataSource() {
        // Auto-configure DataSource
    }
}
```

### 3. **Apply Defaults**
Applies sensible default configurations.

```properties
# Default configurations applied automatically
server.port=8080
spring.jpa.show-sql=false
spring.jackson.serialization.indent-output=false
```

### 4. **Override Capability**
You can override any auto-configuration.

```properties
# Override defaults
server.port=9090
spring.jpa.show-sql=true
```

## Auto-configuration Process

```
┌─────────────────────────────────────────┐
│  1. Spring Boot Starts                  │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  2. Scan Classpath for Dependencies     │
│     - JARs                              │
│     - Classes                           │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  3. Check Conditions                    │
│     - @ConditionalOnClass               │
│     - @ConditionalOnMissingBean         │
│     - @ConditionalOnProperty            │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  4. Create & Configure Beans            │
│     - DataSource                        │
│     - EntityManager                     │
│     - Transaction Manager               │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  5. Application Ready                   │
└─────────────────────────────────────────┘
```

## @EnableAutoConfiguration

The core annotation that enables auto-configuration.

```java
@EnableAutoConfiguration
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**Note:** `@SpringBootApplication` includes `@EnableAutoConfiguration`

```java
@SpringBootApplication  // Contains @EnableAutoConfiguration
public class Application {
    // ...
}
```

## Common Auto-configurations

### 1. Web Applications

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

**Auto-configured:**
- Embedded Tomcat server
- DispatcherServlet
- Error page
- Jackson for JSON
- HTTP message converters

### 2. Data JPA

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

**Auto-configured:**
- DataSource
- EntityManagerFactory
- JpaTransactionManager
- Spring Data JPA repositories

### 3. Security

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**Auto-configured:**
- Default login page
- Basic authentication
- CSRF protection
- Security filter chain

### 4. Actuator

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Auto-configured:**
- Health endpoint
- Metrics endpoint
- Info endpoint
- Monitoring capabilities

## Conditional Annotations

### @ConditionalOnClass
Configure only if specific class exists on classpath.

```java
@Configuration
@ConditionalOnClass(DataSource.class)
public class DatabaseConfig {
    
    @Bean
    public DataSource dataSource() {
        // Only created if DataSource.class is present
    }
}
```

### @ConditionalOnMissingBean
Configure only if bean is not already defined.

```java
@Configuration
public class CustomDataSourceConfig {
    
    @Bean
    @ConditionalOnMissingBean
    public DataSource dataSource() {
        // Only created if no DataSource bean exists
        return new HikariDataSource();
    }
}
```

### @ConditionalOnProperty
Configure based on property value.

```java
@Configuration
@ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true")
public class FeatureConfig {
    
    @Bean
    public FeatureService featureService() {
        // Only created if app.feature.enabled=true
    }
}
```

### @ConditionalOnMissingClass
Configure only if specific class is NOT present.

```java
@Configuration
@ConditionalOnMissingClass("com.example.CustomLogger")
public class DefaultLoggerConfig {
    
    @Bean
    public Logger logger() {
        // Created only if CustomLogger not found
    }
}
```

### @ConditionalOnBean
Configure only if specific bean exists.

```java
@Configuration
public class SecondaryConfig {
    
    @Bean
    @ConditionalOnBean(DataSource.class)
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        // Created only if DataSource bean exists
        return new JdbcTemplate(dataSource);
    }
}
```

### @ConditionalOnResource
Configure if specific resource exists.

```java
@Configuration
@ConditionalOnResource(resources = "classpath:custom-config.xml")
public class CustomConfig {
    // ...
}
```

### @ConditionalOnWebApplication
Configure only for web applications.

```java
@Configuration
@ConditionalOnWebApplication
public class WebConfig {
    // Only for web applications
}
```

## Viewing Auto-configuration Report

### Method 1: Debug Mode
```properties
# application.properties
debug=true
```

### Method 2: Command Line
```bash
java -jar myapp.jar --debug
```

### Method 3: Actuator
```properties
management.endpoints.web.exposure.include=conditions
```
Access: `http://localhost:8080/actuator/conditions`

### Sample Report Output
```
============================
CONDITIONS EVALUATION REPORT
============================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required class 'javax.sql.DataSource' (OnClassCondition)
      
   JpaRepositoriesAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.data.jpa.repository.JpaRepository' (OnClassCondition)

Negative matches:
-----------------
   MongoAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'com.mongodb.client.MongoClient' (OnClassCondition)

Exclusions:
-----------
   None

Unconditional classes:
----------------------
   org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration
```

## Disabling Auto-configuration

### Method 1: Exclude in @SpringBootApplication
```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    SecurityAutoConfiguration.class
})
public class Application {
    // DataSource and Security not auto-configured
}
```

### Method 2: Using Properties
```properties
# application.properties
spring.autoconfigure.exclude=\
  org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
  org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
```

### Method 3: @EnableAutoConfiguration
```java
@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
public class Application {
    // ...
}
```

## Custom Auto-configuration

### Step 1: Create Auto-configuration Class
```java
@Configuration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(MyServiceProperties.class)
public class MyServiceAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public MyService myService(MyServiceProperties properties) {
        return new MyService(properties.getApiKey());
    }
}
```

### Step 2: Create Properties Class
```java
@ConfigurationProperties(prefix = "myservice")
public class MyServiceProperties {
    
    private String apiKey;
    private int timeout = 5000;
    
    // Getters and setters
}
```

### Step 3: Register Auto-configuration
Create `META-INF/spring.factories`:
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfigure.MyServiceAutoConfiguration
```

### Step 4: Usage
```properties
# application.properties
myservice.api-key=abc123
myservice.timeout=10000
```

```java
@Autowired
private MyService myService; // Auto-configured!
```

## Auto-configuration Examples

### Example 1: DataSource Auto-configuration

**Scenario:** Add H2 database dependency

```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

**Auto-configured:**
```java
// Spring Boot automatically creates:
// 1. DataSource with H2 connection
// 2. JdbcTemplate
// 3. Transaction Manager

@Autowired
private DataSource dataSource; // Ready to use!
```

### Example 2: RestTemplate Auto-configuration

**Configuration:**
```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @ConditionalOnMissingBean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
}
```

**Usage:**
```java
@Autowired
private RestTemplate restTemplate; // Auto-configured
```

### Example 3: Thymeleaf Auto-configuration

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

**Auto-configured:**
- Template engine
- View resolver
- Default prefix: `classpath:/templates/`
- Default suffix: `.html`

## Common Auto-configuration Classes

| Class | Purpose |
|-------|---------|
| `DataSourceAutoConfiguration` | Database connections |
| `JpaRepositoriesAutoConfiguration` | JPA repositories |
| `WebMvcAutoConfiguration` | Spring MVC |
| `SecurityAutoConfiguration` | Spring Security |
| `JacksonAutoConfiguration` | JSON processing |
| `RedisAutoConfiguration` | Redis cache |
| `KafkaAutoConfiguration` | Apache Kafka |
| `MongoAutoConfiguration` | MongoDB |

## Best Practices

1. ✅ **Understand what's auto-configured** - Use debug mode
2. ✅ **Override selectively** - Only override when necessary
3. ✅ **Use @ConditionalOnMissingBean** - Allow users to override
4. ✅ **Provide properties** - Make configurations customizable
5. ✅ **Document auto-configurations** - Especially for libraries
6. ✅ **Test with/without dependencies** - Ensure conditions work
7. ❌ **Don't fight auto-configuration** - Work with it, not against it
8. ❌ **Don't disable everything** - Defeats the purpose

## Troubleshooting

### Problem: Bean Not Created
```java
// Check if dependency is on classpath
// Enable debug mode to see why
debug=true
```

### Problem: Wrong Bean Type
```java
// Define your own bean - auto-configuration will back off
@Bean
public DataSource dataSource() {
    return new CustomDataSource();
}
```

### Problem: Configuration Conflicts
```java
// Exclude conflicting auto-configuration
@SpringBootApplication(exclude = ConflictingAutoConfiguration.class)
```

## Interview Questions

**Q: What is auto-configuration in Spring Boot?**  
A: Automatic configuration of beans based on classpath dependencies using conditional annotations.

**Q: How does Spring Boot know what to auto-configure?**  
A: It scans the classpath for classes and uses @Conditional annotations to decide.

**Q: Can auto-configuration be disabled?**  
A: Yes, using exclude in @SpringBootApplication or spring.autoconfigure.exclude property.

**Q: What is @ConditionalOnMissingBean?**  
A: Configures a bean only if no bean of that type exists, allowing user overrides.

**Q: How to see what's auto-configured?**  
A: Enable debug mode or use Actuator's /conditions endpoint.

**Q: What happens if multiple auto-configurations conflict?**  
A: Use @Order, @Primary, or exclude one of them.

## Key Takeaways

- Auto-configuration = Smart defaults based on classpath
- Uses @Conditional annotations for decision-making
- Can be overridden easily
- Debug mode shows what's configured
- Follow conventions for best results
- Custom auto-configuration is possible
- Makes Spring Boot "opinionated but flexible"
