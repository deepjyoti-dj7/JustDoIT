# Spring Data JPA Interview Questions

---

## 1. JPA Fundamentals

### Q1: What is JPA?
**Answer:**
JPA (Java Persistence API) is a specification for ORM (Object-Relational Mapping) in Java.

**Key Features:**
- Maps Java objects to database tables
- Provides entity lifecycle management
- Supports JPQL (Java Persistence Query Language)
- Vendor-independent

**Implementation:** Hibernate (most popular), EclipseLink, OpenJPA

**Example:**
```java
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(unique = true)
    private String email;
    
    // Getters and setters
}
```

---

### Q2: What is Spring Data JPA?
**Answer:**
Spring Data JPA is an abstraction layer on top of JPA that simplifies data access.

**Benefits:**
- Reduces boilerplate code
- Provides repository pattern
- Query derivation from method names
- Pagination and sorting support
- Custom queries with @Query

**Example:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    // Query derivation
    List<User> findByName(String name);
    Optional<User> findByEmail(String email);
    List<User> findByAgeGreaterThan(int age);
    
    // Custom query
    @Query("SELECT u FROM User u WHERE u.email LIKE %:domain%")
    List<User> findByEmailDomain(@Param("domain") String domain);
}
```

---

### Q3: JpaRepository vs CrudRepository vs PagingAndSortingRepository?
**Answer:**

| Repository | Methods | Features |
|------------|---------|----------|
| CrudRepository | Basic CRUD | save, findById, delete |
| PagingAndSortingRepository | + Pagination | findAll(Pageable), findAll(Sort) |
| JpaRepository | + Batch operations | saveAll, flush, deleteInBatch |

**Hierarchy:**
```
Repository
    ↓
CrudRepository (save, findById, delete, findAll, count)
    ↓
PagingAndSortingRepository (+ pagination, sorting)
    ↓
JpaRepository (+ batch operations, flush)
```

**Example:**
```java
// CrudRepository - Basic operations
public interface ProductRepository extends CrudRepository<Product, Long> {
    // save, findById, delete, etc.
}

// PagingAndSortingRepository - With pagination
public interface OrderRepository extends PagingAndSortingRepository<Order, Long> {
    Page<Order> findAll(Pageable pageable);
}

// JpaRepository - Full featured (Recommended)
public interface UserRepository extends JpaRepository<User, Long> {
    // All above methods + flush, saveAllAndFlush, deleteInBatch
}
```

---

### Q4: Entity lifecycle states?
**Answer:**

**Four States:**
1. **Transient:** New object, not associated with persistence context
2. **Persistent (Managed):** Associated with persistence context, tracked
3. **Detached:** Was persistent, no longer tracked
4. **Removed:** Marked for deletion

**Example:**
```java
@Service
public class UserService {
    
    @Autowired
    private EntityManager entityManager;
    
    @Transactional
    public void demonstrateLifecycle() {
        // 1. Transient - new object
        User user = new User();
        user.setName("John");
        
        // 2. Persistent - managed by persistence context
        entityManager.persist(user);
        user.setEmail("john@example.com");  // Tracked, will be updated
        
        // 3. Detached - remove from persistence context
        entityManager.detach(user);
        user.setName("Jane");  // Not tracked, won't be updated
        
        // 4. Merge - attach detached entity
        User managed = entityManager.merge(user);  // Now tracked again
        
        // 5. Removed - marked for deletion
        entityManager.remove(managed);
    }
}
```

---

### Q5: @Entity annotation and requirements?
**Answer:**

**Requirements:**
1. Must have @Entity annotation
2. Must have no-arg constructor (public or protected)
3. Cannot be final class
4. Persistent fields cannot be final

**Example:**
```java
@Entity
@Table(name = "products", 
       indexes = {@Index(name = "idx_name", columnList = "name")},
       uniqueConstraints = {@UniqueConstraint(columnNames = {"sku"})})
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 200)
    private String name;
    
    @Column(unique = true)
    private String sku;
    
    @Column(precision = 10, scale = 2)
    private BigDecimal price;
    
    @Enumerated(EnumType.STRING)
    private ProductStatus status;
    
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdAt;
    
    @Lob
    private String description;
    
    @Transient  // Not persisted
    private String tempData;
    
    // No-arg constructor (required)
    protected Product() {}
    
    public Product(String name, String sku) {
        this.name = name;
        this.sku = sku;
    }
    
    // Getters and setters
}
```

---

## 2. Relationships

### Q6: Types of JPA relationships?
**Answer:**

1. **@OneToOne:** One entity maps to one entity
2. **@OneToMany:** One entity maps to many entities
3. **@ManyToOne:** Many entities map to one entity
4. **@ManyToMany:** Many entities map to many entities

**Example:**
```java
// @OneToOne
@Entity
public class User {
    @Id
    private Long id;
    
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
    private Profile profile;
}

@Entity
public class Profile {
    @Id
    private Long id;
    
    @OneToOne
    @JoinColumn(name = "user_id")
    private User user;
}

// @OneToMany / @ManyToOne
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;
    
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> items = new ArrayList<>();
}

@Entity
public class OrderItem {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;
}

// @ManyToMany
@Entity
public class Student {
    @Id
    private Long id;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();
}

@Entity
public class Course {
    @Id
    private Long id;
    
    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}
```

---

### Q7: What is cascading?
**Answer:**
Cascade operations propagate from parent to child entities.

**Cascade Types:**
- **ALL:** All operations
- **PERSIST:** Save operations
- **MERGE:** Update operations
- **REMOVE:** Delete operations
- **REFRESH:** Reload from database
- **DETACH:** Detach from persistence context

**Example:**
```java
@Entity
public class Order {
    @Id
    private Long id;
    
    // Cascade all operations to items
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> items = new ArrayList<>();
    
    // Helper methods
    public void addItem(OrderItem item) {
        items.add(item);
        item.setOrder(this);
    }
    
    public void removeItem(OrderItem item) {
        items.remove(item);
        item.setOrder(null);
    }
}

@Service
public class OrderService {
    
    @Transactional
    public void createOrder() {
        Order order = new Order();
        
        OrderItem item1 = new OrderItem();
        OrderItem item2 = new OrderItem();
        
        order.addItem(item1);
        order.addItem(item2);
        
        orderRepository.save(order);  // Saves order AND items (CASCADE)
    }
    
    @Transactional
    public void deleteOrder(Long id) {
        Order order = orderRepository.findById(id).orElseThrow();
        orderRepository.delete(order);  // Deletes order AND items (CASCADE)
    }
}
```

---

### Q8: Lazy vs Eager loading?
**Answer:**

| Lazy Loading | Eager Loading |
|--------------|---------------|
| Load on access | Load immediately |
| Default for @OneToMany, @ManyToMany | Default for @OneToOne, @ManyToOne |
| Better performance | Can cause performance issues |
| May cause LazyInitializationException | No lazy loading issues |

**Example:**
```java
@Entity
public class Order {
    @Id
    private Long id;
    
    // Eager - loads immediately
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "customer_id")
    private Customer customer;
    
    // Lazy - loads on access (default for collections)
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> items = new ArrayList<>();
}

@Service
public class OrderService {
    
    @Transactional
    public void demonstrateFetching() {
        Order order = orderRepository.findById(1L).orElseThrow();
        
        // Customer already loaded (EAGER)
        System.out.println(order.getCustomer().getName());  // No additional query
        
        // Items not loaded yet (LAZY)
        System.out.println(order.getItems().size());  // Triggers query here
    }
    
    // Solution: Fetch join to avoid lazy loading issues
    @Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id = :id")
    Optional<Order> findByIdWithItems(@Param("id") Long id);
}
```

---

### Q9: What is orphanRemoval?
**Answer:**
Automatically deletes child entities when removed from parent collection.

**Example:**
```java
@Entity
public class Blog {
    @Id
    private Long id;
    
    @OneToMany(mappedBy = "blog", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();
    
    public void removeComment(Comment comment) {
        comments.remove(comment);
        comment.setBlog(null);
    }
}

@Service
public class BlogService {
    
    @Transactional
    public void deleteComment(Long blogId, Long commentId) {
        Blog blog = blogRepository.findById(blogId).orElseThrow();
        Comment comment = blog.getComments().stream()
                .filter(c -> c.getId().equals(commentId))
                .findFirst()
                .orElseThrow();
        
        blog.removeComment(comment);
        // Comment automatically deleted from database (orphanRemoval = true)
    }
}
```

**Without orphanRemoval:**
```java
@OneToMany(mappedBy = "blog", cascade = CascadeType.ALL)
private List<Comment> comments = new ArrayList<>();

// Need to explicitly delete
commentRepository.delete(comment);
```

---

### Q10: How to handle bidirectional relationships?
**Answer:**

**Best Practice: Use helper methods**

```java
@Entity
public class Author {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Book> books = new ArrayList<>();
    
    // Helper method - maintains both sides
    public void addBook(Book book) {
        books.add(book);
        book.setAuthor(this);
    }
    
    public void removeBook(Book book) {
        books.remove(book);
        book.setAuthor(null);
    }
}

@Entity
public class Book {
    @Id
    private Long id;
    private String title;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "author_id")
    private Author author;
    
    // Avoid circular reference in toString/equals/hashCode
    @Override
    public String toString() {
        return "Book{id=" + id + ", title='" + title + "'}";
    }
}

@Service
public class AuthorService {
    
    @Transactional
    public void createAuthorWithBooks() {
        Author author = new Author();
        author.setName("John Doe");
        
        Book book1 = new Book();
        book1.setTitle("Book 1");
        
        Book book2 = new Book();
        book2.setTitle("Book 2");
        
        // Use helper method
        author.addBook(book1);
        author.addBook(book2);
        
        authorRepository.save(author);  // Saves author and books
    }
}
```

---

## 3. Query Methods

### Q11: Query derivation from method names?
**Answer:**

**Supported Keywords:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Equality
    User findByEmail(String email);
    
    // And / Or
    List<User> findByNameAndEmail(String name, String email);
    List<User> findByNameOrEmail(String name, String email);
    
    // Comparison
    List<User> findByAgeGreaterThan(int age);
    List<User> findByAgeLessThan(int age);
    List<User> findByAgeGreaterThanEqual(int age);
    List<User> findByAgeLessThanEqual(int age);
    List<User> findByAgeBetween(int start, int end);
    
    // String operations
    List<User> findByNameStartingWith(String prefix);
    List<User> findByNameEndingWith(String suffix);
    List<User> findByNameContaining(String infix);
    List<User> findByNameLike(String pattern);
    List<User> findByNameIgnoreCase(String name);
    
    // Null checks
    List<User> findByEmailIsNull();
    List<User> findByEmailIsNotNull();
    
    // Boolean
    List<User> findByActiveTrue();
    List<User> findByActiveFalse();
    
    // In / NotIn
    List<User> findByAgeIn(Collection<Integer> ages);
    List<User> findByAgeNotIn(Collection<Integer> ages);
    
    // OrderBy
    List<User> findByNameOrderByAgeDesc(String name);
    List<User> findByActiveOrderByNameAsc(boolean active);
    
    // First / Top
    User findFirstByOrderByAgeDesc();
    List<User> findTop5ByOrderByNameAsc();
    
    // Distinct
    List<User> findDistinctByName(String name);
    
    // Count / Exists / Delete
    long countByActive(boolean active);
    boolean existsByEmail(String email);
    void deleteByActive(boolean active);
}
```

---

### Q12: @Query annotation?
**Answer:**

**JPQL Queries:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Simple JPQL
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    Optional<User> findByEmail(String email);
    
    // Named parameters (preferred)
    @Query("SELECT u FROM User u WHERE u.name = :name AND u.age > :age")
    List<User> findByNameAndMinAge(@Param("name") String name, @Param("age") int age);
    
    // Join query
    @Query("SELECT u FROM User u JOIN u.orders o WHERE o.status = :status")
    List<User> findUsersWithOrderStatus(@Param("status") OrderStatus status);
    
    // Fetch join (solve N+1)
    @Query("SELECT DISTINCT u FROM User u JOIN FETCH u.orders WHERE u.id = :id")
    Optional<User> findByIdWithOrders(@Param("id") Long id);
    
    // Projection (DTO)
    @Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) FROM User u")
    List<UserDTO> findAllUserDTOs();
    
    // Aggregation
    @Query("SELECT u.city, COUNT(u) FROM User u GROUP BY u.city")
    List<Object[]> countUsersByCity();
    
    // Modifying query
    @Modifying
    @Query("UPDATE User u SET u.active = false WHERE u.lastLogin < :date")
    int deactivateInactiveUsers(@Param("date") LocalDateTime date);
    
    @Modifying
    @Query("DELETE FROM User u WHERE u.active = false")
    void deleteInactiveUsers();
}
```

**Native SQL:**
```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Native query
    @Query(value = "SELECT * FROM products WHERE price > ?1", nativeQuery = true)
    List<Product> findExpensiveProducts(BigDecimal minPrice);
    
    // With named parameters
    @Query(value = "SELECT * FROM products WHERE category = :category ORDER BY price DESC",
           nativeQuery = true)
    List<Product> findByCategoryNative(@Param("category") String category);
    
    // Complex native query
    @Query(value = """
        SELECT p.*, c.name as category_name
        FROM products p
        JOIN categories c ON p.category_id = c.id
        WHERE p.price BETWEEN :minPrice AND :maxPrice
        """, nativeQuery = true)
    List<Object[]> findProductsWithCategory(@Param("minPrice") BigDecimal minPrice,
                                            @Param("maxPrice") BigDecimal maxPrice);
}
```

---

### Q13: Specifications for dynamic queries?
**Answer:**

**Dependency:**
```java
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
}
```

**Specification:**
```java
public class UserSpecification {
    
    public static Specification<User> hasName(String name) {
        return (root, query, cb) -> 
            name == null ? null : cb.equal(root.get("name"), name);
    }
    
    public static Specification<User> hasEmail(String email) {
        return (root, query, cb) -> 
            email == null ? null : cb.equal(root.get("email"), email);
    }
    
    public static Specification<User> hasMinAge(Integer minAge) {
        return (root, query, cb) -> 
            minAge == null ? null : cb.greaterThanOrEqualTo(root.get("age"), minAge);
    }
    
    public static Specification<User> isActive(Boolean active) {
        return (root, query, cb) -> 
            active == null ? null : cb.equal(root.get("active"), active);
    }
    
    public static Specification<User> hasOrders() {
        return (root, query, cb) -> {
            Join<User, Order> orders = root.join("orders", JoinType.INNER);
            return cb.isNotNull(orders.get("id"));
        };
    }
}
```

**Usage:**
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public List<User> searchUsers(String name, String email, Integer minAge, Boolean active) {
        Specification<User> spec = Specification.where(UserSpecification.hasName(name))
                .and(UserSpecification.hasEmail(email))
                .and(UserSpecification.hasMinAge(minAge))
                .and(UserSpecification.isActive(active));
        
        return userRepository.findAll(spec);
    }
    
    public Page<User> searchUsersWithPagination(String name, Integer minAge, Pageable pageable) {
        Specification<User> spec = Specification.where(UserSpecification.hasName(name))
                .and(UserSpecification.hasMinAge(minAge));
        
        return userRepository.findAll(spec, pageable);
    }
}
```

---

### Q14: Projections?
**Answer:**

**1. Interface-based Projection:**
```java
public interface UserProjection {
    String getName();
    String getEmail();
    
    // Nested projection
    AddressProjection getAddress();
}

public interface AddressProjection {
    String getCity();
    String getCountry();
}

public interface UserRepository extends JpaRepository<User, Long> {
    List<UserProjection> findAllProjectedBy();
    UserProjection findProjectedById(Long id);
}
```

**2. Class-based Projection (DTO):**
```java
@Data
@AllArgsConstructor
public class UserDTO {
    private Long id;
    private String name;
    private String email;
}

public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT new com.example.dto.UserDTO(u.id, u.name, u.email) FROM User u")
    List<UserDTO> findAllDTOs();
}
```

**3. Dynamic Projection:**
```java
public interface UserRepository extends JpaRepository<User, Long> {
    <T> List<T> findByName(String name, Class<T> type);
}

// Usage
List<UserProjection> projections = userRepository.findByName("John", UserProjection.class);
List<UserDTO> dtos = userRepository.findByName("John", UserDTO.class);
```

---

### Q15: How to handle N+1 query problem?
**Answer:**

**Problem:**
```java
// Causes N+1 queries
List<Order> orders = orderRepository.findAll();  // 1 query
for (Order order : orders) {
    order.getItems().size();  // N queries (lazy loading)
}
```

**Solutions:**

**1. Fetch Join:**
```java
@Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.items")
List<Order> findAllWithItems();

// With WHERE clause
@Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.items WHERE o.status = :status")
List<Order> findByStatusWithItems(@Param("status") OrderStatus status);
```

**2. Entity Graph:**
```java
@EntityGraph(attributePaths = {"items", "customer"})
@Query("SELECT o FROM Order o")
List<Order> findAllWithItemsAndCustomer();

// Named entity graph
@Entity
@NamedEntityGraph(
    name = "Order.withItems",
    attributeNodes = @NamedAttributeNode("items")
)
public class Order {
    // ...
}

@EntityGraph(value = "Order.withItems")
List<Order> findAll();
```

**3. @BatchSize:**
```java
@Entity
public class Order {
    @OneToMany(mappedBy = "order")
    @BatchSize(size = 10)  // Fetch in batches of 10
    private List<OrderItem> items;
}
```

**4. DTO Projection:**
```java
@Query("""
    SELECT new com.example.dto.OrderDTO(
        o.id, o.total, c.name,
        (SELECT COUNT(i) FROM OrderItem i WHERE i.order = o)
    )
    FROM Order o
    JOIN o.customer c
    """)
List<OrderDTO> findAllOrderDTOs();
```

---

## 4. Advanced Topics

### Q16: @Transactional annotation?
**Answer:**

**Purpose:** Manages database transactions automatically.

**Example:**
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryService inventoryService;
    
    // Default: REQUIRED propagation, READ_COMMITTED isolation
    @Transactional
    public Order createOrder(OrderDTO dto) {
        Order order = orderRepository.save(dto.toEntity());
        inventoryService.decreaseStock(order.getItems());
        return order;
    }
    
    // Read-only optimization
    @Transactional(readOnly = true)
    public List<Order> findAll() {
        return orderRepository.findAll();
    }
    
    // Custom propagation
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createLog(String message) {
        // Always creates new transaction
    }
    
    // Custom isolation
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void criticalOperation() {
        // Highest isolation level
    }
    
    // Timeout
    @Transactional(timeout = 30)  // 30 seconds
    public void longRunningOperation() {
        // ...
    }
    
    // Rollback rules
    @Transactional(rollbackFor = Exception.class, noRollbackFor = IllegalArgumentException.class)
    public void processWithRollback() {
        // Rollback on Exception, but not on IllegalArgumentException
    }
}
```

**Propagation Types:**
- REQUIRED (default): Use existing or create new
- REQUIRES_NEW: Always create new
- NESTED: Nested transaction
- MANDATORY: Must have existing transaction
- SUPPORTS: Use if exists, non-transactional otherwise
- NOT_SUPPORTED: Execute non-transactionally
- NEVER: Throw exception if transaction exists

---

### Q17: Auditing with @EntityListeners?
**Answer:**

**Enable auditing:**
```java
@Configuration
@EnableJpaAuditing
public class JpaConfig {
    
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            // Get current user from security context
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return Optional.ofNullable(auth).map(Authentication::getName);
        };
    }
}
```

**Base auditing entity:**
```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableEntity {
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    @CreatedBy
    @Column(nullable = false, updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    private String updatedBy;
    
    // Getters and setters
}
```

**Entity:**
```java
@Entity
public class Product extends AuditableEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
    
    // Automatically populated: createdAt, updatedAt, createdBy, updatedBy
}
```

**Custom lifecycle callbacks:**
```java
@Entity
@EntityListeners(ProductListener.class)
public class Product {
    @Id
    private Long id;
    
    private BigDecimal price;
    private BigDecimal discountedPrice;
    
    @PrePersist
    public void prePersist() {
        calculateDiscountedPrice();
    }
    
    @PreUpdate
    public void preUpdate() {
        calculateDiscountedPrice();
    }
    
    private void calculateDiscountedPrice() {
        this.discountedPrice = price.multiply(new BigDecimal("0.9"));
    }
}

public class ProductListener {
    
    @PostLoad
    public void postLoad(Product product) {
        // Called after loading from database
    }
    
    @PostPersist
    public void postPersist(Product product) {
        // Called after insert
    }
    
    @PostUpdate
    public void postUpdate(Product product) {
        // Called after update
    }
    
    @PostRemove
    public void postRemove(Product product) {
        // Called after delete
    }
}
```

---

### Q18: Soft delete implementation?
**Answer:**

```java
@Entity
@SQLDelete(sql = "UPDATE products SET deleted = true WHERE id = ?")
@Where(clause = "deleted = false")
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Column(nullable = false)
    private boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    // Getters and setters
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Soft deleted products
    @Query("SELECT p FROM Product p WHERE p.deleted = true")
    List<Product> findDeleted();
    
    // Include deleted products
    @Query("SELECT p FROM Product p WHERE p.id = :id", nativeQuery = false)
    Optional<Product> findByIdIncludingDeleted(@Param("id") Long id);
}

@Service
public class ProductService {
    
    @Transactional
    public void softDelete(Long id) {
        Product product = productRepository.findById(id).orElseThrow();
        product.setDeleted(true);
        product.setDeletedAt(LocalDateTime.now());
        productRepository.save(product);
    }
    
    @Transactional
    public void restore(Long id) {
        Product product = productRepository.findByIdIncludingDeleted(id).orElseThrow();
        product.setDeleted(false);
        product.setDeletedAt(null);
        productRepository.save(product);
    }
}
```

---

### Q19: Optimistic vs Pessimistic locking?
**Answer:**

**Optimistic Locking (Versioning):**
```java
@Entity
public class Account {
    
    @Id
    private Long id;
    
    private BigDecimal balance;
    
    @Version  // Optimistic locking
    private Long version;
    
    // Getters and setters
}

@Service
public class AccountService {
    
    @Transactional
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        Account from = accountRepository.findById(fromId).orElseThrow();
        Account to = accountRepository.findById(toId).orElseThrow();
        
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        accountRepository.save(from);  // Version incremented
        accountRepository.save(to);    // Version incremented
        
        // If another transaction modified these accounts,
        // OptimisticLockException is thrown
    }
}
```

**Pessimistic Locking:**
```java
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT a FROM Account a WHERE a.id = :id")
    Optional<Account> findByIdWithLock(@Param("id") Long id);
    
    @Lock(LockModeType.PESSIMISTIC_READ)
    Optional<Account> findById(Long id);
}

@Service
public class AccountService {
    
    @Transactional
    public void transferWithLock(Long fromId, Long toId, BigDecimal amount) {
        // Acquires database lock
        Account from = accountRepository.findByIdWithLock(fromId).orElseThrow();
        Account to = accountRepository.findByIdWithLock(toId).orElseThrow();
        
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        // Lock released when transaction commits
    }
}
```

**Lock Types:**
- PESSIMISTIC_READ: Shared lock, prevents writes
- PESSIMISTIC_WRITE: Exclusive lock, prevents reads and writes
- PESSIMISTIC_FORCE_INCREMENT: Exclusive lock + version increment

---

### Q20: How to handle database migrations?
**Answer:**

**Using Flyway:**

**Dependency:**
```xml
<dependency>
    <groupId>org.flywaydb</groupId>
    <artifactId>flyway-core</artifactId>
</dependency>
```

**Configuration:**
```yaml
spring:
  flyway:
    enabled: true
    baseline-on-migrate: true
    locations: classpath:db/migration
```

**Migration files (src/main/resources/db/migration):**
```sql
-- V1__create_users_table.sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- V2__add_phone_to_users.sql
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- V3__create_orders_table.sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    total DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

**Using Liquibase:**

**Dependency:**
```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
</dependency>
```

**Configuration:**
```yaml
spring:
  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.xml
```

**Changelog (db/changelog/db.changelog-master.xml):**
```xml
<databaseChangeLog>
    <changeSet id="1" author="admin">
        <createTable tableName="users">
            <column name="id" type="BIGINT" autoIncrement="true">
                <constraints primaryKey="true"/>
            </column>
            <column name="name" type="VARCHAR(100)">
                <constraints nullable="false"/>
            </column>
            <column name="email" type="VARCHAR(255)">
                <constraints nullable="false" unique="true"/>
            </column>
        </createTable>
    </changeSet>
</databaseChangeLog>
```

---

## Summary

Spring Data JPA simplifies data access: JpaRepository provides CRUD, pagination, sorting, batch operations. Entity lifecycle: transient, persistent, detached, removed. Relationships: @OneToOne, @OneToMany, @ManyToOne, @ManyToMany with cascade and orphanRemoval. Lazy loading (default for collections) vs eager loading. Query methods: derivation from method names, @Query for JPQL/native SQL, Specifications for dynamic queries, Projections for DTOs. N+1 problem solutions: fetch join, entity graph, @BatchSize, DTO projection. @Transactional for transaction management with propagation and isolation levels. Auditing with @CreatedDate, @LastModifiedDate, @CreatedBy, @LastModifiedBy. Soft delete with @SQLDelete and @Where. Locking: optimistic (@Version) vs pessimistic (@Lock). Database migrations with Flyway or Liquibase.

---

**Next:** Security Questions →
