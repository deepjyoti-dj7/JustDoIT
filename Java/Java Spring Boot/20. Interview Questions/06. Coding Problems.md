# Coding Problems

---

## Problem 1: Implement Paginated REST API with Sorting

**Problem:** Create a REST API for products with pagination, sorting, and filtering.

**Requirements:**
- Paginated response
- Sort by multiple fields
- Filter by category and price range
- Include metadata (total pages, total elements)

**Solution:**

```java
// Entity
@Entity
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
    private BigDecimal price;
    private String category;
    private Integer stock;
    private LocalDateTime createdAt;
    
    // Getters and setters
}

// Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {
}

// Specification for filtering
public class ProductSpecification {
    
    public static Specification<Product> hasCategory(String category) {
        return (root, query, cb) -> {
            if (category == null) return cb.conjunction();
            return cb.equal(root.get("category"), category);
        };
    }
    
    public static Specification<Product> hasPriceBetween(BigDecimal minPrice, BigDecimal maxPrice) {
        return (root, query, cb) -> {
            if (minPrice == null && maxPrice == null) return cb.conjunction();
            if (minPrice != null && maxPrice != null) {
                return cb.between(root.get("price"), minPrice, maxPrice);
            } else if (minPrice != null) {
                return cb.greaterThanOrEqualTo(root.get("price"), minPrice);
            } else {
                return cb.lessThanOrEqualTo(root.get("price"), maxPrice);
            }
        };
    }
    
    public static Specification<Product> searchByName(String name) {
        return (root, query, cb) -> {
            if (name == null || name.isEmpty()) return cb.conjunction();
            return cb.like(cb.lower(root.get("name")), "%" + name.toLowerCase() + "%");
        };
    }
}

// Service
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    public Page<Product> getProducts(String category, BigDecimal minPrice, BigDecimal maxPrice,
                                      String search, Pageable pageable) {
        Specification<Product> spec = Specification.where(ProductSpecification.hasCategory(category))
                .and(ProductSpecification.hasPriceBetween(minPrice, maxPrice))
                .and(ProductSpecification.searchByName(search));
        
        return productRepository.findAll(spec, pageable);
    }
}

// Controller
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @Autowired
    private ProductService productService;
    
    @GetMapping
    public ResponseEntity<PagedResponse<ProductDTO>> getProducts(
            @RequestParam(required = false) String category,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice,
            @RequestParam(required = false) String search,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id,asc") String[] sort) {
        
        // Parse sort parameters
        List<Sort.Order> orders = new ArrayList<>();
        for (String sortParam : sort) {
            String[] sortFields = sortParam.split(",");
            String field = sortFields[0];
            String direction = sortFields.length > 1 ? sortFields[1] : "asc";
            orders.add(new Sort.Order(Sort.Direction.fromString(direction), field));
        }
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(orders));
        Page<Product> productPage = productService.getProducts(category, minPrice, maxPrice, search, pageable);
        
        List<ProductDTO> content = productPage.getContent().stream()
                .map(this::toDTO)
                .collect(Collectors.toList());
        
        PagedResponse<ProductDTO> response = PagedResponse.<ProductDTO>builder()
                .content(content)
                .page(productPage.getNumber())
                .size(productPage.getSize())
                .totalElements(productPage.getTotalElements())
                .totalPages(productPage.getTotalPages())
                .last(productPage.isLast())
                .build();
        
        return ResponseEntity.ok(response);
    }
    
    private ProductDTO toDTO(Product product) {
        ProductDTO dto = new ProductDTO();
        dto.setId(product.getId());
        dto.setName(product.getName());
        dto.setPrice(product.getPrice());
        dto.setCategory(product.getCategory());
        return dto;
    }
}

// Response DTO
@Data
@Builder
public class PagedResponse<T> {
    private List<T> content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;
    private boolean last;
}

// DTO
@Data
public class ProductDTO {
    private Long id;
    private String name;
    private BigDecimal price;
    private String category;
}
```

**Usage:**
```bash
# Get page 0, size 10, sorted by price descending
GET /api/products?page=0&size=10&sort=price,desc

# Filter by category and price range
GET /api/products?category=Electronics&minPrice=100&maxPrice=1000

# Search and sort by multiple fields
GET /api/products?search=laptop&sort=price,desc&sort=name,asc
```

---

## Problem 2: Implement File Upload with Validation

**Problem:** Create an API to upload files with size, type validation, and error handling.

**Requirements:**
- Maximum file size: 5MB
- Allowed types: PDF, JPEG, PNG
- Generate unique filename
- Return file URL

**Solution:**

```java
// Configuration
@Configuration
public class FileUploadConfig {
    
    @Bean
    public MultipartResolver multipartResolver() {
        CommonsMultipartResolver resolver = new CommonsMultipartResolver();
        resolver.setMaxUploadSize(5 * 1024 * 1024); // 5MB
        return resolver;
    }
}

// Service
@Service
public class FileService {
    
    @Value("${file.upload-dir}")
    private String uploadDir;
    
    private static final List<String> ALLOWED_EXTENSIONS = Arrays.asList("pdf", "jpg", "jpeg", "png");
    private static final long MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
    
    @PostConstruct
    public void init() {
        try {
            Files.createDirectories(Paths.get(uploadDir));
        } catch (IOException e) {
            throw new RuntimeException("Could not create upload directory", e);
        }
    }
    
    public FileUploadResponse uploadFile(MultipartFile file) {
        // Validate file
        validateFile(file);
        
        // Generate unique filename
        String originalFilename = file.getOriginalFilename();
        String extension = getFileExtension(originalFilename);
        String filename = UUID.randomUUID().toString() + "." + extension;
        
        try {
            // Save file
            Path targetLocation = Paths.get(uploadDir).resolve(filename);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            
            // Save metadata to database
            FileMetadata metadata = new FileMetadata();
            metadata.setOriginalName(originalFilename);
            metadata.setStoredName(filename);
            metadata.setFileSize(file.getSize());
            metadata.setContentType(file.getContentType());
            metadata.setUploadedAt(LocalDateTime.now());
            fileMetadataRepository.save(metadata);
            
            String fileUrl = "/api/files/" + filename;
            
            return FileUploadResponse.builder()
                    .filename(filename)
                    .originalFilename(originalFilename)
                    .fileUrl(fileUrl)
                    .fileSize(file.getSize())
                    .contentType(file.getContentType())
                    .build();
            
        } catch (IOException e) {
            throw new FileStorageException("Failed to store file " + filename, e);
        }
    }
    
    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new InvalidFileException("File is empty");
        }
        
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new InvalidFileException("File size exceeds maximum limit of 5MB");
        }
        
        String extension = getFileExtension(file.getOriginalFilename());
        if (!ALLOWED_EXTENSIONS.contains(extension.toLowerCase())) {
            throw new InvalidFileException("File type not allowed. Allowed types: " + ALLOWED_EXTENSIONS);
        }
    }
    
    private String getFileExtension(String filename) {
        if (filename == null) {
            throw new InvalidFileException("Filename is null");
        }
        int lastDotIndex = filename.lastIndexOf('.');
        if (lastDotIndex == -1) {
            throw new InvalidFileException("File has no extension");
        }
        return filename.substring(lastDotIndex + 1);
    }
    
    public Resource loadFileAsResource(String filename) {
        try {
            Path filePath = Paths.get(uploadDir).resolve(filename).normalize();
            Resource resource = new UrlResource(filePath.toUri());
            
            if (resource.exists()) {
                return resource;
            } else {
                throw new FileNotFoundException("File not found: " + filename);
            }
        } catch (MalformedURLException e) {
            throw new FileNotFoundException("File not found: " + filename);
        }
    }
}

// Controller
@RestController
@RequestMapping("/api/files")
public class FileController {
    
    @Autowired
    private FileService fileService;
    
    @PostMapping("/upload")
    public ResponseEntity<FileUploadResponse> uploadFile(
            @RequestParam("file") MultipartFile file) {
        FileUploadResponse response = fileService.uploadFile(file);
        return ResponseEntity.ok(response);
    }
    
    @PostMapping("/upload-multiple")
    public ResponseEntity<List<FileUploadResponse>> uploadMultipleFiles(
            @RequestParam("files") MultipartFile[] files) {
        List<FileUploadResponse> responses = Arrays.stream(files)
                .map(fileService::uploadFile)
                .collect(Collectors.toList());
        return ResponseEntity.ok(responses);
    }
    
    @GetMapping("/{filename}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String filename) {
        Resource resource = fileService.loadFileAsResource(filename);
        
        String contentType = "application/octet-stream";
        
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                        "attachment; filename=\"" + resource.getFilename() + "\"")
                .body(resource);
    }
}

// Response DTO
@Data
@Builder
public class FileUploadResponse {
    private String filename;
    private String originalFilename;
    private String fileUrl;
    private Long fileSize;
    private String contentType;
}

// Entity
@Entity
@Table(name = "file_metadata")
public class FileMetadata {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String originalName;
    private String storedName;
    private Long fileSize;
    private String contentType;
    private LocalDateTime uploadedAt;
    
    // Getters and setters
}

// Custom Exceptions
public class InvalidFileException extends RuntimeException {
    public InvalidFileException(String message) {
        super(message);
    }
}

public class FileStorageException extends RuntimeException {
    public FileStorageException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class FileNotFoundException extends RuntimeException {
    public FileNotFoundException(String message) {
        super(message);
    }
}

// Exception Handler
@RestControllerAdvice
public class FileExceptionHandler {
    
    @ExceptionHandler(InvalidFileException.class)
    public ResponseEntity<ErrorResponse> handleInvalidFile(InvalidFileException ex) {
        ErrorResponse error = new ErrorResponse(HttpStatus.BAD_REQUEST.value(), ex.getMessage());
        return ResponseEntity.badRequest().body(error);
    }
    
    @ExceptionHandler(FileStorageException.class)
    public ResponseEntity<ErrorResponse> handleFileStorage(FileStorageException ex) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), ex.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ErrorResponse> handleMaxSize(MaxUploadSizeExceededException ex) {
        ErrorResponse error = new ErrorResponse(HttpStatus.BAD_REQUEST.value(), 
                "File size exceeds maximum limit of 5MB");
        return ResponseEntity.badRequest().body(error);
    }
}
```

**application.yml:**
```yaml
spring:
  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 5MB

file:
  upload-dir: ./uploads
```

---

## Problem 3: Implement N+1 Query Solution

**Problem:** Fix N+1 query problem in order-items relationship.

**Bad Code (N+1 Problem):**
```java
@Service
public class OrderService {
    
    public List<OrderDTO> getAllOrders() {
        List<Order> orders = orderRepository.findAll(); // 1 query
        
        return orders.stream()
                .map(order -> {
                    OrderDTO dto = new OrderDTO();
                    dto.setId(order.getId());
                    // N queries - one for each order's items
                    dto.setItems(order.getItems().stream()
                            .map(this::toItemDTO)
                            .collect(Collectors.toList()));
                    return dto;
                })
                .collect(Collectors.toList());
    }
}
```

**Solution 1: Fetch Join:**
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @Query("SELECT o FROM Order o LEFT JOIN FETCH o.items WHERE o.id = :id")
    Optional<Order> findByIdWithItems(@Param("id") Long id);
    
    @Query("SELECT DISTINCT o FROM Order o LEFT JOIN FETCH o.items")
    List<Order> findAllWithItems();
}
```

**Solution 2: Entity Graph:**
```java
@Entity
@Table(name = "orders")
@NamedEntityGraph(
    name = "Order.items",
    attributeNodes = @NamedAttributeNode("items")
)
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> items = new ArrayList<>();
    
    // Other fields
}

public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @EntityGraph(value = "Order.items")
    List<Order> findAll();
    
    @EntityGraph(attributePaths = {"items", "items.product"})
    Optional<Order> findById(Long id);
}
```

**Solution 3: DTO Projection:**
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @Query("SELECT new com.example.dto.OrderWithItemsDTO(" +
           "o.id, o.orderDate, o.total, " +
           "i.id, i.quantity, i.price, " +
           "p.id, p.name) " +
           "FROM Order o " +
           "LEFT JOIN o.items i " +
           "LEFT JOIN i.product p")
    List<OrderWithItemsDTO> findAllOrdersWithItems();
}

// DTO
public class OrderWithItemsDTO {
    private Long orderId;
    private LocalDateTime orderDate;
    private BigDecimal total;
    private Long itemId;
    private Integer quantity;
    private BigDecimal price;
    private Long productId;
    private String productName;
    
    // Constructor, getters
}

// Service transforms flat results into nested structure
@Service
public class OrderService {
    
    public List<OrderDTO> getAllOrders() {
        List<OrderWithItemsDTO> flat = orderRepository.findAllOrdersWithItems();
        
        Map<Long, OrderDTO> orderMap = new HashMap<>();
        
        for (OrderWithItemsDTO dto : flat) {
            OrderDTO order = orderMap.computeIfAbsent(dto.getOrderId(), id -> {
                OrderDTO o = new OrderDTO();
                o.setId(dto.getOrderId());
                o.setOrderDate(dto.getOrderDate());
                o.setTotal(dto.getTotal());
                o.setItems(new ArrayList<>());
                return o;
            });
            
            if (dto.getItemId() != null) {
                OrderItemDTO item = new OrderItemDTO();
                item.setId(dto.getItemId());
                item.setQuantity(dto.getQuantity());
                item.setPrice(dto.getPrice());
                item.setProductName(dto.getProductName());
                order.getItems().add(item);
            }
        }
        
        return new ArrayList<>(orderMap.values());
    }
}
```

---

## Problem 4: Implement Soft Delete

**Problem:** Implement soft delete for entities with audit trail.

**Solution:**

```java
// Base Entity
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    private LocalDateTime updatedAt;
    
    private LocalDateTime deletedAt;
    
    @Column(nullable = false)
    private Boolean deleted = false;
    
    // Getters and setters
}

// Product Entity
@Entity
@Table(name = "products")
@SQLDelete(sql = "UPDATE products SET deleted = true, deleted_at = NOW() WHERE id = ?")
@Where(clause = "deleted = false")
public class Product extends BaseEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
    
    // Getters and setters
}

// Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Find all including deleted
    @Query("SELECT p FROM Product p")
    List<Product> findAllIncludingDeleted();
    
    // Find deleted only
    @Query("SELECT p FROM Product p WHERE p.deleted = true")
    List<Product> findDeleted();
    
    // Restore deleted product
    @Modifying
    @Transactional
    @Query("UPDATE Product p SET p.deleted = false, p.deletedAt = null WHERE p.id = :id")
    void restore(@Param("id") Long id);
    
    // Hard delete
    @Modifying
    @Transactional
    @Query("DELETE FROM Product p WHERE p.id = :id")
    void hardDelete(@Param("id") Long id);
}

// Service
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    // Soft delete (using JPA delete - triggers @SQLDelete)
    @Transactional
    public void deleteProduct(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        productRepository.delete(product);  // Triggers soft delete
    }
    
    // Restore
    @Transactional
    public void restoreProduct(Long id) {
        productRepository.restore(id);
    }
    
    // Hard delete
    @Transactional
    public void hardDeleteProduct(Long id) {
        productRepository.hardDelete(id);
    }
    
    // Get all active
    public List<Product> getAllProducts() {
        return productRepository.findAll();  // Excludes deleted due to @Where
    }
    
    // Get all including deleted
    public List<Product> getAllIncludingDeleted() {
        return productRepository.findAllIncludingDeleted();
    }
    
    // Get deleted only
    public List<Product> getDeletedProducts() {
        return productRepository.findDeleted();
    }
}
```

---

## Problem 5: Implement JWT Authentication

**Problem:** Create complete JWT authentication from scratch.

**Solution:**

```java
// JWT Utility
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList()));
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
}

// JWT Filter
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain chain) throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization");
        
        String username = null;
        String jwt = null;
        
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            jwt = authHeader.substring(7);
            try {
                username = jwtUtil.extractUsername(jwt);
            } catch (Exception e) {
                logger.error("JWT token validation error", e);
            }
        }
        
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            
            if (jwtUtil.validateToken(jwt, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = 
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        
        chain.doFilter(request, response);
    }
}

// Auth Controller
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @PostMapping("/login")
    public ResponseEntity<JwtResponse> login(@Valid @RequestBody LoginRequest request) {
        Authentication authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );
        
        SecurityContextHolder.getContext().setAuthentication(authentication);
        
        UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());
        String token = jwtUtil.generateToken(userDetails);
        
        return ResponseEntity.ok(new JwtResponse(token));
    }
    
    @PostMapping("/register")
    public ResponseEntity<MessageResponse> register(@Valid @RequestBody RegisterRequest request) {
        // Registration logic
        return ResponseEntity.ok(new MessageResponse("User registered successfully"));
    }
}

// Security Config
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtAuthFilter;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) 
            throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

## Problem 6: Implement Caching Strategy

**Problem:** Implement multi-level caching for product catalog.

**Solution:**

```java
// Configuration
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }
}

// Service with caching
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
    }
    
    @Cacheable(value = "products", key = "'all'")
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
    
    @CachePut(value = "products", key = "#result.id")
    public Product updateProduct(Long id, ProductDTO dto) {
        Product product = getProduct(id);
        product.setName(dto.getName());
        product.setPrice(dto.getPrice());
        return productRepository.save(product);
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void deleteProduct(Long id) {
        productRepository.deleteById(id);
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Clears all entries
    }
}
```

---

## Problem 7: Implement Async Processing

**Problem:** Process large orders asynchronously.

**Solution:**

```java
// Configuration
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    @Bean(name = "taskExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> 
            log.error("Async method {} threw exception", method.getName(), ex);
    }
}

// Async Service
@Service
public class OrderProcessingService {
    
    @Async("taskExecutor")
    public CompletableFuture<OrderResult> processOrder(Order order) {
        try {
            // Simulate processing
            Thread.sleep(2000);
            
            // Process payment
            paymentService.processPayment(order);
            
            // Update inventory
            inventoryService.updateInventory(order);
            
            // Send notification
            notificationService.sendOrderConfirmation(order);
            
            OrderResult result = new OrderResult(order.getId(), "SUCCESS");
            return CompletableFuture.completedFuture(result);
            
        } catch (Exception e) {
            OrderResult result = new OrderResult(order.getId(), "FAILED");
            return CompletableFuture.completedFuture(result);
        }
    }
    
    @Async
    public void sendEmail(String to, String subject, String body) {
        // Send email asynchronously
        emailService.send(to, subject, body);
    }
}

// Controller
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderProcessingService processingService;
    
    @PostMapping
    public ResponseEntity<String> createOrder(@Valid @RequestBody OrderDTO dto) {
        Order order = orderRepository.save(dto.toEntity());
        
        // Process asynchronously
        CompletableFuture<OrderResult> future = processingService.processOrder(order);
        
        // Return immediately
        return ResponseEntity.accepted()
                .body("Order accepted for processing. ID: " + order.getId());
    }
    
    @PostMapping("/batch")
    public ResponseEntity<String> createBatchOrders(@RequestBody List<OrderDTO> orders) {
        List<CompletableFuture<OrderResult>> futures = orders.stream()
                .map(dto -> {
                    Order order = orderRepository.save(dto.toEntity());
                    return processingService.processOrder(order);
                })
                .collect(Collectors.toList());
        
        // Wait for all to complete
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenRun(() -> log.info("All orders processed"));
        
        return ResponseEntity.accepted()
                .body("Batch processing started for " + orders.size() + " orders");
    }
}
```

---

## Problem 8: Implement Rate Limiting

**Problem:** Implement API rate limiting per user.

**Solution:**

```java
// Bucket4j Configuration
@Configuration
public class RateLimitConfig {
    
    @Bean
    public Bucket createBucket() {
        Bandwidth limit = Bandwidth.classic(10, Refill.intervally(10, Duration.ofMinutes(1)));
        return Bucket.builder()
                .addLimit(limit)
                .build();
    }
}

// Rate Limit Interceptor
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final Map<String, Bucket> cache = new ConcurrentHashMap<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                             Object handler) throws Exception {
        String apiKey = request.getHeader("X-API-KEY");
        if (apiKey == null) {
            response.sendError(HttpStatus.BAD_REQUEST.value(), "Missing API Key");
            return false;
        }
        
        Bucket bucket = resolveBucket(apiKey);
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
        
        if (probe.isConsumed()) {
            response.addHeader("X-Rate-Limit-Remaining", 
                    String.valueOf(probe.getRemainingTokens()));
            return true;
        } else {
            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;
            response.addHeader("X-Rate-Limit-Retry-After-Seconds", 
                    String.valueOf(waitForRefill));
            response.sendError(HttpStatus.TOO_MANY_REQUESTS.value(), 
                    "You have exhausted your API Request Quota");
            return false;
        }
    }
    
    private Bucket resolveBucket(String apiKey) {
        return cache.computeIfAbsent(apiKey, k -> {
            Bandwidth limit = Bandwidth.classic(100, 
                    Refill.intervally(100, Duration.ofHours(1)));
            return Bucket.builder().addLimit(limit).build();
        });
    }
}

// Register Interceptor
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private RateLimitInterceptor rateLimitInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/auth/**");
    }
}
```

---

## Problem 9: Implement Optimistic Locking

**Problem:** Handle concurrent updates with optimistic locking.

**Solution:**

```java
// Entity
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
    private Integer stock;
    
    @Version
    private Long version;
    
    // Getters and setters
}

// Service
@Service
public class ProductService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Transactional
    public Product updateProduct(Long id, ProductDTO dto) {
        int maxRetries = 3;
        int attempt = 0;
        
        while (attempt < maxRetries) {
            try {
                Product product = productRepository.findById(id)
                        .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
                
                product.setName(dto.getName());
                product.setPrice(dto.getPrice());
                product.setStock(dto.getStock());
                
                return productRepository.save(product);
                
            } catch (OptimisticLockingFailureException e) {
                attempt++;
                if (attempt >= maxRetries) {
                    throw new ConcurrentUpdateException(
                            "Product was updated by another transaction. Please try again.");
                }
                // Wait before retry
                try {
                    Thread.sleep(100 * attempt);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Retry interrupted", ie);
                }
            }
        }
        
        throw new ConcurrentUpdateException("Failed to update product after " + maxRetries + " attempts");
    }
}
```

---

## Problem 10: Implement Circuit Breaker

**Problem:** Add circuit breaker to external API calls.

**Solution:**

```java
// Service
@Service
public class PaymentService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "processPaymentFallback")
    @Retry(name = "paymentService", fallbackMethod = "processPaymentFallback")
    @Bulkhead(name = "paymentService")
    public PaymentResponse processPayment(PaymentRequest request) {
        String url = "https://payment-gateway.com/api/process";
        return restTemplate.postForObject(url, request, PaymentResponse.class);
    }
    
    private PaymentResponse processPaymentFallback(PaymentRequest request, Exception ex) {
        log.error("Payment failed, using fallback", ex);
        
        // Save for later processing
        pendingPaymentRepository.save(request);
        
        PaymentResponse response = new PaymentResponse();
        response.setStatus("PENDING");
        response.setMessage("Payment is being processed. You will be notified.");
        return response;
    }
}
```

**Configuration:**
```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10s
        permitted-number-of-calls-in-half-open-state: 3
  
  retry:
    instances:
      paymentService:
        max-attempts: 3
        wait-duration: 2s
        enable-exponential-backoff: true
        exponential-backoff-multiplier: 2
  
  bulkhead:
    instances:
      paymentService:
        max-concurrent-calls: 5
        max-wait-duration: 1s
```

---

## Summary

Practical coding problems covering: **Pagination & Sorting** (Specification API, PageRequest, custom PagedResponse), **File Upload** (MultipartFile validation, size limits, type checking, unique filename generation, metadata storage), **N+1 Query Solutions** (fetch join, @EntityGraph, DTO projection with result transformation), **Soft Delete** (@SQLDelete annotation, @Where clause, restore functionality, audit trail with deletedAt timestamp), **JWT Authentication** (token generation/validation, JwtAuthenticationFilter, SecurityConfig with stateless sessions), **Caching** (Redis with @Cacheable/@CachePut/@CacheEvict, TTL configuration), **Async Processing** (@Async with ThreadPoolTaskExecutor, CompletableFuture for batch operations), **Rate Limiting** (Bucket4j with token bucket algorithm, HandlerInterceptor implementation), **Optimistic Locking** (@Version field, retry logic with exponential backoff, OptimisticLockingFailureException handling), **Circuit Breaker** (Resilience4j with fallback methods, retry with exponential backoff, bulkhead pattern for resource isolation). All solutions include complete working code with error handling, validation, and best practices.

---

**Next:** Scenario-based Questions â†’
