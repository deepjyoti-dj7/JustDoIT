# Core Spring Boot Interview Questions

---

## 1. Fundamentals

### Q1: What is Spring Boot?
**Answer:**
Spring Boot is an opinionated framework built on top of Spring Framework that simplifies the development of production-ready applications. It provides:
- **Auto-configuration:** Automatically configures Spring application based on dependencies
- **Starter dependencies:** Pre-configured dependency bundles
- **Embedded servers:** Tomcat, Jetty, or Undertow embedded
- **Production-ready features:** Actuator for monitoring, externalized configuration
- **No XML configuration:** Convention over configuration approach

**Example:**
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

---

### Q2: What is @SpringBootApplication annotation?
**Answer:**
Combination of three annotations:
- `@Configuration`: Makes class a source of bean definitions
- `@EnableAutoConfiguration`: Enables auto-configuration
- `@ComponentScan`: Scans for components in current package and sub-packages

**Example:**
```java
// Equivalent to:
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class MyApplication {
    // Application code
}
```

---

### Q3: How does Spring Boot auto-configuration work?
**Answer:**
Auto-configuration uses `@Conditional` annotations to configure beans based on:
- **Classpath dependencies:** If H2 is present, configure H2 datasource
- **Existing beans:** Only configure if bean doesn't exist
- **Property values:** Configure based on application.properties

**Example:**
```java
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnMissingBean(DataSource.class)
public class DataSourceAutoConfiguration {
    
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}
```

---

### Q4: What are Spring Boot starters?
**Answer:**
Pre-configured dependency descriptors that bring in all necessary dependencies for a feature.

**Common Starters:**
```xml
<!-- Web applications -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- JPA with Hibernate -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- Testing -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

---

### Q5: Difference between Spring and Spring Boot?
**Answer:**

| Spring | Spring Boot |
|--------|-------------|
| Requires manual configuration | Auto-configuration |
| No embedded server | Embedded Tomcat/Jetty |
| XML or Java configuration | Convention over configuration |
| Manual dependency management | Starter dependencies |
| No production features | Actuator for monitoring |
| Complex setup | Quick start |

---

### Q6: What is application.properties vs application.yml?
**Answer:**
Both are configuration files, different formats.

**application.properties:**
```properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.jpa.hibernate.ddl-auto=update
```

**application.yml:**
```yaml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
  jpa:
    hibernate:
      ddl-auto: update
```

**Advantages of YAML:**
- More readable
- Hierarchical structure
- Less repetition
- Supports lists

---

### Q7: How to change default port in Spring Boot?
**Answer:**
Multiple ways:

**1. application.properties:**
```properties
server.port=9090
```

**2. application.yml:**
```yaml
server:
  port: 9090
```

**3. Command line:**
```bash
java -jar app.jar --server.port=9090
```

**4. Environment variable:**
```bash
export SERVER_PORT=9090
```

**5. Programmatically:**
```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(MyApplication.class);
        app.setDefaultProperties(Collections.singletonMap("server.port", "9090"));
        app.run(args);
    }
}
```

---

### Q8: What is Spring Boot Actuator?
**Answer:**
Provides production-ready features for monitoring and managing applications.

**Configuration:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
```

**Common Endpoints:**
- `/actuator/health` - Application health
- `/actuator/info` - Application info
- `/actuator/metrics` - Application metrics
- `/actuator/env` - Environment properties
- `/actuator/beans` - All beans
- `/actuator/mappings` - Request mappings

---

### Q9: What are profiles in Spring Boot?
**Answer:**
Profiles allow different configurations for different environments.

**Define profiles:**
```yaml
# application.yml (common)
spring:
  application:
    name: myapp

---
# application-dev.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
logging:
  level:
    root: DEBUG

---
# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/mydb
logging:
  level:
    root: INFO
```

**Activate profile:**
```bash
java -jar app.jar --spring.profiles.active=prod
```

**Conditional beans:**
```java
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        return new H2DataSource();
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        return new MysqlDataSource();
    }
}
```

---

### Q10: What is @Value annotation?
**Answer:**
Injects property values from configuration files.

**application.properties:**
```properties
app.name=MyApplication
app.version=1.0.0
app.max.retry=3
```

**Usage:**
```java
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String version;
    
    @Value("${app.max.retry:5}")  // Default value 5
    private int maxRetry;
    
    @Value("${app.features}")  // Comma-separated
    private List<String> features;
}
```

---

## 2. Dependency Injection & IoC

### Q11: What is Dependency Injection?
**Answer:**
Design pattern where objects receive their dependencies from external source rather than creating them.

**Types:**
1. **Constructor Injection (Recommended)**
2. **Setter Injection**
3. **Field Injection**

**Example:**
```java
// Constructor Injection (Best practice)
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    @Autowired  // Optional in single constructor
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}

// Setter Injection
@Service
public class OrderService {
    private PaymentService paymentService;
    
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// Field Injection (Not recommended)
@Service
public class ProductService {
    @Autowired
    private ProductRepository productRepository;  // Hard to test
}
```

---

### Q12: What is IoC Container?
**Answer:**
Inversion of Control Container manages bean lifecycle and dependencies.

**Two types:**
1. **BeanFactory:** Basic IoC container
2. **ApplicationContext:** Advanced IoC container (used by Spring Boot)

**Bean Lifecycle:**
```java
@Component
public class MyBean {
    
    public MyBean() {
        System.out.println("1. Constructor called");
    }
    
    @PostConstruct
    public void init() {
        System.out.println("2. PostConstruct called");
    }
    
    @PreDestroy
    public void destroy() {
        System.out.println("3. PreDestroy called");
    }
}
```

---

### Q13: What are bean scopes?
**Answer:**

| Scope | Description | Lifecycle |
|-------|-------------|-----------|
| singleton | One instance per container (default) | Container lifetime |
| prototype | New instance each time | Request lifetime |
| request | One per HTTP request | HTTP request |
| session | One per HTTP session | HTTP session |
| application | One per ServletContext | Application lifetime |

**Example:**
```java
@Service
@Scope("singleton")  // Default
public class SingletonService {
    // Single instance
}

@Component
@Scope("prototype")
public class PrototypeBean {
    // New instance each time
}

@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {
    // New instance per HTTP request
}
```

---

### Q14: What is @Autowired annotation?
**Answer:**
Enables automatic dependency injection.

**Usage:**
```java
// Constructor (Recommended)
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Autowired  // Optional for single constructor
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

// Field
@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
}

// Setter
@Service
public class ProductService {
    private ProductRepository productRepository;
    
    @Autowired
    public void setProductRepository(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }
}

// Optional dependency
@Service
public class EmailService {
    @Autowired(required = false)
    private SmtpServer smtpServer;  // Null if not found
}
```

---

### Q15: @Component vs @Service vs @Repository vs @Controller?
**Answer:**

| Annotation | Purpose | Layer |
|------------|---------|-------|
| @Component | Generic stereotype | Any |
| @Service | Business logic | Service |
| @Repository | Data access | Persistence |
| @Controller | MVC controller | Web |
| @RestController | REST API | Web |

**Example:**
```java
@Component
public class EmailValidator {
    // Generic component
}

@Service
public class UserService {
    // Business logic
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Data access
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    // REST endpoints
}
```

---

### Q16: What is @Qualifier annotation?
**Answer:**
Resolves ambiguity when multiple beans of same type exist.

**Example:**
```java
// Two implementations
@Component("emailNotification")
public class EmailNotificationService implements NotificationService {
    @Override
    public void send(String message) {
        // Send email
    }
}

@Component("smsNotification")
public class SmsNotificationService implements NotificationService {
    @Override
    public void send(String message) {
        // Send SMS
    }
}

// Use @Qualifier to specify which one
@Service
public class UserService {
    private final NotificationService notificationService;
    
    @Autowired
    public UserService(@Qualifier("emailNotification") NotificationService notificationService) {
        this.notificationService = notificationService;
    }
}
```

---

### Q17: What is @Primary annotation?
**Answer:**
Marks a bean as primary choice when multiple candidates exist.

**Example:**
```java
@Component
@Primary  // This will be injected by default
public class PrimaryPaymentService implements PaymentService {
    @Override
    public void processPayment(Payment payment) {
        // Primary implementation
    }
}

@Component
public class SecondaryPaymentService implements PaymentService {
    @Override
    public void processPayment(Payment payment) {
        // Secondary implementation
    }
}

@Service
public class OrderService {
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(PaymentService paymentService) {
        // PrimaryPaymentService will be injected
        this.paymentService = paymentService;
    }
}
```

---

### Q18: What is @Lazy annotation?
**Answer:**
Delays bean initialization until first use.

**Example:**
```java
@Service
@Lazy  // Not created until first use
public class HeavyService {
    
    public HeavyService() {
        System.out.println("Heavy initialization...");
        // Load large data, connect to external service
    }
}

@Service
public class UserService {
    
    @Autowired
    @Lazy  // Proxy created, actual bean created on first method call
    private HeavyService heavyService;
    
    public void someMethod() {
        heavyService.process();  // HeavyService initialized here
    }
}
```

---

### Q19: What is @PostConstruct and @PreDestroy?
**Answer:**
Lifecycle callback methods.

**Example:**
```java
@Component
public class DatabaseConnection {
    
    private Connection connection;
    
    @PostConstruct  // Called after dependency injection
    public void init() {
        System.out.println("Opening database connection...");
        connection = DriverManager.getConnection("jdbc:mysql://localhost/mydb");
    }
    
    @PreDestroy  // Called before bean destruction
    public void cleanup() {
        System.out.println("Closing database connection...");
        if (connection != null) {
            connection.close();
        }
    }
}
```

---

### Q20: How to create custom auto-configuration?
**Answer:**
Create auto-configuration class and register in `spring.factories`.

**Step 1: Auto-configuration class**
```java
@Configuration
@ConditionalOnClass(CustomService.class)
@EnableConfigurationProperties(CustomProperties.class)
public class CustomAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public CustomService customService(CustomProperties properties) {
        return new CustomService(properties);
    }
}
```

**Step 2: Properties class**
```java
@ConfigurationProperties(prefix = "custom")
public class CustomProperties {
    private String apiKey;
    private int timeout = 30;
    
    // Getters and setters
}
```

**Step 3: Register in META-INF/spring.factories**
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfigure.CustomAutoConfiguration
```

---

## 3. Configuration

### Q21: What is @ConfigurationProperties?
**Answer:**
Type-safe configuration binding.

**application.yml:**
```yaml
app:
  name: MyApplication
  version: 1.0.0
  security:
    enabled: true
    timeout: 3600
  features:
    - feature1
    - feature2
```

**Configuration class:**
```java
@Configuration
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {
    
    @NotBlank
    private String name;
    
    private String version;
    
    private Security security;
    
    private List<String> features;
    
    public static class Security {
        private boolean enabled;
        private int timeout;
        
        // Getters and setters
    }
    
    // Getters and setters
}
```

**Usage:**
```java
@Service
public class MyService {
    private final AppProperties appProperties;
    
    @Autowired
    public MyService(AppProperties appProperties) {
        this.appProperties = appProperties;
    }
    
    public void process() {
        if (appProperties.getSecurity().isEnabled()) {
            // Security enabled
        }
    }
}
```

---

### Q22: How to externalize configuration?
**Answer:**
Multiple ways to provide configuration:

**Priority order (highest to lowest):**
1. Command line arguments
2. Java system properties
3. OS environment variables
4. application-{profile}.properties outside JAR
5. application-{profile}.properties inside JAR
6. application.properties outside JAR
7. application.properties inside JAR

**Examples:**
```bash
# Command line
java -jar app.jar --server.port=9090

# System property
java -Dserver.port=9090 -jar app.jar

# Environment variable
export SERVER_PORT=9090
java -jar app.jar

# External config file
java -jar app.jar --spring.config.location=/path/to/config/
```

---

### Q23: What is @ConditionalOnProperty?
**Answer:**
Conditionally create bean based on property value.

**Example:**
```java
@Configuration
public class FeatureConfig {
    
    @Bean
    @ConditionalOnProperty(name = "feature.email.enabled", havingValue = "true", matchIfMissing = false)
    public EmailService emailService() {
        return new EmailService();
    }
    
    @Bean
    @ConditionalOnProperty(prefix = "feature", name = "sms.enabled", havingValue = "true")
    public SmsService smsService() {
        return new SmsService();
    }
}
```

**application.yml:**
```yaml
feature:
  email:
    enabled: true
  sms:
    enabled: false
```

---

### Q24: What is CommandLineRunner?
**Answer:**
Executes code after application startup.

**Example:**
```java
@Component
public class DataLoader implements CommandLineRunner {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public void run(String... args) throws Exception {
        // Load initial data
        if (userRepository.count() == 0) {
            userRepository.save(new User("admin", "admin@example.com"));
            userRepository.save(new User("user", "user@example.com"));
        }
        
        // Process command line arguments
        for (String arg : args) {
            System.out.println("Argument: " + arg);
        }
    }
}
```

---

### Q25: ApplicationRunner vs CommandLineRunner?
**Answer:**

| Feature | CommandLineRunner | ApplicationRunner |
|---------|-------------------|-------------------|
| Arguments | String[] | ApplicationArguments |
| Access | Raw strings | Option/non-option args |
| Parse | Manual | Automatic |

**Example:**
```java
// CommandLineRunner
@Component
public class MyCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... args) throws Exception {
        // args = ["--name=John", "file.txt"]
        System.out.println(args[0]);  // --name=John
    }
}

// ApplicationRunner (Better)
@Component
public class MyApplicationRunner implements ApplicationRunner {
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // Option arguments: --name=John
        if (args.containsOption("name")) {
            String name = args.getOptionValues("name").get(0);  // John
        }
        
        // Non-option arguments: file.txt
        List<String> files = args.getNonOptionArgs();  // [file.txt]
    }
}
```

---

## 4. Advanced Topics

### Q26: How to create custom starter?
**Answer:**

**Step 1: Create autoconfigure module**
```java
// CustomAutoConfiguration.java
@Configuration
@ConditionalOnClass(CustomService.class)
@EnableConfigurationProperties(CustomProperties.class)
public class CustomAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public CustomService customService(CustomProperties properties) {
        return new CustomServiceImpl(properties);
    }
}

// CustomProperties.java
@ConfigurationProperties(prefix = "custom")
public class CustomProperties {
    private String apiKey;
    private int timeout = 30;
    // Getters/setters
}
```

**Step 2: META-INF/spring.factories**
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.autoconfigure.CustomAutoConfiguration
```

**Step 3: Create starter module**
```xml
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>custom-spring-boot-autoconfigure</artifactId>
        <version>${project.version}</version>
    </dependency>
    <!-- Additional dependencies -->
</dependencies>
```

---

### Q27: What is Spring Boot DevTools?
**Answer:**
Development-time tools for better developer experience.

**Features:**
- Automatic restart on code changes
- LiveReload support
- Configurations for development
- Remote debugging

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

**Configuration:**
```yaml
spring:
  devtools:
    restart:
      enabled: true
      exclude: static/**,public/**
    livereload:
      enabled: true
```

---

### Q28: How to run Spring Boot as service?
**Answer:**

**Linux (systemd):**
```bash
# Create service file: /etc/systemd/system/myapp.service
[Unit]
Description=My Spring Boot Application
After=syslog.target

[Service]
User=myapp
ExecStart=/usr/bin/java -jar /opt/myapp/app.jar
SuccessExitStatus=143

[Install]
WantedBy=multi-user.target

# Enable and start
sudo systemctl enable myapp
sudo systemctl start myapp
```

**Windows:**
```xml
<!-- Use winsw (Windows Service Wrapper) -->
<service>
    <id>myapp</id>
    <name>My Application</name>
    <description>Spring Boot Application</description>
    <executable>java</executable>
    <arguments>-jar app.jar</arguments>
</service>
```

---

### Q29: What is Spring Boot Maven Plugin?
**Answer:**
Provides Maven goals for Spring Boot applications.

**Configuration:**
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <mainClass>com.example.MyApplication</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>
```

**Goals:**
```bash
# Run application
mvn spring-boot:run

# Package as executable JAR
mvn package

# Build Docker image
mvn spring-boot:build-image
```

---

### Q30: How to enable HTTPS in Spring Boot?
**Answer:**

**Step 1: Generate keystore**
```bash
keytool -genkeypair -alias myapp -keyalg RSA -keysize 2048 \
  -storetype PKCS12 -keystore keystore.p12 -validity 3650
```

**Step 2: Configure application.yml**
```yaml
server:
  port: 8443
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: changeit
    key-store-type: PKCS12
    key-alias: myapp
```

**Step 3: Redirect HTTP to HTTPS (Optional)**
```java
@Configuration
public class HttpsConfig {
    
    @Bean
    public ServletWebServerFactory servletContainer() {
        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() {
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint securityConstraint = new SecurityConstraint();
                securityConstraint.setUserConstraint("CONFIDENTIAL");
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern("/*");
                securityConstraint.addCollection(collection);
                context.addConstraint(securityConstraint);
            }
        };
        tomcat.addAdditionalTomcatConnectors(redirectConnector());
        return tomcat;
    }
    
    private Connector redirectConnector() {
        Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
        connector.setScheme("http");
        connector.setPort(8080);
        connector.setSecure(false);
        connector.setRedirectPort(8443);
        return connector;
    }
}
```

---

## Summary

Core Spring Boot concepts: Auto-configuration simplifies setup, starters provide dependencies, embedded servers eliminate deployment complexity. Dependency injection via constructor (recommended), setter, or field. Bean scopes: singleton (default), prototype, request, session. Configuration via application.properties/yml, @ConfigurationProperties for type-safety, profiles for environments. Actuator for monitoring (/health, /metrics, /info). Annotations: @SpringBootApplication (combination of @Configuration, @EnableAutoConfiguration, @ComponentScan), @Autowired (DI), @Qualifier (resolve ambiguity), @Primary (default choice), @Value (property injection). Lifecycle: @PostConstruct (after DI), @PreDestroy (before destruction). CommandLineRunner/ApplicationRunner for startup tasks. DevTools for development, Maven plugin for building. Essential for Spring Boot mastery.

---

**Next:** REST API Questions â†’
