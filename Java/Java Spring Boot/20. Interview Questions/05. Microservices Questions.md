# Microservices Interview Questions

---

## 1. Microservices Fundamentals

### Q1: What are microservices?
**Answer:**
Architectural style where application is composed of small, independent services.

**Characteristics:**
- **Single responsibility:** Each service does one thing
- **Independently deployable:** Deploy without affecting others
- **Decentralized:** Own database, technology stack
- **Fault isolation:** Failure doesn't cascade
- **Scalable:** Scale services independently

**Example:**
```
E-commerce Application:
├── User Service (8081)
├── Product Service (8082)
├── Order Service (8083)
├── Payment Service (8084)
├── Inventory Service (8085)
└── Notification Service (8086)
```

**Monolith vs Microservices:**

| Monolith | Microservices |
|----------|---------------|
| Single deployment unit | Multiple services |
| One database | Database per service |
| Tight coupling | Loose coupling |
| Scale entire app | Scale individual services |
| One technology stack | Polyglot architecture |

---

### Q2: What is Spring Cloud?
**Answer:**
Framework for building microservices-based applications.

**Components:**
```xml
<!-- Service Discovery -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<!-- API Gateway -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<!-- Circuit Breaker -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>

<!-- Config Server -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>

<!-- Load Balancer -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

---

### Q3: What is service discovery?
**Answer:**
Mechanism for services to find and communicate with each other dynamically.

**Eureka Server:**
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```

**application.yml:**
```yaml
server:
  port: 8761

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
  server:
    enable-self-preservation: false
```

**Eureka Client:**
```java
@SpringBootApplication
@EnableDiscoveryClient
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

**application.yml:**
```yaml
spring:
  application:
    name: order-service

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true
```

**Service-to-Service Communication:**
```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    public Order createOrder(OrderDTO dto) {
        // Get product from Product Service
        String productServiceUrl = "http://product-service/api/products/" + dto.getProductId();
        Product product = restTemplate.getForObject(productServiceUrl, Product.class);
        
        // Create order
        Order order = new Order();
        order.setProduct(product);
        order.setQuantity(dto.getQuantity());
        
        return orderRepository.save(order);
    }
}

@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced  // Enable client-side load balancing
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

---

### Q4: What is API Gateway?
**Answer:**
Single entry point for all client requests, routes to appropriate services.

**Spring Cloud Gateway:**
```java
@SpringBootApplication
public class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

**application.yml:**
```yaml
spring:
  cloud:
    gateway:
      routes:
        # User Service
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - RewritePath=/api/users/(?<segment>.*), /${segment}
        
        # Product Service
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            - AddRequestHeader=X-Request-Source, Gateway
        
        # Order Service
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: CircuitBreaker
              args:
                name: orderCircuitBreaker
                fallbackUri: forward:/fallback/orders
```

**Custom Filter:**
```java
@Component
public class AuthenticationFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        if (!request.getHeaders().containsKey("Authorization")) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        String token = request.getHeaders().getFirst("Authorization");
        
        if (!isValidToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        return chain.filter(exchange);
    }
    
    @Override
    public int getOrder() {
        return -1;
    }
    
    private boolean isValidToken(String token) {
        // Validate JWT token
        return true;
    }
}
```

---

### Q5: What is circuit breaker pattern?
**Answer:**
Prevents cascading failures by failing fast when service is unavailable.

**States:**
- **Closed:** Normal operation, requests pass through
- **Open:** Service failing, requests rejected immediately
- **Half-Open:** Testing if service recovered

**Resilience4j Implementation:**
```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @CircuitBreaker(name = "productService", fallbackMethod = "getProductFallback")
    @Retry(name = "productService")
    @RateLimiter(name = "productService")
    public Product getProduct(Long productId) {
        return restTemplate.getForObject(
            "http://product-service/api/products/" + productId,
            Product.class
        );
    }
    
    // Fallback method
    public Product getProductFallback(Long productId, Exception ex) {
        Product fallback = new Product();
        fallback.setId(productId);
        fallback.setName("Product temporarily unavailable");
        return fallback;
    }
}
```

**Configuration:**
```yaml
resilience4j:
  circuitbreaker:
    instances:
      productService:
        register-health-indicator: true
        sliding-window-size: 10
        minimum-number-of-calls: 5
        permitted-number-of-calls-in-half-open-state: 3
        wait-duration-in-open-state: 10s
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 2s
  
  retry:
    instances:
      productService:
        max-attempts: 3
        wait-duration: 1s
  
  ratelimiter:
    instances:
      productService:
        limit-for-period: 10
        limit-refresh-period: 1s
        timeout-duration: 0
```

---

### Q6: What is Config Server?
**Answer:**
Centralized configuration management for distributed systems.

**Config Server:**
```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
```

**application.yml:**
```yaml
server:
  port: 8888

spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/mycompany/config-repo
          default-label: main
          search-paths: '{application}'
```

**Config Client:**
```yaml
spring:
  application:
    name: order-service
  cloud:
    config:
      uri: http://localhost:8888
      fail-fast: true
  config:
    import: optional:configserver:http://localhost:8888
```

**Refresh Configuration:**
```java
@RestController
@RefreshScope  // Enables configuration refresh
public class OrderController {
    
    @Value("${order.max-items}")
    private int maxItems;
    
    @GetMapping("/config")
    public Map<String, Object> getConfig() {
        return Map.of("maxItems", maxItems);
    }
}
```

**Trigger refresh:**
```bash
curl -X POST http://localhost:8080/actuator/refresh
```

---

### Q7: What is distributed tracing?
**Answer:**
Track requests across multiple microservices.

**Spring Cloud Sleuth + Zipkin:**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>
```

**application.yml:**
```yaml
spring:
  sleuth:
    sampler:
      probability: 1.0  # Sample 100% of requests
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web

logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%X{traceId}/%X{spanId}] %msg%n"
```

**Automatic tracing:**
```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order createOrder(OrderDTO dto) {
        // Trace ID automatically propagated
        Product product = restTemplate.getForObject(
            "http://product-service/api/products/" + dto.getProductId(),
            Product.class
        );
        
        // All logs include trace ID
        log.info("Creating order for product: {}", product.getName());
        
        return orderRepository.save(order);
    }
}
```

---

### Q8: What is event-driven architecture?
**Answer:**
Services communicate through events instead of direct calls.

**Using Spring Cloud Stream + Kafka:**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-kafka</artifactId>
</dependency>
```

**Producer:**
```java
@Service
public class OrderService {
    
    @Autowired
    private StreamBridge streamBridge;
    
    @Transactional
    public Order createOrder(OrderDTO dto) {
        Order order = orderRepository.save(dto.toEntity());
        
        // Publish event
        OrderCreatedEvent event = new OrderCreatedEvent(order.getId(), order.getTotal());
        streamBridge.send("orderCreated-out-0", event);
        
        return order;
    }
}
```

**Consumer:**
```java
@Service
public class NotificationService {
    
    @Bean
    public Consumer<OrderCreatedEvent> handleOrderCreated() {
        return event -> {
            log.info("Order created: {}", event.getOrderId());
            sendNotification(event);
        };
    }
    
    private void sendNotification(OrderCreatedEvent event) {
        // Send email/SMS notification
    }
}
```

**Configuration:**
```yaml
spring:
  cloud:
    stream:
      kafka:
        binder:
          brokers: localhost:9092
      bindings:
        orderCreated-out-0:
          destination: order-events
        handleOrderCreated-in-0:
          destination: order-events
          group: notification-service
```

---

### Q9: What is saga pattern?
**Answer:**
Manage distributed transactions across microservices.

**Choreography-based Saga:**
```java
// Order Service
@Service
public class OrderService {
    
    @Autowired
    private StreamBridge streamBridge;
    
    @Transactional
    public Order createOrder(OrderDTO dto) {
        Order order = new Order();
        order.setStatus(OrderStatus.PENDING);
        order = orderRepository.save(order);
        
        // Publish event
        OrderCreatedEvent event = new OrderCreatedEvent(order.getId(), dto.getItems());
        streamBridge.send("orderCreated", event);
        
        return order;
    }
    
    @Bean
    public Consumer<PaymentCompletedEvent> handlePaymentCompleted() {
        return event -> {
            Order order = orderRepository.findById(event.getOrderId()).orElseThrow();
            order.setStatus(OrderStatus.CONFIRMED);
            orderRepository.save(order);
            
            // Publish next event
            streamBridge.send("orderConfirmed", new OrderConfirmedEvent(order.getId()));
        };
    }
    
    @Bean
    public Consumer<PaymentFailedEvent> handlePaymentFailed() {
        return event -> {
            Order order = orderRepository.findById(event.getOrderId()).orElseThrow();
            order.setStatus(OrderStatus.CANCELLED);
            orderRepository.save(order);
        };
    }
}

// Payment Service
@Service
public class PaymentService {
    
    @Bean
    public Consumer<OrderCreatedEvent> processPayment() {
        return event -> {
            try {
                // Process payment
                Payment payment = processPayment(event);
                
                // Success
                streamBridge.send("paymentCompleted", 
                    new PaymentCompletedEvent(event.getOrderId(), payment.getId()));
            } catch (Exception e) {
                // Failure - compensate
                streamBridge.send("paymentFailed", 
                    new PaymentFailedEvent(event.getOrderId(), e.getMessage()));
            }
        };
    }
}

// Inventory Service
@Service
public class InventoryService {
    
    @Bean
    public Consumer<OrderConfirmedEvent> reserveInventory() {
        return event -> {
            try {
                reserveItems(event.getOrderId());
                streamBridge.send("inventoryReserved", new InventoryReservedEvent(event.getOrderId()));
            } catch (Exception e) {
                // Compensate - refund payment
                streamBridge.send("inventoryReservationFailed", 
                    new InventoryReservationFailedEvent(event.getOrderId()));
            }
        };
    }
}
```

---

### Q10: What is API versioning in microservices?
**Answer:**

**URI Versioning:**
```java
@RestController
@RequestMapping("/api/v1/orders")
public class OrderControllerV1 {
    @GetMapping("/{id}")
    public OrderV1 getOrder(@PathVariable Long id) {
        return orderService.findByIdV1(id);
    }
}

@RestController
@RequestMapping("/api/v2/orders")
public class OrderControllerV2 {
    @GetMapping("/{id}")
    public OrderV2 getOrder(@PathVariable Long id) {
        return orderService.findByIdV2(id);
    }
}
```

---

### Q11: What is service mesh?
**Answer:**
Infrastructure layer for service-to-service communication.

**Features:**
- Load balancing
- Service discovery
- Failure recovery
- Metrics and monitoring
- A/B testing
- Canary deployments

**Example: Istio, Linkerd**

---

### Q12: How to handle data consistency in microservices?
**Answer:**

**1. Eventual Consistency:**
```java
@Service
public class OrderService {
    
    @Transactional
    public Order createOrder(OrderDTO dto) {
        // Save order
        Order order = orderRepository.save(dto.toEntity());
        
        // Publish event - other services eventually consistent
        eventPublisher.publish(new OrderCreatedEvent(order));
        
        return order;
    }
}
```

**2. Two-Phase Commit (avoid in microservices):**
- Coordinator prepares all services
- Commit or rollback

**3. Saga Pattern:**
- Sequence of local transactions
- Compensating transactions on failure

---

### Q13: What is CQRS pattern?
**Answer:**
Command Query Responsibility Segregation - separate read and write models.

**Command Side (Write):**
```java
@Service
public class OrderCommandService {
    
    @Transactional
    public Order createOrder(CreateOrderCommand command) {
        Order order = new Order();
        // Process command
        order = orderRepository.save(order);
        
        // Publish event
        eventPublisher.publish(new OrderCreatedEvent(order));
        
        return order;
    }
}
```

**Query Side (Read):**
```java
@Service
public class OrderQueryService {
    
    @Autowired
    private OrderReadRepository readRepository;
    
    public OrderView getOrder(Long id) {
        return readRepository.findById(id).orElseThrow();
    }
    
    public List<OrderView> getOrdersByCustomer(Long customerId) {
        return readRepository.findByCustomerId(customerId);
    }
}

// Event handler updates read model
@Service
public class OrderEventHandler {
    
    @Bean
    public Consumer<OrderCreatedEvent> updateReadModel() {
        return event -> {
            OrderView view = new OrderView();
            view.setOrderId(event.getOrderId());
            view.setCustomerId(event.getCustomerId());
            orderReadRepository.save(view);
        };
    }
}
```

---

### Q14: How to test microservices?
**Answer:**

**1. Unit Tests:**
```java
@ExtendWith(MockitoExtension.class)
class OrderServiceTest {
    
    @Mock
    private OrderRepository orderRepository;
    
    @InjectMocks
    private OrderService orderService;
    
    @Test
    void createOrder_ShouldSaveOrder() {
        // Test service in isolation
    }
}
```

**2. Integration Tests:**
```java
@SpringBootTest
@AutoConfigureMockMvc
class OrderControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    void getOrder_ShouldReturnOrder() throws Exception {
        mockMvc.perform(get("/api/orders/1"))
               .andExpect(status().isOk());
    }
}
```

**3. Contract Testing (Pact):**
```java
@ExtendWith(PactConsumerTestExt.class)
class OrderServiceContractTest {
    
    @Pact(consumer = "order-service", provider = "product-service")
    public RequestResponsePact createPact(PactDslWithProvider builder) {
        return builder
            .given("product exists")
            .uponReceiving("get product")
            .path("/api/products/1")
            .method("GET")
            .willRespondWith()
            .status(200)
            .body(newJsonBody(body -> {
                body.numberType("id", 1);
                body.stringType("name", "Product 1");
            }).build())
            .toPact();
    }
}
```

**4. End-to-End Tests:**
```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class E2ETest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void completeOrderFlow() {
        // Test entire flow across services
    }
}
```

---

### Q15: Best practices for microservices?
**Answer:**

1. **Single Responsibility:** One service, one business capability
2. **Database per Service:** Don't share databases
3. **API Gateway:** Single entry point
4. **Service Discovery:** Dynamic service location
5. **Circuit Breaker:** Prevent cascading failures
6. **Centralized Configuration:** Config server
7. **Distributed Tracing:** Track requests
8. **Event-Driven:** Async communication
9. **Containerization:** Docker, Kubernetes
10. **Monitoring:** Prometheus, Grafana
11. **Security:** OAuth2, JWT at gateway
12. **Versioning:** Version APIs properly
13. **Documentation:** OpenAPI/Swagger
14. **Testing:** Unit, integration, contract tests
15. **CI/CD:** Automated pipelines

---

## Summary

Microservices architecture: Independent, deployable services with single responsibility. Spring Cloud components: Eureka (service discovery), Gateway (API gateway), Resilience4j (circuit breaker), Config Server (centralized config), Sleuth+Zipkin (distributed tracing). Communication patterns: REST (synchronous), Events (asynchronous with Kafka/RabbitMQ). Circuit breaker prevents cascading failures with states: closed, open, half-open. Saga pattern for distributed transactions with choreography or orchestration. CQRS separates read/write models. Service mesh (Istio) for infrastructure concerns. API Gateway routes requests, handles authentication, rate limiting. Config Server centralizes configuration from Git repository. Testing: unit, integration, contract (Pact), E2E. Best practices: database per service, event-driven, containerization, monitoring, security at gateway.

---

**Next:** Coding Problems →
