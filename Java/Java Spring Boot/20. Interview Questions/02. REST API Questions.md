# REST API Interview Questions

---

## 1. REST Fundamentals

### Q1: What is REST?
**Answer:**
REST (Representational State Transfer) is an architectural style for designing networked applications.

**Key Principles:**
1. **Client-Server:** Separation of concerns
2. **Stateless:** Each request contains all information
3. **Cacheable:** Responses can be cached
4. **Uniform Interface:** Standard HTTP methods
5. **Layered System:** Hierarchical layers
6. **Code on Demand (Optional):** Server can send executable code

**Example:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}
```

---

### Q2: HTTP methods and their usage?
**Answer:**

| Method | Purpose | Idempotent | Safe |
|--------|---------|------------|------|
| GET | Retrieve resource | Yes | Yes |
| POST | Create resource | No | No |
| PUT | Update/Replace resource | Yes | No |
| PATCH | Partial update | No | No |
| DELETE | Delete resource | Yes | No |
| HEAD | Get headers only | Yes | Yes |
| OPTIONS | Get allowed methods | Yes | Yes |

**Example:**
```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // GET - Retrieve
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable Long id) {
        return ResponseEntity.ok(productService.findById(id));
    }
    
    // POST - Create
    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody ProductDTO dto) {
        Product product = productService.create(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(product);
    }
    
    // PUT - Update (full replacement)
    @PutMapping("/{id}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long id, @RequestBody ProductDTO dto) {
        Product product = productService.update(id, dto);
        return ResponseEntity.ok(product);
    }
    
    // PATCH - Partial update
    @PatchMapping("/{id}")
    public ResponseEntity<Product> partialUpdate(@PathVariable Long id, @RequestBody Map<String, Object> updates) {
        Product product = productService.partialUpdate(id, updates);
        return ResponseEntity.ok(product);
    }
    
    // DELETE - Remove
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
```

---

### Q3: HTTP status codes?
**Answer:**

**2xx Success:**
- 200 OK - Request succeeded
- 201 Created - Resource created
- 204 No Content - Success, no body
- 206 Partial Content - Range request

**3xx Redirection:**
- 301 Moved Permanently
- 302 Found (temporary redirect)
- 304 Not Modified (cached)

**4xx Client Error:**
- 400 Bad Request - Invalid input
- 401 Unauthorized - Authentication required
- 403 Forbidden - No permission
- 404 Not Found - Resource not found
- 409 Conflict - Resource conflict
- 422 Unprocessable Entity - Validation error

**5xx Server Error:**
- 500 Internal Server Error
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout

**Example:**
```java
@RestController
public class OrderController {
    
    @PostMapping("/api/orders")
    public ResponseEntity<Order> createOrder(@RequestBody OrderDTO dto) {
        Order order = orderService.create(dto);
        return ResponseEntity
                .status(HttpStatus.CREATED)  // 201
                .header("Location", "/api/orders/" + order.getId())
                .body(order);
    }
    
    @GetMapping("/api/orders/{id}")
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        return orderService.findById(id)
                .map(ResponseEntity::ok)  // 200
                .orElse(ResponseEntity.notFound().build());  // 404
    }
    
    @DeleteMapping("/api/orders/{id}")
    public ResponseEntity<Void> deleteOrder(@PathVariable Long id) {
        orderService.delete(id);
        return ResponseEntity.noContent().build();  // 204
    }
}
```

---

### Q4: @RestController vs @Controller?
**Answer:**

| @Controller | @RestController |
|-------------|-----------------|
| Returns view name | Returns data (JSON/XML) |
| Needs @ResponseBody | Implicit @ResponseBody |
| For web pages | For REST APIs |

**Example:**
```java
// Traditional Controller (MVC)
@Controller
public class WebController {
    
    @GetMapping("/home")
    public String home(Model model) {
        model.addAttribute("message", "Hello");
        return "home";  // Returns view name
    }
    
    @GetMapping("/api/data")
    @ResponseBody  // Required to return data
    public User getData() {
        return new User("John");
    }
}

// REST Controller (API)
@RestController  // Combines @Controller + @ResponseBody
@RequestMapping("/api")
public class ApiController {
    
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.findAll();  // Automatically converted to JSON
    }
}
```

---

### Q5: @RequestMapping vs specific annotations?
**Answer:**

**@RequestMapping (Generic):**
```java
@RequestMapping(value = "/users", method = RequestMethod.GET)
public List<User> getUsers() { }
```

**Specific Annotations (Better):**
```java
@GetMapping("/users")
public List<User> getUsers() { }

@PostMapping("/users")
public User createUser(@RequestBody UserDTO dto) { }

@PutMapping("/users/{id}")
public User updateUser(@PathVariable Long id, @RequestBody UserDTO dto) { }

@DeleteMapping("/users/{id}")
public void deleteUser(@PathVariable Long id) { }

@PatchMapping("/users/{id}")
public User patchUser(@PathVariable Long id, @RequestBody Map<String, Object> updates) { }
```

**Advantages of specific annotations:**
- More concise
- Better readability
- Type-safe

---

## 2. Request Handling

### Q6: @PathVariable vs @RequestParam?
**Answer:**

| @PathVariable | @RequestParam |
|---------------|---------------|
| Part of URL path | Query parameter |
| Required by default | Optional with default |
| `/users/{id}` | `/users?id=123` |

**Example:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // @PathVariable - Part of URL
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    // URL: /api/users/123
    
    // @RequestParam - Query parameter
    @GetMapping
    public List<User> searchUsers(
            @RequestParam String name,
            @RequestParam(required = false, defaultValue = "0") int page,
            @RequestParam(required = false, defaultValue = "20") int size) {
        return userService.search(name, page, size);
    }
    // URL: /api/users?name=John&page=0&size=20
    
    // Combined
    @GetMapping("/{id}/orders")
    public List<Order> getUserOrders(
            @PathVariable Long id,
            @RequestParam(required = false) String status) {
        return orderService.findByUserIdAndStatus(id, status);
    }
    // URL: /api/users/123/orders?status=PENDING
}
```

---

### Q7: @RequestBody vs @RequestParam vs @PathVariable?
**Answer:**

```java
@RestController
@RequestMapping("/api")
public class DemoController {
    
    // @PathVariable - From URL path
    @GetMapping("/users/{userId}/posts/{postId}")
    public Post getPost(
            @PathVariable Long userId,
            @PathVariable Long postId) {
        return postService.findByUserAndId(userId, postId);
    }
    // URL: /api/users/123/posts/456
    
    // @RequestParam - From query string
    @GetMapping("/users")
    public List<User> getUsers(
            @RequestParam(required = false) String name,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        return userService.findByName(name, page, size);
    }
    // URL: /api/users?name=John&page=0&size=20
    
    // @RequestBody - From request body (POST/PUT)
    @PostMapping("/users")
    public User createUser(@RequestBody UserDTO dto) {
        return userService.create(dto);
    }
    // Body: {"name": "John", "email": "john@example.com"}
    
    // All combined
    @PutMapping("/users/{id}")
    public User updateUser(
            @PathVariable Long id,
            @RequestBody UserDTO dto,
            @RequestParam(required = false) boolean notify) {
        return userService.update(id, dto, notify);
    }
    // URL: /api/users/123?notify=true
    // Body: {"name": "John", "email": "john@example.com"}
}
```

---

### Q8: How to handle request headers?
**Answer:**

```java
@RestController
public class HeaderController {
    
    // Single header
    @GetMapping("/api/users")
    public List<User> getUsers(@RequestHeader("Authorization") String token) {
        return userService.findAll(token);
    }
    
    // Optional header
    @GetMapping("/api/products")
    public List<Product> getProducts(
            @RequestHeader(value = "X-API-Version", defaultValue = "v1") String version) {
        return productService.findAll(version);
    }
    
    // All headers
    @GetMapping("/api/debug")
    public Map<String, String> debugHeaders(@RequestHeader Map<String, String> headers) {
        return headers;
    }
    
    // HttpHeaders object
    @GetMapping("/api/info")
    public String getInfo(@RequestHeader HttpHeaders headers) {
        String userAgent = headers.getFirst("User-Agent");
        List<String> acceptLanguages = headers.get("Accept-Language");
        return "User-Agent: " + userAgent;
    }
}
```

---

### Q9: How to validate request data?
**Answer:**

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

**DTO with validation:**
```java
public class UserDTO {
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must be less than 120")
    private Integer age;
    
    @Pattern(regexp = "^\\d{10}$", message = "Phone must be 10 digits")
    private String phone;
    
    @Valid  // Nested validation
    private Address address;
    
    // Getters and setters
}

public class Address {
    @NotBlank
    private String street;
    
    @NotBlank
    private String city;
    
    @NotBlank
    @Pattern(regexp = "\\d{5}")
    private String zipCode;
}
```

**Controller:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO dto) {
        User user = userService.create(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
}
```

**Global exception handler:**
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ErrorResponse response = new ErrorResponse(
            "Validation failed",
            errors
        );
        
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

### Q10: How to implement pagination?
**Answer:**

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // Simple pagination
    @GetMapping
    public ResponseEntity<Page<ProductDTO>> getProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "id") String sortBy,
            @RequestParam(defaultValue = "ASC") Sort.Direction direction) {
        
        PageRequest pageRequest = PageRequest.of(page, size, Sort.by(direction, sortBy));
        Page<ProductDTO> products = productService.findAll(pageRequest);
        
        return ResponseEntity.ok(products);
    }
    
    // With Pageable
    @GetMapping("/v2")
    public ResponseEntity<Page<ProductDTO>> getProductsV2(Pageable pageable) {
        Page<ProductDTO> products = productService.findAll(pageable);
        return ResponseEntity.ok(products);
    }
    
    // Custom response
    @GetMapping("/v3")
    public ResponseEntity<PaginatedResponse<ProductDTO>> getProductsV3(
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) 
            Pageable pageable) {
        
        Page<ProductDTO> page = productService.findAll(pageable);
        
        PaginatedResponse<ProductDTO> response = new PaginatedResponse<>();
        response.setContent(page.getContent());
        response.setPageNumber(page.getNumber());
        response.setPageSize(page.getSize());
        response.setTotalElements(page.getTotalElements());
        response.setTotalPages(page.getTotalPages());
        response.setLast(page.isLast());
        
        return ResponseEntity.ok(response);
    }
}

// Custom response DTO
@Data
public class PaginatedResponse<T> {
    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean last;
}
```

**URL examples:**
```
GET /api/products?page=0&size=20
GET /api/products?page=1&size=50&sortBy=price&direction=DESC
GET /api/products?page=0&size=10&sort=name,asc&sort=price,desc
```

---

## 3. Response Handling

### Q11: How to customize response?
**Answer:**

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // Simple response
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // ResponseEntity with status
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody UserDTO dto) {
        User user = userService.create(dto);
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(user);
    }
    
    // With headers
    @PostMapping("/v2")
    public ResponseEntity<User> createUserV2(@RequestBody UserDTO dto) {
        User user = userService.create(dto);
        
        HttpHeaders headers = new HttpHeaders();
        headers.add("X-User-Id", user.getId().toString());
        headers.add("Location", "/api/users/" + user.getId());
        
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .headers(headers)
                .body(user);
    }
    
    // Optional response
    @GetMapping("/{id}/optional")
    public ResponseEntity<User> getUserOptional(@PathVariable Long id) {
        return userService.findByIdOptional(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
    
    // No content
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }
    
    // Custom wrapper
    @GetMapping("/wrapped")
    public ResponseEntity<ApiResponse<List<User>>> getUsers() {
        List<User> users = userService.findAll();
        
        ApiResponse<List<User>> response = ApiResponse.<List<User>>builder()
                .success(true)
                .message("Users retrieved successfully")
                .data(users)
                .timestamp(LocalDateTime.now())
                .build();
        
        return ResponseEntity.ok(response);
    }
}

@Data
@Builder
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private LocalDateTime timestamp;
}
```

---

### Q12: How to implement HATEOAS?
**Answer:**
HATEOAS (Hypermedia As The Engine Of Application State) adds links to responses.

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

**Example:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public EntityModel<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        
        EntityModel<User> resource = EntityModel.of(user);
        
        // Add links
        resource.add(linkTo(methodOn(UserController.class).getUser(id)).withSelfRel());
        resource.add(linkTo(methodOn(UserController.class).getAllUsers()).withRel("all-users"));
        resource.add(linkTo(methodOn(OrderController.class).getUserOrders(id)).withRel("orders"));
        
        return resource;
    }
    
    @GetMapping
    public CollectionModel<EntityModel<User>> getAllUsers() {
        List<EntityModel<User>> users = userService.findAll().stream()
                .map(user -> EntityModel.of(user,
                        linkTo(methodOn(UserController.class).getUser(user.getId())).withSelfRel(),
                        linkTo(methodOn(OrderController.class).getUserOrders(user.getId())).withRel("orders")))
                .collect(Collectors.toList());
        
        return CollectionModel.of(users,
                linkTo(methodOn(UserController.class).getAllUsers()).withSelfRel());
    }
}
```

**Response:**
```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "_links": {
    "self": {
      "href": "http://localhost:8080/api/users/1"
    },
    "all-users": {
      "href": "http://localhost:8080/api/users"
    },
    "orders": {
      "href": "http://localhost:8080/api/users/1/orders"
    }
  }
}
```

---

### Q13: How to handle file upload/download?
**Answer:**

**Upload:**
```java
@RestController
@RequestMapping("/api/files")
public class FileController {
    
    // Single file upload
    @PostMapping("/upload")
    public ResponseEntity<FileResponse> uploadFile(@RequestParam("file") MultipartFile file) {
        if (file.isEmpty()) {
            throw new BadRequestException("File is empty");
        }
        
        String fileName = fileService.store(file);
        
        FileResponse response = new FileResponse(fileName, file.getSize(), file.getContentType());
        return ResponseEntity.ok(response);
    }
    
    // Multiple files upload
    @PostMapping("/upload-multiple")
    public ResponseEntity<List<FileResponse>> uploadMultipleFiles(
            @RequestParam("files") MultipartFile[] files) {
        
        List<FileResponse> responses = Arrays.stream(files)
                .map(file -> {
                    String fileName = fileService.store(file);
                    return new FileResponse(fileName, file.getSize(), file.getContentType());
                })
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(responses);
    }
    
    // With additional data
    @PostMapping("/upload-with-data")
    public ResponseEntity<Document> uploadWithData(
            @RequestParam("file") MultipartFile file,
            @RequestParam("title") String title,
            @RequestParam("description") String description) {
        
        String fileName = fileService.store(file);
        
        Document document = new Document();
        document.setFileName(fileName);
        document.setTitle(title);
        document.setDescription(description);
        
        Document saved = documentService.save(document);
        return ResponseEntity.ok(saved);
    }
}

@Service
public class FileService {
    
    @Value("${file.upload-dir}")
    private String uploadDir;
    
    public String store(MultipartFile file) {
        String fileName = StringUtils.cleanPath(file.getOriginalFilename());
        
        try {
            // Check file name
            if (fileName.contains("..")) {
                throw new BadRequestException("Invalid file path");
            }
            
            // Save file
            Path targetLocation = Paths.get(uploadDir).resolve(fileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            
            return fileName;
        } catch (IOException ex) {
            throw new FileStorageException("Could not store file " + fileName, ex);
        }
    }
}
```

**Download:**
```java
@RestController
@RequestMapping("/api/files")
public class FileController {
    
    @GetMapping("/download/{fileName:.+}")
    public ResponseEntity<Resource> downloadFile(@PathVariable String fileName) {
        Resource resource = fileService.loadAsResource(fileName);
        
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                        "attachment; filename=\"" + resource.getFilename() + "\"")
                .body(resource);
    }
    
    @GetMapping("/view/{fileName:.+}")
    public ResponseEntity<Resource> viewFile(@PathVariable String fileName) {
        Resource resource = fileService.loadAsResource(fileName);
        
        String contentType = "application/octet-stream";
        try {
            contentType = Files.probeContentType(Paths.get(resource.getURI()));
        } catch (IOException ex) {
            // Use default
        }
        
        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType(contentType))
                .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                .body(resource);
    }
}

@Service
public class FileService {
    
    @Value("${file.upload-dir}")
    private String uploadDir;
    
    public Resource loadAsResource(String fileName) {
        try {
            Path filePath = Paths.get(uploadDir).resolve(fileName).normalize();
            Resource resource = new UrlResource(filePath.toUri());
            
            if (resource.exists() && resource.isReadable()) {
                return resource;
            } else {
                throw new FileNotFoundException("File not found: " + fileName);
            }
        } catch (MalformedURLException ex) {
            throw new FileNotFoundException("File not found: " + fileName, ex);
        }
    }
}
```

**Configuration:**
```yaml
spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB

file:
  upload-dir: ./uploads
```

---

### Q14: How to implement content negotiation?
**Answer:**
Serve different content types based on client's Accept header.

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping(value = "/{id}", produces = {MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // JSON only
    @GetMapping(value = "/json/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public User getUserJson(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // XML only
    @GetMapping(value = "/xml/{id}", produces = MediaType.APPLICATION_XML_VALUE)
    public User getUserXml(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

**Entity with XML annotations:**
```java
@Entity
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class User {
    
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    
    private String email;
    
    // Getters and setters
}
```

**Dependency for XML:**
```xml
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

**Request:**
```bash
# JSON response
curl -H "Accept: application/json" http://localhost:8080/api/users/1

# XML response
curl -H "Accept: application/xml" http://localhost:8080/api/users/1
```

---

### Q15: How to version REST API?
**Answer:**

**1. URI Versioning:**
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 {
    @GetMapping("/{id}")
    public UserV1 getUser(@PathVariable Long id) {
        return userService.findByIdV1(id);
    }
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
    @GetMapping("/{id}")
    public UserV2 getUser(@PathVariable Long id) {
        return userService.findByIdV2(id);
    }
}
```

**2. Request Parameter Versioning:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping(value = "/{id}", params = "version=1")
    public UserV1 getUserV1(@PathVariable Long id) {
        return userService.findByIdV1(id);
    }
    
    @GetMapping(value = "/{id}", params = "version=2")
    public UserV2 getUserV2(@PathVariable Long id) {
        return userService.findByIdV2(id);
    }
}
// URL: /api/users/1?version=2
```

**3. Header Versioning:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping(value = "/{id}", headers = "X-API-VERSION=1")
    public UserV1 getUserV1(@PathVariable Long id) {
        return userService.findByIdV1(id);
    }
    
    @GetMapping(value = "/{id}", headers = "X-API-VERSION=2")
    public UserV2 getUserV2(@PathVariable Long id) {
        return userService.findByIdV2(id);
    }
}
```

**4. Content Negotiation (Accept header):**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping(value = "/{id}", produces = "application/vnd.company.app-v1+json")
    public UserV1 getUserV1(@PathVariable Long id) {
        return userService.findByIdV1(id);
    }
    
    @GetMapping(value = "/{id}", produces = "application/vnd.company.app-v2+json")
    public UserV2 getUserV2(@PathVariable Long id) {
        return userService.findByIdV2(id);
    }
}
```

---

## 4. Exception Handling

### Q16: How to handle exceptions in REST API?
**Answer:**

```java
// Custom exceptions
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    // Specific exception
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // Validation exception
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ErrorResponse error = new ErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Validation failed",
            errors,
            LocalDateTime.now()
        );
        return ResponseEntity.badRequest().body(error);
    }
    
    // Generic exception
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "An error occurred",
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

@Data
@AllArgsConstructor
public class ErrorResponse {
    private int status;
    private String message;
    private Object errors;
    private LocalDateTime timestamp;
    
    public ErrorResponse(int status, String message, LocalDateTime timestamp) {
        this.status = status;
        this.message = message;
        this.timestamp = timestamp;
    }
}
```

---

### Q17: How to implement API documentation?
**Answer:**

**Using Springdoc OpenAPI (Swagger):**

**Dependency:**
```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.2.0</version>
</dependency>
```

**Configuration:**
```java
@Configuration
public class OpenApiConfig {
    
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("User Management API")
                        .version("1.0")
                        .description("API for managing users")
                        .contact(new Contact()
                                .name("API Support")
                                .email("support@example.com"))
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://www.apache.org/licenses/LICENSE-2.0")))
                .servers(List.of(
                        new Server().url("http://localhost:8080").description("Dev"),
                        new Server().url("https://api.example.com").description("Prod")
                ));
    }
}
```

**Controller with annotations:**
```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "User", description = "User management APIs")
public class UserController {
    
    @Operation(
        summary = "Get user by ID",
        description = "Returns a single user"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Success"),
        @ApiResponse(responseCode = "404", description = "User not found")
    })
    @GetMapping("/{id}")
    public User getUser(
            @Parameter(description = "User ID") @PathVariable Long id) {
        return userService.findById(id);
    }
    
    @Operation(summary = "Create new user")
    @PostMapping
    public User createUser(@RequestBody UserDTO dto) {
        return userService.create(dto);
    }
}
```

**Access Swagger UI:**
```
http://localhost:8080/swagger-ui.html
http://localhost:8080/v3/api-docs
```

---

### Q18: How to implement CORS?
**Answer:**

**Method 1: Global configuration**
```java
@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                        .allowedOrigins("http://localhost:3000", "https://example.com")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true)
                        .maxAge(3600);
            }
        };
    }
}
```

**Method 2: Controller level**
```java
@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "http://localhost:3000", maxAge = 3600)
public class UserController {
    
    @GetMapping
    public List<User> getUsers() {
        return userService.findAll();
    }
}
```

**Method 3: Method level**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @CrossOrigin(origins = "http://localhost:3000")
    @GetMapping
    public List<User> getUsers() {
        return userService.findAll();
    }
}
```

---

### Q19: How to implement rate limiting?
**Answer:**

**Using Bucket4j:**

**Dependency:**
```xml
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-core</artifactId>
    <version>7.6.0</version>
</dependency>
```

**Implementation:**
```java
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final Map<String, Bucket> cache = new ConcurrentHashMap<>();
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String key = getClientKey(request);
        Bucket bucket = resolveBucket(key);
        
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
        
        if (probe.isConsumed()) {
            response.addHeader("X-Rate-Limit-Remaining", String.valueOf(probe.getRemainingTokens()));
            return true;
        } else {
            response.setStatus(429);  // Too Many Requests
            response.addHeader("X-Rate-Limit-Retry-After-Seconds", 
                String.valueOf(probe.getNanosToWaitForRefill() / 1_000_000_000));
            return false;
        }
    }
    
    private Bucket resolveBucket(String key) {
        return cache.computeIfAbsent(key, k -> createNewBucket());
    }
    
    private Bucket createNewBucket() {
        Bandwidth limit = Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1)));
        return Bucket.builder()
                .addLimit(limit)
                .build();
    }
    
    private String getClientKey(HttpServletRequest request) {
        // Use IP address as key
        return request.getRemoteAddr();
    }
}

@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private RateLimitInterceptor rateLimitInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/**");
    }
}
```

---

### Q20: How to implement API caching?
**Answer:**

**ETags:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(
            @PathVariable Long id,
            WebRequest request) {
        
        User user = userService.findById(id);
        
        // Generate ETag based on version or last modified
        String etag = "\"" + user.getVersion() + "\"";
        
        // Check if client has cached version
        if (request.checkNotModified(etag)) {
            return null;  // 304 Not Modified
        }
        
        return ResponseEntity
                .ok()
                .eTag(etag)
                .body(user);
    }
}
```

**Cache-Control:**
```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping
    public ResponseEntity<List<Product>> getProducts() {
        List<Product> products = productService.findAll();
        
        return ResponseEntity
                .ok()
                .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS))
                .body(products);
    }
    
    @GetMapping("/no-cache")
    public ResponseEntity<List<Product>> getProductsNoCache() {
        List<Product> products = productService.findAll();
        
        return ResponseEntity
                .ok()
                .cacheControl(CacheControl.noCache())
                .body(products);
    }
}
```

---

## Summary

REST APIs in Spring Boot: @RestController combines @Controller and @ResponseBody. HTTP methods: GET (retrieve), POST (create), PUT (update), DELETE (remove). Status codes: 2xx success, 4xx client error, 5xx server error. Request parameters: @PathVariable (URL path), @RequestParam (query string), @RequestBody (request body). Validation with @Valid and Bean Validation annotations. Pagination with Pageable and Page<T>. Exception handling with @RestControllerAdvice and @ExceptionHandler. HATEOAS for hypermedia links. Content negotiation with produces/consumes. API versioning: URI, parameter, header, or content negotiation. CORS configuration for cross-origin requests. Documentation with Springdoc OpenAPI/Swagger. Rate limiting with interceptors. Caching with ETags and Cache-Control. File upload/download with MultipartFile and Resource. ResponseEntity for custom status and headers.

---

**Next:** Spring Data JPA Questions â†’
