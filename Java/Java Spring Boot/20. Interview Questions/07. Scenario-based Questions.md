# Scenario-based Questions

---

## Scenario 1: Application Slow Performance

**Problem:** Your Spring Boot application is responding slowly. Users complain about 5-10 second response times.

**Investigation Steps:**

1. **Enable Actuator Metrics:**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,httptrace,loggers
  metrics:
    export:
      prometheus:
        enabled: true
```

2. **Check Application Logs:**
```bash
# Look for slow queries
grep "slow query" application.log

# Check for OutOfMemory errors
grep "OutOfMemoryError" application.log
```

3. **Profile Database Queries:**
```yaml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

4. **Enable Slow Query Logging:**
```yaml
spring:
  datasource:
    hikari:
      leak-detection-threshold: 60000
logging:
  level:
    com.zaxxer.hikari: DEBUG
```

**Common Causes & Solutions:**

**A. N+1 Query Problem:**
```java
// Problem
@GetMapping("/orders")
public List<OrderDTO> getOrders() {
    List<Order> orders = orderRepository.findAll();  // 1 query
    return orders.stream()
            .map(order -> {
                // N queries for items
                order.getItems().size();
                return toDTO(order);
            })
            .collect(Collectors.toList());
}

// Solution: Use fetch join
@Query("SELECT o FROM Order o LEFT JOIN FETCH o.items")
List<Order> findAllWithItems();
```

**B. Missing Database Indexes:**
```sql
-- Check slow queries
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;

-- Add index
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

**C. Connection Pool Exhausted:**
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20  # Increase from default 10
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
```

**D. Blocking I/O Operations:**
```java
// Problem: Blocking call in request thread
@GetMapping("/product/{id}")
public Product getProduct(@PathVariable Long id) {
    Product product = productRepository.findById(id).orElseThrow();
    // Blocking external API call
    Inventory inventory = restTemplate.getForObject(
        "http://inventory-service/api/stock/" + id, Inventory.class);
    product.setStock(inventory.getStock());
    return product;
}

// Solution: Use async processing
@Async
public CompletableFuture<Inventory> getInventory(Long productId) {
    return CompletableFuture.supplyAsync(() ->
        restTemplate.getForObject(
            "http://inventory-service/api/stock/" + productId, Inventory.class));
}
```

**E. Missing Caching:**
```java
// Add caching for frequently accessed data
@Cacheable(value = "products", key = "#id")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElseThrow();
}
```

---

## Scenario 2: High Memory Usage / OutOfMemoryError

**Problem:** Application crashes with `java.lang.OutOfMemoryError: Java heap space`.

**Investigation:**

1. **Generate Heap Dump:**
```bash
# Add JVM options
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/app/heapdump.hprof

# Or manually
jmap -dump:live,format=b,file=heap.bin <pid>
```

2. **Analyze with Eclipse MAT or VisualVM:**
```bash
# Install Eclipse MAT
# Open heap dump and look for:
# - Largest objects
# - Dominator tree
# - Leak suspects
```

3. **Check Memory Metrics:**
```java
@RestController
public class MemoryController {
    
    @GetMapping("/memory")
    public Map<String, Long> getMemoryStats() {
        Runtime runtime = Runtime.getRuntime();
        return Map.of(
            "freeMemory", runtime.freeMemory() / 1024 / 1024,
            "totalMemory", runtime.totalMemory() / 1024 / 1024,
            "maxMemory", runtime.maxMemory() / 1024 / 1024,
            "usedMemory", (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024
        );
    }
}
```

**Common Causes & Solutions:**

**A. Loading Too Much Data:**
```java
// Problem: Loading all records
public List<Order> getAllOrders() {
    return orderRepository.findAll();  // 1 million records!
}

// Solution: Use pagination
public Page<Order> getOrders(Pageable pageable) {
    return orderRepository.findAll(pageable);
}

// Solution: Stream large results
@Query("SELECT o FROM Order o")
Stream<Order> streamAll();

@Transactional(readOnly = true)
public void processOrders() {
    try (Stream<Order> stream = orderRepository.streamAll()) {
        stream.forEach(this::processOrder);
    }
}
```

**B. Caching Too Much:**
```java
// Problem: Unbounded cache
@Cacheable("products")
public Product getProduct(Long id) {
    return productRepository.findById(id).orElseThrow();
}

// Solution: Configure cache size and TTL
@Bean
public CacheManager cacheManager() {
    CaffeineCacheManager cacheManager = new CaffeineCacheManager("products");
    cacheManager.setCaffeine(Caffeine.newBuilder()
        .maximumSize(1000)  // Max entries
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .recordStats());
    return cacheManager;
}
```

**C. Memory Leak - Unclosed Resources:**
```java
// Problem: Not closing resources
public void exportData() {
    FileWriter writer = new FileWriter("data.csv");
    writer.write(data);
    // writer never closed!
}

// Solution: Use try-with-resources
public void exportData() {
    try (FileWriter writer = new FileWriter("data.csv")) {
        writer.write(data);
    } catch (IOException e) {
        log.error("Export failed", e);
    }
}
```

**D. Large Collections in Session:**
```java
// Problem: Storing large objects in session
@GetMapping("/cart")
public String viewCart(HttpSession session) {
    List<Product> cart = (List<Product>) session.getAttribute("cart");
    // Storing full product objects with all data
}

// Solution: Store only IDs
public String viewCart(HttpSession session) {
    List<Long> cartIds = (List<Long>) session.getAttribute("cartIds");
    List<Product> products = productRepository.findAllById(cartIds);
}
```

**E. Increase Heap Size:**
```bash
# Adjust JVM options
java -Xms512m -Xmx2048m -jar application.jar
```

---

## Scenario 3: Database Connection Pool Exhausted

**Problem:** Application throws `HikariPool - Connection is not available`.

**Investigation:**

```java
@RestController
public class PoolMonitorController {
    
    @Autowired
    private DataSource dataSource;
    
    @GetMapping("/pool-stats")
    public Map<String, Object> getPoolStats() {
        HikariDataSource hikariDS = (HikariDataSource) dataSource;
        HikariPoolMXBean poolBean = hikariDS.getHikariPoolMXBean();
        
        return Map.of(
            "activeConnections", poolBean.getActiveConnections(),
            "idleConnections", poolBean.getIdleConnections(),
            "totalConnections", poolBean.getTotalConnections(),
            "threadsAwaitingConnection", poolBean.getThreadsAwaitingConnection()
        );
    }
}
```

**Common Causes & Solutions:**

**A. Missing @Transactional:**
```java
// Problem: Connection held for entire method
public void processOrders() {
    List<Order> orders = orderRepository.findAll();  // Gets connection
    
    for (Order order : orders) {
        // Long processing
        externalService.process(order);  // Still holding connection!
    }
}  // Connection released here

// Solution: Use @Transactional
@Transactional
public void processOrders() {
    List<Order> orders = orderRepository.findAll();
    // Connection released after transaction
}
```

**B. Long-Running Transactions:**
```java
// Problem
@Transactional
public void processOrder(Long orderId) {
    Order order = orderRepository.findById(orderId).orElseThrow();
    
    // External API call in transaction - holds connection
    PaymentResponse payment = paymentService.processPayment(order);
    
    order.setPaymentId(payment.getId());
    orderRepository.save(order);
}

// Solution: Move external calls outside transaction
public void processOrder(Long orderId) {
    // External call first
    Order order = orderRepository.findById(orderId).orElseThrow();
    PaymentResponse payment = paymentService.processPayment(order);
    
    // Quick transaction
    updateOrder(orderId, payment.getId());
}

@Transactional
public void updateOrder(Long orderId, String paymentId) {
    Order order = orderRepository.findById(orderId).orElseThrow();
    order.setPaymentId(paymentId);
}
```

**C. Increase Pool Size:**
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
```

**D. Connection Leak:**
```java
// Enable leak detection
spring:
  datasource:
    hikari:
      leak-detection-threshold: 60000  # 60 seconds

# Check logs for:
# "Connection leak detection triggered"
```

---

## Scenario 4: Authentication Failures After Deployment

**Problem:** After deploying new version, users cannot login. JWT tokens invalid.

**Investigation:**

1. **Check JWT Secret:**
```yaml
# application.yml
jwt:
  secret: ${JWT_SECRET:default-secret-key}  # Environment variable
  expiration: 86400000
```

2. **Verify Token Generation:**
```java
@GetMapping("/debug/token")
public Map<String, Object> debugToken(@RequestHeader("Authorization") String token) {
    String jwt = token.substring(7);
    Claims claims = jwtUtil.extractAllClaims(jwt);
    
    return Map.of(
        "subject", claims.getSubject(),
        "issuedAt", claims.getIssuedAt(),
        "expiration", claims.getExpiration(),
        "isExpired", claims.getExpiration().before(new Date())
    );
}
```

**Root Causes & Solutions:**

**A. Secret Key Changed:**
```bash
# Problem: Secret changed between deployments
# Old tokens signed with old secret

# Solution: Use consistent secret from environment
export JWT_SECRET="consistent-secret-key-across-deployments"

# Or use key rotation
```

**B. Token Expiration Too Short:**
```yaml
# Problem
jwt:
  expiration: 300000  # 5 minutes - too short!

# Solution
jwt:
  expiration: 86400000  # 24 hours
  refresh-expiration: 604800000  # 7 days

# Implement refresh token
@PostMapping("/refresh")
public ResponseEntity<JwtResponse> refreshToken(
        @RequestBody RefreshTokenRequest request) {
    String username = jwtUtil.extractUsername(request.getRefreshToken());
    
    if (refreshTokenService.isValid(request.getRefreshToken())) {
        String newToken = jwtUtil.generateToken(username);
        return ResponseEntity.ok(new JwtResponse(newToken));
    }
    
    throw new InvalidTokenException("Invalid refresh token");
}
```

**C. CORS Issues:**
```java
// Problem: CORS blocking authentication requests
// Solution: Configure CORS properly
@Configuration
public class CorsConfig {
    
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                    .allowedOrigins("http://localhost:3000", "https://app.example.com")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                    .allowedHeaders("*")
                    .allowCredentials(true)
                    .maxAge(3600);
            }
        };
    }
}
```

**D. Password Encoding Mismatch:**
```java
// Problem: Different password encoders
// Registration used BCrypt, login uses plaintext

// Solution: Consistent encoder
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// Registration
public void register(RegisterRequest request) {
    User user = new User();
    user.setPassword(passwordEncoder.encode(request.getPassword()));
    userRepository.save(user);
}

// Login
public void authenticate(String username, String password) {
    UserDetails user = userDetailsService.loadUserByUsername(username);
    if (!passwordEncoder.matches(password, user.getPassword())) {
        throw new BadCredentialsException("Invalid credentials");
    }
}
```

---

## Scenario 5: Microservice Circuit Breaker Keeps Opening

**Problem:** Circuit breaker to product service constantly opens, causing failures.

**Investigation:**

```java
// Add detailed logging
@Service
public class OrderService {
    
    @CircuitBreaker(name = "productService", fallbackMethod = "getProductFallback")
    public Product getProduct(Long id) {
        log.info("Calling product service for product: {}", id);
        long startTime = System.currentTimeMillis();
        
        try {
            Product product = restTemplate.getForObject(
                "http://product-service/api/products/" + id, Product.class);
            log.info("Product service responded in {}ms", 
                System.currentTimeMillis() - startTime);
            return product;
        } catch (Exception e) {
            log.error("Product service call failed", e);
            throw e;
        }
    }
    
    public Product getProductFallback(Long id, Exception e) {
        log.error("Circuit breaker fallback triggered for product: {}", id, e);
        return new Product(id, "Product Unavailable", BigDecimal.ZERO);
    }
}
```

**Check Circuit Breaker Metrics:**
```java
@RestController
public class CircuitBreakerController {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @GetMapping("/circuit-breaker/state")
    public Map<String, Object> getCircuitBreakerState() {
        CircuitBreaker cb = circuitBreakerRegistry.circuitBreaker("productService");
        CircuitBreaker.Metrics metrics = cb.getMetrics();
        
        return Map.of(
            "state", cb.getState().toString(),
            "failureRate", metrics.getFailureRate(),
            "slowCallRate", metrics.getSlowCallRate(),
            "numberOfBufferedCalls", metrics.getNumberOfBufferedCalls(),
            "numberOfFailedCalls", metrics.getNumberOfFailedCalls(),
            "numberOfSlowCalls", metrics.getNumberOfSlowCalls()
        );
    }
}
```

**Solutions:**

**A. Adjust Circuit Breaker Configuration:**
```yaml
resilience4j:
  circuitbreaker:
    instances:
      productService:
        sliding-window-size: 10  # Increase sample size
        failure-rate-threshold: 50  # Allow 50% failures
        slow-call-rate-threshold: 80  # Increase threshold
        slow-call-duration-threshold: 5s  # Increase timeout
        wait-duration-in-open-state: 60s  # Wait longer before retry
        permitted-number-of-calls-in-half-open-state: 5
        automatic-transition-from-open-to-half-open-enabled: true
```

**B. Add Timeouts:**
```java
@Bean
public RestTemplate restTemplate() {
    RestTemplate restTemplate = new RestTemplate();
    
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(3000);  // 3 seconds
    factory.setReadTimeout(5000);     // 5 seconds
    
    restTemplate.setRequestFactory(factory);
    return restTemplate;
}
```

**C. Implement Retry with Backoff:**
```yaml
resilience4j:
  retry:
    instances:
      productService:
        max-attempts: 3
        wait-duration: 1s
        enable-exponential-backoff: true
        exponential-backoff-multiplier: 2
        retry-exceptions:
          - org.springframework.web.client.ResourceAccessException
```

---

## Scenario 6: Kafka Consumer Lag Increasing

**Problem:** Kafka consumer lag keeps increasing, messages not being processed.

**Investigation:**

```bash
# Check consumer lag
kafka-consumer-groups --bootstrap-server localhost:9092 \
  --group order-consumer-group --describe

# Output shows LAG column increasing
```

**Solutions:**

**A. Increase Partitions:**
```bash
# Current: 3 partitions, 1 consumer = slow
kafka-topics --bootstrap-server localhost:9092 \
  --alter --topic order-events --partitions 10
```

**B. Add More Consumer Instances:**
```yaml
# Scale up consumer pods
kubectl scale deployment order-consumer --replicas=5
```

**C. Optimize Consumer Processing:**
```java
// Problem: Slow processing
@Service
public class OrderEventConsumer {
    
    @KafkaListener(topics = "order-events", groupId = "order-group")
    public void consume(OrderEvent event) {
        // Slow database operation for each message
        Order order = orderRepository.findById(event.getOrderId()).orElseThrow();
        order.setStatus(event.getStatus());
        orderRepository.save(order);  // Individual save
    }
}

// Solution: Batch processing
@Service
public class OrderEventConsumer {
    
    private List<OrderEvent> batch = new ArrayList<>();
    private static final int BATCH_SIZE = 100;
    
    @KafkaListener(topics = "order-events", groupId = "order-group")
    public void consume(OrderEvent event) {
        batch.add(event);
        
        if (batch.size() >= BATCH_SIZE) {
            processBatch();
        }
    }
    
    @Scheduled(fixedDelay = 5000)
    public void processRemainingBatch() {
        if (!batch.isEmpty()) {
            processBatch();
        }
    }
    
    @Transactional
    private void processBatch() {
        List<Long> orderIds = batch.stream()
            .map(OrderEvent::getOrderId)
            .collect(Collectors.toList());
        
        List<Order> orders = orderRepository.findAllById(orderIds);
        
        Map<Long, OrderEvent> eventMap = batch.stream()
            .collect(Collectors.toMap(OrderEvent::getOrderId, e -> e));
        
        orders.forEach(order -> {
            OrderEvent event = eventMap.get(order.getId());
            order.setStatus(event.getStatus());
        });
        
        orderRepository.saveAll(orders);  // Batch save
        batch.clear();
    }
}
```

**D. Increase Fetch Size:**
```yaml
spring:
  kafka:
    consumer:
      max-poll-records: 500
      fetch-min-size: 1048576  # 1MB
```

---

## Scenario 7: Deadlock in Database

**Problem:** Application logs show: `Deadlock found when trying to get lock`.

**Investigation:**

```sql
-- MySQL: Check for deadlocks
SHOW ENGINE INNODB STATUS;

-- PostgreSQL
SELECT * FROM pg_stat_activity WHERE state = 'active';
```

**Example Deadlock Scenario:**
```java
// Thread 1
@Transactional
public void transferFunds(Long fromAccount, Long toAccount, BigDecimal amount) {
    Account from = accountRepository.findById(fromAccount).orElseThrow();  // Locks account 1
    Thread.sleep(100);  // Simulating delay
    Account to = accountRepository.findById(toAccount).orElseThrow();      // Tries to lock account 2
    
    from.setBalance(from.getBalance().subtract(amount));
    to.setBalance(to.getBalance().add(amount));
}

// Thread 2 (reverse order)
@Transactional
public void transferFunds(Long fromAccount, Long toAccount, BigDecimal amount) {
    Account to = accountRepository.findById(toAccount).orElseThrow();      // Locks account 2
    Thread.sleep(100);
    Account from = accountRepository.findById(fromAccount).orElseThrow();  // Tries to lock account 1
    // DEADLOCK!
}
```

**Solutions:**

**A. Consistent Lock Order:**
```java
@Transactional
public void transferFunds(Long fromAccountId, Long toAccountId, BigDecimal amount) {
    // Always lock accounts in ID order
    Long firstId = Math.min(fromAccountId, toAccountId);
    Long secondId = Math.max(fromAccountId, toAccountId);
    
    Account first = accountRepository.findById(firstId).orElseThrow();
    Account second = accountRepository.findById(secondId).orElseThrow();
    
    Account from = fromAccountId.equals(firstId) ? first : second;
    Account to = fromAccountId.equals(firstId) ? second : first;
    
    from.setBalance(from.getBalance().subtract(amount));
    to.setBalance(to.getBalance().add(amount));
}
```

**B. Use Pessimistic Locking:**
```java
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT a FROM Account a WHERE a.id = :id")
    Optional<Account> findByIdWithLock(@Param("id") Long id);
}
```

**C. Reduce Transaction Scope:**
```java
// Problem: Large transaction
@Transactional
public void processOrder(OrderDTO dto) {
    Order order = createOrder(dto);           // DB write
    sendEmailNotification(order);             // External call
    updateInventory(order);                   // DB write
    processPayment(order);                    // External call
    generateInvoice(order);                   // DB write
}

// Solution: Multiple smaller transactions
public void processOrder(OrderDTO dto) {
    Order order = createOrderTransaction(dto);
    sendEmailNotification(order);  // Outside transaction
    updateInventoryTransaction(order);
    processPayment(order);  // Outside transaction
    generateInvoiceTransaction(order);
}
```

---

## Scenario 8: High CPU Usage

**Problem:** Server CPU at 100%, application unresponsive.

**Investigation:**

```bash
# Get thread dump
jstack <pid> > threaddump.txt

# Or using JVM flag
kill -3 <pid>  # Prints to stdout

# Check for patterns:
# - Many threads in RUNNABLE state
# - Threads stuck in specific method
# - Infinite loops
```

**Common Causes:**

**A. Infinite Loop:**
```java
// Problem
@Scheduled(fixedDelay = 1000)
public void processOrders() {
    while (true) {  // Infinite loop!
        Order order = orderQueue.poll();
        if (order != null) {
            process(order);
        }
    }
}

// Solution
@Scheduled(fixedDelay = 1000)
public void processOrders() {
    Order order = orderQueue.poll();
    while (order != null) {
        process(order);
        order = orderQueue.poll();
    }
}
```

**B. Too Many Threads:**
```yaml
# Problem: Thread pool too large
spring:
  task:
    execution:
      pool:
        core-size: 100  # Too many!
        max-size: 200

# Solution: Right-size thread pool
spring:
  task:
    execution:
      pool:
        core-size: 10
        max-size: 20
        queue-capacity: 100
```

**C. Inefficient Algorithm:**
```java
// Problem: O(n²) complexity
public List<Product> findDuplicates(List<Product> products) {
    List<Product> duplicates = new ArrayList<>();
    for (int i = 0; i < products.size(); i++) {
        for (int j = i + 1; j < products.size(); j++) {
            if (products.get(i).equals(products.get(j))) {
                duplicates.add(products.get(i));
            }
        }
    }
    return duplicates;
}

// Solution: Use Set
public List<Product> findDuplicates(List<Product> products) {
    Set<Product> seen = new HashSet<>();
    return products.stream()
        .filter(p -> !seen.add(p))
        .collect(Collectors.toList());
}
```

---

## Scenario 9: Intermittent 500 Errors

**Problem:** Random 500 errors, no pattern in logs.

**Investigation:**

```java
// Add comprehensive logging
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception ex, 
                                                         HttpServletRequest request) {
        String requestId = UUID.randomUUID().toString();
        
        log.error("Request ID: {} | URL: {} | Method: {} | Error: {}", 
            requestId, request.getRequestURI(), request.getMethod(), ex.getMessage(), ex);
        
        ErrorResponse error = new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Internal server error. Request ID: " + requestId,
            LocalDateTime.now()
        );
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

**Common Causes:**

**A. Null Pointer Exception:**
```java
// Problem: No null checks
@GetMapping("/user/{id}/orders")
public List<Order> getUserOrders(@PathVariable Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return user.getOrders();  // NPE if orders is null
}

// Solution
@GetMapping("/user/{id}/orders")
public List<Order> getUserOrders(@PathVariable Long id) {
    User user = userRepository.findById(id).orElseThrow();
    return user.getOrders() != null ? user.getOrders() : Collections.emptyList();
}
```

**B. External Service Timeout:**
```java
// Add circuit breaker and timeout
@CircuitBreaker(name = "externalService", fallbackMethod = "fallback")
@TimeLimiter(name = "externalService")
public CompletableFuture<Response> callExternalService() {
    return CompletableFuture.supplyAsync(() ->
        restTemplate.getForObject("http://external-api/data", Response.class)
    );
}
```

---

## Scenario 10: Data Inconsistency

**Problem:** Order shows as "Paid" but payment record doesn't exist.

**Solution: Implement Distributed Transaction (Saga)**

```java
// Choreography-based saga
@Service
public class OrderSagaService {
    
    @Transactional
    public Order createOrder(OrderDTO dto) {
        // Step 1: Create order
        Order order = new Order();
        order.setStatus(OrderStatus.PENDING);
        order = orderRepository.save(order);
        
        // Publish event
        OrderCreatedEvent event = new OrderCreatedEvent(order.getId(), dto.getTotal());
        eventPublisher.publish(event);
        
        return order;
    }
    
    // Listen for payment completion
    @KafkaListener(topics = "payment-completed")
    @Transactional
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        Order order = orderRepository.findById(event.getOrderId()).orElseThrow();
        order.setStatus(OrderStatus.PAID);
        order.setPaymentId(event.getPaymentId());
        orderRepository.save(order);
        
        // Next step: reserve inventory
        eventPublisher.publish(new ReserveInventoryEvent(event.getOrderId()));
    }
    
    // Compensating transaction
    @KafkaListener(topics = "payment-failed")
    @Transactional
    public void handlePaymentFailed(PaymentFailedEvent event) {
        Order order = orderRepository.findById(event.getOrderId()).orElseThrow();
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
    }
}
```

---

## Summary

Troubleshooting scenarios: **Slow performance** (enable metrics, profile queries, check N+1 problem, add indexes, tune connection pool, implement caching, use async processing), **High memory** (heap dump analysis with MAT, avoid loading large datasets, implement pagination/streaming, configure cache limits, fix resource leaks, use try-with-resources), **Connection pool exhaustion** (monitor HikariCP stats, fix missing @Transactional, reduce transaction scope, move external calls outside transactions, increase pool size), **Authentication failures** (consistent JWT secrets across deployments, implement refresh tokens, configure CORS properly, use same password encoder), **Circuit breaker opening** (adjust thresholds, add timeouts, implement retry with exponential backoff, check service health), **Kafka lag** (increase partitions, scale consumers horizontally, implement batch processing, optimize fetch configuration), **Database deadlocks** (maintain consistent lock order, use pessimistic locking, reduce transaction scope), **High CPU** (analyze thread dumps, fix infinite loops, right-size thread pools, optimize algorithms from O(n²) to O(n)), **Intermittent errors** (comprehensive logging with request IDs, null checks, circuit breakers for external services, timeouts), **Data inconsistency** (implement saga pattern with compensating transactions, event-driven architecture, eventual consistency).

---

**Next:** System Design Questions →
