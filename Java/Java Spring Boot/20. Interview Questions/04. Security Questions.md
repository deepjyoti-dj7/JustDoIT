# Spring Security Interview Questions

---

## 1. Security Fundamentals

### Q1: What is Spring Security?
**Answer:**
Framework for authentication and authorization in Spring applications.

**Features:**
- Authentication (who are you?)
- Authorization (what can you do?)
- Protection against common attacks (CSRF, Session Fixation, Clickjacking)
- Integration with various authentication mechanisms
- Method-level security

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**Basic configuration:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/public/**").permitAll()
                        .anyRequest().authenticated()
                )
                .formLogin(Customizer.withDefaults())
                .build();
    }
}
```

---

### Q2: What is authentication vs authorization?
**Answer:**

| Authentication | Authorization |
|----------------|---------------|
| Verifying identity | Verifying permissions |
| Who are you? | What can you do? |
| Login process | Access control |
| Username/password, JWT, OAuth2 | Roles, authorities |

**Example:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                // Authentication
                .httpBasic(Customizer.withDefaults())
                
                // Authorization
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                        .requestMatchers("/api/public/**").permitAll()
                        .anyRequest().authenticated()
                )
                .build();
    }
    
    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.builder()
                .username("user")
                .password(passwordEncoder().encode("password"))
                .roles("USER")
                .build();
        
        UserDetails admin = User.builder()
                .username("admin")
                .password(passwordEncoder().encode("admin"))
                .roles("ADMIN", "USER")
                .build();
        
        return new InMemoryUserDetailsManager(user, admin);
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### Q3: How does Spring Security work?
**Answer:**
Uses filter chain to intercept and process requests.

**Filter Chain:**
```
Request → Security Filters → Controller
          ↓
    1. SecurityContextPersistenceFilter
    2. LogoutFilter
    3. UsernamePasswordAuthenticationFilter
    4. BasicAuthenticationFilter
    5. JwtAuthenticationFilter (custom)
    6. ExceptionTranslationFilter
    7. FilterSecurityInterceptor (authorization)
```

**Custom filter:**
```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        
        String token = extractToken(request);
        
        if (token != null && jwtService.validateToken(token)) {
            Authentication authentication = jwtService.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationFilter jwtFilter;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .build();
    }
}
```

---

### Q4: What is UserDetailsService?
**Answer:**
Interface to load user-specific data.

**Implementation:**
```java
@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(getAuthorities(user))
                .accountExpired(!user.isAccountNonExpired())
                .accountLocked(!user.isAccountNonLocked())
                .credentialsExpired(!user.isCredentialsNonExpired())
                .disabled(!user.isEnabled())
                .build();
    }
    
    private Collection<? extends GrantedAuthority> getAuthorities(User user) {
        return user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
                .collect(Collectors.toList());
    }
}

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String username;
    
    private String password;
    
    @ManyToMany(fetch = FetchType.EAGER)
    private Set<Role> roles = new HashSet<>();
    
    private boolean accountNonExpired = true;
    private boolean accountNonLocked = true;
    private boolean credentialsNonExpired = true;
    private boolean enabled = true;
    
    // Getters and setters
}

@Entity
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;  // ADMIN, USER, etc.
    
    // Getters and setters
}
```

---

### Q5: What is PasswordEncoder?
**Answer:**
Interface for password hashing.

**Common implementations:**
```java
@Configuration
public class SecurityConfig {
    
    // BCrypt (Recommended)
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    // PBKDF2
    // return new Pbkdf2PasswordEncoder();
    
    // SCrypt
    // return new SCryptPasswordEncoder();
    
    // Delegating (multiple encoders)
    // return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}

@Service
public class UserService {
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private UserRepository userRepository;
    
    public User createUser(String username, String rawPassword) {
        User user = new User();
        user.setUsername(username);
        user.setPassword(passwordEncoder.encode(rawPassword));  // Hash password
        return userRepository.save(user);
    }
    
    public boolean checkPassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
}
```

---

## 2. Authentication

### Q6: How to implement JWT authentication?
**Answer:**

**JWT Service:**
```java
@Service
public class JwtService {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private long expiration;
    
    public String generateToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(SignatureAlgorithm.HS256, secret)
                .compact();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return !isTokenExpired(token);
        } catch (Exception e) {
            return false;
        }
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();
        return claimsResolver.apply(claims);
    }
    
    public Authentication getAuthentication(String token) {
        String username = extractUsername(token);
        UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        return new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
    }
}
```

**Authentication Controller:**
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtService jwtService;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @PostMapping("/login")
    public ResponseEntity<JwtResponse> login(@RequestBody LoginRequest request) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );
        
        SecurityContextHolder.getContext().setAuthentication(authentication);
        
        UserDetails userDetails = userDetailsService.loadUserByUsername(request.getUsername());
        String token = jwtService.generateToken(userDetails);
        
        return ResponseEntity.ok(new JwtResponse(token));
    }
}

@Data
public class LoginRequest {
    private String username;
    private String password;
}

@Data
@AllArgsConstructor
public class JwtResponse {
    private String token;
}
```

**Configuration:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, JwtAuthenticationFilter jwtFilter) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}
```

---

### Q7: What is method-level security?
**Answer:**

**Enable:**
```java
@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
}
```

**Usage:**
```java
@Service
public class UserService {
    
    // Requires ADMIN role
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    // Requires USER or ADMIN role
    @PreAuthorize("hasAnyRole('USER', 'ADMIN')")
    public User getUser(Long id) {
        return userRepository.findById(id).orElseThrow();
    }
    
    // Check if user owns resource
    @PreAuthorize("#userId == authentication.principal.id")
    public User updateUser(Long userId, UserDTO dto) {
        User user = userRepository.findById(userId).orElseThrow();
        // Update user
        return userRepository.save(user);
    }
    
    // Complex expression
    @PreAuthorize("hasRole('ADMIN') or (#userId == authentication.principal.id)")
    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }
    
    // Check after method execution
    @PostAuthorize("returnObject.username == authentication.principal.username")
    public User getUserDetails(Long id) {
        return userRepository.findById(id).orElseThrow();
    }
    
    // Filter collection before return
    @PostFilter("filterObject.public or filterObject.owner == authentication.principal.username")
    public List<Document> getDocuments() {
        return documentRepository.findAll();
    }
    
    // Filter collection before processing
    @PreFilter("filterObject.owner == authentication.principal.username")
    public void deleteDocuments(List<Document> documents) {
        documentRepository.deleteAll(documents);
    }
    
    // Check permissions with custom service
    @PreAuthorize("@permissionService.canAccessOrder(#orderId)")
    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId).orElseThrow();
    }
}

@Service
public class PermissionService {
    
    public boolean canAccessOrder(Long orderId) {
        // Custom permission logic
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth.getName();
        
        Order order = orderRepository.findById(orderId).orElse(null);
        return order != null && order.getCustomer().getUsername().equals(username);
    }
}
```

---

### Q8: How to get current authenticated user?
**Answer:**

**Method 1: SecurityContextHolder**
```java
@RestController
public class ProfileController {
    
    @GetMapping("/api/profile")
    public User getProfile() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication.getName();
        
        return userService.findByUsername(username);
    }
}
```

**Method 2: Authentication parameter**
```java
@RestController
public class ProfileController {
    
    @GetMapping("/api/profile")
    public User getProfile(Authentication authentication) {
        String username = authentication.getName();
        return userService.findByUsername(username);
    }
}
```

**Method 3: @AuthenticationPrincipal**
```java
@RestController
public class ProfileController {
    
    @GetMapping("/api/profile")
    public User getProfile(@AuthenticationPrincipal UserDetails userDetails) {
        String username = userDetails.getUsername();
        return userService.findByUsername(username);
    }
    
    // With custom UserDetails
    @GetMapping("/api/me")
    public CustomUser getMe(@AuthenticationPrincipal CustomUser user) {
        return user;
    }
}

// Custom UserDetails
public class CustomUser implements UserDetails {
    private final User user;
    
    public CustomUser(User user) {
        this.user = user;
    }
    
    public Long getId() {
        return user.getId();
    }
    
    @Override
    public String getUsername() {
        return user.getUsername();
    }
    
    @Override
    public String getPassword() {
        return user.getPassword();
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getRoles().stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
                .collect(Collectors.toList());
    }
    
    // Other methods...
}
```

---

### Q9: How to implement OAuth2 login?
**Answer:**

**Dependency:**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
```

**Configuration:**
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope:
              - email
              - profile
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            scope:
              - user:email
              - read:user
```

**Security Config:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/", "/login**", "/error**").permitAll()
                        .anyRequest().authenticated()
                )
                .oauth2Login(oauth2 -> oauth2
                        .loginPage("/login")
                        .defaultSuccessUrl("/dashboard")
                        .failureUrl("/login?error")
                        .userInfoEndpoint(userInfo -> userInfo
                                .userService(customOAuth2UserService())
                        )
                )
                .build();
    }
    
    @Bean
    public OAuth2UserService<OAuth2UserRequest, OAuth2User> customOAuth2UserService() {
        return new CustomOAuth2UserService();
    }
}

@Service
public class CustomOAuth2UserService extends DefaultOAuth2UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User oauth2User = super.loadUser(userRequest);
        
        // Process OAuth2 user and save to database
        String email = oauth2User.getAttribute("email");
        String name = oauth2User.getAttribute("name");
        
        User user = userRepository.findByEmail(email)
                .orElseGet(() -> createUser(email, name));
        
        return new CustomOAuth2User(oauth2User, user);
    }
    
    private User createUser(String email, String name) {
        User user = new User();
        user.setEmail(email);
        user.setName(name);
        user.setProvider("google");
        return userRepository.save(user);
    }
}
```

---

### Q10: What is CSRF protection?
**Answer:**
Cross-Site Request Forgery protection prevents unauthorized commands from authenticated users.

**Enable (default):**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(Customizer.withDefaults())  // Enabled by default
                .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
                .build();
    }
}
```

**Disable (for stateless APIs):**
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http
            .csrf(csrf -> csrf.disable())  // Disable for JWT/token-based auth
            .sessionManagement(session -> session
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .build();
}
```

**Custom CSRF configuration:**
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    return http
            .csrf(csrf -> csrf
                    .ignoringRequestMatchers("/api/public/**")  // Exclude endpoints
                    .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            )
            .build();
}
```

---

## 3. Authorization

### Q11: How to implement role-based access control?
**Answer:**

**Entity:**
```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String username;
    private String password;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = "user_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
}

@Entity
public class Role {
    @Id
    private Long id;
    
    private String name;  // ROLE_USER, ROLE_ADMIN, ROLE_MODERATOR
    
    @ManyToMany
    private Set<Permission> permissions = new HashSet<>();
}

@Entity
public class Permission {
    @Id
    private Long id;
    
    private String name;  // READ_USERS, WRITE_USERS, DELETE_USERS
}
```

**Security Config:**
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers("/api/public/**").permitAll()
                        
                        // Role-based access
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .requestMatchers("/api/moderator/**").hasAnyRole("ADMIN", "MODERATOR")
                        .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
                        
                        // Authority-based access
                        .requestMatchers(HttpMethod.GET, "/api/users/**").hasAuthority("READ_USERS")
                        .requestMatchers(HttpMethod.POST, "/api/users/**").hasAuthority("WRITE_USERS")
                        .requestMatchers(HttpMethod.DELETE, "/api/users/**").hasAuthority("DELETE_USERS")
                        
                        .anyRequest().authenticated()
                )
                .build();
    }
}
```

**Service with method security:**
```java
@Service
public class UserService {
    
    @PreAuthorize("hasRole('ADMIN')")
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    @PreAuthorize("hasAuthority('WRITE_USERS')")
    public User createUser(UserDTO dto) {
        return userRepository.save(dto.toEntity());
    }
    
    @PreAuthorize("hasAuthority('DELETE_USERS') and hasRole('ADMIN')")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

---

### Q12: How to implement custom permission evaluator?
**Answer:**

**Permission Evaluator:**
```java
@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if (authentication == null || targetDomainObject == null || !(permission instanceof String)) {
            return false;
        }
        
        String targetType = targetDomainObject.getClass().getSimpleName().toUpperCase();
        return hasPrivilege(authentication, targetType, permission.toString());
    }
    
    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        if (authentication == null || targetType == null || !(permission instanceof String)) {
            return false;
        }
        
        return hasPrivilege(authentication, targetType.toUpperCase(), permission.toString());
    }
    
    private boolean hasPrivilege(Authentication auth, String targetType, String permission) {
        if (targetType.equals("ORDER") && permission.equals("READ")) {
            return canReadOrder(auth, (Order) targetType);
        }
        
        return false;
    }
    
    private boolean canReadOrder(Authentication auth, Order order) {
        String username = auth.getName();
        return order.getCustomer().getUsername().equals(username) ||
               auth.getAuthorities().stream()
                       .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }
}

@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
    
    @Bean
    public MethodSecurityExpressionHandler methodSecurityExpressionHandler(CustomPermissionEvaluator permissionEvaluator) {
        DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
        expressionHandler.setPermissionEvaluator(permissionEvaluator);
        return expressionHandler;
    }
}
```

**Usage:**
```java
@Service
public class OrderService {
    
    @PreAuthorize("hasPermission(#order, 'READ')")
    public Order getOrder(Order order) {
        return order;
    }
    
    @PreAuthorize("hasPermission(#orderId, 'ORDER', 'WRITE')")
    public Order updateOrder(Long orderId, OrderDTO dto) {
        Order order = orderRepository.findById(orderId).orElseThrow();
        // Update order
        return orderRepository.save(order);
    }
}
```

---

## 4. Advanced Topics

### Q13: How to handle security exceptions?
**Answer:**

**Exception Handler:**
```java
@RestControllerAdvice
public class SecurityExceptionHandler {
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.FORBIDDEN.value(),
                "Access denied",
                ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }
    
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthentication(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.UNAUTHORIZED.value(),
                "Authentication failed",
                ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }
    
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleBadCredentials(BadCredentialsException ex) {
        ErrorResponse error = new ErrorResponse(
                HttpStatus.UNAUTHORIZED.value(),
                "Invalid credentials",
                "Username or password is incorrect"
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }
}
```

**Custom entry point:**
```java
@Component
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
    
    @Override
    public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        
        response.setContentType("application/json");
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        
        ErrorResponse error = new ErrorResponse(
                HttpServletResponse.SC_UNAUTHORIZED,
                "Unauthorized",
                authException.getMessage()
        );
        
        ObjectMapper mapper = new ObjectMapper();
        response.getWriter().write(mapper.writeValueAsString(error));
    }
}

@Bean
public SecurityFilterChain filterChain(HttpSecurity http, CustomAuthenticationEntryPoint entryPoint) throws Exception {
    return http
            .exceptionHandling(exception -> exception
                    .authenticationEntryPoint(entryPoint)
            )
            .build();
}
```

---

### Q14: How to implement remember-me functionality?
**Answer:**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .rememberMe(remember -> remember
                        .key("uniqueAndSecret")
                        .tokenValiditySeconds(86400)  // 24 hours
                        .rememberMeParameter("remember-me")
                        .rememberMeCookieName("my-remember-me")
                )
                .build();
    }
}

// Persistent token approach
@Bean
public SecurityFilterChain filterChain(HttpSecurity http, DataSource dataSource) throws Exception {
    return http
            .rememberMe(remember -> remember
                    .tokenRepository(persistentTokenRepository(dataSource))
                    .tokenValiditySeconds(86400)
            )
            .build();
}

@Bean
public PersistentTokenRepository persistentTokenRepository(DataSource dataSource) {
    JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
    tokenRepository.setDataSource(dataSource);
    return tokenRepository;
}
```

**SQL schema:**
```sql
CREATE TABLE persistent_logins (
    username VARCHAR(64) NOT NULL,
    series VARCHAR(64) PRIMARY KEY,
    token VARCHAR(64) NOT NULL,
    last_used TIMESTAMP NOT NULL
);
```

---

### Q15: How to implement account lockout after failed attempts?
**Answer:**

```java
@Component
public class LoginAttemptService {
    
    private final int MAX_ATTEMPT = 5;
    private LoadingCache<String, Integer> attemptsCache;
    
    public LoginAttemptService() {
        attemptsCache = CacheBuilder.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build(new CacheLoader<String, Integer>() {
                    @Override
                    public Integer load(String key) {
                        return 0;
                    }
                });
    }
    
    public void loginSucceeded(String key) {
        attemptsCache.invalidate(key);
    }
    
    public void loginFailed(String key) {
        int attempts = attemptsCache.getUnchecked(key);
        attempts++;
        attemptsCache.put(key, attempts);
    }
    
    public boolean isBlocked(String key) {
        return attemptsCache.getUnchecked(key) >= MAX_ATTEMPT;
    }
}

@Service
public class CustomUserDetailsService implements UserDetailsService {
    
    @Autowired
    private LoginAttemptService loginAttemptService;
    
    @Autowired
    private HttpServletRequest request;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        String ip = getClientIP();
        
        if (loginAttemptService.isBlocked(ip)) {
            throw new RuntimeException("Account locked due to multiple failed login attempts");
        }
        
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getAuthorities()
        );
    }
    
    private String getClientIP() {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null) {
            return request.getRemoteAddr();
        }
        return xfHeader.split(",")[0];
    }
}

@Component
public class AuthenticationEventListener {
    
    @Autowired
    private LoginAttemptService loginAttemptService;
    
    @EventListener
    public void onSuccess(AuthenticationSuccessEvent event) {
        String username = event.getAuthentication().getName();
        loginAttemptService.loginSucceeded(username);
    }
    
    @EventListener
    public void onFailure(AuthenticationFailureBadCredentialsEvent event) {
        String username = (String) event.getAuthentication().getPrincipal();
        loginAttemptService.loginFailed(username);
    }
}
```

---

### Q16: How to implement API key authentication?
**Answer:**

```java
@Component
public class ApiKeyAuthenticationFilter extends OncePerRequestFilter {
    
    private static final String API_KEY_HEADER = "X-API-KEY";
    
    @Autowired
    private ApiKeyService apiKeyService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        
        String apiKey = request.getHeader(API_KEY_HEADER);
        
        if (apiKey != null && apiKeyService.isValidApiKey(apiKey)) {
            User user = apiKeyService.getUserByApiKey(apiKey);
            
            List<GrantedAuthority> authorities = user.getRoles().stream()
                    .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getName()))
                    .collect(Collectors.toList());
            
            Authentication authentication = new UsernamePasswordAuthenticationToken(
                    user.getUsername(), null, authorities);
            
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        
        filterChain.doFilter(request, response);
    }
}

@Service
public class ApiKeyService {
    
    @Autowired
    private UserRepository userRepository;
    
    public boolean isValidApiKey(String apiKey) {
        return userRepository.findByApiKey(apiKey).isPresent();
    }
    
    public User getUserByApiKey(String apiKey) {
        return userRepository.findByApiKey(apiKey).orElse(null);
    }
    
    public String generateApiKey(User user) {
        String apiKey = UUID.randomUUID().toString();
        user.setApiKey(apiKey);
        userRepository.save(user);
        return apiKey;
    }
}
```

---

### Q17: How to implement two-factor authentication?
**Answer:**

**Dependency:**
```xml
<dependency>
    <groupId>com.warrenstrange</groupId>
    <artifactId>googleauth</artifactId>
    <version>1.5.0</version>
</dependency>
```

**Service:**
```java
@Service
public class TwoFactorAuthService {
    
    private final GoogleAuthenticator gAuth = new GoogleAuthenticator();
    
    public String generateSecretKey() {
        GoogleAuthenticatorKey key = gAuth.createCredentials();
        return key.getKey();
    }
    
    public String getQRCodeUrl(String username, String secret) {
        return String.format(
                "otpauth://totp/%s:%s?secret=%s&issuer=%s",
                "MyApp", username, secret, "MyApp"
        );
    }
    
    public boolean verifyCode(String secret, int code) {
        return gAuth.authorize(secret, code);
    }
}

@RestController
@RequestMapping("/api/2fa")
public class TwoFactorAuthController {
    
    @Autowired
    private TwoFactorAuthService twoFactorAuthService;
    
    @Autowired
    private UserRepository userRepository;
    
    @PostMapping("/enable")
    public ResponseEntity<?> enable(@AuthenticationPrincipal UserDetails userDetails) {
        User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();
        
        String secret = twoFactorAuthService.generateSecretKey();
        user.setTwoFactorSecret(secret);
        user.setTwoFactorEnabled(false);  // Will be enabled after verification
        userRepository.save(user);
        
        String qrUrl = twoFactorAuthService.getQRCodeUrl(user.getUsername(), secret);
        
        return ResponseEntity.ok(Map.of(
                "secret", secret,
                "qrCodeUrl", qrUrl
        ));
    }
    
    @PostMapping("/verify")
    public ResponseEntity<?> verify(
            @AuthenticationPrincipal UserDetails userDetails,
            @RequestParam int code) {
        
        User user = userRepository.findByUsername(userDetails.getUsername()).orElseThrow();
        
        boolean valid = twoFactorAuthService.verifyCode(user.getTwoFactorSecret(), code);
        
        if (valid) {
            user.setTwoFactorEnabled(true);
            userRepository.save(user);
            return ResponseEntity.ok("2FA enabled successfully");
        }
        
        return ResponseEntity.badRequest().body("Invalid code");
    }
}
```

---

### Q18: How to implement rate limiting?
**Answer:**

```java
@Component
public class RateLimitFilter extends OncePerRequestFilter {
    
    private final Map<String, Bucket> cache = new ConcurrentHashMap<>();
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        
        String key = getClientKey(request);
        Bucket bucket = resolveBucket(key);
        
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
        
        if (probe.isConsumed()) {
            response.addHeader("X-Rate-Limit-Remaining", 
                    String.valueOf(probe.getRemainingTokens()));
            filterChain.doFilter(request, response);
        } else {
            response.setStatus(429);
            response.getWriter().write("Too many requests");
        }
    }
    
    private Bucket resolveBucket(String key) {
        return cache.computeIfAbsent(key, k -> createBucket());
    }
    
    private Bucket createBucket() {
        Bandwidth limit = Bandwidth.classic(100, Refill.intervally(100, Duration.ofMinutes(1)));
        return Bucket.builder().addLimit(limit).build();
    }
    
    private String getClientKey(HttpServletRequest request) {
        return request.getRemoteAddr();
    }
}
```

---

### Q19: How to secure REST API with Spring Security?
**Answer:**

**Complete configuration:**
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, JwtAuthenticationFilter jwtFilter) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .cors(Customizer.withDefaults())
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/api/auth/**", "/api/public/**").permitAll()
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(new CustomAuthenticationEntryPoint())
                        .accessDeniedHandler(new CustomAccessDeniedHandler())
                )
                .build();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### Q20: Best practices for Spring Security?
**Answer:**

1. **Use HTTPS in production**
2. **Hash passwords with BCrypt**
3. **Implement rate limiting**
4. **Use stateless authentication (JWT)**
5. **Validate all inputs**
6. **Implement CSRF protection for stateful apps**
7. **Use method-level security**
8. **Implement account lockout**
9. **Log security events**
10. **Regular security audits**
11. **Keep dependencies updated**
12. **Use secure headers**
13. **Implement two-factor authentication**
14. **Validate JWT tokens properly**
15. **Store secrets in environment variables**

---

## Summary

Spring Security provides authentication (verifying identity) and authorization (verifying permissions). Core components: UserDetailsService (load user data), PasswordEncoder (hash passwords), SecurityFilterChain (filter configuration). JWT authentication: generate token on login, validate on each request, stateless. Method security with @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter. OAuth2 login for social authentication. CSRF protection for stateful apps, disable for stateless APIs. Role-based access control with @ManyToMany relationships. Get authenticated user with SecurityContextHolder or @AuthenticationPrincipal. Custom filters for API keys, rate limiting. Handle exceptions with @RestControllerAdvice. Remember-me for persistent authentication. Account lockout after failed attempts. Two-factor authentication with TOTP. Best practices: HTTPS, BCrypt, rate limiting, input validation, security logging.

---

**Next:** Microservices Questions →
