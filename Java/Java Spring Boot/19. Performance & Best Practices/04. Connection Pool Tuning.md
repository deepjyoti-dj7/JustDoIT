# Connection Pool Tuning - Complete Guide

---

## 1. Introduction to Connection Pooling

Connection pooling reuses database connections instead of creating new ones for each request, dramatically improving performance.

### Why Connection Pooling?

- **Performance** - Reuse connections instead of creating new ones
- **Resource Management** - Limit database connections
- **Scalability** - Handle more concurrent requests
- **Stability** - Prevent connection exhaustion

### Connection Creation Cost

Creating a new database connection involves:
1. TCP handshake
2. Authentication
3. Session initialization
4. Transaction setup

**Time:** 50-100ms per connection  
**Solution:** Connection pooling reuses connections (~1ms)

---

## 2. HikariCP Overview

HikariCP is the default connection pool in Spring Boot and the fastest available.

### 2.1. Why HikariCP?

- **Fast** - Fastest connection pool implementation
- **Reliable** - Production-proven
- **Lightweight** - Small bytecode footprint
- **Zero-overhead** - Optimized instrumentation

### 2.2. Basic Configuration

```xml
<!-- Already included in spring-boot-starter-data-jpa -->
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
</dependency>
```

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
```

---

## 3. Core Configuration Parameters

### 3.1. Pool Size Settings

#### maximum-pool-size

**Description:** Maximum number of connections in the pool

**Default:** 10

**Formula:** `connections = ((core_count * 2) + effective_spindle_count)`

For cloud/SSD: `connections = (core_count * 2)`

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20  # For 8 cores: 8 * 2 = 16-20
```

**Recommendations:**
- **Small app:** 5-10
- **Medium app:** 10-20
- **Large app:** 20-50
- **Very large:** Start with 20, monitor, adjust

⚠️ **More is NOT better!** Too many connections:
- Waste resources
- Increase context switching
- Overwhelm database

#### minimum-idle

**Description:** Minimum number of idle connections maintained

**Default:** Same as maximum-pool-size

```yaml
spring:
  datasource:
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
```

**Recommendation:** Let HikariCP manage (set equal to maximum-pool-size)

```yaml
# Recommended: Don't set minimum-idle, let it equal maximum-pool-size
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      # minimum-idle not specified
```

---

### 3.2. Timeout Settings

#### connection-timeout

**Description:** Maximum time to wait for connection from pool

**Default:** 30000ms (30 seconds)

```yaml
spring:
  datasource:
    hikari:
      connection-timeout: 30000  # 30 seconds
```

**Recommendations:**
- **API servers:** 10000-30000ms (10-30 seconds)
- **Background jobs:** 60000ms (1 minute)
- **Critical paths:** 5000ms (5 seconds) to fail fast

#### idle-timeout

**Description:** Maximum time a connection can sit idle before being retired

**Default:** 600000ms (10 minutes)

```yaml
spring:
  datasource:
    hikari:
      idle-timeout: 600000  # 10 minutes
```

**Note:** Only applies if minimum-idle < maximum-pool-size

#### max-lifetime

**Description:** Maximum lifetime of a connection in the pool

**Default:** 1800000ms (30 minutes)

```yaml
spring:
  datasource:
    hikari:
      max-lifetime: 1800000  # 30 minutes
```

**Important:** Should be several seconds shorter than database connection timeout

**Database timeouts:**
- MySQL: `wait_timeout` (default: 8 hours)
- PostgreSQL: `idle_in_transaction_session_timeout`

```yaml
# If database timeout is 5 minutes
spring:
  datasource:
    hikari:
      max-lifetime: 240000  # 4 minutes (less than 5)
```

---

### 3.3. Connection Testing

#### connection-test-query

**Description:** Query to test connection validity

**Default:** None (uses JDBC4 isValid())

```yaml
spring:
  datasource:
    hikari:
      connection-test-query: SELECT 1
```

**Recommendation:** Don't set this. Let HikariCP use JDBC4 `Connection.isValid()`

#### validation-timeout

**Description:** Maximum time to wait for connection validation

**Default:** 5000ms (5 seconds)

```yaml
spring:
  datasource:
    hikari:
      validation-timeout: 5000
```

---

### 3.4. Leak Detection

#### leak-detection-threshold

**Description:** Threshold for connection leak detection (milliseconds)

**Default:** 0 (disabled)

```yaml
spring:
  datasource:
    hikari:
      leak-detection-threshold: 60000  # 60 seconds
```

**When enabled:** Logs warning if connection not returned within threshold

**Recommendations:**
- **Development:** 30000ms (30 seconds)
- **Production:** 60000ms (60 seconds) or disabled
- **Debugging leaks:** 10000ms (10 seconds)

**Example warning:**
```
Connection leak detection triggered for connection 
    on thread http-nio-8080-exec-5, stack trace follows
```

---

## 4. Complete Configuration Examples

### 4.1. Development Configuration

```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb_dev
    username: dev_user
    password: dev_password
    hikari:
      maximum-pool-size: 5
      connection-timeout: 20000
      leak-detection-threshold: 30000
      pool-name: DevHikariPool
      
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
```

### 4.2. Production Configuration

```yaml
# application-prod.yml
spring:
  datasource:
    url: ${DATABASE_URL}
    username: ${DATABASE_USERNAME}
    password: ${DATABASE_PASSWORD}
    hikari:
      maximum-pool-size: 20
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
      pool-name: ProdHikariPool
      
      # Advanced settings
      auto-commit: false
      read-only: false
      
      # Connection initialization
      connection-init-sql: SET TIME ZONE 'UTC'
      
      # JMX monitoring
      register-mbeans: true
```

### 4.3. High-Traffic Configuration

```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 20000
      idle-timeout: 300000      # 5 minutes
      max-lifetime: 1200000     # 20 minutes
      leak-detection-threshold: 120000
      
      # Performance tuning
      auto-commit: false
      
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 50
        order_inserts: true
        order_updates: true
```

---

## 5. Monitoring Connection Pool

### 5.1. HikariCP Metrics

```java
@Component
public class HikariMetricsLogger {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 60000)  // Every minute
    public void logPoolMetrics() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikari = (HikariDataSource) dataSource;
            HikariPoolMXBean poolBean = hikari.getHikariPoolMXBean();
            
            log.info("HikariCP Pool Stats:");
            log.info("  Active Connections: {}", poolBean.getActiveConnections());
            log.info("  Idle Connections: {}", poolBean.getIdleConnections());
            log.info("  Total Connections: {}", poolBean.getTotalConnections());
            log.info("  Threads Awaiting Connection: {}", poolBean.getThreadsAwaitingConnection());
        }
    }
}
```

### 5.2. Micrometer Metrics

```java
@Configuration
public class HikariMetricsConfig {
    
    @Bean
    public MeterBinder hikariMetrics(DataSource dataSource) {
        if (dataSource instanceof HikariDataSource) {
            return new HikariDataSourceMetrics((HikariDataSource) dataSource, "hikaricp", null);
        }
        return registry -> {};
    }
}
```

**Available metrics:**
- `hikaricp.connections.active` - Active connections
- `hikaricp.connections.idle` - Idle connections
- `hikaricp.connections.max` - Maximum pool size
- `hikaricp.connections.min` - Minimum idle
- `hikaricp.connections.pending` - Threads waiting
- `hikaricp.connections.timeout` - Connection timeouts
- `hikaricp.connections.usage` - Connection usage time
- `hikaricp.connections.acquire` - Connection acquisition time
- `hikaricp.connections.creation` - Connection creation time

### 5.3. Actuator Endpoint

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics
  
  metrics:
    enable:
      hikaricp: true
```

**Access metrics:**
```bash
# Get all HikariCP metrics
curl http://localhost:8080/actuator/metrics/hikaricp.connections.active

# Response
{
  "name": "hikaricp.connections.active",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 5.0
    }
  ]
}
```

---

## 6. Connection Pool Sizing

### 6.1. Formula-Based Sizing

**PostgreSQL Formula:**
```
connections = ((core_count * 2) + effective_spindle_count)
```

**Example:**
- 4 CPU cores
- SSD storage (effective_spindle_count ≈ 0)
- Result: (4 * 2) + 0 = **8 connections**

### 6.2. Load Testing Approach

```java
@SpringBootTest
public class ConnectionPoolLoadTest {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Test
    public void testConnectionPoolUnderLoad() throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(50);
        CountDownLatch latch = new CountDownLatch(1000);
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < 1000; i++) {
            executor.submit(() -> {
                try {
                    productRepository.findById(1L);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        long duration = System.currentTimeMillis() - startTime;
        
        log.info("1000 requests completed in {}ms", duration);
        executor.shutdown();
    }
}
```

### 6.3. Monitoring-Based Tuning

**Indicators pool is too small:**
- High `hikaricp.connections.pending`
- Frequent connection timeouts
- Threads waiting for connections

**Indicators pool is too large:**
- Many idle connections
- Database connection limit reached
- High memory usage

---

## 7. Common Issues and Solutions

### 7.1. Connection Timeout

**Problem:**
```
java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available,
request timed out after 30000ms.
```

**Causes:**
1. Pool size too small
2. Connections not being returned (leaks)
3. Slow queries blocking connections

**Solutions:**
```yaml
# Increase pool size
spring:
  datasource:
    hikari:
      maximum-pool-size: 20  # Increase from 10

# Reduce timeout to fail faster
spring:
  datasource:
    hikari:
      connection-timeout: 10000  # 10 seconds
      
# Enable leak detection
spring:
  datasource:
    hikari:
      leak-detection-threshold: 30000
```

### 7.2. Connection Leaks

**Problem:**
```
Connection leak detection triggered for connection on thread http-nio-8080-exec-5
```

**Causes:**
- Not closing connections
- Exceptions interrupting finally blocks
- Long-running transactions

**Solutions:**
```java
// ❌ Bad - Manual connection management
Connection conn = dataSource.getConnection();
// If exception occurs, connection never closed!
conn.close();

// ✅ Good - Use try-with-resources
try (Connection conn = dataSource.getConnection()) {
    // Use connection
} // Automatically closed

// ✅ Best - Use Spring's JdbcTemplate or JPA
@Autowired
private JdbcTemplate jdbcTemplate;

public List<Product> getProducts() {
    return jdbcTemplate.query("SELECT * FROM product", 
                              new ProductRowMapper());
}
```

### 7.3. Database Connection Limit

**Problem:**
```
FATAL: sorry, too many clients already
```

**PostgreSQL:**
```sql
-- Check max connections
SHOW max_connections;  -- Default: 100

-- Check current connections
SELECT count(*) FROM pg_stat_activity;

-- Increase max connections
ALTER SYSTEM SET max_connections = 200;
-- Restart PostgreSQL
```

**Solution:**
```yaml
# Ensure pool size < database max connections
# With 3 application instances and max_connections=100
spring:
  datasource:
    hikari:
      maximum-pool-size: 30  # 3 instances * 30 = 90 < 100
```

---

## 8. Multi-Tenant Configuration

### 8.1. Separate Pools per Tenant

```java
@Configuration
public class MultiTenantDataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>();
        
        targetDataSources.put("tenant1", createHikariDataSource(
            "jdbc:postgresql://localhost:5432/tenant1_db", 10));
        targetDataSources.put("tenant2", createHikariDataSource(
            "jdbc:postgresql://localhost:5432/tenant2_db", 10));
        
        AbstractRoutingDataSource dataSource = new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                return TenantContext.getCurrentTenant();
            }
        };
        
        dataSource.setTargetDataSources(targetDataSources);
        dataSource.setDefaultTargetDataSource(targetDataSources.get("tenant1"));
        
        return dataSource;
    }
    
    private HikariDataSource createHikariDataSource(String url, int poolSize) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setUsername("user");
        config.setPassword("password");
        config.setMaximumPoolSize(poolSize);
        config.setConnectionTimeout(30000);
        
        return new HikariDataSource(config);
    }
}
```

---

## 9. Interview Questions

**Q1: What is connection pooling?**
**A:** Reusing database connections instead of creating new ones.

**Q2: What is HikariCP?**
**A:** Fastest JDBC connection pool, default in Spring Boot.

**Q3: What is maximum-pool-size?**
**A:** Maximum number of connections in the pool.

**Q4: Formula for pool size?**
**A:** (core_count * 2) + effective_spindle_count

**Q5: What is minimum-idle?**
**A:** Minimum number of idle connections maintained.

**Q6: Should you set minimum-idle?**
**A:** No, let it equal maximum-pool-size (HikariCP recommendation).

**Q7: What is connection-timeout?**
**A:** Maximum time to wait for connection from pool.

**Q8: What is idle-timeout?**
**A:** Maximum time connection can sit idle before retirement.

**Q9: What is max-lifetime?**
**A:** Maximum lifetime of connection in pool.

**Q10: Why set max-lifetime?**
**A:** Prevent using stale connections, should be less than database timeout.

**Q11: What is leak-detection-threshold?**
**A:** Threshold for logging connection leak warnings.

**Q12: What is connection-test-query?**
**A:** Query to test connection validity (not recommended with JDBC4).

**Q13: What is HikariPoolMXBean?**
**A:** JMX bean for monitoring HikariCP metrics.

**Q14: Key HikariCP metrics?**
**A:** Active, idle, total connections, threads waiting.

**Q15: What causes "Connection is not available" error?**
**A:** Pool size too small, connection leaks, or slow queries.

**Q16: How to detect connection leaks?**
**A:** Enable leak-detection-threshold.

**Q17: What is auto-commit?**
**A:** Automatically commit after each statement (default: true).

**Q18: Should you disable auto-commit?**
**A:** Yes, in production for better transaction control.

**Q19: What is effective_spindle_count?**
**A:** Number of spinning hard drives (0 for SSD/cloud).

**Q20: More connections = better performance?**
**A:** No! Too many connections waste resources and overwhelm database.

---

## 10. Summary

Connection pooling reuses database connections for better performance. HikariCP is default in Spring Boot - fastest and most reliable. Key configurations: maximum-pool-size (formula: core_count * 2 for SSD, typically 10-20), connection-timeout (30 seconds), max-lifetime (30 minutes, less than database timeout), leak-detection-threshold (60 seconds). Don't set minimum-idle - let it equal maximum-pool-size. Monitor with HikariPoolMXBean metrics: active, idle, total connections, threads waiting. Common issues: connection timeout (increase pool size), connection leaks (use try-with-resources, enable leak detection), database connection limit (ensure pool_size * instances < db_max_connections). More connections NOT always better - tune based on load testing and monitoring. Critical for production performance and stability.

---

**Next:** Async Processing →
