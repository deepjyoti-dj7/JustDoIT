# Memory Management - Complete Guide

---

## 1. Introduction to JVM Memory

Understanding JVM memory structure is crucial for optimizing application performance and preventing OutOfMemoryErrors.

### JVM Memory Structure

```
┌─────────────────────────────────────┐
│        JVM Memory                    │
├─────────────────────────────────────┤
│  Heap Memory                         │
│  ├── Young Generation                │
│  │   ├── Eden Space                  │
│  │   ├── Survivor 0 (S0)             │
│  │   └── Survivor 1 (S1)             │
│  └── Old Generation (Tenured)        │
├─────────────────────────────────────┤
│  Non-Heap Memory                     │
│  ├── Metaspace (Class metadata)      │
│  ├── Code Cache (JIT compiled code)  │
│  └── Thread Stacks                   │
└─────────────────────────────────────┘
```

---

## 2. Heap Memory Configuration

### 2.1. Basic Heap Settings

```bash
java -Xms2g \          # Initial heap size: 2GB
     -Xmx4g \          # Maximum heap size: 4GB
     -jar application.jar
```

**Recommendations:**
- Set `-Xms` = `-Xmx` for production (prevents resizing)
- Total heap: 25-50% of total system memory
- Leave memory for OS and non-heap

### 2.2. Young Generation Sizing

```bash
java -Xms4g -Xmx4g \
     -XX:NewRatio=2 \              # Old:Young = 2:1
     -XX:SurvivorRatio=8 \         # Eden:Survivor = 8:1
     -jar application.jar

# Or specify directly
java -Xms4g -Xmx4g \
     -XX:NewSize=1g \
     -XX:MaxNewSize=1g \
     -jar application.jar
```

**Formula:**
- Young = Heap / (NewRatio + 1)
- With NewRatio=2 and Heap=3GB: Young=1GB, Old=2GB

---

## 3. Metaspace Configuration

### 3.1. Metaspace Settings

```bash
java -XX:MetaspaceSize=256m \      # Initial metaspace
     -XX:MaxMetaspaceSize=512m \   # Maximum metaspace
     -jar application.jar
```

**Default:**
- Initial: ~21MB
- Maximum: Unlimited (native memory)

**Recommendations:**
- Set `MaxMetaspaceSize` to prevent unlimited growth
- Monitor with `-XX:+TraceClassLoading` and `-XX:+TraceClassUnloading`

### 3.2. Class Metadata Monitoring

```java
@Component
public class MetaspaceMonitor {
    
    @Scheduled(fixedRate = 300000)  // Every 5 minutes
    public void logMetaspaceUsage() {
        List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
        
        for (MemoryPoolMXBean pool : pools) {
            if (pool.getName().contains("Metaspace")) {
                MemoryUsage usage = pool.getUsage();
                long used = usage.getUsed() / 1024 / 1024;  // MB
                long max = usage.getMax() / 1024 / 1024;
                
                log.info("Metaspace: {} MB / {} MB ({}%)",
                         used, max, (used * 100) / max);
            }
        }
    }
}
```

---

## 4. Garbage Collection

### 4.1. GC Algorithms

#### Serial GC (Single Thread)
```bash
java -XX:+UseSerialGC -jar application.jar
```
**Use:** Small applications, single CPU

#### Parallel GC (Throughput)
```bash
java -XX:+UseParallelGC \
     -XX:ParallelGCThreads=4 \
     -jar application.jar
```
**Use:** Batch processing, throughput-focused

#### G1 GC (Balanced - Default since Java 9)
```bash
java -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \    # Target pause time
     -XX:G1HeapRegionSize=16m \
     -jar application.jar
```
**Use:** General purpose, balanced throughput and latency

#### ZGC (Low Latency)
```bash
java -XX:+UseZGC \
     -XX:ZAllocationSpikeTolerance=5 \
     -jar application.jar
```
**Use:** Large heaps, low latency requirements (<10ms pauses)

### 4.2. GC Logging

```bash
# Java 8
java -Xloggc:/var/log/gc.log \
     -XX:+PrintGCDetails \
     -XX:+PrintGCDateStamps \
     -XX:+UseGCLogFileRotation \
     -XX:NumberOfGCLogFiles=10 \
     -XX:GCLogFileSize=10M \
     -jar application.jar

# Java 9+
java -Xlog:gc*:file=/var/log/gc.log:time,uptime,level,tags:filecount=10,filesize=10M \
     -jar application.jar
```

### 4.3. GC Tuning

```bash
java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \      # Target 200ms pause
     -XX:G1HeapRegionSize=16m \
     -XX:InitiatingHeapOccupancyPercent=45 \  # Start concurrent GC at 45%
     -XX:G1ReservePercent=10 \        # Reserve 10% for to-space
     -XX:+UseStringDeduplication \    # Deduplicate strings
     -jar application.jar
```

---

## 5. Memory Leak Detection

### 5.1. Common Memory Leak Patterns

#### Static Collections
```java
// ❌ Bad - Memory leak
public class UserCache {
    private static Map<Long, User> cache = new HashMap<>();
    
    public void addUser(User user) {
        cache.put(user.getId(), user);  // Never removed!
    }
}

// ✅ Good - Bounded cache
public class UserCache {
    private final Map<Long, User> cache = new LinkedHashMap<>(100, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Long, User> eldest) {
            return size() > 100;
        }
    };
}

// ✅ Better - Use Caffeine
@Configuration
public class CacheConfig {
    @Bean
    public Cache<Long, User> userCache() {
        return Caffeine.newBuilder()
                       .maximumSize(1000)
                       .expireAfterWrite(10, TimeUnit.MINUTES)
                       .build();
    }
}
```

#### Unclosed Resources
```java
// ❌ Bad - Resource leak
public void processFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(path));
    // If exception occurs, reader never closed!
    String line = reader.readLine();
}

// ✅ Good - Auto-close
public void processFile(String path) throws IOException {
    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
        String line = reader.readLine();
    }  // Automatically closed
}
```

#### ThreadLocal Leaks
```java
// ❌ Bad - ThreadLocal leak
public class RequestContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setUser(User user) {
        currentUser.set(user);  // Never removed!
    }
}

// ✅ Good - Clean up
public class RequestContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public static void setUser(User user) {
        currentUser.set(user);
    }
    
    public static void clear() {
        currentUser.remove();  // Clean up
    }
}

@Component
public class RequestContextFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain chain) throws IOException, ServletException {
        try {
            User user = getUserFromRequest(request);
            RequestContext.setUser(user);
            chain.doFilter(request, response);
        } finally {
            RequestContext.clear();  // Always clean up
        }
    }
}
```

### 5.2. Heap Dump Analysis

```bash
# Manual heap dump
jmap -dump:live,format=b,file=heap.hprof <pid>

# Automatic heap dump on OOM
java -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/heapdumps \
     -jar application.jar
```

**Analyze with Eclipse MAT:**
1. Open heap.hprof in MAT
2. Run "Leak Suspects Report"
3. Check "Dominator Tree" for largest objects
4. Look for unexpected object retention

---

## 6. Memory Monitoring

### 6.1. JVM Memory Metrics

```java
@Component
public class MemoryMonitor {
    
    @Scheduled(fixedRate = 60000)
    public void logMemoryUsage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        
        // Heap memory
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        long heapUsed = heapUsage.getUsed() / 1024 / 1024;
        long heapMax = heapUsage.getMax() / 1024 / 1024;
        
        // Non-heap memory
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        long nonHeapUsed = nonHeapUsage.getUsed() / 1024 / 1024;
        
        log.info("Memory Usage:");
        log.info("  Heap: {} MB / {} MB ({}%)", 
                 heapUsed, heapMax, (heapUsed * 100) / heapMax);
        log.info("  Non-Heap: {} MB", nonHeapUsed);
        
        // GC stats
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            log.info("  GC {}: {} collections, {} ms",
                     gcBean.getName(),
                     gcBean.getCollectionCount(),
                     gcBean.getCollectionTime());
        }
    }
}
```

### 6.2. Actuator Metrics

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics
```

**Access metrics:**
```bash
# Heap memory
curl http://localhost:8080/actuator/metrics/jvm.memory.used?tag=area:heap

# GC metrics
curl http://localhost:8080/actuator/metrics/jvm.gc.pause

# Memory pool
curl http://localhost:8080/actuator/metrics/jvm.memory.used?tag=id:PS%20Eden%20Space
```

---

## 7. Memory Optimization Techniques

### 7.1. Object Pooling

```java
// For expensive-to-create objects
public class ConnectionPool {
    private final BlockingQueue<Connection> pool;
    
    public ConnectionPool(int size) {
        pool = new LinkedBlockingQueue<>(size);
        for (int i = 0; i < size; i++) {
            pool.offer(createConnection());
        }
    }
    
    public Connection acquire() throws InterruptedException {
        return pool.take();
    }
    
    public void release(Connection connection) {
        pool.offer(connection);
    }
}
```

### 7.2. Lazy Initialization

```java
// ❌ Bad - Eager initialization
public class ReportService {
    private final ExpensiveResource resource = new ExpensiveResource();
}

// ✅ Good - Lazy initialization
public class ReportService {
    private ExpensiveResource resource;
    
    private ExpensiveResource getResource() {
        if (resource == null) {
            resource = new ExpensiveResource();
        }
        return resource;
    }
}

// ✅ Better - Spring lazy bean
@Service
@Lazy
public class ReportService {
    // Only created when first used
}
```

### 7.3. String Optimization

```java
// ❌ Bad - Creates many objects
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // Creates 1000 String objects
}

// ✅ Good - Reuses buffer
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

### 7.4. Weak References

```java
public class ImageCache {
    private final Map<String, WeakReference<Image>> cache = new ConcurrentHashMap<>();
    
    public Image getImage(String key) {
        WeakReference<Image> ref = cache.get(key);
        if (ref != null) {
            Image image = ref.get();
            if (image != null) {
                return image;
            }
        }
        
        // Load and cache
        Image image = loadImage(key);
        cache.put(key, new WeakReference<>(image));
        return image;
    }
}
```

---

## 8. OutOfMemoryError Handling

### 8.1. Types of OOM

#### Heap Space
```
java.lang.OutOfMemoryError: Java heap space
```
**Cause:** Heap exhausted  
**Solution:** Increase `-Xmx` or fix memory leaks

#### Metaspace
```
java.lang.OutOfMemoryError: Metaspace
```
**Cause:** Too many classes  
**Solution:** Increase `-XX:MaxMetaspaceSize` or reduce class loading

#### GC Overhead Limit
```
java.lang.OutOfMemoryError: GC overhead limit exceeded
```
**Cause:** >98% time in GC, <2% heap recovered  
**Solution:** Increase heap or optimize code

#### Unable to create new native thread
```
java.lang.OutOfMemoryError: unable to create new native thread
```
**Cause:** Too many threads  
**Solution:** Reduce threads or increase OS limits

### 8.2. OOM Handling

```java
@ControllerAdvice
public class OOMHandler {
    
    @ExceptionHandler(OutOfMemoryError.class)
    public ResponseEntity<String> handleOOM(OutOfMemoryError error) {
        log.error("OutOfMemoryError occurred", error);
        
        // Trigger heap dump
        triggerHeapDump();
        
        // Alert operations team
        alertService.sendCritical("OOM in production!");
        
        // Return graceful error
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                             .body("Service temporarily unavailable");
    }
    
    private void triggerHeapDump() {
        try {
            MBeanServer server = ManagementFactory.getPlatformMBeanServer();
            HotSpotDiagnosticMXBean bean = ManagementFactory.newPlatformMXBeanProxy(
                server, "com.sun.management:type=HotSpotDiagnostic", 
                HotSpotDiagnosticMXBean.class
            );
            bean.dumpHeap("/var/log/oom-" + System.currentTimeMillis() + ".hprof", true);
        } catch (IOException e) {
            log.error("Failed to create heap dump", e);
        }
    }
}
```

---

## 9. Interview Questions

**Q1: What is heap memory?**
**A:** Memory area where objects are allocated.

**Q2: What is non-heap memory?**
**A:** Metaspace, code cache, thread stacks.

**Q3: What is -Xms?**
**A:** Initial heap size.

**Q4: What is -Xmx?**
**A:** Maximum heap size.

**Q5: Should Xms = Xmx?**
**A:** Yes, in production to avoid resizing overhead.

**Q6: What is Metaspace?**
**A:** Area for class metadata (replaced PermGen in Java 8).

**Q7: What is G1GC?**
**A:** Garbage-First Garbage Collector (default since Java 9).

**Q8: What is MaxGCPauseMillis?**
**A:** Target maximum GC pause time for G1GC.

**Q9: What is heap dump?**
**A:** Snapshot of all objects in heap memory.

**Q10: How to trigger heap dump?**
**A:** jmap -dump or -XX:+HeapDumpOnOutOfMemoryError

**Q11: What is memory leak?**
**A:** Objects not GC'd despite being unused.

**Q12: Common memory leak patterns?**
**A:** Static collections, unclosed resources, ThreadLocal not cleared.

**Q13: What is ThreadLocal leak?**
**A:** ThreadLocal not cleared in thread pools.

**Q14: What is try-with-resources?**
**A:** Auto-closes resources implementing AutoCloseable.

**Q15: What is WeakReference?**
**A:** Reference GC'd when no strong references exist.

**Q16: What is Eden Space?**
**A:** Where new objects are allocated in young generation.

**Q17: What is Survivor Space?**
**A:** Where objects surviving minor GC are moved.

**Q18: What is Old Generation?**
**A:** Where long-lived objects are promoted.

**Q19: What is full GC?**
**A:** GC of both young and old generations.

**Q20: What is GC overhead limit exceeded?**
**A:** >98% time in GC, <2% heap recovered.

---

## 10. Summary

JVM memory: Heap (young generation: Eden + Survivors, old generation) and Non-Heap (Metaspace, code cache, thread stacks). Configure heap: -Xms (initial), -Xmx (maximum), set equal in production. Metaspace: -XX:MetaspaceSize, -XX:MaxMetaspaceSize. GC algorithms: G1GC (default, balanced), ZGC (low latency), Parallel GC (throughput). Enable GC logging and heap dump on OOM. Common leaks: static collections (use bounded cache), unclosed resources (use try-with-resources), ThreadLocal (always remove()). Monitor: MemoryMXBean, Actuator metrics, heap dumps with Eclipse MAT. Optimize: object pooling, lazy initialization, StringBuilder, weak references. Critical for production stability and performance.

---

**Next:** Common Pitfalls →
