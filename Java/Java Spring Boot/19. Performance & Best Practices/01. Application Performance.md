# Application Performance - Complete Guide

---

## 1. Introduction to Application Performance

Application performance is critical for user experience, scalability, and cost efficiency.

### Why Performance Matters?

- **User Experience** - Fast response times improve satisfaction
- **Scalability** - Handle more requests with same resources
- **Cost Efficiency** - Reduce infrastructure costs
- **Competitive Advantage** - Faster apps win users
- **Resource Utilization** - Better CPU, memory, I/O usage

### Key Performance Metrics

- **Response Time** - Time to complete a request
- **Throughput** - Requests processed per second
- **Latency** - Time waiting for response
- **CPU Utilization** - Percentage of CPU used
- **Memory Usage** - Heap and non-heap consumption
- **I/O Operations** - Disk and network operations

---

## 2. Performance Profiling

### 2.1. JVM Profiling Tools

**VisualVM:**
```bash
# Download and run VisualVM
visualvm

# Connect to running application
jvisualvm --openpid <pid>
```

**Java Mission Control (JMC):**
```bash
# Enable JFR (Java Flight Recorder)
java -XX:+UnlockCommercialFeatures \
     -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=recording.jfr \
     -jar application.jar

# Analyze recording
jmc recording.jfr
```

**JProfiler:**
- Commercial profiling tool
- CPU, memory, thread profiling
- Database and network analysis

### 2.2. Spring Boot Actuator Metrics

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    private final MeterRegistry meterRegistry;
    private final Timer requestTimer;
    
    public ProductController(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.requestTimer = Timer.builder("product.request.time")
                                  .publishPercentiles(0.5, 0.95, 0.99)
                                  .register(meterRegistry);
    }
    
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable Long id) {
        return requestTimer.record(() -> {
            return productService.findById(id);
        });
    }
}
```

### 2.3. Custom Performance Monitoring

```java
@Aspect
@Component
@Slf4j
public class PerformanceMonitoringAspect {
    
    @Around("@annotation(monitored)")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint, 
                                     Monitored monitored) throws Throwable {
        long startTime = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().getName();
        
        try {
            Object result = joinPoint.proceed();
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (executionTime > monitored.threshold()) {
                log.warn("Slow method detected: {} took {}ms (threshold: {}ms)",
                         methodName, executionTime, monitored.threshold());
            } else {
                log.debug("Method {} executed in {}ms", methodName, executionTime);
            }
            
            return result;
        } catch (Throwable e) {
            long executionTime = System.currentTimeMillis() - startTime;
            log.error("Method {} failed after {}ms", methodName, executionTime, e);
            throw e;
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Monitored {
    long threshold() default 1000; // milliseconds
}
```

**Usage:**
```java
@Service
public class ProductService {
    
    @Monitored(threshold = 500)
    public Product findById(Long id) {
        return productRepository.findById(id)
                                .orElseThrow(() -> new NotFoundException("Product not found"));
    }
}
```

---

## 3. Response Time Optimization

### 3.1. HTTP Compression

```yaml
# application.yml
server:
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml
    min-response-size: 1024
```

### 3.2. HTTP Caching

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProduct(@PathVariable Long id) {
        Product product = productService.findById(id);
        
        return ResponseEntity.ok()
                             .cacheControl(CacheControl.maxAge(1, TimeUnit.HOURS)
                                                       .cachePublic())
                             .eTag(product.getVersion().toString())
                             .body(product);
    }
}
```

### 3.3. ETag Support

```java
@GetMapping("/{id}")
public ResponseEntity<Product> getProduct(@PathVariable Long id,
                                          WebRequest request) {
    Product product = productService.findById(id);
    String etag = String.valueOf(product.getVersion());
    
    // Check if content has changed
    if (request.checkNotModified(etag)) {
        return null; // 304 Not Modified
    }
    
    return ResponseEntity.ok()
                         .eTag(etag)
                         .body(product);
}
```

---

## 4. Lazy Loading and Eager Loading

### 4.1. Lazy Loading (Default)

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Lazy loading - loaded only when accessed
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> items;
}
```

### 4.2. Eager Loading (When Needed)

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Eager loading - loaded immediately
    @OneToMany(mappedBy = "order", fetch = FetchType.EAGER)
    private List<OrderItem> items;
}
```

### 4.3. Entity Graph (Preferred)

```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @EntityGraph(attributePaths = {"items", "customer"})
    @Query("SELECT o FROM Order o WHERE o.id = :id")
    Optional<Order> findByIdWithDetails(@Param("id") Long id);
}
```

---

## 5. Pagination and Limiting Results

### 5.1. Spring Data Pagination

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    Page<Product> findByCategory(String category, Pageable pageable);
}
```

**Usage:**
```java
@GetMapping
public Page<Product> getProducts(
        @RequestParam String category,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size,
        @RequestParam(defaultValue = "name,asc") String[] sort) {
    
    Sort.Direction direction = sort[1].equalsIgnoreCase("desc") 
                               ? Sort.Direction.DESC 
                               : Sort.Direction.ASC;
    Pageable pageable = PageRequest.of(page, size, Sort.by(direction, sort[0]));
    
    return productRepository.findByCategory(category, pageable);
}
```

### 5.2. Slice for Better Performance

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Slice doesn't count total elements (faster)
    Slice<Product> findByCategory(String category, Pageable pageable);
}
```

### 5.3. Limit Query Results

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Limit to top 10 results
    List<Product> findTop10ByOrderByCreatedAtDesc();
    
    // First 5 results
    List<Product> findFirst5ByCategory(String category);
}
```

---

## 6. Batch Processing

### 6.1. Batch Insert

```java
@Service
@Transactional
public class ProductService {
    
    @Autowired
    private EntityManager entityManager;
    
    public void batchInsert(List<Product> products) {
        int batchSize = 50;
        
        for (int i = 0; i < products.size(); i++) {
            entityManager.persist(products.get(i));
            
            if (i > 0 && i % batchSize == 0) {
                entityManager.flush();
                entityManager.clear();
            }
        }
        
        entityManager.flush();
        entityManager.clear();
    }
}
```

**Configuration:**
```yaml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 50
        order_inserts: true
        order_updates: true
```

### 6.2. JDBC Batch Insert

```java
@Service
public class ProductBatchService {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public void batchInsert(List<Product> products) {
        String sql = "INSERT INTO product (name, price, category) VALUES (?, ?, ?)";
        
        jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                Product product = products.get(i);
                ps.setString(1, product.getName());
                ps.setBigDecimal(2, product.getPrice());
                ps.setString(3, product.getCategory());
            }
            
            @Override
            public int getBatchSize() {
                return products.size();
            }
        });
    }
}
```

---

## 7. Caching Strategies

### 7.1. Application-Level Caching

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("products", "users");
        cacheManager.setCaffeine(Caffeine.newBuilder()
                                         .maximumSize(1000)
                                         .expireAfterWrite(10, TimeUnit.MINUTES)
                                         .recordStats());
        return cacheManager;
    }
}
```

```java
@Service
public class ProductService {
    
    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        return productRepository.findById(id)
                                .orElseThrow(() -> new NotFoundException("Product not found"));
    }
    
    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        return productRepository.save(product);
    }
    
    @CacheEvict(value = "products", key = "#id")
    public void delete(Long id) {
        productRepository.deleteById(id);
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        // Cache cleared
    }
}
```

### 7.2. Redis Caching

```yaml
spring:
  cache:
    type: redis
  redis:
    host: localhost
    port: 6379
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
```

```java
@Configuration
@EnableCaching
public class RedisCacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(
                new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(
                new GenericJackson2JsonRedisSerializer()))
            .disableCachingNullValues();
        
        return RedisCacheManager.builder(connectionFactory)
                                .cacheDefaults(config)
                                .build();
    }
}
```

---

## 8. CDN and Static Resource Optimization

### 8.1. Static Resource Versioning

```yaml
spring:
  resources:
    chain:
      strategy:
        content:
          enabled: true
          paths: /**
      cache: true
    cache:
      cachecontrol:
        max-age: 365d
```

### 8.2. CDN Configuration

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Value("${cdn.url}")
    private String cdnUrl;
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/")
                .setCachePeriod(31536000) // 1 year
                .resourceChain(true)
                .addResolver(new PathResourceResolver());
    }
}
```

---

## 9. Load Balancing and Scaling

### 9.1. Horizontal Scaling

```yaml
# Kubernetes deployment with multiple replicas
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: product-service
  template:
    spec:
      containers:
      - name: product-service
        image: product-service:1.0.0
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
```

### 9.2. Load Balancer Configuration

```yaml
# Service with load balancer
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  type: LoadBalancer
  selector:
    app: product-service
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800
```

---

## 10. Database Query Performance

### 10.1. Query Optimization

```java
// ❌ Bad - Loads all fields
@Query("SELECT p FROM Product p WHERE p.category = :category")
List<Product> findByCategory(@Param("category") String category);

// ✅ Good - Projects only needed fields
@Query("SELECT new com.example.dto.ProductDTO(p.id, p.name, p.price) " +
       "FROM Product p WHERE p.category = :category")
List<ProductDTO> findByCategoryProjected(@Param("category") String category);
```

### 10.2. Index Usage

```java
@Entity
@Table(name = "product", indexes = {
    @Index(name = "idx_category", columnList = "category"),
    @Index(name = "idx_name", columnList = "name"),
    @Index(name = "idx_category_price", columnList = "category, price")
})
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(nullable = false)
    private BigDecimal price;
    
    @Column(nullable = false, length = 50)
    private String category;
}
```

---

## 11. API Response Optimization

### 11.1. DTO Projections

```java
// DTO for API response
@Data
@AllArgsConstructor
public class ProductDTO {
    private Long id;
    private String name;
    private BigDecimal price;
    private String category;
}

// Mapper
@Component
public class ProductMapper {
    
    public ProductDTO toDTO(Product product) {
        return new ProductDTO(
            product.getId(),
            product.getName(),
            product.getPrice(),
            product.getCategory()
        );
    }
    
    public List<ProductDTO> toDTOList(List<Product> products) {
        return products.stream()
                       .map(this::toDTO)
                       .collect(Collectors.toList());
    }
}
```

### 11.2. JsonView for Conditional Serialization

```java
public class Views {
    public static class Summary {}
    public static class Detailed extends Summary {}
}

@Entity
public class Product {
    @Id
    @JsonView(Views.Summary.class)
    private Long id;
    
    @JsonView(Views.Summary.class)
    private String name;
    
    @JsonView(Views.Summary.class)
    private BigDecimal price;
    
    @JsonView(Views.Detailed.class)
    private String description;
    
    @JsonView(Views.Detailed.class)
    private LocalDateTime createdAt;
}

@RestController
public class ProductController {
    
    @GetMapping
    @JsonView(Views.Summary.class)
    public List<Product> getProducts() {
        return productService.findAll();
    }
    
    @GetMapping("/{id}")
    @JsonView(Views.Detailed.class)
    public Product getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
}
```

---

## 12. Interview Questions

**Q1: What is response time?**
**A:** Time taken to complete a request from start to finish.

**Q2: What is throughput?**
**A:** Number of requests processed per second.

**Q3: What is latency?**
**A:** Time waiting for a response to start.

**Q4: How to enable HTTP compression?**
**A:** server.compression.enabled=true in application.yml

**Q5: What is ETag?**
**A:** HTTP header for cache validation based on resource version.

**Q6: Difference between lazy and eager loading?**
**A:** Lazy: load on access. Eager: load immediately.

**Q7: What is @EntityGraph?**
**A:** Defines which relationships to fetch eagerly for specific queries.

**Q8: What is pagination?**
**A:** Breaking large result sets into pages for better performance.

**Q9: What is Slice vs Page?**
**A:** Slice doesn't count total elements, Page does (faster).

**Q10: What is batch processing?**
**A:** Processing multiple records together in batches for efficiency.

**Q11: What is @Cacheable?**
**A:** Caches method result, returns cached value on subsequent calls.

**Q12: What is @CacheEvict?**
**A:** Removes entries from cache.

**Q13: What is @CachePut?**
**A:** Updates cache with method result.

**Q14: What is Caffeine cache?**
**A:** High-performance in-memory cache library for Java.

**Q15: What is horizontal scaling?**
**A:** Adding more instances/servers to handle load.

**Q16: What is vertical scaling?**
**A:** Increasing resources (CPU, memory) of existing server.

**Q17: What is DTO projection?**
**A:** Selecting only needed fields instead of entire entity.

**Q18: What is @JsonView?**
**A:** Conditionally include/exclude fields in JSON serialization.

**Q19: What is CDN?**
**A:** Content Delivery Network - distributes static content globally.

**Q20: What is query optimization?**
**A:** Improving query performance through better structure, indexes, projections.

---

## 13. Summary

Application performance optimization is crucial for scalability and user experience. Key areas: Response time (HTTP compression, caching, ETags), Lazy vs Eager loading (use @EntityGraph for selective eager loading), Pagination (use Page or Slice, limit results), Batch processing (JDBC batch, Hibernate batch with flush/clear), Caching (@Cacheable, @CachePut, @CacheEvict with Caffeine or Redis), Query optimization (DTO projections, indexes, avoid N+1), API optimization (JsonView, DTO mappers), Scaling (horizontal scaling with load balancers). Monitor with Actuator metrics, JProfiler, VisualVM. Configure compression, cache headers, batch sizes. Profile before optimizing - measure, don't guess. Essential for production applications handling significant load.

---

**Next:** Database Optimization →
