# Design Patterns in Spring Boot - Complete Guide

---

## 1. Introduction to Design Patterns

Design patterns are reusable solutions to common software design problems.

### Why Design Patterns?

- **Proven Solutions** - Battle-tested approaches
- **Common Vocabulary** - Team communication
- **Best Practices** - Industry standards
- **Maintainability** - Easier to understand and modify
- **Scalability** - Handle growth effectively

### Pattern Categories

1. **Creational** - Object creation mechanisms
2. **Structural** - Object composition
3. **Behavioral** - Object interaction and responsibility

---

## 2. Creational Patterns

### 2.1. Singleton Pattern

**Definition:** Ensures a class has only one instance.

**Spring Boot Implementation:**

```java
// Spring beans are singleton by default
@Service
public class UserService {
    // Only one instance created by Spring container
}

// Explicit singleton scope
@Service
@Scope("singleton")  // Default scope
public class ConfigService {
    private final Map<String, String> config = new HashMap<>();
}
```

**Manual Singleton:**

```java
public class DatabaseConnection {
    private static DatabaseConnection instance;
    
    private DatabaseConnection() {
        // Private constructor
    }
    
    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```

### 2.2. Factory Pattern

**Definition:** Creates objects without specifying exact class.

```java
// Factory interface
public interface PaymentProcessor {
    void process(Payment payment);
}

// Concrete implementations
@Component("creditCardProcessor")
public class CreditCardProcessor implements PaymentProcessor {
    @Override
    public void process(Payment payment) {
        // Credit card processing
    }
}

@Component("paypalProcessor")
public class PayPalProcessor implements PaymentProcessor {
    @Override
    public void process(Payment payment) {
        // PayPal processing
    }
}

// Factory
@Component
public class PaymentProcessorFactory {
    private final Map<String, PaymentProcessor> processors;
    
    @Autowired
    public PaymentProcessorFactory(List<PaymentProcessor> processorList) {
        processors = processorList.stream()
            .collect(Collectors.toMap(
                processor -> processor.getClass().getSimpleName().replace("Processor", "").toLowerCase(),
                processor -> processor
            ));
    }
    
    public PaymentProcessor getProcessor(String type) {
        PaymentProcessor processor = processors.get(type.toLowerCase());
        if (processor == null) {
            throw new IllegalArgumentException("Unknown payment type: " + type);
        }
        return processor;
    }
}

// Usage
@Service
public class OrderService {
    private final PaymentProcessorFactory processorFactory;
    
    public void checkout(Order order, String paymentType) {
        PaymentProcessor processor = processorFactory.getProcessor(paymentType);
        processor.process(order.getPayment());
    }
}
```

### 2.3. Builder Pattern

**Definition:** Constructs complex objects step by step.

```java
// Using Lombok
@Builder
@Data
public class User {
    private String firstName;
    private String lastName;
    private String email;
    private String phone;
    private Address address;
}

// Usage
User user = User.builder()
    .firstName("John")
    .lastName("Doe")
    .email("john@example.com")
    .phone("123-456-7890")
    .build();

// Custom builder
public class QueryBuilder {
    private final StringBuilder query = new StringBuilder("SELECT * FROM users WHERE 1=1");
    private final List<Object> params = new ArrayList<>();
    
    public QueryBuilder withName(String name) {
        if (name != null) {
            query.append(" AND name = ?");
            params.add(name);
        }
        return this;
    }
    
    public QueryBuilder withEmail(String email) {
        if (email != null) {
            query.append(" AND email = ?");
            params.add(email);
        }
        return this;
    }
    
    public QueryBuilder withAge(Integer minAge, Integer maxAge) {
        if (minAge != null) {
            query.append(" AND age >= ?");
            params.add(minAge);
        }
        if (maxAge != null) {
            query.append(" AND age <= ?");
            params.add(maxAge);
        }
        return this;
    }
    
    public String build() {
        return query.toString();
    }
    
    public List<Object> getParams() {
        return params;
    }
}

// Usage
QueryBuilder builder = new QueryBuilder()
    .withName("John")
    .withEmail("john@example.com")
    .withAge(18, 65);
```

### 2.4. Prototype Pattern

**Definition:** Creates new objects by cloning existing ones.

```java
@Component
@Scope("prototype")  // New instance for each request
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    
    public void addItem(Item item) {
        items.add(item);
    }
}

// Usage
@Service
public class CartService {
    @Autowired
    private ApplicationContext context;
    
    public ShoppingCart createNewCart() {
        return context.getBean(ShoppingCart.class);  // New instance each time
    }
}
```

---

## 3. Structural Patterns

### 3.1. Adapter Pattern

**Definition:** Converts interface of a class into another interface.

```java
// Target interface
public interface PaymentGateway {
    boolean processPayment(String amount, String currency);
}

// Adaptee - existing third-party library
public class StripeClient {
    public StripeResponse charge(double amount, String currency) {
        // Stripe-specific implementation
        return new StripeResponse();
    }
}

// Adapter
@Component
public class StripeAdapter implements PaymentGateway {
    private final StripeClient stripeClient = new StripeClient();
    
    @Override
    public boolean processPayment(String amount, String currency) {
        double amountDouble = Double.parseDouble(amount);
        StripeResponse response = stripeClient.charge(amountDouble, currency);
        return response.isSuccess();
    }
}

// Service using adapter
@Service
public class PaymentService {
    private final PaymentGateway paymentGateway;
    
    @Autowired
    public PaymentService(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }
    
    public void pay(Order order) {
        boolean success = paymentGateway.processPayment(
            order.getTotal().toString(),
            order.getCurrency()
        );
    }
}
```

### 3.2. Decorator Pattern

**Definition:** Adds behavior to objects dynamically.

```java
// Component
public interface Coffee {
    String getDescription();
    double getCost();
}

// Concrete component
public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

// Base decorator
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
}

// Concrete decorators
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    
    @Override
    public double getCost() {
        return coffee.getCost() + 0.2;
    }
}

// Usage
Coffee coffee = new SimpleCoffee();
coffee = new MilkDecorator(coffee);
coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription());  // Simple Coffee, Milk, Sugar
System.out.println(coffee.getCost());  // 2.7

// Spring Boot example - TaskDecorator
@Configuration
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setTaskDecorator(new ContextCopyingDecorator());  // Decorator!
        executor.initialize();
        return executor;
    }
}

public class ContextCopyingDecorator implements TaskDecorator {
    @Override
    public Runnable decorate(Runnable task) {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return () -> {
            try {
                // Copy context to new thread
                SecurityContext context = SecurityContextHolder.createEmptyContext();
                context.setAuthentication(new UsernamePasswordAuthenticationToken(username, null));
                SecurityContextHolder.setContext(context);
                task.run();
            } finally {
                SecurityContextHolder.clearContext();
            }
        };
    }
}
```

### 3.3. Proxy Pattern

**Definition:** Provides placeholder for another object.

```java
// Subject interface
public interface UserService {
    User findById(Long id);
}

// Real subject
@Service
public class UserServiceImpl implements UserService {
    @Override
    public User findById(Long id) {
        // Database query
        return userRepository.findById(id).orElse(null);
    }
}

// Proxy with caching
@Service
@Primary
public class CachedUserServiceProxy implements UserService {
    private final UserService userService;
    private final Map<Long, User> cache = new ConcurrentHashMap<>();
    
    @Autowired
    public CachedUserServiceProxy(@Qualifier("userServiceImpl") UserService userService) {
        this.userService = userService;
    }
    
    @Override
    public User findById(Long id) {
        return cache.computeIfAbsent(id, userService::findById);
    }
}

// Spring AOP is proxy-based
@Service
public class OrderService {
    
    @Transactional  // Creates proxy with transaction management
    public void createOrder(Order order) {
        orderRepository.save(order);
    }
}
```

### 3.4. Facade Pattern

**Definition:** Provides simplified interface to complex subsystem.

```java
// Complex subsystems
@Service
public class InventoryService {
    public boolean checkAvailability(Long productId, int quantity) {
        // Complex inventory logic
        return true;
    }
    
    public void reserveItems(Long productId, int quantity) {
        // Reserve logic
    }
}

@Service
public class PaymentService {
    public boolean processPayment(Payment payment) {
        // Complex payment processing
        return true;
    }
}

@Service
public class ShippingService {
    public void scheduleShipment(Order order) {
        // Complex shipping logic
    }
}

@Service
public class NotificationService {
    public void sendOrderConfirmation(Order order) {
        // Send email/SMS
    }
}

// Facade - Simplified interface
@Service
public class OrderFacade {
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final ShippingService shippingService;
    private final NotificationService notificationService;
    private final OrderRepository orderRepository;
    
    @Transactional
    public OrderResult placeOrder(OrderRequest request) {
        // 1. Check inventory
        if (!inventoryService.checkAvailability(request.getProductId(), request.getQuantity())) {
            return OrderResult.failure("Out of stock");
        }
        
        // 2. Reserve items
        inventoryService.reserveItems(request.getProductId(), request.getQuantity());
        
        // 3. Process payment
        if (!paymentService.processPayment(request.getPayment())) {
            return OrderResult.failure("Payment failed");
        }
        
        // 4. Save order
        Order order = orderRepository.save(request.toOrder());
        
        // 5. Schedule shipping
        shippingService.scheduleShipment(order);
        
        // 6. Send notification
        notificationService.sendOrderConfirmation(order);
        
        return OrderResult.success(order);
    }
}

// Controller uses simple facade
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    private final OrderFacade orderFacade;
    
    @PostMapping
    public ResponseEntity<OrderResult> placeOrder(@RequestBody OrderRequest request) {
        OrderResult result = orderFacade.placeOrder(request);
        return ResponseEntity.ok(result);
    }
}
```

---

## 4. Behavioral Patterns

### 4.1. Strategy Pattern

**Definition:** Defines family of algorithms, makes them interchangeable.

```java
// Strategy interface
public interface DiscountStrategy {
    BigDecimal calculateDiscount(BigDecimal amount);
}

// Concrete strategies
@Component
public class NoDiscountStrategy implements DiscountStrategy {
    @Override
    public BigDecimal calculateDiscount(BigDecimal amount) {
        return BigDecimal.ZERO;
    }
}

@Component
public class PercentageDiscountStrategy implements DiscountStrategy {
    private final BigDecimal percentage = new BigDecimal("0.10");  // 10%
    
    @Override
    public BigDecimal calculateDiscount(BigDecimal amount) {
        return amount.multiply(percentage);
    }
}

@Component
public class FixedAmountDiscountStrategy implements DiscountStrategy {
    private final BigDecimal fixedAmount = new BigDecimal("5.00");
    
    @Override
    public BigDecimal calculateDiscount(BigDecimal amount) {
        return fixedAmount;
    }
}

// Context
@Service
public class PricingService {
    private final Map<String, DiscountStrategy> strategies;
    
    @Autowired
    public PricingService(List<DiscountStrategy> strategyList) {
        strategies = strategyList.stream()
            .collect(Collectors.toMap(
                s -> s.getClass().getSimpleName(),
                s -> s
            ));
    }
    
    public BigDecimal calculateFinalPrice(BigDecimal basePrice, String discountType) {
        DiscountStrategy strategy = strategies.getOrDefault(
            discountType + "DiscountStrategy",
            new NoDiscountStrategy()
        );
        BigDecimal discount = strategy.calculateDiscount(basePrice);
        return basePrice.subtract(discount);
    }
}
```

### 4.2. Observer Pattern

**Definition:** Notifies multiple objects about state changes.

```java
// Event
public class OrderCreatedEvent extends ApplicationEvent {
    private final Order order;
    
    public OrderCreatedEvent(Object source, Order order) {
        super(source);
        this.order = order;
    }
    
    public Order getOrder() {
        return order;
    }
}

// Publisher
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    private final OrderRepository orderRepository;
    
    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(request.toOrder());
        
        // Publish event
        eventPublisher.publishEvent(new OrderCreatedEvent(this, order));
        
        return order;
    }
}

// Observers (Listeners)
@Component
public class EmailNotificationListener {
    
    @EventListener
    @Async
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = event.getOrder();
        // Send email notification
        sendEmail(order.getCustomer().getEmail(), "Order confirmed: " + order.getId());
    }
}

@Component
public class InventoryUpdateListener {
    
    @EventListener
    @Transactional
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = event.getOrder();
        // Update inventory
        inventoryService.decreaseStock(order.getItems());
    }
}

@Component
public class AnalyticsListener {
    
    @EventListener
    @Async
    public void handleOrderCreated(OrderCreatedEvent event) {
        Order order = event.getOrder();
        // Track analytics
        analyticsService.trackOrderCreated(order);
    }
}
```

### 4.3. Template Method Pattern

**Definition:** Defines skeleton of algorithm, subclasses override steps.

```java
// Abstract template
public abstract class DataProcessor {
    
    // Template method
    public final ProcessResult process() {
        try {
            List<String> data = readData();
            List<String> validated = validateData(data);
            List<String> transformed = transformData(validated);
            saveData(transformed);
            return ProcessResult.success();
        } catch (Exception e) {
            handleError(e);
            return ProcessResult.failure(e.getMessage());
        }
    }
    
    // Abstract methods - subclasses must implement
    protected abstract List<String> readData();
    protected abstract void saveData(List<String> data);
    
    // Hook methods - subclasses can override
    protected List<String> validateData(List<String> data) {
        return data.stream()
                   .filter(line -> !line.isEmpty())
                   .collect(Collectors.toList());
    }
    
    protected List<String> transformData(List<String> data) {
        return data;  // Default: no transformation
    }
    
    protected void handleError(Exception e) {
        log.error("Processing failed", e);
    }
}

// Concrete implementation
@Component
public class CsvDataProcessor extends DataProcessor {
    
    @Override
    protected List<String> readData() {
        // Read from CSV file
        return Files.readAllLines(Paths.get("data.csv"));
    }
    
    @Override
    protected void saveData(List<String> data) {
        // Save to database
        repository.saveAll(data.stream()
                              .map(this::parseEntity)
                              .collect(Collectors.toList()));
    }
    
    @Override
    protected List<String> transformData(List<String> data) {
        // CSV-specific transformation
        return data.stream()
                   .map(line -> line.toUpperCase())
                   .collect(Collectors.toList());
    }
}

// Spring's JdbcTemplate is template method pattern
@Repository
public class UserRepository {
    private final JdbcTemplate jdbcTemplate;
    
    public List<User> findAll() {
        return jdbcTemplate.query(
            "SELECT * FROM users",
            (rs, rowNum) -> new User(  // Callback method
                rs.getLong("id"),
                rs.getString("name")
            )
        );
    }
}
```

### 4.4. Chain of Responsibility

**Definition:** Passes request along chain of handlers.

```java
// Handler interface
public interface ValidationHandler {
    void setNext(ValidationHandler next);
    void validate(OrderRequest request);
}

// Abstract handler
public abstract class AbstractValidationHandler implements ValidationHandler {
    protected ValidationHandler next;
    
    @Override
    public void setNext(ValidationHandler next) {
        this.next = next;
    }
    
    protected void validateNext(OrderRequest request) {
        if (next != null) {
            next.validate(request);
        }
    }
}

// Concrete handlers
@Component
public class NullCheckHandler extends AbstractValidationHandler {
    @Override
    public void validate(OrderRequest request) {
        if (request == null) {
            throw new ValidationException("Request cannot be null");
        }
        validateNext(request);
    }
}

@Component
public class ProductExistsHandler extends AbstractValidationHandler {
    private final ProductRepository productRepository;
    
    @Override
    public void validate(OrderRequest request) {
        if (!productRepository.existsById(request.getProductId())) {
            throw new ValidationException("Product not found");
        }
        validateNext(request);
    }
}

@Component
public class StockAvailabilityHandler extends AbstractValidationHandler {
    private final InventoryService inventoryService;
    
    @Override
    public void validate(OrderRequest request) {
        if (!inventoryService.isAvailable(request.getProductId(), request.getQuantity())) {
            throw new ValidationException("Insufficient stock");
        }
        validateNext(request);
    }
}

// Chain builder
@Configuration
public class ValidationChainConfig {
    
    @Bean
    public ValidationHandler validationChain(
            NullCheckHandler nullCheck,
            ProductExistsHandler productExists,
            StockAvailabilityHandler stockCheck) {
        
        nullCheck.setNext(productExists);
        productExists.setNext(stockCheck);
        
        return nullCheck;  // Return first handler
    }
}

// Usage
@Service
public class OrderService {
    private final ValidationHandler validationChain;
    
    public Order createOrder(OrderRequest request) {
        validationChain.validate(request);  // Runs through entire chain
        return orderRepository.save(request.toOrder());
    }
}

// Spring Security Filter Chain is chain of responsibility
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(new CustomAuthFilter(), UsernamePasswordAuthenticationFilter.class)
            .build();
    }
}
```

---

## 5. Spring-Specific Patterns

### 5.1. Dependency Injection

```java
// Constructor injection (recommended)
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;
    
    @Autowired
    public OrderService(OrderRepository orderRepository, PaymentService paymentService) {
        this.orderRepository = orderRepository;
        this.paymentService = paymentService;
    }
}

// Field injection (not recommended)
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;  // Hard to test
}
```

### 5.2. Repository Pattern

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByLastName(String lastName);
    
    @Query("SELECT u FROM User u WHERE u.email = ?1")
    Optional<User> findByEmail(String email);
}
```

### 5.3. DTO Pattern

```java
// Entity - internal representation
@Entity
public class User {
    @Id
    private Long id;
    private String password;  // Sensitive!
    private String email;
}

// DTO - external representation
@Data
public class UserDTO {
    private Long id;
    private String email;
    // No password!
}

// Mapper
@Component
public class UserMapper {
    public UserDTO toDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setEmail(user.getEmail());
        return dto;
    }
}
```

---

## 6. Interview Questions

**Q1: What is design pattern?**
**A:** Reusable solution to common design problem.

**Q2: What are pattern categories?**
**A:** Creational, Structural, Behavioral.

**Q3: What is Singleton?**
**A:** Single instance of a class.

**Q4: Are Spring beans singleton?**
**A:** Yes, by default.

**Q5: What is Factory pattern?**
**A:** Creates objects without specifying exact class.

**Q6: What is Builder pattern?**
**A:** Constructs complex objects step by step.

**Q7: What is Adapter pattern?**
**A:** Converts interface to another interface.

**Q8: What is Decorator pattern?**
**A:** Adds behavior dynamically.

**Q9: What is Proxy pattern?**
**A:** Provides placeholder for another object.

**Q10: Is @Transactional a proxy?**
**A:** Yes, Spring creates proxy for transaction management.

**Q11: What is Facade pattern?**
**A:** Simplified interface to complex subsystem.

**Q12: What is Strategy pattern?**
**A:** Family of interchangeable algorithms.

**Q13: What is Observer pattern?**
**A:** Notifies multiple objects about state changes.

**Q14: How does Spring implement Observer?**
**A:** ApplicationEvent and @EventListener.

**Q15: What is Template Method?**
**A:** Skeleton of algorithm, subclasses override steps.

**Q16: Example of Template Method in Spring?**
**A:** JdbcTemplate, RestTemplate.

**Q17: What is Chain of Responsibility?**
**A:** Passes request along chain of handlers.

**Q18: Example in Spring?**
**A:** Filter chain in Spring Security.

**Q19: What is Repository pattern?**
**A:** Abstraction over data access layer.

**Q20: What is DTO pattern?**
**A:** Data Transfer Object for external representation.

---

## 7. Summary

Design patterns provide proven solutions to common problems. Creational patterns: Singleton (single instance, Spring default), Factory (create without specifying class), Builder (step-by-step construction, Lombok @Builder), Prototype (clone existing, @Scope("prototype")). Structural patterns: Adapter (interface conversion), Decorator (add behavior, TaskDecorator), Proxy (placeholder, @Transactional creates proxy), Facade (simplified interface, service layer). Behavioral patterns: Strategy (interchangeable algorithms), Observer (Spring events @EventListener), Template Method (JdbcTemplate), Chain of Responsibility (filter chain). Spring patterns: Dependency Injection (constructor injection preferred), Repository (JpaRepository), DTO (external representation). Use patterns to improve code quality, maintainability, and team communication.

---

**← Previous: Code Quality** | **Next: README →**
