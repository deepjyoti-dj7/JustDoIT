# N+1 Query Problem - Complete Guide

---

## 1. Introduction to N+1 Query Problem

The N+1 query problem is one of the most common performance issues in ORM frameworks like Hibernate.

### What is N+1 Problem?

**N+1 queries** occur when:
1. **1 query** to fetch N parent records
2. **N queries** (one per parent) to fetch related child records

**Total:** 1 + N = N+1 queries instead of just 1 or 2 queries

### Example Scenario

```java
// Fetching 100 orders
List<Order> orders = orderRepository.findAll(); // 1 query

// Accessing items for each order
for (Order order : orders) {
    order.getItems().size(); // 100 additional queries!
}
// Total: 101 queries instead of 1-2 queries
```

---

## 2. Detecting N+1 Problem

### 2.1. Enable SQL Logging

```yaml
# application.yml
spring:
  jpa:
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
```

**Console Output:**
```sql
-- 1st query: Fetch all orders
SELECT * FROM orders;

-- N additional queries: Fetch items for each order
SELECT * FROM order_items WHERE order_id = 1;
SELECT * FROM order_items WHERE order_id = 2;
SELECT * FROM order_items WHERE order_id = 3;
...
SELECT * FROM order_items WHERE order_id = 100;
```

### 2.2. Hibernate Statistics

```yaml
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true
```

```java
@Component
public class HibernateStatisticsLogger {
    
    @Autowired
    private EntityManagerFactory entityManagerFactory;
    
    public void logStatistics() {
        Statistics stats = entityManagerFactory.unwrap(SessionFactory.class)
                                                .getStatistics();
        
        log.info("Query Count: {}", stats.getQueryExecutionCount());
        log.info("Query Time: {}ms", stats.getQueryExecutionMaxTime());
        log.info("Second Level Cache Hits: {}", stats.getSecondLevelCacheHitCount());
    }
}
```

### 2.3. Spring Boot Actuator Metrics

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @GetMapping
    public List<OrderDTO> getOrders() {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        List<OrderDTO> orders = orderService.findAll();
        
        sample.stop(Timer.builder("orders.query.time")
                        .description("Time to fetch orders")
                        .register(meterRegistry));
        
        return orders;
    }
}
```

---

## 3. Solution 1: Fetch Join

### 3.1. JPQL Fetch Join

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // ❌ N+1 Problem
    List<Order> findAll();
    
    // ✅ Solution: Fetch join
    @Query("SELECT DISTINCT o FROM Order o LEFT JOIN FETCH o.items")
    List<Order> findAllWithItems();
    
    // ✅ Multiple joins
    @Query("SELECT DISTINCT o FROM Order o " +
           "LEFT JOIN FETCH o.items i " +
           "LEFT JOIN FETCH o.customer")
    List<Order> findAllWithItemsAndCustomer();
}
```

**Generated SQL:**
```sql
SELECT DISTINCT o.*, i.*, c.*
FROM orders o
LEFT JOIN order_items i ON o.id = i.order_id
LEFT JOIN customers c ON o.customer_id = c.id;
```

### 3.2. Criteria API Fetch Join

```java
@Service
public class OrderService {
    
    @Autowired
    private EntityManager entityManager;
    
    public List<Order> findAllWithItems() {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Order> query = cb.createQuery(Order.class);
        Root<Order> order = query.from(Order.class);
        
        // Fetch join
        order.fetch("items", JoinType.LEFT);
        
        query.select(order).distinct(true);
        
        return entityManager.createQuery(query).getResultList();
    }
}
```

---

## 4. Solution 2: Entity Graph

### 4.1. Named Entity Graph

```java
@Entity
@NamedEntityGraph(
    name = "Order.items",
    attributeNodes = @NamedAttributeNode("items")
)
@NamedEntityGraph(
    name = "Order.full",
    attributeNodes = {
        @NamedAttributeNode("items"),
        @NamedAttributeNode("customer"),
        @NamedAttributeNode(value = "items", subgraph = "items.product")
    },
    subgraphs = {
        @NamedSubgraph(
            name = "items.product",
            attributeNodes = @NamedAttributeNode("product")
        )
    }
)
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    private List<OrderItem> items;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;
}
```

**Usage:**
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @EntityGraph(value = "Order.items")
    List<Order> findAll();
    
    @EntityGraph(value = "Order.full")
    Optional<Order> findById(Long id);
}
```

### 4.2. Ad-hoc Entity Graph

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @EntityGraph(attributePaths = {"items", "customer"})
    List<Order> findAll();
    
    @EntityGraph(attributePaths = {"items", "items.product"})
    Optional<Order> findById(Long id);
}
```

---

## 5. Solution 3: Batch Fetching

### 5.1. @BatchSize Annotation

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    @BatchSize(size = 10)  // Fetch in batches of 10
    private List<OrderItem> items;
}
```

**Generated SQL:**
```sql
-- 1st query: Fetch all orders
SELECT * FROM orders;

-- Batch queries: Fetch items for multiple orders at once
SELECT * FROM order_items WHERE order_id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
SELECT * FROM order_items WHERE order_id IN (11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
...
```

**Result:** 1 + (N / batch_size) queries instead of 1 + N queries

### 5.2. Global Batch Size

```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 10
```

---

## 6. Solution 4: DTO Projection

### 6.1. Constructor Expression

```java
@Data
@AllArgsConstructor
public class OrderDTO {
    private Long id;
    private String customerName;
    private BigDecimal totalAmount;
    private Integer itemCount;
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @Query("SELECT new com.example.dto.OrderDTO(" +
           "o.id, o.customer.name, o.totalAmount, SIZE(o.items)) " +
           "FROM Order o")
    List<OrderDTO> findAllProjected();
}
```

**Generated SQL:**
```sql
SELECT o.id, c.name, o.total_amount, 
       (SELECT COUNT(*) FROM order_items WHERE order_id = o.id)
FROM orders o
JOIN customers c ON o.customer_id = c.id;
```

### 6.2. Interface-based Projection

```java
public interface OrderSummary {
    Long getId();
    String getCustomerName();
    BigDecimal getTotalAmount();
    
    @Value("#{target.items.size()}")
    Integer getItemCount();
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    @Query("SELECT o FROM Order o JOIN o.customer")
    List<OrderSummary> findAllSummaries();
}
```

---

## 7. Solution 5: Subselect Fetch

### 7.1. @Fetch Annotation

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
    @Fetch(FetchMode.SUBSELECT)
    private List<OrderItem> items;
}
```

**Generated SQL:**
```sql
-- 1st query: Fetch all orders
SELECT * FROM orders WHERE ...;

-- 2nd query: Fetch ALL items in one subselect query
SELECT * FROM order_items 
WHERE order_id IN (
    SELECT id FROM orders WHERE ...
);
```

**Result:** Exactly 2 queries regardless of number of orders

---

## 8. Comparison of Solutions

### 8.1. Performance Comparison

| Solution | Queries | Use Case | Pros | Cons |
|----------|---------|----------|------|------|
| **Fetch Join** | 1 | Always need related data | Best performance | Cartesian product, pagination issues |
| **Entity Graph** | 1 | Flexible fetching | Dynamic, clean | Complex for deep graphs |
| **Batch Fetching** | 1 + N/batch_size | Sometimes need related data | Good for lazy loading | Still multiple queries |
| **DTO Projection** | 1 | Read-only views | Fast, minimal data | No entity features |
| **Subselect** | 2 | All parents need children | Predictable | Always 2 queries even if not needed |

### 8.2. When to Use Each

**Fetch Join:**
```java
// When you ALWAYS need the related data
@Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.status = 'ACTIVE'")
List<Order> findActiveOrdersWithItems();
```

**Entity Graph:**
```java
// When you need flexibility
@EntityGraph(attributePaths = {"items", "customer"})
Optional<Order> findById(Long id);
```

**Batch Fetching:**
```java
// When you SOMETIMES access related data
@OneToMany(mappedBy = "order")
@BatchSize(size = 10)
private List<OrderItem> items;
```

**DTO Projection:**
```java
// For read-only list/summary views
@Query("SELECT new OrderDTO(o.id, o.totalAmount) FROM Order o")
List<OrderDTO> findAllSummaries();
```

---

## 9. Common Pitfalls

### 9.1. Multiple Fetch Joins (Cartesian Product)

```java
// ❌ Bad - Cartesian product
@Query("SELECT o FROM Order o " +
       "JOIN FETCH o.items " +
       "JOIN FETCH o.payments")
List<Order> findAllWithItemsAndPayments();
```

**Problem:** If an order has 5 items and 3 payments, result has 15 rows for that order!

**Solution:**
```java
// ✅ Good - Separate queries or entity graph
@Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.items")
List<Order> findAllWithItems();

@Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.payments WHERE o.id IN :ids")
List<Order> findByIdWithPayments(@Param("ids") List<Long> ids);
```

### 9.2. Pagination with Fetch Join

```java
// ⚠️ Warning - Pagination in memory
@Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.items")
Page<Order> findAll(Pageable pageable);
```

**Hibernate Warning:**
```
HHH000104: firstResult/maxResults specified with collection fetch; 
applying in memory!
```

**Solution:**
```java
// ✅ Use two queries
@Query("SELECT o FROM Order o")
Page<Order> findAll(Pageable pageable);

@Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id IN :ids")
List<Order> findByIdWithItems(@Param("ids") List<Long> ids);
```

---

## 10. Real-World Examples

### 10.1. E-commerce Order Processing

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    // ✅ List view - Use DTO projection
    public List<OrderSummaryDTO> getOrderSummaries() {
        return orderRepository.findAllSummaries();
    }
    
    // ✅ Detail view - Use entity graph
    public OrderDetailDTO getOrderDetails(Long id) {
        Order order = orderRepository.findByIdWithFullDetails(id)
                                      .orElseThrow(() -> new NotFoundException("Order not found"));
        return orderMapper.toDetailDTO(order);
    }
    
    // ✅ Report generation - Use fetch join
    @Transactional(readOnly = true)
    public List<Order> getOrdersForReport(LocalDate startDate, LocalDate endDate) {
        return orderRepository.findByDateRangeWithDetails(startDate, endDate);
    }
}
```

### 10.2. Blog with Comments

```java
@Entity
public class Post {
    @Id
    private Long id;
    private String title;
    private String content;
    
    @OneToMany(mappedBy = "post")
    @BatchSize(size = 10)
    private List<Comment> comments;
}

@Service
public class BlogService {
    
    // ✅ Blog feed - Don't load comments
    public List<PostDTO> getFeed() {
        return postRepository.findAll().stream()
                             .map(postMapper::toDTO)
                             .collect(Collectors.toList());
    }
    
    // ✅ Post detail - Load comments with entity graph
    public PostDetailDTO getPostDetail(Long id) {
        Post post = postRepository.findByIdWithComments(id)
                                   .orElseThrow(() -> new NotFoundException("Post not found"));
        return postMapper.toDetailDTO(post);
    }
}
```

---

## 11. Testing for N+1 Problems

### 11.1. Hibernate Assert

```java
@Test
public void testNoNPlus1Problem() {
    // Enable statistics
    Statistics stats = sessionFactory.getStatistics();
    stats.setStatisticsEnabled(true);
    stats.clear();
    
    // Execute query
    List<Order> orders = orderRepository.findAllWithItems();
    orders.forEach(order -> order.getItems().size());
    
    // Assert query count
    long queryCount = stats.getQueryExecutionCount();
    assertThat(queryCount).isLessThanOrEqualTo(2);
}
```

### 11.2. Query Counter

```java
public class QueryCounterListener implements StatementInspector {
    
    private static final ThreadLocal<Integer> queryCount = ThreadLocal.withInitial(() -> 0);
    
    @Override
    public String inspect(String sql) {
        queryCount.set(queryCount.get() + 1);
        return sql;
    }
    
    public static int getQueryCount() {
        return queryCount.get();
    }
    
    public static void reset() {
        queryCount.set(0);
    }
}

@Test
public void testQueryCount() {
    QueryCounterListener.reset();
    
    List<Order> orders = orderRepository.findAllWithItems();
    orders.forEach(order -> order.getItems().size());
    
    int queries = QueryCounterListener.getQueryCount();
    assertThat(queries).isLessThanOrEqualTo(2);
}
```

---

## 12. Interview Questions

**Q1: What is N+1 query problem?**
**A:** 1 query for N parent records + N queries for child records = N+1 total queries.

**Q2: How to detect N+1 problem?**
**A:** Enable SQL logging (spring.jpa.show-sql=true) and count queries.

**Q3: What is fetch join?**
**A:** JPQL join that eagerly fetches related entities in same query.

**Q4: Syntax for fetch join?**
**A:** SELECT o FROM Order o JOIN FETCH o.items

**Q5: What is entity graph?**
**A:** Defines which relationships to fetch for specific query.

**Q6: What is @BatchSize?**
**A:** Fetches related entities in batches instead of one-by-one.

**Q7: What is good batch size?**
**A:** Typically 10-50, depends on use case.

**Q8: What is DTO projection?**
**A:** Selecting only needed fields into DTO instead of full entity.

**Q9: What is FetchMode.SUBSELECT?**
**A:** Fetches all related entities in second query using subselect.

**Q10: Difference between fetch join and entity graph?**
**A:** Fetch join in JPQL, entity graph more flexible and reusable.

**Q11: Can you paginate with fetch join?**
**A:** Warning - Hibernate paginates in memory, not in database.

**Q12: What is cartesian product problem?**
**A:** Multiple fetch joins multiply result rows.

**Q13: How many fetch joins recommended?**
**A:** Maximum 1 collection fetch join per query.

**Q14: What is DISTINCT in fetch join?**
**A:** Removes duplicate parent entities from result.

**Q15: When to use batch fetching?**
**A:** When you sometimes (not always) access related data.

**Q16: When to use fetch join?**
**A:** When you always need related data.

**Q17: When to use DTO projection?**
**A:** For read-only list/summary views.

**Q18: What is Hibernate statistics?**
**A:** Metrics for query count, cache hits, execution time.

**Q19: What is lazy loading?**
**A:** Load related entities only when accessed (default for collections).

**Q20: What is eager loading?**
**A:** Load related entities immediately (default for @ManyToOne).

---

## 13. Summary

N+1 query problem occurs when 1 query fetches N parents and N additional queries fetch children (total N+1 queries). Major performance issue in ORM. Solutions: Fetch Join (JOIN FETCH in JPQL - 1 query, best for always-needed data), Entity Graph (@EntityGraph - flexible, dynamic fetching), Batch Fetching (@BatchSize - reduces to 1 + N/batch_size queries), DTO Projection (select only needed fields), Subselect (@Fetch(SUBSELECT) - exactly 2 queries). Detect with SQL logging and Hibernate statistics. Avoid multiple collection fetch joins (cartesian product). Use pagination carefully with fetch joins (in-memory warning). Choose solution based on use case: list views (DTO), detail views (entity graph), reports (fetch join). Test with query counters. Critical optimization for performance.

---

**Next:** Connection Pool Tuning →
