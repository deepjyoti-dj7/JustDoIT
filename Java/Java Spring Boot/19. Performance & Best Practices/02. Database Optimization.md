# Database Optimization - Complete Guide

---

## 1. Introduction to Database Optimization

Database optimization ensures efficient data access, reduced query times, and better resource utilization.

### Why Database Optimization?

- **Query Performance** - Faster data retrieval
- **Scalability** - Handle more concurrent users
- **Resource Efficiency** - Reduce CPU and memory usage
- **Cost Reduction** - Lower database instance costs
- **User Experience** - Faster page loads

### Key Optimization Areas

1. **Indexing** - Speed up data retrieval
2. **Query Optimization** - Efficient SQL queries
3. **Connection Pooling** - Reuse database connections
4. **Caching** - Reduce database hits
5. **Schema Design** - Proper normalization/denormalization

---

## 2. Database Indexing

### 2.1. Single Column Index

```java
@Entity
@Table(name = "product", indexes = {
    @Index(name = "idx_name", columnList = "name"),
    @Index(name = "idx_category", columnList = "category")
})
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(nullable = false, length = 50)
    private String category;
}
```

### 2.2. Composite Index

```java
@Entity
@Table(name = "product", indexes = {
    @Index(name = "idx_category_price", columnList = "category, price"),
    @Index(name = "idx_category_created", columnList = "category, created_at")
})
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String category;
    private BigDecimal price;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
}
```

**Query benefiting from composite index:**
```java
// Uses idx_category_price
@Query("SELECT p FROM Product p WHERE p.category = :category AND p.price > :minPrice")
List<Product> findByCategoryAndPriceGreaterThan(
    @Param("category") String category,
    @Param("minPrice") BigDecimal minPrice
);
```

### 2.3. Unique Index

```java
@Entity
@Table(name = "user", uniqueConstraints = {
    @UniqueConstraint(name = "uk_email", columnNames = "email"),
    @UniqueConstraint(name = "uk_username", columnNames = "username")
})
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(nullable = false, unique = true, length = 50)
    private String username;
}
```

### 2.4. Index on Foreign Key

```java
@Entity
@Table(name = "order_item", indexes = {
    @Index(name = "idx_order_id", columnList = "order_id"),
    @Index(name = "idx_product_id", columnList = "product_id")
})
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
}
```

---

## 3. Query Optimization

### 3.1. Avoid SELECT *

```java
// ❌ Bad - Selects all columns
@Query("SELECT p FROM Product p WHERE p.category = :category")
List<Product> findByCategory(@Param("category") String category);

// ✅ Good - Select only needed fields
@Query("SELECT new com.example.dto.ProductDTO(p.id, p.name, p.price) " +
       "FROM Product p WHERE p.category = :category")
List<ProductDTO> findByCategoryProjected(@Param("category") String category);
```

### 3.2. Use Exists Instead of Count

```java
// ❌ Bad - Counts all records
public boolean hasProducts(String category) {
    long count = productRepository.countByCategory(category);
    return count > 0;
}

// ✅ Good - Stops at first match
public interface ProductRepository extends JpaRepository<Product, Long> {
    boolean existsByCategory(String category);
}
```

### 3.3. Fetch Joins to Avoid N+1

```java
// ✅ Good - Single query with join
@Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id = :id")
Optional<Order> findByIdWithItems(@Param("id") Long id);

// ✅ Good - Entity graph
@EntityGraph(attributePaths = {"items", "customer"})
Optional<Order> findById(Long id);
```

### 3.4. Batch Fetch

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToMany(mappedBy = "order")
    @BatchSize(size = 10)  // Fetch in batches of 10
    private List<OrderItem> items;
}
```

---

## 4. Connection Pool Optimization

### 4.1. HikariCP Configuration (Default in Spring Boot)

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      # Connection pool settings
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000      # 30 seconds
      idle-timeout: 600000           # 10 minutes
      max-lifetime: 1800000          # 30 minutes
      
      # Performance settings
      auto-commit: false
      leak-detection-threshold: 60000  # 60 seconds
      
      # Connection test query
      connection-test-query: SELECT 1
      validation-timeout: 5000
```

### 4.2. Pool Size Calculation

**Formula:** `connections = ((core_count * 2) + effective_spindle_count)`

For most applications:
- **CPU-intensive:** `pool_size = core_count + 1`
- **I/O-intensive:** `pool_size = core_count * 2`
- **Mixed workload:** `pool_size = 10-20`

### 4.3. Monitoring Connection Pool

```java
@Component
public class HikariMetrics {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 60000)
    public void logPoolMetrics() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikari = (HikariDataSource) dataSource;
            HikariPoolMXBean poolBean = hikari.getHikariPoolMXBean();
            
            log.info("HikariCP Stats - Active: {}, Idle: {}, Total: {}, Waiting: {}",
                     poolBean.getActiveConnections(),
                     poolBean.getIdleConnections(),
                     poolBean.getTotalConnections(),
                     poolBean.getThreadsAwaitingConnection());
        }
    }
}
```

---

## 5. Query Caching

### 5.1. JPA Second-Level Cache

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-jcache</artifactId>
</dependency>
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
</dependency>
```

```yaml
# application.yml
spring:
  jpa:
    properties:
      hibernate:
        cache:
          use_second_level_cache: true
          use_query_cache: true
          region:
            factory_class: org.hibernate.cache.jcache.JCacheRegionFactory
        javax:
          cache:
            provider: org.ehcache.jsr107.EhcacheCachingProvider
```

```java
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private BigDecimal price;
}
```

### 5.2. Query Cache

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))
    @Query("SELECT p FROM Product p WHERE p.category = :category")
    List<Product> findByCategoryCached(@Param("category") String category);
}
```

---

## 6. Read Replicas

### 6.1. Read-Write Splitting

```java
public enum DatabaseType {
    PRIMARY, REPLICA
}

public class DatabaseContextHolder {
    private static final ThreadLocal<DatabaseType> contextHolder = new ThreadLocal<>();
    
    public static void set(DatabaseType databaseType) {
        contextHolder.set(databaseType);
    }
    
    public static DatabaseType get() {
        return contextHolder.get();
    }
    
    public static void clear() {
        contextHolder.remove();
    }
}
```

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.replica")
    public DataSource replicaDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @Primary
    public DataSource routingDataSource() {
        AbstractRoutingDataSource routingDataSource = new AbstractRoutingDataSource() {
            @Override
            protected Object determineCurrentLookupKey() {
                return DatabaseContextHolder.get();
            }
        };
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DatabaseType.PRIMARY, primaryDataSource());
        targetDataSources.put(DatabaseType.REPLICA, replicaDataSource());
        
        routingDataSource.setTargetDataSources(targetDataSources);
        routingDataSource.setDefaultTargetDataSource(primaryDataSource());
        
        return routingDataSource;
    }
}
```

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ReadOnly {
}

@Aspect
@Component
public class DataSourceAspect {
    
    @Before("@annotation(ReadOnly)")
    public void setReadDataSource() {
        DatabaseContextHolder.set(DatabaseType.REPLICA);
    }
    
    @After("@annotation(ReadOnly)")
    public void clearDataSource() {
        DatabaseContextHolder.clear();
    }
}
```

**Usage:**
```java
@Service
public class ProductService {
    
    @Transactional
    public Product create(Product product) {
        // Uses primary database
        return productRepository.save(product);
    }
    
    @ReadOnly
    @Transactional(readOnly = true)
    public Product findById(Long id) {
        // Uses replica database
        return productRepository.findById(id)
                                .orElseThrow(() -> new NotFoundException("Product not found"));
    }
}
```

---

## 7. Database Partitioning

### 7.1. Horizontal Partitioning (Sharding)

```java
@Entity
@Table(name = "order")
public class Order {
    @Id
    private Long id;  // Shard key
    
    private Long customerId;
    private LocalDateTime createdAt;
}
```

**Shard routing:**
```java
public class ShardResolver {
    
    private static final int SHARD_COUNT = 4;
    
    public int getShardId(Long customerId) {
        return Math.abs(customerId.hashCode() % SHARD_COUNT);
    }
}
```

### 7.2. Vertical Partitioning

```java
// Hot data - frequently accessed
@Entity
@Table(name = "product")
public class Product {
    @Id
    private Long id;
    private String name;
    private BigDecimal price;
    private String category;
}

// Cold data - rarely accessed
@Entity
@Table(name = "product_details")
public class ProductDetails {
    @Id
    private Long id;
    
    @OneToOne
    @MapsId
    private Product product;
    
    private String longDescription;
    private String specifications;
    private String reviews;
}
```

---

## 8. Bulk Operations

### 8.1. Batch Insert

```java
@Service
@Transactional
public class ProductService {
    
    @Autowired
    private EntityManager entityManager;
    
    public void batchInsert(List<Product> products) {
        int batchSize = 50;
        
        for (int i = 0; i < products.size(); i++) {
            entityManager.persist(products.get(i));
            
            if (i > 0 && i % batchSize == 0) {
                entityManager.flush();
                entityManager.clear();
            }
        }
        
        entityManager.flush();
        entityManager.clear();
    }
}
```

### 8.2. Batch Update

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Modifying
    @Query("UPDATE Product p SET p.price = p.price * :factor WHERE p.category = :category")
    int updatePriceByCategory(@Param("category") String category, 
                              @Param("factor") BigDecimal factor);
}
```

### 8.3. Batch Delete

```java
@Modifying
@Query("DELETE FROM Product p WHERE p.createdAt < :date")
int deleteOldProducts(@Param("date") LocalDateTime date);
```

---

## 9. Database Indexes Best Practices

### 9.1. When to Create Indexes

✅ **Create indexes for:**
- Primary keys (automatic)
- Foreign keys
- Columns in WHERE clauses
- Columns in JOIN conditions
- Columns in ORDER BY
- Columns in GROUP BY

❌ **Avoid indexes for:**
- Small tables (<1000 rows)
- Columns with low cardinality (few distinct values)
- Frequently updated columns
- Too many indexes on one table

### 9.2. Index Monitoring

```sql
-- PostgreSQL: Find unused indexes
SELECT schemaname, tablename, indexname, idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY schemaname, tablename;

-- MySQL: Show index usage
SELECT TABLE_NAME, INDEX_NAME, CARDINALITY
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'mydb';
```

---

## 10. Explain Plan Analysis

### 10.1. Using EXPLAIN

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query(value = "EXPLAIN ANALYZE SELECT * FROM product WHERE category = :category", 
           nativeQuery = true)
    List<Object[]> explainFindByCategory(@Param("category") String category);
}
```

**Example output:**
```
Seq Scan on product  (cost=0.00..35.50 rows=10 width=100)
  Filter: (category = 'Electronics')
  
Index Scan using idx_category on product  (cost=0.29..8.31 rows=10 width=100)
  Index Cond: (category = 'Electronics')
```

---

## 11. Database Schema Design

### 11.1. Normalization

**Third Normal Form (3NF):**
```java
// Customer table
@Entity
public class Customer {
    @Id
    private Long id;
    private String name;
    private String email;
}

// Order table
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;
    
    private LocalDateTime orderDate;
}

// OrderItem table
@Entity
public class OrderItem {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;
    
    @ManyToOne
    @JoinColumn(name = "product_id")
    private Product product;
    
    private Integer quantity;
    private BigDecimal price;
}
```

### 11.2. Denormalization for Performance

```java
@Entity
public class Order {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;
    
    // Denormalized fields for performance
    private String customerName;  // Copied from Customer
    private String customerEmail; // Copied from Customer
    
    private BigDecimal totalAmount; // Calculated from OrderItems
    private Integer itemCount;      // Count of OrderItems
    
    private LocalDateTime orderDate;
}
```

---

## 12. Interview Questions

**Q1: What is database indexing?**
**A:** Data structure that improves speed of data retrieval operations.

**Q2: What is composite index?**
**A:** Index on multiple columns together.

**Q3: When to use composite index?**
**A:** When queries filter on multiple columns together.

**Q4: What is HikariCP?**
**A:** High-performance JDBC connection pool (default in Spring Boot).

**Q5: What is maximum-pool-size?**
**A:** Maximum number of connections in the pool.

**Q6: What is connection-timeout?**
**A:** Maximum time to wait for connection from pool.

**Q7: What is leak-detection-threshold?**
**A:** Time threshold to detect connection leaks.

**Q8: What is second-level cache?**
**A:** Application-level cache shared across sessions.

**Q9: What is query cache?**
**A:** Caches query results for identical queries.

**Q10: What is read replica?**
**A:** Read-only copy of database for scaling reads.

**Q11: What is sharding?**
**A:** Horizontal partitioning of data across multiple databases.

**Q12: What is vertical partitioning?**
**A:** Splitting table columns into separate tables.

**Q13: What is batch size in Hibernate?**
**A:** Number of statements sent to database in one batch.

**Q14: What is flush()?**
**A:** Synchronizes persistence context with database.

**Q15: What is clear()?**
**A:** Detaches all entities from persistence context.

**Q16: What is EXPLAIN?**
**A:** Shows query execution plan and index usage.

**Q17: What is normalization?**
**A:** Organizing data to reduce redundancy.

**Q18: What is denormalization?**
**A:** Adding redundancy for performance optimization.

**Q19: What is cardinality?**
**A:** Number of distinct values in a column.

**Q20: When to avoid indexes?**
**A:** Small tables, low cardinality columns, frequently updated columns.

---

## 13. Summary

Database optimization is critical for application performance. Key strategies: Indexing (single, composite, unique indexes on foreign keys and WHERE/JOIN columns), Query optimization (avoid SELECT *, use EXISTS, fetch joins, DTO projections), Connection pooling (configure HikariCP: maximum-pool-size, connection-timeout, leak-detection), Caching (second-level cache, query cache with Hibernate), Read replicas (read-write splitting with routing datasource), Bulk operations (batch insert/update/delete with flush/clear), Schema design (normalize for consistency, denormalize for performance). Monitor with EXPLAIN plans, track unused indexes, tune pool sizes based on workload. Essential configuration: batch_size, pool sizes, cache settings. Profile queries before optimizing.

---

**Next:** N+1 Query Problem →
