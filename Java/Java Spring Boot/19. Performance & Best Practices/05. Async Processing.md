# Async Processing - Complete Guide

---

## 1. Introduction to Async Processing

Asynchronous processing allows tasks to run in the background without blocking the main thread, improving application responsiveness and throughput.

### Why Async Processing?

- **Improved Response Time** - Don't wait for slow operations
- **Better Resource Utilization** - CPU can work on other tasks
- **Scalability** - Handle more concurrent requests
- **User Experience** - Faster perceived response times

### Use Cases

- Sending emails
- Processing reports
- Image/video processing
- External API calls
- Background data synchronization
- Logging and analytics

---

## 2. Spring Async Support

### 2.1. Enable Async Processing

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    // Async enabled
}
```

### 2.2. Simple Async Method

```java
@Service
public class EmailService {
    
    @Async
    public void sendEmail(String to, String subject, String body) {
        // This runs in a separate thread
        log.info("Sending email to {} in thread {}", to, Thread.currentThread().getName());
        
        // Simulate email sending
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        log.info("Email sent to {}", to);
    }
}
```

**Usage:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private EmailService emailService;
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);
        
        // Async - doesn't block
        emailService.sendEmail(user.getEmail(), "Welcome", "Welcome to our platform!");
        
        // Returns immediately
        return ResponseEntity.ok(savedUser);
    }
}
```

---

## 3. Async with Return Value

### 3.1. Future

```java
@Service
public class ReportService {
    
    @Async
    public Future<Report> generateReport(String reportType) {
        log.info("Generating report in thread {}", Thread.currentThread().getName());
        
        // Simulate long-running task
        Report report = processReport(reportType);
        
        return new AsyncResult<>(report);
    }
}
```

**Usage:**
```java
@GetMapping("/report")
public ResponseEntity<Report> getReport(@RequestParam String type) throws Exception {
    Future<Report> futureReport = reportService.generateReport(type);
    
    // Wait for result (blocks)
    Report report = futureReport.get();
    
    return ResponseEntity.ok(report);
}
```

### 3.2. CompletableFuture

```java
@Service
public class ProductService {
    
    @Async
    public CompletableFuture<Product> getProductFromExternalAPI(String productId) {
        log.info("Fetching product {} in thread {}", 
                 productId, Thread.currentThread().getName());
        
        Product product = externalAPIClient.getProduct(productId);
        
        return CompletableFuture.completedFuture(product);
    }
}
```

**Usage with multiple async calls:**
```java
@GetMapping("/products/batch")
public ResponseEntity<List<Product>> getProducts(@RequestParam List<String> ids) {
    List<CompletableFuture<Product>> futures = ids.stream()
        .map(productService::getProductFromExternalAPI)
        .collect(Collectors.toList());
    
    // Wait for all to complete
    CompletableFuture<Void> allFutures = CompletableFuture.allOf(
        futures.toArray(new CompletableFuture[0])
    );
    
    allFutures.join();
    
    List<Product> products = futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
    
    return ResponseEntity.ok(products);
}
```

---

## 4. Custom Thread Pool Configuration

### 4.1. Thread Pool Executor

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // Core pool size
        executor.setCorePoolSize(5);
        
        // Maximum pool size
        executor.setMaxPoolSize(10);
        
        // Queue capacity
        executor.setQueueCapacity(100);
        
        // Thread name prefix
        executor.setThreadNamePrefix("async-");
        
        // Rejection policy
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        
        // Wait for tasks to complete on shutdown
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        
        executor.initialize();
        return executor;
    }
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new CustomAsyncExceptionHandler();
    }
}
```

### 4.2. Multiple Thread Pools

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "emailExecutor")
    public Executor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("email-");
        executor.initialize();
        return executor;
    }
    
    @Bean(name = "reportExecutor")
    public Executor reportExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("report-");
        executor.initialize();
        return executor;
    }
}
```

**Usage:**
```java
@Service
public class EmailService {
    
    @Async("emailExecutor")
    public void sendEmail(String to, String subject, String body) {
        // Uses emailExecutor thread pool
    }
}

@Service
public class ReportService {
    
    @Async("reportExecutor")
    public CompletableFuture<Report> generateReport(String type) {
        // Uses reportExecutor thread pool
    }
}
```

---

## 5. Exception Handling

### 5.1. Custom Exception Handler

```java
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {
    
    private static final Logger log = LoggerFactory.getLogger(CustomAsyncExceptionHandler.class);
    
    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        log.error("Async method {} threw exception", method.getName(), ex);
        log.error("Method parameters: {}", Arrays.toString(params));
        
        // Send alert, log to monitoring system, etc.
    }
}
```

### 5.2. Try-Catch in Async Method

```java
@Service
public class NotificationService {
    
    @Async
    public void sendNotification(User user, String message) {
        try {
            // Send notification
            notificationClient.send(user.getPhone(), message);
            log.info("Notification sent to {}", user.getPhone());
            
        } catch (Exception e) {
            log.error("Failed to send notification to {}", user.getPhone(), e);
            
            // Fallback: Save to retry queue
            retryQueueService.add(user.getId(), message);
        }
    }
}
```

---

## 6. Real-World Examples

### 6.1. Email Processing

```java
@Service
public class UserRegistrationService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    @Transactional
    public User registerUser(UserRegistrationDTO dto) {
        // Synchronous - Save user
        User user = new User();
        user.setEmail(dto.getEmail());
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        User savedUser = userRepository.save(user);
        
        // Asynchronous - Send welcome email
        emailService.sendWelcomeEmail(savedUser);
        
        // Asynchronous - Send to analytics
        analyticsService.trackUserRegistration(savedUser);
        
        return savedUser;
    }
}

@Service
public class EmailService {
    
    @Async("emailExecutor")
    public void sendWelcomeEmail(User user) {
        EmailTemplate template = templateService.getWelcomeTemplate();
        String body = template.render(user);
        
        emailClient.send(user.getEmail(), "Welcome!", body);
        log.info("Welcome email sent to {}", user.getEmail());
    }
}
```

### 6.2. Parallel API Calls

```java
@Service
public class ProductAggregationService {
    
    @Async
    public CompletableFuture<Product> getProductDetails(String productId) {
        return CompletableFuture.completedFuture(
            productClient.getProduct(productId)
        );
    }
    
    @Async
    public CompletableFuture<List<Review>> getProductReviews(String productId) {
        return CompletableFuture.completedFuture(
            reviewClient.getReviews(productId)
        );
    }
    
    @Async
    public CompletableFuture<Inventory> getProductInventory(String productId) {
        return CompletableFuture.completedFuture(
            inventoryClient.getInventory(productId)
        );
    }
    
    public ProductDetailDTO getCompleteProductInfo(String productId) {
        CompletableFuture<Product> productFuture = getProductDetails(productId);
        CompletableFuture<List<Review>> reviewsFuture = getProductReviews(productId);
        CompletableFuture<Inventory> inventoryFuture = getProductInventory(productId);
        
        // Wait for all
        CompletableFuture.allOf(productFuture, reviewsFuture, inventoryFuture).join();
        
        // Combine results
        return new ProductDetailDTO(
            productFuture.join(),
            reviewsFuture.join(),
            inventoryFuture.join()
        );
    }
}
```

### 6.3. File Processing

```java
@Service
public class FileProcessingService {
    
    @Async("fileProcessorExecutor")
    public CompletableFuture<FileProcessingResult> processFile(MultipartFile file) {
        log.info("Processing file {} in thread {}", 
                 file.getOriginalFilename(), Thread.currentThread().getName());
        
        try {
            // Save file
            String filePath = fileStorageService.save(file);
            
            // Process file
            List<Record> records = csvParser.parse(filePath);
            
            // Validate records
            ValidationResult validation = validator.validate(records);
            
            // Import to database
            if (validation.isValid()) {
                recordRepository.saveAll(records);
                return CompletableFuture.completedFuture(
                    FileProcessingResult.success(records.size())
                );
            } else {
                return CompletableFuture.completedFuture(
                    FileProcessingResult.failure(validation.getErrors())
                );
            }
            
        } catch (Exception e) {
            log.error("File processing failed", e);
            return CompletableFuture.completedFuture(
                FileProcessingResult.error(e.getMessage())
            );
        }
    }
}
```

---

## 7. Best Practices

### 7.1. Thread Pool Sizing

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // CPU-bound tasks
        int cores = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(cores);
        executor.setMaxPoolSize(cores * 2);
        
        // I/O-bound tasks (network, database)
        // executor.setCorePoolSize(cores * 2);
        // executor.setMaxPoolSize(cores * 4);
        
        // Queue capacity - bounded to prevent memory issues
        executor.setQueueCapacity(100);
        
        // Rejection policy
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        
        executor.initialize();
        return executor;
    }
}
```

### 7.2. Avoid Blocking in Async Methods

```java
// ❌ Bad - Blocks async thread
@Async
public void processData(List<Data> dataList) {
    for (Data data : dataList) {
        Thread.sleep(1000);  // Blocking!
    }
}

// ✅ Good - Non-blocking
@Async
public CompletableFuture<Void> processData(List<Data> dataList) {
    return CompletableFuture.runAsync(() -> {
        dataList.forEach(this::process);
    });
}
```

### 7.3. Transaction Management

```java
@Service
public class OrderService {
    
    // ❌ Bad - @Async and @Transactional on same method
    @Async
    @Transactional
    public void processOrder(Order order) {
        // Transaction may not work as expected
        orderRepository.save(order);
    }
    
    // ✅ Good - Separate transaction method
    @Async
    public void processOrderAsync(Order order) {
        orderProcessingService.processInTransaction(order);
    }
}

@Service
public class OrderProcessingService {
    
    @Transactional
    public void processInTransaction(Order order) {
        orderRepository.save(order);
        // Transaction managed properly
    }
}
```

---

## 8. Monitoring Async Tasks

### 8.1. Thread Pool Metrics

```java
@Component
public class ThreadPoolMonitor {
    
    @Autowired
    @Qualifier("taskExecutor")
    private Executor executor;
    
    @Scheduled(fixedRate = 60000)
    public void logThreadPoolMetrics() {
        if (executor instanceof ThreadPoolTaskExecutor) {
            ThreadPoolTaskExecutor taskExecutor = (ThreadPoolTaskExecutor) executor;
            ThreadPoolExecutor threadPool = taskExecutor.getThreadPoolExecutor();
            
            log.info("Thread Pool Stats:");
            log.info("  Active Threads: {}", threadPool.getActiveCount());
            log.info("  Pool Size: {}", threadPool.getPoolSize());
            log.info("  Queue Size: {}", threadPool.getQueue().size());
            log.info("  Completed Tasks: {}", threadPool.getCompletedTaskCount());
            log.info("  Total Tasks: {}", threadPool.getTaskCount());
        }
    }
}
```

### 8.2. Micrometer Metrics

```java
@Configuration
public class AsyncMetricsConfig {
    
    @Bean
    public MeterBinder threadPoolMetrics(@Qualifier("taskExecutor") Executor executor) {
        if (executor instanceof ThreadPoolTaskExecutor) {
            ThreadPoolTaskExecutor taskExecutor = (ThreadPoolTaskExecutor) executor;
            return new ExecutorServiceMetrics(
                taskExecutor.getThreadPoolExecutor(),
                "async_executor",
                Collections.emptyList()
            );
        }
        return registry -> {};
    }
}
```

---

## 9. Interview Questions

**Q1: What is async processing?**
**A:** Executing tasks in background threads without blocking main thread.

**Q2: How to enable async in Spring Boot?**
**A:** Add @EnableAsync on configuration class.

**Q3: What is @Async annotation?**
**A:** Marks method to run asynchronously in separate thread.

**Q4: Can @Async return value?**
**A:** Yes, using Future or CompletableFuture.

**Q5: What is Future?**
**A:** Represents result of asynchronous computation.

**Q6: What is CompletableFuture?**
**A:** Enhanced Future with better API for composition and chaining.

**Q7: How to configure thread pool for @Async?**
**A:** Implement AsyncConfigurer or create Executor bean.

**Q8: What is corePoolSize?**
**A:** Minimum number of threads to keep in pool.

**Q9: What is maxPoolSize?**
**A:** Maximum number of threads allowed in pool.

**Q10: What is queueCapacity?**
**A:** Size of queue for tasks waiting for thread.

**Q11: What happens when queue is full?**
**A:** Rejection policy is applied (CallerRunsPolicy, AbortPolicy, etc.).

**Q12: What is CallerRunsPolicy?**
**A:** Executes task in calling thread when pool is full.

**Q13: Can you use @Async with @Transactional?**
**A:** Not recommended - transaction may not work as expected. Separate methods.

**Q14: How to handle exceptions in @Async?**
**A:** Implement AsyncUncaughtExceptionHandler or use try-catch.

**Q15: What is AsyncConfigurer?**
**A:** Interface to customize async executor and exception handler.

**Q16: How to wait for multiple async tasks?**
**A:** CompletableFuture.allOf() or Future.get() in loop.

**Q17: What is thread pool sizing for CPU-bound tasks?**
**A:** core_count to core_count * 2

**Q18: What is thread pool sizing for I/O-bound tasks?**
**A:** core_count * 2 to core_count * 4

**Q19: What is @Async("executorName")?**
**A:** Specifies which executor bean to use for async execution.

**Q20: Can @Async method call another @Async method?**
**A:** Yes, but each runs in separate thread from pool.

---

## 10. Summary

Async processing improves responsiveness by running tasks in background threads. Enable with @EnableAsync, mark methods with @Async. Return types: void (fire-and-forget), Future, CompletableFuture (for results). Configure custom thread pool with ThreadPoolTaskExecutor: corePoolSize, maxPoolSize, queueCapacity, rejection policy. Use multiple thread pools for different task types (@Async("executorName")). Handle exceptions with AsyncUncaughtExceptionHandler. Thread pool sizing: CPU-bound (core_count), I/O-bound (core_count * 2-4). Avoid @Transactional on @Async methods - separate transaction logic. Monitor with metrics: active threads, queue size, completed tasks. Use cases: email sending, report generation, parallel API calls, file processing. Critical for scalable applications.

---

**Next:** Thread Pool Configuration →
