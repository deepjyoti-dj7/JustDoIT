# Thread Pool Configuration - Complete Guide

---

## 1. Introduction to Thread Pools

Thread pools manage a pool of worker threads to execute tasks efficiently, avoiding the overhead of creating and destroying threads.

### Why Thread Pools?

- **Performance** - Reuse threads instead of creating new ones
- **Resource Control** - Limit concurrent thread count
- **Task Management** - Queue and prioritize tasks
- **Stability** - Prevent thread exhaustion

### Thread Creation Cost

Creating thread: ~1ms  
Reusing from pool: ~0.01ms  
**100x faster!**

---

## 2. Java Thread Pool Basics

### 2.1. ExecutorService

```java
// Fixed thread pool
ExecutorService executor = Executors.newFixedThreadPool(10);

// Cached thread pool
ExecutorService executor = Executors.newCachedThreadPool();

// Single thread executor
ExecutorService executor = Executors.newSingleThreadExecutor();

// Scheduled thread pool
ScheduledExecutorService executor = Executors.newScheduledThreadPool(5);
```

### 2.2. ThreadPoolExecutor

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                      // corePoolSize
    10,                     // maximumPoolSize
    60L,                    // keepAliveTime
    TimeUnit.SECONDS,       // unit
    new LinkedBlockingQueue<>(100),  // workQueue
    new ThreadPoolExecutor.CallerRunsPolicy()  // rejectionHandler
);
```

---

## 3. Spring ThreadPoolTaskExecutor

### 3.1. Basic Configuration

```java
@Configuration
public class ThreadPoolConfig {
    
    @Bean(name = "taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // Core pool size - minimum threads
        executor.setCorePoolSize(5);
        
        // Maximum pool size
        executor.setMaxPoolSize(10);
        
        // Queue capacity
        executor.setQueueCapacity(100);
        
        // Thread name prefix
        executor.setThreadNamePrefix("task-exec-");
        
        // Keep alive time for idle threads
        executor.setKeepAliveSeconds(60);
        
        // Allow core threads to timeout
        executor.setAllowCoreThreadTimeOut(false);
        
        executor.initialize();
        return executor;
    }
}
```

### 3.2. Complete Configuration

```java
@Configuration
public class AdvancedThreadPoolConfig {
    
    @Bean(name = "advancedExecutor")
    public ThreadPoolTaskExecutor advancedExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        // Pool sizing
        int cores = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(cores);
        executor.setMaxPoolSize(cores * 2);
        executor.setQueueCapacity(200);
        
        // Thread configuration
        executor.setThreadNamePrefix("advanced-");
        executor.setThreadPriority(Thread.NORM_PRIORITY);
        executor.setDaemon(false);
        
        // Timeout configuration
        executor.setKeepAliveSeconds(120);
        executor.setAllowCoreThreadTimeOut(true);
        
        // Rejection policy
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        
        // Shutdown configuration
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        
        // Task decorator
        executor.setTaskDecorator(new ContextCopyingDecorator());
        
        executor.initialize();
        return executor;
    }
    
    private static class ContextCopyingDecorator implements TaskDecorator {
        @Override
        public Runnable decorate(Runnable runnable) {
            // Copy security context, request context, etc.
            SecurityContext context = SecurityContextHolder.getContext();
            return () -> {
                try {
                    SecurityContextHolder.setContext(context);
                    runnable.run();
                } finally {
                    SecurityContextHolder.clearContext();
                }
            };
        }
    }
}
```

---

## 4. Thread Pool Sizing

### 4.1. CPU-Bound Tasks

**Formula:** `pool_size = core_count + 1`

```java
@Bean(name = "cpuBoundExecutor")
public ThreadPoolTaskExecutor cpuBoundExecutor() {
    int cores = Runtime.getRuntime().availableProcessors();
    
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(cores);
    executor.setMaxPoolSize(cores + 1);
    executor.setQueueCapacity(50);
    executor.setThreadNamePrefix("cpu-");
    executor.initialize();
    
    return executor;
}
```

### 4.2. I/O-Bound Tasks

**Formula:** `pool_size = core_count * (1 + wait_time / compute_time)`

Typically: `core_count * 2` to `core_count * 4`

```java
@Bean(name = "ioBoundExecutor")
public ThreadPoolTaskExecutor ioBoundExecutor() {
    int cores = Runtime.getRuntime().availableProcessors();
    
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(cores * 2);
    executor.setMaxPoolSize(cores * 4);
    executor.setQueueCapacity(200);
    executor.setThreadNamePrefix("io-");
    executor.initialize();
    
    return executor;
}
```

### 4.3. Mixed Workload

```java
@Bean(name = "mixedExecutor")
public ThreadPoolTaskExecutor mixedExecutor() {
    int cores = Runtime.getRuntime().availableProcessors();
    
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(cores);
    executor.setMaxPoolSize(cores * 2);
    executor.setQueueCapacity(100);
    executor.setThreadNamePrefix("mixed-");
    executor.initialize();
    
    return executor;
}
```

---

## 5. Rejection Policies

### 5.1. AbortPolicy (Default)

```java
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
```

**Behavior:** Throws `RejectedExecutionException`

**Use when:** Failing fast is acceptable

### 5.2. CallerRunsPolicy

```java
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
```

**Behavior:** Executes task in calling thread

**Use when:** All tasks must be executed, can afford to slow down submission

### 5.3. DiscardPolicy

```java
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
```

**Behavior:** Silently discards task

**Use when:** Some task loss is acceptable (e.g., metrics, logging)

### 5.4. DiscardOldestPolicy

```java
executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());
```

**Behavior:** Discards oldest queued task, retries submission

**Use when:** Newer tasks are more important

### 5.5. Custom Rejection Policy

```java
public class CustomRejectionHandler implements RejectedExecutionHandler {
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        log.error("Task rejected: {}", r.toString());
        
        // Send alert
        alertService.send("Thread pool full!");
        
        // Save to retry queue
        retryQueue.add(r);
        
        // Or throw exception
        throw new RejectedExecutionException("Task " + r.toString() + " rejected");
    }
}

executor.setRejectedExecutionHandler(new CustomRejectionHandler());
```

---

## 6. Queue Types

### 6.1. LinkedBlockingQueue (Unbounded)

```java
new LinkedBlockingQueue<>()  // No capacity limit
```

**Pros:** Never rejects tasks  
**Cons:** Can cause memory issues

### 6.2. LinkedBlockingQueue (Bounded)

```java
new LinkedBlockingQueue<>(100)  // Maximum 100 tasks
```

**Pros:** Memory safe  
**Cons:** Tasks can be rejected

### 6.3. ArrayBlockingQueue

```java
new ArrayBlockingQueue<>(100)
```

**Pros:** Fixed size, FIFO  
**Cons:** Less flexible than LinkedBlockingQueue

### 6.4. SynchronousQueue

```java
new SynchronousQueue<>()
```

**Pros:** Direct hand-off, no queuing  
**Cons:** Requires available thread or rejects

### 6.5. PriorityBlockingQueue

```java
new PriorityBlockingQueue<>(100, new TaskPriorityComparator())
```

**Pros:** Tasks executed by priority  
**Cons:** Overhead of sorting

---

## 7. Scheduled Thread Pools

### 7.1. Basic Scheduling

```java
@Configuration
@EnableScheduling
public class SchedulingConfig {
    
    @Bean
    public TaskScheduler taskScheduler() {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.setPoolSize(5);
        scheduler.setThreadNamePrefix("scheduled-");
        scheduler.setWaitForTasksToCompleteOnShutdown(true);
        scheduler.setAwaitTerminationSeconds(30);
        scheduler.initialize();
        return scheduler;
    }
}
```

### 7.2. Scheduled Tasks

```java
@Service
public class ScheduledService {
    
    @Scheduled(fixedRate = 60000)  // Every 60 seconds
    public void reportGeneration() {
        log.info("Generating report at {}", LocalDateTime.now());
    }
    
    @Scheduled(fixedDelay = 30000, initialDelay = 10000)
    public void dataSync() {
        log.info("Syncing data");
    }
    
    @Scheduled(cron = "0 0 2 * * ?")  // Every day at 2 AM
    public void dailyCleanup() {
        log.info("Running daily cleanup");
    }
}
```

---

## 8. Monitoring Thread Pools

### 8.1. Thread Pool Metrics

```java
@Component
public class ThreadPoolMonitor {
    
    @Autowired
    @Qualifier("taskExecutor")
    private ThreadPoolTaskExecutor taskExecutor;
    
    @Scheduled(fixedRate = 60000)
    public void monitorThreadPool() {
        ThreadPoolExecutor executor = taskExecutor.getThreadPoolExecutor();
        
        int activeCount = executor.getActiveCount();
        int poolSize = executor.getPoolSize();
        int corePoolSize = executor.getCorePoolSize();
        int maxPoolSize = executor.getMaximumPoolSize();
        long completedTasks = executor.getCompletedTaskCount();
        long totalTasks = executor.getTaskCount();
        int queueSize = executor.getQueue().size();
        
        log.info("Thread Pool Stats:");
        log.info("  Active: {}/{}", activeCount, poolSize);
        log.info("  Pool Size: {} (core: {}, max: {})", poolSize, corePoolSize, maxPoolSize);
        log.info("  Queue: {} tasks", queueSize);
        log.info("  Completed: {}/{}", completedTasks, totalTasks);
        
        // Alert if pool is saturated
        if (activeCount == maxPoolSize && queueSize > 0) {
            log.warn("Thread pool is saturated!");
        }
    }
}
```

### 8.2. Micrometer Integration

```java
@Configuration
public class ThreadPoolMetricsConfig {
    
    @Bean
    public MeterBinder threadPoolMetrics(@Qualifier("taskExecutor") ThreadPoolTaskExecutor executor) {
        return new ExecutorServiceMetrics(
            executor.getThreadPoolExecutor(),
            "task_executor",
            Tags.of("type", "async")
        );
    }
}
```

**Available metrics:**
- `executor.active` - Active threads
- `executor.pool.size` - Current pool size
- `executor.pool.core` - Core pool size
- `executor.pool.max` - Maximum pool size
- `executor.queued` - Queued tasks
- `executor.queue.remaining` - Queue capacity remaining
- `executor.completed` - Completed tasks

---

## 9. Best Practices

### 9.1. Proper Shutdown

```java
@Configuration
public class ThreadPoolConfig {
    
    @Bean(name = "taskExecutor", destroyMethod = "shutdown")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        
        // Graceful shutdown
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        
        executor.initialize();
        return executor;
    }
}
```

### 9.2. Named Thread Pools

```java
// ❌ Bad - Generic name
executor.setThreadNamePrefix("thread-");

// ✅ Good - Descriptive name
executor.setThreadNamePrefix("email-processor-");
executor.setThreadNamePrefix("report-generator-");
executor.setThreadNamePrefix("image-converter-");
```

### 9.3. Bounded Queues

```java
// ❌ Bad - Unbounded queue
executor.setQueueCapacity(Integer.MAX_VALUE);

// ✅ Good - Bounded queue
executor.setQueueCapacity(100);
```

### 9.4. Separate Pools for Different Tasks

```java
@Configuration
public class MultipleThreadPoolsConfig {
    
    @Bean(name = "fastTaskExecutor")
    public ThreadPoolTaskExecutor fastTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setThreadNamePrefix("fast-");
        executor.initialize();
        return executor;
    }
    
    @Bean(name = "slowTaskExecutor")
    public ThreadPoolTaskExecutor slowTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("slow-");
        executor.initialize();
        return executor;
    }
}
```

---

## 10. Common Pitfalls

### 10.1. Pool Too Large

```java
// ❌ Bad - Too many threads
executor.setCorePoolSize(1000);
executor.setMaxPoolSize(2000);
```

**Problems:**
- High memory usage
- Excessive context switching
- CPU thrashing

### 10.2. Unbounded Queue

```java
// ❌ Bad - Can cause OOM
executor.setQueueCapacity(Integer.MAX_VALUE);
```

### 10.3. No Rejection Policy

```java
// ❌ Bad - Default abort policy may surprise you
// No explicit rejection handler set
```

### 10.4. Ignoring Shutdown

```java
// ❌ Bad - Abrupt shutdown
executor.shutdown();

// ✅ Good - Graceful shutdown
executor.setWaitForTasksToCompleteOnShutdown(true);
executor.setAwaitTerminationSeconds(60);
```

---

## 11. Interview Questions

**Q1: What is thread pool?**
**A:** Pool of reusable worker threads to execute tasks.

**Q2: Why use thread pools?**
**A:** Avoid overhead of creating/destroying threads, control resources.

**Q3: What is corePoolSize?**
**A:** Minimum number of threads kept alive.

**Q4: What is maximumPoolSize?**
**A:** Maximum number of threads allowed.

**Q5: What is queueCapacity?**
**A:** Maximum number of tasks waiting in queue.

**Q6: What happens when queue is full?**
**A:** Rejection policy is applied.

**Q7: What is CallerRunsPolicy?**
**A:** Executes rejected task in calling thread.

**Q8: What is AbortPolicy?**
**A:** Throws RejectedExecutionException (default).

**Q9: What is DiscardPolicy?**
**A:** Silently discards rejected task.

**Q10: Pool size for CPU-bound tasks?**
**A:** core_count + 1

**Q11: Pool size for I/O-bound tasks?**
**A:** core_count * 2 to core_count * 4

**Q12: What is keepAliveTime?**
**A:** How long idle threads wait before terminating.

**Q13: What is ThreadPoolTaskExecutor?**
**A:** Spring's implementation of thread pool with additional features.

**Q14: What is TaskDecorator?**
**A:** Wraps tasks to copy context (security, MDC, etc.).

**Q15: What is LinkedBlockingQueue?**
**A:** Blocking queue implementation, can be bounded or unbounded.

**Q16: What is SynchronousQueue?**
**A:** Queue with no storage, direct hand-off to thread.

**Q17: How to monitor thread pool?**
**A:** ThreadPoolExecutor metrics: active count, pool size, queue size.

**Q18: What is graceful shutdown?**
**A:** Wait for running tasks to complete before shutting down.

**Q19: What is TaskScheduler?**
**A:** Scheduled thread pool for recurring tasks.

**Q20: When to use multiple thread pools?**
**A:** Different task types with different characteristics (fast vs slow, CPU vs I/O).

---

## 12. Summary

Thread pools manage reusable worker threads for efficient task execution. Spring's ThreadPoolTaskExecutor configuration: corePoolSize (minimum threads), maxPoolSize (maximum threads), queueCapacity (task queue size). Sizing: CPU-bound (core_count + 1), I/O-bound (core_count * 2-4). Rejection policies: AbortPolicy (throws exception), CallerRunsPolicy (runs in caller), DiscardPolicy (drops task), DiscardOldestPolicy (drops oldest). Queue types: LinkedBlockingQueue (bounded/unbounded), SynchronousQueue (no storage), PriorityBlockingQueue (priority-based). Use TaskDecorator for context propagation. Monitor: active threads, pool size, queue size. Best practices: bounded queues, named threads, separate pools for different tasks, graceful shutdown. Essential for scalable async processing.

---

**Next:** Memory Management →
