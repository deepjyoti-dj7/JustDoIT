# Code Quality - Complete Guide

---

## 1. Introduction to Code Quality

Code quality determines maintainability, readability, and long-term success of software projects.

### Why Code Quality Matters?

- **Maintainability** - Easy to update and fix
- **Readability** - Team members understand quickly
- **Reliability** - Fewer bugs in production
- **Performance** - Optimized and efficient
- **Collaboration** - Easier for teams to work together

---

## 2. SOLID Principles

### 2.1. Single Responsibility Principle (SRP)

**Definition:** A class should have only one reason to change.

```java
// ❌ Bad - Multiple responsibilities
@Service
public class UserService {
    public void createUser(User user) { }
    public void sendEmail(User user) { }
    public void generateReport(User user) { }
    public void validateUser(User user) { }
}

// ✅ Good - Single responsibility
@Service
public class UserService {
    public User createUser(UserDTO dto) {
        return userRepository.save(userMapper.toEntity(dto));
    }
}

@Service
public class EmailService {
    public void sendWelcomeEmail(User user) {
        emailClient.send(user.getEmail(), "Welcome", template.render(user));
    }
}

@Service
public class ReportService {
    public Report generateUserReport(User user) {
        return reportGenerator.generate(user);
    }
}
```

### 2.2. Open/Closed Principle (OCP)

**Definition:** Open for extension, closed for modification.

```java
// ❌ Bad - Need to modify for new types
public class PaymentProcessor {
    public void process(Payment payment) {
        if (payment.getType().equals("CREDIT_CARD")) {
            processCreditCard(payment);
        } else if (payment.getType().equals("PAYPAL")) {
            processPayPal(payment);
        }
        // Need to add more if-else for new types!
    }
}

// ✅ Good - Strategy pattern
public interface PaymentStrategy {
    void process(Payment payment);
}

@Component
public class CreditCardStrategy implements PaymentStrategy {
    @Override
    public void process(Payment payment) {
        // Credit card processing
    }
}

@Component
public class PayPalStrategy implements PaymentStrategy {
    @Override
    public void process(Payment payment) {
        // PayPal processing
    }
}

@Service
public class PaymentProcessor {
    private final Map<String, PaymentStrategy> strategies;
    
    @Autowired
    public PaymentProcessor(List<PaymentStrategy> strategyList) {
        this.strategies = strategyList.stream()
            .collect(Collectors.toMap(
                s -> s.getClass().getSimpleName().replace("Strategy", "").toUpperCase(),
                s -> s
            ));
    }
    
    public void process(Payment payment) {
        PaymentStrategy strategy = strategies.get(payment.getType());
        strategy.process(payment);
    }
}
```

### 2.3. Liskov Substitution Principle (LSP)

**Definition:** Subtypes must be substitutable for their base types.

```java
// ❌ Bad - Violates LSP
public class Bird {
    public void fly() {
        // Flying logic
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

// ✅ Good - Proper abstraction
public abstract class Bird {
    public abstract void move();
}

public class Sparrow extends Bird {
    @Override
    public void move() {
        fly();
    }
    
    private void fly() {
        // Flying logic
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        swim();
    }
    
    private void swim() {
        // Swimming logic
    }
}
```

### 2.4. Interface Segregation Principle (ISP)

**Definition:** Clients shouldn't depend on interfaces they don't use.

```java
// ❌ Bad - Fat interface
public interface Worker {
    void work();
    void eat();
    void sleep();
}

public class Robot implements Worker {
    @Override
    public void work() {
        // Work logic
    }
    
    @Override
    public void eat() {
        throw new UnsupportedOperationException();  // Robots don't eat!
    }
    
    @Override
    public void sleep() {
        throw new UnsupportedOperationException();  // Robots don't sleep!
    }
}

// ✅ Good - Segregated interfaces
public interface Workable {
    void work();
}

public interface Eatable {
    void eat();
}

public interface Sleepable {
    void sleep();
}

public class Human implements Workable, Eatable, Sleepable {
    @Override
    public void work() { }
    
    @Override
    public void eat() { }
    
    @Override
    public void sleep() { }
}

public class Robot implements Workable {
    @Override
    public void work() { }
}
```

### 2.5. Dependency Inversion Principle (DIP)

**Definition:** Depend on abstractions, not concretions.

```java
// ❌ Bad - Depends on concrete implementation
@Service
public class OrderService {
    private final MySQLOrderRepository repository = new MySQLOrderRepository();
    
    public void save(Order order) {
        repository.save(order);
    }
}

// ✅ Good - Depends on abstraction
public interface OrderRepository {
    Order save(Order order);
    Optional<Order> findById(Long id);
}

@Service
public class OrderService {
    private final OrderRepository repository;
    
    @Autowired
    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }
    
    public void save(Order order) {
        repository.save(order);
    }
}
```

---

## 3. Clean Code Practices

### 3.1. Meaningful Names

```java
// ❌ Bad - Unclear names
int d;  // elapsed time in days
List<User> list1;
User getData();

// ✅ Good - Descriptive names
int elapsedTimeInDays;
List<User> activeUsers;
User getActiveUserById(Long id);
```

### 3.2. Small Functions

```java
// ❌ Bad - Long function
public void processOrder(Order order) {
    // Validate order (20 lines)
    // Calculate total (15 lines)
    // Apply discount (25 lines)
    // Process payment (30 lines)
    // Update inventory (20 lines)
    // Send notifications (15 lines)
}

// ✅ Good - Small, focused functions
@Transactional
public void processOrder(Order order) {
    validateOrder(order);
    BigDecimal total = calculateTotal(order);
    BigDecimal finalAmount = applyDiscount(total, order.getCustomer());
    processPayment(order, finalAmount);
    updateInventory(order);
    sendNotifications(order);
}

private void validateOrder(Order order) {
    // Validation logic
}

private BigDecimal calculateTotal(Order order) {
    return order.getItems().stream()
               .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
               .reduce(BigDecimal.ZERO, BigDecimal::add);
}
```

### 3.3. Comments

```java
// ❌ Bad - Redundant comments
// Get user by ID
public User getUserById(Long id) {
    return userRepository.findById(id).orElseThrow();
}

// ✅ Good - Code is self-explanatory
public User findActiveUserById(Long id) {
    return userRepository.findById(id)
                         .filter(User::isActive)
                         .orElseThrow(() -> new UserNotFoundException(id));
}

// ✅ Good - Comments explain WHY
public BigDecimal calculateDiscount(BigDecimal amount, Customer customer) {
    // Apply 10% discount for premium customers to match competitor pricing
    if (customer.isPremium()) {
        return amount.multiply(new BigDecimal("0.10"));
    }
    return BigDecimal.ZERO;
}
```

### 3.4. Error Handling

```java
// ❌ Bad - Generic exceptions
public User getUser(Long id) throws Exception {
    return userRepository.findById(id).orElseThrow(() -> new Exception("Not found"));
}

// ✅ Good - Specific exceptions
public User getUser(Long id) {
    return userRepository.findById(id)
                         .orElseThrow(() -> new UserNotFoundException("User not found with id: " + id));
}

@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
```

---

## 4. Code Organization

### 4.1. Package Structure

```
com.example.product
├── controller
│   ├── ProductController.java
│   └── CategoryController.java
├── service
│   ├── ProductService.java
│   └── CategoryService.java
├── repository
│   ├── ProductRepository.java
│   └── CategoryRepository.java
├── model
│   ├── entity
│   │   ├── Product.java
│   │   └── Category.java
│   └── dto
│       ├── ProductDTO.java
│       └── CategoryDTO.java
├── mapper
│   ├── ProductMapper.java
│   └── CategoryMapper.java
├── exception
│   ├── ProductNotFoundException.java
│   └── InvalidProductException.java
└── config
    └── ProductConfig.java
```

### 4.2. Layer Separation

```java
// Controller layer - HTTP concerns
@RestController
@RequestMapping("/api/products")
public class ProductController {
    private final ProductService productService;
    
    @GetMapping("/{id}")
    public ResponseEntity<ProductDTO> getProduct(@PathVariable Long id) {
        ProductDTO product = productService.findById(id);
        return ResponseEntity.ok(product);
    }
}

// Service layer - Business logic
@Service
public class ProductService {
    private final ProductRepository productRepository;
    private final ProductMapper productMapper;
    
    public ProductDTO findById(Long id) {
        Product product = productRepository.findById(id)
                                           .orElseThrow(() -> new ProductNotFoundException(id));
        return productMapper.toDTO(product);
    }
}

// Repository layer - Data access
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    List<Product> findByCategory(String category);
}
```

---

## 5. Testing

### 5.1. Unit Tests

```java
@ExtendWith(MockitoExtension.class)
class ProductServiceTest {
    
    @Mock
    private ProductRepository productRepository;
    
    @Mock
    private ProductMapper productMapper;
    
    @InjectMocks
    private ProductService productService;
    
    @Test
    void findById_WhenProductExists_ShouldReturnProduct() {
        // Given
        Long productId = 1L;
        Product product = new Product();
        product.setId(productId);
        ProductDTO expectedDTO = new ProductDTO();
        
        when(productRepository.findById(productId)).thenReturn(Optional.of(product));
        when(productMapper.toDTO(product)).thenReturn(expectedDTO);
        
        // When
        ProductDTO result = productService.findById(productId);
        
        // Then
        assertThat(result).isEqualTo(expectedDTO);
        verify(productRepository).findById(productId);
        verify(productMapper).toDTO(product);
    }
    
    @Test
    void findById_WhenProductNotFound_ShouldThrowException() {
        // Given
        Long productId = 999L;
        when(productRepository.findById(productId)).thenReturn(Optional.empty());
        
        // When & Then
        assertThrows(ProductNotFoundException.class, () -> productService.findById(productId));
    }
}
```

### 5.2. Integration Tests

```java
@SpringBootTest
@AutoConfigureMockMvc
class ProductControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ProductRepository productRepository;
    
    @Test
    void getProduct_ShouldReturnProduct() throws Exception {
        // Given
        Product product = new Product();
        product.setName("Test Product");
        product.setPrice(new BigDecimal("99.99"));
        Product saved = productRepository.save(product);
        
        // When & Then
        mockMvc.perform(get("/api/products/{id}", saved.getId()))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.name").value("Test Product"))
               .andExpect(jsonPath("$.price").value(99.99));
    }
}
```

---

## 6. Code Review Checklist

### 6.1. Functionality
- [ ] Code works as expected
- [ ] Edge cases handled
- [ ] Error handling implemented
- [ ] Validation in place

### 6.2. Design
- [ ] SOLID principles followed
- [ ] Proper layer separation
- [ ] No code duplication
- [ ] Appropriate design patterns used

### 6.3. Performance
- [ ] No N+1 queries
- [ ] Proper indexing
- [ ] Pagination implemented
- [ ] Caching where appropriate

### 6.4. Security
- [ ] Input validation
- [ ] SQL injection prevented
- [ ] Authentication/authorization
- [ ] Sensitive data protected

### 6.5. Testing
- [ ] Unit tests written
- [ ] Integration tests added
- [ ] Edge cases tested
- [ ] Coverage > 80%

### 6.6. Code Quality
- [ ] Meaningful names
- [ ] Small, focused functions
- [ ] No magic numbers
- [ ] Proper comments

---

## 7. Static Code Analysis

### 7.1. SonarQube

```xml
<!-- pom.xml -->
<properties>
    <sonar.organization>myorg</sonar.organization>
    <sonar.host.url>https://sonarcloud.io</sonar.host.url>
</properties>

<plugin>
    <groupId>org.sonarsource.scanner.maven</groupId>
    <artifactId>sonar-maven-plugin</artifactId>
    <version>3.9.1.2184</version>
</plugin>
```

```bash
mvn clean verify sonar:sonar
```

### 7.2. Checkstyle

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>3.2.0</version>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
    </configuration>
</plugin>
```

### 7.3. SpotBugs

```xml
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.0</version>
</plugin>
```

---

## 8. Interview Questions

**Q1: What is SOLID?**
**A:** Five principles: SRP, OCP, LSP, ISP, DIP.

**Q2: What is SRP?**
**A:** Single Responsibility Principle - one reason to change.

**Q3: What is OCP?**
**A:** Open/Closed - open for extension, closed for modification.

**Q4: What is LSP?**
**A:** Liskov Substitution - subtypes substitutable for base types.

**Q5: What is ISP?**
**A:** Interface Segregation - don't depend on unused interfaces.

**Q6: What is DIP?**
**A:** Dependency Inversion - depend on abstractions, not concretions.

**Q7: What is clean code?**
**A:** Readable, maintainable, simple, well-tested code.

**Q8: What makes a good function name?**
**A:** Descriptive, verb-based, reveals intent.

**Q9: How long should a function be?**
**A:** Small, ideally < 20 lines, one level of abstraction.

**Q10: When to write comments?**
**A:** Explain WHY, not WHAT. Code should be self-explanatory.

**Q11: What is code smell?**
**A:** Indicator of deeper problems in code.

**Q12: What is technical debt?**
**A:** Cost of shortcuts that must be paid later.

**Q13: What is refactoring?**
**A:** Improving code structure without changing behavior.

**Q14: What is code coverage?**
**A:** Percentage of code executed by tests.

**Q15: What is a good coverage target?**
**A:** 80%+ for critical code, 100% for business logic.

**Q16: What is SonarQube?**
**A:** Static code analysis tool for quality and security.

**Q17: What is Checkstyle?**
**A:** Tool to enforce coding standards.

**Q18: What is SpotBugs?**
**A:** Static analysis tool to find bugs.

**Q19: What is code review?**
**A:** Peer examination of code changes.

**Q20: Benefits of code review?**
**A:** Find bugs, share knowledge, maintain quality, enforce standards.

---

## 9. Summary

Code quality is essential for maintainable software. SOLID principles: SRP (one responsibility), OCP (extend, don't modify), LSP (subtypes substitutable), ISP (segregated interfaces), DIP (depend on abstractions). Clean code practices: meaningful names, small functions, appropriate comments, specific exceptions. Proper organization: layer separation (controller, service, repository), package by feature. Testing: unit tests (80%+ coverage), integration tests, edge cases. Code review: check functionality, design, performance, security. Static analysis: SonarQube (quality), Checkstyle (standards), SpotBugs (bugs). Refactor continuously, pay technical debt early. Essential for long-term project success and team productivity.

---

**Next:** Design Patterns →
