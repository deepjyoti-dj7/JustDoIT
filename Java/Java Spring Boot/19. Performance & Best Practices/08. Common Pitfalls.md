# Common Pitfalls - Complete Guide

---

## 1. Introduction

Understanding common mistakes helps avoid production issues and improves code quality.

### Categories of Pitfalls

1. **Architecture** - Design and structure issues
2. **Performance** - Slow queries, memory leaks
3. **Concurrency** - Threading and synchronization
4. **Security** - Vulnerabilities and exposure
5. **Data** - Database and transaction issues

---

## 2. Architecture Pitfalls

### 2.1. God Classes

```java
// ❌ Bad - God class doing everything
@Service
public class UserService {
    public User createUser(UserDTO dto) { }
    public void sendEmail(User user) { }
    public void generateReport(User user) { }
    public void processPayment(User user, Payment payment) { }
    public void uploadToS3(File file) { }
    // ... 50 more methods
}

// ✅ Good - Separate responsibilities
@Service
public class UserService {
    public User createUser(UserDTO dto) { }
    public User updateUser(Long id, UserDTO dto) { }
}

@Service
public class EmailService {
    public void sendEmail(String to, String subject, String body) { }
}

@Service
public class PaymentService {
    public void processPayment(Payment payment) { }
}
```

### 2.2. Circular Dependencies

```java
// ❌ Bad - Circular dependency
@Service
public class OrderService {
    @Autowired
    private CustomerService customerService;  // A depends on B
}

@Service
public class CustomerService {
    @Autowired
    private OrderService orderService;  // B depends on A
}

// ✅ Good - Extract common logic
@Service
public class OrderService {
    @Autowired
    private OrderValidator orderValidator;
}

@Service
public class CustomerService {
    @Autowired
    private OrderValidator orderValidator;
}

@Service
public class OrderValidator {
    // Shared validation logic
}
```

### 2.3. Missing DTOs

```java
// ❌ Bad - Exposing entities directly
@RestController
public class UserController {
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userRepository.findById(id).orElseThrow();
    }
}

// ✅ Good - Use DTOs
@RestController
public class UserController {
    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        User user = userRepository.findById(id).orElseThrow();
        return userMapper.toDTO(user);
    }
}

@Data
public class UserDTO {
    private Long id;
    private String email;
    // No password, no internal fields
}
```

---

## 3. Performance Pitfalls

### 3.1. N+1 Query Problem

```java
// ❌ Bad - N+1 queries
public List<OrderDTO> getOrders() {
    List<Order> orders = orderRepository.findAll();  // 1 query
    return orders.stream()
                 .map(order -> {
                     order.getItems().size();  // N queries!
                     return orderMapper.toDTO(order);
                 })
                 .collect(Collectors.toList());
}

// ✅ Good - Fetch join
@Query("SELECT DISTINCT o FROM Order o LEFT JOIN FETCH o.items")
List<Order> findAllWithItems();

public List<OrderDTO> getOrders() {
    List<Order> orders = orderRepository.findAllWithItems();  // 1 query
    return orderMapper.toDTOList(orders);
}
```

### 3.2. Missing Indexes

```java
// ❌ Bad - No indexes
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private String category;  // Frequently queried, no index!
}

// ✅ Good - Proper indexes
@Entity
@Table(name = "product", indexes = {
    @Index(name = "idx_category", columnList = "category"),
    @Index(name = "idx_name", columnList = "name")
})
public class Product {
    @Id
    private Long id;
    private String name;
    private String category;
}
```

### 3.3. Not Using Pagination

```java
// ❌ Bad - Load all records
@GetMapping("/products")
public List<Product> getProducts() {
    return productRepository.findAll();  // Could be millions!
}

// ✅ Good - Pagination
@GetMapping("/products")
public Page<ProductDTO> getProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    Pageable pageable = PageRequest.of(page, size);
    return productRepository.findAll(pageable)
                            .map(productMapper::toDTO);
}
```

---

## 4. Concurrency Pitfalls

### 4.1. Race Conditions

```java
// ❌ Bad - Race condition
@Service
public class CounterService {
    private int counter = 0;
    
    public void increment() {
        counter++;  // Not thread-safe!
    }
}

// ✅ Good - Synchronized
@Service
public class CounterService {
    private final AtomicInteger counter = new AtomicInteger(0);
    
    public void increment() {
        counter.incrementAndGet();
    }
}
```

### 4.2. Deadlocks

```java
// ❌ Bad - Potential deadlock
public class TransferService {
    public synchronized void transfer(Account from, Account to, BigDecimal amount) {
        synchronized (from) {
            synchronized (to) {
                from.withdraw(amount);
                to.deposit(amount);
            }
        }
    }
}

// ✅ Good - Consistent lock ordering
public class TransferService {
    public void transfer(Account from, Account to, BigDecimal amount) {
        Account first = from.getId() < to.getId() ? from : to;
        Account second = from.getId() < to.getId() ? to : from;
        
        synchronized (first) {
            synchronized (second) {
                if (from == first) {
                    from.withdraw(amount);
                    to.deposit(amount);
                } else {
                    to.deposit(amount);
                    from.withdraw(amount);
                }
            }
        }
    }
}
```

---

## 5. Transaction Pitfalls

### 5.1. Missing @Transactional

```java
// ❌ Bad - No transaction
@Service
public class OrderService {
    public void createOrder(OrderDTO dto) {
        Order order = new Order();
        orderRepository.save(order);
        
        // If this fails, order is still saved!
        inventoryService.reduceStock(dto.getProductId(), dto.getQuantity());
    }
}

// ✅ Good - Transactional
@Service
public class OrderService {
    @Transactional
    public void createOrder(OrderDTO dto) {
        Order order = new Order();
        orderRepository.save(order);
        
        // Rolls back if this fails
        inventoryService.reduceStock(dto.getProductId(), dto.getQuantity());
    }
}
```

### 5.2. Wrong Transaction Propagation

```java
// ❌ Bad - Each operation in separate transaction
@Service
public class OrderService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveOrder(Order order) {
        orderRepository.save(order);
    }
    
    @Transactional
    public void processOrder(OrderDTO dto) {
        Order order = new Order();
        saveOrder(order);  // New transaction!
        
        // If this fails, order still saved!
        paymentService.processPayment(order);
    }
}

// ✅ Good - Default propagation
@Service
public class OrderService {
    @Transactional
    public void saveOrder(Order order) {
        orderRepository.save(order);
    }
    
    @Transactional
    public void processOrder(OrderDTO dto) {
        Order order = new Order();
        saveOrder(order);  // Same transaction
        
        // Rolls back both if this fails
        paymentService.processPayment(order);
    }
}
```

---

## 6. Security Pitfalls

### 6.1. SQL Injection

```java
// ❌ Bad - SQL injection vulnerability
@Repository
public class UserRepository {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper());
    }
}

// ✅ Good - Parameterized query
@Repository
public class UserRepository {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), username);
    }
}
```

### 6.2. Exposed Sensitive Data

```java
// ❌ Bad - Password in response
@Entity
public class User {
    @Id
    private Long id;
    private String email;
    private String password;  // Exposed in JSON!
}

// ✅ Good - Hide sensitive fields
@Entity
public class User {
    @Id
    private Long id;
    private String email;
    
    @JsonIgnore
    private String password;
}

// ✅ Better - Use DTO
@Data
public class UserDTO {
    private Long id;
    private String email;
    // No password field
}
```

### 6.3. Missing Authentication

```java
// ❌ Bad - No authentication
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    @DeleteMapping("/users/{id}")
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);  // Anyone can delete!
    }
}

// ✅ Good - Require authentication and authorization
@RestController
@RequestMapping("/api/admin")
public class AdminController {
    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/users/{id}")
    public void deleteUser(@PathVariable Long id) {
        userService.delete(id);
    }
}
```

---

## 7. Exception Handling Pitfalls

### 7.1. Swallowing Exceptions

```java
// ❌ Bad - Silent failure
public void processFile(String path) {
    try {
        fileProcessor.process(path);
    } catch (Exception e) {
        // Silent! No logging, no re-throw
    }
}

// ✅ Good - Log and handle
public void processFile(String path) {
    try {
        fileProcessor.process(path);
    } catch (IOException e) {
        log.error("Failed to process file: {}", path, e);
        throw new FileProcessingException("Unable to process file", e);
    }
}
```

### 7.2. Catching Throwable

```java
// ❌ Bad - Catches errors too
public void riskyOperation() {
    try {
        // code
    } catch (Throwable t) {  // Catches OutOfMemoryError!
        log.error("Error", t);
    }
}

// ✅ Good - Catch specific exceptions
public void riskyOperation() {
    try {
        // code
    } catch (IOException | SQLException e) {
        log.error("Error", e);
    }
}
```

---

## 8. Resource Management Pitfalls

### 8.1. Not Closing Resources

```java
// ❌ Bad - Resource leak
public void readFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(path));
    String line = reader.readLine();
    // Reader never closed if exception occurs!
}

// ✅ Good - Try-with-resources
public void readFile(String path) throws IOException {
    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {
        String line = reader.readLine();
    }  // Automatically closed
}
```

### 8.2. Connection Pool Exhaustion

```java
// ❌ Bad - Manual connection management
public void executeQuery(String sql) {
    Connection conn = dataSource.getConnection();
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(sql);
    // Never closed!
}

// ✅ Good - Use Spring templates
@Autowired
private JdbcTemplate jdbcTemplate;

public List<User> executeQuery(String sql) {
    return jdbcTemplate.query(sql, new UserRowMapper());
}
```

---

## 9. Configuration Pitfalls

### 9.1. Hardcoded Values

```java
// ❌ Bad - Hardcoded
@Service
public class EmailService {
    private static final String SMTP_HOST = "smtp.gmail.com";
    private static final int SMTP_PORT = 587;
}

// ✅ Good - Externalized configuration
@Service
public class EmailService {
    @Value("${email.smtp.host}")
    private String smtpHost;
    
    @Value("${email.smtp.port}")
    private int smtpPort;
}
```

### 9.2. Passwords in Code

```java
// ❌ Bad - Password in code
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("admin");
        config.setPassword("admin123");  // Hardcoded!
        return new HikariDataSource(config);
    }
}

// ✅ Good - Environment variables
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(System.getenv("DATABASE_URL"));
        config.setUsername(System.getenv("DATABASE_USERNAME"));
        config.setPassword(System.getenv("DATABASE_PASSWORD"));
        return new HikariDataSource(config);
    }
}
```

---

## 10. Interview Questions

**Q1: What is a god class?**
**A:** Class with too many responsibilities, violates SRP.

**Q2: What is circular dependency?**
**A:** Two classes depending on each other.

**Q3: What is N+1 problem?**
**A:** 1 query for parents + N queries for children.

**Q4: How to prevent N+1?**
**A:** Use fetch joins, entity graphs, or batch fetching.

**Q5: Why use DTOs?**
**A:** Hide internal details, prevent over-fetching, security.

**Q6: What is race condition?**
**A:** Multiple threads accessing shared data causing unexpected results.

**Q7: How to prevent race conditions?**
**A:** Use synchronized, AtomicInteger, or locks.

**Q8: What is deadlock?**
**A:** Two threads waiting for each other's locks.

**Q9: How to prevent deadlock?**
**A:** Consistent lock ordering, timeout, avoid nested locks.

**Q10: What is SQL injection?**
**A:** Malicious SQL in user input.

**Q11: How to prevent SQL injection?**
**A:** Use parameterized queries, never concatenate SQL.

**Q12: Why hide passwords in DTOs?**
**A:** Prevent exposure in JSON responses/logs.

**Q13: What is @JsonIgnore?**
**A:** Excludes field from JSON serialization.

**Q14: What is try-with-resources?**
**A:** Auto-closes resources implementing AutoCloseable.

**Q15: Why not catch Throwable?**
**A:** Catches errors like OutOfMemoryError that shouldn't be caught.

**Q16: What is resource leak?**
**A:** Not closing connections, files, streams.

**Q17: What is @Transactional?**
**A:** Marks method to run in database transaction.

**Q18: What is transaction propagation?**
**A:** How transactions behave when calling other methods.

**Q19: What is REQUIRES_NEW?**
**A:** Always creates new transaction, suspends current.

**Q20: Why externalize configuration?**
**A:** Change settings without code changes, security.

---

## 11. Summary

Common pitfalls to avoid: Architecture (god classes - use SRP, circular dependencies - extract common logic, missing DTOs - use mappers), Performance (N+1 queries - use fetch joins, missing indexes - add on queried columns, no pagination - use Page/Slice), Concurrency (race conditions - use AtomicInteger, deadlocks - consistent lock ordering), Transactions (missing @Transactional - always use for multi-step operations, wrong propagation - use default REQUIRED), Security (SQL injection - parameterized queries, exposed passwords - use @JsonIgnore or DTOs, no authentication - use @PreAuthorize), Resources (not closing - use try-with-resources, connection leaks - use Spring templates), Configuration (hardcoded values - use @Value, passwords in code - environment variables). Always review code for these patterns. Critical for production applications.

---

**Next:** Code Quality →
