# üî® ConstraintValidator - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [ConstraintValidator Interface](#constraintvalidator-interface)
- [Creating Custom Validators](#creating-custom-validators)
- [Multi-Type Validators](#multi-type-validators)
- [Validator with Dependencies](#validator-with-dependencies)
- [Performance Optimization](#performance-optimization)
- [Testing Validators](#testing-validators)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**ConstraintValidator** is the core interface for implementing custom validation logic in Bean Validation.

### ConstraintValidator Flow

```
1. Define constraint annotation (@ValidEmail)
2. Implement ConstraintValidator<A, T>
   - A: Annotation type
   - T: Type being validated
3. Override initialize() - setup
4. Override isValid() - validation logic
5. Apply annotation to field
6. Trigger with @Valid/@Validated
```

---

## üîß ConstraintValidator Interface

### Interface Definition

```java
public interface ConstraintValidator<A extends Annotation, T> {
    
    /**
     * Initializes the validator.
     * Called once before any validations.
     * 
     * @param constraintAnnotation annotation instance
     */
    default void initialize(A constraintAnnotation) {
    }
    
    /**
     * Implements the validation logic.
     * 
     * @param value object to validate
     * @param context context in which the constraint is evaluated
     * @return false if value is invalid, true if valid
     */
    boolean isValid(T value, ConstraintValidatorContext context);
}
```

### Type Parameters

```java
// A: Annotation type
// T: Validated type

// Example: Validate String with @ValidPhoneNumber
public class PhoneNumberValidator 
    implements ConstraintValidator<ValidPhoneNumber, String> {
    //                            ^^^^^^^^^^^^^^^^^  ^^^^^^
    //                            Annotation type    Validated type
}

// Example: Validate LocalDate with @ValidAge
public class AgeValidator 
    implements ConstraintValidator<ValidAge, LocalDate> {
    //                            ^^^^^^^^  ^^^^^^^^^
    //                            Annotation  Validated type
}
```

---

## üé® Creating Custom Validators

### Simple String Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface ValidPhoneNumber {
    String message() default "Invalid phone number format";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class PhoneNumberValidator implements ConstraintValidator<ValidPhoneNumber, String> {
    
    private static final Pattern PHONE_PATTERN = 
        Pattern.compile("^\\+?[1-9]\\d{1,14}$");
    
    @Override
    public void initialize(ValidPhoneNumber constraintAnnotation) {
        // Called once during initialization
        // Can access annotation parameters here
    }
    
    @Override
    public boolean isValid(String phoneNumber, ConstraintValidatorContext context) {
        // Null values are considered valid
        // Use @NotNull separately for null checks
        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {
            return true;
        }
        
        // Remove common formatting characters
        String cleanNumber = phoneNumber.replaceAll("[\\s\\-\\(\\)]", "");
        
        return PHONE_PATTERN.matcher(cleanNumber).matches();
    }
}

// Usage
@Data
public class ContactRequest {
    @ValidPhoneNumber
    private String phone;
}
```

### Parameterized Validator

```java
// Annotation with parameters
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MinAgeValidator.class)
public @interface MinAge {
    
    String message() default "Age must be at least {value} years";
    
    int value() default 18;  // Parameter
    
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator accessing parameter
public class MinAgeValidator implements ConstraintValidator<MinAge, LocalDate> {
    
    private int minAge;
    
    @Override
    public void initialize(MinAge constraintAnnotation) {
        // Access annotation parameter
        this.minAge = constraintAnnotation.value();
    }
    
    @Override
    public boolean isValid(LocalDate birthDate, ConstraintValidatorContext context) {
        if (birthDate == null) {
            return true;
        }
        
        int age = Period.between(birthDate, LocalDate.now()).getYears();
        return age >= minAge;
    }
}

// Usage
@Data
public class UserRequest {
    
    @MinAge(18)  // Must be at least 18
    private LocalDate birthDate;
    
    @MinAge(value = 21, message = "Must be 21+ for alcohol purchase")
    private LocalDate alcoholPurchaseBirthDate;
}
```

### Complex Business Logic Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidCreditCardValidator.class)
public @interface ValidCreditCard {
    
    String message() default "Invalid credit card number";
    
    CreditCardType[] acceptedTypes() default {
        CreditCardType.VISA,
        CreditCardType.MASTERCARD,
        CreditCardType.AMEX
    };
    
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public enum CreditCardType {
    VISA("^4[0-9]{12}(?:[0-9]{3})?$"),
    MASTERCARD("^5[1-5][0-9]{14}$"),
    AMEX("^3[47][0-9]{13}$");
    
    private final String pattern;
    
    CreditCardType(String pattern) {
        this.pattern = pattern;
    }
    
    public String getPattern() {
        return pattern;
    }
}

// Validator
public class ValidCreditCardValidator implements ConstraintValidator<ValidCreditCard, String> {
    
    private Set<CreditCardType> acceptedTypes;
    
    @Override
    public void initialize(ValidCreditCard constraintAnnotation) {
        this.acceptedTypes = new HashSet<>(
            Arrays.asList(constraintAnnotation.acceptedTypes())
        );
    }
    
    @Override
    public boolean isValid(String cardNumber, ConstraintValidatorContext context) {
        if (cardNumber == null || cardNumber.trim().isEmpty()) {
            return true;
        }
        
        // Remove spaces and dashes
        String cleanNumber = cardNumber.replaceAll("[\\s\\-]", "");
        
        // Check if matches any accepted type
        boolean matchesType = acceptedTypes.stream()
            .anyMatch(type -> cleanNumber.matches(type.getPattern()));
        
        if (!matchesType) {
            return false;
        }
        
        // Luhn algorithm check
        return passesLuhnCheck(cleanNumber);
    }
    
    private boolean passesLuhnCheck(String cardNumber) {
        int sum = 0;
        boolean alternate = false;
        
        for (int i = cardNumber.length() - 1; i >= 0; i--) {
            int digit = Character.getNumericValue(cardNumber.charAt(i));
            
            if (alternate) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            
            sum += digit;
            alternate = !alternate;
        }
        
        return sum % 10 == 0;
    }
}

// Usage
@Data
public class PaymentRequest {
    
    @ValidCreditCard
    private String cardNumber;
    
    @ValidCreditCard(
        acceptedTypes = {CreditCardType.VISA, CreditCardType.MASTERCARD},
        message = "Only Visa and Mastercard accepted"
    )
    private String restrictedCardNumber;
}
```

---

## üîÑ Multi-Type Validators

### Single Validator for Multiple Types

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = {
    NotEmptyStringValidator.class,
    NotEmptyCollectionValidator.class,
    NotEmptyMapValidator.class
})
public @interface NotEmpty {
    String message() default "Must not be empty";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator for String
public class NotEmptyStringValidator implements ConstraintValidator<NotEmpty, String> {
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return value != null && !value.trim().isEmpty();
    }
}

// Validator for Collection
public class NotEmptyCollectionValidator implements ConstraintValidator<NotEmpty, Collection<?>> {
    
    @Override
    public boolean isValid(Collection<?> value, ConstraintValidatorContext context) {
        return value != null && !value.isEmpty();
    }
}

// Validator for Map
public class NotEmptyMapValidator implements ConstraintValidator<NotEmpty, Map<?, ?>> {
    
    @Override
    public boolean isValid(Map<?, ?> value, ConstraintValidatorContext context) {
        return value != null && !value.isEmpty();
    }
}

// Usage
@Data
public class Request {
    
    @NotEmpty
    private String name;  // Uses NotEmptyStringValidator
    
    @NotEmpty
    private List<String> tags;  // Uses NotEmptyCollectionValidator
    
    @NotEmpty
    private Map<String, String> metadata;  // Uses NotEmptyMapValidator
}
```

### Generic Type Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = RangeValidator.class)
public @interface Range {
    String message() default "Value must be between {min} and {max}";
    long min() default Long.MIN_VALUE;
    long max() default Long.MAX_VALUE;
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator for Number types
public class RangeValidator implements ConstraintValidator<Range, Number> {
    
    private long min;
    private long max;
    
    @Override
    public void initialize(Range constraintAnnotation) {
        this.min = constraintAnnotation.min();
        this.max = constraintAnnotation.max();
    }
    
    @Override
    public boolean isValid(Number value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }
        
        long longValue = value.longValue();
        return longValue >= min && longValue <= max;
    }
}

// Usage
@Data
public class Request {
    
    @Range(min = 1, max = 100)
    private Integer quantity;  // Works with Integer
    
    @Range(min = 0, max = 1000000)
    private Long amount;  // Works with Long
    
    @Range(min = 1, max = 5)
    private Short rating;  // Works with Short
}
```

---

## üíâ Validator with Dependencies

### Repository Injection

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    String message() default "Email already exists";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator with @Component and @Autowired
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    
    private final UserRepository userRepository;
    
    @Autowired
    public UniqueEmailValidator(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        return !userRepository.existsByEmail(email);
    }
}

// Usage
@Data
public class UserRegistrationRequest {
    
    @NotBlank
    @Email
    @UniqueEmail  // Checks database
    private String email;
}
```

### Service Injection

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidPromoCodeValidator.class)
public @interface ValidPromoCode {
    String message() default "Invalid or expired promo code";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Validator with service dependency
@Component
public class ValidPromoCodeValidator implements ConstraintValidator<ValidPromoCode, String> {
    
    private final PromoCodeService promoCodeService;
    
    @Autowired
    public ValidPromoCodeValidator(PromoCodeService promoCodeService) {
        this.promoCodeService = promoCodeService;
    }
    
    @Override
    public boolean isValid(String code, ConstraintValidatorContext context) {
        if (code == null || code.trim().isEmpty()) {
            return true;
        }
        
        // Check if code is valid and not expired
        boolean isValid = promoCodeService.isValidAndActive(code);
        
        if (!isValid) {
            // Custom message with details
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                String.format("Promo code '%s' is invalid or expired", code)
            ).addConstraintViolation();
        }
        
        return isValid;
    }
}

// Usage
@Data
public class OrderRequest {
    
    @ValidPromoCode
    private String promoCode;
}
```

---

## ‚ö° Performance Optimization

### Caching in Validators

```java
@Component
public class OptimizedEmailDomainValidator 
    implements ConstraintValidator<ValidEmailDomain, String> {
    
    private final ConfigService configService;
    
    // Cache allowed domains
    private Set<String> cachedAllowedDomains;
    private LocalDateTime lastCacheRefresh;
    private static final Duration CACHE_DURATION = Duration.ofHours(1);
    
    @Autowired
    public OptimizedEmailDomainValidator(ConfigService configService) {
        this.configService = configService;
    }
    
    @Override
    public void initialize(ValidEmailDomain constraintAnnotation) {
        refreshCache();
    }
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        // Refresh cache if expired
        if (isCacheExpired()) {
            refreshCache();
        }
        
        String domain = extractDomain(email);
        return cachedAllowedDomains.contains(domain.toLowerCase());
    }
    
    private void refreshCache() {
        this.cachedAllowedDomains = new HashSet<>(
            configService.getAllowedEmailDomains()
        );
        this.lastCacheRefresh = LocalDateTime.now();
    }
    
    private boolean isCacheExpired() {
        return lastCacheRefresh == null || 
               Duration.between(lastCacheRefresh, LocalDateTime.now())
                   .compareTo(CACHE_DURATION) > 0;
    }
    
    private String extractDomain(String email) {
        return email.substring(email.lastIndexOf('@') + 1);
    }
}
```

### Compiled Pattern Reuse

```java
public class RegexValidator implements ConstraintValidator<ValidPattern, String> {
    
    // Compile pattern once in initialize()
    private Pattern compiledPattern;
    
    @Override
    public void initialize(ValidPattern constraintAnnotation) {
        // ‚úÖ Good - Compile once
        this.compiledPattern = Pattern.compile(
            constraintAnnotation.regexp(),
            Pattern.CASE_INSENSITIVE
        );
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }
        
        // ‚úÖ Reuse compiled pattern
        return compiledPattern.matcher(value).matches();
    }
}

// ‚ùå Bad - Compile on every validation
public class BadRegexValidator implements ConstraintValidator<ValidPattern, String> {
    
    private String regex;
    
    @Override
    public void initialize(ValidPattern constraintAnnotation) {
        this.regex = constraintAnnotation.regexp();
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // ‚ùå Compiles pattern on every call (slow)
        return value.matches(regex);
    }
}
```

---

## üß™ Testing Validators

### Unit Testing

```java
@SpringBootTest
class PhoneNumberValidatorTest {
    
    private PhoneNumberValidator validator;
    private ConstraintValidatorContext context;
    
    @BeforeEach
    void setUp() {
        validator = new PhoneNumberValidator();
        context = mock(ConstraintValidatorContext.class);
        
        // Initialize validator
        ValidPhoneNumber annotation = mock(ValidPhoneNumber.class);
        validator.initialize(annotation);
    }
    
    @Test
    void shouldAcceptValidPhoneNumber() {
        assertTrue(validator.isValid("+1234567890", context));
        assertTrue(validator.isValid("+12345678901234", context));
    }
    
    @Test
    void shouldRejectInvalidPhoneNumber() {
        assertFalse(validator.isValid("123", context));
        assertFalse(validator.isValid("abc", context));
        assertFalse(validator.isValid("+", context));
    }
    
    @Test
    void shouldAcceptNullValue() {
        assertTrue(validator.isValid(null, context));
    }
    
    @Test
    void shouldAcceptEmptyString() {
        assertTrue(validator.isValid("", context));
        assertTrue(validator.isValid("   ", context));
    }
    
    @Test
    void shouldHandleFormattedNumbers() {
        assertTrue(validator.isValid("+1 (234) 567-890", context));
    }
}
```

### Integration Testing

```java
@SpringBootTest
@AutoConfigureMockMvc
class UniqueEmailValidatorIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private UserRepository userRepository;
    
    @BeforeEach
    void setUp() {
        userRepository.deleteAll();
    }
    
    @Test
    void shouldRejectDuplicateEmail() throws Exception {
        // Given: Existing user
        User existingUser = new User();
        existingUser.setEmail("test@example.com");
        userRepository.save(existingUser);
        
        // When: Try to register with same email
        UserRegistrationRequest request = new UserRegistrationRequest();
        request.setEmail("test@example.com");
        request.setPassword("password123");
        
        // Then: Should fail validation
        mockMvc.perform(post("/api/users/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(toJson(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.validationErrors.email")
                .value("Email already exists"));
    }
    
    @Test
    void shouldAcceptUniqueEmail() throws Exception {
        // When: Register with new email
        UserRegistrationRequest request = new UserRegistrationRequest();
        request.setEmail("newuser@example.com");
        request.setPassword("password123");
        
        // Then: Should succeed
        mockMvc.perform(post("/api/users/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(toJson(request)))
            .andExpect(status().isCreated());
    }
}
```

---

## üí° Best Practices

### 1. Null Handling

```java
// ‚úÖ Good - Return true for null
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    if (value == null) {
        return true;  // Let @NotNull handle null checks
    }
    return performValidation(value);
}

// ‚ùå Bad - Validator handles null
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    if (value == null) {
        return false;  // Don't do this
    }
    return performValidation(value);
}
```

### 2. Initialize Heavy Resources Once

```java
// ‚úÖ Good - Initialize in initialize()
private Pattern pattern;

@Override
public void initialize(Annotation annotation) {
    this.pattern = Pattern.compile(annotation.regexp());
}

// ‚ùå Bad - Create on every validation
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    Pattern pattern = Pattern.compile(regex);  // Inefficient
    return pattern.matcher(value).matches();
}
```

### 3. Use @Component for Dependency Injection

```java
// ‚úÖ Good - Spring manages instance
@Component
public class MyValidator implements ConstraintValidator<MyAnnotation, String> {
    @Autowired
    private MyService service;
}
```

### 4. Thread Safety

```java
// ‚úÖ Good - Immutable state
public class ThreadSafeValidator implements ConstraintValidator<Valid, String> {
    private final Pattern pattern = Pattern.compile("...");  // Immutable
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return pattern.matcher(value).matches();
    }
}

// ‚ùå Bad - Mutable state (not thread-safe)
public class UnsafeValidator implements ConstraintValidator<Valid, String> {
    private String lastValue;  // Shared mutable state
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        this.lastValue = value;  // Race condition!
        return checkValue();
    }
}
```

### 5. Clear Error Messages

```java
// ‚úÖ Good - Descriptive error
@Override
public boolean isValid(String email, ConstraintValidatorContext context) {
    if (!isValid(email)) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(
            String.format("Email '%s' is already registered", email)
        ).addConstraintViolation();
        return false;
    }
    return true;
}
```

---

## üé§ Interview Questions

### Q1: What is ConstraintValidator?
**Answer:** Interface for implementing custom validation logic with two type parameters: annotation type and validated type.

### Q2: What are the two methods in ConstraintValidator?
**Answer:** `initialize(A annotation)` and `isValid(T value, ConstraintValidatorContext context)`.

### Q3: When is initialize() called?
**Answer:** Once during validator initialization, before any validations.

### Q4: What is the purpose of initialize()?
**Answer:** To access annotation parameters and initialize validator state.

### Q5: What should isValid() return for null values?
**Answer:** Usually true (let @NotNull handle null checks separately).

### Q6: Can one annotation have multiple validators?
**Answer:** Yes, specify multiple in @Constraint:
```java
@Constraint(validatedBy = {Validator1.class, Validator2.class})
```

### Q7: How to inject dependencies in validators?
**Answer:** Mark validator with @Component, use @Autowired:
```java
@Component
public class MyValidator {
    @Autowired
    private MyService service;
}
```

### Q8: What is ConstraintValidatorContext?
**Answer:** Provides context for validation, allows custom error messages.

### Q9: How to create custom error message in validator?
**Answer:**
```java
context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("Custom message")
    .addConstraintViolation();
```

### Q10: Are validators thread-safe?
**Answer:** Should be - avoid mutable instance state, one instance used for all validations.

### Q11: Can validators access database?
**Answer:** Yes, inject repository/service, but be mindful of performance.

### Q12: How to validate multiple types with one annotation?
**Answer:** Create multiple validator classes, list all in @Constraint.

### Q13: What is the second parameter of isValid()?
**Answer:** ConstraintValidatorContext - provides context and custom message building.

### Q14: Can validators be stateful?
**Answer:** Avoid mutable state (thread safety), use immutable state from initialize().

### Q15: How to optimize validator performance?
**Answer:** Cache expensive operations, compile patterns once in initialize(), use efficient algorithms.

### Q16: Can isValid() throw exceptions?
**Answer:** Should return false instead, exceptions may not be handled properly.

### Q17: How to test validators?
**Answer:** Unit test: Instantiate validator, call initialize() and isValid(). Integration test: Test via REST endpoint.

### Q18: Difference between initialize() and constructor?
**Answer:** Constructor called once by Spring, initialize() called once by validation framework with annotation instance.

### Q19: Can you use generic types in validators?
**Answer:** Yes, but type erasure limits runtime type checking:
```java
ConstraintValidator<MyAnnotation, Number>
```

### Q20: Best practice for null handling?
**Answer:** Return true for null, let @NotNull handle null checks separately.

---

## üìö Summary

### ConstraintValidator Template

```java
// 1. Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MyValidator.class)
public @interface MyConstraint {
    String message() default "Invalid value";
    int value() default 0;  // Parameters
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 2. Validator
@Component  // For dependency injection
public class MyValidator implements ConstraintValidator<MyConstraint, String> {
    
    @Autowired  // Optional: inject dependencies
    private MyService service;
    
    private int paramValue;
    
    @Override
    public void initialize(MyConstraint annotation) {
        // Access annotation parameters
        this.paramValue = annotation.value();
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // Null handling
        if (value == null) {
            return true;
        }
        
        // Validation logic
        boolean isValid = performValidation(value);
        
        // Optional: Custom message
        if (!isValid) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate("Custom message")
                .addConstraintViolation();
        }
        
        return isValid;
    }
}

// 3. Usage
@Data
public class Request {
    @MyConstraint(value = 10)
    private String field;
}
```

### Key Points

- **Interface**: `ConstraintValidator<A, T>`
- **Methods**: `initialize(A)`, `isValid(T, Context)`
- **Null Handling**: Return true, use @NotNull separately
- **DI**: Use @Component + @Autowired
- **Thread Safety**: Avoid mutable state
- **Performance**: Initialize heavy operations once
- **Testing**: Unit test + Integration test

**Next:** README (Module Overview) ‚Üí

