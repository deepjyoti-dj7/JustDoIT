# üé® Custom Validators - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Creating Custom Annotations](#creating-custom-annotations)
- [Implementing ConstraintValidator](#implementing-constraintvalidator)
- [Field-Level Custom Validators](#field-level-custom-validators)
- [Class-Level Custom Validators](#class-level-custom-validators)
- [Parameterized Validators](#parameterized-validators)
- [Dependency Injection in Validators](#dependency-injection-in-validators)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Custom Validators** allow you to create domain-specific validation constraints beyond the built-in validators.

### Why Custom Validators?

```
Built-in Validators:
‚úÖ Common validations (email, size, etc.)
‚ùå Cannot handle business logic
‚ùå Limited to standard checks

Custom Validators:
‚úÖ Business-specific validation
‚úÖ Complex validation logic
‚úÖ Database lookups
‚úÖ Cross-field validation
‚úÖ Reusable across DTOs
‚úÖ Clean, declarative code
```

### Custom Validator Flow

```
1. Create custom annotation (@ValidPhoneNumber)
2. Implement ConstraintValidator interface
3. Add validation logic
4. Apply annotation to field/class
5. Trigger with @Valid
```

---

## üîß Creating Custom Annotations

### Basic Custom Annotation

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
@Documented
public @interface ValidPhoneNumber {
    
    String message() default "Invalid phone number format";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}
```

### Annotation Components Explained

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
// Where annotation can be applied:
// - ElementType.FIELD: On class fields
// - ElementType.PARAMETER: On method parameters
// - ElementType.TYPE: On classes (for class-level validation)
// - ElementType.METHOD: On methods

@Retention(RetentionPolicy.RUNTIME)
// Annotation available at runtime (required for validators)

@Constraint(validatedBy = PhoneNumberValidator.class)
// Specifies the validator implementation class

@Documented
// Include in Javadoc

public @interface ValidPhoneNumber {
    
    // Required attributes for all constraints:
    
    String message() default "Invalid phone number format";
    // Error message when validation fails
    
    Class<?>[] groups() default {};
    // Validation groups (for conditional validation)
    
    Class<? extends Payload>[] payload() default {};
    // Metadata for validators (rarely used)
}
```

---

## üèóÔ∏è Implementing ConstraintValidator

### Basic Validator Implementation

```java
public class PhoneNumberValidator implements ConstraintValidator<ValidPhoneNumber, String> {
    
    private static final Pattern PHONE_PATTERN = Pattern.compile("^\\+?[1-9]\\d{1,14}$");
    
    @Override
    public void initialize(ValidPhoneNumber constraintAnnotation) {
        // Initialize validator (called once)
        // Can access annotation parameters here
    }
    
    @Override
    public boolean isValid(String phoneNumber, ConstraintValidatorContext context) {
        // Validation logic
        
        // Null values are considered valid
        // Use @NotNull separately for null checks
        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {
            return true;
        }
        
        // Remove common formatting characters
        String cleanedNumber = phoneNumber.replaceAll("[\\s\\-\\(\\)]", "");
        
        return PHONE_PATTERN.matcher(cleanedNumber).matches();
    }
}
```

### Using the Custom Validator

```java
@Data
public class UserRequest {
    
    @NotBlank(message = "Phone is required")
    @ValidPhoneNumber(message = "Phone number must be in E.164 format")
    private String phone;
}

// Request
{
  "phone": "+1234567890"     // ‚úÖ Valid
  "phone": "+1 (234) 567-890" // ‚úÖ Valid (formatting removed)
  "phone": "123"              // ‚ùå Invalid
  "phone": "abc"              // ‚ùå Invalid
}
```

---

## üìù Field-Level Custom Validators

### Email Domain Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailDomainValidator.class)
public @interface ValidEmailDomain {
    
    String message() default "Email domain is not allowed";
    
    String[] allowedDomains() default {};
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class EmailDomainValidator implements ConstraintValidator<ValidEmailDomain, String> {
    
    private Set<String> allowedDomains;
    
    @Override
    public void initialize(ValidEmailDomain constraintAnnotation) {
        this.allowedDomains = new HashSet<>(
            Arrays.asList(constraintAnnotation.allowedDomains())
        );
    }
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        if (!email.contains("@")) {
            return false;
        }
        
        String domain = email.substring(email.lastIndexOf('@') + 1).toLowerCase();
        return allowedDomains.isEmpty() || allowedDomains.contains(domain);
    }
}

// Usage
@Data
public class EmployeeRequest {
    
    @Email(message = "Email must be valid")
    @ValidEmailDomain(
        allowedDomains = {"company.com", "company.net"},
        message = "Email must be from company domain"
    )
    private String email;
}
```

### Password Strength Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = StrongPasswordValidator.class)
public @interface StrongPassword {
    
    String message() default "Password does not meet strength requirements";
    
    int minLength() default 8;
    
    boolean requireUppercase() default true;
    
    boolean requireLowercase() default true;
    
    boolean requireDigit() default true;
    
    boolean requireSpecialChar() default true;
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {
    
    private int minLength;
    private boolean requireUppercase;
    private boolean requireLowercase;
    private boolean requireDigit;
    private boolean requireSpecialChar;
    
    @Override
    public void initialize(StrongPassword constraintAnnotation) {
        this.minLength = constraintAnnotation.minLength();
        this.requireUppercase = constraintAnnotation.requireUppercase();
        this.requireLowercase = constraintAnnotation.requireLowercase();
        this.requireDigit = constraintAnnotation.requireDigit();
        this.requireSpecialChar = constraintAnnotation.requireSpecialChar();
    }
    
    @Override
    public boolean isValid(String password, ConstraintValidatorContext context) {
        if (password == null) {
            return true;
        }
        
        if (password.length() < minLength) {
            return false;
        }
        
        if (requireUppercase && !password.matches(".*[A-Z].*")) {
            return false;
        }
        
        if (requireLowercase && !password.matches(".*[a-z].*")) {
            return false;
        }
        
        if (requireDigit && !password.matches(".*\\d.*")) {
            return false;
        }
        
        if (requireSpecialChar && !password.matches(".*[@$!%*?&].*")) {
            return false;
        }
        
        return true;
    }
}

// Usage
@Data
public class UserRegistrationRequest {
    
    @NotBlank(message = "Password is required")
    @StrongPassword(
        minLength = 10,
        requireUppercase = true,
        requireLowercase = true,
        requireDigit = true,
        requireSpecialChar = true,
        message = "Password must be at least 10 characters with uppercase, lowercase, digit, and special character"
    )
    private String password;
}
```

### Age Validator

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = AgeValidator.class)
public @interface ValidAge {
    
    String message() default "Age is not valid";
    
    int min() default 0;
    
    int max() default 150;
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class AgeValidator implements ConstraintValidator<ValidAge, LocalDate> {
    
    private int minAge;
    private int maxAge;
    
    @Override
    public void initialize(ValidAge constraintAnnotation) {
        this.minAge = constraintAnnotation.min();
        this.maxAge = constraintAnnotation.max();
    }
    
    @Override
    public boolean isValid(LocalDate birthDate, ConstraintValidatorContext context) {
        if (birthDate == null) {
            return true;
        }
        
        int age = Period.between(birthDate, LocalDate.now()).getYears();
        
        return age >= minAge && age <= maxAge;
    }
}

// Usage
@Data
public class UserRequest {
    
    @NotNull(message = "Birth date is required")
    @Past(message = "Birth date must be in the past")
    @ValidAge(
        min = 18,
        max = 120,
        message = "You must be between 18 and 120 years old"
    )
    private LocalDate birthDate;
}
```

---

## üèõÔ∏è Class-Level Custom Validators

### Password Match Validator

```java
// Annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
@Documented
public @interface PasswordMatches {
    
    String message() default "Passwords do not match";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class PasswordMatchesValidator implements ConstraintValidator<PasswordMatches, Object> {
    
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        if (obj == null) {
            return true;
        }
        
        try {
            Field passwordField = obj.getClass().getDeclaredField("password");
            Field confirmPasswordField = obj.getClass().getDeclaredField("confirmPassword");
            
            passwordField.setAccessible(true);
            confirmPasswordField.setAccessible(true);
            
            String password = (String) passwordField.get(obj);
            String confirmPassword = (String) confirmPasswordField.get(obj);
            
            if (password == null && confirmPassword == null) {
                return true;
            }
            
            return password != null && password.equals(confirmPassword);
            
        } catch (NoSuchFieldException | IllegalAccessException e) {
            return false;
        }
    }
}

// Usage
@Data
@PasswordMatches
public class UserRegistrationRequest {
    
    @NotBlank(message = "Email is required")
    @Email
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8)
    private String password;
    
    @NotBlank(message = "Confirm password is required")
    private String confirmPassword;
}
```

### Date Range Validator

```java
// Annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = DateRangeValidator.class)
public @interface ValidDateRange {
    
    String message() default "End date must be after start date";
    
    String startDate();
    
    String endDate();
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class DateRangeValidator implements ConstraintValidator<ValidDateRange, Object> {
    
    private String startDateField;
    private String endDateField;
    
    @Override
    public void initialize(ValidDateRange constraintAnnotation) {
        this.startDateField = constraintAnnotation.startDate();
        this.endDateField = constraintAnnotation.endDate();
    }
    
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        try {
            Field startField = value.getClass().getDeclaredField(startDateField);
            Field endField = value.getClass().getDeclaredField(endDateField);
            
            startField.setAccessible(true);
            endField.setAccessible(true);
            
            LocalDate startDate = (LocalDate) startField.get(value);
            LocalDate endDate = (LocalDate) endField.get(value);
            
            if (startDate == null || endDate == null) {
                return true;
            }
            
            return !endDate.isBefore(startDate);
            
        } catch (Exception e) {
            return false;
        }
    }
}

// Usage
@Data
@ValidDateRange(
    startDate = "startDate",
    endDate = "endDate",
    message = "End date must be after start date"
)
public class EventRequest {
    
    @NotNull(message = "Start date is required")
    private LocalDate startDate;
    
    @NotNull(message = "End date is required")
    private LocalDate endDate;
    
    @NotBlank(message = "Event name is required")
    private String name;
}
```

### Price Range Validator

```java
// Annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PriceRangeValidator.class)
public @interface ValidPriceRange {
    
    String message() default "Maximum price must be greater than minimum price";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class PriceRangeValidator implements ConstraintValidator<ValidPriceRange, Object> {
    
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        try {
            Field minPriceField = obj.getClass().getDeclaredField("minPrice");
            Field maxPriceField = obj.getClass().getDeclaredField("maxPrice");
            
            minPriceField.setAccessible(true);
            maxPriceField.setAccessible(true);
            
            BigDecimal minPrice = (BigDecimal) minPriceField.get(obj);
            BigDecimal maxPrice = (BigDecimal) maxPriceField.get(obj);
            
            if (minPrice == null || maxPrice == null) {
                return true;
            }
            
            return maxPrice.compareTo(minPrice) >= 0;
            
        } catch (Exception e) {
            return false;
        }
    }
}

// Usage
@Data
@ValidPriceRange
public class ProductSearchRequest {
    
    @PositiveOrZero(message = "Minimum price cannot be negative")
    private BigDecimal minPrice;
    
    @Positive(message = "Maximum price must be positive")
    private BigDecimal maxPrice;
}
```

---

## üéØ Parameterized Validators

### Enum Validator

```java
// Annotation
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EnumValidator.class)
public @interface ValidEnum {
    
    String message() default "Invalid value. Must be one of: {allowedValues}";
    
    Class<? extends Enum<?>> enumClass();
    
    boolean ignoreCase() default false;
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator
public class EnumValidator implements ConstraintValidator<ValidEnum, String> {
    
    private Set<String> allowedValues;
    private boolean ignoreCase;
    
    @Override
    public void initialize(ValidEnum constraintAnnotation) {
        this.ignoreCase = constraintAnnotation.ignoreCase();
        
        Class<? extends Enum<?>> enumClass = constraintAnnotation.enumClass();
        Enum<?>[] enumConstants = enumClass.getEnumConstants();
        
        this.allowedValues = Arrays.stream(enumConstants)
            .map(Enum::name)
            .map(name -> ignoreCase ? name.toLowerCase() : name)
            .collect(Collectors.toSet());
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }
        
        String valueToCheck = ignoreCase ? value.toLowerCase() : value;
        return allowedValues.contains(valueToCheck);
    }
}

// Usage
public enum OrderStatus {
    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED
}

@Data
public class OrderRequest {
    
    @NotBlank(message = "Status is required")
    @ValidEnum(
        enumClass = OrderStatus.class,
        ignoreCase = true,
        message = "Status must be one of: PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED"
    )
    private String status;
}
```

---

## üíâ Dependency Injection in Validators

### Validator with Service Dependency

```java
// Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    
    String message() default "Email already exists";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

// Validator with @Autowired
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        return !userRepository.existsByEmail(email);
    }
}

// Usage
@Data
public class UserRegistrationRequest {
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    @UniqueEmail(message = "Email is already registered")
    private String email;
}
```

### Custom Error Messages with Context

```java
@Component
public class ProductSkuValidator implements ConstraintValidator<ValidProductSku, String> {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Override
    public boolean isValid(String sku, ConstraintValidatorContext context) {
        if (sku == null || sku.trim().isEmpty()) {
            return true;
        }
        
        // Check if SKU exists
        if (productRepository.existsBySku(sku)) {
            // Disable default message
            context.disableDefaultConstraintViolation();
            
            // Add custom message with details
            context.buildConstraintViolationWithTemplate(
                String.format("Product SKU '%s' already exists", sku)
            ).addConstraintViolation();
            
            return false;
        }
        
        return true;
    }
}
```

---

## üìå Best Practices

### 1. Null Handling

```java
// ‚úÖ Good - Allow null, use @NotNull separately
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    if (value == null || value.trim().isEmpty()) {
        return true; // Let @NotNull handle null checks
    }
    
    return performValidation(value);
}

// ‚ùå Bad - Validator handles null
@Override
public boolean isValid(String value, ConstraintValidatorContext context) {
    if (value == null) {
        return false; // Don't do this
    }
    return performValidation(value);
}
```

### 2. Reusable Validators

```java
// ‚úÖ Good - Generic, reusable
@ValidEnum(enumClass = OrderStatus.class)
private String status;

@ValidEnum(enumClass = PaymentMethod.class)
private String paymentMethod;

// ‚ùå Bad - Specific, not reusable
@ValidOrderStatus
private String status;

@ValidPaymentMethod
private String paymentMethod;
```

### 3. Clear Error Messages

```java
// ‚úÖ Good - Descriptive message
@StrongPassword(
    minLength = 10,
    message = "Password must be at least 10 characters with uppercase, lowercase, digit, and special character"
)
private String password;

// ‚ùå Bad - Generic message
@StrongPassword(message = "Invalid password")
private String password;
```

### 4. Parameterize When Possible

```java
// ‚úÖ Good - Parameterized, flexible
@ValidAge(min = 18, max = 65, message = "Age must be between 18 and 65")
private LocalDate birthDate;

// ‚ùå Bad - Hardcoded values
@ValidAdultAge  // Always checks 18-120
private LocalDate birthDate;
```

### 5. Avoid Heavy Operations

```java
// ‚ùå Bad - Expensive database query in validator
@Override
public boolean isValid(String email, ConstraintValidatorContext context) {
    // Avoid complex queries
    List<User> allUsers = userRepository.findAll();
    return allUsers.stream().noneMatch(u -> u.getEmail().equals(email));
}

// ‚úÖ Good - Optimized query
@Override
public boolean isValid(String email, ConstraintValidatorContext context) {
    return !userRepository.existsByEmail(email);
}
```

### 6. Component Annotation for DI

```java
// ‚úÖ Good - Use @Component for autowiring
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    @Autowired
    private UserRepository userRepository;
}

// Or configure in validator factory (advanced)
```

---

## üé§ Interview Questions

### Q1: How to create a custom validator?
**Answer:**
1. Create annotation with @Constraint
2. Implement ConstraintValidator<YourAnnotation, Type>
3. Override initialize() and isValid()
4. Apply annotation to field/class

### Q2: What is ConstraintValidator interface?
**Answer:** Interface with two type parameters (annotation type, validated type) and two methods: initialize() and isValid().

### Q3: When to use field-level vs class-level validators?
**Answer:**
- Field-level: Validate single field
- Class-level: Cross-field validation (e.g., password match)

### Q4: How to handle null values in custom validators?
**Answer:** Return true for null, let @NotNull handle null checks separately.

### Q5: Can you inject dependencies in validators?
**Answer:** Yes, mark validator with @Component and use @Autowired.

### Q6: What is initialize() method for?
**Answer:** Called once to initialize validator, access annotation parameters.

### Q7: How to create parameterized validators?
**Answer:** Add parameters to annotation:
```java
@interface ValidAge {
    int min() default 0;
    int max() default 150;
}
```

### Q8: What is ConstraintValidatorContext?
**Answer:** Provides context for validation, allows custom error messages.

### Q9: Can one annotation have multiple validators?
**Answer:** Yes, specify multiple validators in @Constraint:
```java
@Constraint(validatedBy = {Validator1.class, Validator2.class})
```

### Q10: How to validate enums?
**Answer:** Create @ValidEnum with enumClass parameter, check if value exists in enum.

### Q11: What is @Target in annotations?
**Answer:** Specifies where annotation can be applied (FIELD, TYPE, PARAMETER, etc.).

### Q12: What is @Retention?
**Answer:** Specifies annotation lifetime (RUNTIME required for validators).

### Q13: How to customize error messages dynamically?
**Answer:**
```java
context.disableDefaultConstraintViolation();
context.buildConstraintViolationWithTemplate("Custom message")
    .addConstraintViolation();
```

### Q14: Can validators be async?
**Answer:** No, validators must be synchronous. For async validation, use service layer.

### Q15: How to validate date ranges?
**Answer:** Create class-level validator, access both date fields via reflection.

### Q16: What is Payload in annotations?
**Answer:** Metadata for validators, used to carry additional information (rarely used).

### Q17: Can you test custom validators?
**Answer:** Yes, instantiate validator, call initialize() and isValid() with test data.

### Q18: How to validate unique values?
**Answer:** Inject repository, check if value exists:
```java
return !repository.existsByField(value);
```

### Q19: Best practices for custom validators?
**Answer:**
1. Return true for null
2. Make reusable with parameters
3. Clear error messages
4. Avoid heavy operations
5. Use @Component for DI
6. Test thoroughly

### Q20: Difference between custom validator and service validation?
**Answer:**
- Custom validator: Declarative, reusable, automatic with @Valid
- Service validation: Programmatic, complex business logic, manual

---

## üìö Summary

### Creating Custom Validator

```java
// 1. Annotation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
public @interface ValidPhoneNumber {
    String message() default "Invalid phone number";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 2. Validator
public class PhoneNumberValidator implements ConstraintValidator<ValidPhoneNumber, String> {
    
    @Override
    public void initialize(ValidPhoneNumber annotation) {
        // Initialize
    }
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) return true;
        return value.matches("^\\+?[1-9]\\d{1,14}$");
    }
}

// 3. Usage
@ValidPhoneNumber
private String phone;
```

### Key Points

- **Annotation**: @Target, @Retention, @Constraint
- **Validator**: Implement ConstraintValidator<A, T>
- **initialize()**: Setup validator
- **isValid()**: Validation logic
- **Null handling**: Return true for null
- **DI**: Use @Component for autowiring
- **Parameters**: Add to annotation for flexibility

**Next:** Valid vs Validated ‚Üí

