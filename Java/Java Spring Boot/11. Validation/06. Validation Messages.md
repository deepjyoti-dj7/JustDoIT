# üí¨ Validation Messages - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Default Messages](#default-messages)
- [Custom Messages](#custom-messages)
- [Message Interpolation](#message-interpolation)
- [Internationalization (i18n)](#internationalization-i18n)
- [MessageSource Configuration](#messagesource-configuration)
- [Dynamic Messages](#dynamic-messages)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Validation Messages** provide meaningful feedback when validation fails. Spring Boot supports default messages, custom messages, internationalization, and dynamic message generation.

### Message Resolution Order

```
1. Custom message in annotation (@NotNull(message = "Custom"))
2. Message from ValidationMessages.properties
3. Default message from validator
```

---

## üìù Default Messages

### Built-in Default Messages

```java
@Data
public class UserRequest {
    
    @NotNull
    private String name;
    // Default message: "must not be null"
    
    @NotBlank
    private String email;
    // Default message: "must not be blank"
    
    @Size(min = 2, max = 50)
    private String username;
    // Default message: "size must be between 2 and 50"
    
    @Min(18)
    private Integer age;
    // Default message: "must be greater than or equal to 18"
    
    @Email
    private String emailAddress;
    // Default message: "must be a well-formed email address"
    
    @Pattern(regexp = "^\\d{10}$")
    private String phone;
    // Default message: "must match \"^\\d{10}$\""
}
```

### Default Message Examples

```json
// POST /api/users with invalid data
{
  "name": null,
  "email": "  ",
  "username": "a",
  "age": 15,
  "emailAddress": "invalid",
  "phone": "123"
}

// Response
{
  "status": 400,
  "errors": {
    "name": "must not be null",
    "email": "must not be blank",
    "username": "size must be between 2 and 50",
    "age": "must be greater than or equal to 18",
    "emailAddress": "must be a well-formed email address",
    "phone": "must match \"^\\d{10}$\""
  }
}
```

---

## üé® Custom Messages

### Inline Custom Messages

```java
@Data
public class UserRequest {
    
    @NotNull(message = "Name is required")
    private String name;
    
    @NotBlank(message = "Email cannot be empty")
    @Email(message = "Please provide a valid email address")
    private String email;
    
    @Size(
        min = 8,
        max = 20,
        message = "Username must be between 8 and 20 characters"
    )
    private String username;
    
    @Min(value = 18, message = "You must be at least 18 years old")
    private Integer age;
    
    @Pattern(
        regexp = "^\\d{10}$",
        message = "Phone number must be exactly 10 digits"
    )
    private String phone;
    
    @Positive(message = "Price must be greater than zero")
    private BigDecimal price;
}
```

### Using Message Keys

```java
@Data
public class UserRequest {
    
    @NotNull(message = "{user.name.required}")
    private String name;
    
    @Email(message = "{user.email.invalid}")
    private String email;
    
    @Size(
        min = 8,
        max = 20,
        message = "{user.username.size}"
    )
    private String username;
}
```

---

## üî§ Message Interpolation

### Parameter Interpolation

```java
@Data
public class ProductRequest {
    
    @Size(
        min = 3,
        max = 50,
        message = "Name must be between {min} and {max} characters"
    )
    private String name;
    
    @DecimalMin(
        value = "0.01",
        message = "Price must be at least ${value}"
    )
    private BigDecimal price;
    
    @Min(
        value = 1,
        message = "Quantity must be at least {value}"
    )
    private Integer quantity;
}

// Validation error
{
  "name": "AB",
  "price": 0.00,
  "quantity": 0
}

// Response
{
  "errors": {
    "name": "Name must be between 3 and 50 characters",
    "price": "Price must be at least $0.01",
    "quantity": "Quantity must be at least 1"
  }
}
```

### Accessing Validated Value

```java
@Data
public class Request {
    
    @NotBlank(message = "Field cannot be empty. Received: '{validatedValue}'")
    private String field;
}

// POST with {"field": ""}
// Error: "Field cannot be empty. Received: ''"
```

### Complex Interpolation

```java
@Data
public class OrderRequest {
    
    @DecimalMin(
        value = "10.00",
        message = "Order total ${validatedValue} is below minimum ${value}"
    )
    private BigDecimal total;
}

// POST with {"total": 5.00}
// Error: "Order total $5.00 is below minimum $10.00"
```

---

## üåç Internationalization (i18n)

### ValidationMessages.properties

Create `src/main/resources/ValidationMessages.properties`:

```properties
# Default messages (English)
user.name.required=Name is required
user.email.invalid=Please provide a valid email address
user.email.required=Email is required
user.username.size=Username must be between {min} and {max} characters
user.password.required=Password is required
user.password.weak=Password must contain uppercase, lowercase, digit, and special character
user.age.minimum=You must be at least {value} years old

product.name.required=Product name is required
product.price.positive=Price must be greater than zero
product.stock.min=Stock must be at least {value}

order.items.empty=Order must contain at least one item
order.total.minimum=Order total must be at least ${value}
```

### ValidationMessages_es.properties (Spanish)

```properties
# Spanish messages
user.name.required=El nombre es obligatorio
user.email.invalid=Por favor proporcione un correo electr√≥nico v√°lido
user.email.required=El correo electr√≥nico es obligatorio
user.username.size=El nombre de usuario debe tener entre {min} y {max} caracteres
user.password.required=La contrase√±a es obligatoria
user.password.weak=La contrase√±a debe contener may√∫sculas, min√∫sculas, d√≠gitos y caracteres especiales
user.age.minimum=Debe tener al menos {value} a√±os

product.name.required=El nombre del producto es obligatorio
product.price.positive=El precio debe ser mayor que cero
product.stock.min=El stock debe ser al menos {value}

order.items.empty=El pedido debe contener al menos un art√≠culo
order.total.minimum=El total del pedido debe ser al menos ${value}
```

### ValidationMessages_fr.properties (French)

```properties
# French messages
user.name.required=Le nom est requis
user.email.invalid=Veuillez fournir une adresse e-mail valide
user.email.required=L'e-mail est requis
user.username.size=Le nom d'utilisateur doit contenir entre {min} et {max} caract√®res
user.password.required=Le mot de passe est requis
user.password.weak=Le mot de passe doit contenir des majuscules, minuscules, chiffres et caract√®res sp√©ciaux
user.age.minimum=Vous devez avoir au moins {value} ans

product.name.required=Le nom du produit est requis
product.price.positive=Le prix doit √™tre sup√©rieur √† z√©ro
product.stock.min=Le stock doit √™tre d'au moins {value}

order.items.empty=La commande doit contenir au moins un article
order.total.minimum=Le total de la commande doit √™tre d'au moins ${value}
```

### Using Message Keys in DTOs

```java
@Data
public class UserRequest {
    
    @NotBlank(message = "{user.name.required}")
    private String name;
    
    @NotBlank(message = "{user.email.required}")
    @Email(message = "{user.email.invalid}")
    private String email;
    
    @Size(
        min = 8,
        max = 20,
        message = "{user.username.size}"
    )
    private String username;
    
    @Min(value = 18, message = "{user.age.minimum}")
    private Integer age;
}
```

### Locale-Based Validation

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(
        @Valid @RequestBody UserRequest request,
        @RequestHeader(value = "Accept-Language", defaultValue = "en") Locale locale
    ) {
        // Validation messages automatically use the locale
        User user = userService.create(request);
        return ResponseEntity.ok(user);
    }
}

// Request with English
// POST /api/users
// Accept-Language: en
// Error: "Name is required"

// Request with Spanish
// POST /api/users
// Accept-Language: es
// Error: "El nombre es obligatorio"

// Request with French
// POST /api/users
// Accept-Language: fr
// Error: "Le nom est requis"
```

---

## üîß MessageSource Configuration

### Custom MessageSource Bean

```java
@Configuration
public class ValidationConfig {
    
    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = 
            new ReloadableResourceBundleMessageSource();
        
        messageSource.setBasename("classpath:ValidationMessages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setCacheSeconds(3600); // Cache for 1 hour
        
        return messageSource;
    }
    
    @Bean
    public LocalValidatorFactoryBean validator(MessageSource messageSource) {
        LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();
        bean.setValidationMessageSource(messageSource);
        return bean;
    }
}
```

### application.yml Configuration

```yaml
spring:
  messages:
    basename: ValidationMessages
    encoding: UTF-8
    cache-duration: 3600
    fallback-to-system-locale: false
```

### Multiple Message Sources

```java
@Configuration
public class MessageConfig {
    
    @Bean
    public MessageSource messageSource() {
        ReloadableResourceBundleMessageSource messageSource = 
            new ReloadableResourceBundleMessageSource();
        
        // Multiple base names
        messageSource.setBasenames(
            "classpath:ValidationMessages",
            "classpath:messages/errors",
            "classpath:messages/labels"
        );
        
        messageSource.setDefaultEncoding("UTF-8");
        return messageSource;
    }
}
```

---

## üéØ Dynamic Messages

### Using ConstraintValidatorContext

```java
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        Optional<User> existingUser = userRepository.findByEmail(email);
        
        if (existingUser.isPresent()) {
            // Disable default message
            context.disableDefaultConstraintViolation();
            
            // Build custom message with dynamic content
            context.buildConstraintViolationWithTemplate(
                String.format("Email '%s' is already registered. Please use a different email.", email)
            ).addConstraintViolation();
            
            return false;
        }
        
        return true;
    }
}
```

### Dynamic Messages Based on Business Logic

```java
@Component
public class ValidOrderAmountValidator implements ConstraintValidator<ValidOrderAmount, BigDecimal> {
    
    @Autowired
    private ConfigService configService;
    
    @Override
    public boolean isValid(BigDecimal amount, ConstraintValidatorContext context) {
        if (amount == null) {
            return true;
        }
        
        BigDecimal minAmount = configService.getMinOrderAmount();
        BigDecimal maxAmount = configService.getMaxOrderAmount();
        
        if (amount.compareTo(minAmount) < 0) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                String.format(
                    "Order amount $%s is below minimum required amount $%s",
                    amount,
                    minAmount
                )
            ).addConstraintViolation();
            return false;
        }
        
        if (amount.compareTo(maxAmount) > 0) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                String.format(
                    "Order amount $%s exceeds maximum allowed amount $%s",
                    amount,
                    maxAmount
                )
            ).addConstraintViolation();
            return false;
        }
        
        return true;
    }
}
```

### Contextual Messages

```java
@Component
public class StockValidator implements ConstraintValidator<ValidStock, Integer> {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Override
    public boolean isValid(Integer requestedQuantity, ConstraintValidatorContext context) {
        // Get product ID from context (advanced technique)
        // Usually done via class-level validator
        
        int availableStock = productRepository.getAvailableStock(productId);
        
        if (requestedQuantity > availableStock) {
            context.disableDefaultConstraintViolation();
            context.buildConstraintViolationWithTemplate(
                String.format(
                    "Requested quantity %d exceeds available stock %d",
                    requestedQuantity,
                    availableStock
                )
            ).addConstraintViolation();
            return false;
        }
        
        return true;
    }
}
```

---

## üé® Custom Error Response

### Standard Error Response DTO

```java
@Data
@AllArgsConstructor
public class ErrorResponse {
    private String timestamp;
    private int status;
    private String error;
    private Map<String, String> validationErrors;
    private String path;
}
```

### Global Exception Handler

```java
@RestControllerAdvice
public class ValidationExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(
        MethodArgumentNotValidException ex,
        WebRequest request
    ) {
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });
        
        ErrorResponse response = new ErrorResponse(
            LocalDateTime.now().toString(),
            HttpStatus.BAD_REQUEST.value(),
            "Validation Failed",
            errors,
            request.getDescription(false).replace("uri=", "")
        );
        
        return ResponseEntity.badRequest().body(response);
    }
}

// Error response
{
  "timestamp": "2024-01-15T10:30:00",
  "status": 400,
  "error": "Validation Failed",
  "validationErrors": {
    "name": "Name is required",
    "email": "Please provide a valid email address",
    "age": "You must be at least 18 years old"
  },
  "path": "/api/users"
}
```

---

## üí° Best Practices

### 1. Use Message Keys for i18n

```java
// ‚úÖ Good - Supports internationalization
@NotBlank(message = "{user.name.required}")
private String name;

// ‚ùå Bad - Hardcoded English only
@NotBlank(message = "Name is required")
private String name;
```

### 2. Clear, User-Friendly Messages

```java
// ‚úÖ Good - Clear and actionable
@Email(message = "Please provide a valid email address (e.g., user@example.com)")
private String email;

// ‚ùå Bad - Technical, unclear
@Email(message = "Invalid format")
private String email;
```

### 3. Include Expected Values

```java
// ‚úÖ Good - Shows expected range
@Size(
    min = 8,
    max = 20,
    message = "Username must be between {min} and {max} characters"
)
private String username;

// ‚ùå Bad - Doesn't show range
@Size(min = 8, max = 20, message = "Username length invalid")
private String username;
```

### 4. Organize Messages by Domain

```properties
# ‚úÖ Good - Organized
user.name.required=Name is required
user.email.invalid=Invalid email
user.password.weak=Weak password

product.name.required=Product name required
product.price.invalid=Invalid price

# ‚ùå Bad - Disorganized
msg1=Name is required
msg2=Invalid email
msg3=Product name required
```

### 5. Consistent Message Format

```properties
# ‚úÖ Good - Consistent format
user.name.required=Name is required
user.email.required=Email is required
user.password.required=Password is required

# ‚ùå Bad - Inconsistent
user.name.required=Name is required
user.email.notprovided=You didn't provide email
user.password.missing=Missing password field
```

### 6. Use Dynamic Messages for Business Rules

```java
// ‚úÖ Good - Dynamic based on business rule
@Component
public class CustomValidator implements ConstraintValidator<Custom, String> {
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        String dynamicMessage = businessLogic(value);
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(dynamicMessage)
            .addConstraintViolation();
        return false;
    }
}
```

---

## üé§ Interview Questions

### Q1: Where are validation messages defined?
**Answer:** 
1. Inline in annotation: `@NotNull(message = "Required")`
2. ValidationMessages.properties
3. Custom MessageSource
4. Default from validator

### Q2: What is message interpolation?
**Answer:** Process of replacing placeholders like `{min}`, `{max}`, `{value}` with actual values.

### Q3: How to internationalize validation messages?
**Answer:** Create ValidationMessages_*.properties files for each locale:
```
ValidationMessages.properties (default)
ValidationMessages_es.properties (Spanish)
ValidationMessages_fr.properties (French)
```

### Q4: What is ValidationMessages.properties?
**Answer:** Resource bundle for validation messages, loaded automatically by Bean Validation.

### Q5: How to access constraint parameters in messages?
**Answer:** Use `{parameterName}`:
```java
@Size(min = 5, max = 10, message = "Length must be {min}-{max}")
```

### Q6: How to get validated value in message?
**Answer:** Use `{validatedValue}`:
```java
@NotBlank(message = "Field cannot be '{validatedValue}'")
```

### Q7: What is ConstraintValidatorContext?
**Answer:** Provides context for custom validation messages:
```java
context.buildConstraintViolationWithTemplate("Custom message")
    .addConstraintViolation();
```

### Q8: How to disable default message?
**Answer:**
```java
context.disableDefaultConstraintViolation();
```

### Q9: Message resolution order?
**Answer:**
1. Custom message in annotation
2. ValidationMessages.properties
3. Default validator message

### Q10: How to configure MessageSource?
**Answer:**
```java
@Bean
public MessageSource messageSource() {
    ReloadableResourceBundleMessageSource ms = 
        new ReloadableResourceBundleMessageSource();
    ms.setBasename("classpath:ValidationMessages");
    return ms;
}
```

### Q11: Can you use Spring EL in messages?
**Answer:** No, validation messages don't support Spring Expression Language.

### Q12: How to handle locale-specific validation?
**Answer:** Spring automatically picks locale from Accept-Language header, loads appropriate ValidationMessages_*.properties.

### Q13: What is fallback locale?
**Answer:** If specific locale not found, falls back to default ValidationMessages.properties.

### Q14: Can custom validators have dynamic messages?
**Answer:** Yes, use ConstraintValidatorContext:
```java
context.buildConstraintViolationWithTemplate("Dynamic: " + value)
```

### Q15: How to include field name in message?
**Answer:** Use `{property}` or access via ConstraintValidatorContext (limited support).

### Q16: Best practice for message keys?
**Answer:** Use hierarchical naming: `entity.field.constraint` (e.g., `user.email.invalid`)

### Q17: Can messages include HTML?
**Answer:** Yes, but be cautious of XSS. Sanitize if displaying in web UI.

### Q18: How to test validation messages?
**Answer:**
```java
Set<ConstraintViolation<User>> violations = validator.validate(user);
assertEquals("Expected message", violations.iterator().next().getMessage());
```

### Q19: Can you override built-in messages?
**Answer:** Yes, define message key in ValidationMessages.properties:
```properties
jakarta.validation.constraints.NotNull.message=Field is required
```

### Q20: How to provide context-specific messages?
**Answer:** Use validation groups or custom validators with ConstraintValidatorContext.

---

## üìö Summary

### Message Configuration Levels

```java
// 1. Inline message
@NotBlank(message = "Name is required")
private String name;

// 2. Message key
@NotBlank(message = "{user.name.required}")
private String name;

// 3. With interpolation
@Size(min = 5, max = 10, message = "Length: {min}-{max}")
private String field;

// 4. Dynamic message
context.buildConstraintViolationWithTemplate("Custom: " + value)
    .addConstraintViolation();
```

### ValidationMessages.properties Structure

```properties
# Format: entity.field.constraint=Message
user.name.required=Name is required
user.email.invalid=Invalid email format
user.age.minimum=Must be at least {value} years old

product.price.positive=Price must be positive
product.stock.min=Stock must be at least {value}
```

### Key Points

- **Message Sources**: Annotation ‚Üí ValidationMessages.properties ‚Üí Default
- **Interpolation**: Use `{parameter}` for constraint parameters
- **i18n**: Create ValidationMessages_locale.properties
- **Dynamic**: Use ConstraintValidatorContext for runtime messages
- **Best Practice**: Use message keys for internationalization

**Next:** ConstraintValidator ‚Üí

