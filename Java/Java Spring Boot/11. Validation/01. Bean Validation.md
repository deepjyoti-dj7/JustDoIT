# üéØ Bean Validation - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Bean Validation Basics](#bean-validation-basics)
- [JSR-303 vs JSR-380](#jsr-303-vs-jsr-380)
- [Validation Annotations](#validation-annotations)
- [Request Validation](#request-validation)
- [Nested Object Validation](#nested-object-validation)
- [Collection Validation](#collection-validation)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Bean Validation** is a Java specification (JSR-303/JSR-380) for declarative validation using annotations, providing a standard way to validate Java objects.

### Why Bean Validation?

```
Without Bean Validation:
‚ùå Manual validation in every method
‚ùå Duplicate validation logic
‚ùå Inconsistent error messages
‚ùå Hard to maintain

With Bean Validation:
‚úÖ Declarative validation with annotations
‚úÖ Reusable constraints
‚úÖ Consistent error messages
‚úÖ Framework integration
‚úÖ Standard specification
‚úÖ Easy to maintain
```

### Bean Validation Flow

```
Request ‚Üí @Valid ‚Üí Constraint Validation ‚Üí Success/Failure
                                              ‚Üì
                                    MethodArgumentNotValidException
                                              ‚Üì
                                    @ExceptionHandler catches
                                              ‚Üì
                                    Return field errors
```

---

## üîß Bean Validation Basics

### Setup Dependencies

```xml
<!-- Spring Boot Starter Validation -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

<!-- Includes:
     - hibernate-validator (implementation)
     - jakarta.validation-api (spec)
     - jakarta.el (expression language)
-->
```

### Simple Validation Example

```java
@Data
public class UserRequest {
    
    @NotNull(message = "Name is required")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @NotNull(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must not exceed 120")
    private Integer age;
}
```

### Controller with @Valid

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {
        User user = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
    
    @PutMapping("/{id}")
    public User updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserRequest request) {
        return userService.update(id, request);
    }
}
```

### Exception Handler

```java
@RestControllerAdvice
public class ValidationExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidationErrors(
            MethodArgumentNotValidException ex) {
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        return ValidationErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Validation failed")
            .errors(errors)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

---

## üìö JSR-303 vs JSR-380

### JSR-303 (Bean Validation 1.0/1.1)

```java
// Original specification
javax.validation.constraints.*

// Basic annotations
@NotNull
@Size
@Min
@Max
@Pattern
@Email
```

### JSR-380 (Bean Validation 2.0)

```java
// Updated specification (Java 8+)
jakarta.validation.constraints.*

// New annotations in 2.0
@NotEmpty
@NotBlank
@Positive
@PositiveOrZero
@Negative
@NegativeOrZero
@Past
@PastOrPresent
@Future
@FutureOrPresent
@Email (improved)
```

### Key Differences

```java
// JSR-303 (Old - javax.*)
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

// JSR-380 (New - jakarta.*)
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.NotBlank; // New in 2.0
import jakarta.validation.constraints.Positive; // New in 2.0
```

### Migration

```java
// Before (javax)
import javax.validation.Valid;
import javax.validation.constraints.*;

// After (jakarta)
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;

// Spring Boot 3.x uses jakarta.* by default
```

---

## üìù Validation Annotations

### Null/Empty Checks

```java
@Data
public class UserRequest {
    
    // @NotNull - Value must not be null
    @NotNull(message = "Username is required")
    private String username;
    
    // @NotEmpty - Collection/String must not be null or empty
    @NotEmpty(message = "Roles cannot be empty")
    private List<String> roles;
    
    // @NotBlank - String must not be null, empty, or whitespace
    @NotBlank(message = "Description cannot be blank")
    private String description;
}

// Comparison:
// null       -> @NotNull ‚ùå, @NotEmpty ‚ùå, @NotBlank ‚ùå
// ""         -> @NotNull ‚úÖ, @NotEmpty ‚ùå, @NotBlank ‚ùå
// "   "      -> @NotNull ‚úÖ, @NotEmpty ‚úÖ, @NotBlank ‚ùå
// "text"     -> @NotNull ‚úÖ, @NotEmpty ‚úÖ, @NotBlank ‚úÖ
```

### Size Constraints

```java
@Data
public class ProductRequest {
    
    // String size
    @Size(min = 3, max = 100, message = "Name must be between 3 and 100 characters")
    private String name;
    
    // Collection size
    @Size(min = 1, max = 10, message = "Must have between 1 and 10 tags")
    private List<String> tags;
    
    // Array size
    @Size(max = 5, message = "Cannot upload more than 5 images")
    private String[] images;
    
    // Map size
    @Size(min = 1, message = "At least one attribute required")
    private Map<String, String> attributes;
}
```

### Numeric Constraints

```java
@Data
public class ProductRequest {
    
    // Min/Max
    @Min(value = 0, message = "Price cannot be negative")
    @Max(value = 999999, message = "Price too high")
    private Integer price;
    
    // Positive/Negative (JSR-380)
    @Positive(message = "Quantity must be positive")
    private Integer quantity;
    
    @PositiveOrZero(message = "Discount cannot be negative")
    private Integer discount;
    
    @Negative(message = "Loss must be negative")
    private Integer loss;
    
    @NegativeOrZero(message = "Refund cannot be positive")
    private Integer refund;
    
    // Decimal constraints
    @DecimalMin(value = "0.01", message = "Price must be at least 0.01")
    @DecimalMax(value = "999999.99", message = "Price cannot exceed 999999.99")
    @Digits(integer = 6, fraction = 2, message = "Price format invalid")
    private BigDecimal price;
}
```

### Date/Time Constraints

```java
@Data
public class EventRequest {
    
    // Past dates
    @Past(message = "Birth date must be in the past")
    private LocalDate birthDate;
    
    @PastOrPresent(message = "Registration date cannot be in the future")
    private LocalDate registrationDate;
    
    // Future dates
    @Future(message = "Event date must be in the future")
    private LocalDate eventDate;
    
    @FutureOrPresent(message = "Start date cannot be in the past")
    private LocalDateTime startDateTime;
}
```

### Pattern Validation

```java
@Data
public class UserRequest {
    
    // Phone number
    @Pattern(
        regexp = "^\\d{10}$",
        message = "Phone must be 10 digits"
    )
    private String phone;
    
    // Zip code
    @Pattern(
        regexp = "^\\d{5}(-\\d{4})?$",
        message = "Invalid zip code format"
    )
    private String zipCode;
    
    // Password
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$",
        message = "Password must contain uppercase, lowercase, digit, and special character"
    )
    private String password;
    
    // URL
    @Pattern(
        regexp = "^https?://.*",
        message = "Must be a valid HTTP(S) URL"
    )
    private String website;
}
```

### Email Validation

```java
@Data
public class ContactRequest {
    
    // Basic email validation
    @Email(message = "Email must be valid")
    private String email;
    
    // Email with pattern
    @Email(
        regexp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
        message = "Email format is invalid"
    )
    private String strictEmail;
}
```

### Boolean Constraints

```java
@Data
public class TermsRequest {
    
    @AssertTrue(message = "You must accept the terms and conditions")
    private Boolean acceptTerms;
    
    @AssertFalse(message = "Account cannot be suspended")
    private Boolean isSuspended;
}
```

---

## üåê Request Validation

### POST Request Validation

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {
        User user = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
}

@Data
public class UserRequest {
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50)
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Must be at least 18")
    private Integer age;
}
```

### PUT Request Validation

```java
@PutMapping("/{id}")
public User updateUser(
        @PathVariable Long id,
        @Valid @RequestBody UserUpdateRequest request) {
    return userService.update(id, request);
}

@Data
public class UserUpdateRequest {
    
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @Email(message = "Email must be valid")
    private String email;
    
    @Min(value = 18, message = "Must be at least 18")
    private Integer age;
    
    // Fields are optional in update, but if provided must be valid
}
```

### Path Parameter Validation

```java
@RestController
@RequestMapping("/api/users")
@Validated // Required for method parameter validation
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(
            @PathVariable 
            @Min(value = 1, message = "ID must be positive") 
            Long id) {
        return userService.findById(id);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(
            @PathVariable 
            @Positive(message = "ID must be positive") 
            Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }
}
```

### Query Parameter Validation

```java
@RestController
@RequestMapping("/api/users")
@Validated
public class UserController {
    
    @GetMapping
    public Page<User> getUsers(
            @RequestParam(defaultValue = "0")
            @Min(value = 0, message = "Page must be non-negative")
            int page,
            
            @RequestParam(defaultValue = "20")
            @Min(value = 1, message = "Size must be at least 1")
            @Max(value = 100, message = "Size cannot exceed 100")
            int size,
            
            @RequestParam(required = false)
            @Pattern(regexp = "^[a-zA-Z]+$", message = "Sort field must contain only letters")
            String sort) {
        
        return userService.findAll(page, size, sort);
    }
}
```

---

## üîó Nested Object Validation

### Simple Nested Validation

```java
@Data
public class OrderRequest {
    
    @NotNull(message = "Customer is required")
    @Valid // Triggers validation on nested object
    private CustomerRequest customer;
    
    @NotEmpty(message = "Order items cannot be empty")
    @Valid // Validates each item in collection
    private List<OrderItemRequest> items;
}

@Data
public class CustomerRequest {
    
    @NotBlank(message = "Customer name is required")
    private String name;
    
    @Email(message = "Email must be valid")
    private String email;
    
    @Valid
    private AddressRequest address;
}

@Data
public class AddressRequest {
    
    @NotBlank(message = "Street is required")
    private String street;
    
    @NotBlank(message = "City is required")
    private String city;
    
    @Pattern(regexp = "^\\d{5}$", message = "Zip code must be 5 digits")
    private String zipCode;
}
```

### Deep Nesting Example

```java
@Data
public class CompanyRequest {
    
    @NotBlank(message = "Company name is required")
    private String name;
    
    @Valid
    @NotNull(message = "Primary contact is required")
    private ContactRequest primaryContact;
    
    @Valid
    private List<DepartmentRequest> departments;
}

@Data
public class DepartmentRequest {
    
    @NotBlank(message = "Department name is required")
    private String name;
    
    @Valid
    @NotNull(message = "Manager is required")
    private EmployeeRequest manager;
    
    @Valid
    private List<EmployeeRequest> employees;
}

@Data
public class EmployeeRequest {
    
    @NotBlank(message = "Employee name is required")
    private String name;
    
    @Email(message = "Email must be valid")
    private String email;
    
    @Valid
    private AddressRequest address;
}

// When validated, all nested objects are validated recursively
```

---

## üì¶ Collection Validation

### List Validation

```java
@Data
public class ProductRequest {
    
    // Validate collection size
    @NotEmpty(message = "At least one tag is required")
    @Size(max = 10, message = "Cannot have more than 10 tags")
    private List<String> tags;
    
    // Validate each element
    @NotEmpty(message = "At least one image is required")
    private List<
        @Pattern(regexp = "^https?://.*", message = "Image must be a valid URL")
        String
    > images;
    
    // Validate nested objects in list
    @NotEmpty(message = "At least one variant is required")
    @Valid
    private List<ProductVariantRequest> variants;
}

@Data
public class ProductVariantRequest {
    
    @NotBlank(message = "Variant name is required")
    private String name;
    
    @Positive(message = "Price must be positive")
    private BigDecimal price;
    
    @PositiveOrZero(message = "Stock cannot be negative")
    private Integer stock;
}
```

### Set Validation

```java
@Data
public class UserRequest {
    
    @NotEmpty(message = "At least one role is required")
    @Size(max = 5, message = "Cannot have more than 5 roles")
    private Set<
        @NotBlank(message = "Role cannot be blank")
        String
    > roles;
    
    @Valid
    private Set<PermissionRequest> permissions;
}
```

### Map Validation

```java
@Data
public class ConfigurationRequest {
    
    @NotEmpty(message = "At least one configuration is required")
    @Size(max = 20, message = "Cannot have more than 20 configurations")
    private Map<
        @NotBlank(message = "Config key cannot be blank")
        String,
        @NotBlank(message = "Config value cannot be blank")
        String
    > settings;
    
    // Validate map values as objects
    @Valid
    private Map<String, DatabaseConfig> databases;
}

@Data
public class DatabaseConfig {
    
    @NotBlank(message = "Host is required")
    private String host;
    
    @Positive(message = "Port must be positive")
    private Integer port;
    
    @NotBlank(message = "Username is required")
    private String username;
}
```

### Array Validation

```java
@Data
public class UploadRequest {
    
    @NotNull(message = "Files are required")
    @Size(min = 1, max = 5, message = "Must upload between 1 and 5 files")
    private String[] fileUrls;
    
    // Validate each element
    private @NotBlank(message = "Category cannot be blank") String[] categories;
}
```

---

## üìå Best Practices

### 1. Use Appropriate Annotations

```java
// ‚úÖ Good - Appropriate for strings
@NotBlank(message = "Name cannot be blank")
private String name;

// ‚ùå Bad - @NotEmpty allows whitespace for strings
@NotEmpty(message = "Name cannot be empty")
private String name;

// ‚úÖ Good - For numbers
@Positive(message = "Price must be positive")
private BigDecimal price;

// ‚ùå Bad - Less clear
@Min(value = 1, message = "Price must be at least 1")
private BigDecimal price;
```

### 2. Meaningful Error Messages

```java
// ‚úÖ Good - Clear, specific messages
@NotBlank(message = "Email is required")
@Email(message = "Email must be in valid format (e.g., user@example.com)")
private String email;

@Size(min = 8, max = 50, message = "Password must be between 8 and 50 characters")
private String password;

// ‚ùå Bad - Generic or no messages
@NotBlank
@Email
private String email;
```

### 3. Validate Nested Objects

```java
// ‚úÖ Good - Use @Valid for nested objects
@Data
public class OrderRequest {
    
    @Valid
    @NotNull(message = "Shipping address is required")
    private AddressRequest shippingAddress;
    
    @Valid
    @NotEmpty(message = "At least one item is required")
    private List<OrderItemRequest> items;
}

// ‚ùå Bad - Missing @Valid, nested objects not validated
@Data
public class OrderRequest {
    @NotNull
    private AddressRequest shippingAddress; // Not validated!
}
```

### 4. Don't Over-Validate

```java
// ‚ùå Bad - Redundant validations
@NotNull
@NotEmpty
@NotBlank
private String name; // @NotBlank includes the other two

// ‚úÖ Good - Single appropriate annotation
@NotBlank(message = "Name is required")
private String name;
```

### 5. Validate at the Right Layer

```java
// ‚úÖ Good - Validation in DTO/Request object
@Data
public class UserRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
}

// ‚ùå Bad - Manual validation in service
@Service
public class UserService {
    public User create(UserRequest request) {
        if (request.getEmail() == null || request.getEmail().isBlank()) {
            throw new ValidationException("Email is required");
        }
        // Duplicate validation logic
    }
}
```

### 6. Use @Valid in Controllers

```java
// ‚úÖ Good - Trigger validation with @Valid
@PostMapping
public User create(@Valid @RequestBody UserRequest request) {
    return userService.create(request);
}

// ‚ùå Bad - Missing @Valid, validation not triggered
@PostMapping
public User create(@RequestBody UserRequest request) {
    return userService.create(request); // Validation skipped!
}
```

---

## üé§ Interview Questions

### Q1: What is Bean Validation?
**Answer:** Java specification (JSR-303/JSR-380) for declarative validation using annotations.

### Q2: What is the difference between JSR-303 and JSR-380?
**Answer:**
- JSR-303: Bean Validation 1.0/1.1 (javax.validation)
- JSR-380: Bean Validation 2.0+ (jakarta.validation), added @NotEmpty, @NotBlank, @Positive, etc.

### Q3: Difference between @NotNull, @NotEmpty, @NotBlank?
**Answer:**
- @NotNull: Value must not be null
- @NotEmpty: Collection/String must not be null or empty
- @NotBlank: String must not be null, empty, or whitespace

### Q4: How to trigger validation?
**Answer:** Use @Valid on controller parameters annotated with @RequestBody, @ModelAttribute.

### Q5: What exception is thrown on validation failure?
**Answer:** MethodArgumentNotValidException for @RequestBody, ConstraintViolationException for path/query params.

### Q6: How to validate nested objects?
**Answer:** Use @Valid on the nested field:
```java
@Valid
@NotNull
private AddressRequest address;
```

### Q7: How to validate collection elements?
**Answer:**
```java
@NotEmpty
@Valid
private List<OrderItemRequest> items;

// Or inline
private List<@NotBlank String> tags;
```

### Q8: What is @Validated annotation?
**Answer:** Spring-specific annotation for method-level validation and validation groups.

### Q9: How to validate path parameters?
**Answer:**
```java
@Validated // On class
@GetMapping("/{id}")
public User get(@PathVariable @Min(1) Long id) { }
```

### Q10: What is hibernate-validator?
**Answer:** Reference implementation of Bean Validation specification.

### Q11: Can you use multiple validation annotations?
**Answer:** Yes, can combine multiple constraints:
```java
@NotBlank
@Size(min = 8, max = 50)
@Pattern(regexp = ".*")
private String password;
```

### Q12: How to create custom error messages?
**Answer:** Use message attribute in annotations:
```java
@NotBlank(message = "Email is required")
@Email(message = "Email must be valid")
private String email;
```

### Q13: What is @Valid vs @Validated?
**Answer:**
- @Valid: Standard JSR-303, validates objects
- @Validated: Spring-specific, supports groups and method validation

### Q14: How to extract validation errors?
**Answer:**
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public Map<String, String> handle(MethodArgumentNotValidException ex) {
    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getFieldErrors().forEach(error -> 
        errors.put(error.getField(), error.getDefaultMessage())
    );
    return errors;
}
```

### Q15: Can you validate query parameters?
**Answer:** Yes, with @Validated on class and constraints on @RequestParam:
```java
@Validated
@GetMapping
public List<User> get(@RequestParam @Min(0) int page) { }
```

### Q16: What is @AssertTrue/@AssertFalse?
**Answer:** Validates that a boolean field is true/false.

### Q17: How to validate email?
**Answer:**
```java
@Email(message = "Email must be valid")
private String email;
```

### Q18: What is @Pattern used for?
**Answer:** Validates string against regular expression pattern.

### Q19: How to validate date ranges?
**Answer:** Use @Past, @PastOrPresent, @Future, @FutureOrPresent or create custom validator.

### Q20: Best practices for Bean Validation?
**Answer:**
1. Use appropriate annotations
2. Meaningful error messages
3. Validate nested objects with @Valid
4. Don't over-validate
5. Validate at DTO layer
6. Use @Valid in controllers
7. Handle exceptions globally

---

## üìö Summary

### Basic Setup

```java
// 1. Add dependency
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

// 2. Create DTO with validation
@Data
public class UserRequest {
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50)
    private String name;
    
    @Email(message = "Email must be valid")
    private String email;
    
    @Min(value = 18, message = "Must be at least 18")
    private Integer age;
}

// 3. Use @Valid in controller
@PostMapping
public User create(@Valid @RequestBody UserRequest request) {
    return userService.create(request);
}

// 4. Handle validation errors
@ExceptionHandler(MethodArgumentNotValidException.class)
public ValidationErrorResponse handle(MethodArgumentNotValidException ex) {
    // Extract and return field errors
}
```

### Common Annotations

- **@NotNull** - Value must not be null
- **@NotEmpty** - Collection/String not null or empty
- **@NotBlank** - String not null, empty, or whitespace
- **@Size** - Size constraints (min, max)
- **@Min/@Max** - Numeric min/max
- **@Positive/@Negative** - Numeric sign
- **@Email** - Email format
- **@Pattern** - Regex pattern
- **@Past/@Future** - Date/time constraints
- **@Valid** - Trigger nested validation

**Next:** Built-in Validators ‚Üí

