# üéØ Group Validation - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Creating Validation Groups](#creating-validation-groups)
- [Using Validation Groups](#using-validation-groups)
- [Group Sequences](#group-sequences)
- [Default Group](#default-group)
- [Group Inheritance](#group-inheritance)
- [Advanced Group Patterns](#advanced-group-patterns)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Validation Groups** allow you to apply different validation rules to the same DTO based on context (create, update, delete, etc.).

### Why Validation Groups?

```
Without Groups:
‚ùå Separate DTOs for create/update
‚ùå Code duplication
‚ùå Hard to maintain

With Groups:
‚úÖ Single DTO
‚úÖ Conditional validation
‚úÖ Cleaner code
‚úÖ Flexible validation rules
```

### Group Validation Flow

```
1. Define group interfaces
2. Assign constraints to groups
3. Trigger validation with @Validated(Group.class)
4. Only specified group constraints validated
```

---

## üì¶ Creating Validation Groups

### Basic Group Interfaces

```java
// Define marker interfaces
public interface CreateGroup {}

public interface UpdateGroup {}

public interface DeleteGroup {}

public interface PartialUpdateGroup {}
```

### Naming Conventions

```java
// ‚úÖ Good - Clear, descriptive names
public interface CreateValidation {}
public interface UpdateValidation {}
public interface AdminValidation {}

// ‚úÖ Also good - Short names
public interface Create {}
public interface Update {}
public interface Admin {}

// ‚ùå Bad - Unclear names
public interface Group1 {}
public interface Group2 {}
public interface ValidationA {}
```

### Domain-Specific Groups

```java
// E-commerce groups
public interface CheckoutGroup {}
public interface PaymentGroup {}
public interface ShippingGroup {}

// User management groups
public interface RegistrationGroup {}
public interface ProfileUpdateGroup {}
public interface PasswordChangeGroup {}

// Admin groups
public interface AdminCreateGroup {}
public interface AdminDeleteGroup {}
```

---

## üéØ Using Validation Groups

### Basic Group Assignment

```java
@Data
public class UserRequest {
    
    // ID required for update, must be null for create
    @Null(
        groups = CreateGroup.class,
        message = "ID must be null when creating user"
    )
    @NotNull(
        groups = UpdateGroup.class,
        message = "ID is required when updating user"
    )
    private Long id;
    
    // Name required for both create and update
    @NotBlank(
        groups = {CreateGroup.class, UpdateGroup.class},
        message = "Name is required"
    )
    @Size(
        min = 2,
        max = 50,
        groups = {CreateGroup.class, UpdateGroup.class}
    )
    private String name;
    
    // Password required only for create
    @NotBlank(
        groups = CreateGroup.class,
        message = "Password is required"
    )
    @Size(
        min = 8,
        groups = CreateGroup.class,
        message = "Password must be at least 8 characters"
    )
    private String password;
    
    // Email required for both
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    @Email(groups = {CreateGroup.class, UpdateGroup.class})
    private String email;
}
```

### Controller Usage

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Create - validates CreateGroup constraints
    @PostMapping
    public ResponseEntity<User> createUser(
        @Validated(CreateGroup.class) @RequestBody UserRequest request
    ) {
        // Validated constraints:
        // - id: must be null
        // - name: required, size 2-50
        // - password: required, min 8 chars
        // - email: required, valid email
        
        User user = userService.create(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
    
    // Update - validates UpdateGroup constraints
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(
        @PathVariable Long id,
        @Validated(UpdateGroup.class) @RequestBody UserRequest request
    ) {
        // Validated constraints:
        // - id: required
        // - name: required, size 2-50
        // - password: NOT validated (no UpdateGroup on password)
        // - email: required, valid email
        
        User user = userService.update(id, request);
        return ResponseEntity.ok(user);
    }
}
```

### Multiple Groups in Same Request

```java
@Data
public class ProductRequest {
    
    @Null(groups = CreateGroup.class)
    @NotNull(groups = UpdateGroup.class)
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    private String name;
    
    @NotNull(groups = CreateGroup.class)
    @Positive(groups = CreateGroup.class)
    private BigDecimal price;
    
    @NotBlank(groups = AdminCreateGroup.class)
    private String internalCode;
    
    @NotNull(groups = AdminCreateGroup.class)
    private String supplierInfo;
}

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // Regular user create - only CreateGroup
    @PostMapping
    public Product createProduct(
        @Validated(CreateGroup.class) @RequestBody ProductRequest request
    ) {
        // Validates: id (null), name, price
        // Does NOT validate: internalCode, supplierInfo
        return productService.create(request);
    }
    
    // Admin create - both CreateGroup AND AdminCreateGroup
    @PostMapping("/admin")
    public Product createProductAsAdmin(
        @Validated({CreateGroup.class, AdminCreateGroup.class}) 
        @RequestBody ProductRequest request
    ) {
        // Validates: id (null), name, price, internalCode, supplierInfo
        return productService.createAsAdmin(request);
    }
}
```

---

## üî¢ Group Sequences

### Basic Sequence

```java
// Define sequence
@GroupSequence({FirstGroup.class, SecondGroup.class, ThirdGroup.class})
public interface OrderedValidation {}

@Data
public class PaymentRequest {
    
    @NotNull(groups = FirstGroup.class)
    private String cardNumber;
    
    @NotNull(groups = SecondGroup.class)
    @ValidCardNumber(groups = SecondGroup.class)  // Custom validator
    private String cardNumberFormatted;
    
    @NotNull(groups = ThirdGroup.class)
    @ValidCVV(groups = ThirdGroup.class)
    private String cvv;
}

// Usage
@PostMapping("/payment")
public Payment processPayment(
    @Validated(OrderedValidation.class) @RequestBody PaymentRequest request
) {
    // Validates in order:
    // 1. FirstGroup - Check cardNumber not null
    // 2. SecondGroup - Validate card format (only if FirstGroup passes)
    // 3. ThirdGroup - Validate CVV (only if SecondGroup passes)
    return paymentService.process(request);
}
```

### Why Use Sequences?

```java
// Without sequence - all validated together
@Data
public class UserRequest {
    @NotBlank  // Checked
    @Email     // Checked even if blank
    private String email;
}

// With sequence - ordered validation
public interface BasicCheck {}
public interface FormatCheck {}

@GroupSequence({BasicCheck.class, FormatCheck.class})
public interface UserValidation {}

@Data
public class UserRequest {
    @NotBlank(groups = BasicCheck.class)
    @Email(groups = FormatCheck.class)  // Only checked if not blank
    private String email;
}
```

### Practical Sequence Example

```java
// Validation order groups
public interface NotNullGroup {}
public interface FormatGroup {}
public interface BusinessRuleGroup {}

@GroupSequence({NotNullGroup.class, FormatGroup.class, BusinessRuleGroup.class})
public interface CompleteValidation {}

@Data
public class OrderRequest {
    
    // Step 1: Check not null
    @NotNull(
        groups = NotNullGroup.class,
        message = "Email is required"
    )
    private String email;
    
    // Step 2: Validate format (only if not null)
    @Email(
        groups = FormatGroup.class,
        message = "Email format is invalid"
    )
    private String emailFormat;
    
    // Step 3: Business validation (only if format valid)
    @UniqueEmail(
        groups = BusinessRuleGroup.class,
        message = "Email already exists"
    )
    private String emailUnique;
    
    // Similar for other fields
    @NotNull(groups = NotNullGroup.class)
    private BigDecimal amount;
    
    @Positive(groups = FormatGroup.class)
    private BigDecimal amountPositive;
    
    @ValidOrderAmount(groups = BusinessRuleGroup.class)
    private BigDecimal amountBusinessRule;
}

@PostMapping("/orders")
public Order createOrder(
    @Validated(CompleteValidation.class) @RequestBody OrderRequest request
) {
    // Validates in order, stops at first failure
    return orderService.create(request);
}
```

---

## üéØ Default Group

### Understanding Default Group

```java
@Data
public class ProductRequest {
    
    // No group specified = Default group
    @NotBlank
    private String name;
    
    @Positive
    private BigDecimal price;
    
    // Specific group
    @NotNull(groups = CreateGroup.class)
    private String sku;
}

// Validates only Default group constraints (name, price)
@PostMapping
public Product create(@Valid @RequestBody ProductRequest request) {
    // name and price validated
    // sku NOT validated
}

// Validates only CreateGroup constraints (sku)
@PostMapping
public Product create(@Validated(CreateGroup.class) @RequestBody ProductRequest request) {
    // Only sku validated
    // name and price NOT validated
}
```

### Combining Default Group

```java
@Data
public class UserRequest {
    
    @NotBlank  // Default group
    private String name;
    
    @NotBlank(groups = CreateGroup.class)
    private String password;
}

// Validate both Default and CreateGroup
@PostMapping
public User create(
    @Validated({Default.class, CreateGroup.class}) @RequestBody UserRequest request
) {
    // Both name and password validated
}
```

### Default Group in Sequences

```java
@GroupSequence({Default.class, ExtendedValidation.class})
public interface CompleteValidation {}

@Data
public class Request {
    
    @NotBlank  // Default group - validated first
    private String name;
    
    @ValidName(groups = ExtendedValidation.class)  // Validated second
    private String nameExtended;
}
```

---

## üß¨ Group Inheritance

### Basic Inheritance

```java
// Base group
public interface CreateGroup {}

// Extended group inherits CreateGroup
public interface AdminCreateGroup extends CreateGroup {}

@Data
public class UserRequest {
    
    @NotBlank(groups = CreateGroup.class)
    private String name;
    
    @NotBlank(groups = AdminCreateGroup.class)
    private String role;
}

// Validates AdminCreateGroup (includes CreateGroup)
@PostMapping("/admin/users")
public User createAsAdmin(
    @Validated(AdminCreateGroup.class) @RequestBody UserRequest request
) {
    // Both name and role validated (AdminCreateGroup extends CreateGroup)
}
```

### Hierarchical Groups

```java
// Base validations
public interface BasicValidation {}

// Extends basic
public interface StandardValidation extends BasicValidation {}

// Extends standard
public interface AdvancedValidation extends StandardValidation {}

@Data
public class ComplexRequest {
    
    @NotBlank(groups = BasicValidation.class)
    private String name;
    
    @Email(groups = StandardValidation.class)
    private String email;
    
    @ValidTaxId(groups = AdvancedValidation.class)
    private String taxId;
}

// Validates AdvancedValidation (includes Standard and Basic)
@PostMapping("/advanced")
public Response create(
    @Validated(AdvancedValidation.class) @RequestBody ComplexRequest request
) {
    // All three validated: name, email, taxId
}
```

---

## üöÄ Advanced Group Patterns

### CRUD Groups Pattern

```java
public interface CreateValidation {}
public interface UpdateValidation {}
public interface PatchValidation {}
public interface DeleteValidation {}

@Data
public class ResourceRequest {
    
    // ID constraints
    @Null(
        groups = CreateValidation.class,
        message = "ID must be null for creation"
    )
    @NotNull(
        groups = {UpdateValidation.class, DeleteValidation.class},
        message = "ID is required"
    )
    private Long id;
    
    // Name constraints
    @NotBlank(
        groups = {CreateValidation.class, UpdateValidation.class},
        message = "Name is required for create and update"
    )
    private String name;
    
    // Optional fields for patch
    @Size(
        min = 10,
        max = 500,
        groups = {CreateValidation.class, UpdateValidation.class, PatchValidation.class}
    )
    private String description;
}

@RestController
@RequestMapping("/api/resources")
public class ResourceController {
    
    @PostMapping
    public Resource create(
        @Validated(CreateValidation.class) @RequestBody ResourceRequest request
    ) {
        return resourceService.create(request);
    }
    
    @PutMapping("/{id}")
    public Resource update(
        @PathVariable Long id,
        @Validated(UpdateValidation.class) @RequestBody ResourceRequest request
    ) {
        return resourceService.update(id, request);
    }
    
    @PatchMapping("/{id}")
    public Resource patch(
        @PathVariable Long id,
        @Validated(PatchValidation.class) @RequestBody ResourceRequest request
    ) {
        return resourceService.patch(id, request);
    }
    
    @DeleteMapping("/{id}")
    public void delete(
        @PathVariable Long id,
        @Validated(DeleteValidation.class) @RequestBody ResourceRequest request
    ) {
        resourceService.delete(id);
    }
}
```

### Role-Based Validation

```java
public interface UserRole {}
public interface AdminRole extends UserRole {}
public interface SuperAdminRole extends AdminRole {}

@Data
public class ArticleRequest {
    
    @NotBlank(groups = UserRole.class)
    private String title;
    
    @NotBlank(groups = UserRole.class)
    private String content;
    
    @NotBlank(groups = AdminRole.class)
    private String category;
    
    @NotNull(groups = AdminRole.class)
    private Boolean featured;
    
    @NotBlank(groups = SuperAdminRole.class)
    private String internalNotes;
}

@RestController
@RequestMapping("/api/articles")
public class ArticleController {
    
    // Regular user
    @PostMapping("/user")
    public Article createAsUser(
        @Validated(UserRole.class) @RequestBody ArticleRequest request
    ) {
        // Validates: title, content
        return articleService.createAsUser(request);
    }
    
    // Admin user
    @PostMapping("/admin")
    public Article createAsAdmin(
        @Validated(AdminRole.class) @RequestBody ArticleRequest request
    ) {
        // Validates: title, content, category, featured
        return articleService.createAsAdmin(request);
    }
    
    // Super admin
    @PostMapping("/superadmin")
    public Article createAsSuperAdmin(
        @Validated(SuperAdminRole.class) @RequestBody ArticleRequest request
    ) {
        // Validates: all fields
        return articleService.createAsSuperAdmin(request);
    }
}
```

### Multi-Step Form Validation

```java
public interface Step1 {}
public interface Step2 {}
public interface Step3 {}

@GroupSequence({Step1.class, Step2.class, Step3.class})
public interface CompleteRegistration {}

@Data
public class RegistrationRequest {
    
    // Step 1: Basic info
    @NotBlank(groups = Step1.class)
    private String username;
    
    @NotBlank(groups = Step1.class)
    @Email(groups = Step1.class)
    private String email;
    
    @NotBlank(groups = Step1.class)
    private String password;
    
    // Step 2: Personal info
    @NotBlank(groups = Step2.class)
    private String firstName;
    
    @NotBlank(groups = Step2.class)
    private String lastName;
    
    @NotNull(groups = Step2.class)
    private LocalDate birthDate;
    
    // Step 3: Address
    @NotBlank(groups = Step3.class)
    private String street;
    
    @NotBlank(groups = Step3.class)
    private String city;
    
    @NotBlank(groups = Step3.class)
    private String zipCode;
}

@RestController
@RequestMapping("/api/register")
public class RegistrationController {
    
    @PostMapping("/step1")
    public StepResult validateStep1(
        @Validated(Step1.class) @RequestBody RegistrationRequest request
    ) {
        return new StepResult(true, "Step 1 completed");
    }
    
    @PostMapping("/step2")
    public StepResult validateStep2(
        @Validated(Step2.class) @RequestBody RegistrationRequest request
    ) {
        return new StepResult(true, "Step 2 completed");
    }
    
    @PostMapping("/step3")
    public StepResult validateStep3(
        @Validated(Step3.class) @RequestBody RegistrationRequest request
    ) {
        return new StepResult(true, "Step 3 completed");
    }
    
    @PostMapping("/complete")
    public User completeRegistration(
        @Validated(CompleteRegistration.class) @RequestBody RegistrationRequest request
    ) {
        // Validates all steps in sequence
        return registrationService.complete(request);
    }
}
```

---

## üí° Best Practices

### 1. Clear Group Naming

```java
// ‚úÖ Good - Clear intent
public interface CreateValidation {}
public interface UpdateValidation {}

// ‚ùå Bad - Unclear
public interface Group1 {}
public interface Group2 {}
```

### 2. Use Sequences for Dependent Validation

```java
// ‚úÖ Good - Sequential validation
@GroupSequence({NotNullCheck.class, FormatCheck.class, BusinessRuleCheck.class})
public interface OrderedValidation {}

// ‚ùå Bad - All validated together (expensive business rules run even if format invalid)
@Validated({NotNullCheck.class, FormatCheck.class, BusinessRuleCheck.class})
```

### 3. Don't Over-Engineer

```java
// ‚úÖ Good - Simple, clear
public interface Create {}
public interface Update {}

// ‚ùå Bad - Too many groups
public interface CreateWithEmailValidation {}
public interface CreateWithPhoneValidation {}
public interface CreateWithEmailAndPhoneValidation {}
```

### 4. Document Group Purpose

```java
/**
 * Validation group for user creation.
 * Validates: email, password, username (all required)
 * ID must be null.
 */
public interface CreateUserValidation {}

/**
 * Validation group for user profile update.
 * Validates: email, username
 * Password not validated (use separate endpoint)
 * ID must be present.
 */
public interface UpdateUserValidation {}
```

### 5. Combine with Default Group When Needed

```java
@Data
public class Request {
    
    @NotBlank  // Always validated
    private String name;
    
    @NotBlank(groups = CreateGroup.class)
    private String password;
}

// Validate both default and create group
@PostMapping
public Response create(
    @Validated({Default.class, CreateGroup.class}) @RequestBody Request request
) {
    // Both name and password validated
}
```

---

## üé§ Interview Questions

### Q1: What are validation groups?
**Answer:** Marker interfaces to conditionally apply validation constraints based on context.

### Q2: How to define a validation group?
**Answer:** Create an empty interface:
```java
public interface CreateGroup {}
```

### Q3: How to assign constraint to a group?
**Answer:** Use `groups` attribute:
```java
@NotNull(groups = CreateGroup.class)
private Long id;
```

### Q4: How to validate specific group?
**Answer:** Use @Validated:
```java
@Validated(CreateGroup.class) @RequestBody Request request
```

### Q5: What is @GroupSequence?
**Answer:** Defines order of group validation, stops at first failure.

### Q6: Can groups inherit from other groups?
**Answer:** Yes, interfaces can extend other interfaces:
```java
public interface AdminGroup extends UserGroup {}
```

### Q7: What is the Default group?
**Answer:** `jakarta.validation.groups.Default` - used when no group specified on constraint.

### Q8: How to validate multiple groups?
**Answer:**
```java
@Validated({CreateGroup.class, AdminGroup.class})
```

### Q9: When to use validation groups?
**Answer:** When same DTO needs different validation rules (create vs update).

### Q10: Can @Valid use groups?
**Answer:** No, only @Validated supports groups.

### Q11: What happens in group sequence?
**Answer:** Groups validated in order, stops at first violation.

### Q12: How to validate Default + Custom group?
**Answer:**
```java
@Validated({Default.class, CreateGroup.class})
```

### Q13: Can same constraint be in multiple groups?
**Answer:** Yes:
```java
@NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
```

### Q14: Best practice for group naming?
**Answer:** Use clear, descriptive names like `CreateValidation`, `UpdateValidation`.

### Q15: Difference between group sequence and multiple groups?
**Answer:**
- Sequence: Ordered, stops at first failure
- Multiple: All validated together

### Q16: Can you use groups in service layer?
**Answer:** Yes, with @Validated:
```java
@Service
@Validated
public class UserService {
    public void create(@Validated(CreateGroup.class) UserRequest req) {}
}
```

### Q17: How to handle group validation errors?
**Answer:** Same as regular validation - MethodArgumentNotValidException or ConstraintViolationException.

### Q18: Can groups be nested?
**Answer:** Yes, through inheritance:
```java
public interface Level2 extends Level1 {}
```

### Q19: Performance impact of groups?
**Answer:** Minimal - only specified group constraints are evaluated.

### Q20: Common group validation pattern?
**Answer:** CRUD pattern with Create, Update, Delete groups on same DTO.

---

## üìö Summary

### Quick Reference

```java
// Define groups
public interface CreateGroup {}
public interface UpdateGroup {}

// Assign to constraints
@Data
public class Request {
    @Null(groups = CreateGroup.class)
    @NotNull(groups = UpdateGroup.class)
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    private String name;
}

// Use in controller
@PostMapping
public Response create(@Validated(CreateGroup.class) @RequestBody Request req) {}

@PutMapping
public Response update(@Validated(UpdateGroup.class) @RequestBody Request req) {}

// Group sequence
@GroupSequence({First.class, Second.class})
public interface Ordered {}

// Group inheritance
public interface AdminGroup extends UserGroup {}
```

### Key Concepts

| Concept | Description | Example |
|---------|-------------|---------|
| **Group** | Marker interface | `public interface CreateGroup {}` |
| **Assignment** | Add to constraint | `@NotNull(groups = CreateGroup.class)` |
| **Validation** | Use @Validated | `@Validated(CreateGroup.class)` |
| **Sequence** | Ordered validation | `@GroupSequence({A.class, B.class})` |
| **Inheritance** | Group extends group | `interface Admin extends User {}` |
| **Multiple** | Validate many groups | `@Validated({A.class, B.class})` |
| **Default** | No group specified | Automatically `Default.class` |

**Next:** Validation Messages ‚Üí

