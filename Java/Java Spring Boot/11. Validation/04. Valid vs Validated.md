# ‚öñÔ∏è @Valid vs @Validated - Complete Comparison

## üìã Table of Contents
- [Introduction](#introduction)
- [Core Differences](#core-differences)
- [@Valid Annotation](#valid-annotation)
- [@Validated Annotation](#validated-annotation)
- [Validation Groups](#validation-groups)
- [Method Validation](#method-validation)
- [Use Cases Comparison](#use-cases-comparison)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

Both `@Valid` and `@Validated` trigger Bean Validation, but they have **different capabilities and use cases**.

### Quick Comparison

| Feature | @Valid | @Validated |
|---------|--------|------------|
| **Origin** | Jakarta (JSR 380) | Spring Framework |
| **Package** | `jakarta.validation.Valid` | `org.springframework.validation.annotation.Validated` |
| **Validation Groups** | ‚ùå No | ‚úÖ Yes |
| **Method Validation** | ‚ùå No | ‚úÖ Yes |
| **Class Level** | ‚ùå No | ‚úÖ Yes |
| **Nested Objects** | ‚úÖ Yes | ‚úÖ Yes |
| **Controller Parameters** | ‚úÖ Yes | ‚úÖ Yes |
| **Spring Proxy Required** | ‚ùå No | ‚úÖ Yes |

---

## üîç Core Differences

### @Valid - Jakarta Bean Validation

```java
import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // Basic validation - no groups support
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserRequest request) {
        // All constraints validated
        return ResponseEntity.ok(userService.create(request));
    }
    
    // Nested object validation
    @Data
    public class UserRequest {
        @NotBlank
        private String name;
        
        @Valid  // Validates nested object
        private AddressRequest address;
    }
}
```

### @Validated - Spring Specific

```java
import org.springframework.validation.annotation.Validated;

@RestController
@RequestMapping("/api/users")
@Validated  // Enables method-level validation
public class UserController {
    
    // With validation groups
    @PostMapping
    public ResponseEntity<User> createUser(
        @Validated(CreateGroup.class) @RequestBody UserRequest request
    ) {
        // Only CreateGroup constraints validated
        return ResponseEntity.ok(userService.create(request));
    }
    
    // Method parameter validation
    @GetMapping("/{id}")
    public User getUser(@PathVariable @Min(1) Long id) {
        // Validates id > 0
        return userService.findById(id);
    }
}
```

---

## ‚úÖ @Valid Annotation

### Basic Usage

```java
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    // Validate request body
    @PostMapping
    public ResponseEntity<Product> createProduct(
        @Valid @RequestBody ProductRequest request
    ) {
        return ResponseEntity.ok(productService.create(request));
    }
}

@Data
public class ProductRequest {
    @NotBlank(message = "Name is required")
    private String name;
    
    @NotNull(message = "Price is required")
    @Positive(message = "Price must be positive")
    private BigDecimal price;
    
    @Min(value = 0, message = "Stock cannot be negative")
    private Integer stock;
}
```

### Nested Object Validation

```java
@Data
public class OrderRequest {
    
    @NotBlank
    private String orderNumber;
    
    @Valid  // ‚úÖ Triggers validation on nested object
    @NotNull
    private CustomerInfo customer;
    
    @Valid  // ‚úÖ Validates each item in list
    @NotEmpty(message = "Order must have at least one item")
    private List<OrderItemRequest> items;
}

@Data
public class CustomerInfo {
    @NotBlank
    private String name;
    
    @Email
    private String email;
    
    @Valid  // ‚úÖ Nested validation continues
    private AddressInfo address;
}

@Data
public class AddressInfo {
    @NotBlank
    private String street;
    
    @NotBlank
    private String city;
    
    @Pattern(regexp = "\\d{5}")
    private String zipCode;
}
```

### Collection Validation

```java
@Data
public class BatchUserRequest {
    
    @Valid  // ‚úÖ Validates each user in the list
    @NotEmpty(message = "User list cannot be empty")
    private List<UserRequest> users;
}

@Data
public class UserRequest {
    @NotBlank
    private String name;
    
    @Email
    private String email;
}

// POST /api/users/batch
// All users in list will be validated
```

### Map Validation

```java
@Data
public class ConfigRequest {
    
    @Valid  // ‚úÖ Validates each value in map
    private Map<String, @NotBlank String> settings;
    
    // Keys and values both validated
    private Map<@NotBlank String, @Valid SettingValue> configurations;
}
```

### Limitations of @Valid

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // ‚ùå Cannot use validation groups with @Valid
    @PostMapping
    public User createUser(@Valid @RequestBody UserRequest request) {
        // All constraints validated, no way to select groups
    }
    
    // ‚ùå Cannot validate method parameters
    @GetMapping("/{id}")
    public User getUser(@PathVariable @Min(1) Long id) {
        // @Min is ignored with just @Valid
    }
    
    // ‚ùå Cannot validate return values
    @GetMapping
    @Valid  // Not supported
    public List<User> getAllUsers() {
        return userService.findAll();
    }
}
```

---

## ‚úîÔ∏è @Validated Annotation

### Class-Level Usage

```java
@RestController
@RequestMapping("/api/products")
@Validated  // ‚úÖ Enables method-level validation
public class ProductController {
    
    // Method parameters validated
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable @Min(1) Long id) {
        // Validates id >= 1
        return productService.findById(id);
    }
    
    // Query parameters validated
    @GetMapping("/search")
    public List<Product> search(
        @RequestParam @NotBlank String query,
        @RequestParam @Min(1) @Max(100) int limit
    ) {
        return productService.search(query, limit);
    }
}
```

### Validation Groups Support

```java
// Define validation groups
public interface CreateGroup {}
public interface UpdateGroup {}

@Data
public class UserRequest {
    
    @Null(groups = CreateGroup.class, message = "ID must be null for creation")
    @NotNull(groups = UpdateGroup.class, message = "ID is required for update")
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    private String name;
    
    @NotBlank(groups = CreateGroup.class, message = "Password required for creation")
    @Null(groups = UpdateGroup.class, message = "Use separate endpoint to change password")
    private String password;
    
    @Email(groups = {CreateGroup.class, UpdateGroup.class})
    private String email;
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // Validates only CreateGroup constraints
    @PostMapping
    public User createUser(
        @Validated(CreateGroup.class) @RequestBody UserRequest request
    ) {
        // id must be null
        // name, email, password must be present
        return userService.create(request);
    }
    
    // Validates only UpdateGroup constraints
    @PutMapping("/{id}")
    public User updateUser(
        @PathVariable Long id,
        @Validated(UpdateGroup.class) @RequestBody UserRequest request
    ) {
        // id must be present
        // name, email must be present
        // password must be null
        return userService.update(id, request);
    }
}
```

### Method Validation

```java
@Service
@Validated  // ‚úÖ Required for method validation
public class UserService {
    
    // Validate method parameters
    public User findById(@Min(1) Long id) {
        // Throws ConstraintViolationException if id < 1
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }
    
    // Validate return value
    @NotNull
    public User createUser(@Valid UserRequest request) {
        // Method must return non-null User
        User user = new User();
        // ... set fields
        return user;  // Validated on return
    }
    
    // Multiple parameter validation
    public List<User> search(
        @NotBlank String query,
        @Min(0) Integer page,
        @Min(1) @Max(100) Integer size
    ) {
        return userRepository.search(query, page, size);
    }
}
```

### Spring Proxy Requirement

```java
// ‚úÖ Good - @Validated on Spring-managed bean
@Service
@Validated
public class ProductService {
    
    public Product findById(@Min(1) Long id) {
        // Works - ProductService is Spring proxy
    }
}

// ‚ùå Bad - Direct instantiation
ProductService service = new ProductService();
service.findById(-1);  // Validation NOT triggered

// ‚úÖ Good - Autowired (uses proxy)
@Autowired
private ProductService productService;

productService.findById(-1);  // Validation triggered
```

---

## üéØ Validation Groups

### Default Group

```java
@Data
public class UserRequest {
    // Default group (no group specified)
    @NotBlank
    private String name;
    
    @Email
    private String email;
}

// Validates default group
@PostMapping
public User create(@Validated @RequestBody UserRequest request) {
    // Both name and email validated
}
```

### Multiple Groups

```java
public interface CreateGroup {}
public interface UpdateGroup {}
public interface AdminGroup {}

@Data
public class UserRequest {
    
    @Null(groups = CreateGroup.class)
    @NotNull(groups = {UpdateGroup.class, AdminGroup.class})
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    private String name;
    
    @NotBlank(groups = CreateGroup.class)
    private String password;
    
    @NotBlank(groups = AdminGroup.class)
    private String role;
}

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    // Create - validates CreateGroup
    @PostMapping
    public User create(
        @Validated(CreateGroup.class) @RequestBody UserRequest request
    ) {
        // id: null, name: required, password: required, role: not validated
    }
    
    // Update - validates UpdateGroup
    @PutMapping("/{id}")
    public User update(
        @PathVariable Long id,
        @Validated(UpdateGroup.class) @RequestBody UserRequest request
    ) {
        // id: required, name: required, password: not validated, role: not validated
    }
    
    // Admin update - validates AdminGroup
    @PutMapping("/{id}/admin")
    public User updateAsAdmin(
        @PathVariable Long id,
        @Validated(AdminGroup.class) @RequestBody UserRequest request
    ) {
        // id: required, role: required, name: not validated, password: not validated
    }
    
    // Multiple groups
    @PostMapping("/admin")
    public User createAsAdmin(
        @Validated({CreateGroup.class, AdminGroup.class}) @RequestBody UserRequest request
    ) {
        // Validates both CreateGroup AND AdminGroup constraints
    }
}
```

### Group Inheritance

```java
public interface CreateGroup {}
public interface UpdateGroup extends CreateGroup {}  // Inherits CreateGroup

@Data
public class ProductRequest {
    
    @NotBlank(groups = CreateGroup.class)
    private String name;
    
    @NotNull(groups = UpdateGroup.class)
    private Long id;
}

// Validates UpdateGroup (includes CreateGroup)
@PutMapping
public Product update(
    @Validated(UpdateGroup.class) @RequestBody ProductRequest request
) {
    // Both name and id validated (UpdateGroup includes CreateGroup)
}
```

---

## üîß Method Validation

### Service Layer Validation

```java
@Service
@Validated  // ‚úÖ Required for method validation
public class OrderService {
    
    private final OrderRepository orderRepository;
    
    // Validate parameters
    public Order findById(@NotNull @Min(1) Long id) {
        return orderRepository.findById(id)
            .orElseThrow(() -> new OrderNotFoundException(id));
    }
    
    // Validate complex parameters
    public Order createOrder(
        @NotNull @Valid OrderRequest request,
        @NotNull @Min(1) Long userId
    ) {
        Order order = new Order();
        // ... set fields
        return orderRepository.save(order);
    }
    
    // Validate return value
    @NotNull
    public List<Order> findByUserId(@NotNull Long userId) {
        List<Order> orders = orderRepository.findByUserId(userId);
        // Must return non-null list (can be empty)
        return orders != null ? orders : Collections.emptyList();
    }
}
```

### Exception Handling

```java
@RestControllerAdvice
public class ValidationExceptionHandler {
    
    // Handle @Valid violations (controller level)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationErrors(
        MethodArgumentNotValidException ex
    ) {
        Map<String, String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .collect(Collectors.toMap(
                FieldError::getField,
                FieldError::getDefaultMessage
            ));
        
        ErrorResponse response = new ErrorResponse("Validation failed", errors);
        return ResponseEntity.badRequest().body(response);
    }
    
    // Handle @Validated violations (method level)
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ErrorResponse> handleConstraintViolations(
        ConstraintViolationException ex
    ) {
        Map<String, String> errors = ex.getConstraintViolations()
            .stream()
            .collect(Collectors.toMap(
                violation -> violation.getPropertyPath().toString(),
                ConstraintViolation::getMessage
            ));
        
        ErrorResponse response = new ErrorResponse("Constraint violation", errors);
        return ResponseEntity.badRequest().body(response);
    }
}
```

---

## üìä Use Cases Comparison

### When to Use @Valid

| Use Case | @Valid | Example |
|----------|--------|---------|
| **Controller request body** | ‚úÖ Yes | `@Valid @RequestBody UserRequest request` |
| **Nested object validation** | ‚úÖ Yes | `@Valid private AddressRequest address;` |
| **List/Collection validation** | ‚úÖ Yes | `@Valid List<UserRequest> users;` |
| **Simple validation (no groups)** | ‚úÖ Yes | Basic DTOs without conditional logic |
| **Standard JSR 380 compliance** | ‚úÖ Yes | Portable across frameworks |

```java
// ‚úÖ Good use of @Valid
@PostMapping("/register")
public User register(@Valid @RequestBody UserRegistrationRequest request) {
    // Simple validation, no groups needed
    return userService.register(request);
}

@Data
public class UserRegistrationRequest {
    @NotBlank
    private String username;
    
    @Email
    private String email;
    
    @Valid  // Nested validation
    private AddressRequest address;
}
```

### When to Use @Validated

| Use Case | @Validated | Example |
|----------|------------|---------|
| **Validation groups** | ‚úÖ Yes | `@Validated(CreateGroup.class)` |
| **Method parameter validation** | ‚úÖ Yes | `public User find(@Min(1) Long id)` |
| **Service layer validation** | ‚úÖ Yes | `@Validated @Service public class UserService` |
| **Class-level validation** | ‚úÖ Yes | `@Validated public class UserController` |
| **Conditional validation** | ‚úÖ Yes | Different rules for create/update |

```java
// ‚úÖ Good use of @Validated
@RestController
@Validated  // Enable method validation
@RequestMapping("/api/users")
public class UserController {
    
    // Validation groups
    @PostMapping
    public User create(@Validated(CreateGroup.class) @RequestBody UserRequest request) {
        return userService.create(request);
    }
    
    @PutMapping("/{id}")
    public User update(
        @PathVariable @Min(1) Long id,  // Method parameter validation
        @Validated(UpdateGroup.class) @RequestBody UserRequest request
    ) {
        return userService.update(id, request);
    }
}
```

---

## üí° Best Practices

### 1. Choose Based on Requirements

```java
// ‚úÖ Simple validation - use @Valid
@PostMapping("/products")
public Product create(@Valid @RequestBody ProductRequest request) {
    // No groups needed
}

// ‚úÖ Conditional validation - use @Validated
@PostMapping("/users")
public User create(@Validated(CreateGroup.class) @RequestBody UserRequest request) {
    // Different rules for create vs update
}
```

### 2. Combine Both When Needed

```java
@RestController
@Validated  // For method parameter validation
@RequestMapping("/api/orders")
public class OrderController {
    
    @PostMapping
    public Order create(
        @Valid @RequestBody OrderRequest request,  // Nested validation
        @Min(1) Long userId  // Method parameter validation
    ) {
        return orderService.create(request, userId);
    }
}
```

### 3. Service Layer Validation

```java
// ‚úÖ Use @Validated for service layer
@Service
@Validated
public class UserService {
    
    public User findById(@Min(1) Long id) {
        // Validation at service level
    }
}
```

### 4. Group Organization

```java
// ‚úÖ Good - Clear group naming
public interface CreateGroup {}
public interface UpdateGroup {}
public interface DeleteGroup {}

// ‚ùå Bad - Unclear names
public interface Group1 {}
public interface Group2 {}
```

### 5. Don't Mix Validation Layers

```java
// ‚ùå Bad - Validation in multiple layers
@RestController
public class UserController {
    @PostMapping
    public User create(@Valid @RequestBody UserRequest request) {
        if (request.getEmail() == null) {  // Don't do this
            throw new ValidationException("Email required");
        }
        return userService.create(request);
    }
}

// ‚úÖ Good - Validation in constraints
@Data
public class UserRequest {
    @NotNull(message = "Email required")
    @Email
    private String email;
}
```

---

## üé§ Interview Questions

### Q1: What is the main difference between @Valid and @Validated?
**Answer:** @Valid is Jakarta standard (no groups), @Validated is Spring-specific (supports groups + method validation).

### Q2: Can @Valid support validation groups?
**Answer:** No, @Valid doesn't support validation groups. Use @Validated for groups.

### Q3: Which annotation is required for method parameter validation?
**Answer:** @Validated at class level enables method parameter validation.

### Q4: Can you use @Valid in service layer?
**Answer:** Yes, but only for nested object validation. For method parameters, use @Validated.

### Q5: What package does @Valid come from?
**Answer:** `jakarta.validation.Valid` (formerly javax.validation)

### Q6: What package does @Validated come from?
**Answer:** `org.springframework.validation.annotation.Validated`

### Q7: Do you need Spring proxy for @Valid?
**Answer:** No, @Valid works without Spring proxy. @Validated requires Spring proxy.

### Q8: How to validate method return values?
**Answer:** Use @Validated at class level, add constraint to return type:
```java
@NotNull
public User findById(Long id) { ... }
```

### Q9: Can you combine @Valid and @Validated?
**Answer:** Yes, use @Validated for groups/method validation, @Valid for nested objects.

### Q10: What exception does @Valid throw?
**Answer:** `MethodArgumentNotValidException` in controllers.

### Q11: What exception does @Validated throw?
**Answer:** `ConstraintViolationException` for method parameter violations.

### Q12: How to validate path variables?
**Answer:** Use @Validated at class level:
```java
@Validated
@RestController
public class UserController {
    @GetMapping("/{id}")
    public User get(@PathVariable @Min(1) Long id) { }
}
```

### Q13: Can @Valid validate collections?
**Answer:** Yes, use `@Valid List<UserRequest> users` to validate each item.

### Q14: What are validation groups?
**Answer:** Interfaces to conditionally apply constraints:
```java
@NotNull(groups = CreateGroup.class)
private Long id;
```

### Q15: When to use validation groups?
**Answer:** When same DTO has different validation rules (create vs update).

### Q16: Can groups inherit from other groups?
**Answer:** Yes, interfaces can extend other interfaces for group inheritance.

### Q17: How to validate multiple groups?
**Answer:**
```java
@Validated({CreateGroup.class, AdminGroup.class})
```

### Q18: Default group in Bean Validation?
**Answer:** `jakarta.validation.groups.Default` - used when no group specified.

### Q19: Can @Validated validate nested objects?
**Answer:** Yes, but use @Valid for cascade validation on nested fields.

### Q20: Best practice for choosing between them?
**Answer:**
- Simple validation ‚Üí @Valid
- Groups/method validation ‚Üí @Validated
- Nested objects ‚Üí @Valid
- Service layer ‚Üí @Validated

---

## üìö Summary

### Quick Decision Guide

```
Need validation groups?
‚îú‚îÄ YES ‚Üí Use @Validated
‚îî‚îÄ NO
   ‚îú‚îÄ Need method parameter validation?
   ‚îÇ  ‚îú‚îÄ YES ‚Üí Use @Validated
   ‚îÇ  ‚îî‚îÄ NO
   ‚îÇ     ‚îú‚îÄ Service layer?
   ‚îÇ     ‚îÇ  ‚îú‚îÄ YES ‚Üí Use @Validated
   ‚îÇ     ‚îÇ  ‚îî‚îÄ NO ‚Üí Use @Valid (standard)
   ‚îÇ     ‚îî‚îÄ Controller request body?
   ‚îÇ        ‚îî‚îÄ Use @Valid (or @Validated)
```

### Comparison Table

| Aspect | @Valid | @Validated |
|--------|--------|------------|
| **Standard** | Jakarta (JSR 380) | Spring |
| **Groups** | ‚ùå | ‚úÖ |
| **Method Validation** | ‚ùå | ‚úÖ |
| **Nested Objects** | ‚úÖ | ‚úÖ |
| **Collections** | ‚úÖ | ‚úÖ |
| **Spring Proxy** | ‚ùå Not required | ‚úÖ Required |
| **Controller Params** | ‚úÖ | ‚úÖ |
| **Service Layer** | ‚ö†Ô∏è Limited | ‚úÖ Full support |

### Common Patterns

```java
// Pattern 1: Simple validation
@PostMapping
public User create(@Valid @RequestBody UserRequest request) { }

// Pattern 2: With groups
@PostMapping
public User create(@Validated(CreateGroup.class) @RequestBody UserRequest request) { }

// Pattern 3: Method validation
@Validated
@Service
public class UserService {
    public User findById(@Min(1) Long id) { }
}

// Pattern 4: Combined
@Validated
@RestController
public class UserController {
    @PostMapping
    public User create(
        @Valid @RequestBody UserRequest request,
        @Min(1) Long userId
    ) { }
}
```

**Next:** Group Validation ‚Üí

