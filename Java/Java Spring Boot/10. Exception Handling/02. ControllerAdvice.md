# üåê ControllerAdvice - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Basic ControllerAdvice](#basic-controlleradvice)
- [Global Exception Handling](#global-exception-handling)
- [RestControllerAdvice](#restcontrolleradvice)
- [Targeting Specific Controllers](#targeting-specific-controllers)
- [Model Attributes](#model-attributes)
- [InitBinder](#initbinder)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**@ControllerAdvice** is a specialization of @Component for global exception handling and cross-cutting concerns across all controllers.

### Why ControllerAdvice?

```
Without ControllerAdvice:
‚ùå Duplicate exception handlers in every controller
‚ùå Inconsistent error handling
‚ùå Hard to maintain

With ControllerAdvice:
‚úÖ Centralized exception handling
‚úÖ Consistent error responses
‚úÖ DRY principle
‚úÖ Easy to maintain
‚úÖ Cross-cutting concerns
```

### How It Works

```
Request ‚Üí Controller ‚Üí Exception
                          ‚Üì
            @ControllerAdvice catches
                          ‚Üì
            @ExceptionHandler methods
                          ‚Üì
            Format response
                          ‚Üì
            Return to client
```

---

## üîß Basic ControllerAdvice

### Simple Global Handler

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            WebRequest request) {
        
        log.warn("Resource not found: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex,
            WebRequest request) {
        
        log.error("Unexpected error occurred", ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message("An unexpected error occurred. Please try again later.")
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

### Error Response DTO

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ErrorResponse {
    private int status;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
```

---

## üåç Global Exception Handling

### Comprehensive Exception Handler

```java
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // 404 - Not Found
    @ExceptionHandler({
        UserNotFoundException.class,
        ProductNotFoundException.class,
        OrderNotFoundException.class
    })
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ResponseEntity<ErrorResponse> handleNotFound(
            RuntimeException ex,
            HttpServletRequest request) {
        
        log.warn("Resource not found: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // 400 - Bad Request
    @ExceptionHandler({
        InvalidRequestException.class,
        IllegalArgumentException.class
    })
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<ErrorResponse> handleBadRequest(
            RuntimeException ex,
            HttpServletRequest request) {
        
        log.warn("Bad request: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.BAD_REQUEST.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    // 409 - Conflict
    @ExceptionHandler({
        DuplicateEmailException.class,
        ResourceAlreadyExistsException.class
    })
    @ResponseStatus(HttpStatus.CONFLICT)
    public ResponseEntity<ErrorResponse> handleConflict(
            RuntimeException ex,
            HttpServletRequest request) {
        
        log.warn("Conflict: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.CONFLICT.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }
    
    // 401 - Unauthorized
    @ExceptionHandler(UnauthorizedException.class)
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public ResponseEntity<ErrorResponse> handleUnauthorized(
            UnauthorizedException ex,
            HttpServletRequest request) {
        
        log.warn("Unauthorized access attempt: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.UNAUTHORIZED.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .header("WWW-Authenticate", "Bearer")
            .body(error);
    }
    
    // 403 - Forbidden
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public ResponseEntity<ErrorResponse> handleAccessDenied(
            AccessDeniedException ex,
            HttpServletRequest request) {
        
        log.warn("Access denied: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.FORBIDDEN.value())
            .message("You don't have permission to access this resource")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }
    
    // 422 - Validation Error
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.UNPROCESSABLE_ENTITY)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {
        
        log.warn("Validation failed for request: {}", request.getRequestURI());
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .status(HttpStatus.UNPROCESSABLE_ENTITY.value())
            .message("Validation failed")
            .errors(errors)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(errorResponse);
    }
    
    // 500 - Internal Server Error
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex,
            HttpServletRequest request) {
        
        log.error("Unexpected error occurred at {}", request.getRequestURI(), ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message("An unexpected error occurred. Please contact support.")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    // Database Exceptions
    @ExceptionHandler(DataIntegrityViolationException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(
            DataIntegrityViolationException ex,
            HttpServletRequest request) {
        
        log.error("Data integrity violation", ex);
        
        String message = "Database constraint violation";
        if (ex.getMessage().contains("Duplicate entry")) {
            message = "Duplicate entry. Record already exists.";
        }
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.CONFLICT.value())
            .message(message)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }
    
    // HTTP Message Not Readable
    @ExceptionHandler(HttpMessageNotReadableException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ResponseEntity<ErrorResponse> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpServletRequest request) {
        
        log.warn("Malformed JSON request", ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Malformed JSON request")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
}
```

### Validation Error Response

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ValidationErrorResponse {
    private int status;
    private String message;
    private Map<String, String> errors;
    private String path;
    private LocalDateTime timestamp;
}
```

---

## üéØ RestControllerAdvice

### Using @RestControllerAdvice

```java
@RestControllerAdvice
@Slf4j
public class RestExceptionHandler {
    
    // No need for @ResponseBody, automatically serialized to JSON
    
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleUserNotFound(UserNotFoundException ex) {
        log.warn("User not found: {}", ex.getMessage());
        
        return ErrorResponse.builder()
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    @ExceptionHandler(InvalidCredentialsException.class)
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public ErrorResponse handleInvalidCredentials(InvalidCredentialsException ex) {
        log.warn("Invalid credentials attempt");
        
        return ErrorResponse.builder()
            .status(HttpStatus.UNAUTHORIZED.value())
            .message("Invalid email or password")
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### Difference: @ControllerAdvice vs @RestControllerAdvice

```java
// @ControllerAdvice - Need @ResponseBody
@ControllerAdvice
public class GlobalHandler {
    
    @ExceptionHandler(Exception.class)
    @ResponseBody // Need this
    public ErrorResponse handle(Exception ex) {
        return new ErrorResponse(...);
    }
}

// @RestControllerAdvice - No need @ResponseBody
@RestControllerAdvice
public class RestHandler {
    
    @ExceptionHandler(Exception.class)
    // @ResponseBody not needed
    public ErrorResponse handle(Exception ex) {
        return new ErrorResponse(...);
    }
}
```

---

## üéØ Targeting Specific Controllers

### By Package

```java
@RestControllerAdvice(basePackages = "com.example.api.controllers")
public class ApiExceptionHandler {
    // Handles exceptions only from controllers in this package
    
    @ExceptionHandler(ApiException.class)
    public ResponseEntity<ErrorResponse> handleApiException(ApiException ex) {
        return ResponseEntity.status(400).body(createError(ex));
    }
}
```

### By Controller Class

```java
@RestControllerAdvice(assignableTypes = {UserController.class, ProductController.class})
public class DomainExceptionHandler {
    // Handles exceptions only from specified controllers
    
    @ExceptionHandler(DomainException.class)
    public ResponseEntity<ErrorResponse> handleDomainException(DomainException ex) {
        return ResponseEntity.status(400).body(createError(ex));
    }
}
```

### By Annotation

```java
// Custom annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiController {
}

// Apply to controllers
@RestController
@ApiController
public class UserController { }

// Target in ControllerAdvice
@RestControllerAdvice(annotations = ApiController.class)
public class ApiExceptionHandler {
    // Handles exceptions only from @ApiController controllers
}
```

### Multiple Handlers for Different Scopes

```java
// Global handler for all controllers
@RestControllerAdvice
@Order(Ordered.LOWEST_PRECEDENCE)
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ErrorResponse handleGeneric(Exception ex) {
        return createError(ex);
    }
}

// Specific handler for API controllers
@RestControllerAdvice(basePackages = "com.example.api")
@Order(Ordered.HIGHEST_PRECEDENCE)
public class ApiExceptionHandler {
    @ExceptionHandler(ApiException.class)
    public ErrorResponse handleApi(ApiException ex) {
        return createError(ex);
    }
}
```

---

## üé® Model Attributes

### Adding Common Attributes

```java
@ControllerAdvice
public class GlobalControllerAdvice {
    
    @ModelAttribute("appName")
    public String getAppName() {
        return "My Application";
    }
    
    @ModelAttribute("version")
    public String getVersion() {
        return "1.0.0";
    }
    
    @ModelAttribute("currentYear")
    public int getCurrentYear() {
        return LocalDate.now().getYear();
    }
}

// Available in all views
// ${appName}, ${version}, ${currentYear}
```

### User-Specific Attributes

```java
@ControllerAdvice
public class UserAttributesAdvice {
    
    @ModelAttribute("currentUser")
    public User getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        if (userDetails != null) {
            return userService.findByEmail(userDetails.getUsername());
        }
        return null;
    }
    
    @ModelAttribute("isAuthenticated")
    public boolean isAuthenticated(Authentication authentication) {
        return authentication != null && authentication.isAuthenticated();
    }
}
```

---

## üîß InitBinder

### Custom Data Binding

```java
@ControllerAdvice
public class DataBindingAdvice {
    
    @InitBinder
    public void initBinder(WebDataBinder binder) {
        // Trim strings
        StringTrimmerEditor stringTrimmer = new StringTrimmerEditor(true);
        binder.registerCustomEditor(String.class, stringTrimmer);
        
        // Custom date format
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));
    }
    
    @InitBinder
    public void setAllowedFields(WebDataBinder binder) {
        // Prevent binding certain fields
        binder.setDisallowedFields("id", "createdAt", "updatedAt");
    }
}
```

### Validators

```java
@ControllerAdvice
public class ValidationAdvice {
    
    @Autowired
    private UserValidator userValidator;
    
    @InitBinder("user")
    public void initUserBinder(WebDataBinder binder) {
        binder.addValidators(userValidator);
    }
}

@Component
public class UserValidator implements Validator {
    
    @Override
    public boolean supports(Class<?> clazz) {
        return User.class.equals(clazz);
    }
    
    @Override
    public void validate(Object target, Errors errors) {
        User user = (User) target;
        
        if (user.getAge() != null && user.getAge() < 18) {
            errors.rejectValue("age", "user.age.tooYoung", "Must be 18 or older");
        }
    }
}
```

---

## üìå Best Practices

### 1. Use @RestControllerAdvice for REST APIs

```java
// ‚úÖ Good - For REST APIs
@RestControllerAdvice
public class RestExceptionHandler {
    // Automatically returns JSON
}

// ‚úÖ Good - For MVC views
@ControllerAdvice
public class MvcExceptionHandler {
    // Returns view names
}
```

### 2. Order Your Exception Handlers

```java
// ‚úÖ Good - Specific handlers have higher priority
@RestControllerAdvice
@Order(1)
public class SpecificExceptionHandler {
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handleUserNotFound(UserNotFoundException ex) { }
}

@RestControllerAdvice
@Order(2)
public class GenericExceptionHandler {
    @ExceptionHandler(Exception.class)
    public ErrorResponse handleGeneric(Exception ex) { }
}
```

### 3. Don't Duplicate Handlers

```java
// ‚ùå Bad - Duplicate handlers
@RestControllerAdvice
public class Handler1 {
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handle(UserNotFoundException ex) { }
}

@RestControllerAdvice
public class Handler2 {
    @ExceptionHandler(UserNotFoundException.class) // Conflict!
    public ErrorResponse handle(UserNotFoundException ex) { }
}

// ‚úÖ Good - Single handler
@RestControllerAdvice
public class GlobalHandler {
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handle(UserNotFoundException ex) { }
}
```

### 4. Log Appropriately

```java
// ‚úÖ Good - Different log levels
@RestControllerAdvice
@Slf4j
public class GlobalHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ErrorResponse handleNotFound(UserNotFoundException ex) {
        log.warn("Resource not found: {}", ex.getMessage()); // WARN for expected
        return createError(ex);
    }
    
    @ExceptionHandler(Exception.class)
    public ErrorResponse handleGeneric(Exception ex) {
        log.error("Unexpected error", ex); // ERROR for unexpected
        return createError(ex);
    }
}
```

### 5. Include Request Context

```java
// ‚úÖ Good - Include request details
@ExceptionHandler(Exception.class)
public ErrorResponse handleException(
        Exception ex,
        HttpServletRequest request) {
    
    log.error("Error at {} {}", request.getMethod(), request.getRequestURI(), ex);
    
    return ErrorResponse.builder()
        .status(500)
        .message(ex.getMessage())
        .path(request.getRequestURI())
        .method(request.getMethod())
        .timestamp(LocalDateTime.now())
        .build();
}
```

### 6. Use Consistent Error Format

```java
// ‚úÖ Good - Consistent format
@Data
@Builder
public class ErrorResponse {
    private int status;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}

// All handlers return this format
```

### 7. Separate Concerns

```java
// ‚úÖ Good - Separate handlers for different concerns
@RestControllerAdvice(basePackages = "com.example.api")
public class ApiExceptionHandler {
    // API-specific exceptions
}

@RestControllerAdvice(basePackages = "com.example.admin")
public class AdminExceptionHandler {
    // Admin-specific exceptions
}

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Global exceptions
}
```

---

## üé§ Interview Questions

### Q1: What is @ControllerAdvice?
**Answer:** Specialization of @Component for global exception handling and cross-cutting concerns across controllers.

### Q2: Difference between @ControllerAdvice and @RestControllerAdvice?
**Answer:** 
- @ControllerAdvice: Need @ResponseBody for JSON
- @RestControllerAdvice: Automatically returns JSON (combines @ControllerAdvice + @ResponseBody)

### Q3: How to target specific controllers?
**Answer:**
```java
@RestControllerAdvice(basePackages = "com.example.api")
@RestControllerAdvice(assignableTypes = {UserController.class})
@RestControllerAdvice(annotations = ApiController.class)
```

### Q4: What is @ModelAttribute in @ControllerAdvice?
**Answer:** Adds common model attributes available to all controllers/views.

### Q5: What is @InitBinder?
**Answer:** Customizes data binding, registers editors, validators, sets allowed fields.

### Q6: Can you have multiple @ControllerAdvice classes?
**Answer:** Yes, can have multiple with different scopes and priorities.

### Q7: How to set priority between @ControllerAdvice classes?
**Answer:** Use @Order annotation, lower number = higher priority.

### Q8: What exceptions can @ControllerAdvice handle?
**Answer:** All exceptions thrown from @Controller or @RestController methods.

### Q9: Does @ControllerAdvice work for filters?
**Answer:** No, only for controller exceptions. Filter exceptions need FilterExceptionHandler.

### Q10: How to handle validation errors globally?
**Answer:**
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ValidationErrorResponse handle(MethodArgumentNotValidException ex) {
    // Extract field errors
}
```

### Q11: Can you inject beans in @ControllerAdvice?
**Answer:** Yes, @ControllerAdvice is a Spring component, supports dependency injection.

### Q12: What is WebRequest parameter?
**Answer:** Provides generic access to request details (path, headers, parameters).

### Q13: Can @ControllerAdvice return different response types?
**Answer:** Yes, can return ErrorResponse, String, ModelAndView, etc.

### Q14: How to add custom headers in error response?
**Answer:**
```java
return ResponseEntity.status(401)
    .header("Custom-Header", "value")
    .body(error);
```

### Q15: What is basePackages attribute?
**Answer:** Restricts @ControllerAdvice to controllers in specified packages.

### Q16: Can @ControllerAdvice be used with @Component?
**Answer:** No need, @ControllerAdvice is already a @Component.

### Q17: How to handle Spring Security exceptions?
**Answer:**
```java
@ExceptionHandler(AccessDeniedException.class)
public ErrorResponse handleAccessDenied(AccessDeniedException ex) { }
```

### Q18: What is assignableTypes attribute?
**Answer:** Restricts @ControllerAdvice to specified controller classes.

### Q19: Can you test @ControllerAdvice?
**Answer:** Yes, using @WebMvcTest or MockMvc.

### Q20: Best practice for @ControllerAdvice?
**Answer:**
1. Use @RestControllerAdvice for REST APIs
2. Log appropriately (WARN vs ERROR)
3. Consistent error format
4. Don't expose stack traces
5. Include request context
6. Order handlers by specificity
7. Target specific scopes when needed

---

## üìö Summary

### Basic Setup

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleNotFound(ResourceNotFoundException ex) {
        log.warn("Resource not found: {}", ex.getMessage());
        
        return ErrorResponse.builder()
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGeneric(Exception ex) {
        log.error("Unexpected error", ex);
        
        return ErrorResponse.builder()
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message("An unexpected error occurred")
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### Key Points

- **@ControllerAdvice:** Global exception handling
- **@RestControllerAdvice:** Auto-serializes to JSON
- **@ExceptionHandler:** Handle specific exceptions
- **Targeting:** basePackages, assignableTypes, annotations
- **@ModelAttribute:** Add common model attributes
- **@InitBinder:** Customize data binding
- **@Order:** Set handler priority

**Next:** Custom Exceptions ‚Üí

