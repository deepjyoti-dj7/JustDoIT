# üåê Global Exception Handling - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [ResponseEntityExceptionHandler](#responseentityexceptionhandler)
- [Centralized Exception Handling](#centralized-exception-handling)
- [Default Exception Handlers](#default-exception-handlers)
- [Custom Error Responses](#custom-error-responses)
- [Exception Handling Strategies](#exception-handling-strategies)
- [Production-Ready Setup](#production-ready-setup)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Global Exception Handling** provides centralized error handling across the entire application using @ControllerAdvice and ResponseEntityExceptionHandler.

### Benefits

```
Local Exception Handling:
‚ùå Duplicate code in every controller
‚ùå Inconsistent error responses
‚ùå Hard to maintain
‚ùå Difficult to apply changes

Global Exception Handling:
‚úÖ Single point of error handling
‚úÖ Consistent error responses
‚úÖ Easy to maintain
‚úÖ DRY principle
‚úÖ Centralized logging
‚úÖ Production-ready
```

### Architecture

```
Request ‚Üí Filter ‚Üí Controller ‚Üí Service
                                   ‚Üì
                              Exception
                                   ‚Üì
                    @ControllerAdvice intercepts
                                   ‚Üì
                    ResponseEntityExceptionHandler
                                   ‚Üì
                    Format error response
                                   ‚Üì
                    Return to client
```

---

## üîß ResponseEntityExceptionHandler

### Extending ResponseEntityExceptionHandler

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        log.warn("Validation failed: {}", ex.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Validation failed")
            .errors(errors)
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        log.warn("Malformed JSON request: {}", ex.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Malformed JSON request")
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    @Override
    protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(
            HttpRequestMethodNotSupportedException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        log.warn("Method not supported: {}", ex.getMethod());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .status(HttpStatus.METHOD_NOT_ALLOWED.value())
            .message(String.format("Method %s is not supported for this endpoint", ex.getMethod()))
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(errorResponse);
    }
    
    @Override
    protected ResponseEntity<Object> handleMissingServletRequestParameter(
            MissingServletRequestParameterException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        log.warn("Missing parameter: {}", ex.getParameterName());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
            .status(HttpStatus.BAD_REQUEST.value())
            .message(String.format("Required parameter '%s' is missing", ex.getParameterName()))
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
}
```

### Response Entity Exception Handler Methods

```java
// Common methods to override:

handleMethodArgumentNotValid          // Bean validation errors (@Valid)
handleHttpMessageNotReadable          // Malformed JSON
handleHttpRequestMethodNotSupported   // Wrong HTTP method (GET vs POST)
handleMissingServletRequestParameter  // Missing query/path parameters
handleTypeMismatch                    // Type conversion errors
handleNoHandlerFoundException         // 404 - No handler found
handleHttpMediaTypeNotSupported       // Unsupported media type
handleMissingPathVariable             // Missing path variable
handleBindException                   // Binding errors
```

---

## üåç Centralized Exception Handling

### Complete Global Handler

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    // ==================== Custom Business Exceptions ====================
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {
        
        log.warn("Resource not found: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(ResourceAlreadyExistsException.class)
    public ResponseEntity<ErrorResponse> handleResourceAlreadyExists(
            ResourceAlreadyExistsException ex,
            HttpServletRequest request) {
        
        log.warn("Resource already exists: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(HttpStatus.CONFLICT.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }
    
    @ExceptionHandler(InvalidRequestException.class)
    public ResponseEntity<ErrorResponse> handleInvalidRequest(
            InvalidRequestException ex,
            HttpServletRequest request) {
        
        log.warn("Invalid request: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(HttpStatus.BAD_REQUEST.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    // ==================== Security Exceptions ====================
    
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorized(
            UnauthorizedException ex,
            HttpServletRequest request) {
        
        log.warn("Unauthorized access: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("UNAUTHORIZED")
            .status(HttpStatus.UNAUTHORIZED.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .header("WWW-Authenticate", "Bearer")
            .body(error);
    }
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(
            AccessDeniedException ex,
            HttpServletRequest request) {
        
        log.warn("Access denied: {} - {}", request.getRequestURI(), ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("FORBIDDEN")
            .status(HttpStatus.FORBIDDEN.value())
            .message("You don't have permission to access this resource")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }
    
    // ==================== Database Exceptions ====================
    
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(
            DataIntegrityViolationException ex,
            HttpServletRequest request) {
        
        log.error("Data integrity violation at {}", request.getRequestURI(), ex);
        
        String message = "Database constraint violation";
        String errorCode = "DATABASE_ERROR";
        
        if (ex.getRootCause() != null) {
            String rootMsg = ex.getRootCause().getMessage();
            if (rootMsg.contains("Duplicate entry")) {
                message = "Duplicate entry. Resource already exists.";
                errorCode = "DUPLICATE_ENTRY";
            } else if (rootMsg.contains("foreign key constraint")) {
                message = "Cannot delete. Resource is referenced by other records.";
                errorCode = "FOREIGN_KEY_VIOLATION";
            }
        }
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(errorCode)
            .status(HttpStatus.CONFLICT.value())
            .message(message)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }
    
    @ExceptionHandler(EmptyResultDataAccessException.class)
    public ResponseEntity<ErrorResponse> handleEmptyResult(
            EmptyResultDataAccessException ex,
            HttpServletRequest request) {
        
        log.warn("No data found for delete operation");
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("RESOURCE_NOT_FOUND")
            .status(HttpStatus.NOT_FOUND.value())
            .message("Resource not found")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // ==================== Validation Exceptions ====================
    
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        log.warn("Validation failed: {}", ex.getBindingResult().getErrorCount() + " errors");
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Validation failed")
            .errors(errors)
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ValidationErrorResponse> handleConstraintViolation(
            ConstraintViolationException ex,
            HttpServletRequest request) {
        
        log.warn("Constraint violation: {}", ex.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        ex.getConstraintViolations().forEach(violation -> {
            String propertyPath = violation.getPropertyPath().toString();
            String message = violation.getMessage();
            errors.put(propertyPath, message);
        });
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .errorCode("CONSTRAINT_VIOLATION")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Constraint violation")
            .errors(errors)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    // ==================== Generic Exceptions ====================
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgument(
            IllegalArgumentException ex,
            HttpServletRequest request) {
        
        log.warn("Illegal argument: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("ILLEGAL_ARGUMENT")
            .status(HttpStatus.BAD_REQUEST.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex,
            HttpServletRequest request) {
        
        log.error("Unexpected error at {}", request.getRequestURI(), ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("INTERNAL_SERVER_ERROR")
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message("An unexpected error occurred. Please contact support.")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

---

## üéØ Default Exception Handlers

### Common HTTP Exceptions

```java
@RestControllerAdvice
@Slf4j
public class DefaultExceptionHandler extends ResponseEntityExceptionHandler {
    
    // 400 - Bad Request (Malformed JSON)
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        ErrorResponse error = createError(
            "MALFORMED_JSON",
            HttpStatus.BAD_REQUEST,
            "Malformed JSON request",
            request
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    // 405 - Method Not Allowed
    @Override
    protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(
            HttpRequestMethodNotSupportedException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        String message = String.format(
            "Method %s is not supported. Supported methods: %s",
            ex.getMethod(),
            ex.getSupportedHttpMethods()
        );
        
        ErrorResponse error = createError(
            "METHOD_NOT_ALLOWED",
            HttpStatus.METHOD_NOT_ALLOWED,
            message,
            request
        );
        
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(error);
    }
    
    // 415 - Unsupported Media Type
    @Override
    protected ResponseEntity<Object> handleHttpMediaTypeNotSupported(
            HttpMediaTypeNotSupportedException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        String message = String.format(
            "Media type %s is not supported. Supported types: %s",
            ex.getContentType(),
            ex.getSupportedMediaTypes()
        );
        
        ErrorResponse error = createError(
            "UNSUPPORTED_MEDIA_TYPE",
            HttpStatus.UNSUPPORTED_MEDIA_TYPE,
            message,
            request
        );
        
        return ResponseEntity.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).body(error);
    }
    
    // 404 - No Handler Found
    @Override
    protected ResponseEntity<Object> handleNoHandlerFoundException(
            NoHandlerFoundException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        String message = String.format(
            "No handler found for %s %s",
            ex.getHttpMethod(),
            ex.getRequestURL()
        );
        
        ErrorResponse error = createError(
            "ENDPOINT_NOT_FOUND",
            HttpStatus.NOT_FOUND,
            message,
            request
        );
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // 400 - Missing Parameter
    @Override
    protected ResponseEntity<Object> handleMissingServletRequestParameter(
            MissingServletRequestParameterException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        String message = String.format(
            "Required parameter '%s' is missing",
            ex.getParameterName()
        );
        
        ErrorResponse error = createError(
            "MISSING_PARAMETER",
            HttpStatus.BAD_REQUEST,
            message,
            request
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    // 400 - Type Mismatch
    @Override
    protected ResponseEntity<Object> handleTypeMismatch(
            TypeMismatchException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        String message = String.format(
            "Invalid value '%s' for parameter '%s'. Expected type: %s",
            ex.getValue(),
            ex.getPropertyName(),
            ex.getRequiredType().getSimpleName()
        );
        
        ErrorResponse error = createError(
            "TYPE_MISMATCH",
            HttpStatus.BAD_REQUEST,
            message,
            request
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }
    
    // Helper method
    private ErrorResponse createError(
            String errorCode,
            HttpStatus status,
            String message,
            WebRequest request) {
        
        return ErrorResponse.builder()
            .errorCode(errorCode)
            .status(status.value())
            .message(message)
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

---

## üì¶ Custom Error Responses

### Error Response Structure

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
```

### Validation Error Response

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ValidationErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private Map<String, String> errors;
    private String path;
    private LocalDateTime timestamp;
}
```

### Rich Error Response

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class RichErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private String path;
    private String method;
    private LocalDateTime timestamp;
    private Map<String, Object> metadata;
    
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String debugMessage; // Only in development
}
```

---

## üéØ Exception Handling Strategies

### Strategy 1: By HTTP Status

```java
@RestControllerAdvice
public class StatusBasedHandler {
    
    @ExceptionHandler({UserNotFoundException.class, ProductNotFoundException.class})
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handle404(RuntimeException ex) {
        return createError(ex, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler({DuplicateEmailException.class, ConflictException.class})
    @ResponseStatus(HttpStatus.CONFLICT)
    public ErrorResponse handle409(RuntimeException ex) {
        return createError(ex, HttpStatus.CONFLICT);
    }
}
```

### Strategy 2: By Domain

```java
@RestControllerAdvice(basePackages = "com.example.user")
public class UserExceptionHandler {
    // Handle user-related exceptions
}

@RestControllerAdvice(basePackages = "com.example.product")
public class ProductExceptionHandler {
    // Handle product-related exceptions
}
```

### Strategy 3: By Exception Type

```java
@RestControllerAdvice
public class BusinessExceptionHandler {
    
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BaseException ex) {
        return ResponseEntity.status(ex.getStatus()).body(createError(ex));
    }
}
```

---

## üöÄ Production-Ready Setup

### Complete Production Handler

```java
@RestControllerAdvice
@Slf4j
public class ProductionExceptionHandler extends ResponseEntityExceptionHandler {
    
    @Value("${spring.profiles.active:prod}")
    private String activeProfile;
    
    // Business exceptions
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBaseException(
            BaseException ex,
            HttpServletRequest request) {
        
        logException(ex, request);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(ex.getStatus().value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(ex.getStatus()).body(error);
    }
    
    // Validation errors
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        Map<String, String> errors = extractFieldErrors(ex);
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Validation failed")
            .errors(errors)
            .path(request.getDescription(false).replace("uri=", ""))
            .timestamp(LocalDateTime.now())
            .build();
        
        log.warn("Validation failed: {} errors", errors.size());
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    // Database exceptions
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<ErrorResponse> handleDataAccess(
            DataAccessException ex,
            HttpServletRequest request) {
        
        log.error("Database error at {}", request.getRequestURI(), ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("DATABASE_ERROR")
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message(getProductionMessage("Database error occurred"))
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    // Generic exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(
            Exception ex,
            HttpServletRequest request) {
        
        log.error("Unexpected error", ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message(getProductionMessage("An unexpected error occurred"))
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    // Helper methods
    
    private void logException(Exception ex, HttpServletRequest request) {
        if (ex instanceof BaseException) {
            log.warn("Business exception at {} - {}", request.getRequestURI(), ex.getMessage());
        } else {
            log.error("Exception at {}", request.getRequestURI(), ex);
        }
    }
    
    private Map<String, String> extractFieldErrors(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        return errors;
    }
    
    private String getProductionMessage(String devMessage) {
        if ("dev".equals(activeProfile) || "local".equals(activeProfile)) {
            return devMessage;
        }
        return "An error occurred. Please contact support if the problem persists.";
    }
}
```

---

## üìå Best Practices

### 1. Use ResponseEntityExceptionHandler

```java
// ‚úÖ Good - Extend ResponseEntityExceptionHandler
@RestControllerAdvice
public class GlobalHandler extends ResponseEntityExceptionHandler {
    // Override specific methods
}

// ‚ùå Bad - Start from scratch
@RestControllerAdvice
public class GlobalHandler {
    // Miss built-in exception handling
}
```

### 2. Log Appropriately

```java
// ‚úÖ Good - Different log levels
@ExceptionHandler(UserNotFoundException.class)
public ErrorResponse handleNotFound(UserNotFoundException ex) {
    log.warn("User not found: {}", ex.getMessage()); // WARN for expected
    return createError(ex);
}

@ExceptionHandler(Exception.class)
public ErrorResponse handleGeneric(Exception ex) {
    log.error("Unexpected error", ex); // ERROR for unexpected
    return createError(ex);
}
```

### 3. Don't Expose Sensitive Information

```java
// ‚ùå Bad - Exposes stack trace
@ExceptionHandler(Exception.class)
public ErrorResponse handle(Exception ex) {
    return new ErrorResponse(ex.getStackTrace().toString());
}

// ‚úÖ Good - Generic message to client, log details
@ExceptionHandler(Exception.class)
public ErrorResponse handle(Exception ex) {
    log.error("Error occurred", ex); // Log full details
    return new ErrorResponse("An error occurred"); // Generic to client
}
```

### 4. Consistent Error Format

```java
// ‚úÖ Good - Same format for all errors
@Data
@Builder
public class ErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}

// All handlers return this format
```

### 5. Include Request Context

```java
// ‚úÖ Good - Include path, method
@ExceptionHandler(Exception.class)
public ErrorResponse handle(Exception ex, HttpServletRequest request) {
    log.error("Error at {} {}", request.getMethod(), request.getRequestURI(), ex);
    
    return ErrorResponse.builder()
        .message(ex.getMessage())
        .path(request.getRequestURI())
        .method(request.getMethod())
        .build();
}
```

### 6. Environment-Specific Messages

```java
@Value("${spring.profiles.active:prod}")
private String activeProfile;

private String getMessage(Exception ex) {
    if ("dev".equals(activeProfile)) {
        return ex.getMessage(); // Detailed in dev
    }
    return "An error occurred"; // Generic in prod
}
```

---

## üé§ Interview Questions

### Q1: What is global exception handling?
**Answer:** Centralized error handling using @ControllerAdvice to handle exceptions across all controllers.

### Q2: What is ResponseEntityExceptionHandler?
**Answer:** Base class providing default handlers for common Spring MVC exceptions.

### Q3: Why extend ResponseEntityExceptionHandler?
**Answer:** Get built-in handling for Spring exceptions (validation, JSON parsing, etc.).

### Q4: What methods can you override?
**Answer:** handleMethodArgumentNotValid, handleHttpMessageNotReadable, handleHttpRequestMethodNotSupported, etc.

### Q5: Difference between @ControllerAdvice and @RestControllerAdvice?
**Answer:** @RestControllerAdvice = @ControllerAdvice + @ResponseBody (auto JSON serialization).

### Q6: Can you have multiple @ControllerAdvice classes?
**Answer:** Yes, use @Order or basePackages to organize them.

### Q7: How to handle validation exceptions globally?
**Answer:** Override handleMethodArgumentNotValid or @ExceptionHandler(MethodArgumentNotValidException.class).

### Q8: What is WebRequest parameter?
**Answer:** Provides generic access to request details (path, headers, parameters).

### Q9: How to include request path in error response?
**Answer:** Use HttpServletRequest.getRequestURI() or WebRequest.getDescription().

### Q10: Should you log in global handler?
**Answer:** Yes, log appropriately (WARN for expected, ERROR for unexpected).

### Q11: How to handle database exceptions?
**Answer:**
```java
@ExceptionHandler(DataIntegrityViolationException.class)
public ErrorResponse handleDatabase(DataIntegrityViolationException ex) { }
```

### Q12: What is the order of exception handler execution?
**Answer:** Most specific exception first, then parent classes, then generic Exception.

### Q13: Can you return different status codes?
**Answer:** Yes, use ResponseEntity.status() or @ResponseStatus.

### Q14: How to add custom headers?
**Answer:**
```java
return ResponseEntity.status(401)
    .header("WWW-Authenticate", "Bearer")
    .body(error);
```

### Q15: Should error responses include stack traces?
**Answer:** No in production, only log them server-side.

### Q16: How to handle async exceptions?
**Answer:**
```java
@ExceptionHandler(AsyncRequestTimeoutException.class)
public ErrorResponse handleAsyncTimeout(AsyncRequestTimeoutException ex) { }
```

### Q17: What is @ResponseStatus?
**Answer:** Annotation to specify HTTP status code for exception response.

### Q18: Can you test global exception handling?
**Answer:** Yes, using @WebMvcTest or MockMvc.

### Q19: How to handle Spring Security exceptions?
**Answer:** @ExceptionHandler(AccessDeniedException.class) or configure in SecurityConfig.

### Q20: Best practices for global exception handling?
**Answer:**
1. Extend ResponseEntityExceptionHandler
2. Log appropriately
3. Consistent error format
4. Don't expose sensitive info
5. Include request context
6. Environment-specific messages
7. Handle validation errors
8. Use error codes

---

## üìö Summary

### Basic Setup

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {
        
        log.warn("Resource not found: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(HttpStatus.NOT_FOUND.value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        
        // Handle validation errors
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errors);
    }
}
```

### Key Points

- **@RestControllerAdvice:** Global exception handling
- **ResponseEntityExceptionHandler:** Base class for Spring exceptions
- **Override Methods:** handleMethodArgumentNotValid, handleHttpMessageNotReadable, etc.
- **Logging:** Appropriate log levels (WARN vs ERROR)
- **Error Format:** Consistent structure
- **Security:** Don't expose sensitive information

**Next:** Error Response Structure ‚Üí

