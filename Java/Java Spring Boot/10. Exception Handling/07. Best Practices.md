# üìö Exception Handling Best Practices - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Exception Design Principles](#exception-design-principles)
- [Global Exception Handling](#global-exception-handling)
- [Error Response Standards](#error-response-standards)
- [Logging Strategies](#logging-strategies)
- [Security Considerations](#security-considerations)
- [Testing Exception Handling](#testing-exception-handling)
- [Production Best Practices](#production-best-practices)
- [Common Anti-Patterns](#common-anti-patterns)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Best Practices** for exception handling ensure consistent, secure, and maintainable error handling across your Spring Boot application.

### Core Principles

```
‚úÖ Fail Fast
‚úÖ Meaningful Messages
‚úÖ Consistent Format
‚úÖ Security First
‚úÖ Log Appropriately
‚úÖ Don't Swallow Exceptions
‚úÖ Use Specific Exceptions
‚úÖ Clean Error Responses
```

---

## üèóÔ∏è Exception Design Principles

### 1. Use Exception Hierarchy

```java
// ‚úÖ Good - Organized hierarchy
@Getter
public abstract class BaseException extends RuntimeException {
    private final HttpStatus status;
    private final String errorCode;
    
    protected BaseException(String message, HttpStatus status, String errorCode) {
        super(message);
        this.status = status;
        this.errorCode = errorCode;
    }
}

public class ResourceNotFoundException extends BaseException {
    public ResourceNotFoundException(String resource, Long id) {
        super(
            String.format("%s not found with id: %d", resource, id),
            HttpStatus.NOT_FOUND,
            "RESOURCE_NOT_FOUND"
        );
    }
}

public class UserNotFoundException extends ResourceNotFoundException {
    public UserNotFoundException(Long id) {
        super("User", id);
    }
}

// Benefits:
// - Can catch at any level (UserNotFoundException, ResourceNotFoundException, BaseException)
// - Common properties (status, errorCode) in base class
// - Consistent error handling
```

### 2. Prefer Unchecked Exceptions

```java
// ‚úÖ Good - RuntimeException (unchecked)
public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(BigDecimal required, BigDecimal available) {
        super(String.format("Insufficient funds. Required: %.2f, Available: %.2f",
            required, available));
    }
}

// ‚ùå Bad - Checked exception for business logic
public class InsufficientFundsException extends Exception {
    // Forces try-catch everywhere
}

// Reasoning:
// - Business logic exceptions are not recoverable by caller
// - Cleaner code without forced try-catch
// - Let @ExceptionHandler handle them globally
```

### 3. Meaningful Exception Names

```java
// ‚úÖ Good - Clear, specific names
UserNotFoundException
DuplicateEmailException
InvalidOrderStatusException
InsufficientStockException
PaymentFailedException

// ‚ùå Bad - Generic names
UserException
DataException
ServiceException
```

### 4. Include Context in Messages

```java
// ‚úÖ Good - Detailed, actionable message
throw new InsufficientStockException(
    String.format("Product '%s' (ID: %d) has insufficient stock. Requested: %d, Available: %d",
        product.getName(), product.getId(), requestedQty, product.getStock())
);

// ‚ùå Bad - Generic message
throw new InsufficientStockException("Insufficient stock");
```

---

## üåê Global Exception Handling

### 1. Centralized Handler

```java
// ‚úÖ Good - Single global handler
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    // All exception handlers in one place
    
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBaseException(
            BaseException ex,
            HttpServletRequest request) {
        
        logException(ex, request);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(ex.getStatus().value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(ex.getStatus()).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(
            Exception ex,
            HttpServletRequest request) {
        
        log.error("Unexpected error at {}", request.getRequestURI(), ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message("An unexpected error occurred")
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    private void logException(Exception ex, HttpServletRequest request) {
        if (ex instanceof BaseException) {
            log.warn("Business exception: {} at {}", ex.getMessage(), request.getRequestURI());
        } else {
            log.error("Exception at {}", request.getRequestURI(), ex);
        }
    }
}
```

### 2. Extend ResponseEntityExceptionHandler

```java
// ‚úÖ Good - Get built-in Spring exception handling
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        // Custom validation error handling
    }
    
    @Override
    protected ResponseEntity<Object> handleHttpMessageNotReadable(
            HttpMessageNotReadableException ex,
            HttpHeaders headers,
            HttpStatusCode status,
            WebRequest request) {
        // Custom malformed JSON handling
    }
}
```

---

## üì¶ Error Response Standards

### 1. Consistent Structure

```java
// ‚úÖ Good - Standard structure for ALL errors
@Data
@Builder
public class ErrorResponse {
    private String errorCode;      // Machine-readable identifier
    private int status;             // HTTP status code
    private String message;         // Human-readable message
    private String path;            // Request URI
    private LocalDateTime timestamp; // When error occurred
    
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private Map<String, Object> metadata; // Additional context
}

// All handlers return this format
```

### 2. Use Error Codes

```java
// ‚úÖ Good - Unique error codes
{
  "errorCode": "USER_NOT_FOUND",
  "status": 404,
  "message": "User not found with id: 123"
}

// Benefits:
// - Clients can handle specific errors programmatically
// - Easier to track and categorize errors
// - Supports internationalization
```

### 3. Validation Errors as Map

```java
// ‚úÖ Good - Field errors as map
@Data
@Builder
public class ValidationErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private Map<String, String> errors; // field -> error message
    private String path;
    private LocalDateTime timestamp;
}

// Response
{
  "errorCode": "VALIDATION_ERROR",
  "errors": {
    "email": "Email must be valid",
    "age": "Must be at least 18"
  }
}
```

---

## üìù Logging Strategies

### 1. Log Levels

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // WARN for expected business exceptions
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        log.warn("Resource not found: {}", ex.getMessage());
        return createErrorResponse(ex);
    }
    
    // ERROR for unexpected exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {
        log.error("Unexpected error occurred", ex); // Include stack trace
        return createErrorResponse(ex);
    }
    
    // INFO for retryable errors
    @ExceptionHandler(ServiceUnavailableException.class)
    public ResponseEntity<ErrorResponse> handleServiceUnavailable(ServiceUnavailableException ex) {
        log.info("Service temporarily unavailable: {}", ex.getMessage());
        return createErrorResponse(ex);
    }
}
```

### 2. Include Request Context

```java
// ‚úÖ Good - Rich logging context
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(
        Exception ex,
        HttpServletRequest request) {
    
    log.error("Error processing request: method={}, uri={}, user={}",
        request.getMethod(),
        request.getRequestURI(),
        getCurrentUsername(),
        ex // Exception with stack trace
    );
    
    return createErrorResponse(ex);
}
```

### 3. Structured Logging

```java
// ‚úÖ Good - Structured logging for better searchability
log.error("Exception occurred",
    kv("errorCode", ex.getErrorCode()),
    kv("requestUri", request.getRequestURI()),
    kv("method", request.getMethod()),
    kv("userId", getCurrentUserId()),
    kv("correlationId", getCorrelationId()),
    ex
);
```

---

## üîí Security Considerations

### 1. Don't Expose Sensitive Information

```java
// ‚ùå Bad - Exposes stack trace
@ExceptionHandler(Exception.class)
public ErrorResponse handleException(Exception ex) {
    return new ErrorResponse(
        500,
        ex.getMessage(),
        Arrays.toString(ex.getStackTrace()) // NEVER!
    );
}

// ‚úÖ Good - Generic message, log details server-side
@ExceptionHandler(Exception.class)
public ErrorResponse handleException(Exception ex, HttpServletRequest request) {
    log.error("Error at {}", request.getRequestURI(), ex); // Log full details
    
    return ErrorResponse.builder()
        .errorCode("INTERNAL_ERROR")
        .status(500)
        .message("An error occurred. Please contact support.") // Generic to client
        .timestamp(LocalDateTime.now())
        .build();
}
```

### 2. Environment-Specific Messages

```java
@Value("${spring.profiles.active:prod}")
private String activeProfile;

private String getErrorMessage(Exception ex) {
    if ("dev".equals(activeProfile) || "local".equals(activeProfile)) {
        return ex.getMessage(); // Detailed in development
    }
    return "An error occurred. Please contact support."; // Generic in production
}
```

### 3. Sanitize User Input in Errors

```java
// ‚úÖ Good - Sanitize before including in message
throw new UserNotFoundException(
    String.format("User not found with id: %d", sanitize(userId))
);

// ‚ùå Bad - Direct user input in error
throw new UserNotFoundException("User not found: " + userInput);
```

### 4. Don't Expose Internal Paths

```java
// ‚ùå Bad - Exposes internal structure
{
  "message": "File not found: /var/app/secrets/config.properties"
}

// ‚úÖ Good - Generic message
{
  "errorCode": "CONFIGURATION_ERROR",
  "message": "A configuration error occurred"
}
```

---

## üß™ Testing Exception Handling

### 1. Test Exception Handlers

```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    void whenUserNotFound_thenReturns404() throws Exception {
        when(userService.findById(999L))
            .thenThrow(new UserNotFoundException(999L));
        
        mockMvc.perform(get("/api/users/999"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.errorCode").value("USER_NOT_FOUND"))
            .andExpect(jsonPath("$.status").value(404))
            .andExpect(jsonPath("$.message").value("User not found with id: 999"))
            .andExpect(jsonPath("$.path").value("/api/users/999"))
            .andExpect(jsonPath("$.timestamp").exists());
    }
    
    @Test
    void whenValidationFails_thenReturns400() throws Exception {
        String requestBody = """
            {
                "email": "invalid-email",
                "age": 15
            }
            """;
        
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.errorCode").value("VALIDATION_ERROR"))
            .andExpect(jsonPath("$.errors.email").exists())
            .andExpect(jsonPath("$.errors.age").exists());
    }
    
    @Test
    void whenInternalError_thenReturns500() throws Exception {
        when(userService.findById(1L))
            .thenThrow(new RuntimeException("Database connection failed"));
        
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isInternalServerError())
            .andExpect(jsonPath("$.errorCode").value("INTERNAL_ERROR"))
            .andExpect(jsonPath("$.status").value(500))
            .andExpect(jsonPath("$.message").doesNotContain("Database connection")); // Generic message
    }
}
```

### 2. Test Custom Exceptions

```java
@Test
void testCustomException() {
    UserNotFoundException exception = new UserNotFoundException(123L);
    
    assertEquals("User not found with id: 123", exception.getMessage());
    assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());
    assertEquals("USER_NOT_FOUND", exception.getErrorCode());
}
```

---

## üöÄ Production Best Practices

### 1. Complete Production Setup

```java
@RestControllerAdvice
@Slf4j
public class ProductionExceptionHandler extends ResponseEntityExceptionHandler {
    
    @Value("${spring.profiles.active:prod}")
    private String activeProfile;
    
    @Value("${app.support.email}")
    private String supportEmail;
    
    // Business exceptions
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(
            BaseException ex,
            HttpServletRequest request) {
        
        String correlationId = UUID.randomUUID().toString();
        
        log.warn("Business exception [{}]: {} at {}",
            correlationId,
            ex.getMessage(),
            request.getRequestURI()
        );
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode(ex.getErrorCode())
            .status(ex.getStatus().value())
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .metadata(Map.of("correlationId", correlationId))
            .build();
        
        return ResponseEntity.status(ex.getStatus()).body(error);
    }
    
    // Unexpected exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleUnexpectedException(
            Exception ex,
            HttpServletRequest request) {
        
        String correlationId = UUID.randomUUID().toString();
        
        log.error("Unexpected exception [{}]",
            correlationId,
            kv("uri", request.getRequestURI()),
            kv("method", request.getMethod()),
            kv("user", getCurrentUsername()),
            ex
        );
        
        String message = isDevEnvironment()
            ? ex.getMessage()
            : String.format("An error occurred. Reference ID: %s. Contact: %s",
                correlationId, supportEmail);
        
        ErrorResponse error = ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .message(message)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .metadata(Map.of("correlationId", correlationId))
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
    
    private boolean isDevEnvironment() {
        return "dev".equals(activeProfile) || "local".equals(activeProfile);
    }
    
    private String getCurrentUsername() {
        try {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            return auth != null ? auth.getName() : "anonymous";
        } catch (Exception e) {
            return "unknown";
        }
    }
}
```

### 2. Correlation IDs

```java
// ‚úÖ Good - Include correlation ID for tracking
@ExceptionHandler(Exception.class)
public ResponseEntity<ErrorResponse> handleException(Exception ex) {
    String correlationId = UUID.randomUUID().toString();
    
    log.error("Error [{}]", correlationId, ex);
    
    return ResponseEntity
        .status(500)
        .header("X-Correlation-ID", correlationId)
        .body(ErrorResponse.builder()
            .errorCode("INTERNAL_ERROR")
            .message("Error occurred. Reference: " + correlationId)
            .build());
}
```

### 3. Monitoring and Alerting

```java
@RestControllerAdvice
@Slf4j
public class MonitoredExceptionHandler {
    
    @Autowired
    private MetricService metricService;
    
    @Autowired
    private AlertService alertService;
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(
            Exception ex,
            HttpServletRequest request) {
        
        // Increment error metrics
        metricService.incrementCounter("errors.total");
        metricService.incrementCounter("errors." + ex.getClass().getSimpleName());
        
        // Alert on critical errors
        if (isCritical(ex)) {
            alertService.sendAlert(
                "Critical Error",
                String.format("Error at %s: %s", request.getRequestURI(), ex.getMessage())
            );
        }
        
        log.error("Exception occurred", ex);
        
        return createErrorResponse(ex);
    }
    
    private boolean isCritical(Exception ex) {
        return ex instanceof DatabaseConnectionException
            || ex instanceof PaymentGatewayException
            || ex instanceof SecurityException;
    }
}
```

---

## ‚ùå Common Anti-Patterns

### 1. Swallowing Exceptions

```java
// ‚ùå Bad - Swallows exception
try {
    userService.createUser(request);
} catch (Exception e) {
    // Do nothing
}

// ‚úÖ Good - Log and/or re-throw
try {
    userService.createUser(request);
} catch (Exception e) {
    log.error("Failed to create user", e);
    throw new UserCreationException("Failed to create user", e);
}
```

### 2. Generic Exception Handling

```java
// ‚ùå Bad - Catch generic Exception
try {
    userService.createUser(request);
} catch (Exception e) {
    // Can't handle different exceptions differently
}

// ‚úÖ Good - Catch specific exceptions
try {
    userService.createUser(request);
} catch (DuplicateEmailException e) {
    // Handle duplicate email
} catch (ValidationException e) {
    // Handle validation errors
}
```

### 3. Logging Without Context

```java
// ‚ùå Bad - No context
log.error("Error occurred");

// ‚úÖ Good - Include context
log.error("Failed to process order {} for user {}", orderId, userId, ex);
```

### 4. Returning Stack Traces

```java
// ‚ùå Bad - Exposes implementation details
return new ErrorResponse(ex.getStackTrace().toString());

// ‚úÖ Good - Generic message, log stack trace
log.error("Error", ex);
return new ErrorResponse("An error occurred");
```

### 5. Inconsistent Error Formats

```java
// ‚ùå Bad - Different formats
// Endpoint 1
{ "error": "Not found" }

// Endpoint 2
{ "message": "Not found", "code": 404 }

// ‚úÖ Good - Consistent format
// All endpoints
{
  "errorCode": "RESOURCE_NOT_FOUND",
  "status": 404,
  "message": "Resource not found",
  "timestamp": "2024-01-15T10:30:45"
}
```

---

## üé§ Interview Questions

### Q1: Why use @RestControllerAdvice?
**Answer:** Centralized global exception handling with automatic JSON serialization.

### Q2: Should you use checked or unchecked exceptions?
**Answer:** Unchecked (RuntimeException) for business logic, checked for recoverable errors.

### Q3: How to avoid exposing sensitive information?
**Answer:**
- Don't return stack traces
- Generic messages in production
- Log details server-side
- Environment-specific responses

### Q4: What log level for exceptions?
**Answer:**
- WARN: Expected business exceptions
- ERROR: Unexpected exceptions
- INFO: Retryable/temporary errors

### Q5: Should error responses include HTTP status?
**Answer:** Yes, in response body for redundancy and client convenience.

### Q6: How to test exception handling?
**Answer:** Use MockMvc to verify status code, error code, message structure.

### Q7: What is correlation ID?
**Answer:** Unique identifier linking request, error, and logs for tracking.

### Q8: Should you log in exception constructor?
**Answer:** No, log in exception handler, not in exception class.

### Q9: How to handle validation errors?
**Answer:** Extract field errors as Map<String, String> and return in structured format.

### Q10: What fields in error response?
**Answer:** errorCode, status, message, path, timestamp (minimum).

### Q11: How to organize custom exceptions?
**Answer:** Use hierarchy with base exception, group by domain/status.

### Q12: Should you catch generic Exception?
**Answer:** Only as last resort in global handler, prefer specific exceptions.

### Q13: How to include request context in logs?
**Answer:** Log URI, method, user, correlation ID with exception.

### Q14: What is @JsonInclude?
**Answer:** Jackson annotation to hide null/empty fields from JSON response.

### Q15: Should you re-throw exceptions?
**Answer:** Yes, if you can't handle them, or wrap in domain-specific exception.

### Q16: How to monitor exceptions?
**Answer:** Increment metrics, send alerts for critical errors, log with context.

### Q17: What is ResponseEntityExceptionHandler?
**Answer:** Base class providing handlers for Spring MVC exceptions.

### Q18: Should error messages be technical?
**Answer:** No in production, user-friendly messages. Technical details in logs.

### Q19: How to handle async exceptions?
**Answer:** @ExceptionHandler(AsyncRequestTimeoutException.class) or AsyncUncaughtExceptionHandler.

### Q20: Best practices summary?
**Answer:**
1. Use exception hierarchy
2. Centralized global handling
3. Consistent error format
4. Don't expose sensitive info
5. Log appropriately
6. Environment-specific messages
7. Include correlation IDs
8. Test exception handling
9. Monitor and alert
10. Avoid anti-patterns

---

## üìö Summary

### Complete Best Practices Setup

```java
// 1. Exception Hierarchy
@Getter
public abstract class BaseException extends RuntimeException {
    private final HttpStatus status;
    private final String errorCode;
}

// 2. Global Handler
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ErrorResponse> handleBusiness(BaseException ex) {
        log.warn("Business exception: {}", ex.getMessage());
        return createResponse(ex);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex) {
        log.error("Unexpected error", ex);
        return createGenericResponse();
    }
}

// 3. Error Response
@Data
@Builder
public class ErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private String path;
    private LocalDateTime timestamp;
}
```

### Key Principles

‚úÖ **Use hierarchy** - Organized exception structure  
‚úÖ **Fail fast** - Detect errors early  
‚úÖ **Consistent format** - Same structure everywhere  
‚úÖ **Log appropriately** - WARN vs ERROR  
‚úÖ **Security first** - Don't expose internals  
‚úÖ **Test thoroughly** - Verify exception handling  
‚úÖ **Monitor** - Track errors and alert  
‚úÖ **Correlation IDs** - Link requests and errors

**This completes the Exception Handling module!**

