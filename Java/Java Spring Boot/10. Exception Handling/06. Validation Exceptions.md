# ‚úÖ Validation Exceptions - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Bean Validation Basics](#bean-validation-basics)
- [MethodArgumentNotValidException](#methodargumentnotvalidexception)
- [ConstraintViolationException](#constraintviolationexception)
- [Custom Validators](#custom-validators)
- [Field-Level Validation](#field-level-validation)
- [Class-Level Validation](#class-level-validation)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Validation Exceptions** handle errors from Bean Validation (JSR-303/JSR-380) when request data doesn't meet validation constraints.

### Why Validation Exceptions?

```
Without Validation Exception Handling:
‚ùå Generic 400 Bad Request
‚ùå No field-specific errors
‚ùå Hard to debug on client
‚ùå Poor user experience

With Validation Exception Handling:
‚úÖ Field-specific error messages
‚úÖ Clear validation failures
‚úÖ Easy to fix on client
‚úÖ Better user experience
‚úÖ Professional API
```

### Validation Flow

```
Request ‚Üí @Valid ‚Üí Validation ‚Üí Exception
                                    ‚Üì
                  MethodArgumentNotValidException
                                    ‚Üì
                  @ExceptionHandler catches
                                    ‚Üì
                  Extract field errors
                                    ‚Üì
                  Return to client
```

---

## üîß Bean Validation Basics

### Common Validation Annotations

```java
@Data
public class UserRegistrationRequest {
    
    @NotNull(message = "Name is required")
    @NotBlank(message = "Name cannot be blank")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @NotNull(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotNull(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$",
        message = "Password must contain uppercase, lowercase, and digit"
    )
    private String password;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must be less than 120")
    private Integer age;
    
    @NotNull(message = "Phone is required")
    @Pattern(regexp = "^\\d{10}$", message = "Phone must be 10 digits")
    private String phone;
    
    @Past(message = "Date of birth must be in the past")
    private LocalDate dateOfBirth;
}
```

### Controller with @Valid

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping("/register")
    public ResponseEntity<User> register(@Valid @RequestBody UserRegistrationRequest request) {
        User user = userService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
    
    @PutMapping("/{id}")
    public User updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UserUpdateRequest request) {
        return userService.update(id, request);
    }
}
```

---

## üìù MethodArgumentNotValidException

### Handling Validation Errors

```java
@RestControllerAdvice
@Slf4j
public class ValidationExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex,
            HttpServletRequest request) {
        
        log.warn("Validation failed for request: {}", request.getRequestURI());
        
        Map<String, String> errors = new HashMap<>();
        
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Validation failed")
            .errors(errors)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return errorResponse;
    }
}
```

### Validation Error Response DTO

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ValidationErrorResponse {
    private String errorCode;
    private int status;
    private String message;
    private Map<String, String> errors;
    private String path;
    
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS")
    private LocalDateTime timestamp;
}
```

### Response Example

```json
{
  "errorCode": "VALIDATION_ERROR",
  "status": 400,
  "message": "Validation failed",
  "errors": {
    "email": "Email must be valid",
    "password": "Password must be at least 8 characters",
    "age": "Age must be at least 18",
    "phone": "Phone must be 10 digits"
  },
  "path": "/api/users/register",
  "timestamp": "2024-01-15T10:30:45.123"
}
```

---

## üéØ ConstraintViolationException

### Path Parameter Validation

```java
@RestController
@RequestMapping("/api/users")
@Validated // Required for method parameter validation
public class UserController {
    
    @GetMapping("/{id}")
    public User getUser(
            @PathVariable 
            @Min(value = 1, message = "User ID must be positive") 
            Long id) {
        return userService.findById(id);
    }
    
    @GetMapping
    public List<User> getUsers(
            @RequestParam 
            @Min(value = 0, message = "Page must be non-negative") 
            int page,
            
            @RequestParam 
            @Min(value = 1, message = "Size must be at least 1")
            @Max(value = 100, message = "Size cannot exceed 100")
            int size) {
        return userService.findAll(page, size);
    }
}
```

### Handling ConstraintViolationException

```java
@RestControllerAdvice
@Slf4j
public class ValidationExceptionHandler {
    
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleConstraintViolation(
            ConstraintViolationException ex,
            HttpServletRequest request) {
        
        log.warn("Constraint violation: {}", ex.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        
        ex.getConstraintViolations().forEach(violation -> {
            String propertyPath = violation.getPropertyPath().toString();
            String message = violation.getMessage();
            
            // Extract parameter name from path (e.g., "getUser.id" -> "id")
            String fieldName = propertyPath.substring(propertyPath.lastIndexOf('.') + 1);
            
            errors.put(fieldName, message);
        });
        
        ValidationErrorResponse errorResponse = ValidationErrorResponse.builder()
            .errorCode("CONSTRAINT_VIOLATION")
            .status(HttpStatus.BAD_REQUEST.value())
            .message("Constraint violation")
            .errors(errors)
            .path(request.getRequestURI())
            .timestamp(LocalDateTime.now())
            .build();
        
        return errorResponse;
    }
}
```

### Response Example

```json
{
  "errorCode": "CONSTRAINT_VIOLATION",
  "status": 400,
  "message": "Constraint violation",
  "errors": {
    "id": "User ID must be positive",
    "page": "Page must be non-negative",
    "size": "Size must be at least 1"
  },
  "path": "/api/users/-1",
  "timestamp": "2024-01-15T10:30:45.123"
}
```

---

## üé® Custom Validators

### Custom Annotation

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneNumberValidator.class)
@Documented
public @interface ValidPhoneNumber {
    
    String message() default "Invalid phone number";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}
```

### Validator Implementation

```java
public class PhoneNumberValidator implements ConstraintValidator<ValidPhoneNumber, String> {
    
    private static final Pattern PHONE_PATTERN = Pattern.compile("^\\+?[1-9]\\d{1,14}$");
    
    @Override
    public void initialize(ValidPhoneNumber constraintAnnotation) {
        // Initialization logic if needed
    }
    
    @Override
    public boolean isValid(String phoneNumber, ConstraintValidatorContext context) {
        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {
            return true; // Use @NotNull for null checks
        }
        
        return PHONE_PATTERN.matcher(phoneNumber).matches();
    }
}
```

### Usage

```java
@Data
public class UserRequest {
    
    @NotNull(message = "Phone is required")
    @ValidPhoneNumber(message = "Phone number must be in E.164 format")
    private String phone;
}
```

### Custom Email Domain Validator

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailDomainValidator.class)
public @interface ValidEmailDomain {
    
    String message() default "Email domain is not allowed";
    
    String[] allowedDomains() default {};
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

public class EmailDomainValidator implements ConstraintValidator<ValidEmailDomain, String> {
    
    private Set<String> allowedDomains;
    
    @Override
    public void initialize(ValidEmailDomain constraintAnnotation) {
        this.allowedDomains = new HashSet<>(Arrays.asList(constraintAnnotation.allowedDomains()));
    }
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return true;
        }
        
        String domain = email.substring(email.lastIndexOf('@') + 1);
        return allowedDomains.contains(domain.toLowerCase());
    }
}

// Usage
@Data
public class EmployeeRequest {
    
    @Email(message = "Email must be valid")
    @ValidEmailDomain(
        allowedDomains = {"company.com", "company.net"},
        message = "Email must be from company domain"
    )
    private String email;
}
```

---

## üîç Field-Level Validation

### Comprehensive Field Validations

```java
@Data
public class ProductRequest {
    
    // String validations
    @NotBlank(message = "Product name is required")
    @Size(min = 3, max = 100, message = "Name must be between 3 and 100 characters")
    private String name;
    
    @NotBlank(message = "Description is required")
    @Size(max = 500, message = "Description cannot exceed 500 characters")
    private String description;
    
    // Numeric validations
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.01", message = "Price must be greater than 0")
    @DecimalMax(value = "999999.99", message = "Price cannot exceed 999999.99")
    @Digits(integer = 6, fraction = 2, message = "Price format is invalid")
    private BigDecimal price;
    
    @NotNull(message = "Stock quantity is required")
    @Min(value = 0, message = "Stock cannot be negative")
    @Max(value = 10000, message = "Stock cannot exceed 10000")
    private Integer stock;
    
    // Date validations
    @Future(message = "Launch date must be in the future")
    private LocalDate launchDate;
    
    @PastOrPresent(message = "Manufacture date cannot be in the future")
    private LocalDate manufactureDate;
    
    // Pattern validations
    @Pattern(regexp = "^[A-Z]{3}-\\d{6}$", message = "SKU must be in format XXX-123456")
    private String sku;
    
    // Collection validations
    @NotEmpty(message = "At least one category is required")
    @Size(max = 5, message = "Cannot have more than 5 categories")
    private List<String> categories;
    
    // Nested object validation
    @Valid
    @NotNull(message = "Manufacturer details are required")
    private ManufacturerRequest manufacturer;
}
```

### Nested Object Validation

```java
@Data
public class ManufacturerRequest {
    
    @NotBlank(message = "Manufacturer name is required")
    private String name;
    
    @Email(message = "Email must be valid")
    private String email;
    
    @Valid
    private AddressRequest address;
}

@Data
public class AddressRequest {
    
    @NotBlank(message = "Street is required")
    private String street;
    
    @NotBlank(message = "City is required")
    private String city;
    
    @NotBlank(message = "Zipcode is required")
    @Pattern(regexp = "^\\d{5}(-\\d{4})?$", message = "Invalid zipcode format")
    private String zipcode;
}
```

---

## üèóÔ∏è Class-Level Validation

### Custom Class Validator

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
public @interface PasswordMatches {
    
    String message() default "Passwords do not match";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

public class PasswordMatchesValidator implements ConstraintValidator<PasswordMatches, Object> {
    
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        if (obj instanceof UserRegistrationRequest) {
            UserRegistrationRequest user = (UserRegistrationRequest) obj;
            
            if (user.getPassword() == null || user.getConfirmPassword() == null) {
                return true; // Use @NotNull for null checks
            }
            
            return user.getPassword().equals(user.getConfirmPassword());
        }
        
        return false;
    }
}
```

### Usage

```java
@Data
@PasswordMatches
public class UserRegistrationRequest {
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;
    
    @NotBlank(message = "Confirm password is required")
    private String confirmPassword;
}
```

### Date Range Validator

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = DateRangeValidator.class)
public @interface ValidDateRange {
    
    String message() default "End date must be after start date";
    
    String startDate();
    
    String endDate();
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

public class DateRangeValidator implements ConstraintValidator<ValidDateRange, Object> {
    
    private String startDateField;
    private String endDateField;
    
    @Override
    public void initialize(ValidDateRange constraintAnnotation) {
        this.startDateField = constraintAnnotation.startDate();
        this.endDateField = constraintAnnotation.endDate();
    }
    
    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        try {
            Field startField = value.getClass().getDeclaredField(startDateField);
            Field endField = value.getClass().getDeclaredField(endDateField);
            
            startField.setAccessible(true);
            endField.setAccessible(true);
            
            LocalDate startDate = (LocalDate) startField.get(value);
            LocalDate endDate = (LocalDate) endField.get(value);
            
            if (startDate == null || endDate == null) {
                return true;
            }
            
            return !endDate.isBefore(startDate);
            
        } catch (Exception e) {
            return false;
        }
    }
}

// Usage
@Data
@ValidDateRange(startDate = "startDate", endDate = "endDate")
public class EventRequest {
    
    @NotNull(message = "Start date is required")
    private LocalDate startDate;
    
    @NotNull(message = "End date is required")
    private LocalDate endDate;
}
```

---

## üìå Best Practices

### 1. Use @Valid for Nested Objects

```java
// ‚úÖ Good - Validates nested objects
@Data
public class OrderRequest {
    
    @Valid
    @NotNull(message = "Shipping address is required")
    private AddressRequest shippingAddress;
    
    @Valid
    @NotEmpty(message = "At least one item is required")
    private List<OrderItemRequest> items;
}
```

### 2. Meaningful Error Messages

```java
// ‚úÖ Good - Clear, specific messages
@NotBlank(message = "Email is required")
@Email(message = "Email must be in valid format (e.g., user@example.com)")
private String email;

// ‚ùå Bad - Generic messages
@NotBlank
@Email
private String email;
```

### 3. Group Related Validations

```java
public interface BasicValidation {}
public interface AdvancedValidation {}

@Data
public class UserRequest {
    
    @NotBlank(groups = BasicValidation.class)
    private String name;
    
    @Email(groups = BasicValidation.class)
    private String email;
    
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$",
        groups = AdvancedValidation.class
    )
    private String password;
}

// Controller
@PostMapping("/basic")
public User createBasic(@Validated(BasicValidation.class) @RequestBody UserRequest request) {
    // Only basic validations run
}

@PostMapping("/advanced")
public User createAdvanced(@Validated(AdvancedValidation.class) @RequestBody UserRequest request) {
    // Only advanced validations run
}
```

### 4. Don't Validate in Multiple Places

```java
// ‚ùå Bad - Duplicate validation
@Service
public class UserService {
    public User create(UserRequest request) {
        if (request.getEmail() == null) {
            throw new InvalidRequestException("Email is required");
        }
        // ...
    }
}

// ‚úÖ Good - Single validation point
@Data
public class UserRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
}
```

### 5. Use Custom Validators for Complex Logic

```java
// ‚úÖ Good - Custom validator for complex logic
@ValidCreditCard
private String creditCardNumber;

// ‚ùå Bad - Validation in service
if (!isValidCreditCard(request.getCreditCardNumber())) {
    throw new InvalidRequestException("Invalid credit card");
}
```

### 6. Extract Field Errors Properly

```java
// ‚úÖ Good - Extract all field errors
Map<String, String> errors = new HashMap<>();
ex.getBindingResult().getFieldErrors().forEach(error -> 
    errors.put(error.getField(), error.getDefaultMessage())
);

// Also handle global errors
ex.getBindingResult().getGlobalErrors().forEach(error -> 
    errors.put(error.getObjectName(), error.getDefaultMessage())
);
```

---

## üé§ Interview Questions

### Q1: What is Bean Validation?
**Answer:** Java specification (JSR-303/JSR-380) for declarative validation using annotations.

### Q2: What is MethodArgumentNotValidException?
**Answer:** Exception thrown when @Valid fails on @RequestBody.

### Q3: What is ConstraintViolationException?
**Answer:** Exception thrown when validation fails on method parameters (path/query params).

### Q4: Difference between @NotNull, @NotEmpty, @NotBlank?
**Answer:**
- @NotNull: Value must not be null
- @NotEmpty: Collection/String must not be null or empty
- @NotBlank: String must not be null, empty, or whitespace

### Q5: How to validate request body?
**Answer:**
```java
@PostMapping
public User create(@Valid @RequestBody UserRequest request) { }
```

### Q6: How to validate path parameters?
**Answer:**
```java
@Validated // On class
@GetMapping("/{id}")
public User get(@PathVariable @Min(1) Long id) { }
```

### Q7: How to create custom validator?
**Answer:**
1. Create annotation with @Constraint
2. Implement ConstraintValidator
3. Apply annotation to field/class

### Q8: What is @Valid for nested objects?
**Answer:** Triggers validation on nested objects.

### Q9: How to extract field errors?
**Answer:**
```java
ex.getBindingResult().getFieldErrors().forEach(error -> 
    errors.put(error.getField(), error.getDefaultMessage())
);
```

### Q10: What is validation groups?
**Answer:** Group validations for different scenarios (BasicValidation, AdvancedValidation).

### Q11: How to handle validation errors globally?
**Answer:**
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ValidationErrorResponse handle(MethodArgumentNotValidException ex) { }
```

### Q12: Can you validate collections?
**Answer:** Yes, use @Valid on collection elements:
```java
List<@Valid OrderItemRequest> items;
```

### Q13: What is @Validated vs @Valid?
**Answer:**
- @Valid: Standard JSR-303, works on fields and parameters
- @Validated: Spring-specific, supports validation groups

### Q14: How to validate class-level constraints?
**Answer:** Create custom annotation on class, implement ConstraintValidator.

### Q15: Can you customize validation messages?
**Answer:** Yes, in annotation:
```java
@NotBlank(message = "Name is required")
```

### Q16: How to validate enum values?
**Answer:**
```java
@Pattern(regexp = "PENDING|PROCESSING|COMPLETED")
private String status;
```
Or create custom @ValidEnum validator.

### Q17: What is Payload in validation?
**Answer:** Additional metadata for validators, rarely used.

### Q18: How to validate date ranges?
**Answer:** Create class-level validator comparing two date fields.

### Q19: Can you disable validation?
**Answer:** Remove @Valid/@Validated annotation, but not recommended.

### Q20: Best practices for validation?
**Answer:**
1. Use @Valid for nested objects
2. Meaningful error messages
3. Group related validations
4. Single validation point
5. Custom validators for complex logic
6. Extract field errors properly
7. Don't expose sensitive data in errors

---

## üìö Summary

### Bean Validation

```java
@Data
public class UserRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Must be at least 18")
    private Integer age;
}
```

### Validation Exception Handler

```java
@RestControllerAdvice
public class ValidationExceptionHandler {
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ValidationErrorResponse handle(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        
        return ValidationErrorResponse.builder()
            .errorCode("VALIDATION_ERROR")
            .status(400)
            .message("Validation failed")
            .errors(errors)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

### Key Points

- **@Valid:** Trigger validation on request body
- **@Validated:** Enable method parameter validation
- **MethodArgumentNotValidException:** Request body validation
- **ConstraintViolationException:** Path/query parameter validation
- **Custom Validators:** Complex validation logic
- **Nested Validation:** Use @Valid on nested objects
- **Field Errors:** Extract as Map<String, String>

**Next:** Best Practices ‚Üí

