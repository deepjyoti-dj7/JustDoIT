# Production-ready Features - Complete Guide

---

## 1. Introduction to Production Readiness

Production readiness ensures your Spring Boot application runs reliably, securely, and efficiently in production environments.

### Why Production Readiness?

- **Reliability** - Minimize downtime and failures
- **Observability** - Monitor and troubleshoot effectively
- **Security** - Protect against attacks and data breaches
- **Performance** - Handle expected load efficiently
- **Maintainability** - Easy updates and configuration changes

### Key Pillars

1. **Health Checks** - Liveness and readiness probes
2. **Metrics** - Performance and resource monitoring
3. **Logging** - Comprehensive audit and debugging
4. **Security** - Authentication, authorization, encryption
5. **Configuration** - Externalized and environment-specific
6. **Resilience** - Graceful degradation and recovery

---

## 2. Production Checklist

### 2.1. Configuration Checklist

✅ **Externalized Configuration**
```yaml
# application.yml - Only non-sensitive defaults
spring:
  application:
    name: product-service
  profiles:
    active: ${ENVIRONMENT:dev}

# Environment variables for sensitive data
# DATABASE_URL=jdbc:postgresql://...
# DATABASE_USERNAME=...
# DATABASE_PASSWORD=...
```

✅ **Environment-Specific Profiles**
```yaml
# application-production.yml
spring:
  datasource:
    url: ${DATABASE_URL}
    username: ${DATABASE_USERNAME}
    password: ${DATABASE_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

logging:
  level:
    root: INFO
    com.example: INFO

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
```

✅ **Secrets Management**
```bash
# Kubernetes Secrets
kubectl create secret generic app-secrets \
  --from-literal=database-password=secretpass \
  --from-literal=api-key=myapikey

# Reference in deployment
env:
  - name: DATABASE_PASSWORD
    valueFrom:
      secretKeyRef:
        name: app-secrets
        key: database-password
```

### 2.2. Security Checklist

✅ **HTTPS Enabled**
```yaml
server:
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: ${KEYSTORE_PASSWORD}
    key-store-type: PKCS12
    key-alias: tomcat
  port: 8443

# Redirect HTTP to HTTPS
management:
  server:
    ssl:
      enabled: true
```

✅ **Security Headers**
```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .headers()
                .contentSecurityPolicy("default-src 'self'")
                .and()
                .xssProtection()
                .and()
                .frameOptions().deny()
                .and()
                .httpStrictTransportSecurity()
                    .maxAgeInSeconds(31536000)
                    .includeSubDomains(true);
        
        return http.build();
    }
}
```

✅ **Actuator Security**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
        exclude: shutdown,threaddump,heapdump
  
  endpoint:
    health:
      show-details: when-authorized
      roles: ADMIN
  
  server:
    port: 8081
    address: 127.0.0.1
```

### 2.3. Monitoring Checklist

✅ **Health Checks Configured**
```yaml
management:
  health:
    livenessState:
      enabled: true
    readinessState:
      enabled: true
  endpoint:
    health:
      probes:
        enabled: true
      group:
        readiness:
          include: db,redis,diskSpace
        liveness:
          include: ping
```

✅ **Metrics Collection**
```yaml
management:
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      slo:
        http.server.requests: 50ms,100ms,200ms,500ms,1s
```

### 2.4. Logging Checklist

✅ **Structured Logging**
```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyName>traceId</includeMdcKeyName>
            <includeMdcKeyName>spanId</includeMdcKeyName>
            <customFields>{"application":"product-service"}</customFields>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

✅ **Log Levels by Environment**
```yaml
# application-production.yml
logging:
  level:
    root: WARN
    com.example: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: WARN
```

---

## 3. Health Checks Configuration

### 3.1. Kubernetes Probes

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  template:
    spec:
      containers:
      - name: product-service
        image: product-service:1.0.0
        
        # Startup Probe - Initial application start
        startupProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 0
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 30  # 150 seconds max startup time
        
        # Liveness Probe - Is application running?
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        # Readiness Probe - Ready to serve traffic?
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 20
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
          successThreshold: 1
```

### 3.2. Custom Health Indicators

```java
@Component
public class ProductionReadinessHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisConnectionFactory redisFactory;
    
    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        try {
            // Check database connectivity
            checkDatabase();
            
            // Check cache connectivity
            checkRedis();
            
            // Check external API
            checkExternalAPI();
            
            builder.up()
                   .withDetail("database", "UP")
                   .withDetail("redis", "UP")
                   .withDetail("externalAPI", "UP");
            
        } catch (Exception e) {
            builder.down()
                   .withException(e);
        }
        
        return builder.build();
    }
    
    private void checkDatabase() throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            conn.createStatement().execute("SELECT 1");
        }
    }
    
    private void checkRedis() {
        redisFactory.getConnection().ping();
    }
    
    private void checkExternalAPI() {
        // Implementation
    }
}
```

---

## 4. Graceful Shutdown

### 4.1. Configuration

```yaml
server:
  shutdown: graceful

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s
```

### 4.2. Graceful Shutdown Listener

```java
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.stereotype.Component;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class GracefulShutdownListener implements ApplicationListener<ContextClosedEvent> {
    
    @Autowired
    private TaskExecutor taskExecutor;
    
    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        log.info("Graceful shutdown initiated");
        
        // Stop accepting new requests
        log.info("Stopping new request acceptance");
        
        // Wait for in-flight requests to complete
        waitForRequestsToComplete();
        
        // Close resources
        closeResources();
        
        log.info("Graceful shutdown completed");
    }
    
    private void waitForRequestsToComplete() {
        if (taskExecutor instanceof ThreadPoolTaskExecutor) {
            ThreadPoolTaskExecutor executor = (ThreadPoolTaskExecutor) taskExecutor;
            executor.setWaitForTasksToCompleteOnShutdown(true);
            executor.setAwaitTerminationSeconds(30);
        }
    }
    
    private void closeResources() {
        // Close database connections, cache, etc.
    }
}
```

---

## 5. Thread Dump Analysis

### 5.1. Capturing Thread Dump

```bash
# Using Actuator
curl http://localhost:8080/actuator/threaddump > threaddump.txt

# Using jstack
jstack <pid> > threaddump.txt

# Kubernetes
kubectl exec <pod> -- jstack 1 > threaddump.txt
```

### 5.2. Analyzing Deadlocks

```
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00007f8a1c0050c8 (object 0x00000000d5f20c88, a java.lang.Object),
  which is held by "Thread-2"
"Thread-2":
  waiting to lock monitor 0x00007f8a1c007f18 (object 0x00000000d5f20c98, a java.lang.Object),
  which is held by "Thread-1"
```

### 5.3. Identifying Thread Leaks

```java
@Component
public class ThreadMonitor {
    
    @Scheduled(fixedRate = 60000)
    public void monitorThreads() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        int threadCount = threadBean.getThreadCount();
        int peakThreadCount = threadBean.getPeakThreadCount();
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        
        log.info("Thread count: {}, Peak: {}, Deadlocked: {}", 
                 threadCount, peakThreadCount, 
                 deadlockedThreads != null ? deadlockedThreads.length : 0);
        
        if (threadCount > 500) {
            log.error("High thread count detected: {}", threadCount);
            // Alert or take action
        }
    }
}
```

---

## 6. Heap Dump Analysis

### 6.1. Capturing Heap Dump

```bash
# Using Actuator
curl -X POST http://localhost:8080/actuator/heapdump -o heapdump.hprof

# Using jmap
jmap -dump:live,format=b,file=heapdump.hprof <pid>

# Automatic on OOM
java -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/var/log/heapdumps \
     -jar application.jar
```

### 6.2. Analyzing with Eclipse MAT

**Common Memory Leak Patterns:**
- Unclosed resources (connections, streams)
- Static collections growing indefinitely
- ThreadLocal variables not cleared
- Event listeners not removed

---

## 7. JVM Tuning

### 7.1. Memory Configuration

```bash
java -Xms2g \                    # Initial heap size
     -Xmx4g \                    # Maximum heap size
     -XX:MetaspaceSize=256m \    # Initial metaspace
     -XX:MaxMetaspaceSize=512m \ # Maximum metaspace
     -XX:+UseG1GC \              # G1 garbage collector
     -XX:MaxGCPauseMillis=200 \  # GC pause time goal
     -XX:+UseStringDeduplication \ # Deduplicate strings
     -jar application.jar
```

### 7.2. GC Logging

```bash
java -Xlog:gc*:file=/var/log/gc.log:time,uptime,level,tags \
     -XX:+UseGCLogFileRotation \
     -XX:NumberOfGCLogFiles=10 \
     -XX:GCLogFileSize=10M \
     -jar application.jar
```

### 7.3. Performance Tuning

```yaml
# application-production.yml
server:
  tomcat:
    threads:
      max: 200
      min-spare: 10
    connection-timeout: 20000
    accept-count: 100
    max-connections: 10000

spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      leak-detection-threshold: 60000
```

---

## 8. External Configuration

### 8.1. Spring Cloud Config Server

**Config Server:**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/company/config-repo
          username: ${GIT_USERNAME}
          password: ${GIT_PASSWORD}
          default-label: main
```

**Client:**
```yaml
spring:
  application:
    name: product-service
  cloud:
    config:
      uri: http://config-server:8888
      fail-fast: true
      retry:
        max-attempts: 6
        initial-interval: 1000
```

### 8.2. Environment Variables

```bash
# .env file
SPRING_APPLICATION_NAME=product-service
SPRING_PROFILES_ACTIVE=production
DATABASE_URL=jdbc:postgresql://db:5432/products
DATABASE_USERNAME=dbuser
DATABASE_PASSWORD=secretpass
REDIS_HOST=redis
REDIS_PORT=6379
```

### 8.3. ConfigMap (Kubernetes)

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: product-service-config
data:
  application.yml: |
    spring:
      datasource:
        hikari:
          maximum-pool-size: 20
    management:
      endpoints:
        web:
          exposure:
            include: health,info,metrics
```

---

## 9. Error Handling

### 9.1. Global Exception Handler

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.NOT_FOUND.value())
            .error("Not Found")
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        log.error("Unexpected error", ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("Internal Server Error")
            .message("An unexpected error occurred")
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

### 9.2. Circuit Breaker (Resilience4j)

```java
@Service
public class ProductService {
    
    @CircuitBreaker(name = "externalAPI", fallbackMethod = "fallbackGetProduct")
    @Retry(name = "externalAPI")
    @TimeLimiter(name = "externalAPI")
    public CompletableFuture<Product> getProductFromExternal(String id) {
        return CompletableFuture.supplyAsync(() -> externalAPIClient.getProduct(id));
    }
    
    private CompletableFuture<Product> fallbackGetProduct(String id, Exception ex) {
        log.error("External API failed, using fallback", ex);
        return CompletableFuture.completedFuture(getCachedProduct(id));
    }
}
```

**Configuration:**
```yaml
resilience4j:
  circuitbreaker:
    instances:
      externalAPI:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000
        sliding-window-size: 10
        minimum-number-of-calls: 5
  
  retry:
    instances:
      externalAPI:
        max-attempts: 3
        wait-duration: 1000
  
  timelimiter:
    instances:
      externalAPI:
        timeout-duration: 3s
```

---

## 10. Deployment Strategies

### 10.1. Blue-Green Deployment

```yaml
# Blue deployment (current)
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  selector:
    app: product-service
    version: blue

---
# Green deployment (new)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: product-service
      version: green
```

### 10.2. Canary Deployment

```yaml
# Stable version: 90% traffic
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: product-service
      version: stable

---
# Canary version: 10% traffic
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: product-service
      version: canary
```

### 10.3. Rolling Update

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  replicas: 3
```

---

## 11. Monitoring Dashboards

### 11.1. Key Metrics to Monitor

**Application Metrics:**
- Request rate (requests/sec)
- Response time (p50, p95, p99)
- Error rate (%)
- Throughput (MB/sec)

**JVM Metrics:**
- Heap memory usage (%)
- GC pause time (ms)
- Thread count
- Class loading

**Infrastructure Metrics:**
- CPU usage (%)
- Memory usage (%)
- Disk I/O
- Network I/O

### 11.2. SLIs and SLOs

```yaml
# Service Level Indicators
sli:
  availability: 99.9%      # Uptime
  latency_p95: 200ms       # 95% of requests < 200ms
  error_rate: 0.1%         # < 0.1% 5xx errors

# Service Level Objectives
slo:
  availability: 99.95%
  latency_p95: 150ms
  error_rate: 0.05%
```

---

## 12. Troubleshooting Guide

### 12.1. High Memory Usage

**Diagnosis:**
```bash
# Check heap usage
curl http://localhost:8080/actuator/metrics/jvm.memory.used

# Capture heap dump
curl -X POST http://localhost:8080/actuator/heapdump -o heap.hprof

# Analyze with MAT
```

**Common Causes:**
- Memory leaks (unclosed resources)
- Large object retention
- Cache misconfiguration

### 12.2. Slow Response Times

**Diagnosis:**
```bash
# Check response time metrics
curl http://localhost:8080/actuator/metrics/http.server.requests

# Check database connection pool
curl http://localhost:8080/actuator/metrics/hikaricp.connections.active
```

**Common Causes:**
- Database query performance
- External API latency
- Thread pool exhaustion

### 12.3. Application Crashes

**Diagnosis:**
```bash
# Check logs
kubectl logs <pod> --previous

# Check JVM crashes
cat hs_err_pid*.log

# Check OOM dumps
ls -lh /var/log/heapdumps/
```

---

## 13. Interview Questions

**Q1: What is graceful shutdown?**
**A:** Stops accepting new requests, completes in-flight requests before shutdown.

**Q2: How to configure graceful shutdown?**
**A:** server.shutdown=graceful, spring.lifecycle.timeout-per-shutdown-phase=30s

**Q3: What is thread dump?**
**A:** Snapshot of all thread states, useful for diagnosing deadlocks.

**Q4: How to capture heap dump?**
**A:** /actuator/heapdump endpoint or jmap -dump command.

**Q5: What is G1GC?**
**A:** Garbage-First Garbage Collector, balances throughput and latency.

**Q6: What is liveness probe?**
**A:** Checks if application is running, restarts pod if fails.

**Q7: What is readiness probe?**
**A:** Checks if application is ready for traffic, removes from endpoints if fails.

**Q8: What is blue-green deployment?**
**A:** Two identical environments, switch traffic from blue to green.

**Q9: What is canary deployment?**
**A:** Gradually route traffic to new version (e.g., 10% canary, 90% stable).

**Q10: What is circuit breaker?**
**A:** Prevents cascading failures by failing fast when dependency is down.

**Q11: What is externalized configuration?**
**A:** Store config outside code (env vars, config server, ConfigMap).

**Q12: What is Spring Cloud Config?**
**A:** Centralized configuration server for distributed systems.

**Q13: What is HikariCP?**
**A:** High-performance JDBC connection pool used by Spring Boot.

**Q14: What is leak detection threshold?**
**A:** Logs warning if connection not returned within threshold (HikariCP).

**Q15: What is SLI?**
**A:** Service Level Indicator - metrics measuring service quality.

**Q16: What is SLO?**
**A:** Service Level Objective - target values for SLIs.

**Q17: What is p95 latency?**
**A:** 95th percentile - 95% of requests complete faster than this value.

**Q18: What is structured logging?**
**A:** Logs in JSON format with fields, easier to parse and search.

**Q19: What is HSTS?**
**A:** HTTP Strict Transport Security - forces HTTPS connections.

**Q20: What is CSP?**
**A:** Content Security Policy - prevents XSS by restricting resource loading.

---

## 14. Summary

Production readiness requires comprehensive planning across multiple dimensions. Key areas: Health checks (liveness/readiness probes for Kubernetes), Metrics (JVM, HTTP, database monitoring), Logging (structured, environment-specific levels), Security (HTTPS, actuator security, secrets management), Configuration (externalized, Spring Cloud Config, ConfigMap). Enable graceful shutdown with server.shutdown=graceful. Use thread dumps for deadlock analysis, heap dumps for memory leaks. Tune JVM with appropriate memory settings (-Xms, -Xmx) and G1GC. Configure HikariCP connection pool properly. Implement circuit breakers with Resilience4j. Use deployment strategies: blue-green, canary, rolling update. Monitor SLIs and SLOs. Essential checklist: externalized config, HTTPS, health probes, metrics export, structured logging, error handling, resource limits. Production readiness ensures reliability, security, and maintainability.

---

**Next:** README (Module Overview) →
