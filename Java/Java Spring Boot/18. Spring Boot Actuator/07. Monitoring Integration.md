# Monitoring Integration - Complete Guide

---

## 1. Introduction to Monitoring Integration

Integrating Spring Boot Actuator with monitoring systems enables comprehensive observability, alerting, and visualization.

### Why Monitoring Integration?

- **Real-time visibility** - Track application health and performance
- **Proactive alerting** - Detect issues before users notice
- **Historical analysis** - Trend analysis and capacity planning
- **Centralized dashboards** - Single pane of glass for all services
- **Incident response** - Quick troubleshooting with metrics and traces

### Popular Monitoring Stacks

- **Prometheus + Grafana** - Open source, widely adopted
- **Datadog** - SaaS, comprehensive features
- **New Relic** - APM with infrastructure monitoring
- **CloudWatch** - AWS native monitoring
- **Elastic APM** - Part of ELK stack

---

## 2. Prometheus Integration

### 2.1. Dependencies

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

### 2.2. Configuration

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:dev}
```

### 2.3. Prometheus Endpoint

**Access:** `GET /actuator/prometheus`

**Response:**
```
# HELP jvm_memory_used_bytes The amount of used memory
# TYPE jvm_memory_used_bytes gauge
jvm_memory_used_bytes{application="product-service",area="heap",environment="production",id="PS Eden Space",} 5.2428800E7

# HELP http_server_requests_seconds  
# TYPE http_server_requests_seconds summary
http_server_requests_seconds_count{application="product-service",exception="None",method="GET",outcome="SUCCESS",status="200",uri="/api/products/{id}",} 1523.0
http_server_requests_seconds_sum{application="product-service",exception="None",method="GET",outcome="SUCCESS",status="200",uri="/api/products/{id}",} 45.678
```

### 2.4. Prometheus Configuration

**prometheus.yml:**
```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    cluster: 'production'
    region: 'us-east-1'

scrape_configs:
  - job_name: 'spring-boot-actuator'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
        labels:
          application: 'product-service'
          team: 'product-team'
  
  # Service discovery for Kubernetes
  - job_name: 'kubernetes-pods'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        target_label: __address__
```

### 2.5. Kubernetes Service Discovery

**deployment.yml:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/actuator/prometheus"
        prometheus.io/port: "8080"
    spec:
      containers:
      - name: product-service
        image: product-service:1.0.0
        ports:
        - containerPort: 8080
```

---

## 3. Grafana Dashboards

### 3.1. Data Source Configuration

**Add Prometheus Data Source in Grafana:**
```yaml
apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
    editable: true
```

### 3.2. JVM Dashboard JSON

```json
{
  "dashboard": {
    "title": "Spring Boot JVM Metrics",
    "panels": [
      {
        "title": "Heap Memory Usage",
        "targets": [
          {
            "expr": "jvm_memory_used_bytes{area=\"heap\"}",
            "legendFormat": "{{id}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "GC Pause Time",
        "targets": [
          {
            "expr": "rate(jvm_gc_pause_seconds_sum[1m])",
            "legendFormat": "{{action}}-{{cause}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Thread Count",
        "targets": [
          {
            "expr": "jvm_threads_live",
            "legendFormat": "Live Threads"
          }
        ],
        "type": "graph"
      }
    ]
  }
}
```

### 3.3. HTTP Metrics Dashboard

```json
{
  "panels": [
    {
      "title": "Request Rate",
      "targets": [
        {
          "expr": "rate(http_server_requests_seconds_count{application=\"product-service\"}[5m])",
          "legendFormat": "{{method}} {{uri}} {{status}}"
        }
      ]
    },
    {
      "title": "Response Time p95",
      "targets": [
        {
          "expr": "histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le, uri))",
          "legendFormat": "{{uri}}"
        }
      ]
    },
    {
      "title": "Error Rate",
      "targets": [
        {
          "expr": "rate(http_server_requests_seconds_count{status=~\"5..\"}[5m])",
          "legendFormat": "{{uri}}"
        }
      ]
    }
  ]
}
```

### 3.4. Importing Spring Boot Dashboard

Grafana provides pre-built dashboards:
- **JVM (Micrometer)** - Dashboard ID: 4701
- **Spring Boot Statistics** - Dashboard ID: 6756
- **Spring Boot APM Dashboard** - Dashboard ID: 12900

**Import Steps:**
1. Go to Grafana → Dashboards → Import
2. Enter Dashboard ID
3. Select Prometheus data source
4. Click Import

---

## 4. Alerting Configuration

### 4.1. Prometheus Alert Rules

**alerts.yml:**
```yaml
groups:
  - name: spring_boot_alerts
    interval: 30s
    rules:
      # High Memory Usage
      - alert: HighMemoryUsage
        expr: (jvm_memory_used_bytes{area="heap"} / jvm_memory_max_bytes{area="heap"}) > 0.9
        for: 5m
        labels:
          severity: warning
          team: product-team
        annotations:
          summary: "High memory usage on {{ $labels.instance }}"
          description: "JVM heap memory usage is above 90% (current: {{ $value | humanizePercentage }})"
      
      # High Error Rate
      - alert: HighErrorRate
        expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
          team: product-team
        annotations:
          summary: "High error rate on {{ $labels.instance }}"
          description: "Error rate is {{ $value | humanize }} req/s"
      
      # Slow Response Time
      - alert: SlowResponseTime
        expr: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le, uri)) > 1
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Slow response time for {{ $labels.uri }}"
          description: "p95 response time is {{ $value }}s"
      
      # Service Down
      - alert: ServiceDown
        expr: up{job="spring-boot-actuator"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service {{ $labels.instance }} is down"
          description: "{{ $labels.instance }} has been down for more than 1 minute"
      
      # High GC Time
      - alert: HighGCTime
        expr: rate(jvm_gc_pause_seconds_sum[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High GC time on {{ $labels.instance }}"
          description: "GC is consuming {{ $value | humanizePercentage }} of CPU time"
```

### 4.2. Alertmanager Configuration

**alertmanager.yml:**
```yaml
global:
  resolve_timeout: 5m

route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h
  receiver: 'default'
  routes:
    - match:
        severity: critical
      receiver: 'pagerduty'
    - match:
        severity: warning
      receiver: 'slack'

receivers:
  - name: 'default'
    email_configs:
      - to: 'team@example.com'
        from: 'alertmanager@example.com'
        smarthost: smtp.example.com:587
  
  - name: 'slack'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'
        channel: '#alerts'
        title: '{{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
  
  - name: 'pagerduty'
    pagerduty_configs:
      - service_key: 'YOUR_PAGERDUTY_KEY'
```

---

## 5. Datadog Integration

### 5.1. Dependencies

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-datadog</artifactId>
</dependency>
```

### 5.2. Configuration

```yaml
management:
  metrics:
    export:
      datadog:
        enabled: true
        api-key: ${DATADOG_API_KEY}
        application-key: ${DATADOG_APP_KEY}
        uri: https://api.datadoghq.com
        step: 10s
        batch-size: 10000
    tags:
      service: product-service
      env: production
      version: 1.0.0
```

### 5.3. Datadog Agent Configuration

**datadog.yaml:**
```yaml
api_key: YOUR_API_KEY
site: datadoghq.com
logs_enabled: true

apm_config:
  enabled: true
  env: production

process_config:
  enabled: "true"
```

---

## 6. CloudWatch Integration

### 6.1. Dependencies

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-cloudwatch2</artifactId>
</dependency>
```

### 6.2. Configuration

```yaml
management:
  metrics:
    export:
      cloudwatch:
        enabled: true
        namespace: ProductService
        step: 1m
        batch-size: 20
    tags:
      application: product-service
      environment: production

cloud:
  aws:
    credentials:
      access-key: ${AWS_ACCESS_KEY}
      secret-key: ${AWS_SECRET_KEY}
    region:
      static: us-east-1
```

### 6.3. CloudWatch Dashboard

```json
{
  "widgets": [
    {
      "type": "metric",
      "properties": {
        "metrics": [
          ["ProductService", "jvm.memory.used", {"stat": "Average"}],
          [".", "http.server.requests", {"stat": "Sum"}]
        ],
        "period": 300,
        "stat": "Average",
        "region": "us-east-1",
        "title": "Application Metrics"
      }
    }
  ]
}
```

---

## 7. Elastic APM Integration

### 7.1. Agent Download

```bash
wget https://repo1.maven.org/maven2/co/elastic/apm/elastic-apm-agent/1.39.0/elastic-apm-agent-1.39.0.jar
```

### 7.2. JVM Arguments

```bash
java -javaagent:/path/to/elastic-apm-agent.jar \
     -Delastic.apm.service_name=product-service \
     -Delastic.apm.server_urls=http://apm-server:8200 \
     -Delastic.apm.secret_token=YOUR_SECRET_TOKEN \
     -Delastic.apm.environment=production \
     -jar application.jar
```

### 7.3. Configuration

**elasticapm.properties:**
```properties
service_name=product-service
server_urls=http://apm-server:8200
secret_token=YOUR_SECRET_TOKEN
environment=production
application_packages=com.example
log_level=INFO
capture_body=all
capture_headers=true
```

---

## 8. Custom Metrics Exporters

### 8.1. Multiple Registries

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.composite.CompositeMeterRegistry;
import io.micrometer.prometheus.PrometheusMeterRegistry;
import io.micrometer.datadog.DatadogMeterRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MetricsExportConfig {
    
    @Bean
    public MeterRegistry meterRegistry(
            PrometheusMeterRegistry prometheusRegistry,
            DatadogMeterRegistry datadogRegistry) {
        
        CompositeMeterRegistry composite = new CompositeMeterRegistry();
        composite.add(prometheusRegistry);
        composite.add(datadogRegistry);
        
        return composite;
    }
}
```

---

## 9. Health Check Monitoring

### 9.1. External Health Monitoring

```bash
# Kubernetes Liveness Probe
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Kubernetes Readiness Probe
readinessProbe:
  httpGet:
    path: /actuator/health/readiness
    port: 8080
  initialDelaySeconds: 20
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
```

### 9.2. Uptime Monitoring

**Prometheus Query:**
```promql
# Service uptime
time() - process_start_time_seconds{application="product-service"}

# Availability percentage (last 24h)
avg_over_time(up{job="spring-boot-actuator"}[24h]) * 100
```

---

## 10. Best Practices

### 10.1. Metric Naming

✅ **Good:**
```
http_server_requests_seconds
jvm_memory_used_bytes
database_connections_active
```

❌ **Bad:**
```
httpRequests
JVM_Memory
db-connections
```

### 10.2. Tag Strategy

```yaml
management:
  metrics:
    tags:
      # Low cardinality tags
      application: product-service
      environment: production
      region: us-east-1
      team: product-team
      
      # Avoid high cardinality
      # user_id: ${user.id}  # ❌ Millions of users
      # request_id: ${request.id}  # ❌ Unique per request
```

### 10.3. Alert Thresholds

- Set realistic thresholds based on historical data
- Use percentiles (p95, p99) for latency alerts
- Avoid alert fatigue with appropriate `for` duration
- Group related alerts
- Include runbook links in annotations

---

## 11. Interview Questions

**Q1: How to integrate with Prometheus?**
**A:** Add micrometer-registry-prometheus dependency, expose /actuator/prometheus endpoint.

**Q2: What is Grafana?**
**A:** Visualization and dashboarding tool, commonly used with Prometheus.

**Q3: What metrics format does Prometheus use?**
**A:** Plain text format with metric name, labels, and value.

**Q4: How to create Prometheus alerts?**
**A:** Define alert rules in alerts.yml with PromQL expressions.

**Q5: What is Alertmanager?**
**A:** Component that handles alerts from Prometheus, sends notifications.

**Q6: How to monitor JVM metrics?**
**A:** Use jvm.memory.used, jvm.gc.pause, jvm.threads.live from Micrometer.

**Q7: What is service discovery in Prometheus?**
**A:** Automatic discovery of targets (e.g., Kubernetes pods) for scraping.

**Q8: How to integrate with Datadog?**
**A:** Add micrometer-registry-datadog, configure API key and application key.

**Q9: What is CloudWatch?**
**A:** AWS native monitoring service for metrics, logs, and alarms.

**Q10: What is Elastic APM?**
**A:** Application performance monitoring part of Elastic Stack (ELK).

**Q11: What is CompositeMeterRegistry?**
**A:** Combines multiple meter registries to export metrics to multiple systems.

**Q12: What is scrape interval?**
**A:** How often Prometheus pulls metrics from endpoints (default: 15s).

**Q13: What is PromQL?**
**A:** Prometheus Query Language for querying time series data.

**Q14: How to monitor error rate?**
**A:** rate(http_server_requests_seconds_count{status=~"5.."}[5m])

**Q15: What is p95 response time?**
**A:** 95th percentile - 95% of requests faster than this value.

**Q16: How to create Grafana dashboard?**
**A:** Use Grafana UI or import JSON, query Prometheus data source.

**Q17: What is Alert fatigue?**
**A:** Too many alerts desensitizing teams; use appropriate thresholds and grouping.

**Q18: How to monitor Kubernetes pods?**
**A:** Use kubernetes_sd_configs in Prometheus with pod annotations.

**Q19: What is histogram_quantile?**
**A:** PromQL function to calculate percentiles from histogram metrics.

**Q20: Best practice for metric tags?**
**A:** Use low cardinality tags (environment, service), avoid high cardinality (user_id, request_id).

---

## 12. Summary

Integrate Actuator with monitoring systems for comprehensive observability. Prometheus + Grafana: Popular open source stack. Add micrometer-registry-prometheus for Prometheus. Configure scrape in prometheus.yml. Create Grafana dashboards for visualization. Set up alerts with Prometheus alert rules and Alertmanager. Alternatives: Datadog (SaaS), CloudWatch (AWS), Elastic APM. Use CompositeMeterRegistry for multiple exporters. Monitor JVM, HTTP, database metrics. Create meaningful alerts with appropriate thresholds. Use service discovery for Kubernetes. Essential for production monitoring and incident response.

---

**Next:** Production-ready Features →
