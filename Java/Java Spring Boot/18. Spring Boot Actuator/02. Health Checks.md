# Health Checks - Complete Guide

---

## 1. Introduction to Health Checks

Health checks determine if an application is functioning correctly and ready to serve requests.

### Why Health Checks?

- **Load balancer** - Remove unhealthy instances from rotation
- **Kubernetes** - Restart failed pods
- **Monitoring** - Alert on health issues
- **Circuit breakers** - Stop sending traffic to unhealthy services
- **Deployment** - Verify successful deployment

### Health Status

- **UP** - Application is healthy
- **DOWN** - Application is unhealthy
- **OUT_OF_SERVICE** - Temporarily unavailable
- **UNKNOWN** - Health status cannot be determined

---

## 2. Basic Health Endpoint

### 2.1. Simple Health Check

**URL:** `GET /actuator/health`

**Configuration:**
```yaml
management:
  endpoint:
    health:
      enabled: true
```

**Response:**
```json
{
  "status": "UP"
}
```

### 2.2. Detailed Health Information

```yaml
management:
  endpoint:
    health:
      show-details: always  # Options: always, when-authorized, never
      show-components: always
```

**Response:**
```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "PostgreSQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 499963174912,
        "free": 336764821504,
        "threshold": 10485760
      }
    },
    "ping": {
      "status": "UP"
    }
  }
}
```

---

## 3. Built-in Health Indicators

### 3.1. Database Health Indicator

Automatically enabled when database is configured.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: user
    password: password
```

**Health Response:**
```json
{
  "db": {
    "status": "UP",
    "details": {
      "database": "PostgreSQL",
      "validationQuery": "isValid()"
    }
  }
}
```

### 3.2. Disk Space Health Indicator

```yaml
management:
  health:
    diskspace:
      enabled: true
      threshold: 10MB  # Minimum free space
      path: /
```

**Response:**
```json
{
  "diskSpace": {
    "status": "UP",
    "details": {
      "total": 499963174912,
      "free": 336764821504,
      "threshold": 10485760,
      "exists": true
    }
  }
}
```

### 3.3. Redis Health Indicator

```yaml
spring:
  redis:
    host: localhost
    port: 6379
```

**Response:**
```json
{
  "redis": {
    "status": "UP",
    "details": {
      "version": "7.0.5"
    }
  }
}
```

### 3.4. Other Built-in Indicators

- **Cassandra** - `CassandraHealthIndicator`
- **Elasticsearch** - `ElasticsearchHealthIndicator`
- **Mongo** - `MongoHealthIndicator`
- **RabbitMQ** - `RabbitHealthIndicator`
- **Kafka** - `KafkaHealthIndicator`
- **Mail** - `MailHealthIndicator`
- **JMS** - `JmsHealthIndicator`

---

## 4. Custom Health Indicators

### 4.1. Simple Custom Health Indicator

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        boolean isHealthy = checkHealth();
        
        if (isHealthy) {
            return Health.up()
                    .withDetail("message", "Service is running")
                    .withDetail("timestamp", System.currentTimeMillis())
                    .build();
        } else {
            return Health.down()
                    .withDetail("error", "Service is unavailable")
                    .build();
        }
    }
    
    private boolean checkHealth() {
        // Custom health check logic
        return true;
    }
}
```

### 4.2. External Service Health Check

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
public class ExternalServiceHealthIndicator implements HealthIndicator {
    
    private final RestTemplate restTemplate;
    private static final String SERVICE_URL = "https://api.example.com/health";
    
    public ExternalServiceHealthIndicator(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
    
    @Override
    public Health health() {
        try {
            String response = restTemplate.getForObject(SERVICE_URL, String.class);
            
            return Health.up()
                    .withDetail("service", "external-api")
                    .withDetail("response", response)
                    .build();
                    
        } catch (Exception e) {
            return Health.down()
                    .withDetail("service", "external-api")
                    .withDetail("error", e.getMessage())
                    .build();
        }
    }
}
```

### 4.3. Database Connection Pool Health

```java
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class DatabaseConnectionPoolHealthIndicator implements HealthIndicator {
    
    private final HikariDataSource dataSource;
    
    public DatabaseConnectionPoolHealthIndicator(HikariDataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    @Override
    public Health health() {
        try {
            int activeConnections = dataSource.getHikariPoolMXBean().getActiveConnections();
            int totalConnections = dataSource.getHikariPoolMXBean().getTotalConnections();
            int maxPoolSize = dataSource.getMaximumPoolSize();
            
            double usagePercent = (double) activeConnections / maxPoolSize * 100;
            
            Health.Builder builder = usagePercent < 80 ? Health.up() : Health.outOfService();
            
            return builder
                    .withDetail("active", activeConnections)
                    .withDetail("total", totalConnections)
                    .withDetail("max", maxPoolSize)
                    .withDetail("usage", String.format("%.2f%%", usagePercent))
                    .build();
                    
        } catch (Exception e) {
            return Health.down()
                    .withException(e)
                    .build();
        }
    }
}
```

---

## 5. Reactive Health Indicators

### 5.1. Reactive Health Indicator

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.ReactiveHealthIndicator;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Component
public class ReactiveCustomHealthIndicator implements ReactiveHealthIndicator {
    
    @Override
    public Mono<Health> health() {
        return checkHealth()
                .map(isHealthy -> {
                    if (isHealthy) {
                        return Health.up()
                                .withDetail("status", "operational")
                                .build();
                    } else {
                        return Health.down()
                                .withDetail("status", "degraded")
                                .build();
                    }
                })
                .onErrorResume(ex -> Mono.just(
                        Health.down()
                                .withException(ex)
                                .build()
                ));
    }
    
    private Mono<Boolean> checkHealth() {
        // Async health check
        return Mono.just(true);
    }
}
```

---

## 6. Health Groups

### 6.1. Configuring Health Groups

```yaml
management:
  endpoint:
    health:
      group:
        liveness:
          include: ping,diskSpace
          show-details: always
        readiness:
          include: db,redis,external-service
          show-details: always
```

### 6.2. Accessing Health Groups

**Liveness:** `GET /actuator/health/liveness`
```json
{
  "status": "UP",
  "components": {
    "ping": {
      "status": "UP"
    },
    "diskSpace": {
      "status": "UP"
    }
  }
}
```

**Readiness:** `GET /actuator/health/readiness`
```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP"
    },
    "redis": {
      "status": "UP"
    },
    "externalService": {
      "status": "UP"
    }
  }
}
```

---

## 7. Kubernetes Liveness and Readiness Probes

### 7.1. Configuration

```yaml
management:
  endpoint:
    health:
      probes:
        enabled: true
      group:
        liveness:
          include: livenessState
        readiness:
          include: readinessState,db,redis
```

### 7.2. Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  template:
    spec:
      containers:
      - name: product-service
        image: product-service:1.0.0
        ports:
        - containerPort: 8080
        
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 20
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
```

### 7.3. Liveness vs Readiness

**Liveness:**
- Answers: "Is the application running?"
- Failure: Kubernetes restarts the pod
- Should include: Basic process checks, deadlock detection

**Readiness:**
- Answers: "Is the application ready to serve traffic?"
- Failure: Kubernetes removes pod from service endpoints
- Should include: Database connectivity, external dependencies

---

## 8. Availability States

### 8.1. Application Availability

```java
import org.springframework.boot.availability.AvailabilityChangeEvent;
import org.springframework.boot.availability.LivenessState;
import org.springframework.boot.availability.ReadinessState;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AvailabilityService {
    
    private final ApplicationEventPublisher eventPublisher;
    
    public void markAsNotLive() {
        AvailabilityChangeEvent.publish(
            eventPublisher,
            this,
            LivenessState.BROKEN
        );
    }
    
    public void markAsLive() {
        AvailabilityChangeEvent.publish(
            eventPublisher,
            this,
            LivenessState.CORRECT
        );
    }
    
    public void markAsNotReady() {
        AvailabilityChangeEvent.publish(
            eventPublisher,
            this,
            ReadinessState.REFUSING_TRAFFIC
        );
    }
    
    public void markAsReady() {
        AvailabilityChangeEvent.publish(
            eventPublisher,
            this,
            ReadinessState.ACCEPTING_TRAFFIC
        );
    }
}
```

---

## 9. Composite Health Indicators

### 9.1. Creating Composite Indicator

```java
import org.springframework.boot.actuate.health.CompositeHealthContributor;
import org.springframework.boot.actuate.health.HealthContributor;
import org.springframework.boot.actuate.health.NamedContributor;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

@Component("microservices")
public class MicroservicesHealthIndicator implements CompositeHealthContributor {
    
    private final Map<String, HealthContributor> contributors = new LinkedHashMap<>();
    
    public MicroservicesHealthIndicator() {
        contributors.put("orderService", new ExternalServiceHealthIndicator("http://order-service/health"));
        contributors.put("paymentService", new ExternalServiceHealthIndicator("http://payment-service/health"));
        contributors.put("inventoryService", new ExternalServiceHealthIndicator("http://inventory-service/health"));
    }
    
    @Override
    public HealthContributor getContributor(String name) {
        return contributors.get(name);
    }
    
    @Override
    public Iterator<NamedContributor<HealthContributor>> iterator() {
        return contributors.entrySet().stream()
                .map(entry -> NamedContributor.of(entry.getKey(), entry.getValue()))
                .iterator();
    }
}
```

---

## 10. Timeout Configuration

### 10.1. Health Check Timeout

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.concurrent.*;

@Component
public class TimeoutHealthIndicator implements HealthIndicator {
    
    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private static final Duration TIMEOUT = Duration.ofSeconds(5);
    
    @Override
    public Health health() {
        Future<Health> future = executor.submit(this::performHealthCheck);
        
        try {
            return future.get(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            future.cancel(true);
            return Health.down()
                    .withDetail("error", "Health check timed out")
                    .build();
        } catch (Exception e) {
            return Health.down()
                    .withException(e)
                    .build();
        }
    }
    
    private Health performHealthCheck() {
        // Potentially slow health check
        return Health.up().build();
    }
}
```

---

## 11. Caching Health Results

### 11.1. Cached Health Indicator

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class CachedHealthIndicator implements HealthIndicator {
    
    @Override
    @Cacheable(value = "health", unless = "#result.status.code != 'UP'")
    public Health health() {
        return performExpensiveHealthCheck();
    }
    
    private Health performExpensiveHealthCheck() {
        // Expensive operation (database query, external API call)
        try {
            Thread.sleep(1000);  // Simulate slow check
            return Health.up().build();
        } catch (InterruptedException e) {
            return Health.down().build();
        }
    }
}
```

**Cache Configuration:**
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("health");
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.SECONDS)
                .maximumSize(100));
        return cacheManager;
    }
}
```

---

## 12. Disabling Health Indicators

### 12.1. Disable Specific Indicator

```yaml
management:
  health:
    db:
      enabled: false  # Disable database health check
    redis:
      enabled: false  # Disable Redis health check
    diskspace:
      enabled: true   # Keep disk space check
```

### 12.2. Disable All Default Indicators

```yaml
management:
  health:
    defaults:
      enabled: false  # Disable all default indicators
```

---

## 13. Security for Health Endpoint

### 13.1. Public vs Authenticated Access

```yaml
management:
  endpoint:
    health:
      show-details: when-authorized  # Show details only when authenticated
      roles: ADMIN  # Required role to see details
```

### 13.2. Security Configuration

```java
@Configuration
public class HealthSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/actuator/health/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            );
        
        return http.build();
    }
}
```

---

## 14. Best Practices

### 14.1. Health Check Design

✅ **DO:**
- Keep health checks fast (< 1 second)
- Check critical dependencies only
- Use timeouts to prevent hanging
- Cache expensive health checks
- Separate liveness from readiness

❌ **DON'T:**
- Include non-critical checks in liveness
- Perform expensive operations
- Check transient failures in liveness
- Return DOWN for temporary issues

### 14.2. Liveness Probe Guidelines

```java
@Component
public class LivenessHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        // Simple checks only:
        // - Is JVM responding?
        // - Are critical threads alive?
        // - Is there a deadlock?
        
        if (isDeadlocked()) {
            return Health.down()
                    .withDetail("reason", "Thread deadlock detected")
                    .build();
        }
        
        return Health.up().build();
    }
    
    private boolean isDeadlocked() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        return deadlockedThreads != null && deadlockedThreads.length > 0;
    }
}
```

### 14.3. Readiness Probe Guidelines

```java
@Component
public class ReadinessHealthIndicator implements HealthIndicator {
    
    private final DataSource dataSource;
    private final RedisTemplate<String, String> redisTemplate;
    
    @Override
    public Health health() {
        // Check all critical dependencies:
        // - Database connectivity
        // - Cache availability
        // - External services
        
        if (!isDatabaseReady() || !isRedisReady()) {
            return Health.outOfService()
                    .withDetail("database", isDatabaseReady())
                    .withDetail("redis", isRedisReady())
                    .build();
        }
        
        return Health.up().build();
    }
}
```

---

## 15. Interview Questions

**Q1: What is a health check?**
**A:** Endpoint that determines if application is functioning correctly and ready to serve traffic.

**Q2: What are the health status values?**
**A:** UP (healthy), DOWN (unhealthy), OUT_OF_SERVICE (temporarily unavailable), UNKNOWN.

**Q3: What is HealthIndicator interface?**
**A:** Interface for creating custom health checks, implements health() method.

**Q4: Name 3 built-in health indicators.**
**A:** DatabaseHealthIndicator, DiskSpaceHealthIndicator, RedisHealthIndicator.

**Q5: Liveness vs Readiness probe?**
**A:** Liveness: Is app running? (restart if fails). Readiness: Ready for traffic? (remove from load balancer if fails).

**Q6: How to show health details?**
**A:** Set `management.endpoint.health.show-details=always`.

**Q7: What is health group?**
**A:** Grouping of specific health indicators for different purposes (liveness, readiness).

**Q8: How to create custom health indicator?**
**A:** Implement HealthIndicator interface and return Health object.

**Q9: What should liveness probe check?**
**A:** Basic process health: JVM responding, no deadlocks, critical threads alive.

**Q10: What should readiness probe check?**
**A:** All dependencies: database, cache, external services, message queues.

**Q11: How to disable health indicator?**
**A:** Set `management.health.{indicator}.enabled=false`.

**Q12: What is CompositeHealthContributor?**
**A:** Interface for creating hierarchical health checks with multiple sub-indicators.

**Q13: Why cache health check results?**
**A:** To avoid expensive operations on every health check call.

**Q14: How to secure health endpoint?**
**A:** Use Spring Security with `show-details=when-authorized` and role requirements.

**Q15: What is AvailabilityState?**
**A:** Application state representing LivenessState and ReadinessState.

**Q16: How to mark application as not ready?**
**A:** Publish AvailabilityChangeEvent with ReadinessState.REFUSING_TRAFFIC.

**Q17: What timeout for health checks?**
**A:** Keep under 1-2 seconds to avoid affecting load balancer decisions.

**Q18: What happens when liveness fails?**
**A:** Kubernetes restarts the pod/container.

**Q19: What happens when readiness fails?**
**A:** Kubernetes removes pod from service endpoints, stops sending traffic.

**Q20: Should database check be in liveness?**
**A:** No, database should be in readiness. Temporary DB issues shouldn't restart app.

---

## 16. Summary

Health checks determine application health status (UP, DOWN, OUT_OF_SERVICE). Spring Boot provides built-in indicators: database, Redis, disk space. Create custom indicators by implementing HealthIndicator interface. Use health groups for liveness (app running?) and readiness (ready for traffic?). Kubernetes uses liveness probes to restart pods, readiness probes to route traffic. Keep liveness checks simple and fast. Include all dependencies in readiness. Use `show-details` to control information exposure. Secure sensitive health information. Cache expensive health checks. Essential for production deployments.

---

**Next:** Metrics →
