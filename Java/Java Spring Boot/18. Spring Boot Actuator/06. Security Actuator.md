# Security Actuator - Complete Guide

---

## 1. Introduction to Actuator Security

Securing actuator endpoints is critical as they expose sensitive application information and management capabilities.

### Why Secure Actuator?

- **Sensitive information** - Environment variables, configuration
- **Administrative operations** - Shutdown, thread dumps, heap dumps
- **Production data** - Metrics, logs, database info
- **Attack surface** - Exposed endpoints can be exploited
- **Compliance** - Security requirements for production systems

---

## 2. Spring Security Integration

### 2.1. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

### 2.2. Basic Security Configuration

```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class ActuatorSecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                // Public endpoints
                .requestMatchers(EndpointRequest.to("health", "info")).permitAll()
                
                // Admin-only endpoints
                .requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole("ADMIN")
                
                // Application endpoints
                .anyRequest().authenticated()
            )
            .httpBasic();
        
        return http.build();
    }
}
```

---

## 3. Endpoint-Specific Security

### 3.1. Different Roles for Different Endpoints

```java
@Configuration
public class DetailedActuatorSecurity {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                // Public endpoints
                .requestMatchers(EndpointRequest.to("health")).permitAll()
                .requestMatchers(EndpointRequest.to("info")).permitAll()
                
                // Read-only endpoints - VIEWER role
                .requestMatchers(EndpointRequest.to("metrics", "prometheus"))
                    .hasAnyRole("VIEWER", "ADMIN")
                
                // Dangerous endpoints - ADMIN only
                .requestMatchers(EndpointRequest.to("shutdown", "heapdump", "threaddump"))
                    .hasRole("ADMIN")
                
                // Other endpoints - OPERATOR role
                .requestMatchers(EndpointRequest.toAnyEndpoint())
                    .hasAnyRole("OPERATOR", "ADMIN")
                
                // Application endpoints
                .anyRequest().authenticated()
            )
            .httpBasic();
        
        return http.build();
    }
}
```

### 3.2. Method-Level Security

```java
import org.springframework.boot.actuate.endpoint.annotation.*;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Component;

@Component
@Endpoint(id = "custom-admin")
public class CustomAdminEndpoint {
    
    @ReadOperation
    @PreAuthorize("hasRole('ADMIN')")
    public Map<String, Object> getAdminData() {
        Map<String, Object> data = new HashMap<>();
        data.put("sensitiveInfo", "admin-only-data");
        return data;
    }
    
    @WriteOperation
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public String performCriticalOperation() {
        return "Critical operation performed";
    }
}
```

**Enable Method Security:**
```java
@Configuration
@EnableMethodSecurity
public class MethodSecurityConfig {
}
```

---

## 4. Health Endpoint Security

### 4.1. Conditional Health Details

```yaml
management:
  endpoint:
    health:
      show-details: when-authorized
      roles: ADMIN  # Only users with ADMIN role see details
```

**Unauthenticated Response:**
```json
{
  "status": "UP"
}
```

**Authenticated (ADMIN) Response:**
```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP",
      "details": {
        "database": "PostgreSQL",
        "validationQuery": "isValid()"
      }
    },
    "diskSpace": {
      "status": "UP",
      "details": {
        "total": 499963174912,
        "free": 336764821504
      }
    }
  }
}
```

### 4.2. Custom Health Authorization

```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

@Component
public class SecureHealthIndicator implements HealthIndicator {
    
    @Override
    public Health health() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        
        if (auth != null && auth.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"))) {
            // Show detailed health for admins
            return Health.up()
                    .withDetail("database", "PostgreSQL 14.5")
                    .withDetail("connections", 10)
                    .build();
        } else {
            // Show limited health for others
            return Health.up().build();
        }
    }
}
```

---

## 5. Separate Management Port

### 5.1. Configuration

```yaml
server:
  port: 8080  # Application port

management:
  server:
    port: 8081  # Management port (different from application)
    address: 127.0.0.1  # Only accessible from localhost
  
  endpoints:
    web:
      exposure:
        include: '*'
```

### 5.2. Firewall Rules

Only allow management port access from:
- Localhost
- Internal network
- VPN connections
- Monitoring systems

**Benefits:**
- Isolate management traffic
- Easier firewall configuration
- Separate SSL certificates
- Different authentication mechanisms

---

## 6. HTTPS Configuration

### 6.1. SSL for Management Endpoints

```yaml
management:
  server:
    port: 8081
    ssl:
      enabled: true
      key-store: classpath:management-keystore.p12
      key-store-password: changeit
      key-store-type: PKCS12
      key-alias: management
```

**Generate Keystore:**
```bash
keytool -genkeypair -alias management -keyalg RSA -keysize 2048 \
  -storetype PKCS12 -keystore management-keystore.p12 \
  -validity 3650 -storepass changeit
```

### 6.2. Mutual TLS (mTLS)

```yaml
management:
  server:
    ssl:
      enabled: true
      key-store: classpath:server.p12
      key-store-password: changeit
      trust-store: classpath:truststore.p12
      trust-store-password: changeit
      client-auth: need  # Require client certificate
```

---

## 7. CORS Configuration

### 7.1. Enabling CORS for Actuator

```yaml
management:
  endpoints:
    web:
      cors:
        allowed-origins: https://monitoring.example.com
        allowed-methods: GET,POST
        allowed-headers: "*"
        allow-credentials: true
        max-age: 3600
```

### 7.2. Programmatic CORS Configuration

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@Configuration
public class ActuatorCorsConfig {
    
    @Bean
    public CorsFilter actuatorCorsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("https://monitoring.example.com");
        config.addAllowedHeader("*");
        config.addAllowedMethod("GET");
        config.addAllowedMethod("POST");
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/actuator/**", config);
        
        return new CorsFilter(source);
    }
}
```

---

## 8. Authentication Methods

### 8.1. Basic Authentication

```yaml
spring:
  security:
    user:
      name: admin
      password: ${ADMIN_PASSWORD}
      roles: ADMIN
```

**Access:**
```bash
curl -u admin:password http://localhost:8080/actuator/metrics
```

### 8.2. JWT Token Authentication

```java
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class JwtActuatorSecurity {
    
    private final JwtAuthenticationFilter jwtFilter;
    
    public JwtActuatorSecurity(JwtAuthenticationFilter jwtFilter) {
        this.jwtFilter = jwtFilter;
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers(EndpointRequest.to("health", "info")).permitAll()
                .requestMatchers(EndpointRequest.toAnyEndpoint()).authenticated()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)
            .csrf().disable();
        
        return http.build();
    }
}
```

### 8.3. OAuth2 Authentication

```java
@Configuration
public class OAuth2ActuatorSecurity {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers(EndpointRequest.to("health")).permitAll()
                .requestMatchers(EndpointRequest.toAnyEndpoint())
                    .hasAuthority("SCOPE_actuator.read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        
        return http.build();
    }
}
```

---

## 9. IP Whitelisting

### 9.1. IP-Based Access Control

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Component
public class IpWhitelistFilter extends OncePerRequestFilter {
    
    private final List<String> allowedIps = Arrays.asList(
        "127.0.0.1",
        "192.168.1.0/24",
        "10.0.0.0/8"
    );
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        
        String requestPath = request.getRequestURI();
        
        if (requestPath.startsWith("/actuator")) {
            String remoteIp = request.getRemoteAddr();
            
            if (!isIpAllowed(remoteIp)) {
                response.sendError(HttpServletResponse.SC_FORBIDDEN, 
                    "Access denied from IP: " + remoteIp);
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private boolean isIpAllowed(String ip) {
        return allowedIps.contains(ip) || ip.equals("127.0.0.1");
    }
}
```

---

## 10. Audit Logging

### 10.1. Actuator Audit Events

```java
import org.springframework.boot.actuate.audit.AuditEvent;
import org.springframework.boot.actuate.audit.listener.AuditApplicationEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
@Slf4j
public class ActuatorAuditListener {
    
    @EventListener
    public void onAuditEvent(AuditApplicationEvent event) {
        AuditEvent auditEvent = event.getAuditEvent();
        
        log.info("Actuator Audit: principal={}, type={}, data={}",
            auditEvent.getPrincipal(),
            auditEvent.getType(),
            auditEvent.getData()
        );
    }
}
```

### 10.2. Custom Audit for Endpoint Access

```java
import org.springframework.boot.actuate.audit.AuditEventRepository;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class ActuatorAuditFilter extends OncePerRequestFilter {
    
    private final AuditEventRepository auditEventRepository;
    
    public ActuatorAuditFilter(AuditEventRepository auditEventRepository) {
        this.auditEventRepository = auditEventRepository;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        
        if (request.getRequestURI().startsWith("/actuator")) {
            String principal = SecurityContextHolder.getContext()
                    .getAuthentication().getName();
            
            Map<String, Object> data = new HashMap<>();
            data.put("endpoint", request.getRequestURI());
            data.put("method", request.getMethod());
            data.put("remoteIp", request.getRemoteAddr());
            
            AuditEvent auditEvent = new AuditEvent(
                principal,
                "ACTUATOR_ACCESS",
                data
            );
            
            auditEventRepository.add(auditEvent);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

---

## 11. Hiding Sensitive Information

### 11.1. Sanitizing Environment Properties

```java
import org.springframework.boot.actuate.endpoint.SanitizingFunction;
import org.springframework.boot.actuate.endpoint.Show;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SanitizationConfig {
    
    @Bean
    public SanitizingFunction sanitizingFunction() {
        return (data) -> {
            if (data.getKey().toLowerCase().contains("password") ||
                data.getKey().toLowerCase().contains("secret") ||
                data.getKey().toLowerCase().contains("key")) {
                return data.withValue("******");
            }
            return data;
        };
    }
}
```

**Configuration:**
```yaml
management:
  endpoint:
    env:
      show-values: when-authorized  # never, always, when-authorized
      additional-keys-to-sanitize: token,apikey,privatekey
```

### 11.2. Custom Property Sanitization

```java
import org.springframework.boot.actuate.autoconfigure.env.EnvironmentEndpointProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class CustomSanitizationConfig {
    
    @Bean
    public EnvironmentEndpointProperties environmentEndpointProperties() {
        EnvironmentEndpointProperties properties = new EnvironmentEndpointProperties();
        properties.setKeysToSanitize(
            "password", "secret", "key", "token", 
            ".*credentials.*", ".*api[_-]?key.*"
        );
        return properties;
    }
}
```

---

## 12. Production Security Checklist

### 12.1. Essential Security Measures

```yaml
# Production Configuration
management:
  endpoints:
    web:
      exposure:
        # Only expose necessary endpoints
        include: health,info,metrics,prometheus
        # Explicitly exclude dangerous endpoints
        exclude: shutdown,heapdump,threaddump
      
      # Use non-standard base path
      base-path: /management
  
  endpoint:
    health:
      show-details: when-authorized
      roles: ADMIN
    
    shutdown:
      enabled: false  # Disable shutdown endpoint
  
  server:
    # Separate management port
    port: 8081
    # Bind to localhost or internal network
    address: 127.0.0.1
    # Enable SSL
    ssl:
      enabled: true

spring:
  security:
    user:
      # Use strong passwords from environment
      password: ${ADMIN_PASSWORD}
      roles: ADMIN
```

### 12.2. Security Best Practices

✅ **Must Do:**
1. Enable Spring Security
2. Use HTTPS for management endpoints
3. Separate management port
4. Restrict network access (firewall)
5. Use strong authentication
6. Enable audit logging
7. Sanitize sensitive properties
8. Disable dangerous endpoints
9. Use role-based access control
10. Regular security audits

❌ **Never Do:**
1. Expose all endpoints in production
2. Use default passwords
3. Allow unauthenticated access
4. Expose management port publicly
5. Log sensitive information
6. Enable shutdown endpoint without security
7. Use HTTP in production
8. Allow unlimited CORS origins

---

## 13. Cloud Provider Integration

### 13.1. AWS IAM Authentication

```java
@Configuration
public class AwsActuatorSecurity {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers(EndpointRequest.to("health")).permitAll()
                .requestMatchers(EndpointRequest.toAnyEndpoint())
                    .hasIpAddress(getAWSNetworkRange())
                .anyRequest().authenticated()
            );
        
        return http.build();
    }
    
    private String getAWSNetworkRange() {
        // AWS VPC CIDR block
        return "10.0.0.0/16";
    }
}
```

### 13.2. Kubernetes RBAC Integration

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: actuator-reader
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: actuator-reader-role
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["services"]
  resourceNames: ["product-service"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: actuator-reader-binding
subjects:
- kind: ServiceAccount
  name: actuator-reader
roleRef:
  kind: Role
  name: actuator-reader-role
  apiGroup: rbac.authorization.k8s.io
```

---

## 14. Interview Questions

**Q1: Why secure actuator endpoints?**
**A:** They expose sensitive information (env vars, config, heap dumps) and management operations.

**Q2: How to secure actuator with Spring Security?**
**A:** Use EndpointRequest matcher in SecurityFilterChain configuration.

**Q3: What is show-details in health endpoint?**
**A:** Controls when to show health details: always, never, when-authorized.

**Q4: How to use separate port for actuator?**
**A:** Set management.server.port to different port from server.port.

**Q5: What endpoints should be public?**
**A:** Typically only health and info; all others should be authenticated.

**Q6: How to enable HTTPS for actuator?**
**A:** Configure management.server.ssl properties with keystore.

**Q7: What is CORS and why configure it?**
**A:** Cross-Origin Resource Sharing; allows monitoring UIs from different origins to access endpoints.

**Q8: How to sanitize sensitive properties?**
**A:** Use management.endpoint.env.additional-keys-to-sanitize or custom SanitizingFunction.

**Q9: Should shutdown endpoint be enabled?**
**A:** No, disable in production (management.endpoint.shutdown.enabled=false).

**Q10: What is IP whitelisting?**
**A:** Restricting actuator access to specific IP addresses or ranges.

**Q11: How to audit actuator access?**
**A:** Implement AuditApplicationEvent listener or custom filter with AuditEventRepository.

**Q12: What authentication methods supported?**
**A:** Basic, JWT, OAuth2, mutual TLS, custom.

**Q13: How to secure custom endpoints?**
**A:** Use @PreAuthorize or EndpointRequest.to("endpoint-id") in security config.

**Q14: What is management.server.address?**
**A:** Binds management port to specific IP (127.0.0.1 for localhost only).

**Q15: Should heapdump be publicly accessible?**
**A:** No, contains sensitive memory data; restrict to admins only.

**Q16: How to implement role-based access?**
**A:** Use hasRole() or hasAnyRole() in security configuration.

**Q17: What is when-authorized in show-details?**
**A:** Show health details only for authenticated users with specified roles.

**Q18: How to disable all endpoints except health?**
**A:** Set management.endpoints.web.exposure.include=health.

**Q19: What is mutual TLS for actuator?**
**A:** Requires both server and client certificates for authentication.

**Q20: Production security essentials?**
**A:** HTTPS, authentication, separate port, IP restrictions, disable dangerous endpoints, audit logging.

---

## 15. Summary

Secure actuator endpoints with Spring Security using EndpointRequest matchers. Public: health, info. Authenticated: metrics, prometheus. Admin-only: shutdown, heapdump, threaddump. Use separate management port bound to localhost or internal network. Enable HTTPS with SSL configuration. Configure CORS for monitoring UIs. Sanitize sensitive properties. Implement audit logging for access tracking. Use role-based access control (RBAC). IP whitelisting for additional security. Disable dangerous endpoints in production. Essential for protecting sensitive application information and management operations.

---

**Next:** Monitoring Integration →
