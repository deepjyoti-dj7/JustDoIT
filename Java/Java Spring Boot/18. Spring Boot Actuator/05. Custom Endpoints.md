# Custom Endpoints - Complete Guide

---

## 1. Introduction to Custom Endpoints

Custom actuator endpoints allow you to expose application-specific management and monitoring functionality.

### Why Custom Endpoints?

- **Application-specific operations** - Custom administrative tasks
- **Business metrics** - Expose domain-specific metrics
- **Diagnostics** - Custom troubleshooting tools
- **Configuration** - Runtime configuration management
- **Cache management** - Custom cache operations

---

## 2. Creating Custom Endpoints

### 2.1. Basic Custom Endpoint

```java
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Component
@Endpoint(id = "custom")
public class CustomEndpoint {
    
    @ReadOperation
    public Map<String, Object> customEndpoint() {
        Map<String, Object> details = new HashMap<>();
        details.put("message", "Custom endpoint data");
        details.put("timestamp", LocalDateTime.now().toString());
        details.put("status", "operational");
        
        return details;
    }
}
```

**Access:** `GET /actuator/custom`

**Response:**
```json
{
  "message": "Custom endpoint data",
  "timestamp": "2024-01-15T10:30:45",
  "status": "operational"
}
```

### 2.2. Endpoint with Parameters

```java
import org.springframework.boot.actuate.endpoint.annotation.*;
import org.springframework.stereotype.Component;

@Component
@Endpoint(id = "features")
public class FeatureEndpoint {
    
    private final Map<String, Boolean> features = new HashMap<>();
    
    public FeatureEndpoint() {
        features.put("newUI", true);
        features.put("betaFeatures", false);
        features.put("experimentalCheckout", true);
    }
    
    @ReadOperation
    public Map<String, Boolean> getAllFeatures() {
        return features;
    }
    
    @ReadOperation
    public Boolean getFeature(@Selector String featureName) {
        return features.getOrDefault(featureName, false);
    }
    
    @WriteOperation
    public void setFeature(@Selector String featureName, Boolean enabled) {
        features.put(featureName, enabled);
    }
    
    @DeleteOperation
    public void deleteFeature(@Selector String featureName) {
        features.remove(featureName);
    }
}
```

**Operations:**
```bash
# Get all features
GET /actuator/features

# Get specific feature
GET /actuator/features/newUI

# Enable feature
POST /actuator/features/newUI
Body: {"enabled": true}

# Delete feature
DELETE /actuator/features/newUI
```

---

## 3. Operation Types

### 3.1. @ReadOperation

```java
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
import org.springframework.stereotype.Component;

@Component
@Endpoint(id = "cache-stats")
public class CacheStatsEndpoint {
    
    private final CacheManager cacheManager;
    
    public CacheStatsEndpoint(CacheManager cacheManager) {
        this.cacheManager = cacheManager;
    }
    
    @ReadOperation
    public Map<String, Object> getCacheStats() {
        Map<String, Object> stats = new HashMap<>();
        
        for (String cacheName : cacheManager.getCacheNames()) {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                CacheStats cacheStats = nativeCache.stats();
                Map<String, Object> metrics = new HashMap<>();
                metrics.put("hitCount", cacheStats.hitCount());
                metrics.put("missCount", cacheStats.missCount());
                metrics.put("hitRate", cacheStats.hitRate());
                metrics.put("evictionCount", cacheStats.evictionCount());
                
                stats.put(cacheName, metrics);
            }
        }
        
        return stats;
    }
}
```

### 3.2. @WriteOperation

```java
@Component
@Endpoint(id = "cache-management")
public class CacheManagementEndpoint {
    
    private final CacheManager cacheManager;
    
    public CacheManagementEndpoint(CacheManager cacheManager) {
        this.cacheManager = cacheManager;
    }
    
    @WriteOperation
    public String clearCache(@Selector String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
            return "Cache '" + cacheName + "' cleared successfully";
        }
        return "Cache '" + cacheName + "' not found";
    }
    
    @WriteOperation
    public String clearAllCaches() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                cache.clear();
            }
        });
        return "All caches cleared successfully";
    }
}
```

**Usage:**
```bash
POST /actuator/cache-management/products
POST /actuator/cache-management
```

### 3.3. @DeleteOperation

```java
@Component
@Endpoint(id = "sessions")
public class SessionManagementEndpoint {
    
    private final Map<String, Session> sessions = new ConcurrentHashMap<>();
    
    @ReadOperation
    public Collection<Session> getAllSessions() {
        return sessions.values();
    }
    
    @DeleteOperation
    public String terminateSession(@Selector String sessionId) {
        Session removed = sessions.remove(sessionId);
        if (removed != null) {
            return "Session " + sessionId + " terminated";
        }
        return "Session " + sessionId + " not found";
    }
}
```

---

## 4. Advanced Custom Endpoints

### 4.1. Thread Dump Endpoint

```java
import org.springframework.boot.actuate.endpoint.annotation.Endpoint;
import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;
import org.springframework.stereotype.Component;

import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
@Endpoint(id = "custom-threads")
public class ThreadAnalysisEndpoint {
    
    @ReadOperation
    public Map<String, Object> getThreadAnalysis() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        
        Map<String, Object> analysis = new HashMap<>();
        analysis.put("totalThreads", threadBean.getThreadCount());
        analysis.put("peakThreads", threadBean.getPeakThreadCount());
        analysis.put("daemonThreads", threadBean.getDaemonThreadCount());
        
        // Find deadlocked threads
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        analysis.put("deadlockedThreads", deadlockedThreads != null ? deadlockedThreads.length : 0);
        
        // Thread states
        ThreadInfo[] threadInfos = threadBean.dumpAllThreads(false, false);
        Map<String, Integer> threadStates = new HashMap<>();
        for (ThreadInfo info : threadInfos) {
            String state = info.getThreadState().toString();
            threadStates.merge(state, 1, Integer::sum);
        }
        analysis.put("threadStates", threadStates);
        
        return analysis;
    }
}
```

### 4.2. Database Connection Pool Endpoint

```java
import com.zaxxer.hikari.HikariDataSource;
import com.zaxxer.hikari.HikariPoolMXBean;
import org.springframework.boot.actuate.endpoint.annotation.*;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Component
@Endpoint(id = "connection-pool")
public class ConnectionPoolEndpoint {
    
    private final HikariDataSource dataSource;
    
    public ConnectionPoolEndpoint(HikariDataSource dataSource) {
        this.dataSource = dataSource;
    }
    
    @ReadOperation
    public Map<String, Object> getPoolStats() {
        HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
        
        Map<String, Object> stats = new HashMap<>();
        stats.put("active", poolBean.getActiveConnections());
        stats.put("idle", poolBean.getIdleConnections());
        stats.put("total", poolBean.getTotalConnections());
        stats.put("threadsAwaitingConnection", poolBean.getThreadsAwaitingConnection());
        stats.put("maxPoolSize", dataSource.getMaximumPoolSize());
        stats.put("minIdle", dataSource.getMinimumIdle());
        
        return stats;
    }
    
    @WriteOperation
    public String softEvictConnections() {
        dataSource.getHikariPoolMXBean().softEvictConnections();
        return "Connections soft evicted";
    }
}
```

### 4.3. System Information Endpoint

```java
@Component
@Endpoint(id = "system-info")
public class SystemInfoEndpoint {
    
    @ReadOperation
    public Map<String, Object> getSystemInfo() {
        Map<String, Object> info = new HashMap<>();
        
        // Runtime info
        Runtime runtime = Runtime.getRuntime();
        Map<String, Object> runtimeInfo = new HashMap<>();
        runtimeInfo.put("availableProcessors", runtime.availableProcessors());
        runtimeInfo.put("freeMemory", runtime.freeMemory());
        runtimeInfo.put("totalMemory", runtime.totalMemory());
        runtimeInfo.put("maxMemory", runtime.maxMemory());
        info.put("runtime", runtimeInfo);
        
        // OS info
        Map<String, String> osInfo = new HashMap<>();
        osInfo.put("name", System.getProperty("os.name"));
        osInfo.put("version", System.getProperty("os.version"));
        osInfo.put("arch", System.getProperty("os.arch"));
        info.put("os", osInfo);
        
        // Disk info
        File root = new File("/");
        Map<String, Object> diskInfo = new HashMap<>();
        diskInfo.put("totalSpace", root.getTotalSpace());
        diskInfo.put("freeSpace", root.getFreeSpace());
        diskInfo.put("usableSpace", root.getUsableSpace());
        info.put("disk", diskInfo);
        
        return info;
    }
}
```

---

## 5. Web vs JMX Endpoints

### 5.1. Web-Only Endpoint

```java
import org.springframework.boot.actuate.endpoint.web.annotation.RestControllerEndpoint;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.*;

@Component
@RestControllerEndpoint(id = "custom-rest")
public class CustomRestEndpoint {
    
    @GetMapping("/status")
    public ResponseEntity<Map<String, String>> getStatus() {
        Map<String, String> status = new HashMap<>();
        status.put("status", "healthy");
        status.put("version", "1.0.0");
        return ResponseEntity.ok(status);
    }
    
    @PostMapping("/action")
    public ResponseEntity<String> performAction(@RequestBody ActionRequest request) {
        // Perform custom action
        return ResponseEntity.ok("Action performed: " + request.getAction());
    }
}
```

### 5.2. JMX Endpoint

```java
import org.springframework.boot.actuate.endpoint.jmx.annotation.JmxEndpoint;
import org.springframework.stereotype.Component;

@Component
@JmxEndpoint(id = "custom-jmx")
public class CustomJmxEndpoint {
    
    @ReadOperation
    public String getJmxData() {
        return "JMX endpoint data";
    }
}
```

---

## 6. Endpoint Security

### 6.1. Securing Custom Endpoints

```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class CustomEndpointSecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(EndpointRequest.to("custom")).hasRole("ADMIN")
                .requestMatchers(EndpointRequest.to("features")).hasRole("ADMIN")
                .requestMatchers(EndpointRequest.to("cache-management")).hasRole("ADMIN")
                .anyRequest().authenticated()
            );
        
        return http.build();
    }
}
```

### 6.2. Role-Based Endpoint Access

```java
@Component
@Endpoint(id = "admin-operations")
public class AdminOperationsEndpoint {
    
    @ReadOperation
    public Map<String, Object> getAdminData() {
        // Only accessible to ADMIN role
        Map<String, Object> data = new HashMap<>();
        data.put("sensitiveData", "confidential");
        return data;
    }
}
```

**Security Configuration:**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: admin-operations
  endpoint:
    admin-operations:
      enabled: true
```

---

## 7. Endpoint Configuration

### 7.1. Enabling/Disabling Endpoints

```yaml
management:
  endpoints:
    web:
      exposure:
        include: custom,features,cache-stats
        exclude: cache-management  # Disable specific endpoint
  
  endpoint:
    custom:
      enabled: true
    features:
      enabled: false  # Disable endpoint completely
```

### 7.2. Endpoint Base Path

```yaml
management:
  endpoints:
    web:
      base-path: /management
      path-mapping:
        custom: custom-path  # Custom path for endpoint
```

**Access:** `GET /management/custom-path`

---

## 8. Real-World Examples

### 8.1. Application Restart Endpoint

```java
@Component
@Endpoint(id = "restart")
public class RestartEndpoint {
    
    private final ConfigurableApplicationContext context;
    
    public RestartEndpoint(ConfigurableApplicationContext context) {
        this.context = context;
    }
    
    @WriteOperation
    public String restart() {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(1000);
                context.close();
                SpringApplication.run(Application.class);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        thread.setDaemon(false);
        thread.start();
        
        return "Application restart initiated";
    }
}
```

### 8.2. Configuration Refresh Endpoint

```java
@Component
@Endpoint(id = "refresh-config")
public class ConfigRefreshEndpoint {
    
    private final ConfigurableEnvironment environment;
    
    public ConfigRefreshEndpoint(ConfigurableEnvironment environment) {
        this.environment = environment;
    }
    
    @WriteOperation
    public String refreshConfiguration() {
        // Refresh external configuration
        // This is a simplified example
        return "Configuration refreshed from external source";
    }
    
    @ReadOperation
    public Map<String, String> getCurrentConfig() {
        Map<String, String> config = new HashMap<>();
        config.put("profile", String.join(",", environment.getActiveProfiles()));
        // Add other config properties
        return config;
    }
}
```

### 8.3. Metrics Summary Endpoint

```java
@Component
@Endpoint(id = "metrics-summary")
public class MetricsSummaryEndpoint {
    
    private final MeterRegistry meterRegistry;
    
    public MetricsSummaryEndpoint(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @ReadOperation
    public Map<String, Object> getMetricsSummary() {
        Map<String, Object> summary = new HashMap<>();
        
        // JVM Memory
        Meter jvmMemory = meterRegistry.find("jvm.memory.used").tag("area", "heap").meter();
        if (jvmMemory != null) {
            summary.put("heapMemoryUsed", 
                jvmMemory.measure().iterator().next().getValue());
        }
        
        // HTTP Requests
        Counter requests = meterRegistry.find("http.server.requests").counter();
        if (requests != null) {
            summary.put("totalRequests", requests.count());
        }
        
        // Add more metrics
        return summary;
    }
}
```

---

## 9. Best Practices

### 9.1. Endpoint Design

✅ **Good:**
- Use clear, descriptive endpoint IDs
- Follow REST conventions for operations
- Return structured, consistent data
- Provide meaningful error messages
- Document endpoint purpose and usage

❌ **Avoid:**
- Using generic IDs like "custom1", "test"
- Exposing sensitive data without security
- Performing expensive operations in @ReadOperation
- Creating endpoints for simple queries

### 9.2. Security Best Practices

```java
@Component
@Endpoint(id = "secure-operation")
public class SecureOperationEndpoint {
    
    @ReadOperation
    public Map<String, Object> getData() {
        // Never expose sensitive data
        Map<String, Object> data = new HashMap<>();
        data.put("publicInfo", "safe data");
        // data.put("password", "secret");  // ❌ Never do this
        return data;
    }
    
    @WriteOperation
    public String performOperation(String param) {
        // Validate input
        if (param == null || param.isEmpty()) {
            throw new IllegalArgumentException("Invalid parameter");
        }
        
        // Log operation
        log.info("Operation performed with param: {}", param);
        
        return "Success";
    }
}
```

---

## 10. Interview Questions

**Q1: What is a custom actuator endpoint?**
**A:** Application-specific management endpoint created using @Endpoint annotation.

**Q2: What annotation creates custom endpoint?**
**A:** @Endpoint(id = "endpoint-name")

**Q3: What are the operation types?**
**A:** @ReadOperation (GET), @WriteOperation (POST), @DeleteOperation (DELETE).

**Q4: What is @Selector used for?**
**A:** Path variable in endpoint URLs (e.g., /actuator/features/{name}).

**Q5: How to secure custom endpoint?**
**A:** Use Spring Security with EndpointRequest.to("endpoint-name").

**Q6: What is @RestControllerEndpoint?**
**A:** Creates web-only endpoint with full Spring MVC support.

**Q7: Can endpoint be both web and JMX?**
**A:** Yes, @Endpoint exposes both. Use @WebEndpoint or @JmxEndpoint for specific.

**Q8: How to disable custom endpoint?**
**A:** Set management.endpoint.{id}.enabled=false.

**Q9: What's difference between @Endpoint and @RestControllerEndpoint?**
**A:** @Endpoint: Technology-agnostic (web + JMX). @RestControllerEndpoint: Web-only with MVC features.

**Q10: How to add parameters to endpoint?**
**A:** Use @Selector for path variables or method parameters for request body.

**Q11: Can @WriteOperation return values?**
**A:** Yes, can return String, Map, or custom objects.

**Q12: How to access custom endpoint?**
**A:** GET /actuator/{endpoint-id}

**Q13: What's the purpose of custom endpoints?**
**A:** Application-specific management, diagnostics, cache clearing, feature toggles.

**Q14: How to create read-only endpoint?**
**A:** Use only @ReadOperation methods, no @WriteOperation or @DeleteOperation.

**Q15: Can endpoint have multiple operations?**
**A:** Yes, multiple @ReadOperation, @WriteOperation, @DeleteOperation methods.

**Q16: How to version custom endpoints?**
**A:** Use path mapping or include version in response data.

**Q17: Should endpoints perform expensive operations?**
**A:** No, keep @ReadOperation fast. Use @WriteOperation for expensive tasks.

**Q18: How to document custom endpoints?**
**A:** Use JavaDoc, OpenAPI/Swagger, or provide /actuator/info documentation.

**Q19: Can custom endpoint modify application state?**
**A:** Yes, @WriteOperation can clear caches, toggle features, etc.

**Q20: How to test custom endpoints?**
**A:** Use @WebMvcTest or integration tests with TestRestTemplate.

---

## 11. Summary

Custom endpoints extend Actuator with application-specific management functionality. Create with @Endpoint annotation. Operations: @ReadOperation (GET), @WriteOperation (POST), @DeleteOperation (DELETE). Use @Selector for path variables. Common use cases: cache management, feature toggles, system info, thread analysis. Secure with Spring Security and EndpointRequest. @RestControllerEndpoint for web-only with full MVC support. Keep @ReadOperation fast. Validate inputs in @WriteOperation. Enable/disable via configuration. Essential for custom administrative operations and diagnostics.

---

**Next:** Security Actuator →
