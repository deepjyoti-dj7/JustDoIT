# Metrics - Complete Guide

---

## 1. Introduction to Actuator Metrics

Spring Boot Actuator provides comprehensive metrics collection for monitoring application performance and behavior.

### Why Metrics?

- **Performance monitoring** - Track response times, throughput
- **Resource usage** - Monitor CPU, memory, threads
- **Business metrics** - Track orders, revenue, user activity
- **Capacity planning** - Predict when to scale
- **Debugging** - Identify performance bottlenecks
- **Alerting** - Trigger notifications on thresholds

### Metrics Categories

- **JVM Metrics** - Memory, GC, threads, class loading
- **System Metrics** - CPU usage, file descriptors, uptime
- **HTTP Metrics** - Request count, latency, status codes
- **Database Metrics** - Connection pool, query performance
- **Cache Metrics** - Hit ratio, evictions, size
- **Custom Metrics** - Application-specific measurements

---

## 2. Accessing Metrics

### 2.1. List All Available Metrics

**URL:** `GET /actuator/metrics`

**Response:**
```json
{
  "names": [
    "jvm.memory.used",
    "jvm.memory.max",
    "jvm.gc.memory.allocated",
    "jvm.gc.pause",
    "jvm.threads.live",
    "http.server.requests",
    "system.cpu.usage",
    "process.uptime",
    "hikaricp.connections.active",
    "cache.gets"
  ]
}
```

### 2.2. Get Specific Metric

**URL:** `GET /actuator/metrics/jvm.memory.used`

**Response:**
```json
{
  "name": "jvm.memory.used",
  "description": "The amount of used memory",
  "baseUnit": "bytes",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 157286400
    }
  ],
  "availableTags": [
    {
      "tag": "area",
      "values": ["heap", "nonheap"]
    },
    {
      "tag": "id",
      "values": ["PS Eden Space", "PS Old Gen", "PS Survivor Space"]
    }
  ]
}
```

### 2.3. Filter by Tags

**URL:** `GET /actuator/metrics/jvm.memory.used?tag=area:heap`

**Response:**
```json
{
  "name": "jvm.memory.used",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 125829120
    }
  ],
  "availableTags": [
    {
      "tag": "id",
      "values": ["PS Eden Space", "PS Old Gen", "PS Survivor Space"]
    }
  ]
}
```

---

## 3. JVM Metrics

### 3.1. Memory Metrics

**Heap Memory:**
```
jvm.memory.used{area="heap"}           # Used heap memory
jvm.memory.max{area="heap"}            # Maximum heap memory
jvm.memory.committed{area="heap"}      # Committed heap memory
```

**Non-Heap Memory:**
```
jvm.memory.used{area="nonheap"}        # Used non-heap memory (metaspace, etc.)
jvm.memory.max{area="nonheap"}
jvm.memory.committed{area="nonheap"}
```

**Example Response:**
```bash
GET /actuator/metrics/jvm.memory.used?tag=area:heap&tag=id:PS%20Eden%20Space
```

```json
{
  "name": "jvm.memory.used",
  "baseUnit": "bytes",
  "measurements": [
    {
      "statistic": "VALUE",
      "value": 52428800
    }
  ]
}
```

### 3.2. Garbage Collection Metrics

```
jvm.gc.pause                           # GC pause time
jvm.gc.memory.allocated                # Memory allocated
jvm.gc.memory.promoted                 # Memory promoted to old generation
jvm.gc.live.data.size                  # Size of old generation after full GC
jvm.gc.max.data.size                   # Max size of old generation
```

**Configuration:**
```yaml
management:
  metrics:
    enable:
      jvm: true
```

### 3.3. Thread Metrics

```
jvm.threads.live                       # Current live threads
jvm.threads.daemon                     # Current daemon threads
jvm.threads.peak                       # Peak thread count
jvm.threads.states                     # Thread states (runnable, blocked, etc.)
```

### 3.4. Class Loading Metrics

```
jvm.classes.loaded                     # Currently loaded classes
jvm.classes.unloaded                   # Total unloaded classes
```

---

## 4. System Metrics

### 4.1. CPU Metrics

```
system.cpu.usage                       # System CPU usage (0-1)
system.cpu.count                       # Number of processors
process.cpu.usage                      # Process CPU usage (0-1)
```

### 4.2. Uptime Metrics

```
process.uptime                         # Application uptime in seconds
process.start.time                     # Application start time
```

### 4.3. File Descriptor Metrics

```
process.files.open                     # Open file descriptors
process.files.max                      # Maximum file descriptors
```

---

## 5. HTTP Metrics

### 5.1. Request Metrics

```
http.server.requests                   # Request count and timing
```

**Available Tags:**
- `uri` - Request URI pattern
- `method` - HTTP method (GET, POST, etc.)
- `status` - HTTP status code
- `exception` - Exception class (if error)
- `outcome` - SUCCESS, CLIENT_ERROR, SERVER_ERROR

**Example:**
```bash
GET /actuator/metrics/http.server.requests?tag=uri:/api/products/{id}&tag=method:GET&tag=status:200
```

**Response:**
```json
{
  "name": "http.server.requests",
  "measurements": [
    {
      "statistic": "COUNT",
      "value": 1523
    },
    {
      "statistic": "TOTAL_TIME",
      "value": 45.678
    },
    {
      "statistic": "MAX",
      "value": 0.234
    }
  ]
}
```

### 5.2. Customizing HTTP Metrics

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import org.springframework.boot.actuate.metrics.web.servlet.WebMvcTagsContributor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Arrays;

@Configuration
public class MetricsConfig {
    
    @Bean
    public WebMvcTagsContributor customTagsContributor() {
        return new WebMvcTagsContributor() {
            @Override
            public Iterable<Tag> getTags(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler,
                                         Throwable exception) {
                return Arrays.asList(
                    Tag.of("custom.tag", "value"),
                    Tag.of("region", request.getHeader("X-Region"))
                );
            }
            
            @Override
            public Iterable<Tag> getLongRequestTags(HttpServletRequest request,
                                                    Object handler) {
                return Arrays.asList(
                    Tag.of("custom.tag", "value")
                );
            }
        };
    }
}
```

---

## 6. Database Metrics

### 6.1. HikariCP Connection Pool

```
hikaricp.connections.active            # Active connections
hikaricp.connections.idle              # Idle connections
hikaricp.connections.pending           # Pending connections
hikaricp.connections.max               # Maximum pool size
hikaricp.connections.min               # Minimum pool size
hikaricp.connections.usage             # Connection usage time
hikaricp.connections.acquire           # Time to acquire connection
hikaricp.connections.creation          # Time to create connection
hikaricp.connections.timeout           # Connection timeout count
```

**Configuration:**
```yaml
spring:
  datasource:
    hikari:
      pool-name: ProductServicePool
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      metrics-enabled: true
```

### 6.2. JDBC Metrics

```java
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DataSourceConfig {
    
    @Bean
    public DataSource dataSource(DataSourceProperties properties,
                                MeterRegistry registry) {
        DataSource dataSource = DataSourceBuilder
                .create()
                .url(properties.getUrl())
                .username(properties.getUsername())
                .password(properties.getPassword())
                .build();
        
        // Automatically registers HikariCP metrics
        return dataSource;
    }
}
```

---

## 7. Cache Metrics

### 7.1. Cache Statistics

```
cache.gets{name="products",result="hit"}      # Cache hits
cache.gets{name="products",result="miss"}     # Cache misses
cache.puts{name="products"}                   # Cache puts
cache.evictions{name="products"}              # Cache evictions
cache.size{name="products"}                   # Cache size
```

### 7.2. Caffeine Cache Configuration

```java
import com.github.benmanes.caffeine.cache.Caffeine;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.binder.cache.CaffeineCacheMetrics;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(MeterRegistry registry) {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .recordStats());
        
        // Register cache metrics
        cacheManager.getCacheNames().forEach(cacheName -> {
            var cache = cacheManager.getCache(cacheName);
            if (cache != null) {
                CaffeineCacheMetrics.monitor(
                    registry,
                    cache.getNativeCache(),
                    cacheName
                );
            }
        });
        
        return cacheManager;
    }
}
```

---

## 8. Custom Metrics

### 8.1. Counter

```java
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Service;

@Service
public class OrderService {
    
    private final Counter orderCounter;
    
    public OrderService(MeterRegistry registry) {
        this.orderCounter = Counter.builder("orders.created")
                .description("Total orders created")
                .tag("type", "online")
                .register(registry);
    }
    
    public Order createOrder(OrderRequest request) {
        Order order = processOrder(request);
        orderCounter.increment();
        return order;
    }
}
```

**Access:**
```bash
GET /actuator/metrics/orders.created
```

### 8.2. Gauge

```java
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.concurrent.atomic.AtomicInteger;

@Component
public class ActiveUsersMetrics {
    
    private final MeterRegistry registry;
    private final AtomicInteger activeUsers = new AtomicInteger(0);
    
    public ActiveUsersMetrics(MeterRegistry registry) {
        this.registry = registry;
    }
    
    @PostConstruct
    public void init() {
        Gauge.builder("users.active", activeUsers, AtomicInteger::get)
                .description("Currently active users")
                .register(registry);
    }
    
    public void userLogin() {
        activeUsers.incrementAndGet();
    }
    
    public void userLogout() {
        activeUsers.decrementAndGet();
    }
}
```

### 8.3. Timer

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.stereotype.Service;

@Service
public class PaymentService {
    
    private final MeterRegistry registry;
    
    public PaymentService(MeterRegistry registry) {
        this.registry = registry;
    }
    
    public Payment processPayment(PaymentRequest request) {
        return Timer.builder("payment.processing.time")
                .description("Payment processing time")
                .tag("provider", request.getProvider())
                .register(registry)
                .record(() -> {
                    // Process payment
                    return chargeCard(request);
                });
    }
}
```

### 8.4. Distribution Summary

```java
import io.micrometer.core.instrument.DistributionSummary;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Service;

@Service
public class OrderMetrics {
    
    private final DistributionSummary orderValueSummary;
    
    public OrderMetrics(MeterRegistry registry) {
        this.orderValueSummary = DistributionSummary.builder("order.value")
                .description("Order value distribution")
                .baseUnit("dollars")
                .serviceLevelObjectives(10, 50, 100, 500, 1000)
                .register(registry);
    }
    
    public void recordOrderValue(double value) {
        orderValueSummary.record(value);
    }
}
```

---

## 9. @Timed and @Counted Annotations

### 9.1. @Timed Annotation

```java
import io.micrometer.core.annotation.Timed;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping("/{id}")
    @Timed(value = "product.get", 
           description = "Time to get product by ID",
           percentiles = {0.5, 0.95, 0.99})
    public Product getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
    
    @PostMapping
    @Timed(value = "product.create",
           extraTags = {"operation", "create"})
    public Product createProduct(@RequestBody ProductRequest request) {
        return productService.create(request);
    }
}
```

**Enable @Timed:**
```java
import io.micrometer.core.aop.TimedAspect;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MetricsAopConfig {
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}
```

### 9.2. @Counted Annotation

```java
import io.micrometer.core.annotation.Counted;
import org.springframework.stereotype.Service;

@Service
public class NotificationService {
    
    @Counted(value = "notifications.sent",
             description = "Total notifications sent",
             extraTags = {"type", "email"})
    public void sendEmail(String to, String subject, String body) {
        // Send email
    }
    
    @Counted(value = "notifications.sent",
             extraTags = {"type", "sms"})
    public void sendSMS(String phone, String message) {
        // Send SMS
    }
}
```

**Enable @Counted:**
```java
import io.micrometer.core.aop.CountedAspect;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MetricsAopConfig {
    
    @Bean
    public CountedAspect countedAspect(MeterRegistry registry) {
        return new CountedAspect(registry);
    }
}
```

---

## 10. Per-Endpoint Metrics

### 10.1. Enabling Per-Endpoint Metrics

```yaml
management:
  metrics:
    web:
      server:
        request:
          autotime:
            enabled: true
            percentiles: 0.5,0.95,0.99
            percentiles-histogram: true
```

### 10.2. Customizing Endpoint Metrics

```java
import io.micrometer.core.instrument.config.MeterFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MetricsFilterConfig {
    
    @Bean
    public MeterFilter renameHttpMetrics() {
        return MeterFilter.renameTag("http.server.requests", "uri", "endpoint");
    }
    
    @Bean
    public MeterFilter ignoreHealthEndpoint() {
        return MeterFilter.deny(id -> 
            id.getName().equals("http.server.requests") &&
            id.getTag("uri").startsWith("/actuator/health")
        );
    }
}
```

---

## 11. Common Tags

### 11.1. Global Tags

```yaml
management:
  metrics:
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:dev}
      region: ${REGION:us-east-1}
```

### 11.2. Programmatic Tags

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tag;
import org.springframework.boot.actuate.autoconfigure.metrics.MeterRegistryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Arrays;

@Configuration
public class MetricsTagsConfig {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags(
            Tag.of("application", "product-service"),
            Tag.of("environment", "production"),
            Tag.of("version", "1.0.0")
        );
    }
}
```

---

## 12. Metric Filters

### 12.1. Deny Specific Metrics

```java
import io.micrometer.core.instrument.config.MeterFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MetricsFilterConfig {
    
    @Bean
    public MeterFilter denyJvmBufferMetrics() {
        return MeterFilter.deny(id -> id.getName().startsWith("jvm.buffer"));
    }
}
```

### 12.2. Maximum Metrics

```java
@Bean
public MeterFilter maximumAllowedMetrics() {
    return MeterFilter.maximumAllowableMetrics(1000);
}
```

### 12.3. Accept Only Specific Metrics

```java
@Bean
public MeterFilter acceptOnlyImportantMetrics() {
    return MeterFilter.accept(id -> {
        String name = id.getName();
        return name.startsWith("http.") ||
               name.startsWith("jvm.memory") ||
               name.startsWith("system.cpu");
    });
}
```

---

## 13. Exporting Metrics

### 13.1. Prometheus Format

**Configuration:**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

**Access:**
```bash
GET /actuator/prometheus
```

**Response:**
```
# HELP jvm_memory_used_bytes The amount of used memory
# TYPE jvm_memory_used_bytes gauge
jvm_memory_used_bytes{area="heap",id="PS Eden Space",} 5.2428800E7

# HELP http_server_requests_seconds  
# TYPE http_server_requests_seconds summary
http_server_requests_seconds_count{exception="None",method="GET",status="200",uri="/api/products/{id}",} 1523.0
http_server_requests_seconds_sum{exception="None",method="GET",status="200",uri="/api/products/{id}",} 45.678
```

---

## 14. Best Practices

### 14.1. Naming Conventions

✅ **Good:**
```
orders.created
payment.processing.time
cache.hit.ratio
```

❌ **Bad:**
```
OrdersCreated
payment_processing_time
cacheHitRatio
```

### 14.2. Tag Cardinality

✅ **Low Cardinality (Good):**
```java
registry.counter("api.requests",
    "endpoint", "/api/products",  // ~10-100 values
    "status", "200"               // ~10 values
);
```

❌ **High Cardinality (Bad):**
```java
registry.counter("api.requests",
    "user_id", userId,            // Millions of values!
    "request_id", requestId       // Unique per request!
);
```

### 14.3. Performance Considerations

- Limit number of metrics (< 1000)
- Control tag cardinality
- Use metric filters to exclude unnecessary metrics
- Cache metric instances
- Use timers for method-level timing

---

## 15. Interview Questions

**Q1: How to access all available metrics?**
**A:** GET /actuator/metrics

**Q2: Name 3 JVM metrics.**
**A:** jvm.memory.used, jvm.gc.pause, jvm.threads.live

**Q3: What is http.server.requests metric?**
**A:** Tracks HTTP request count, duration, and status codes.

**Q4: How to get metric with specific tags?**
**A:** /actuator/metrics/{name}?tag=key:value

**Q5: What is a Counter metric?**
**A:** Monotonically increasing value (orders created, requests received).

**Q6: What is a Gauge metric?**
**A:** Current value that can go up or down (memory usage, active users).

**Q7: What is a Timer metric?**
**A:** Tracks duration and count of events.

**Q8: What is Distribution Summary?**
**A:** Records distribution of values (request sizes, order values).

**Q9: How to create custom metric?**
**A:** Inject MeterRegistry and use Counter.builder(), Gauge.builder(), etc.

**Q10: What is @Timed annotation?**
**A:** Automatically times method execution, requires TimedAspect bean.

**Q11: What are common tags?**
**A:** Global tags applied to all metrics (application, environment, region).

**Q12: What is tag cardinality?**
**A:** Number of unique tag combinations; high cardinality causes performance issues.

**Q13: How to export metrics to Prometheus?**
**A:** Add micrometer-registry-prometheus, expose /actuator/prometheus endpoint.

**Q14: What HikariCP metrics available?**
**A:** Active connections, idle connections, pending connections, usage time.

**Q15: How to enable cache metrics?**
**A:** Use cache with recordStats() and register with CaffeineCacheMetrics.monitor().

**Q16: What is MeterFilter?**
**A:** Interface for filtering, renaming, or transforming metrics.

**Q17: How to disable specific metric?**
**A:** Use MeterFilter.deny() for specific metric names.

**Q18: What is percentile in metrics?**
**A:** Statistical value showing distribution (p50, p95, p99).

**Q19: How to add custom tags to HTTP metrics?**
**A:** Implement WebMvcTagsContributor for custom tag extraction.

**Q20: What metrics for monitoring?**
**A:** JVM memory, GC pauses, HTTP request latency, error rate, CPU usage, connection pool.

---

## 16. Summary

Actuator provides comprehensive metrics via /actuator/metrics endpoint. Categories: JVM (memory, GC, threads), System (CPU, uptime), HTTP (requests, latency), Database (connection pool), Cache (hit ratio). Create custom metrics with MeterRegistry using Counter, Gauge, Timer, DistributionSummary. Use @Timed and @Counted annotations for automatic instrumentation. Apply common tags globally. Control cardinality to avoid performance issues. Export to Prometheus via /actuator/prometheus. Filter unwanted metrics with MeterFilter. Essential for production monitoring and performance analysis.

---

**Next:** Info Endpoint →
