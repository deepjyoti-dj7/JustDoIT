# APM Tools - Complete Guide

---

## 1. Introduction to APM (Application Performance Monitoring)

APM tools provide end-to-end visibility into application performance, user experience, and infrastructure health.

### What is APM?

Application Performance Monitoring is the practice of monitoring software applications to detect and diagnose performance issues, ensure availability, and optimize user experience.

### Why APM?

- **Performance monitoring** - Track response times, throughput
- **Error tracking** - Capture and analyze exceptions
- **Distributed tracing** - Follow requests across microservices
- **Real user monitoring** - Measure actual user experience
- **Root cause analysis** - Quickly identify performance bottlenecks
- **Alerting** - Proactive issue detection

### Key Features

- Transaction tracing
- Error tracking and analysis
- Infrastructure monitoring
- Custom dashboards
- Alerting and notifications
- Distributed tracing
- Database query analysis
- External service monitoring

---

## 2. Popular APM Tools

### Comparison Table

| Feature | New Relic | Datadog | Dynatrace | AppDynamics | Elastic APM |
|---------|-----------|---------|-----------|-------------|-------------|
| **Type** | SaaS | SaaS | SaaS/On-prem | SaaS/On-prem | Open Source |
| **Pricing** | Per host | Per host | Per host | Per app | Free/Enterprise |
| **Auto-instrumentation** | Yes | Yes | Yes | Yes | Limited |
| **Distributed Tracing** | Yes | Yes | Yes | Yes | Yes |
| **AI/ML Anomaly Detection** | Yes | Yes | Yes (AI) | Yes | Limited |
| **Learning Curve** | Medium | Medium | Low | Medium | High |
| **Best For** | Startups/Mid-size | DevOps teams | Enterprise | Enterprise | Cost-conscious |

---

## 3. New Relic

### 3.1. Setup

**Download Agent:**
```bash
wget https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip
unzip newrelic-java.zip -d /opt/newrelic
```

**newrelic.yml:**
```yaml
common: &default_settings
  license_key: 'YOUR_LICENSE_KEY'
  app_name: 'Product Service'
  
  distributed_tracing:
    enabled: true
  
  transaction_tracer:
    enabled: true
    transaction_threshold: apdex_f
    record_sql: obfuscated
    
  error_collector:
    enabled: true
    ignore_errors: 'java.io.IOException'
    
  slow_sql:
    enabled: true
    
  thread_profiler:
    enabled: true

production:
  <<: *default_settings
  
development:
  <<: *default_settings
  app_name: 'Product Service (Dev)'
```

**JVM Arguments:**
```bash
java -javaagent:/opt/newrelic/newrelic.jar \
     -Dnewrelic.config.file=/opt/newrelic/newrelic.yml \
     -jar application.jar
```

### 3.2. Custom Instrumentation

```java
import com.newrelic.api.agent.NewRelic;
import com.newrelic.api.agent.Trace;

@Service
public class OrderService {
    
    @Trace(dispatcher = true)
    public Order processOrder(OrderRequest request) {
        // Add custom parameters
        NewRelic.addCustomParameter("orderId", request.getId());
        NewRelic.addCustomParameter("userId", request.getUserId());
        NewRelic.addCustomParameter("amount", request.getTotal());
        
        try {
            Order order = createOrder(request);
            return order;
        } catch (Exception e) {
            // Report error to New Relic
            NewRelic.noticeError(e);
            throw e;
        }
    }
    
    @Trace
    public void validateOrder(Order order) {
        // This method will be traced
        performValidation(order);
    }
}
```

### 3.3. Custom Metrics

```java
import com.newrelic.api.agent.NewRelic;

@Component
public class CustomMetrics {
    
    public void recordMetric(String name, float value) {
        NewRelic.recordMetric("Custom/" + name, value);
    }
    
    public void recordResponseTime(String operation, long milliseconds) {
        NewRelic.recordResponseTimeMetric("Custom/" + operation, milliseconds);
    }
    
    @Scheduled(fixedRate = 60000)
    public void reportBusinessMetrics() {
        int activeUsers = getActiveUserCount();
        NewRelic.recordMetric("Custom/ActiveUsers", activeUsers);
        
        double revenue = getTotalRevenue();
        NewRelic.recordMetric("Custom/Revenue", (float) revenue);
    }
}
```

---

## 4. Datadog

### 4.1. Setup

**Dependencies:**
```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-datadog</artifactId>
</dependency>
```

**application.yml:**
```yaml
management:
  metrics:
    export:
      datadog:
        enabled: true
        api-key: ${DATADOG_API_KEY}
        application-key: ${DATADOG_APP_KEY}
        uri: https://api.datadoghq.com
        step: 10s
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:dev}

spring:
  application:
    name: product-service
```

**Download DD Agent:**
```bash
DD_AGENT_MAJOR_VERSION=7 \
DD_API_KEY=YOUR_API_KEY \
DD_SITE="datadoghq.com" \
bash -c "$(curl -L https://s3.amazonaws.com/dd-agent/scripts/install_script.sh)"
```

### 4.2. APM Tracing

**Download Java Tracer:**
```bash
wget -O dd-java-agent.jar https://dtdg.co/latest-java-tracer
```

**JVM Arguments:**
```bash
java -javaagent:/path/to/dd-java-agent.jar \
     -Ddd.service=product-service \
     -Ddd.env=production \
     -Ddd.version=1.0.0 \
     -Ddd.trace.sample.rate=1 \
     -jar application.jar
```

### 4.3. Custom Spans

```java
import datadog.trace.api.Trace;
import datadog.trace.api.DDTags;
import io.opentracing.Span;
import io.opentracing.util.GlobalTracer;

@Service
public class PaymentService {
    
    @Trace(operationName = "payment.process", resourceName = "ProcessPayment")
    public Payment processPayment(PaymentRequest request) {
        Span span = GlobalTracer.get().activeSpan();
        
        if (span != null) {
            span.setTag("payment.amount", request.getAmount());
            span.setTag("payment.currency", request.getCurrency());
            span.setTag("payment.provider", request.getProvider());
        }
        
        try {
            Payment payment = chargeCard(request);
            span.setTag(DDTags.RESOURCE_NAME, "payment-" + payment.getId());
            return payment;
        } catch (Exception e) {
            span.setTag(DDTags.ERROR, true);
            span.setTag(DDTags.ERROR_MSG, e.getMessage());
            throw e;
        }
    }
}
```

### 4.4. Custom Metrics

```java
import com.timgroup.statsd.NonBlockingStatsDClient;
import com.timgroup.statsd.StatsDClient;

@Configuration
public class DatadogConfig {
    
    @Bean
    public StatsDClient statsDClient() {
        return new NonBlockingStatsDClient(
            "product-service",
            "localhost",
            8125,
            new String[]{"env:production"}
        );
    }
}

@Service
@RequiredArgsConstructor
public class MetricsService {
    
    private final StatsDClient statsDClient;
    
    public void incrementCounter(String metric, String... tags) {
        statsDClient.increment(metric, tags);
    }
    
    public void recordGauge(String metric, long value, String... tags) {
        statsDClient.gauge(metric, value, tags);
    }
    
    public void recordTiming(String metric, long milliseconds, String... tags) {
        statsDClient.time(metric, milliseconds, tags);
    }
}
```

---

## 5. Dynatrace

### 5.1. OneAgent Installation

**Linux:**
```bash
wget -O Dynatrace-OneAgent.sh "https://YOUR_ENVIRONMENT.live.dynatrace.com/api/v1/deployment/installer/agent/unix/default/latest?Api-Token=YOUR_TOKEN"

sudo /bin/sh Dynatrace-OneAgent.sh APP_LOG_CONTENT_ACCESS=1
```

**Automatic Instrumentation:**
Dynatrace OneAgent automatically instruments Java applications without code changes.

### 5.2. Custom Metrics API

```java
import com.dynatrace.oneagent.sdk.OneAgentSDKFactory;
import com.dynatrace.oneagent.sdk.api.OneAgentSDK;
import com.dynatrace.oneagent.sdk.api.metrics.Gauge;
import com.dynatrace.oneagent.sdk.api.metrics.Counter;

@Service
public class DynatraceMetrics {
    
    private final OneAgentSDK oneAgentSDK;
    private final Counter orderCounter;
    private final Gauge activeUsersGauge;
    
    public DynatraceMetrics() {
        this.oneAgentSDK = OneAgentSDKFactory.createInstance();
        
        this.orderCounter = oneAgentSDK.createMetric("custom.orders.created")
                .counter()
                .withDimension("type", "online")
                .build();
        
        this.activeUsersGauge = oneAgentSDK.createMetric("custom.users.active")
                .gauge()
                .build();
    }
    
    public void recordOrder() {
        orderCounter.increase();
    }
    
    public void updateActiveUsers(int count) {
        activeUsersGauge.setValue(count);
    }
}
```

### 5.3. Custom Service Detection

```java
import com.dynatrace.oneagent.sdk.api.IncomingWebRequestTracer;

@Component
public class CustomServiceTracer {
    
    private final OneAgentSDK oneAgentSDK;
    
    public CustomServiceTracer() {
        this.oneAgentSDK = OneAgentSDKFactory.createInstance();
    }
    
    public void traceRequest(HttpServletRequest request) {
        IncomingWebRequestTracer tracer = oneAgentSDK.traceIncomingWebRequest(
            request.getRequestURL().toString(),
            request.getMethod()
        );
        
        tracer.setRemoteAddress(request.getRemoteAddr());
        tracer.addRequestHeader("User-Agent", request.getHeader("User-Agent"));
        
        tracer.start();
        
        try {
            // Process request
        } finally {
            tracer.end();
        }
    }
}
```

---

## 6. AppDynamics

### 6.1. Setup

**Download Agent:**
```bash
wget https://download.appdynamics.com/download/prox/download-file/sun-jvm/latest/AppServerAgent.zip
unzip AppServerAgent.zip -d /opt/appdynamics
```

**JVM Arguments:**
```bash
java -javaagent:/opt/appdynamics/javaagent.jar \
     -Dappdynamics.controller.hostName=controller.example.com \
     -Dappdynamics.controller.port=443 \
     -Dappdynamics.controller.ssl.enabled=true \
     -Dappdynamics.agent.accountName=YOUR_ACCOUNT \
     -Dappdynamics.agent.accountAccessKey=YOUR_KEY \
     -Dappdynamics.agent.applicationName=ProductService \
     -Dappdynamics.agent.tierName=API \
     -Dappdynamics.agent.nodeName=node1 \
     -jar application.jar
```

### 6.2. Custom Business Transactions

```java
import com.appdynamics.apm.appagent.api.AgentDelegate;
import com.appdynamics.apm.appagent.api.ITransactionDemarcator;

@Service
public class OrderService {
    
    public Order processOrder(OrderRequest request) {
        ITransactionDemarcator txn = AgentDelegate.getTransactionDemarcator();
        
        txn.beginBusinessTransaction("ProcessOrder");
        txn.setTransactionName("Order/" + request.getType());
        
        try {
            AgentDelegate.getMetricPublisher()
                    .reportMetric("Orders|Count", 1, "SUM", "COLLECTIVE");
            
            AgentDelegate.getMetricPublisher()
                    .reportMetric("Orders|Value", request.getTotal(), "AVERAGE", "INDIVIDUAL");
            
            Order order = createOrder(request);
            
            txn.markBusinessTransactionAsNormal();
            return order;
            
        } catch (Exception e) {
            txn.markBusinessTransactionAsError();
            throw e;
        } finally {
            txn.endBusinessTransaction();
        }
    }
}
```

---

## 7. Elastic APM

### 7.1. Setup

**Dependencies:**
```xml
<dependency>
    <groupId>co.elastic.apm</groupId>
    <artifactId>apm-agent-attach</artifactId>
    <version>1.39.0</version>
</dependency>
```

**Download Agent:**
```bash
wget https://repo1.maven.org/maven2/co/elastic/apm/elastic-apm-agent/1.39.0/elastic-apm-agent-1.39.0.jar
```

**JVM Arguments:**
```bash
java -javaagent:/path/to/elastic-apm-agent.jar \
     -Delastic.apm.service_name=product-service \
     -Delastic.apm.server_urls=http://localhost:8200 \
     -Delastic.apm.secret_token=YOUR_SECRET_TOKEN \
     -Delastic.apm.environment=production \
     -Delastic.apm.application_packages=com.example \
     -jar application.jar
```

**elasticapm.properties:**
```properties
service_name=product-service
server_urls=http://apm-server:8200
secret_token=YOUR_SECRET_TOKEN
environment=production
application_packages=com.example
log_level=INFO
```

### 7.2. Custom Spans

```java
import co.elastic.apm.api.ElasticApm;
import co.elastic.apm.api.Span;
import co.elastic.apm.api.Transaction;

@Service
public class ProductService {
    
    public Product findById(Long id) {
        Transaction transaction = ElasticApm.currentTransaction();
        transaction.setName("Product Lookup");
        transaction.setType(Transaction.TYPE_REQUEST);
        transaction.addLabel("productId", id.toString());
        
        Span span = transaction.startSpan("db", "query", "select");
        span.setName("SELECT product");
        
        try {
            Product product = productRepository.findById(id).orElseThrow();
            transaction.setResult("success");
            return product;
        } catch (Exception e) {
            transaction.setResult("error");
            span.captureException(e);
            throw e;
        } finally {
            span.end();
        }
    }
}
```

---

## 8. Real User Monitoring (RUM)

### 8.1. New Relic Browser Agent

```html
<script type="text/javascript">
window.NREUM||(NREUM={});
NREUM.loader_config={
  accountID:"YOUR_ACCOUNT_ID",
  trustKey:"YOUR_TRUST_KEY",
  agentID:"YOUR_AGENT_ID",
  licenseKey:"YOUR_LICENSE_KEY",
  applicationID:"YOUR_APP_ID"
};
</script>
<script type="text/javascript" src="//js-agent.newrelic.com/nr-spa-1234.min.js"></script>
```

### 8.2. Datadog RUM

```html
<script>
  (function(h,o,u,n,d) {
    h=h[d]=h[d]||{q:[],onReady:function(c){h.q.push(c)}}
    d=o.createElement(u);d.async=1;d.src=n
    n=o.getElementsByTagName(u)[0];n.parentNode.insertBefore(d,n)
  })(window,document,'script','https://www.datadoghq-browser-agent.com/datadog-rum.js','DD_RUM')
  
  DD_RUM.onReady(function() {
    DD_RUM.init({
      clientToken: 'YOUR_CLIENT_TOKEN',
      applicationId: 'YOUR_APP_ID',
      site: 'datadoghq.com',
      service: 'product-service',
      env: 'production',
      version: '1.0.0',
      sampleRate: 100,
      trackInteractions: true
    })
  })
</script>
```

---

## 9. Alerting Configuration

### 9.1. New Relic Alert Policy

```yaml
name: "High Error Rate"
incident_preference: "PER_POLICY"
conditions:
  - name: "Error rate > 5%"
    type: "apm_app_metric"
    entities: ["YOUR_APP_ID"]
    metric: "error_percentage"
    condition_scope: "application"
    terms:
      - duration: 5
        operator: "above"
        priority: "critical"
        threshold: 5
        time_function: "all"
    violation_close_timer: 24

notification_channels:
  - type: "email"
    configuration:
      recipients: "ops@example.com"
  - type: "slack"
    configuration:
      url: "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
```

### 9.2. Datadog Monitor

```json
{
  "name": "High Response Time",
  "type": "metric alert",
  "query": "avg(last_5m):avg:trace.servlet.request{env:production} > 1000",
  "message": "Response time is above 1 second @pagerduty",
  "tags": ["team:backend", "severity:high"],
  "options": {
    "thresholds": {
      "critical": 1000,
      "warning": 500
    },
    "notify_no_data": true,
    "no_data_timeframe": 10
  }
}
```

---

## 10. Performance Comparison

### 10.1. Overhead Comparison

| APM Tool | CPU Overhead | Memory Overhead | Network Overhead |
|----------|--------------|-----------------|------------------|
| New Relic | 3-5% | 50-100MB | Low |
| Datadog | 2-4% | 40-80MB | Low |
| Dynatrace | 1-3% | 30-60MB | Very Low |
| AppDynamics | 3-6% | 60-120MB | Medium |
| Elastic APM | 2-5% | 50-100MB | Low |

### 10.2. Feature Comparison

| Feature | New Relic | Datadog | Dynatrace | AppDynamics | Elastic APM |
|---------|-----------|---------|-----------|-------------|-------------|
| Auto-instrumentation | ✅ Excellent | ✅ Excellent | ✅ Best | ✅ Excellent | ⚠️ Good |
| Distributed Tracing | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes |
| AI Anomaly Detection | ✅ Yes | ✅ Yes | ✅ Best (Davis) | ✅ Yes | ❌ No |
| Code-level Diagnostics | ✅ Yes | ⚠️ Limited | ✅ Excellent | ✅ Excellent | ⚠️ Limited |
| Infrastructure Monitoring | ✅ Yes | ✅ Excellent | ✅ Yes | ✅ Yes | ✅ Yes |
| Log Management | ✅ Yes | ✅ Excellent | ✅ Yes | ⚠️ Limited | ✅ Excellent |
| Custom Dashboards | ✅ Yes | ✅ Excellent | ✅ Yes | ✅ Yes | ✅ Yes |
| Mobile RUM | ✅ Yes | ✅ Yes | ✅ Yes | ✅ Yes | ❌ No |

---

## 11. Best Practices

### 11.1. Agent Configuration

- Use environment-specific settings
- Enable distributed tracing
- Configure appropriate sampling rates
- Set transaction thresholds correctly
- Exclude sensitive data
- Monitor agent overhead

### 11.2. Custom Instrumentation

- Instrument critical business transactions
- Add meaningful tags/labels
- Avoid over-instrumentation
- Use async instrumentation for high-throughput
- Capture relevant context

### 11.3. Alerting

- Set appropriate thresholds
- Configure escalation policies
- Avoid alert fatigue
- Use composite conditions
- Test alert notifications

---

## 12. Interview Questions

**Q1: What is APM?**
**A:** Application Performance Monitoring - tools for monitoring app performance, errors, and user experience.

**Q2: Name popular APM tools.**
**A:** New Relic, Datadog, Dynatrace, AppDynamics, Elastic APM.

**Q3: What is distributed tracing?**
**A:** Following a request's path through multiple services in a microservices architecture.

**Q4: What is Real User Monitoring (RUM)?**
**A:** Measuring actual user experience by collecting metrics from real users' browsers.

**Q5: How does New Relic agent work?**
**A:** Java agent attaches to JVM, instruments code, collects metrics, sends to New Relic servers.

**Q6: What is Dynatrace OneAgent?**
**A:** Single agent for automatic instrumentation of applications and infrastructure.

**Q7: Datadog vs New Relic?**
**A:** Datadog: Better for infrastructure/DevOps. New Relic: Better for application monitoring.

**Q8: What is Apdex score?**
**A:** Application Performance Index - measure of user satisfaction (Satisfied, Tolerating, Frustrated).

**Q9: What is transaction tracing?**
**A:** Detailed breakdown of individual request execution across all components.

**Q10: How to reduce APM overhead?**
**A:** Lower sampling rate, disable verbose logging, exclude non-critical transactions.

**Q11: What is code-level diagnostics?**
**A:** Ability to see method-level performance, SQL queries, external calls.

**Q12: What is anomaly detection?**
**A:** AI/ML-based automatic detection of unusual patterns in metrics.

**Q13: What is a business transaction?**
**A:** User-defined transaction representing business operation (checkout, login, etc.).

**Q14: How does Elastic APM differ?**
**A:** Open source, integrates with ELK stack, free but requires more setup.

**Q15: What is synthetic monitoring?**
**A:** Simulated user transactions to proactively test availability and performance.

**Q16: What metrics should be monitored?**
**A:** Response time, error rate, throughput, Apdex, resource utilization.

**Q17: What is agent auto-instrumentation?**
**A:** Automatic code instrumentation without manual code changes.

**Q18: How to handle sensitive data in APM?**
**A:** Configure agent to exclude/obfuscate sensitive parameters, headers, SQL.

**Q19: What is AppDynamics Business iQ?**
**A:** Feature correlating business metrics (revenue, conversions) with technical metrics.

**Q20: What is the difference between logs and traces?**
**A:** Logs: Event records. Traces: Request journey through system with timing.

---

## 13. Summary

APM tools monitor application performance and user experience. Popular tools: New Relic, Datadog, Dynatrace, AppDynamics, Elastic APM. Features include transaction tracing, error tracking, distributed tracing, RUM, infrastructure monitoring. Setup involves installing agent and configuring JVM arguments. Custom instrumentation adds business context. Dynatrace offers best auto-instrumentation with AI. Choose based on: budget, features, team expertise. Monitor overhead, set appropriate sampling rates, configure meaningful alerts.

---

**Next:** Distributed Tracing →
