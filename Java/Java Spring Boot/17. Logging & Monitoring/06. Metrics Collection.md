# Metrics Collection - Complete Guide

---

## 1. Introduction to Metrics

Metrics are numerical measurements collected over time to monitor application health and performance.

### Why Metrics?

- **Performance monitoring** - Track response times, throughput
- **Resource utilization** - CPU, memory, disk, network
- **Business metrics** - Orders, revenue, user activity
- **Alerting** - Trigger notifications on thresholds
- **Capacity planning** - Predict scaling needs
- **Debugging** - Identify bottlenecks

### Types of Metrics

- **Counter** - Monotonically increasing (requests, errors)
- **Gauge** - Current value (memory usage, active connections)
- **Timer** - Duration tracking (response time)
- **Distribution Summary** - Statistical distribution (request sizes)

---

## 2. Micrometer Framework

Micrometer is a metrics facade for Java applications (like SLF4J for logging).

### 2.1. Architecture

```
Application Code
      ↓
  Micrometer API (Facade)
      ↓
Registry (Prometheus, Graphite, etc.)
      ↓
Monitoring System (Grafana, Datadog, etc.)
```

### 2.2. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- Prometheus Registry -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

### 2.3. Configuration

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:dev}
```

---

## 3. Counter Metrics

### 3.1. Basic Counter

```java
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;

@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final MeterRegistry meterRegistry;
    private final Counter orderCounter;
    
    @PostConstruct
    public void init() {
        this.orderCounter = Counter.builder("orders.created")
                .description("Total number of orders created")
                .tag("type", "online")
                .register(meterRegistry);
    }
    
    public Order createOrder(OrderRequest request) {
        Order order = processOrder(request);
        orderCounter.increment();
        return order;
    }
}
```

### 3.2. Counter with Tags

```java
@Service
@RequiredArgsConstructor
public class PaymentService {
    
    private final MeterRegistry meterRegistry;
    
    public void processPayment(Payment payment) {
        try {
            // Process payment
            paymentGateway.charge(payment);
            
            // Record success
            meterRegistry.counter("payments.processed",
                "status", "success",
                "provider", payment.getProvider(),
                "currency", payment.getCurrency()
            ).increment();
            
        } catch (PaymentException e) {
            // Record failure
            meterRegistry.counter("payments.processed",
                "status", "failed",
                "provider", payment.getProvider(),
                "error", e.getClass().getSimpleName()
            ).increment();
            
            throw e;
        }
    }
}
```

---

## 4. Gauge Metrics

### 4.1. Simple Gauge

```java
@Service
@RequiredArgsConstructor
public class CacheMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Cache<String, Object> cache;
    
    @PostConstruct
    public void registerGauges() {
        // Cache size gauge
        Gauge.builder("cache.size", cache, Cache::size)
                .description("Current cache size")
                .tag("cache", "products")
                .register(meterRegistry);
        
        // Hit rate gauge
        Gauge.builder("cache.hit.rate", cache, c -> c.stats().hitRate())
                .description("Cache hit rate")
                .tag("cache", "products")
                .register(meterRegistry);
    }
}
```

### 4.2. Collection Gauge

```java
@Component
@RequiredArgsConstructor
public class ConnectionPoolMetrics {
    
    private final MeterRegistry meterRegistry;
    private final HikariDataSource dataSource;
    
    @PostConstruct
    public void init() {
        Gauge.builder("db.connections.active", 
                dataSource, ds -> ds.getHikariPoolMXBean().getActiveConnections())
                .description("Active database connections")
                .register(meterRegistry);
        
        Gauge.builder("db.connections.idle", 
                dataSource, ds -> ds.getHikariPoolMXBean().getIdleConnections())
                .description("Idle database connections")
                .register(meterRegistry);
        
        Gauge.builder("db.connections.total", 
                dataSource, ds -> ds.getHikariPoolMXBean().getTotalConnections())
                .description("Total database connections")
                .register(meterRegistry);
    }
}
```

---

## 5. Timer Metrics

### 5.1. Timer with Code

```java
@Service
@RequiredArgsConstructor
public class UserService {
    
    private final MeterRegistry meterRegistry;
    private final UserRepository userRepository;
    
    public User getUserById(Long id) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            User user = userRepository.findById(id)
                    .orElseThrow(() -> new UserNotFoundException(id));
            
            sample.stop(Timer.builder("user.fetch")
                    .description("Time to fetch user")
                    .tag("result", "success")
                    .register(meterRegistry));
            
            return user;
            
        } catch (Exception e) {
            sample.stop(Timer.builder("user.fetch")
                    .description("Time to fetch user")
                    .tag("result", "error")
                    .register(meterRegistry));
            throw e;
        }
    }
}
```

### 5.2. @Timed Annotation

```java
import io.micrometer.core.annotation.Timed;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {
    
    private final ProductService productService;
    
    @GetMapping("/{id}")
    @Timed(value = "product.get", description = "Get product by ID", percentiles = {0.5, 0.95, 0.99})
    public Product getProduct(@PathVariable Long id) {
        return productService.findById(id);
    }
    
    @PostMapping
    @Timed(value = "product.create", description = "Create new product")
    public Product createProduct(@RequestBody ProductRequest request) {
        return productService.create(request);
    }
}
```

**Enable @Timed:**
```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public TimedAspect timedAspect(MeterRegistry registry) {
        return new TimedAspect(registry);
    }
}
```

---

## 6. Distribution Summary

### 6.1. Request Size Tracking

```java
@Component
@RequiredArgsConstructor
public class RequestSizeFilter extends OncePerRequestFilter {
    
    private final MeterRegistry meterRegistry;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        int contentLength = request.getContentLength();
        
        if (contentLength > 0) {
            DistributionSummary.builder("http.request.size")
                    .description("HTTP request size distribution")
                    .tag("method", request.getMethod())
                    .tag("uri", request.getRequestURI())
                    .baseUnit("bytes")
                    .serviceLevelObjectives(1024, 10240, 102400) // 1KB, 10KB, 100KB
                    .register(meterRegistry)
                    .record(contentLength);
        }
        
        filterChain.doFilter(request, response);
    }
}
```

### 6.2. Response Size Tracking

```java
@Component
public class ResponseSizeMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public ResponseSizeMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        DistributionSummary.builder("http.response.size")
                .description("HTTP response size distribution")
                .baseUnit("bytes")
                .publishPercentiles(0.5, 0.95, 0.99)
                .register(meterRegistry);
    }
    
    public void recordResponseSize(int size, String endpoint) {
        meterRegistry.summary("http.response.size", "endpoint", endpoint)
                .record(size);
    }
}
```

---

## 7. JVM Metrics

### 7.1. Automatic JVM Metrics

Spring Boot Actuator automatically registers:

- **Memory**: `jvm.memory.used`, `jvm.memory.committed`, `jvm.memory.max`
- **GC**: `jvm.gc.pause`, `jvm.gc.memory.allocated`
- **Threads**: `jvm.threads.live`, `jvm.threads.daemon`, `jvm.threads.peak`
- **Classes**: `jvm.classes.loaded`, `jvm.classes.unloaded`

### 7.2. Custom JVM Metrics

```java
@Component
@RequiredArgsConstructor
public class CustomJvmMetrics {
    
    private final MeterRegistry meterRegistry;
    
    @PostConstruct
    public void init() {
        // CPU usage
        Gauge.builder("jvm.cpu.usage", this, CustomJvmMetrics::getCpuUsage)
                .description("JVM CPU usage")
                .register(meterRegistry);
        
        // Heap memory usage percentage
        Gauge.builder("jvm.heap.usage.percentage", this, CustomJvmMetrics::getHeapUsagePercentage)
                .description("Heap memory usage percentage")
                .register(meterRegistry);
    }
    
    private double getCpuUsage() {
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        if (osBean instanceof com.sun.management.OperatingSystemMXBean) {
            return ((com.sun.management.OperatingSystemMXBean) osBean).getProcessCpuLoad() * 100;
        }
        return -1;
    }
    
    private double getHeapUsagePercentage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        return (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
    }
}
```

---

## 8. HTTP Metrics

### 8.1. Automatic HTTP Metrics

Actuator automatically tracks:

- `http.server.requests` - Request count and duration
- Tags: method, uri, status, exception

### 8.2. Custom HTTP Metrics

```java
@Component
@RequiredArgsConstructor
public class HttpMetricsFilter extends OncePerRequestFilter {
    
    private final MeterRegistry meterRegistry;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            sample.stop(Timer.builder("http.request.custom")
                    .tag("method", request.getMethod())
                    .tag("uri", request.getRequestURI())
                    .tag("status", String.valueOf(response.getStatus()))
                    .tag("outcome", getOutcome(response.getStatus()))
                    .register(meterRegistry));
            
            // Record status code distribution
            meterRegistry.counter("http.status",
                    "code", String.valueOf(response.getStatus()),
                    "series", getStatusSeries(response.getStatus())
            ).increment();
        }
    }
    
    private String getOutcome(int status) {
        if (status >= 200 && status < 300) return "SUCCESS";
        if (status >= 400 && status < 500) return "CLIENT_ERROR";
        if (status >= 500) return "SERVER_ERROR";
        return "UNKNOWN";
    }
    
    private String getStatusSeries(int status) {
        return status / 100 + "xx";
    }
}
```

---

## 9. Database Metrics

### 9.1. HikariCP Metrics

```java
@Configuration
public class DataSourceConfig {
    
    @Bean
    public HikariDataSource dataSource(MeterRegistry meterRegistry) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("password");
        config.setMaximumPoolSize(10);
        config.setMetricRegistry(meterRegistry);
        
        HikariDataSource dataSource = new HikariDataSource(config);
        
        // Register HikariCP metrics
        dataSource.setMetricRegistry(meterRegistry);
        
        return dataSource;
    }
}
```

### 9.2. Query Performance Metrics

```java
@Aspect
@Component
@RequiredArgsConstructor
public class RepositoryMetricsAspect {
    
    private final MeterRegistry meterRegistry;
    
    @Around("execution(* com.example.repository.*.*(..))")
    public Object measureRepositoryMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        Timer.Sample sample = Timer.start(meterRegistry);
        String methodName = joinPoint.getSignature().getName();
        String repository = joinPoint.getTarget().getClass().getSimpleName();
        
        try {
            Object result = joinPoint.proceed();
            
            sample.stop(Timer.builder("repository.query")
                    .tag("repository", repository)
                    .tag("method", methodName)
                    .tag("status", "success")
                    .register(meterRegistry));
            
            return result;
            
        } catch (Exception e) {
            sample.stop(Timer.builder("repository.query")
                    .tag("repository", repository)
                    .tag("method", methodName)
                    .tag("status", "error")
                    .register(meterRegistry));
            throw e;
        }
    }
}
```

---

## 10. Cache Metrics

### 10.1. Caffeine Cache

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(MeterRegistry meterRegistry) {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .recordStats());
        
        // Register metrics
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof CaffeineCache) {
                com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                    ((CaffeineCache) cache).getNativeCache();
                
                CaffeineCacheMetrics.monitor(meterRegistry, nativeCache, cacheName);
            }
        });
        
        return cacheManager;
    }
}
```

### 10.2. Custom Cache Metrics

```java
@Component
@RequiredArgsConstructor
public class CacheMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final CacheManager cacheManager;
    
    @PostConstruct
    public void init() {
        cacheManager.getCacheNames().forEach(this::registerCacheMetrics);
    }
    
    private void registerCacheMetrics(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        
        if (cache instanceof CaffeineCache) {
            com.github.benmanes.caffeine.cache.Cache<Object, Object> nativeCache = 
                ((CaffeineCache) cache).getNativeCache();
            
            CacheStats stats = nativeCache.stats();
            
            Gauge.builder("cache.size", nativeCache, c -> c.estimatedSize())
                    .tag("cache", cacheName)
                    .register(meterRegistry);
            
            Gauge.builder("cache.hit.rate", stats, CacheStats::hitRate)
                    .tag("cache", cacheName)
                    .register(meterRegistry);
            
            Gauge.builder("cache.eviction.count", stats, CacheStats::evictionCount)
                    .tag("cache", cacheName)
                    .register(meterRegistry);
        }
    }
}
```

---

## 11. Business Metrics

### 11.1. Revenue Tracking

```java
@Service
@RequiredArgsConstructor
public class RevenueMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public void recordSale(Order order) {
        // Total revenue counter
        meterRegistry.counter("revenue.total",
                "currency", order.getCurrency(),
                "region", order.getRegion()
        ).increment(order.getTotal().doubleValue());
        
        // Order value distribution
        meterRegistry.summary("order.value",
                "currency", order.getCurrency()
        ).record(order.getTotal().doubleValue());
        
        // Items per order
        meterRegistry.summary("order.items.count")
                .record(order.getItems().size());
    }
}
```

### 11.2. User Activity Metrics

```java
@Service
@RequiredArgsConstructor
public class UserActivityMetrics {
    
    private final MeterRegistry meterRegistry;
    
    public void recordLogin(String userId) {
        meterRegistry.counter("user.logins",
                "userId", userId
        ).increment();
    }
    
    public void recordAction(String action, String userId) {
        meterRegistry.counter("user.actions",
                "action", action,
                "userId", userId
        ).increment();
    }
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void recordActiveUsers() {
        int activeUsers = getActiveUserCount();
        
        Gauge.builder("users.active", this, u -> getActiveUserCount())
                .register(meterRegistry);
    }
    
    private int getActiveUserCount() {
        // Logic to count active users
        return 0;
    }
}
```

---

## 12. Prometheus Integration

### 12.1. Prometheus Configuration

**prometheus.yml:**
```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'spring-boot-app'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']
        labels:
          application: 'product-service'
          environment: 'production'
```

### 12.2. Scrape Endpoint

Access metrics at: `http://localhost:8080/actuator/prometheus`

**Sample output:**
```
# HELP orders_created_total Total number of orders created
# TYPE orders_created_total counter
orders_created_total{application="product-service",environment="production",type="online"} 1523.0

# HELP http_server_requests_seconds  
# TYPE http_server_requests_seconds summary
http_server_requests_seconds_count{exception="None",method="GET",status="200",uri="/api/products/{id}"} 5432.0
http_server_requests_seconds_sum{exception="None",method="GET",status="200",uri="/api/products/{id}"} 124.567
```

---

## 13. Custom MeterBinder

### 13.1. System Metrics Binder

```java
@Component
public class SystemMetricsBinder implements MeterBinder {
    
    @Override
    public void bindTo(MeterRegistry registry) {
        // Disk space
        File root = new File("/");
        Gauge.builder("system.disk.total", root, File::getTotalSpace)
                .baseUnit("bytes")
                .description("Total disk space")
                .register(registry);
        
        Gauge.builder("system.disk.free", root, File::getFreeSpace)
                .baseUnit("bytes")
                .description("Free disk space")
                .register(registry);
        
        // System load
        OperatingSystemMXBean osBean = ManagementFactory.getOperatingSystemMXBean();
        Gauge.builder("system.load.average", osBean, OperatingSystemMXBean::getSystemLoadAverage)
                .description("System load average")
                .register(registry);
    }
}
```

### 13.2. Custom Application Metrics

```java
@Component
public class ApplicationMetricsBinder implements MeterBinder {
    
    private final ApplicationContext applicationContext;
    
    public ApplicationMetricsBinder(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
    
    @Override
    public void bindTo(MeterRegistry registry) {
        // Bean count
        Gauge.builder("application.beans.count", applicationContext, ctx -> ctx.getBeanDefinitionCount())
                .description("Number of beans in application context")
                .register(registry);
        
        // Startup time
        Gauge.builder("application.startup.time", applicationContext, 
                ctx -> ctx.getStartupDate())
                .description("Application startup timestamp")
                .register(registry);
    }
}
```

---

## 14. Multi-Registry Support

### 14.1. Multiple Registries

```java
@Configuration
public class MetricsConfig {
    
    @Bean
    public CompositeMeterRegistry compositeMeterRegistry(
            PrometheusMeterRegistry prometheusRegistry,
            SimpleMeterRegistry simpleRegistry) {
        
        CompositeMeterRegistry composite = new CompositeMeterRegistry();
        composite.add(prometheusRegistry);
        composite.add(simpleRegistry);
        
        return composite;
    }
    
    @Bean
    public PrometheusMeterRegistry prometheusRegistry(PrometheusConfig config) {
        return new PrometheusMeterRegistry(config);
    }
    
    @Bean
    public SimpleMeterRegistry simpleRegistry() {
        return new SimpleMeterRegistry();
    }
}
```

---

## 15. Best Practices

### 15.1. Naming Conventions

```java
// Good - follows conventions
"http.server.requests"
"db.connection.pool.size"
"cache.hit.rate"

// Bad - inconsistent
"httpRequests"
"DB_Connection_Pool_Size"
"cacheHitRate"
```

### 15.2. Tag Usage

```java
// Good - use tags for dimensions
meterRegistry.counter("orders.created",
    "status", "completed",
    "region", "US"
).increment();

// Bad - metrics explosion
meterRegistry.counter("orders.created.completed.US").increment();
```

### 15.3. Cardinality Control

```java
// Good - bounded cardinality
meterRegistry.counter("api.requests",
    "endpoint", "/api/products",  // Limited endpoints
    "status", "200"               // Limited status codes
).increment();

// Bad - unbounded cardinality
meterRegistry.counter("api.requests",
    "user_id", userId,            // Millions of users
    "request_id", requestId       // Unique per request
).increment();
```

---

## 16. Interview Questions

**Q1: What is Micrometer?**
**A:** Metrics facade for Java, like SLF4J for logging.

**Q2: What are the four metric types?**
**A:** Counter (increasing), Gauge (current value), Timer (duration), Distribution Summary (distribution).

**Q3: Counter vs Gauge?**
**A:** Counter: Monotonically increasing (requests). Gauge: Current value that can go up/down (memory).

**Q4: What is a MeterRegistry?**
**A:** Central registry managing all metrics, can be Prometheus, Graphite, etc.

**Q5: How to add custom metrics?**
**A:** Inject MeterRegistry, use Counter.builder(), Gauge.builder(), etc.

**Q6: What is @Timed annotation?**
**A:** Automatically measures method execution time, requires TimedAspect bean.

**Q7: What metrics does Actuator provide?**
**A:** JVM (memory, GC, threads), HTTP requests, database connection pool, cache stats.

**Q8: What is cardinality in metrics?**
**A:** Number of unique tag combinations; high cardinality causes performance issues.

**Q9: How to export metrics to Prometheus?**
**A:** Add micrometer-registry-prometheus dependency, expose /actuator/prometheus endpoint.

**Q10: What are percentiles in Timer?**
**A:** Statistical values (p50, p95, p99) showing distribution of durations.

**Q11: What is MeterBinder?**
**A:** Interface for registering custom metrics, bound to MeterRegistry.

**Q12: How to track HTTP request count?**
**A:** Use http.server.requests counter (automatic) or create custom counter.

**Q13: What is CompositeMeterRegistry?**
**A:** Registry combining multiple registries (e.g., Prometheus + Graphite).

**Q14: How to monitor cache performance?**
**A:** Track size, hit rate, miss rate, eviction count using Gauges.

**Q15: What is Distribution Summary?**
**A:** Tracks distribution of values (e.g., request sizes, payload sizes).

**Q16: How to add tags to metrics?**
**A:** Use .tag("key", "value") when building metrics.

**Q17: What is service level objective (SLO)?**
**A:** Target percentile values for distribution summary.

**Q18: How to track business metrics?**
**A:** Create custom counters/gauges for revenue, orders, user activity.

**Q19: What is base unit in metrics?**
**A:** Unit of measurement (bytes, seconds, etc.) for better understanding.

**Q20: How to avoid metrics explosion?**
**A:** Limit tag cardinality, use bounded tag values, avoid unique IDs as tags.

---

## 17. Summary

Metrics are numerical measurements for monitoring. Micrometer is the metrics facade. Four types: Counter (increasing), Gauge (current value), Timer (duration), Distribution Summary (distribution). Spring Boot Actuator provides automatic JVM, HTTP, and database metrics. Create custom metrics with MeterRegistry. Export to Prometheus via /actuator/prometheus. Use tags for dimensions but control cardinality. Track business metrics (revenue, orders). Follow naming conventions. Monitor cache, database, and HTTP performance.

---

**Next:** APM Tools →
