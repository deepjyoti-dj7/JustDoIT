# Custom Logging - Complete Guide

---

## 1. Introduction to Custom Logging

Custom logging extends Spring Boot's default capabilities with custom appenders, filters, formatters, and patterns to meet specific requirements.

### Use Cases
- Send logs to external services
- Custom log format requirements
- Filtering sensitive data
- Business-specific logging
- Audit trails
- Custom metrics collection

---

## 2. Custom Log Appenders

### 2.1. Database Appender

```java
public class DatabaseAppender extends AppenderBase<ILoggingEvent> {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Override
    protected void append(ILoggingEvent event) {
        String sql = "INSERT INTO logs (timestamp, level, logger, message, thread) " +
                    "VALUES (?, ?, ?, ?, ?)";
        
        jdbcTemplate.update(sql,
            new Timestamp(event.getTimeStamp()),
            event.getLevel().toString(),
            event.getLoggerName(),
            event.getFormattedMessage(),
            event.getThreadName()
        );
    }
}
```

**Configuration:**
```xml
<appender name="DB" class="com.example.logging.DatabaseAppender">
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
        <level>WARN</level>
    </filter>
</appender>

<root level="INFO">
    <appender-ref ref="DB" />
</root>
```

### 2.2. Slack Appender

```java
public class SlackAppender extends AppenderBase<ILoggingEvent> {
    
    private String webhookUrl;
    private RestTemplate restTemplate = new RestTemplate();
    
    @Override
    protected void append(ILoggingEvent event) {
        if (event.getLevel().isGreaterOrEqual(Level.ERROR)) {
            sendToSlack(event);
        }
    }
    
    private void sendToSlack(ILoggingEvent event) {
        Map<String, Object> payload = new HashMap<>();
        payload.put("text", formatMessage(event));
        payload.put("username", "Error Bot");
        payload.put("icon_emoji", ":rotating_light:");
        
        try {
            restTemplate.postForObject(webhookUrl, payload, String.class);
        } catch (Exception e) {
            addError("Failed to send to Slack", e);
        }
    }
    
    private String formatMessage(ILoggingEvent event) {
        return String.format("*%s* - %s\n```%s```",
            event.getLevel(),
            event.getFormattedMessage(),
            event.getThrowableProxy() != null ? 
                ThrowableProxyUtil.asString(event.getThrowableProxy()) : ""
        );
    }
    
    public void setWebhookUrl(String webhookUrl) {
        this.webhookUrl = webhookUrl;
    }
}
```

**Configuration:**
```xml
<appender name="SLACK" class="com.example.logging.SlackAppender">
    <webhookUrl>https://hooks.slack.com/services/YOUR/WEBHOOK/URL</webhookUrl>
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
        <level>ERROR</level>
    </filter>
</appender>
```

### 2.3. Email Appender

```java
public class EmailAppender extends AppenderBase<ILoggingEvent> {
    
    @Autowired
    private JavaMailSender mailSender;
    
    private String to;
    private String from;
    private String subject;
    
    @Override
    protected void append(ILoggingEvent event) {
        sendEmail(event);
    }
    
    private void sendEmail(ILoggingEvent event) {
        MimeMessage message = mailSender.createMimeMessage();
        
        try {
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            helper.setTo(to);
            helper.setFrom(from);
            helper.setSubject(subject + " - " + event.getLevel());
            helper.setText(formatEmail(event), true);
            
            mailSender.send(message);
        } catch (MessagingException e) {
            addError("Failed to send email", e);
        }
    }
    
    private String formatEmail(ILoggingEvent event) {
        StringBuilder html = new StringBuilder();
        html.append("<h2>").append(event.getLevel()).append("</h2>");
        html.append("<p><strong>Time:</strong> ")
            .append(new Date(event.getTimeStamp())).append("</p>");
        html.append("<p><strong>Logger:</strong> ")
            .append(event.getLoggerName()).append("</p>");
        html.append("<p><strong>Message:</strong> ")
            .append(event.getFormattedMessage()).append("</p>");
        
        if (event.getThrowableProxy() != null) {
            html.append("<pre>")
                .append(ThrowableProxyUtil.asString(event.getThrowableProxy()))
                .append("</pre>");
        }
        
        return html.toString();
    }
    
    // Setters
    public void setTo(String to) { this.to = to; }
    public void setFrom(String from) { this.from = from; }
    public void setSubject(String subject) { this.subject = subject; }
}
```

---

## 3. Custom Filters

### 3.1. Sensitive Data Filter

```java
public class SensitiveDataFilter extends Filter<ILoggingEvent> {
    
    private static final Pattern PASSWORD_PATTERN = 
        Pattern.compile("password[\"']?\\s*[:=]\\s*[\"']?([^\\s,\"']+)", 
                       Pattern.CASE_INSENSITIVE);
    
    private static final Pattern CREDIT_CARD_PATTERN = 
        Pattern.compile("\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}\\b");
    
    @Override
    public FilterReply decide(ILoggingEvent event) {
        String message = event.getFormattedMessage();
        
        // Mask passwords
        message = PASSWORD_PATTERN.matcher(message)
            .replaceAll("password=***MASKED***");
        
        // Mask credit cards
        message = CREDIT_CARD_PATTERN.matcher(message)
            .replaceAll("****-****-****-****");
        
        // Create new event with masked message
        // (In practice, you'd modify the event or use a different approach)
        
        return FilterReply.NEUTRAL;
    }
}
```

### 3.2. Rate Limiting Filter

```java
public class RateLimitingFilter extends Filter<ILoggingEvent> {
    
    private final Map<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    private int maxLogsPerSecond = 100;
    
    @Override
    public FilterReply decide(ILoggingEvent event) {
        String logger = event.getLoggerName();
        
        RateLimiter limiter = limiters.computeIfAbsent(
            logger, 
            k -> RateLimiter.create(maxLogsPerSecond)
        );
        
        if (limiter.tryAcquire()) {
            return FilterReply.NEUTRAL;
        } else {
            return FilterReply.DENY;
        }
    }
    
    public void setMaxLogsPerSecond(int maxLogsPerSecond) {
        this.maxLogsPerSecond = maxLogsPerSecond;
    }
}
```

**Configuration:**
```xml
<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>logs/application.log</file>
    <filter class="com.example.logging.RateLimitingFilter">
        <maxLogsPerSecond>100</maxLogsPerSecond>
    </filter>
    <encoder>
        <pattern>%d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>
```

### 3.3. Environment-Based Filter

```java
public class EnvironmentFilter extends Filter<ILoggingEvent> {
    
    private String allowedEnvironment;
    
    @Override
    public FilterReply decide(ILoggingEvent event) {
        String currentEnv = System.getProperty("spring.profiles.active");
        
        if (allowedEnvironment.equals(currentEnv)) {
            return FilterReply.NEUTRAL;
        } else {
            return FilterReply.DENY;
        }
    }
    
    public void setAllowedEnvironment(String env) {
        this.allowedEnvironment = env;
    }
}
```

---

## 4. Custom Layouts

### 4.1. JSON Layout

```java
public class JsonLayout extends LayoutBase<ILoggingEvent> {
    
    private ObjectMapper objectMapper = new ObjectMapper();
    
    @Override
    public String doLayout(ILoggingEvent event) {
        Map<String, Object> logEntry = new LinkedHashMap<>();
        logEntry.put("timestamp", new Date(event.getTimeStamp()));
        logEntry.put("level", event.getLevel().toString());
        logEntry.put("thread", event.getThreadName());
        logEntry.put("logger", event.getLoggerName());
        logEntry.put("message", event.getFormattedMessage());
        
        // Add MDC
        Map<String, String> mdc = event.getMDCPropertyMap();
        if (!mdc.isEmpty()) {
            logEntry.put("mdc", mdc);
        }
        
        // Add exception
        if (event.getThrowableProxy() != null) {
            logEntry.put("exception", 
                ThrowableProxyUtil.asString(event.getThrowableProxy()));
        }
        
        try {
            return objectMapper.writeValueAsString(logEntry) + "\n";
        } catch (JsonProcessingException e) {
            return "{\"error\":\"Failed to serialize log\"}\n";
        }
    }
}
```

**Configuration:**
```xml
<appender name="JSON_FILE" class="ch.qos.logback.core.FileAppender">
    <file>logs/application.json</file>
    <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
        <layout class="com.example.logging.JsonLayout" />
    </encoder>
</appender>
```

### 4.2. Custom Pattern Layout

```java
public class CustomPatternLayout extends PatternLayout {
    
    static {
        // Register custom converter
        DEFAULT_CONVERTER_MAP.put("customField", CustomFieldConverter.class.getName());
    }
}

public class CustomFieldConverter extends ClassicConverter {
    
    @Override
    public String convert(ILoggingEvent event) {
        // Add custom logic
        return MDC.get("customField");
    }
}
```

---

## 5. Audit Logging

### 5.1. Audit Logger

```java
@Slf4j
@Component
public class AuditLogger {
    
    private static final Logger auditLog = 
        LoggerFactory.getLogger("AUDIT");
    
    public void logUserAction(String username, String action, String resource) {
        MDC.put("username", username);
        MDC.put("action", action);
        MDC.put("resource", resource);
        MDC.put("timestamp", Instant.now().toString());
        
        auditLog.info("User action: {} performed {} on {}", 
            username, action, resource);
        
        MDC.clear();
    }
    
    public void logSecurityEvent(String eventType, String details) {
        MDC.put("eventType", eventType);
        MDC.put("severity", "HIGH");
        
        auditLog.warn("Security event: {} - {}", eventType, details);
        
        MDC.clear();
    }
}
```

### 5.2. Audit Configuration

```xml
<!-- logback-spring.xml -->
<appender name="AUDIT_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/audit.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>logs/audit-%d{yyyy-MM-dd}.log</fileNamePattern>
        <maxHistory>365</maxHistory>
    </rollingPolicy>
    <encoder>
        <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{username}] %X{action} %X{resource} - %msg%n</pattern>
    </encoder>
</appender>

<logger name="AUDIT" level="INFO" additivity="false">
    <appender-ref ref="AUDIT_FILE" />
</logger>
```

### 5.3. Audit Aspect

```java
@Aspect
@Component
@Slf4j
public class AuditAspect {
    
    @Autowired
    private AuditLogger auditLogger;
    
    @Around("@annotation(auditable)")
    public Object auditMethod(ProceedingJoinPoint joinPoint, Auditable auditable) 
            throws Throwable {
        
        String username = SecurityContextHolder.getContext()
            .getAuthentication().getName();
        String methodName = joinPoint.getSignature().getName();
        String resource = auditable.resource();
        
        auditLogger.logUserAction(username, methodName, resource);
        
        try {
            Object result = joinPoint.proceed();
            auditLogger.logUserAction(username, methodName + "_SUCCESS", resource);
            return result;
        } catch (Exception e) {
            auditLogger.logSecurityEvent("OPERATION_FAILED", 
                username + " failed " + methodName);
            throw e;
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Auditable {
    String resource();
}
```

**Usage:**
```java
@Service
public class ProductService {
    
    @Auditable(resource = "PRODUCT")
    public Product createProduct(Product product) {
        return repository.save(product);
    }
    
    @Auditable(resource = "PRODUCT")
    public void deleteProduct(Long id) {
        repository.deleteById(id);
    }
}
```

---

## 6. Request/Response Logging

### 6.1. Logging Filter

```java
@Slf4j
@Component
public class RequestResponseLoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        // Wrap request and response for reading
        ContentCachingRequestWrapper wrappedRequest = 
            new ContentCachingRequestWrapper(request);
        ContentCachingResponseWrapper wrappedResponse = 
            new ContentCachingResponseWrapper(response);
        
        long startTime = System.currentTimeMillis();
        
        try {
            filterChain.doFilter(wrappedRequest, wrappedResponse);
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            
            logRequest(wrappedRequest, duration);
            logResponse(wrappedResponse, duration);
            
            wrappedResponse.copyBodyToResponse();
        }
    }
    
    private void logRequest(ContentCachingRequestWrapper request, long duration) {
        String requestBody = new String(request.getContentAsByteArray(), 
                                       StandardCharsets.UTF_8);
        
        log.info("Request: {} {} | Body: {} | Duration: {}ms",
            request.getMethod(),
            request.getRequestURI(),
            requestBody.isEmpty() ? "empty" : requestBody,
            duration);
    }
    
    private void logResponse(ContentCachingResponseWrapper response, long duration) {
        String responseBody = new String(response.getContentAsByteArray(),
                                        StandardCharsets.UTF_8);
        
        log.info("Response: Status {} | Body: {} | Duration: {}ms",
            response.getStatus(),
            responseBody.isEmpty() ? "empty" : responseBody,
            duration);
    }
}
```

### 6.2. Logging Interceptor

```java
@Slf4j
@Component
public class LoggingInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) {
        
        request.setAttribute("startTime", System.currentTimeMillis());
        
        log.info("Incoming request: {} {} from {}",
            request.getMethod(),
            request.getRequestURI(),
            request.getRemoteAddr());
        
        return true;
    }
    
    @Override
    public void postHandle(HttpServletRequest request,
                          HttpServletResponse response,
                          Object handler,
                          ModelAndView modelAndView) {
        
        long startTime = (Long) request.getAttribute("startTime");
        long duration = System.currentTimeMillis() - startTime;
        
        log.info("Request completed: {} {} | Status: {} | Duration: {}ms",
            request.getMethod(),
            request.getRequestURI(),
            response.getStatus(),
            duration);
    }
}
```

---

## 7. Performance Logging

### 7.1. Method Execution Time

```java
@Aspect
@Component
@Slf4j
public class PerformanceLoggingAspect {
    
    @Around("@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        
        long start = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().toShortString();
        
        try {
            Object result = joinPoint.proceed();
            long executionTime = System.currentTimeMillis() - start;
            
            if (executionTime > 1000) {
                log.warn("Slow method: {} took {}ms", methodName, executionTime);
            } else {
                log.debug("Method: {} took {}ms", methodName, executionTime);
            }
            
            return result;
        } catch (Throwable t) {
            log.error("Method {} failed after {}ms", 
                methodName, System.currentTimeMillis() - start, t);
            throw t;
        }
    }
}
```

### 7.2. @Timed Annotation

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Timed {
    String value() default "";
}

@Aspect
@Component
@Slf4j
public class TimedAspect {
    
    @Around("@annotation(timed)")
    public Object measureTime(ProceedingJoinPoint joinPoint, Timed timed) 
            throws Throwable {
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        try {
            return joinPoint.proceed();
        } finally {
            stopWatch.stop();
            String label = timed.value().isEmpty() ? 
                joinPoint.getSignature().toShortString() : timed.value();
            
            log.info("Execution time of {}: {}ms", 
                label, stopWatch.getTotalTimeMillis());
        }
    }
}
```

**Usage:**
```java
@Service
public class ProductService {
    
    @Timed("product-fetch")
    public Product getProduct(Long id) {
        return repository.findById(id).orElseThrow();
    }
}
```

---

## 8. Correlation IDs

### 8.1. Correlation ID Filter

```java
@Component
public class CorrelationIdFilter extends OncePerRequestFilter {
    
    private static final String CORRELATION_ID_HEADER = "X-Correlation-ID";
    private static final String CORRELATION_ID_MDC = "correlationId";
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        String correlationId = request.getHeader(CORRELATION_ID_HEADER);
        
        if (correlationId == null || correlationId.isEmpty()) {
            correlationId = UUID.randomUUID().toString();
        }
        
        MDC.put(CORRELATION_ID_MDC, correlationId);
        response.setHeader(CORRELATION_ID_HEADER, correlationId);
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.remove(CORRELATION_ID_MDC);
        }
    }
}
```

### 8.2. Log Pattern with Correlation ID

```xml
<pattern>%d{HH:mm:ss.SSS} [%X{correlationId}] [%thread] %-5level %logger{36} - %msg%n</pattern>
```

Output:
```
10:30:45.123 [abc-123-def] [http-nio-8080-exec-1] INFO  c.e.ProductService - Fetching product
```

---

## 9. Interview Questions

**Q1: What is a custom appender?**
**A:** Custom destination for logs (database, Slack, email, external service).

**Q2: How to mask sensitive data in logs?**
**A:** Use custom filter with regex patterns to replace sensitive values.

**Q3: What is audit logging?**
**A:** Logging user actions and security events for compliance and security.

**Q4: How to add correlation ID to logs?**
**A:** Use MDC in filter to add correlation ID from header or generate UUID.

**Q5: How to log request/response?**
**A:** Use Filter or Interceptor with ContentCachingRequestWrapper/ResponseWrapper.

**Q6: What is rate limiting in logging?**
**A:** Limiting number of logs per second to prevent log flooding.

**Q7: How to implement custom log layout?**
**A:** Extend LayoutBase<ILoggingEvent> and override doLayout().

**Q8: What is the purpose of @Auditable annotation?**
**A:** Mark methods for automatic audit logging using AOP.

**Q9: How to log method execution time?**
**A:** Use AOP aspect with @Around advice measuring before/after.

**Q10: How to send ERROR logs to Slack?**
**A:** Create custom SlackAppender with ThresholdFilter for ERROR level.

**Q11: What is ContentCachingRequestWrapper?**
**A:** Wrapper that caches request body for multiple reads (logging).

**Q12: How to separate audit logs from application logs?**
**A:** Use separate logger name and appender configuration.

**Q13: How to implement JSON logging?**
**A:** Create custom JsonLayout or use logstash-logback-encoder.

**Q14: What is the purpose of MDC?**
**A:** Add contextual information (correlation ID, user) to all logs.

**Q15: How to filter logs by environment?**
**A:** Use custom EnvironmentFilter checking spring.profiles.active.

**Q16: How to log to database?**
**A:** Create custom DatabaseAppender using JdbcTemplate.

**Q17: Should you log full request/response in production?**
**A:** No, only in dev. In production, log metadata (status, duration, IDs).

**Q18: How to measure slow methods?**
**A:** Use AOP aspect logging execution time, warn if above threshold.

**Q19: What is additivity in loggers?**
**A:** Whether logger passes events to parent logger. Set false for audit logs.

**Q20: How to test custom appenders?**
**A:** Use test appender that stores events in memory for verification.

---

## 10. Summary

Custom logging extends Spring Boot's capabilities with custom appenders (database, Slack, email), filters (sensitive data masking, rate limiting), layouts (JSON), and patterns. Implement audit logging for compliance. Use correlation IDs for request tracking. Log request/response with filters. Measure performance with AOP aspects. Separate audit logs from application logs.

---

**Next:** Structured Logging â†’
