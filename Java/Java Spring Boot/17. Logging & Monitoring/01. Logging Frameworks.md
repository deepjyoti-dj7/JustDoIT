# Logging Frameworks - Complete Guide

---

## 1. Introduction to Logging

Logging is essential for debugging, monitoring, and auditing applications. It provides visibility into application behavior, errors, and performance.

### Why Logging?
- **Debugging** - Trace code execution and identify bugs
- **Monitoring** - Track application health and performance
- **Auditing** - Record user actions and security events
- **Troubleshooting** - Diagnose production issues
- **Analytics** - Analyze usage patterns

### Logging Best Practices
- Use appropriate log levels
- Include contextual information
- Avoid logging sensitive data
- Use structured logging
- Configure log rotation
- Centralize logs in distributed systems

---

## 2. Java Logging Landscape

### 2.1. Logging Facades (Abstractions)

**SLF4J (Simple Logging Facade for Java)**
- Most popular logging facade
- Abstraction over various logging frameworks
- Allows switching implementations without code changes

**Commons Logging (Apache)**
- Older logging facade
- Less popular than SLF4J

### 2.2. Logging Implementations

**Logback** (Recommended)
- Native implementation of SLF4J
- Faster than Log4j
- Better configuration options
- Default in Spring Boot

**Log4j 2**
- Apache logging framework
- Async logging support
- Good performance

**Java Util Logging (JUL)**
- Built into Java
- Less features
- Not recommended for production

---

## 3. Spring Boot Logging Architecture

### 3.1. Default Setup

Spring Boot uses **SLF4J + Logback** by default:

```
Your Code
    ↓
  SLF4J API (Facade)
    ↓
  Logback (Implementation)
    ↓
  Console/File Output
```

### 3.2. Dependencies

Spring Boot Starter includes logging:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <!-- Includes spring-boot-starter-logging -->
</dependency>
```

**spring-boot-starter-logging includes:**
- SLF4J API
- Logback
- Log4j to SLF4J bridge
- JUL to SLF4J bridge

---

## 4. SLF4J (Simple Logging Facade)

### 4.1. Basic Usage

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class ProductService {
    
    private static final Logger log = LoggerFactory.getLogger(ProductService.class);
    
    public Product getProduct(Long id) {
        log.info("Fetching product with id: {}", id);
        
        Product product = repository.findById(id).orElse(null);
        
        if (product == null) {
            log.warn("Product not found: {}", id);
            throw new ProductNotFoundException(id);
        }
        
        log.debug("Product found: {}", product);
        return product;
    }
}
```

### 4.2. Lombok @Slf4j

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
public class ProductService {
    
    public Product getProduct(Long id) {
        log.info("Fetching product: {}", id);
        return repository.findById(id).orElseThrow();
    }
}
```

### 4.3. Parameterized Logging

```java
// GOOD: Parameterized (lazy evaluation)
log.info("User {} logged in from {}", username, ipAddress);
log.debug("Order {} total: ${}", orderId, total);

// BAD: String concatenation (always evaluated)
log.info("User " + username + " logged in from " + ipAddress);
```

### 4.4. Exception Logging

```java
try {
    processOrder(order);
} catch (Exception e) {
    log.error("Failed to process order: {}", order.getId(), e);
}

// With custom message
catch (PaymentException e) {
    log.error("Payment failed for order {}: {}", orderId, e.getMessage(), e);
}
```

---

## 5. Logback Configuration

### 5.1. application.yml Configuration

```yaml
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  
  file:
    name: logs/application.log
    max-size: 10MB
    max-history: 30
    total-size-cap: 1GB
```

### 5.2. logback-spring.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy 
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- Async Appender for better performance -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <appender-ref ref="FILE" />
    </appender>
    
    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC_FILE" />
    </root>
    
    <!-- Package-specific loggers -->
    <logger name="com.example" level="DEBUG" />
    <logger name="org.springframework.web" level="DEBUG" />
    <logger name="org.hibernate.SQL" level="DEBUG" />
    
</configuration>
```

### 5.3. Profile-Specific Configuration

**logback-spring.xml with profiles:**

```xml
<configuration>
    
    <springProfile name="dev">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
            </encoder>
        </appender>
        
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/application.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="FILE" />
        </root>
    </springProfile>
    
</configuration>
```

---

## 6. Log4j 2

### 6.1. Dependencies

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

### 6.2. log4j2.xml Configuration

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    
    <Appenders>
        <!-- Console Appender -->
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        
        <!-- File Appender -->
        <RollingFile name="File" fileName="logs/application.log"
                     filePattern="logs/application-%d{yyyy-MM-dd}-%i.log">
            <PatternLayout>
                <Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n</Pattern>
            </PatternLayout>
            <Policies>
                <TimeBasedTriggeringPolicy />
                <SizeBasedTriggeringPolicy size="10 MB"/>
            </Policies>
            <DefaultRolloverStrategy max="30"/>
        </RollingFile>
        
        <!-- Async Appender -->
        <Async name="AsyncFile">
            <AppenderRef ref="File"/>
        </Async>
    </Appenders>
    
    <Loggers>
        <Logger name="com.example" level="debug" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="AsyncFile"/>
        </Logger>
        
        <Root level="info">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="AsyncFile"/>
        </Root>
    </Loggers>
    
</Configuration>
```

### 6.3. Async Logging

```xml
<!-- log4j2.xml -->
<Configuration>
    <Appenders>
        <Async name="AsyncConsole">
            <AppenderRef ref="Console"/>
        </Async>
    </Appenders>
    
    <Loggers>
        <AsyncRoot level="info">
            <AppenderRef ref="AsyncConsole"/>
        </AsyncRoot>
    </Loggers>
</Configuration>
```

---

## 7. Advanced Logback Features

### 7.1. Colored Console Output

```xml
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
        <pattern>%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
    </encoder>
</appender>
```

### 7.2. JSON Logging

**Dependencies:**
```xml
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>7.4</version>
</dependency>
```

**Configuration:**
```xml
<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/application.json</file>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <includeMdcKeyName>traceId</includeMdcKeyName>
        <includeMdcKeyName>spanId</includeMdcKeyName>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>logs/application-%d{yyyy-MM-dd}.json</fileNamePattern>
        <maxHistory>30</maxHistory>
    </rollingPolicy>
</appender>
```

### 7.3. Custom Appenders

```java
public class CustomAppender extends AppenderBase<ILoggingEvent> {
    
    @Override
    protected void append(ILoggingEvent event) {
        // Send to external service, database, etc.
        String message = event.getFormattedMessage();
        String level = event.getLevel().toString();
        
        externalService.log(level, message);
    }
}
```

---

## 8. Logging Patterns

### 8.1. Pattern Elements

| Pattern | Description | Example |
|---------|-------------|---------|
| `%d` | Date/time | `2024-12-22 10:30:45` |
| `%thread` | Thread name | `http-nio-8080-exec-1` |
| `%level` | Log level | `INFO` |
| `%logger` | Logger name | `com.example.ProductService` |
| `%msg` | Log message | `User logged in` |
| `%n` | Newline | |
| `%ex` | Exception | Stack trace |
| `%mdc` | MDC values | Trace ID |

### 8.2. Common Patterns

**Development:**
```
%d{HH:mm:ss.SSS} %highlight(%-5level) %cyan(%logger{36}) - %msg%n
```

**Production:**
```
%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
```

**JSON (for ELK):**
```json
{
  "timestamp": "2024-12-22T10:30:45.123Z",
  "level": "INFO",
  "thread": "http-nio-8080-exec-1",
  "logger": "com.example.ProductService",
  "message": "User logged in",
  "traceId": "abc123"
}
```

---

## 9. MDC (Mapped Diagnostic Context)

### 9.1. Adding Context

```java
import org.slf4j.MDC;

@Service
public class OrderService {
    
    public void processOrder(Order order) {
        // Add context
        MDC.put("orderId", order.getId().toString());
        MDC.put("userId", order.getUserId().toString());
        
        try {
            log.info("Processing order");
            // ... process order
            log.info("Order processed successfully");
        } finally {
            // Always clear MDC
            MDC.clear();
        }
    }
}
```

### 9.2. MDC Filter for Request Tracking

```java
@Component
public class RequestLoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        String requestId = UUID.randomUUID().toString();
        MDC.put("requestId", requestId);
        MDC.put("requestUri", request.getRequestURI());
        MDC.put("method", request.getMethod());
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
```

### 9.3. Include MDC in Logs

```xml
<pattern>%d{HH:mm:ss.SSS} [%thread] [%X{requestId}] %-5level %logger{36} - %msg%n</pattern>
```

Output:
```
10:30:45.123 [http-nio-8080-exec-1] [abc-123-def] INFO  c.e.ProductService - User logged in
```

---

## 10. Performance Considerations

### 10.1. Async Logging

```xml
<!-- Logback Async Appender -->
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <queueSize>512</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <neverBlock>false</neverBlock>
    <appender-ref ref="FILE" />
</appender>
```

### 10.2. Conditional Logging

```java
// BAD: Always evaluates expensive operation
log.debug("Complex calculation: " + expensiveCalculation());

// GOOD: Check level first
if (log.isDebugEnabled()) {
    log.debug("Complex calculation: {}", expensiveCalculation());
}

// BEST: Use parameterized logging (lazy evaluation)
log.debug("Complex calculation: {}", () -> expensiveCalculation());
```

### 10.3. Log Level Guards

```java
// For very expensive operations
if (log.isTraceEnabled()) {
    log.trace("Full object dump: {}", dumpAllData());
}
```

---

## 11. Best Practices

1. **Use appropriate log levels** - DEBUG for development, INFO/WARN/ERROR for production
2. **Use SLF4J facade** - Allows switching implementations
3. **Use parameterized logging** - Better performance
4. **Log exceptions properly** - Include exception as last parameter
5. **Add context with MDC** - Request ID, user ID, etc.
6. **Avoid logging sensitive data** - Passwords, tokens, PII
7. **Configure log rotation** - Prevent disk space issues
8. **Use async logging** - Better performance in production
9. **Structured logging** - JSON format for parsing
10. **Centralize logs** - Use ELK, Splunk, or cloud services

---

## 12. Interview Questions

**Q1: What is SLF4J?**
**A:** Simple Logging Facade for Java - abstraction over logging frameworks.

**Q2: Logback vs Log4j 2?**
**A:** Logback: Default in Spring Boot, native SLF4J. Log4j 2: Async support, good performance.

**Q3: What is MDC?**
**A:** Mapped Diagnostic Context - adds contextual information (request ID) to logs.

**Q4: How to log exceptions in SLF4J?**
**A:** Pass exception as last parameter: `log.error("Message", exception)`

**Q5: What is async logging?**
**A:** Logging in background thread to avoid blocking application.

**Q6: Why use parameterized logging?**
**A:** Performance - arguments only evaluated if log level enabled.

**Q7: What is log rotation?**
**A:** Automatically archiving old logs based on size/time to manage disk space.

**Q8: How to configure different log levels per package?**
**A:** In application.yml: `logging.level.com.example=DEBUG`

**Q9: What is the default logging framework in Spring Boot?**
**A:** Logback with SLF4J facade.

**Q10: How to switch from Logback to Log4j 2?**
**A:** Exclude spring-boot-starter-logging, add spring-boot-starter-log4j2.

**Q11: What is a logging appender?**
**A:** Destination for logs (console, file, database, external service).

**Q12: How to add custom fields to logs?**
**A:** Use MDC: `MDC.put("key", "value")`

**Q13: What is structured logging?**
**A:** Logging in parseable format (JSON) for analysis tools.

**Q14: How to avoid logging sensitive data?**
**A:** Filter/mask in custom appenders, avoid logging raw requests.

**Q15: What is the self-invocation problem in logging?**
**A:** Not applicable to logging - affects Spring proxies (@Transactional, @Cacheable).

**Q16: How to test logging?**
**A:** Use test appenders, verify log messages with Logback test utilities.

**Q17: What is log level hierarchy?**
**A:** TRACE < DEBUG < INFO < WARN < ERROR. Setting INFO logs INFO and above.

**Q18: How to log SQL queries in Spring Boot?**
**A:** `logging.level.org.hibernate.SQL=DEBUG`

**Q19: What is rolling file appender?**
**A:** Appender that creates new log files based on size/time.

**Q20: How to centralize logs in microservices?**
**A:** Use ELK stack, Splunk, CloudWatch, or Datadog with JSON logging.

---

## 13. Summary

Spring Boot uses SLF4J facade with Logback implementation by default. Configure logging via application.yml or logback-spring.xml. Use appropriate log levels (DEBUG for dev, INFO+ for prod). Add context with MDC. Use async logging for performance. Configure log rotation. Avoid logging sensitive data. Centralize logs in distributed systems.

---

**Next:** Logging Levels →
