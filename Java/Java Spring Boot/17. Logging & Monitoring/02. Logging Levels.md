# Logging Levels - Complete Guide

---

## 1. Introduction to Log Levels

Log levels categorize log messages by severity, allowing you to control what gets logged in different environments.

### Why Log Levels?
- **Control verbosity** - Different detail for dev vs production
- **Filter noise** - Focus on relevant information
- **Performance** - Reduce logging overhead
- **Debugging** - Enable detailed logs when needed
- **Alerting** - Trigger alerts on ERROR/FATAL

---

## 2. Standard Log Levels

### 2.1. Hierarchy

```
TRACE (Most detailed)
  ↓
DEBUG
  ↓
INFO
  ↓
WARN
  ↓
ERROR
  ↓
FATAL (Least detailed)
```

**Rule:** Setting level to INFO logs INFO, WARN, ERROR, FATAL (not DEBUG, TRACE)

### 2.2. Level Descriptions

| Level | Purpose | Examples | Production? |
|-------|---------|----------|-------------|
| **TRACE** | Very detailed debugging | Method entry/exit, variable values | ❌ No |
| **DEBUG** | Debugging information | SQL queries, business logic flow | ❌ Rarely |
| **INFO** | General information | Startup, shutdown, important events | ✅ Yes |
| **WARN** | Warning messages | Deprecated API usage, recoverable errors | ✅ Yes |
| **ERROR** | Error messages | Exceptions, failures | ✅ Yes |
| **FATAL** | Critical errors | System crashes (rarely used) | ✅ Yes |

---

## 3. TRACE Level

### 3.1. When to Use

- Method entry/exit points
- Loop iterations
- Variable values at each step
- Very detailed debugging

### 3.2. Examples

```java
@Slf4j
@Service
public class ProductService {
    
    public Product processProduct(Product product) {
        log.trace("Entering processProduct with: {}", product);
        
        log.trace("Validating product...");
        validate(product);
        
        log.trace("Calculating price...");
        BigDecimal price = calculatePrice(product);
        log.trace("Calculated price: {}", price);
        product.setPrice(price);
        
        log.trace("Saving product...");
        Product saved = repository.save(product);
        
        log.trace("Exiting processProduct with: {}", saved);
        return saved;
    }
}
```

### 3.3. Configuration

```yaml
logging:
  level:
    com.example.ProductService: TRACE
```

---

## 4. DEBUG Level

### 4.1. When to Use

- Business logic flow
- Method parameters and return values
- SQL queries
- Configuration values
- Integration points

### 4.2. Examples

```java
@Slf4j
@Service
public class OrderService {
    
    public Order createOrder(OrderRequest request) {
        log.debug("Creating order for user: {}", request.getUserId());
        log.debug("Order items: {}", request.getItems().size());
        
        // Validate
        if (request.getItems().isEmpty()) {
            log.debug("Order validation failed: no items");
            throw new ValidationException("No items in order");
        }
        
        // Calculate total
        BigDecimal total = calculateTotal(request.getItems());
        log.debug("Order total calculated: ${}", total);
        
        // Create order
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setTotal(total);
        
        Order saved = repository.save(order);
        log.debug("Order created with ID: {}", saved.getId());
        
        return saved;
    }
    
    public List<Order> getUserOrders(Long userId) {
        log.debug("Fetching orders for user: {}", userId);
        List<Order> orders = repository.findByUserId(userId);
        log.debug("Found {} orders for user {}", orders.size(), userId);
        return orders;
    }
}
```

### 4.3. SQL Debugging

```yaml
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

Output:
```sql
DEBUG o.h.SQL - select * from products where id=?
TRACE o.h.t.d.s.BasicBinder - binding parameter [1] as [BIGINT] - [123]
```

---

## 5. INFO Level

### 5.1. When to Use

- Application startup/shutdown
- Configuration loaded
- Important business events
- Scheduled jobs execution
- External service calls
- User actions (login, purchase)

### 5.2. Examples

```java
@Slf4j
@SpringBootApplication
public class Application {
    
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        log.info("Application started successfully");
    }
}

@Slf4j
@Service
public class PaymentService {
    
    public Payment processPayment(Order order) {
        log.info("Processing payment for order: {}", order.getId());
        
        Payment payment = paymentGateway.charge(order.getTotal());
        
        if (payment.isSuccessful()) {
            log.info("Payment successful for order: {}, amount: ${}", 
                order.getId(), order.getTotal());
        } else {
            log.warn("Payment failed for order: {}", order.getId());
        }
        
        return payment;
    }
}

@Slf4j
@Component
public class ScheduledTasks {
    
    @Scheduled(cron = "0 0 2 * * ?")
    public void dailyReport() {
        log.info("Starting daily report generation");
        
        Report report = generateReport();
        
        log.info("Daily report generated: {} records", report.getRecordCount());
    }
}
```

### 5.3. User Actions

```java
@Slf4j
@RestController
public class AuthController {
    
    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        log.info("User login attempt: {}", request.getUsername());
        
        Authentication auth = authService.authenticate(request);
        
        if (auth.isAuthenticated()) {
            log.info("User logged in successfully: {}", request.getUsername());
            return ResponseEntity.ok(auth.getToken());
        } else {
            log.warn("Failed login attempt: {}", request.getUsername());
            return ResponseEntity.status(401).build();
        }
    }
}
```

---

## 6. WARN Level

### 6.1. When to Use

- Recoverable errors
- Deprecated API usage
- Missing optional configuration
- Retry attempts
- Unexpected but handled situations
- Performance degradation

### 6.2. Examples

```java
@Slf4j
@Service
public class CacheService {
    
    public Product getProduct(Long id) {
        try {
            // Try cache first
            return cache.get(id);
        } catch (CacheException e) {
            log.warn("Cache unavailable, falling back to database: {}", e.getMessage());
            return repository.findById(id).orElseThrow();
        }
    }
}

@Slf4j
@Service
public class EmailService {
    
    public void sendEmail(String to, String subject, String body) {
        if (emailConfig.isEnabled()) {
            emailClient.send(to, subject, body);
            log.info("Email sent to: {}", to);
        } else {
            log.warn("Email service disabled, skipping email to: {}", to);
        }
    }
}

@Slf4j
@Service
public class RetryService {
    
    @Retryable(maxAttempts = 3)
    public void callExternalApi() {
        try {
            externalApi.call();
        } catch (TemporaryException e) {
            log.warn("External API call failed, will retry: {}", e.getMessage());
            throw e;
        }
    }
}
```

### 6.3. Deprecated Usage

```java
@Slf4j
@RestController
public class LegacyController {
    
    @GetMapping("/api/v1/products")
    @Deprecated
    public List<Product> getProductsV1() {
        log.warn("Deprecated API called: /api/v1/products. Use /api/v2/products instead");
        return productService.getAllProducts();
    }
}
```

---

## 7. ERROR Level

### 7.1. When to Use

- Exceptions
- Failed operations
- Data integrity issues
- External service failures
- Invalid states

### 7.2. Examples

```java
@Slf4j
@Service
public class OrderService {
    
    public Order createOrder(OrderRequest request) {
        try {
            return processOrder(request);
        } catch (PaymentException e) {
            log.error("Payment processing failed for order: {}", request, e);
            throw e;
        } catch (Exception e) {
            log.error("Unexpected error creating order: {}", request, e);
            throw new OrderCreationException("Failed to create order", e);
        }
    }
}

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        log.error("Unhandled exception", e);
        
        ErrorResponse error = new ErrorResponse(
            "Internal server error",
            e.getMessage()
        );
        
        return ResponseEntity.status(500).body(error);
    }
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException e) {
        log.error("Resource not found: {}", e.getMessage());
        
        return ResponseEntity.status(404)
            .body(new ErrorResponse("Not found", e.getMessage()));
    }
}
```

### 7.3. Data Issues

```java
@Slf4j
@Service
public class DataValidationService {
    
    public void validateAndProcess(Data data) {
        if (!isValid(data)) {
            log.error("Invalid data received: {}", data);
            throw new ValidationException("Data validation failed");
        }
        
        try {
            process(data);
        } catch (DataIntegrityException e) {
            log.error("Data integrity violation: {}", data, e);
            rollback();
            throw e;
        }
    }
}
```

---

## 8. Configuration Examples

### 8.1. Application Properties

```yaml
# Default level for all loggers
logging:
  level:
    root: INFO

# Package-specific levels
logging:
  level:
    com.example: DEBUG
    com.example.service: TRACE
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
```

### 8.2. Development Profile

```yaml
spring:
  profiles:
    active: dev

---
spring:
  config:
    activate:
      on-profile: dev

logging:
  level:
    root: DEBUG
    com.example: TRACE
    org.springframework: DEBUG
```

### 8.3. Production Profile

```yaml
spring:
  config:
    activate:
      on-profile: prod

logging:
  level:
    root: INFO
    com.example: INFO
    org.springframework: WARN
```

### 8.4. Logback Configuration

```xml
<configuration>
    
    <!-- Development -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE" />
        </root>
        
        <logger name="com.example" level="TRACE" />
    </springProfile>
    
    <!-- Production -->
    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE" />
        </root>
        
        <logger name="com.example" level="INFO" />
        <logger name="org.springframework" level="WARN" />
    </springProfile>
    
</configuration>
```

---

## 9. Best Practices by Environment

### 9.1. Development

```yaml
logging:
  level:
    root: DEBUG
    com.example: TRACE
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type: TRACE
```

**Benefits:**
- See all SQL queries
- Track request/response
- Debug business logic
- Find issues quickly

### 9.2. Staging

```yaml
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework: INFO
```

**Benefits:**
- Production-like environment
- Detailed app logs for testing
- Framework logs at normal level

### 9.3. Production

```yaml
logging:
  level:
    root: WARN
    com.example: INFO
    org.springframework: WARN
    org.hibernate: WARN
```

**Benefits:**
- Minimal overhead
- Focus on important events
- Reduce log volume
- Lower costs

---

## 10. Dynamic Log Level Changes

### 10.1. Using Actuator

**Enable in application.yml:**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: loggers
```

**Change level at runtime:**
```bash
# Get current level
curl http://localhost:8080/actuator/loggers/com.example.ProductService

# Set to DEBUG
curl -X POST http://localhost:8080/actuator/loggers/com.example.ProductService \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel":"DEBUG"}'

# Reset to default
curl -X POST http://localhost:8080/actuator/loggers/com.example.ProductService \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel":null}'
```

### 10.2. Programmatic Level Change

```java
@RestController
@RequestMapping("/admin/logging")
public class LogLevelController {
    
    @Autowired
    private LoggingSystem loggingSystem;
    
    @PostMapping("/level")
    public void setLogLevel(@RequestParam String logger, 
                           @RequestParam String level) {
        loggingSystem.setLogLevel(logger, LogLevel.valueOf(level));
    }
}
```

---

## 11. Conditional Logging

### 11.1. Check Before Logging

```java
// For expensive operations
if (log.isDebugEnabled()) {
    log.debug("Complex data: {}", buildComplexObject());
}

if (log.isTraceEnabled()) {
    log.trace("Full state dump: {}", dumpFullState());
}
```

### 11.2. Lambda Logging (Java 8+)

```java
// Lazy evaluation
log.debug("Result: {}", () -> expensiveCalculation());
```

---

## 12. Common Patterns

### 12.1. Controller Logging

```java
@Slf4j
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable Long id) {
        log.info("GET /api/products/{}", id);
        
        Product product = productService.getProduct(id);
        
        log.debug("Product found: {}", product);
        return product;
    }
    
    @PostMapping
    public Product createProduct(@RequestBody @Valid ProductRequest request) {
        log.info("POST /api/products: {}", request.getName());
        
        Product created = productService.createProduct(request);
        
        log.info("Product created with ID: {}", created.getId());
        return created;
    }
}
```

### 12.2. Service Logging

```java
@Slf4j
@Service
public class ProductService {
    
    public Product getProduct(Long id) {
        log.debug("Fetching product: {}", id);
        
        return repository.findById(id)
            .orElseThrow(() -> {
                log.error("Product not found: {}", id);
                return new ProductNotFoundException(id);
            });
    }
    
    @Transactional
    public Product updateProduct(Long id, ProductRequest request) {
        log.info("Updating product: {}", id);
        
        Product product = getProduct(id);
        product.setName(request.getName());
        product.setPrice(request.getPrice());
        
        Product updated = repository.save(product);
        log.info("Product updated: {}", id);
        
        return updated;
    }
}
```

### 12.3. Repository Logging

```java
@Slf4j
@Repository
public class CustomProductRepository {
    
    public List<Product> findExpensiveProducts(BigDecimal minPrice) {
        log.debug("Executing custom query: minPrice={}", minPrice);
        
        List<Product> results = jdbcTemplate.query(
            "SELECT * FROM products WHERE price >= ?",
            new Object[]{minPrice},
            productRowMapper
        );
        
        log.debug("Query returned {} results", results.size());
        return results;
    }
}
```

---

## 13. Performance Impact

### 13.1. Log Level Overhead

| Level | Overhead | Use Case |
|-------|----------|----------|
| TRACE | Highest | Development only |
| DEBUG | High | Development, troubleshooting |
| INFO | Low | Production |
| WARN | Very Low | Production |
| ERROR | Minimal | Production |

### 13.2. Recommendations

```java
// BAD: Always creates string even if DEBUG disabled
log.debug("User: " + user.toString());

// GOOD: Parameterized (only evaluates if DEBUG enabled)
log.debug("User: {}", user);

// BEST: For very expensive operations
if (log.isDebugEnabled()) {
    log.debug("Full dump: {}", expensiveDump());
}
```

---

## 14. Interview Questions

**Q1: What are the standard log levels?**
**A:** TRACE, DEBUG, INFO, WARN, ERROR, FATAL (in order of increasing severity).

**Q2: What level should be used in production?**
**A:** INFO or WARN to minimize overhead and log volume.

**Q3: When to use DEBUG vs TRACE?**
**A:** DEBUG: General debugging. TRACE: Very detailed (method entry/exit, loop iterations).

**Q4: What happens when you set log level to INFO?**
**A:** Logs INFO, WARN, ERROR, FATAL. Suppresses DEBUG and TRACE.

**Q5: How to change log level at runtime?**
**A:** Use Spring Boot Actuator /actuator/loggers endpoint.

**Q6: When to use WARN level?**
**A:** Recoverable errors, deprecated usage, unexpected but handled situations.

**Q7: Should you log at INFO for every method call?**
**A:** No, only for significant events. Use DEBUG for detailed flow.

**Q8: How to log SQL queries?**
**A:** Set `logging.level.org.hibernate.SQL=DEBUG`

**Q9: What is the performance impact of TRACE logging?**
**A:** High - generates large volume of logs. Use only in development.

**Q10: How to conditionally log expensive operations?**
**A:** Check level first: `if (log.isDebugEnabled()) { log.debug(...) }`

**Q11: What level for exceptions?**
**A:** ERROR for exceptions, WARN for recoverable errors.

**Q12: Can you have different levels per package?**
**A:** Yes, configure in application.yml: `logging.level.com.example=DEBUG`

**Q13: What is the default log level in Spring Boot?**
**A:** INFO for root logger.

**Q14: When to use FATAL level?**
**A:** Rarely - for critical errors that crash the application.

**Q15: How to enable debug logging temporarily?**
**A:** Use Actuator to change level at runtime without restart.

**Q16: Should you log at ERROR and throw exception?**
**A:** Usually log at lower level in service, ERROR in exception handler.

**Q17: What level for user login events?**
**A:** INFO for successful login, WARN for failed attempts.

**Q18: How to reduce log volume in production?**
**A:** Set root level to WARN, application packages to INFO.

**Q19: What is log level hierarchy?**
**A:** Setting a level logs that level and all higher severity levels.

**Q20: How to configure different levels for dev vs prod?**
**A:** Use Spring profiles with profile-specific configuration.

---

## 15. Summary

Log levels control verbosity: TRACE (most detailed) to FATAL (least). Use DEBUG/TRACE in development, INFO/WARN/ERROR in production. Configure per package in application.yml. Change levels at runtime with Actuator. Use appropriate levels: INFO for important events, ERROR for exceptions, WARN for recoverable issues. Minimize overhead by avoiding excessive DEBUG/TRACE in production.

---

**Next:** Custom Logging →
