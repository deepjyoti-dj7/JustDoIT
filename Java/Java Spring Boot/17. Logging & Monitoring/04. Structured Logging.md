# Structured Logging - Complete Guide

---

## 1. Introduction to Structured Logging

Structured logging formats log entries as structured data (JSON, key-value pairs) instead of plain text, making logs machine-readable and easier to search, analyze, and monitor.

### Benefits
- **Machine-readable** - Easy parsing by log aggregators
- **Better search** - Query specific fields
- **Context-rich** - Include metadata (user ID, request ID, etc.)
- **Analytics** - Aggregate and analyze patterns
- **ELK/Splunk ready** - Works with log analysis tools

### Plain Text vs Structured

**Plain Text:**
```
2024-12-22 10:30:45 INFO User john logged in from 192.168.1.100
```

**Structured (JSON):**
```json
{
  "timestamp": "2024-12-22T10:30:45.123Z",
  "level": "INFO",
  "message": "User logged in",
  "username": "john",
  "ipAddress": "192.168.1.100",
  "action": "login"
}
```

---

## 2. Logstash Logback Encoder

### 2.1. Dependencies

```xml
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>7.4</version>
</dependency>
```

### 2.2. Basic Configuration

```xml
<!-- logback-spring.xml -->
<configuration>
    
    <appender name="JSON_CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyName>traceId</includeMdcKeyName>
            <includeMdcKeyName>spanId</includeMdcKeyName>
            <includeMdcKeyName>userId</includeMdcKeyName>
        </encoder>
    </appender>
    
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.json</file>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder"/>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.json</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="JSON_CONSOLE" />
        <appender-ref ref="JSON_FILE" />
    </root>
    
</configuration>
```

### 2.3. Output Example

```json
{
  "@timestamp": "2024-12-22T10:30:45.123+00:00",
  "@version": "1",
  "message": "User logged in successfully",
  "logger_name": "com.example.UserService",
  "thread_name": "http-nio-8080-exec-1",
  "level": "INFO",
  "level_value": 20000,
  "traceId": "abc-123-def",
  "spanId": "456-ghi",
  "userId": "john"
}
```

---

## 3. Custom JSON Fields

### 3.1. Static Fields

```xml
<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/application.json</file>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <customFields>{"application":"my-app","environment":"production"}</customFields>
    </encoder>
</appender>
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "User logged in",
  "application": "my-app",
  "environment": "production"
}
```

### 3.2. Dynamic Fields with MDC

```java
@Service
@Slf4j
public class UserService {
    
    public void login(String username) {
        MDC.put("userId", username);
        MDC.put("action", "login");
        MDC.put("ipAddress", getClientIp());
        
        log.info("User logged in successfully");
        
        MDC.clear();
    }
}
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "User logged in successfully",
  "userId": "john",
  "action": "login",
  "ipAddress": "192.168.1.100"
}
```

---

## 4. Structured Logging Markers

### 4.1. Using SLF4J Markers

```java
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

@Service
@Slf4j
public class OrderService {
    
    private static final Marker ORDER_MARKER = MarkerFactory.getMarker("ORDER");
    private static final Marker PAYMENT_MARKER = MarkerFactory.getMarker("PAYMENT");
    
    public void createOrder(Order order) {
        log.info(ORDER_MARKER, "Order created: {}", order.getId());
    }
    
    public void processPayment(Payment payment) {
        log.info(PAYMENT_MARKER, "Payment processed: {}", payment.getId());
    }
}
```

### 4.2. Marker Configuration

```xml
<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <includeMarkers>true</includeMarkers>
    </encoder>
</appender>
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "Order created: 12345",
  "markers": ["ORDER"]
}
```

---

## 5. Structured Arguments

### 5.1. StructuredArguments

```java
import static net.logstash.logback.argument.StructuredArguments.*;

@Service
@Slf4j
public class ProductService {
    
    public Product getProduct(Long id) {
        Product product = repository.findById(id).orElseThrow();
        
        log.info("Product fetched",
            keyValue("productId", id),
            keyValue("productName", product.getName()),
            keyValue("price", product.getPrice())
        );
        
        return product;
    }
    
    public void createOrder(Order order) {
        log.info("Order created",
            value("orderId", order.getId()),
            value("userId", order.getUserId()),
            value("total", order.getTotal()),
            value("items", order.getItems().size())
        );
    }
}
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "Product fetched",
  "productId": 123,
  "productName": "Laptop",
  "price": 999.99
}
```

### 5.2. Nested Objects

```java
import static net.logstash.logback.argument.StructuredArguments.*;

@Service
@Slf4j
public class OrderService {
    
    public void processOrder(Order order) {
        Map<String, Object> orderData = new HashMap<>();
        orderData.put("orderId", order.getId());
        orderData.put("total", order.getTotal());
        orderData.put("itemCount", order.getItems().size());
        
        Map<String, Object> userData = new HashMap<>();
        userData.put("userId", order.getUser().getId());
        userData.put("email", order.getUser().getEmail());
        
        log.info("Processing order",
            entries(orderData),
            keyValue("user", userData)
        );
    }
}
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "Processing order",
  "orderId": 123,
  "total": 299.99,
  "itemCount": 3,
  "user": {
    "userId": 456,
    "email": "john@example.com"
  }
}
```

---

## 6. Exception Logging

### 6.1. Structured Exception Handling

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e,
                                                         HttpServletRequest request) {
        
        Map<String, Object> errorData = new HashMap<>();
        errorData.put("errorType", e.getClass().getSimpleName());
        errorData.put("errorMessage", e.getMessage());
        errorData.put("requestUri", request.getRequestURI());
        errorData.put("method", request.getMethod());
        
        log.error("Unhandled exception",
            entries(errorData),
            keyValue("exception", e.getMessage()),
            e  // Include stack trace
        );
        
        return ResponseEntity.status(500)
            .body(new ErrorResponse("Internal server error"));
    }
}
```

### 6.2. Custom Exception Fields

```xml
<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <throwableConverter class="net.logstash.logback.stacktrace.ShortenedThrowableConverter">
            <maxDepthPerThrowable>30</maxDepthPerThrowable>
            <maxLength>2048</maxLength>
            <shortenedClassNameLength>20</shortenedClassNameLength>
            <excludes>sun\.reflect\..*</excludes>
            <rootCauseFirst>true</rootCauseFirst>
        </throwableConverter>
    </encoder>
</appender>
```

---

## 7. Request/Response Logging

### 7.1. Structured HTTP Logging

```java
@Component
@Slf4j
public class StructuredLoggingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        long startTime = System.currentTimeMillis();
        String requestId = UUID.randomUUID().toString();
        
        MDC.put("requestId", requestId);
        MDC.put("method", request.getMethod());
        MDC.put("uri", request.getRequestURI());
        MDC.put("clientIp", request.getRemoteAddr());
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            
            log.info("HTTP request completed",
                keyValue("requestId", requestId),
                keyValue("method", request.getMethod()),
                keyValue("uri", request.getRequestURI()),
                keyValue("status", response.getStatus()),
                keyValue("duration", duration),
                keyValue("clientIp", request.getRemoteAddr())
            );
            
            MDC.clear();
        }
    }
}
```

Output:
```json
{
  "@timestamp": "2024-12-22T10:30:45.123Z",
  "message": "HTTP request completed",
  "requestId": "abc-123-def",
  "method": "POST",
  "uri": "/api/products",
  "status": 201,
  "duration": 150,
  "clientIp": "192.168.1.100"
}
```

---

## 8. Performance Metrics

### 8.1. Method Performance Logging

```java
@Aspect
@Component
@Slf4j
public class PerformanceLoggingAspect {
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping)")
    public Object logPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        String methodName = joinPoint.getSignature().toShortString();
        Object[] args = joinPoint.getArgs();
        
        try {
            Object result = joinPoint.proceed();
            stopWatch.stop();
            
            log.info("Method execution completed",
                keyValue("method", methodName),
                keyValue("executionTime", stopWatch.getTotalTimeMillis()),
                keyValue("status", "success")
            );
            
            return result;
        } catch (Throwable t) {
            stopWatch.stop();
            
            log.error("Method execution failed",
                keyValue("method", methodName),
                keyValue("executionTime", stopWatch.getTotalTimeMillis()),
                keyValue("status", "failed"),
                keyValue("errorType", t.getClass().getSimpleName()),
                t
            );
            
            throw t;
        }
    }
}
```

---

## 9. Database Query Logging

### 9.1. Structured SQL Logging

```java
@Component
@Slf4j
public class QueryLoggingListener {
    
    @EventListener
    public void onQueryExecution(QueryExecutionEvent event) {
        log.debug("SQL query executed",
            keyValue("query", event.getSql()),
            keyValue("duration", event.getDuration()),
            keyValue("rowCount", event.getRowCount()),
            keyValue("success", event.isSuccess())
        );
    }
}
```

### 9.2. Hibernate Statistics

```yaml
spring:
  jpa:
    properties:
      hibernate:
        generate_statistics: true

logging:
  level:
    org.hibernate.stat: DEBUG
```

```java
@Component
@Slf4j
public class HibernateStatsLogger {
    
    @Autowired
    private EntityManagerFactory entityManagerFactory;
    
    @Scheduled(fixedRate = 60000)
    public void logStatistics() {
        Statistics stats = entityManagerFactory.unwrap(SessionFactory.class)
            .getStatistics();
        
        log.info("Hibernate statistics",
            keyValue("queryExecutionCount", stats.getQueryExecutionCount()),
            keyValue("queryCacheHitCount", stats.getQueryCacheHitCount()),
            keyValue("queryCacheMissCount", stats.getQueryCacheMissCount()),
            keyValue("sessionOpenCount", stats.getSessionOpenCount()),
            keyValue("sessionCloseCount", stats.getSessionCloseCount())
        );
    }
}
```

---

## 10. Correlation and Tracing

### 10.1. Distributed Tracing

```java
@Component
public class TracingFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) 
            throws ServletException, IOException {
        
        String traceId = request.getHeader("X-Trace-ID");
        if (traceId == null) {
            traceId = UUID.randomUUID().toString();
        }
        
        String spanId = UUID.randomUUID().toString();
        
        MDC.put("traceId", traceId);
        MDC.put("spanId", spanId);
        
        response.setHeader("X-Trace-ID", traceId);
        response.setHeader("X-Span-ID", spanId);
        
        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.remove("traceId");
            MDC.remove("spanId");
        }
    }
}
```

---

## 11. ELK Stack Integration

### 11.1. Logstash Pipeline

```ruby
# logstash.conf
input {
  file {
    path => "/var/log/application/*.json"
    codec => "json"
  }
}

filter {
  # Add geolocation
  geoip {
    source => "clientIp"
    target => "geoip"
  }
  
  # Parse timestamp
  date {
    match => ["@timestamp", "ISO8601"]
    target => "@timestamp"
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "application-logs-%{+YYYY.MM.dd}"
  }
}
```

### 11.2. Elasticsearch Mapping

```json
{
  "mappings": {
    "properties": {
      "@timestamp": { "type": "date" },
      "level": { "type": "keyword" },
      "message": { "type": "text" },
      "logger_name": { "type": "keyword" },
      "thread_name": { "type": "keyword" },
      "userId": { "type": "keyword" },
      "requestId": { "type": "keyword" },
      "duration": { "type": "long" },
      "status": { "type": "integer" }
    }
  }
}
```

---

## 12. Best Practices

1. **Use consistent field names** - Standardize across services
2. **Include context** - User ID, request ID, trace ID
3. **Log at appropriate levels** - DEBUG for details, INFO for events
4. **Avoid sensitive data** - Don't log passwords, tokens
5. **Use structured arguments** - keyValue(), entries()
6. **Include metrics** - Duration, count, status
7. **Timestamp in ISO 8601** - Universal format
8. **Keep JSON flat when possible** - Easier querying
9. **Use markers for categorization** - Business domains
10. **Monitor log volume** - Prevent excessive logging

---

## 13. Interview Questions

**Q1: What is structured logging?**
**A:** Logging in machine-readable format (JSON) instead of plain text.

**Q2: Why use structured logging?**
**A:** Better search, analytics, parsing, and integration with ELK/Splunk.

**Q3: What is logstash-logback-encoder?**
**A:** Library for JSON logging in Spring Boot with Logback.

**Q4: How to add custom fields to JSON logs?**
**A:** Use MDC, StructuredArguments, or customFields in encoder config.

**Q5: What is StructuredArguments?**
**A:** Helper class for adding key-value pairs to log entries.

**Q6: How to log nested objects?**
**A:** Use keyValue() with Map or object, or entries() method.

**Q7: What is the ELK stack?**
**A:** Elasticsearch (storage), Logstash (processing), Kibana (visualization).

**Q8: How to include trace ID in logs?**
**A:** Add trace ID to MDC in filter/interceptor.

**Q9: How to configure JSON console output?**
**A:** Use LogstashEncoder with ConsoleAppender in logback-spring.xml.

**Q10: What is a marker in SLF4J?**
**A:** Tag for categorizing log entries (ORDER, PAYMENT, etc.).

**Q11: How to log exceptions structurally?**
**A:** Use StructuredArguments with exception details as key-value pairs.

**Q12: Should you log request body in production?**
**A:** No, only metadata (method, URI, status, duration). Avoid PII.

**Q13: How to reduce JSON log size?**
**A:** Exclude unnecessary fields, shorten stack traces, use compression.

**Q14: What is @timestamp in logs?**
**A:** ISO 8601 timestamp field for log entry creation time.

**Q15: How to query JSON logs?**
**A:** Use jq (command-line), Kibana, or Elasticsearch queries.

**Q16: What is the difference between MDC and StructuredArguments?**
**A:** MDC: Thread-scoped context for all logs. StructuredArguments: Per-log-entry fields.

**Q17: How to test structured logging?**
**A:** Parse JSON output, verify fields present and correct.

**Q18: What is log aggregation?**
**A:** Collecting logs from multiple sources into centralized system.

**Q19: How to include method name in JSON logs?**
**A:** Use %method pattern or add as custom field with AOP.

**Q20: What is the benefit of correlation IDs?**
**A:** Track request across multiple services in distributed systems.

---

## 14. Summary

Structured logging formats logs as JSON for machine readability. Use logstash-logback-encoder for JSON output. Add context with MDC and StructuredArguments. Include metadata (request ID, user ID, duration, status). Integrate with ELK stack for analysis. Avoid logging sensitive data. Use consistent field names across services. Enable better search, analytics, and monitoring.

---

**Next:** Centralized Logging â†’
