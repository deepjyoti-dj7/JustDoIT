# Distributed Tracing - Complete Guide

---

## 1. Introduction to Distributed Tracing

Distributed tracing tracks requests as they flow through multiple services in a microservices architecture.

### Why Distributed Tracing?

In monolithic applications, debugging is straightforward - follow the stack trace. In microservices:

- Request flows through multiple services
- Each service has its own logs
- Finding root cause is difficult
- Performance bottlenecks are hard to identify

### Key Concepts

**Trace**: Complete journey of a request through all services  
**Span**: Single unit of work (method call, database query, HTTP request)  
**Trace ID**: Unique identifier for entire trace  
**Span ID**: Unique identifier for each span  
**Parent Span ID**: Links spans in hierarchy

### Trace Structure

```
Trace (ID: abc-123)
├── Span: API Gateway (ID: span-1, Parent: null)
│   ├── Span: Auth Service (ID: span-2, Parent: span-1)
│   ├── Span: Product Service (ID: span-3, Parent: span-1)
│   │   ├── Span: Database Query (ID: span-4, Parent: span-3)
│   │   └── Span: Cache Lookup (ID: span-5, Parent: span-3)
│   └── Span: Order Service (ID: span-6, Parent: span-1)
```

---

## 2. Popular Tracing Systems

### Comparison

| Feature | Zipkin | Jaeger | OpenTelemetry | Spring Cloud Sleuth |
|---------|--------|--------|---------------|---------------------|
| **Type** | Complete system | Complete system | Instrumentation only | Spring integration |
| **Backend** | Own UI | Own UI | Pluggable | Requires Zipkin/Jaeger |
| **Complexity** | Simple | Medium | Medium | Simple (Spring) |
| **Sampling** | Yes | Yes | Yes | Yes |
| **Storage** | Elasticsearch, Cassandra, MySQL | Elasticsearch, Cassandra, Badger | N/A | N/A |
| **Best For** | Simplicity | Production | Vendor neutrality | Spring apps |

---

## 3. Spring Cloud Sleuth

### 3.1. Dependencies

```xml
<!-- Spring Cloud Sleuth -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>

<!-- Zipkin integration (optional) -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>
```

### 3.2. Configuration

```yaml
spring:
  application:
    name: product-service
  
  sleuth:
    sampler:
      probability: 1.0  # 100% sampling (reduce in production)
    
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web  # or kafka, rabbit
```

### 3.3. Automatic Instrumentation

Sleuth automatically adds trace and span IDs to:

- Logging (MDC)
- HTTP requests/responses
- Messaging (Kafka, RabbitMQ)
- Async operations
- Scheduled tasks

**Log Output:**
```
2024-01-15 10:30:45.123 INFO [product-service,a1b2c3d4e5f6g7h8,i9j0k1l2m3n4o5p6,true] ...
                                 [app-name,       traceId,        spanId,       exportable]
```

### 3.4. Custom Spans

```java
import org.springframework.cloud.sleuth.Span;
import org.springframework.cloud.sleuth.Tracer;

@Service
@RequiredArgsConstructor
public class OrderService {
    
    private final Tracer tracer;
    
    public Order processOrder(OrderRequest request) {
        // Create custom span
        Span span = tracer.nextSpan().name("processOrder").start();
        
        try (Tracer.SpanInScope ws = tracer.withSpan(span)) {
            // Add tags
            span.tag("order.id", request.getId().toString());
            span.tag("order.total", request.getTotal().toString());
            span.tag("user.id", request.getUserId());
            
            // Add event
            span.event("Order validation started");
            
            Order order = createOrder(request);
            
            span.event("Order created successfully");
            
            return order;
            
        } catch (Exception e) {
            span.tag("error", "true");
            span.tag("error.message", e.getMessage());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

### 3.5. Baggage Propagation

```java
import org.springframework.cloud.sleuth.BaggageField;
import org.springframework.cloud.sleuth.Tracer;

@Service
@RequiredArgsConstructor
public class BaggageExample {
    
    private final Tracer tracer;
    private static final BaggageField USER_ID = BaggageField.create("userId");
    private static final BaggageField TENANT_ID = BaggageField.create("tenantId");
    
    public void processRequest(String userId, String tenantId) {
        // Set baggage - propagates to all downstream services
        USER_ID.updateValue(userId);
        TENANT_ID.updateValue(tenantId);
        
        // Baggage is available in all spans
        callDownstreamService();
    }
    
    public void callDownstreamService() {
        // Retrieve baggage
        String userId = USER_ID.get();
        String tenantId = TENANT_ID.get();
        
        log.info("Processing request for user: {}, tenant: {}", userId, tenantId);
    }
}
```

---

## 4. Zipkin

### 4.1. Running Zipkin Server

**Docker:**
```bash
docker run -d -p 9411:9411 openzipkin/zipkin
```

**Access UI:**
```
http://localhost:9411
```

### 4.2. Spring Boot Integration

**application.yml:**
```yaml
spring:
  zipkin:
    base-url: http://zipkin-server:9411
    sender:
      type: web  # Options: web, kafka, rabbit, activemq
    
  sleuth:
    sampler:
      probability: 0.1  # 10% sampling for production
```

### 4.3. Kafka Transport

**Dependencies:**
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-zipkin</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
```

**Configuration:**
```yaml
spring:
  zipkin:
    sender:
      type: kafka
  kafka:
    bootstrap-servers: localhost:9092
```

---

## 5. Jaeger

### 5.1. Running Jaeger

**Docker All-in-One:**
```bash
docker run -d --name jaeger \
  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \
  -p 5775:5775/udp \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 14250:14250 \
  -p 14268:14268 \
  -p 14269:14269 \
  -p 9411:9411 \
  jaegertracing/all-in-one:latest
```

**Access UI:**
```
http://localhost:16686
```

### 5.2. Spring Boot Integration

**Dependencies:**
```xml
<dependency>
    <groupId>io.opentracing.contrib</groupId>
    <artifactId>opentracing-spring-jaeger-cloud-starter</artifactId>
    <version>3.3.1</version>
</dependency>
```

**Configuration:**
```yaml
opentracing:
  jaeger:
    service-name: ${spring.application.name}
    udp-sender:
      host: localhost
      port: 6831
    probabilistic-sampler:
      sampling-rate: 1.0
    log-spans: true
```

### 5.3. Custom Instrumentation

```java
import io.opentracing.Span;
import io.opentracing.Tracer;

@Service
@RequiredArgsConstructor
public class ProductService {
    
    private final Tracer tracer;
    
    public Product findById(Long id) {
        Span span = tracer.buildSpan("findProduct")
                .withTag("product.id", id.toString())
                .start();
        
        try (Scope scope = tracer.activateSpan(span)) {
            span.log("Querying database for product");
            
            Product product = productRepository.findById(id)
                    .orElseThrow(() -> new ProductNotFoundException(id));
            
            span.setTag("product.name", product.getName());
            span.setTag("product.price", product.getPrice().toString());
            
            return product;
            
        } catch (Exception e) {
            span.setTag("error", true);
            span.log(Map.of("event", "error", "message", e.getMessage()));
            throw e;
        } finally {
            span.finish();
        }
    }
}
```

---

## 6. OpenTelemetry

### 6.1. Introduction

OpenTelemetry is vendor-neutral, open-source observability framework supporting:

- **Traces** - Distributed tracing
- **Metrics** - Performance metrics
- **Logs** - Structured logging

### 6.2. Dependencies

```xml
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api</artifactId>
    <version>1.32.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk</artifactId>
    <version>1.32.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-jaeger</artifactId>
    <version>1.32.0</version>
</dependency>
```

### 6.3. Configuration

```java
import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.exporter.jaeger.JaegerGrpcSpanExporter;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.trace.SdkTracerProvider;
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;

@Configuration
public class OpenTelemetryConfig {
    
    @Bean
    public OpenTelemetry openTelemetry() {
        JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.builder()
                .setEndpoint("http://localhost:14250")
                .build();
        
        SdkTracerProvider sdkTracerProvider = SdkTracerProvider.builder()
                .addSpanProcessor(BatchSpanProcessor.builder(jaegerExporter).build())
                .build();
        
        return OpenTelemetrySdk.builder()
                .setTracerProvider(sdkTracerProvider)
                .buildAndRegisterGlobal();
    }
    
    @Bean
    public Tracer tracer(OpenTelemetry openTelemetry) {
        return openTelemetry.getTracer("product-service", "1.0.0");
    }
}
```

### 6.4. Creating Spans

```java
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;

@Service
@RequiredArgsConstructor
public class PaymentService {
    
    private final Tracer tracer;
    
    public Payment processPayment(PaymentRequest request) {
        Span span = tracer.spanBuilder("processPayment")
                .setAttribute("payment.amount", request.getAmount())
                .setAttribute("payment.currency", request.getCurrency())
                .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            // Create child span for validation
            Span validationSpan = tracer.spanBuilder("validatePayment")
                    .startSpan();
            try (Scope validationScope = validationSpan.makeCurrent()) {
                validatePayment(request);
            } finally {
                validationSpan.end();
            }
            
            // Create child span for processing
            Span processingSpan = tracer.spanBuilder("chargeCard")
                    .startSpan();
            try (Scope processingScope = processingSpan.makeCurrent()) {
                Payment payment = chargeCard(request);
                span.setAttribute("payment.id", payment.getId());
                return payment;
            } finally {
                processingSpan.end();
            }
            
        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR, e.getMessage());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

---

## 7. Context Propagation

### 7.1. HTTP Headers

**W3C Trace Context (Standard):**
```
traceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01
             version-trace_id-parent_id-trace_flags
```

**B3 Propagation (Zipkin):**
```
X-B3-TraceId: 0af7651916cd43dd8448eb211c80319c
X-B3-SpanId: b7ad6b7169203331
X-B3-ParentSpanId: 05e3ac9a4f6e3b90
X-B3-Sampled: 1
```

### 7.2. RestTemplate Integration

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
                .interceptors(new TracingClientHttpRequestInterceptor())
                .build();
    }
}

@Component
@RequiredArgsConstructor
public class TracingClientHttpRequestInterceptor implements ClientHttpRequestInterceptor {
    
    private final Tracer tracer;
    
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        
        Span currentSpan = tracer.currentSpan();
        if (currentSpan != null) {
            // Inject trace context into headers
            request.getHeaders().set("X-B3-TraceId", currentSpan.context().traceId());
            request.getHeaders().set("X-B3-SpanId", currentSpan.context().spanId());
        }
        
        return execution.execute(request, body);
    }
}
```

### 7.3. Kafka Integration

```java
@Configuration
@EnableKafka
public class KafkaConfig {
    
    @Bean
    public ProducerFactory<String, String> producerFactory() {
        Map<String, Object> config = new HashMap<>();
        config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        
        return new DefaultKafkaProducerFactory<>(config);
    }
    
    @Bean
    public KafkaTemplate<String, String> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}

@Service
@RequiredArgsConstructor
public class MessageProducer {
    
    private final KafkaTemplate<String, String> kafkaTemplate;
    private final Tracer tracer;
    
    public void sendMessage(String topic, String message) {
        Span span = tracer.nextSpan().name("kafka-send").start();
        
        try (Tracer.SpanInScope ws = tracer.withSpan(span)) {
            span.tag("kafka.topic", topic);
            
            // Sleuth automatically propagates trace context
            kafkaTemplate.send(topic, message);
            
        } finally {
            span.end();
        }
    }
}
```

---

## 8. Sampling Strategies

### 8.1. Probability Sampling

```yaml
spring:
  sleuth:
    sampler:
      probability: 0.1  # Sample 10% of requests
```

### 8.2. Rate Limiting Sampling

```java
@Configuration
public class SamplingConfig {
    
    @Bean
    public Sampler rateLimitingSampler() {
        return new RateLimitingSampler(100);  // Max 100 traces per second
    }
}
```

### 8.3. Custom Sampling

```java
@Component
public class CustomSampler extends Sampler {
    
    @Override
    public SamplingResult getSamplingResult(TraceContext context, String operationName) {
        // Always sample errors
        if (operationName.contains("error")) {
            return SamplingResult.create(true);
        }
        
        // Sample 100% of payment operations
        if (operationName.startsWith("payment")) {
            return SamplingResult.create(true);
        }
        
        // Sample 1% of other operations
        return SamplingResult.create(Math.random() < 0.01);
    }
}
```

---

## 9. Service Mesh Integration

### 9.1. Istio with Jaeger

Istio automatically propagates trace context and sends spans to Jaeger.

**Enable tracing:**
```yaml
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    enableTracing: true
    defaultConfig:
      tracing:
        sampling: 100.0
        zipkin:
          address: jaeger-collector.istio-system:9411
```

**Application annotation:**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: "true"
```

---

## 10. Visualization and Analysis

### 10.1. Zipkin UI Features

- **Trace search** - Find traces by service, time, tags
- **Dependency graph** - Visualize service dependencies
- **Trace timeline** - See span hierarchy and timing
- **Service latency** - Analyze service performance

### 10.2. Jaeger UI Features

- **Trace comparison** - Compare multiple traces
- **Service dependencies** - Automatic dependency discovery
- **Trace search** - Advanced filtering
- **System architecture** - Visualize entire architecture

### 10.3. Query Examples

**Find slow requests:**
```
duration > 1s
```

**Find errors:**
```
error=true
```

**Find by service:**
```
service="product-service"
```

**Find by tag:**
```
http.status_code=500
```

---

## 11. Best Practices

### 11.1. Span Naming

```java
// Good - describes operation
span.name("getUserById");
span.name("database.query.select");
span.name("http.request.get");

// Bad - not descriptive
span.name("process");
span.name("method1");
span.name("execute");
```

### 11.2. Tag Usage

```java
// Add meaningful tags
span.tag("user.id", userId);
span.tag("order.total", order.getTotal().toString());
span.tag("db.statement", sql);
span.tag("http.status_code", "200");

// Avoid high-cardinality tags
span.tag("timestamp", System.currentTimeMillis());  // Bad
span.tag("unique.id", UUID.randomUUID().toString());  // Bad
```

### 11.3. Sampling

- Use lower sampling in production (1-10%)
- Sample 100% of errors
- Use rate limiting to control volume
- Sample high-value transactions at higher rate

### 11.4. Performance

- Use async reporting
- Batch span exports
- Configure appropriate buffer sizes
- Monitor tracing overhead

---

## 12. Interview Questions

**Q1: What is distributed tracing?**
**A:** Tracking requests as they flow through multiple services in microservices architecture.

**Q2: What is a trace?**
**A:** Complete journey of a request through all services.

**Q3: What is a span?**
**A:** Single unit of work (method call, database query, HTTP request).

**Q4: What is trace ID?**
**A:** Unique identifier for entire trace, propagated across services.

**Q5: Zipkin vs Jaeger?**
**A:** Zipkin: Simpler, older. Jaeger: More features, better UI, native OpenTracing support.

**Q6: What is Spring Cloud Sleuth?**
**A:** Spring library for automatic distributed tracing instrumentation.

**Q7: What is baggage in tracing?**
**A:** Key-value pairs propagated with trace to all downstream services.

**Q8: What is W3C Trace Context?**
**A:** Standard for propagating trace context via traceparent HTTP header.

**Q9: What is sampling?**
**A:** Recording only a percentage of traces to reduce overhead and storage.

**Q10: What is OpenTelemetry?**
**A:** Vendor-neutral observability framework for traces, metrics, and logs.

**Q11: How does Sleuth add trace IDs to logs?**
**A:** Uses MDC (Mapped Diagnostic Context) to add traceId and spanId.

**Q12: What is context propagation?**
**A:** Passing trace context (trace ID, span ID) across service boundaries.

**Q13: What is B3 propagation?**
**A:** Zipkin's header format for propagating trace context.

**Q14: How to create custom span?**
**A:** Use Tracer.nextSpan().name("operation").start().

**Q15: What is parent span?**
**A:** Span that initiated the current span, creates hierarchy.

**Q16: What is trace sampling rate?**
**A:** Percentage of traces to record (e.g., 0.1 = 10%).

**Q17: What is Istio tracing?**
**A:** Service mesh automatically propagates trace context between services.

**Q18: What metrics from tracing?**
**A:** Latency percentiles, error rate, request count, service dependencies.

**Q19: How to debug with tracing?**
**A:** Search traces by error tag, examine slow spans, check dependencies.

**Q20: What is trace backend?**
**A:** Storage and UI system (Zipkin, Jaeger) for viewing traces.

---

## 13. Summary

Distributed tracing tracks requests across microservices. Key concepts: trace (entire journey), span (single operation), trace ID (unique identifier). Popular systems: Zipkin (simple), Jaeger (feature-rich), OpenTelemetry (vendor-neutral). Spring Cloud Sleuth provides automatic instrumentation for Spring Boot. Context propagation via HTTP headers (W3C Trace Context, B3). Use sampling to control overhead (1-10% in production). Add meaningful tags and names to spans. Integrate with service mesh (Istio) for automatic tracing. Visualize with Zipkin/Jaeger UI. Essential for microservices debugging and performance analysis.

---

**End of Module 17** • **Next:** Spring Boot Actuator →
