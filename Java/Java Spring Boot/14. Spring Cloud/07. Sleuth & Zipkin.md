# üîç Sleuth & Zipkin - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Spring Cloud Sleuth](#spring-cloud-sleuth)
- [Zipkin Integration](#zipkin-integration)
- [Trace Propagation](#trace-propagation)
- [Custom Spans](#custom-spans)
- [Logging Integration](#logging-integration)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Spring Cloud Sleuth** provides distributed tracing for Spring Boot applications. **Zipkin** visualizes trace data.

### Architecture

```
Service A (Sleuth)
    ‚Üì [Trace ID: abc123, Span ID: 001]
Service B (Sleuth)
    ‚Üì [Trace ID: abc123, Span ID: 002]
Service C (Sleuth)
    ‚Üì [Trace ID: abc123, Span ID: 003]
        ‚Üì
    Zipkin Server
        ‚Üì
    Zipkin UI (Visualization)
```

---

## üå± Spring Cloud Sleuth

### Maven Dependencies

```xml
<dependencies>
    <!-- Sleuth -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    
    <!-- Zipkin -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin</artifactId>
    </dependency>
</dependencies>
```

### Configuration

```yaml
spring:
  application:
    name: order-service
  
  sleuth:
    sampler:
      probability: 1.0  # Sample 100% (reduce in production)
    
    baggage:
      remote-fields: user-id, request-id
      correlation-fields: user-id
  
  zipkin:
    base-url: http://localhost:9411
    sender:
      type: web  # or kafka/rabbit
```

### Auto-Instrumentation

Sleuth automatically instruments:
- RestTemplate
- WebClient
- Feign Clients
- Kafka
- RabbitMQ
- @Async methods
- Scheduled tasks

```java
@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public Order createOrder(OrderRequest request) {
        log.info("Creating order");  // Includes trace ID
        
        // Trace ID automatically propagated
        PaymentResponse payment = restTemplate.postForObject(
            "http://payment-service/api/payments",
            new PaymentRequest(request),
            PaymentResponse.class
        );
        
        return new Order(request, payment);
    }
}
```

---

## üìä Zipkin Integration

### Running Zipkin

**Docker:**

```bash
docker run -d -p 9411:9411 openzipkin/zipkin
```

**JAR:**

```bash
curl -sSL https://zipkin.io/quickstart.sh | bash -s
java -jar zipkin.jar
```

**Access UI:** `http://localhost:9411`

### Zipkin UI Features

```
1. Search Traces
   - By service name
   - By span name
   - By trace ID
   - By time range
   - By tags

2. Trace View
   - Visual timeline
   - Service dependencies
   - Span duration
   - Error spans
   - Tags and annotations

3. Dependencies
   - Service dependency graph
   - Call counts
   - Error rates
```

---

## üîÑ Trace Propagation

### HTTP Headers (B3 Propagation)

```
X-B3-TraceId: abc123def456
X-B3-SpanId: 001
X-B3-ParentSpanId: 000
X-B3-Sampled: 1
```

### RestTemplate

```java
@Configuration
public class RestTemplateConfig {
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
        // Sleuth automatically adds tracing interceptor
    }
}

@Service
public class OrderService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    public PaymentResponse callPaymentService(PaymentRequest request) {
        // Trace context automatically propagated via headers
        return restTemplate.postForObject(
            "http://payment-service/api/payments",
            request,
            PaymentResponse.class
        );
    }
}
```

### WebClient

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder().build();
        // Sleuth automatically adds tracing filter
    }
}

@Service
public class OrderService {
    
    @Autowired
    private WebClient webClient;
    
    public Mono<PaymentResponse> callPaymentService(PaymentRequest request) {
        return webClient.post()
            .uri("http://payment-service/api/payments")
            .bodyValue(request)
            .retrieve()
            .bodyToMono(PaymentResponse.class);
        // Trace context automatically propagated
    }
}
```

### Feign Client

```java
@FeignClient(name = "payment-service")
public interface PaymentClient {
    
    @PostMapping("/api/payments")
    PaymentResponse processPayment(@RequestBody PaymentRequest request);
    // Trace context automatically propagated
}
```

### Kafka

```java
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderEvent(Order order) {
        OrderEvent event = new OrderEvent(order);
        
        // Trace context automatically added to message headers
        kafkaTemplate.send("order-events", event);
    }
}

@Service
public class OrderEventConsumer {
    
    @KafkaListener(topics = "order-events")
    public void handleOrderEvent(OrderEvent event) {
        // Trace context automatically extracted from headers
        log.info("Processing order event");
    }
}
```

---

## üéØ Custom Spans

### Using Tracer

```java
@Service
public class OrderService {
    
    @Autowired
    private Tracer tracer;
    
    public Order createOrder(OrderRequest request) {
        // Create custom span
        Span customSpan = tracer.nextSpan().name("validate-order");
        
        try (Tracer.SpanInScope ws = tracer.withSpan(customSpan.start())) {
            // Add custom tags
            customSpan.tag("order.type", request.getType());
            customSpan.tag("user.id", request.getUserId().toString());
            customSpan.tag("order.total", request.getTotal().toString());
            
            // Business logic
            validateOrder(request);
            
        } catch (Exception e) {
            customSpan.tag("error", e.getMessage());
            throw e;
        } finally {
            customSpan.end();
        }
        
        return orderRepository.save(new Order(request));
    }
}
```

### Annotations

```java
@Service
public class OrderService {
    
    @NewSpan(name = "createOrder")
    public Order createOrder(@SpanTag("order.id") String orderId, 
                            OrderRequest request) {
        return orderRepository.save(new Order(request));
    }
    
    @ContinueSpan
    public void updateOrder(@SpanTag("order.id") String orderId) {
        // Continues current span
        orderRepository.update(orderId);
    }
}
```

---

## üìù Logging Integration

### Logback Configuration

```xml
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - [TraceId: %X{traceId}] [SpanId: %X{spanId}] - %msg%n
            </pattern>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

### Log Output

```
2024-12-20 10:15:30 [http-nio-8081-exec-1] INFO  o.e.OrderService - [TraceId: abc123] [SpanId: 001] - Creating order
2024-12-20 10:15:31 [http-nio-8082-exec-1] INFO  o.e.PaymentService - [TraceId: abc123] [SpanId: 002] - Processing payment
2024-12-20 10:15:32 [http-nio-8083-exec-1] INFO  o.e.InventoryService - [TraceId: abc123] [SpanId: 003] - Reserving inventory
```

### MDC (Mapped Diagnostic Context)

```java
@Component
public class TraceLogger {
    
    @Autowired
    private Tracer tracer;
    
    public void logWithTrace(String message) {
        Span span = tracer.currentSpan();
        
        if (span != null) {
            MDC.put("traceId", span.context().traceIdString());
            MDC.put("spanId", span.context().spanIdString());
        }
        
        log.info(message);
        
        MDC.clear();
    }
}
```

---

## üöÄ Advanced Features

### Baggage Propagation

```yaml
spring:
  sleuth:
    baggage:
      remote-fields: user-id, session-id, request-id
      correlation-fields: user-id  # Also in logs
```

```java
@RestController
public class OrderController {
    
    @Autowired
    private BaggageField userIdField;
    
    @PostMapping("/api/orders")
    public Order createOrder(@RequestBody OrderRequest request) {
        // Set baggage (propagated to all downstream services)
        userIdField.updateValue(request.getUserId().toString());
        
        return orderService.createOrder(request);
    }
}

@Service
public class PaymentService {
    
    @Autowired
    private BaggageField userIdField;
    
    public PaymentResponse processPayment(PaymentRequest request) {
        String userId = userIdField.get();
        log.info("Processing payment for user: {}", userId);
        
        return new PaymentResponse();
    }
}
```

### Sampling

```yaml
spring:
  sleuth:
    sampler:
      # Sample 10% of requests in production
      probability: 0.1
      
      # Sample specific patterns
      rate: 10  # per second
```

```java
@Component
public class CustomSampler extends Sampler {
    
    @Override
    public SamplingDecision trySample(SamplingInput input) {
        String path = input.request().path();
        
        // Always sample error requests
        if (path.contains("/error")) {
            return SamplingDecision.SAMPLE;
        }
        
        // Never sample health checks
        if (path.contains("/health")) {
            return SamplingDecision.NO_SAMPLE;
        }
        
        // Sample 10% of other requests
        return Math.random() < 0.1 ? 
            SamplingDecision.SAMPLE : 
            SamplingDecision.NO_SAMPLE;
    }
}
```

### Custom Span Handler

```java
@Component
public class CustomSpanHandler extends SpanHandler {
    
    @Override
    public boolean end(TraceContext context, MutableSpan span, Cause cause) {
        log.info("Span ended: {} - Duration: {}ms", 
            span.name(), 
            span.finishTimestamp() - span.startTimestamp());
        
        // Send to custom backend
        if (span.tag("error") != null) {
            alertingService.sendAlert("Error in span: " + span.name());
        }
        
        return true;  // Continue to other handlers
    }
}
```

### Async Operations

```java
@Service
public class OrderService {
    
    @Async
    public CompletableFuture<PaymentResponse> processPaymentAsync(Order order) {
        // Trace context automatically propagated to async thread
        log.info("Processing payment asynchronously");
        
        PaymentResponse response = paymentClient.charge(order.getTotal());
        return CompletableFuture.completedFuture(response);
    }
}
```

---

## üìà Monitoring

### Metrics

```yaml
management:
  metrics:
    export:
      prometheus:
        enabled: true
  endpoints:
    web:
      exposure:
        include: prometheus,metrics,traces
```

### Health Endpoint

```
http://localhost:8081/actuator/health

{
  "status": "UP",
  "components": {
    "sleuth": {
      "status": "UP"
    }
  }
}
```

### Trace Endpoint

```
http://localhost:8081/actuator/traces
```

---

## üí° Best Practices

### 1. Use Appropriate Sampling

```yaml
# ‚úÖ Good - Different sampling for environments
---
spring:
  config:
    activate:
      on-profile: dev
  sleuth:
    sampler:
      probability: 1.0  # 100% in dev

---
spring:
  config:
    activate:
      on-profile: prod
  sleuth:
    sampler:
      probability: 0.1  # 10% in production
```

### 2. Add Meaningful Tags

```java
// ‚úÖ Good - Descriptive tags
span.tag("user.id", userId);
span.tag("order.type", orderType);
span.tag("payment.method", paymentMethod);

// ‚ùå Bad - Generic tags
span.tag("data", "value");
```

### 3. Use Correlation IDs

```java
// ‚úÖ Good - Add correlation ID to logs
MDC.put("correlationId", span.context().traceIdString());

// ‚ùå Bad - No correlation
```

### 4. Monitor Trace Metrics

```java
// ‚úÖ Good - Track span metrics
@Component
public class SpanMetrics {
    
    @Autowired
    private MeterRegistry registry;
    
    @EventListener
    public void onSpanEnd(SpanEndedEvent event) {
        registry.counter("spans.ended",
            "service", event.getSpan().name()
        ).increment();
    }
}
```

### 5. Handle Errors Properly

```java
// ‚úÖ Good - Tag errors
try {
    processOrder(request);
} catch (Exception e) {
    span.tag("error", e.getMessage());
    span.tag("error.type", e.getClass().getName());
    throw e;
}
```

---

## üé§ Interview Questions

### Q1: What is Spring Cloud Sleuth?
**Answer:** Library adding distributed tracing to Spring Boot applications automatically.

### Q2: What is a trace?
**Answer:** Complete journey of a request through all microservices.

### Q3: What is a span?
**Answer:** Single operation/unit of work within a trace (e.g., HTTP request, DB query).

### Q4: What is trace ID?
**Answer:** Unique identifier linking all spans of a single request across services.

### Q5: What is span ID?
**Answer:** Unique identifier for a specific span within a trace.

### Q6: What is Zipkin?
**Answer:** Distributed tracing system for collecting and visualizing trace data.

### Q7: How does trace context propagate?
**Answer:** Through HTTP headers (B3 propagation), message headers, automatically by Sleuth.

### Q8: What is B3 propagation?
**Answer:** Standard for propagating trace context via headers (X-B3-TraceId, X-B3-SpanId, etc.).

### Q9: What is baggage?
**Answer:** Key-value pairs propagated with trace context to all downstream services.

### Q10: What is sampling?
**Answer:** Collecting only a percentage of traces to reduce overhead (e.g., 10% in production).

### Q11: How to add custom spans?
**Answer:** Use `Tracer.nextSpan()` to create span, add tags, start/end manually, or use `@NewSpan`.

### Q12: How to correlate logs with traces?
**Answer:** Include trace ID and span ID in log pattern using `%X{traceId}`, `%X{spanId}`.

### Q13: What is parent span ID?
**Answer:** ID of the span that initiated current span, creating parent-child relationship.

### Q14: Sleuth vs Zipkin?
**Answer:** Sleuth generates trace data, Zipkin collects and visualizes it.

### Q15: How to trace async operations?
**Answer:** Sleuth automatically propagates context to async threads (@Async, CompletableFuture).

### Q16: Can you exclude endpoints from tracing?
**Answer:** Yes, use custom sampler to skip specific patterns (e.g., /health, /metrics).

### Q17: Performance impact of tracing?
**Answer:** Minimal with sampling. Use lower rate (10-20%) in production.

### Q18: Can you trace message queues?
**Answer:** Yes, Sleuth supports Kafka, RabbitMQ with automatic context propagation.

### Q19: Zipkin alternatives?
**Answer:** Jaeger, AWS X-Ray, Google Cloud Trace, Datadog APM, New Relic.

### Q20: How to send traces to multiple backends?
**Answer:** Configure multiple senders (Zipkin + custom SpanHandler).

---

## üìö Summary

### Key Concepts

```
Trace:
‚îú‚îÄ Complete request journey
‚îú‚îÄ Unique trace ID
‚îî‚îÄ Multiple spans

Span:
‚îú‚îÄ Single operation
‚îú‚îÄ Unique span ID
‚îú‚îÄ Parent span ID
‚îî‚îÄ Tags and annotations

Propagation:
‚îú‚îÄ HTTP headers (B3)
‚îú‚îÄ Message headers
‚îî‚îÄ Automatic by Sleuth

Sampling:
‚îú‚îÄ Reduce overhead
‚îú‚îÄ Production: 10-20%
‚îî‚îÄ Development: 100%
```

### Configuration Template

```yaml
spring:
  sleuth:
    sampler:
      probability: 0.1
    baggage:
      remote-fields: user-id
      correlation-fields: user-id
  zipkin:
    base-url: http://localhost:9411
```

### Usage Pattern

```java
// Automatic tracing
@Autowired
private RestTemplate restTemplate;

// Custom span
Span span = tracer.nextSpan().name("operation");
try (Tracer.SpanInScope ws = tracer.withSpan(span.start())) {
    span.tag("key", "value");
    // Business logic
} finally {
    span.end();
}
```

**Next:** Cloud Bus ‚Üí

