# üõ°Ô∏è Resilience4j - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Circuit Breaker](#circuit-breaker)
- [Retry](#retry)
- [Rate Limiter](#rate-limiter)
- [Time Limiter](#time-limiter)
- [Bulkhead](#bulkhead)
- [Monitoring](#monitoring)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Resilience4j** is a lightweight fault tolerance library providing Circuit Breaker, Retry, Rate Limiter, Time Limiter, and Bulkhead patterns.

### Why Resilience4j?

```
Fault Tolerance Patterns:
‚úÖ Circuit Breaker - Prevent cascade failures
‚úÖ Retry - Handle transient failures
‚úÖ Rate Limiter - Control request rate
‚úÖ Time Limiter - Limit execution time
‚úÖ Bulkhead - Isolate resources
```

---

## üîå Circuit Breaker

### Maven Dependencies

```xml
<dependencies>
    <!-- Resilience4j Spring Boot -->
    <dependency>
        <groupId>io.github.resilience4j</groupId>
        <artifactId>resilience4j-spring-boot3</artifactId>
    </dependency>
    
    <!-- Spring AOP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    
    <!-- Actuator for metrics -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### Configuration

```yaml
resilience4j:
  circuitbreaker:
    instances:
      paymentService:
        register-health-indicator: true
        sliding-window-size: 10
        minimum-number-of-calls: 5
        permitted-number-of-calls-in-half-open-state: 3
        automatic-transition-from-open-to-half-open-enabled: true
        wait-duration-in-open-state: 10s
        failure-rate-threshold: 50
        event-consumer-buffer-size: 10
        slow-call-rate-threshold: 50
        slow-call-duration-threshold: 2s

management:
  health:
    circuitbreakers:
      enabled: true
  endpoints:
    web:
      exposure:
        include: health,circuitbreakers,circuitbreakerevents
```

### Basic Usage

```java
@Service
public class OrderService {
    
    @Autowired
    private PaymentClient paymentClient;
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "fallbackPayment")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
    
    private PaymentResponse fallbackPayment(PaymentRequest request, Exception ex) {
        log.error("Payment service failed: {}", ex.getMessage());
        return PaymentResponse.failed("Service temporarily unavailable");
    }
}
```

### Programmatic Usage

```java
@Service
public class OrderService {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private PaymentClient paymentClient;
    
    public PaymentResponse processPayment(PaymentRequest request) {
        CircuitBreaker circuitBreaker = circuitBreakerRegistry
            .circuitBreaker("paymentService");
        
        return circuitBreaker.executeSupplier(() -> 
            paymentClient.charge(request)
        );
    }
}
```

### States

```
CLOSED (Normal operation)
    ‚Üì (Failure rate > threshold)
OPEN (Reject calls)
    ‚Üì (Wait duration elapsed)
HALF_OPEN (Test recovery)
    ‚Üì (Success rate good)
CLOSED
```

---

## üîÑ Retry

### Configuration

```yaml
resilience4j:
  retry:
    instances:
      paymentService:
        max-attempts: 3
        wait-duration: 1s
        enable-exponential-backoff: true
        exponential-backoff-multiplier: 2
        retry-exceptions:
          - org.springframework.web.client.HttpServerErrorException
          - java.io.IOException
        ignore-exceptions:
          - com.example.exception.BusinessException
```

### Annotation Usage

```java
@Service
public class OrderService {
    
    @Retry(name = "paymentService", fallbackMethod = "fallbackPayment")
    public PaymentResponse processPayment(PaymentRequest request) {
        log.info("Attempting payment...");
        return paymentClient.charge(request);
    }
    
    private PaymentResponse fallbackPayment(PaymentRequest request, Exception ex) {
        log.error("All retry attempts failed: {}", ex.getMessage());
        return PaymentResponse.failed("Payment failed after retries");
    }
}
```

### Combining Circuit Breaker and Retry

```java
@Service
public class OrderService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "fallback")
    @Retry(name = "paymentService")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
    
    private PaymentResponse fallback(PaymentRequest request, Exception ex) {
        return PaymentResponse.failed("Service unavailable");
    }
}
```

---

## ‚è±Ô∏è Rate Limiter

### Configuration

```yaml
resilience4j:
  ratelimiter:
    instances:
      orderService:
        limit-for-period: 10
        limit-refresh-period: 1s
        timeout-duration: 0
        register-health-indicator: true
```

### Usage

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @RateLimiter(name = "orderService")
    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        Order order = orderService.createOrder(request);
        return ResponseEntity.ok(order);
    }
}
```

### Programmatic Usage

```java
@Service
public class OrderService {
    
    @Autowired
    private RateLimiterRegistry rateLimiterRegistry;
    
    public Order createOrder(OrderRequest request) {
        RateLimiter rateLimiter = rateLimiterRegistry
            .rateLimiter("orderService");
        
        return RateLimiter.decorateSupplier(
            rateLimiter,
            () -> processOrder(request)
        ).get();
    }
}
```

---

## ‚è≤Ô∏è Time Limiter

### Configuration

```yaml
resilience4j:
  timelimiter:
    instances:
      paymentService:
        timeout-duration: 2s
        cancel-running-future: true
```

### Usage

```java
@Service
public class OrderService {
    
    @TimeLimiter(name = "paymentService", fallbackMethod = "fallbackPayment")
    public CompletableFuture<PaymentResponse> processPaymentAsync(PaymentRequest request) {
        return CompletableFuture.supplyAsync(() -> 
            paymentClient.charge(request)
        );
    }
    
    private CompletableFuture<PaymentResponse> fallbackPayment(
            PaymentRequest request, Exception ex) {
        return CompletableFuture.completedFuture(
            PaymentResponse.failed("Payment timeout")
        );
    }
}
```

---

## üèä Bulkhead

### Configuration

```yaml
resilience4j:
  bulkhead:
    instances:
      paymentService:
        max-concurrent-calls: 10
        max-wait-duration: 1s
  
  thread-pool-bulkhead:
    instances:
      paymentService:
        max-thread-pool-size: 4
        core-thread-pool-size: 2
        queue-capacity: 2
        keep-alive-duration: 20ms
```

### Semaphore Bulkhead

```java
@Service
public class OrderService {
    
    @Bulkhead(name = "paymentService", fallbackMethod = "fallbackPayment")
    public PaymentResponse processPayment(PaymentRequest request) {
        return paymentClient.charge(request);
    }
    
    private PaymentResponse fallbackPayment(PaymentRequest request, BulkheadFullException ex) {
        log.error("Bulkhead full, rejecting request");
        return PaymentResponse.failed("Too many concurrent requests");
    }
}
```

### Thread Pool Bulkhead

```java
@Service
public class OrderService {
    
    @Bulkhead(name = "paymentService", type = Bulkhead.Type.THREADPOOL, 
             fallbackMethod = "fallbackPayment")
    public CompletableFuture<PaymentResponse> processPaymentAsync(PaymentRequest request) {
        return CompletableFuture.supplyAsync(() -> 
            paymentClient.charge(request)
        );
    }
}
```

---

## üìä Monitoring

### Health Endpoint

```yaml
management:
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  endpoints:
    web:
      exposure:
        include: health,metrics,circuitbreakers,circuitbreakerevents
```

Access: `http://localhost:8081/actuator/health`

### Event Monitoring

```java
@Component
public class CircuitBreakerEventListener {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @PostConstruct
    public void init() {
        circuitBreakerRegistry.circuitBreaker("paymentService")
            .getEventPublisher()
            .onStateTransition(event -> {
                log.info("Circuit Breaker state transition: {} -> {}",
                    event.getStateTransition().getFromState(),
                    event.getStateTransition().getToState());
            })
            .onError(event -> {
                log.error("Circuit Breaker error: {}", 
                    event.getThrowable().getMessage());
            })
            .onSuccess(event -> {
                log.debug("Circuit Breaker success");
            });
    }
}
```

### Metrics

```java
@Component
public class ResilienceMetrics {
    
    @Autowired
    private CircuitBreakerRegistry circuitBreakerRegistry;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    @PostConstruct
    public void bindCircuitBreakerMetrics() {
        circuitBreakerRegistry.circuitBreaker("paymentService")
            .getEventPublisher()
            .onEvent(event -> {
                meterRegistry.counter("circuit.breaker.calls",
                    "name", "paymentService",
                    "type", event.getEventType().toString()
                ).increment();
            });
    }
}
```

---

## üé® Advanced Patterns

### Complete Resilience Stack

```java
@Service
public class OrderService {
    
    @CircuitBreaker(name = "paymentService", fallbackMethod = "fallback")
    @Retry(name = "paymentService")
    @RateLimiter(name = "paymentService")
    @Bulkhead(name = "paymentService")
    @TimeLimiter(name = "paymentService")
    public CompletableFuture<PaymentResponse> processPayment(PaymentRequest request) {
        return CompletableFuture.supplyAsync(() -> 
            paymentClient.charge(request)
        );
    }
    
    private CompletableFuture<PaymentResponse> fallback(
            PaymentRequest request, Exception ex) {
        log.error("Payment failed: {}", ex.getMessage());
        return CompletableFuture.completedFuture(
            PaymentResponse.failed("Service unavailable")
        );
    }
}
```

### Custom Configuration

```java
@Configuration
public class ResilienceConfig {
    
    @Bean
    public CircuitBreakerConfigCustomizer circuitBreakerCustomizer() {
        return CircuitBreakerConfigCustomizer.of("paymentService", builder -> 
            builder
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(10))
                .permittedNumberOfCallsInHalfOpenState(3)
                .slidingWindowSize(10)
                .recordExceptions(IOException.class, TimeoutException.class)
                .ignoreExceptions(BusinessException.class)
        );
    }
    
    @Bean
    public RetryConfigCustomizer retryCustomizer() {
        return RetryConfigCustomizer.of("paymentService", builder ->
            builder
                .maxAttempts(3)
                .waitDuration(Duration.ofSeconds(1))
                .retryExceptions(IOException.class)
                .ignoreExceptions(BusinessException.class)
        );
    }
}
```

---

## üí° Best Practices

### 1. Use Appropriate Patterns

```java
// ‚úÖ Good - Combine patterns
@CircuitBreaker(name = "service")
@Retry(name = "service")
public Response call() { }

// ‚ùå Bad - Only one pattern
@CircuitBreaker(name = "service")
public Response call() { }
```

### 2. Configure Thresholds Properly

```yaml
# ‚úÖ Good - Reasonable thresholds
resilience4j:
  circuitbreaker:
    instances:
      service:
        failure-rate-threshold: 50
        slow-call-rate-threshold: 50
        wait-duration-in-open-state: 10s

# ‚ùå Bad - Too sensitive
failure-rate-threshold: 10
wait-duration-in-open-state: 1s
```

### 3. Implement Fallbacks

```java
// ‚úÖ Good - Meaningful fallback
private Response fallback(Request req, Exception ex) {
    return Response.fromCache(req);
}

// ‚ùå Bad - Empty fallback
private Response fallback(Request req, Exception ex) {
    return null;
}
```

### 4. Monitor Events

```java
// ‚úÖ Good - Log state transitions
circuitBreaker.getEventPublisher()
    .onStateTransition(event -> log.info(...));

// ‚ùå Bad - No monitoring
```

### 5. Use Health Indicators

```yaml
# ‚úÖ Good - Enable health checks
management:
  health:
    circuitbreakers:
      enabled: true
```

---

## üé§ Interview Questions

### Q1: What is Resilience4j?
**Answer:** Lightweight fault tolerance library providing Circuit Breaker, Retry, Rate Limiter, Time Limiter, Bulkhead.

### Q2: Circuit Breaker states?
**Answer:** CLOSED (normal), OPEN (failing), HALF_OPEN (testing recovery).

### Q3: When does circuit breaker open?
**Answer:** When failure rate exceeds threshold after minimum number of calls.

### Q4: What is retry pattern?
**Answer:** Automatically retry failed operations with configurable delays and max attempts.

### Q5: What is rate limiter?
**Answer:** Controls number of requests allowed in a time period.

### Q6: What is time limiter?
**Answer:** Limits execution time of operations, cancels if exceeds timeout.

### Q7: What is bulkhead pattern?
**Answer:** Isolates resources (threads, concurrent calls) to prevent one failure affecting others.

### Q8: Semaphore vs Thread Pool Bulkhead?
**Answer:** Semaphore: Limits concurrent calls. Thread Pool: Isolates with separate thread pool.

### Q9: How to combine patterns?
**Answer:** Stack annotations: @CircuitBreaker, @Retry, @RateLimiter, @Bulkhead, @TimeLimiter.

### Q10: What is fallback method?
**Answer:** Alternative method called when circuit breaker opens or operation fails.

### Q11: Resilience4j vs Hystrix?
**Answer:** Resilience4j: Lightweight, modular, maintained. Hystrix: Deprecated, monolithic.

### Q12: How to monitor circuit breakers?
**Answer:** Actuator endpoints, event listeners, metrics, health indicators.

### Q13: What is sliding window?
**Answer:** Window of recent calls used to calculate failure rate.

### Q14: Count-based vs Time-based sliding window?
**Answer:** Count-based: Last N calls. Time-based: Calls in last N seconds.

### Q15: What is slow call?
**Answer:** Call exceeding `slow-call-duration-threshold`, counts toward slow-call-rate.

### Q16: How to configure exponential backoff?
**Answer:** Enable in retry config with `exponential-backoff-multiplier`.

### Q17: What metrics does Resilience4j provide?
**Answer:** Calls (successful, failed), state transitions, slow calls, buffered calls.

### Q18: Can you ignore specific exceptions?
**Answer:** Yes, configure `ignore-exceptions` to exclude from failure counting.

### Q19: What is automatic transition?
**Answer:** Circuit breaker automatically moves from OPEN to HALF_OPEN after wait duration.

### Q20: Best practices for resilience?
**Answer:** Combine patterns, configure thresholds properly, implement fallbacks, monitor events, test failure scenarios.

---

## üìö Summary

### Patterns Overview

```
Circuit Breaker:
‚îú‚îÄ Prevents cascade failures
‚îú‚îÄ States: CLOSED, OPEN, HALF_OPEN
‚îî‚îÄ Fallback on failure

Retry:
‚îú‚îÄ Handle transient failures
‚îú‚îÄ Exponential backoff
‚îî‚îÄ Max attempts

Rate Limiter:
‚îú‚îÄ Control request rate
‚îú‚îÄ Limit per period
‚îî‚îÄ Timeout on limit

Time Limiter:
‚îú‚îÄ Limit execution time
‚îú‚îÄ Cancel on timeout
‚îî‚îÄ Async operations

Bulkhead:
‚îú‚îÄ Isolate resources
‚îú‚îÄ Semaphore or Thread Pool
‚îî‚îÄ Prevent resource exhaustion
```

### Configuration Template

```yaml
resilience4j:
  circuitbreaker:
    instances:
      service:
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10s
        sliding-window-size: 10
  
  retry:
    instances:
      service:
        max-attempts: 3
        wait-duration: 1s
```

### Usage Pattern

```java
@CircuitBreaker(name = "service", fallbackMethod = "fallback")
@Retry(name = "service")
public Response call() { }
```

**Next:** Sleuth & Zipkin ‚Üí

