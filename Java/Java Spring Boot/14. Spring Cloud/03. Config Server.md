# ‚öôÔ∏è Config Server - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Server Setup](#server-setup)
- [Client Configuration](#client-configuration)
- [Git Backend](#git-backend)
- [Refresh Mechanisms](#refresh-mechanisms)
- [Encryption](#encryption)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Spring Cloud Config Server** provides centralized configuration management for distributed systems, backed by a Git repository.

### Architecture

```
Git Repository (Config Files)
         ‚Üì
   Config Server (8888)
         ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì    ‚Üì    ‚Üì
Service-A Service-B Service-C
```

---

## üñ•Ô∏è Server Setup

### Maven Dependencies

```xml
<dependencies>
    <!-- Config Server -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
    </dependency>
    
    <!-- Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### Application Class

```java
package com.example.config;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.server.EnableConfigServer;

@SpringBootApplication
@EnableConfigServer  // Enable Config Server
public class ConfigServerApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
```

### Configuration (application.yml)

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
  
  cloud:
    config:
      server:
        git:
          uri: https://github.com/your-org/config-repo
          default-label: main
          clone-on-start: true
          search-paths: '{application}'
          timeout: 4
          
          # Authentication (if private repo)
          username: ${GIT_USERNAME:}
          password: ${GIT_PASSWORD:}
          
          # Or SSH
          # uri: git@github.com:your-org/config-repo.git
          # private-key: |
          #   -----BEGIN RSA PRIVATE KEY-----
          #   ...
          #   -----END RSA PRIVATE KEY-----

management:
  endpoints:
    web:
      exposure:
        include: health,info,refresh,busrefresh
```

---

## üìÇ Git Backend

### Repository Structure

```
config-repo/
‚îú‚îÄ‚îÄ application.yml              # Global defaults
‚îú‚îÄ‚îÄ application-dev.yml          # Dev profile
‚îú‚îÄ‚îÄ application-prod.yml         # Prod profile
‚îÇ
‚îú‚îÄ‚îÄ order-service.yml            # Order service defaults
‚îú‚îÄ‚îÄ order-service-dev.yml        # Order service dev
‚îú‚îÄ‚îÄ order-service-prod.yml       # Order service prod
‚îÇ
‚îú‚îÄ‚îÄ payment-service.yml
‚îú‚îÄ‚îÄ payment-service-dev.yml
‚îî‚îÄ‚îÄ payment-service-prod.yml
```

### Configuration Files

**application.yml (Global):**

```yaml
# Common to all services
logging:
  level:
    root: INFO

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
```

**order-service.yml:**

```yaml
server:
  port: 8081

spring:
  datasource:
    driver-class-name: org.postgresql.Driver

order:
  max-items: 100
  timeout: 30000
```

**order-service-dev.yml:**

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/order_db_dev
    username: dev_user
    password: '{cipher}AQA...'

logging:
  level:
    com.example.order: DEBUG
```

**order-service-prod.yml:**

```yaml
spring:
  datasource:
    url: jdbc:postgresql://prod-db:5432/order_db
    username: prod_user
    password: '{cipher}AQB...'
    hikari:
      maximum-pool-size: 20

logging:
  level:
    com.example.order: WARN
```

### Accessing Configuration

```
# Pattern: /{application}/{profile}/{label}
http://localhost:8888/order-service/dev/main
http://localhost:8888/order-service/prod/main

# Pattern: /{application}-{profile}.yml
http://localhost:8888/order-service-dev.yml
http://localhost:8888/order-service-prod.yml

# Pattern: /{label}/{application}-{profile}.yml
http://localhost:8888/main/order-service-dev.yml
```

---

## üì± Client Configuration

### Maven Dependencies

```xml
<dependencies>
    <!-- Config Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    
    <!-- Bootstrap (for Spring Boot 2.4+) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-bootstrap</artifactId>
    </dependency>
    
    <!-- Actuator for refresh -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### Bootstrap Configuration

**bootstrap.yml:**

```yaml
spring:
  application:
    name: order-service
  
  cloud:
    config:
      uri: http://localhost:8888
      fail-fast: true
      retry:
        initial-interval: 1000
        max-attempts: 6
        max-interval: 2000
        multiplier: 1.1
  
  profiles:
    active: dev
```

### Alternative: application.yml (Spring Boot 2.4+)

```yaml
spring:
  application:
    name: order-service
  
  config:
    import: optional:configserver:http://localhost:8888
  
  profiles:
    active: dev
```

### Using Configuration Properties

```java
@Component
@ConfigurationProperties(prefix = "order")
@RefreshScope  // Enable dynamic refresh
@Data
public class OrderProperties {
    
    private int maxItems;
    private long timeout;
    private boolean enableCache;
    private List<String> allowedPaymentMethods;
}
```

```java
@RestController
@RefreshScope
public class OrderController {
    
    @Value("${order.max-items}")
    private int maxItems;
    
    @Autowired
    private OrderProperties orderProperties;
    
    @GetMapping("/api/config")
    public Map<String, Object> getConfig() {
        return Map.of(
            "maxItems", maxItems,
            "timeout", orderProperties.getTimeout(),
            "enableCache", orderProperties.isEnableCache()
        );
    }
}
```

---

## üîÑ Refresh Mechanisms

### Manual Refresh

```bash
# Update config in Git
git add .
git commit -m "Update config"
git push

# Refresh specific service
curl -X POST http://localhost:8081/actuator/refresh

# Response shows refreshed keys
["order.max-items", "order.timeout"]
```

**Enable refresh endpoint:**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info
```

### Spring Cloud Bus (Automatic Refresh)

**Dependencies:**

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```

**Configuration:**

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
  
  cloud:
    bus:
      enabled: true
      refresh:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: busrefresh
```

**Refresh all services:**

```bash
curl -X POST http://localhost:8888/actuator/busrefresh
# OR
curl -X POST http://localhost:8081/actuator/busrefresh
```

### GitHub Webhook

```java
@RestController
@RequestMapping("/webhook")
public class GitWebhookController {
    
    @Autowired
    private RefreshEndpoint refreshEndpoint;
    
    @Autowired
    private BusRefreshEndpoint busRefreshEndpoint;
    
    @PostMapping("/github")
    public ResponseEntity<?> handleWebhook(
            @RequestBody Map<String, Object> payload,
            @RequestHeader("X-GitHub-Event") String event) {
        
        if (!"push".equals(event)) {
            return ResponseEntity.ok("Ignored non-push event");
        }
        
        String ref = (String) payload.get("ref");
        
        if ("refs/heads/main".equals(ref)) {
            // Trigger bus refresh
            busRefreshEndpoint.busRefresh(null);
            
            return ResponseEntity.ok(Map.of(
                "message", "Configuration refreshed",
                "timestamp", Instant.now()
            ));
        }
        
        return ResponseEntity.ok("No refresh needed");
    }
}
```

**GitHub Webhook Setup:**

```
URL: http://your-config-server/webhook/github
Content type: application/json
Secret: (optional)
Events: Just the push event
```

---

## üîê Encryption

### Symmetric Encryption

**Config Server:**

```yaml
encrypt:
  key: mySecretKey123456789  # Must be strong
```

**Encrypt value:**

```bash
curl http://localhost:8888/encrypt -d "myPassword123"
# Output: AQA1e2f3g4h5i6j7k8l9m0n1o2p3q4r5s6t7u8v9w0...

curl http://localhost:8888/decrypt -d "AQA1e2f3g4h5..."
# Output: myPassword123
```

**Use in config file:**

```yaml
spring:
  datasource:
    password: '{cipher}AQA1e2f3g4h5i6j7k8l9m0n1o2p3q4r5s6t7u8v9w0...'
```

### Asymmetric Encryption (RSA)

**Generate keystore:**

```bash
keytool -genkeypair -alias config-server \
  -keyalg RSA \
  -keystore config-server.jks \
  -keysize 2048 \
  -storepass changeit \
  -keypass changeit \
  -dname "CN=Config Server,OU=Development,O=Example,L=City,ST=State,C=US"
```

**Config Server:**

```yaml
encrypt:
  key-store:
    location: classpath:/config-server.jks
    password: changeit
    alias: config-server
    secret: changeit
```

**Encrypt:**

```bash
curl http://localhost:8888/encrypt -d "myPassword123"
# Much longer output with RSA
```

### Environment Variables

```yaml
# Instead of encryption, use environment variables
spring:
  datasource:
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
```

```bash
export DB_USERNAME=admin
export DB_PASSWORD=secret
java -jar order-service.jar
```

---

## üöÄ Advanced Features

### Multiple Repositories

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/default-config
          repos:
            order:
              pattern: order-service*
              uri: https://github.com/org/order-config
              search-paths: config
            
            payment:
              pattern: payment-service*,billing-service*
              uri: https://github.com/org/payment-config
              username: ${PAYMENT_GIT_USER}
              password: ${PAYMENT_GIT_PASS}
```

### Composite Configuration

```yaml
spring:
  cloud:
    config:
      server:
        composite:
          - type: git
            uri: https://github.com/org/common-config
          
          - type: vault
            host: localhost
            port: 8200
            authentication: TOKEN
            token: ${VAULT_TOKEN}
          
          - type: native
            search-locations: file:/etc/config,classpath:/config
```

### Vault Backend

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-vault-config</artifactId>
</dependency>
```

```yaml
spring:
  cloud:
    config:
      server:
        vault:
          host: localhost
          port: 8200
          authentication: TOKEN
          token: ${VAULT_TOKEN}
          kv-version: 2
          backend: secret
```

### Native Profile (File System)

```yaml
spring:
  profiles:
    active: native
  cloud:
    config:
      server:
        native:
          search-locations: file:/config,classpath:/config
```

### Profile-Specific Config Server

```yaml
# application-docker.yml (for Docker environment)
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/docker-config
          search-paths: docker/{application}

# application-kubernetes.yml (for K8s environment)
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/k8s-config
          search-paths: k8s/{application}
```

### Custom Refresh Strategy

```java
@Component
public class CustomConfigRefresh {
    
    @Autowired
    private RefreshEndpoint refreshEndpoint;
    
    @Autowired
    private ApplicationEventPublisher publisher;
    
    @Scheduled(fixedRate = 300000)  // Every 5 minutes
    public void autoRefresh() {
        Collection<String> keys = refreshEndpoint.refresh();
        
        if (!keys.isEmpty()) {
            log.info("Auto-refreshed configuration: {}", keys);
            
            publisher.publishEvent(
                new ConfigurationRefreshedEvent(keys)
            );
        }
    }
}

public class ConfigurationRefreshedEvent extends ApplicationEvent {
    private final Collection<String> keys;
    
    public ConfigurationRefreshedEvent(Collection<String> keys) {
        super(keys);
        this.keys = keys;
    }
    
    public Collection<String> getKeys() {
        return keys;
    }
}

@Component
public class ConfigChangeListener {
    
    @EventListener
    public void handleConfigChange(ConfigurationRefreshedEvent event) {
        log.info("Configuration changed: {}", event.getKeys());
        
        // Custom logic: send alert, update cache, etc.
        if (event.getKeys().contains("order.max-items")) {
            // Handle max items change
        }
    }
}
```

---

## üí° Best Practices

### 1. Use Profiles

```yaml
# ‚úÖ Good - Separate profiles
application-dev.yml
application-test.yml
application-prod.yml

# ‚ùå Bad - Single file with conditionals
```

### 2. Encrypt Sensitive Data

```yaml
# ‚úÖ Good
spring:
  datasource:
    password: '{cipher}AQA...'

# ‚ùå Bad
spring:
  datasource:
    password: admin123
```

### 3. Version Configuration

```bash
# ‚úÖ Good - Use Git tags
git tag -a v1.0.0 -m "Release 1.0.0"

# Client
spring:
  cloud:
    config:
      label: v1.0.0
```

### 4. Fail Fast in Production

```yaml
# ‚úÖ Good
spring:
  cloud:
    config:
      fail-fast: true

# ‚ùå Bad
spring:
  cloud:
    config:
      fail-fast: false
```

### 5. Monitor Configuration Changes

```java
@Component
public class ConfigAudit {
    
    @EventListener
    public void auditRefresh(RefreshScopeRefreshedEvent event) {
        log.info("Config refreshed: {}", event.getName());
        // Send to audit log, metrics, etc.
    }
}
```

### 6. Use @RefreshScope Wisely

```java
// ‚úÖ Good - RefreshScope on configuration beans
@Component
@ConfigurationProperties(prefix = "order")
@RefreshScope
public class OrderProperties { }

// ‚ùå Bad - RefreshScope on service beans
@Service
@RefreshScope  // Avoid - creates proxy overhead
public class OrderService { }
```

---

## üé§ Interview Questions

### Q1: What is Config Server?
**Answer:** Centralized configuration management for distributed systems, backed by Git repository.

### Q2: Why use Config Server?
**Answer:** Centralized config, version control, environment-specific profiles, dynamic refresh, encrypted secrets.

### Q3: How does Config Server work?
**Answer:** Stores configs in Git, exposes REST API, clients fetch on startup, can refresh dynamically.

### Q4: What is @RefreshScope?
**Answer:** Annotation enabling beans to reload when configuration changes via /actuator/refresh.

### Q5: What is bootstrap.yml?
**Answer:** Loaded before application.yml to configure Config Server connection early in startup.

### Q6: How to refresh configuration?
**Answer:** POST to /actuator/refresh (single service) or /actuator/busrefresh (all services via Cloud Bus).

### Q7: What is Spring Cloud Bus?
**Answer:** Message bus (RabbitMQ/Kafka) for broadcasting events like config refresh to all services.

### Q8: How to encrypt passwords?
**Answer:** Use /encrypt endpoint, store as `{cipher}...`, Config Server auto-decrypts.

### Q9: Symmetric vs Asymmetric encryption?
**Answer:** Symmetric: Single key (faster). Asymmetric: Key pair (more secure, requires keystore).

### Q10: What is fail-fast?
**Answer:** Application fails on startup if Config Server unavailable (`fail-fast: true`).

### Q11: How to version configuration?
**Answer:** Use Git branches/tags, specify with `spring.cloud.config.label`.

### Q12: What backends does Config Server support?
**Answer:** Git (default), Vault, JDBC, Native file system, Composite.

### Q13: What is native profile?
**Answer:** Uses local filesystem instead of Git: `spring.profiles.active=native`.

### Q14: How to secure Config Server?
**Answer:** Spring Security, encrypt properties, HTTPS, restrict Git access.

### Q15: Profile resolution order?
**Answer:** `application.yml` ‚Üí `application-{profile}.yml` ‚Üí `{service}.yml` ‚Üí `{service}-{profile}.yml`

### Q16: Can multiple services share config?
**Answer:** Yes, use `application.yml` for common config, service-specific files for overrides.

### Q17: What is composite configuration?
**Answer:** Combining multiple sources (Git + Vault + Native) in priority order.

### Q18: How to handle config refresh in distributed system?
**Answer:** Use Spring Cloud Bus to broadcast refresh to all service instances.

### Q19: Config Server alternatives?
**Answer:** Consul, etcd, AWS Parameter Store, Azure App Configuration, Kubernetes ConfigMaps.

### Q20: How to test Config Server locally?
**Answer:** Run server on 8888, create local Git repo, configure client, verify /actuator/refresh works.

---

## üìö Summary

### Architecture

```
Git Repository
    ‚Üì
Config Server (8888)
    ‚îú‚îÄ /encrypt, /decrypt
    ‚îú‚îÄ /{app}/{profile}/{label}
    ‚îî‚îÄ /actuator/refresh
    ‚Üì
Clients (8081, 8082, ...)
    ‚îú‚îÄ bootstrap.yml
    ‚îú‚îÄ @RefreshScope
    ‚îî‚îÄ /actuator/refresh
```

### Essential Configuration

**Server:**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/config-repo
          default-label: main

encrypt:
  key: ${ENCRYPT_KEY}
```

**Client:**
```yaml
spring:
  application:
    name: order-service
  cloud:
    config:
      uri: http://localhost:8888
      fail-fast: true
  profiles:
    active: dev
```

### Common Patterns

```java
// Configuration properties
@ConfigurationProperties(prefix = "order")
@RefreshScope
public class OrderProperties { }

// Refresh
curl -X POST http://localhost:8081/actuator/refresh

// Bus refresh (all services)
curl -X POST http://localhost:8888/actuator/busrefresh
```

**Next:** Cloud Gateway ‚Üí

