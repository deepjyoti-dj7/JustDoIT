# üì° Cloud Bus - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Setup](#setup)
- [Configuration Refresh](#configuration-refresh)
- [Custom Events](#custom-events)
- [RabbitMQ Backend](#rabbitmq-backend)
- [Kafka Backend](#kafka-backend)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Spring Cloud Bus** links distributed system nodes with a lightweight message broker, enabling broadcast of state changes (e.g., configuration updates).

### Architecture

```
Config Server ‚Üí Push to Git
      ‚Üì
Webhook/Manual Trigger
      ‚Üì
POST /actuator/busrefresh
      ‚Üì
Message Broker (RabbitMQ/Kafka)
      ‚Üì
  ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚Üì       ‚Üì       ‚Üì       ‚Üì
Service1 Service2 Service3 Service4
  (All instances refresh configuration)
```

---

## üöÄ Setup

### Maven Dependencies (RabbitMQ)

```xml
<dependencies>
    <!-- Cloud Bus AMQP -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-bus-amqp</artifactId>
    </dependency>
    
    <!-- Config Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    
    <!-- Actuator -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

### Configuration

```yaml
spring:
  application:
    name: order-service
  
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
  
  cloud:
    bus:
      enabled: true
      refresh:
        enabled: true
      trace:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: busrefresh,busenv,health,info
```

---

## üîÑ Configuration Refresh

### Manual Refresh (All Services)

```bash
# Refresh all service instances
curl -X POST http://localhost:8888/actuator/busrefresh

# OR from any service instance
curl -X POST http://localhost:8081/actuator/busrefresh
```

### Selective Refresh (Specific Service)

```bash
# Refresh only order-service instances
curl -X POST http://localhost:8888/actuator/busrefresh?destination=order-service:**

# Refresh specific instance
curl -X POST http://localhost:8888/actuator/busrefresh?destination=order-service:8081
```

### Configuration

```java
@Component
@ConfigurationProperties(prefix = "order")
@RefreshScope
@Data
public class OrderProperties {
    private int maxItems;
    private long timeout;
    private boolean enableCache;
}
```

---

## üé® Custom Events

### Creating Custom Event

```java
public class OrderCreatedEvent extends RemoteApplicationEvent {
    
    private String orderId;
    private String customerId;
    private BigDecimal total;
    
    // Required for deserialization
    public OrderCreatedEvent() {
    }
    
    public OrderCreatedEvent(Object source, String originService, 
                            String orderId, String customerId, BigDecimal total) {
        super(source, originService);
        this.orderId = orderId;
        this.customerId = customerId;
        this.total = total;
    }
    
    // Getters and setters
}
```

### Publishing Event

```java
@Service
public class OrderService {
    
    @Autowired
    private ApplicationContext context;
    
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // Publish event to bus
        OrderCreatedEvent event = new OrderCreatedEvent(
            this,
            context.getId(),  // Origin service
            order.getId(),
            order.getCustomerId(),
            order.getTotal()
        );
        
        context.publishEvent(event);
        
        return order;
    }
}
```

### Consuming Event

```java
@Component
public class OrderEventListener {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        log.info("Received OrderCreatedEvent from {}: orderId={}",
            event.getOriginService(),
            event.getOrderId());
        
        // Process event
        processNewOrder(event.getOrderId(), event.getCustomerId());
    }
}
```

---

## üê∞ RabbitMQ Backend

### RabbitMQ Setup

**Docker:**

```bash
docker run -d --name rabbitmq \
  -p 5672:5672 \
  -p 15672:15672 \
  rabbitmq:3-management
```

**Access Management UI:** `http://localhost:15672` (guest/guest)

### Configuration

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    
    # Connection settings
    connection-timeout: 10000
    
    # Producer settings
    template:
      retry:
        enabled: true
        initial-interval: 1000
        max-attempts: 3
        multiplier: 2
    
    # Consumer settings
    listener:
      simple:
        acknowledge-mode: auto
        concurrency: 1
        max-concurrency: 5
        retry:
          enabled: true
          max-attempts: 3
  
  cloud:
    bus:
      enabled: true
      refresh:
        enabled: true
      destination: springCloudBus  # Exchange name
```

### Advanced RabbitMQ Config

```java
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public Jackson2JsonMessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
    
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(messageConverter());
        template.setConfirmCallback((correlationData, ack, cause) -> {
            if (ack) {
                log.info("Message delivered successfully");
            } else {
                log.error("Message delivery failed: {}", cause);
            }
        });
        return template;
    }
}
```

---

## üì® Kafka Backend

### Maven Dependencies

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-kafka</artifactId>
</dependency>
```

### Configuration

```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    
    consumer:
      group-id: cloud-bus-group
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.ByteArrayDeserializer
      auto-offset-reset: earliest
    
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.ByteArraySerializer
      acks: all
  
  cloud:
    bus:
      enabled: true
      kafka:
        binder:
          brokers: localhost:9092
      destination: springCloudBus  # Topic name
```

---

## üöÄ Advanced Features

### Environment Update

```bash
# Update environment variable across all services
curl -X POST http://localhost:8888/actuator/busenv \
  -H "Content-Type: application/json" \
  -d '{"name":"order.max-items","value":"200"}'
```

### Trace Events

```yaml
spring:
  cloud:
    bus:
      trace:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: bustrace
```

**Access traces:**

```bash
curl http://localhost:8081/actuator/bustrace
```

### Event Filtering

```java
@Component
public class CustomEventFilter implements ApplicationListener<RemoteApplicationEvent> {
    
    @Override
    public void onApplicationEvent(RemoteApplicationEvent event) {
        if (event instanceof OrderCreatedEvent) {
            OrderCreatedEvent orderEvent = (OrderCreatedEvent) event;
            
            // Filter based on criteria
            if (orderEvent.getTotal().compareTo(BigDecimal.valueOf(1000)) > 0) {
                log.info("High-value order detected: {}", orderEvent.getOrderId());
                // Process high-value orders differently
            }
        }
    }
}
```

### Custom Destination

```java
public class PriorityOrderEvent extends RemoteApplicationEvent {
    
    public PriorityOrderEvent(Object source, String originService) {
        super(source, originService, "priority-orders:**");  // Custom destination
    }
}
```

### Monitoring

```java
@Component
public class BusEventMonitor {
    
    @EventListener
    public void onRefreshRemoteApplicationEvent(RefreshRemoteApplicationEvent event) {
        log.info("Configuration refresh event from: {}", event.getOriginService());
    }
    
    @EventListener
    public void onEnvironmentChangeRemoteEvent(EnvironmentChangeRemoteApplicationEvent event) {
        log.info("Environment change event: {}", event.getKeys());
    }
    
    @EventListener
    public void onAckRemoteApplicationEvent(AckRemoteApplicationEvent event) {
        log.info("Acknowledgment from: {}", event.getOriginService());
    }
}
```

---

## üîß Integration with Config Server

### Config Server Setup

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
  
  rabbitmq:
    host: localhost
    port: 5672
  
  cloud:
    config:
      server:
        git:
          uri: https://github.com/org/config-repo
    
    bus:
      enabled: true

management:
  endpoints:
    web:
      exposure:
        include: busrefresh
```

### GitHub Webhook

```java
@RestController
@RequestMapping("/webhook")
public class GitWebhookController {
    
    @Autowired
    private BusRefreshEndpoint busRefreshEndpoint;
    
    @PostMapping("/github")
    public ResponseEntity<?> handleGitWebhook(@RequestBody Map<String, Object> payload) {
        String ref = (String) payload.get("ref");
        
        if ("refs/heads/main".equals(ref)) {
            // Trigger bus refresh
            busRefreshEndpoint.busRefresh(null);
            
            return ResponseEntity.ok(Map.of(
                "message", "Configuration refreshed across all services",
                "timestamp", Instant.now()
            ));
        }
        
        return ResponseEntity.ok("No action required");
    }
}
```

**GitHub Webhook Configuration:**

```
Payload URL: http://your-server/webhook/github
Content type: application/json
Events: Just the push event
```

---

## üí° Best Practices

### 1. Use Selective Refresh

```bash
# ‚úÖ Good - Refresh only affected services
curl -X POST http://localhost:8888/actuator/busrefresh?destination=order-service:**

# ‚ùå Bad - Refresh all services unnecessarily
curl -X POST http://localhost:8888/actuator/busrefresh
```

### 2. Enable Tracing

```yaml
# ‚úÖ Good - Enable trace for debugging
spring:
  cloud:
    bus:
      trace:
        enabled: true

# ‚ùå Bad - No visibility into events
```

### 3. Secure Endpoints

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/busrefresh").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic();
        
        return http.build();
    }
}
```

### 4. Handle Event Failures

```java
@Component
public class ResilientEventListener {
    
    @EventListener
    @Retry(name = "busEvents", fallbackMethod = "fallback")
    public void handleOrderCreated(OrderCreatedEvent event) {
        processOrder(event);
    }
    
    private void fallback(OrderCreatedEvent event, Exception ex) {
        log.error("Failed to process order event: {}", ex.getMessage());
        // Store for retry or manual processing
    }
}
```

### 5. Monitor Message Broker

```yaml
# ‚úÖ Good - Monitor RabbitMQ/Kafka health
management:
  health:
    rabbit:
      enabled: true
    kafka:
      enabled: true
```

---

## üé§ Interview Questions

### Q1: What is Spring Cloud Bus?
**Answer:** Links distributed services with message broker for broadcasting state changes.

### Q2: Why use Cloud Bus?
**Answer:** Broadcast configuration refresh, custom events to all service instances simultaneously.

### Q3: How does Cloud Bus work?
**Answer:** Uses message broker (RabbitMQ/Kafka) to broadcast events to all connected services.

### Q4: What is /actuator/busrefresh?
**Answer:** Endpoint triggering configuration refresh across all services via Cloud Bus.

### Q5: RabbitMQ vs Kafka for Cloud Bus?
**Answer:** RabbitMQ: Simpler setup, lower throughput. Kafka: Higher throughput, more complex.

### Q6: What is destination parameter?
**Answer:** Filters which services receive event (e.g., `order-service:**`).

### Q7: Can you send custom events?
**Answer:** Yes, extend `RemoteApplicationEvent` and publish via `ApplicationContext`.

### Q8: What is RefreshRemoteApplicationEvent?
**Answer:** Event broadcast when configuration refresh triggered via /busrefresh.

### Q9: How to secure busrefresh endpoint?
**Answer:** Use Spring Security to require authentication/authorization.

### Q10: What is bus trace?
**Answer:** Records all bus events for debugging (`/actuator/bustrace`).

### Q11: Can you refresh specific instances?
**Answer:** Yes, use destination parameter: `?destination=service:instance-id`.

### Q12: What is AckRemoteApplicationEvent?
**Answer:** Acknowledgment event sent by services confirming event receipt.

### Q13: How to handle event failures?
**Answer:** Use @Retry, implement fallback methods, dead letter queues.

### Q14: Cloud Bus vs direct HTTP calls?
**Answer:** Cloud Bus: Scalable, decoupled. HTTP: Manual, requires service discovery.

### Q15: Can you use Cloud Bus without Config Server?
**Answer:** Yes, for broadcasting any custom events across services.

### Q16: What is springCloudBus?
**Answer:** Default exchange (RabbitMQ) or topic (Kafka) name for Cloud Bus events.

### Q17: How to monitor Cloud Bus?
**Answer:** Enable trace, monitor message broker health, log event listeners.

### Q18: Cloud Bus alternatives?
**Answer:** Direct HTTP calls, Kubernetes ConfigMaps reload, service mesh.

### Q19: Performance impact of Cloud Bus?
**Answer:** Minimal - async event propagation, depends on message broker throughput.

### Q20: Best practices for Cloud Bus?
**Answer:** Use selective refresh, enable tracing, secure endpoints, handle failures, monitor broker.

---

## üìö Summary

### Key Concepts

```
Cloud Bus:
‚îú‚îÄ Message broker integration
‚îú‚îÄ Event broadcasting
‚îî‚îÄ Configuration refresh

Components:
‚îú‚îÄ RabbitMQ/Kafka backend
‚îú‚îÄ /actuator/busrefresh endpoint
‚îú‚îÄ RemoteApplicationEvent
‚îî‚îÄ Destination filtering

Use Cases:
‚îú‚îÄ Configuration refresh
‚îú‚îÄ Custom event broadcasting
‚îú‚îÄ Cluster-wide updates
‚îî‚îÄ Service coordination
```

### Configuration Template

```yaml
spring:
  rabbitmq:
    host: localhost
    port: 5672
  cloud:
    bus:
      enabled: true
      refresh:
        enabled: true

management:
  endpoints:
    web:
      exposure:
        include: busrefresh
```

### Usage Pattern

```bash
# Refresh all services
curl -X POST http://localhost:8888/actuator/busrefresh

# Refresh specific service
curl -X POST http://localhost:8888/actuator/busrefresh?destination=order-service:**
```

**Next:** Complete Spring Cloud Module ‚Üí

