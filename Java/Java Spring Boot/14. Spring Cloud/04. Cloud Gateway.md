# üåê Cloud Gateway - Complete Guide

## üìã Table of Contents
- [Introduction](#introduction)
- [Gateway Setup](#gateway-setup)
- [Route Configuration](#route-configuration)
- [Predicates](#predicates)
- [Filters](#filters)
- [Security](#security)
- [Advanced Features](#advanced-features)
- [Best Practices](#best-practices)
- [Interview Questions](#interview-questions)

---

## üéØ Introduction

**Spring Cloud Gateway** is an API Gateway built on Spring WebFlux, providing routing, filtering, rate limiting, and more for microservices.

### Architecture

```
Client Requests
      ‚Üì
API Gateway (8080)
  ‚îú‚îÄ Route Matching (Predicates)
  ‚îú‚îÄ Pre-Filters
  ‚îú‚îÄ Forward to Service
  ‚îú‚îÄ Post-Filters
  ‚îî‚îÄ Response to Client
```

---

## üñ•Ô∏è Gateway Setup

### Maven Dependencies

```xml
<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    
    <!-- Eureka Client (for service discovery) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    
    <!-- Circuit Breaker -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
    </dependency>
    
    <!-- Redis for rate limiting -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
</dependencies>
```

### Application Class

```java
package com.example.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class GatewayApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(GatewayApplication.class, args);
    }
}
```

---

## üõ£Ô∏è Route Configuration

### YAML Configuration

```yaml
server:
  port: 8080

spring:
  application:
    name: api-gateway
  
  cloud:
    gateway:
      # Discovery locator (automatic routes)
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
      
      # Manual routes
      routes:
        # Order Service
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - RewritePath=/api/orders/(?<segment>.*), /$\{segment}
            - AddRequestHeader=X-Request-Source, api-gateway
        
        # Payment Service
        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payments/**
          filters:
            - StripPrefix=1
        
        # Product Service with specific method
        - id: product-service-get
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
            - Method=GET
          filters:
            - AddResponseHeader=X-Response-From, product-service

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

### Java Configuration

```java
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // Order Service
            .route("order-service", r -> r
                .path("/api/orders/**")
                .filters(f -> f
                    .rewritePath("/api/orders/(?<segment>.*)", "/${segment}")
                    .addRequestHeader("X-Request-Source", "api-gateway")
                    .circuitBreaker(c -> c
                        .setName("orderCircuitBreaker")
                        .setFallbackUri("forward:/fallback/orders")
                    )
                )
                .uri("lb://order-service")
            )
            
            // Payment Service
            .route("payment-service", r -> r
                .path("/api/payments/**")
                .filters(f -> f
                    .stripPrefix(1)
                    .retry(retryConfig -> retryConfig
                        .setRetries(3)
                        .setStatuses(HttpStatus.INTERNAL_SERVER_ERROR)
                    )
                )
                .uri("lb://payment-service")
            )
            
            // Product Service (GET only)
            .route("product-service-get", r -> r
                .path("/api/products/**")
                .and()
                .method(HttpMethod.GET)
                .filters(f -> f
                    .addResponseHeader("X-Response-From", "product-service")
                )
                .uri("lb://product-service")
            )
            
            .build();
    }
}
```

---

## üéØ Predicates

### Built-in Predicates

```yaml
spring:
  cloud:
    gateway:
      routes:
        # Path Predicate
        - id: path-route
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**,/orders/**
        
        # Method Predicate
        - id: method-route
          uri: lb://order-service
          predicates:
            - Method=GET,POST
        
        # Header Predicate
        - id: header-route
          uri: lb://order-service
          predicates:
            - Header=X-Request-Id, \d+
        
        # Query Predicate
        - id: query-route
          uri: lb://order-service
          predicates:
            - Query=color, green
        
        # Cookie Predicate
        - id: cookie-route
          uri: lb://order-service
          predicates:
            - Cookie=session, abc.*
        
        # Host Predicate
        - id: host-route
          uri: lb://order-service
          predicates:
            - Host=**.example.com
        
        # Before/After/Between Predicates
        - id: time-route
          uri: lb://order-service
          predicates:
            - After=2024-01-01T00:00:00+00:00[UTC]
            - Before=2024-12-31T23:59:59+00:00[UTC]
        
        # Weight Predicate (A/B testing)
        - id: weight-route-1
          uri: lb://order-service-v1
          predicates:
            - Weight=group1, 8
        
        - id: weight-route-2
          uri: lb://order-service-v2
          predicates:
            - Weight=group1, 2
```

### Custom Predicate

```java
@Component
public class CustomHeaderRoutePredicateFactory 
        extends AbstractRoutePredicateFactory<CustomHeaderRoutePredicateFactory.Config> {
    
    public CustomHeaderRoutePredicateFactory() {
        super(Config.class);
    }
    
    @Override
    public Predicate<ServerWebExchange> apply(Config config) {
        return exchange -> {
            List<String> headerValues = exchange.getRequest()
                .getHeaders()
                .get(config.getHeaderName());
            
            if (headerValues == null || headerValues.isEmpty()) {
                return false;
            }
            
            return headerValues.stream()
                .anyMatch(value -> value.contains(config.getHeaderValue()));
        };
    }
    
    public static class Config {
        private String headerName;
        private String headerValue;
        
        // Getters and setters
    }
}
```

---

## üîß Filters

### Built-in Filters

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: filter-examples
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            # Add/Remove Headers
            - AddRequestHeader=X-Request-Id, ${random.uuid}
            - AddResponseHeader=X-Response-Time, ${T(System).currentTimeMillis()}
            - RemoveRequestHeader=Cookie
            - RemoveResponseHeader=Set-Cookie
            
            # Path Manipulation
            - StripPrefix=1  # Remove first path segment
            - PrefixPath=/api
            - RewritePath=/api/orders/(?<segment>.*), /$\{segment}
            
            # Request Size Limit
            - name: RequestSize
              args:
                maxSize: 5MB
            
            # Circuit Breaker
            - name: CircuitBreaker
              args:
                name: orderCircuitBreaker
                fallbackUri: forward:/fallback/orders
            
            # Retry
            - name: Retry
              args:
                retries: 3
                statuses: INTERNAL_SERVER_ERROR,BAD_GATEWAY
                methods: GET,POST
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
            
            # Rate Limiter (Redis required)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                redis-rate-limiter.requestedTokens: 1
                key-resolver: "#{@userKeyResolver}"
```

### Custom Filter (Global)

```java
@Component
public class LoggingGlobalFilter implements GlobalFilter, Ordered {
    
    private static final Logger log = LoggerFactory.getLogger(LoggingGlobalFilter.class);
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        log.info("Request: {} {}", request.getMethod(), request.getURI());
        
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            ServerHttpResponse response = exchange.getResponse();
            log.info("Response: {}", response.getStatusCode());
        }));
    }
    
    @Override
    public int getOrder() {
        return -1;  // High priority
    }
}
```

### Custom Filter (Route-specific)

```java
@Component
public class AuthenticationGatewayFilterFactory 
        extends AbstractGatewayFilterFactory<AuthenticationGatewayFilterFactory.Config> {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    public AuthenticationGatewayFilterFactory() {
        super(Config.class);
    }
    
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            
            if (!request.getHeaders().containsKey(HttpHeaders.AUTHORIZATION)) {
                throw new UnauthorizedException("Missing authorization header");
            }
            
            String token = request.getHeaders()
                .getFirst(HttpHeaders.AUTHORIZATION)
                .replace("Bearer ", "");
            
            if (!tokenProvider.validateToken(token)) {
                throw new UnauthorizedException("Invalid token");
            }
            
            String userId = tokenProvider.getUserIdFromToken(token);
            
            ServerHttpRequest modifiedRequest = request.mutate()
                .header("X-User-Id", userId)
                .build();
            
            return chain.filter(exchange.mutate().request(modifiedRequest).build());
        };
    }
    
    public static class Config {
        // Configuration properties if needed
    }
}
```

---

## üîê Security

### JWT Authentication

```java
@Component
public class JwtAuthenticationFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private JwtTokenProvider tokenProvider;
    
    private final List<String> excludedPaths = List.of(
        "/api/auth/login",
        "/api/auth/register",
        "/actuator/health"
    );
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getURI().getPath();
        
        // Skip authentication for excluded paths
        if (excludedPaths.stream().anyMatch(path::startsWith)) {
            return chain.filter(exchange);
        }
        
        // Extract token
        String token = extractToken(request);
        
        if (token == null || !tokenProvider.validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        
        // Add user info to headers
        Claims claims = tokenProvider.getClaimsFromToken(token);
        ServerHttpRequest modifiedRequest = request.mutate()
            .header("X-User-Id", claims.getSubject())
            .header("X-User-Roles", claims.get("roles", String.class))
            .build();
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }
    
    private String extractToken(ServerHttpRequest request) {
        String bearerToken = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        
        return null;
    }
    
    @Override
    public int getOrder() {
        return -100;  // High priority
    }
}
```

### Rate Limiting

```java
@Configuration
public class RateLimiterConfig {
    
    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> Mono.just(
            exchange.getRequest()
                .getHeaders()
                .getFirst("X-User-Id")
        );
    }
    
    @Bean
    public KeyResolver ipKeyResolver() {
        return exchange -> Mono.just(
            exchange.getRequest()
                .getRemoteAddress()
                .getAddress()
                .getHostAddress()
        );
    }
}
```

```yaml
spring:
  redis:
    host: localhost
    port: 6379
  
  cloud:
    gateway:
      routes:
        - id: rate-limited-route
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10    # requests per second
                redis-rate-limiter.burstCapacity: 20     # max burst
                key-resolver: "#{@userKeyResolver}"
```

### CORS Configuration

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration corsConfig = new CorsConfiguration();
        corsConfig.setAllowedOrigins(List.of("http://localhost:3000", "https://example.com"));
        corsConfig.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        corsConfig.setAllowedHeaders(List.of("*"));
        corsConfig.setAllowCredentials(true);
        corsConfig.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", corsConfig);
        
        return new CorsWebFilter(source);
    }
}
```

---

## üöÄ Advanced Features

### Circuit Breaker Integration

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: order-service-cb
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: CircuitBreaker
              args:
                name: orderCircuitBreaker
                fallbackUri: forward:/fallback/orders

resilience4j:
  circuitbreaker:
    instances:
      orderCircuitBreaker:
        sliding-window-size: 10
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000
        permitted-number-of-calls-in-half-open-state: 3
```

```java
@RestController
@RequestMapping("/fallback")
public class FallbackController {
    
    @GetMapping("/orders")
    public Mono<ResponseEntity<Map<String, Object>>> orderFallback() {
        return Mono.just(ResponseEntity.ok(Map.of(
            "message", "Order service temporarily unavailable",
            "status", "fallback"
        )));
    }
}
```

### Request/Response Modification

```java
@Component
public class ModifyRequestBodyFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return DataBufferUtils.join(exchange.getRequest().getBody())
            .flatMap(dataBuffer -> {
                byte[] bytes = new byte[dataBuffer.readableByteCount()];
                dataBuffer.read(bytes);
                DataBufferUtils.release(dataBuffer);
                
                String body = new String(bytes, StandardCharsets.UTF_8);
                
                // Modify request body
                String modifiedBody = modifyRequestBody(body);
                
                ServerHttpRequest mutatedRequest = new ServerHttpRequestDecorator(
                    exchange.getRequest()) {
                    
                    @Override
                    public Flux<DataBuffer> getBody() {
                        return Flux.just(exchange.getResponse()
                            .bufferFactory()
                            .wrap(modifiedBody.getBytes()));
                    }
                };
                
                return chain.filter(exchange.mutate()
                    .request(mutatedRequest)
                    .build());
            });
    }
    
    private String modifyRequestBody(String body) {
        // Modify logic
        return body;
    }
    
    @Override
    public int getOrder() {
        return -2;
    }
}
```

### Response Caching

```java
@Component
public class ResponseCacheFilter implements GlobalFilter, Ordered {
    
    @Autowired
    private ReactiveRedisTemplate<String, String> redisTemplate;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        if (!request.getMethod().equals(HttpMethod.GET)) {
            return chain.filter(exchange);
        }
        
        String cacheKey = generateCacheKey(request);
        
        return redisTemplate.opsForValue()
            .get(cacheKey)
            .flatMap(cachedResponse -> {
                // Return cached response
                ServerHttpResponse response = exchange.getResponse();
                response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
                
                DataBuffer buffer = response.bufferFactory()
                    .wrap(cachedResponse.getBytes());
                
                return response.writeWith(Mono.just(buffer));
            })
            .switchIfEmpty(Mono.defer(() -> {
                // Cache miss - proceed with request
                return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        // Cache response (pseudo-code)
                        // In reality, need to capture response body
                    }));
            }));
    }
    
    private String generateCacheKey(ServerHttpRequest request) {
        return request.getURI().getPath() + ":" + request.getQueryParams();
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}
```

---

## üí° Best Practices

### 1. Use Service Discovery

```yaml
# ‚úÖ Good - Use service name with load balancer
uri: lb://order-service

# ‚ùå Bad - Hardcode URL
uri: http://localhost:8081
```

### 2. Implement Circuit Breakers

```yaml
# ‚úÖ Good - Add circuit breaker
filters:
  - name: CircuitBreaker
    args:
      name: orderCB
      fallbackUri: forward:/fallback

# ‚ùå Bad - No fault tolerance
```

### 3. Add Authentication Early

```java
// ‚úÖ Good - Global filter with high priority
@Override
public int getOrder() {
    return -100;  // Execute early
}
```

### 4. Configure Timeouts

```yaml
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
```

### 5. Enable Logging

```yaml
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    reactor.netty.http.client: DEBUG
```

---

## üé§ Interview Questions

### Q1: What is Spring Cloud Gateway?
**Answer:** API Gateway built on Spring WebFlux for routing, filtering, and resilience in microservices.

### Q2: Gateway vs Zuul?
**Answer:** Gateway: Reactive (WebFlux), modern, maintained. Zuul 1: Blocking (Servlet), deprecated.

### Q3: What are predicates?
**Answer:** Conditions to match routes (Path, Method, Header, Query, Cookie, Time, Weight).

### Q4: What are filters?
**Answer:** Modify request/response (headers, path, authentication, rate limiting, circuit breaker).

### Q5: Global vs Route filters?
**Answer:** Global: Apply to all routes. Route: Apply to specific routes.

### Q6: How to implement authentication?
**Answer:** Create GlobalFilter, extract JWT, validate, add user info to headers.

### Q7: What is lb:// URI scheme?
**Answer:** Load-balanced URI using service discovery to route to service instances.

### Q8: How to implement rate limiting?
**Answer:** Use RequestRateLimiter filter with Redis, define replenishRate and burstCapacity.

### Q9: What is circuit breaker in Gateway?
**Answer:** Filter that stops routing to failing service, returns fallback response.

### Q10: How to handle CORS?
**Answer:** Create CorsWebFilter bean with allowed origins, methods, headers.

### Q11: What is StripPrefix filter?
**Answer:** Removes specified number of path segments before forwarding (e.g., /api/orders ‚Üí /orders).

### Q12: How to modify request body?
**Answer:** Implement GlobalFilter, read body with DataBufferUtils, modify, create new request.

### Q13: What is weight predicate?
**Answer:** Route percentage of traffic to different services (A/B testing, canary deployments).

### Q14: How to secure Gateway?
**Answer:** JWT authentication, rate limiting, CORS, HTTPS, API keys.

### Q15: What is fallbackUri?
**Answer:** URI to forward when circuit breaker opens or service fails.

### Q16: How to log requests/responses?
**Answer:** Implement GlobalFilter, log in filter method, set order for execution priority.

### Q17: Can Gateway modify responses?
**Answer:** Yes, use ModifyResponseBodyGatewayFilterFactory or custom filter.

### Q18: What is KeyResolver in rate limiting?
**Answer:** Bean determining rate limit key (user ID, IP address, API key).

### Q19: How to configure timeouts?
**Answer:** Set `spring.cloud.gateway.httpclient.response-timeout` and `connect-timeout`.

### Q20: Gateway alternatives?
**Answer:** Kong, Nginx, Traefik, AWS API Gateway, Envoy.

---

## üìö Summary

### Key Components

```
Predicates: Route matching
‚îú‚îÄ Path, Method, Header
‚îú‚îÄ Query, Cookie, Host
‚îî‚îÄ Time, Weight

Filters: Request/Response modification
‚îú‚îÄ AddRequestHeader, AddResponseHeader
‚îú‚îÄ RewritePath, StripPrefix
‚îú‚îÄ CircuitBreaker, Retry
‚îú‚îÄ RequestRateLimiter
‚îî‚îÄ Custom filters

Features:
‚îú‚îÄ Service Discovery (lb://)
‚îú‚îÄ Circuit Breaker integration
‚îú‚îÄ JWT Authentication
‚îú‚îÄ Rate Limiting (Redis)
‚îî‚îÄ CORS
```

### Essential Configuration

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: service-name
          uri: lb://service-name
          predicates:
            - Path=/api/**
          filters:
            - StripPrefix=1
            - CircuitBreaker
```

**Next:** Feign Client ‚Üí

