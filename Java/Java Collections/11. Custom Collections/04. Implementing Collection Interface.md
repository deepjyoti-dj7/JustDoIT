# üé® Implementing Collection Interface

## üìñ Overview

Implementing the **Collection interface** allows creating custom collections with standard behavior. Key concepts:
- **Interface contract** - Define required methods
- **Custom behavior** - Tailor to specific needs
- **Interoperability** - Works with Collections framework
- **Type safety** - Generic implementation

```java
public class CustomCollection<E> implements Collection<E> {
    private List<E> elements;
    
    // Implement all Collection interface methods
}
```

---

## ‚≠ê Required Methods

1. **size()** - Return number of elements
2. **isEmpty()** - Check if empty
3. **contains(Object)** - Check if element exists
4. **iterator()** - Return iterator
5. **toArray()** - Convert to array
6. **add(E)** - Add element
7. **remove(Object)** - Remove element
8. **clear()** - Remove all elements
9. **containsAll()** - Check if contains all
10. **addAll()** - Add all elements
11. **removeAll()** - Remove all elements
12. **retainAll()** - Keep only specified elements

---

## üíª Basic Implementation

```java
import java.util.*;

public class CustomCollection<E> implements Collection<E> {
    
    private List<E> elements;
    
    // Constructor
    public CustomCollection() {
        this.elements = new ArrayList<>();
    }
    
    public CustomCollection(Collection<? extends E> c) {
        this.elements = new ArrayList<>(c);
    }
    
    // 1. Size
    @Override
    public int size() {
        return elements.size();
    }
    
    // 2. Is empty
    @Override
    public boolean isEmpty() {
        return elements.isEmpty();
    }
    
    // 3. Contains element
    @Override
    public boolean contains(Object o) {
        return elements.contains(o);
    }
    
    // 4. Iterator
    @Override
    public Iterator<E> iterator() {
        return elements.iterator();
    }
    
    // 5. To array
    @Override
    public Object[] toArray() {
        return elements.toArray();
    }
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        return elements.toArray(a);
    }
    
    // 6. Add element
    @Override
    public boolean add(E e) {
        return elements.add(e);
    }
    
    // 7. Remove element
    @Override
    public boolean remove(Object o) {
        return elements.remove(o);
    }
    
    // 8. Contains all
    @Override
    public boolean containsAll(Collection<?> c) {
        return elements.containsAll(c);
    }
    
    // 9. Add all
    @Override
    public boolean addAll(Collection<? extends E> c) {
        return elements.addAll(c);
    }
    
    // 10. Remove all
    @Override
    public boolean removeAll(Collection<?> c) {
        return elements.removeAll(c);
    }
    
    // 11. Retain all
    @Override
    public boolean retainAll(Collection<?> c) {
        return elements.retainAll(c);
    }
    
    // 12. Clear
    @Override
    public void clear() {
        elements.clear();
    }
    
    // Override equals
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof CustomCollection)) return false;
        CustomCollection<?> that = (CustomCollection<?>) o;
        return elements.equals(that.elements);
    }
    
    // Override hashCode
    @Override
    public int hashCode() {
        return elements.hashCode();
    }
    
    // Override toString
    @Override
    public String toString() {
        return elements.toString();
    }
}
```

---

## üéØ Usage Example

```java
public class Main {
    public static void main(String[] args) {
        CustomCollection<String> collection = new CustomCollection<>();
        
        // Add elements
        collection.add("Alice");
        collection.add("Bob");
        collection.add("Charlie");
        System.out.println("Collection: " + collection);
        
        // Size
        System.out.println("Size: " + collection.size());
        
        // Contains
        System.out.println("Contains Alice: " + collection.contains("Alice"));
        
        // Add all
        Collection<String> more = Arrays.asList("David", "Eve");
        collection.addAll(more);
        System.out.println("After addAll: " + collection);
        
        // Remove
        collection.remove("Bob");
        System.out.println("After remove Bob: " + collection);
        
        // Iterator
        System.out.print("Iterate: ");
        for (String name : collection) {
            System.out.print(name + " ");
        }
        System.out.println();
        
        // To array
        Object[] array = collection.toArray();
        System.out.println("Array: " + Arrays.toString(array));
        
        // Clear
        collection.clear();
        System.out.println("After clear, isEmpty: " + collection.isEmpty());
    }
}
```

---

## üîç Custom Collection Example: UniqueCollection

```java
public class UniqueCollection<E> implements Collection<E> {
    
    private Set<E> elements;  // Use Set for uniqueness
    
    public UniqueCollection() {
        this.elements = new HashSet<>();
    }
    
    @Override
    public boolean add(E e) {
        // Only add if not already present
        if (elements.contains(e)) {
            System.out.println("Duplicate: " + e + " not added");
            return false;
        }
        return elements.add(e);
    }
    
    @Override
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E element : c) {
            if (add(element)) {
                modified = true;
            }
        }
        return modified;
    }
    
    // Implement other methods...
    @Override public int size() { return elements.size(); }
    @Override public boolean isEmpty() { return elements.isEmpty(); }
    @Override public boolean contains(Object o) { return elements.contains(o); }
    @Override public Iterator<E> iterator() { return elements.iterator(); }
    @Override public Object[] toArray() { return elements.toArray(); }
    @Override public <T> T[] toArray(T[] a) { return elements.toArray(a); }
    @Override public boolean remove(Object o) { return elements.remove(o); }
    @Override public boolean containsAll(Collection<?> c) { return elements.containsAll(c); }
    @Override public boolean removeAll(Collection<?> c) { return elements.removeAll(c); }
    @Override public boolean retainAll(Collection<?> c) { return elements.retainAll(c); }
    @Override public void clear() { elements.clear(); }
}
```

---

## üöÄ Advanced Custom Collections

### 1. LimitedSizeCollection
```java
public class LimitedSizeCollection<E> implements Collection<E> {
    
    private List<E> elements;
    private int maxSize;
    
    public LimitedSizeCollection(int maxSize) {
        this.elements = new ArrayList<>();
        this.maxSize = maxSize;
    }
    
    @Override
    public boolean add(E e) {
        if (elements.size() >= maxSize) {
            System.out.println("Collection full, cannot add: " + e);
            return false;
        }
        return elements.add(e);
    }
    
    // Other methods...
}
```

### 2. ObservableCollection
```java
public class ObservableCollection<E> implements Collection<E> {
    
    private List<E> elements;
    private List<CollectionListener<E>> listeners;
    
    public interface CollectionListener<E> {
        void onAdd(E element);
        void onRemove(E element);
    }
    
    public ObservableCollection() {
        this.elements = new ArrayList<>();
        this.listeners = new ArrayList<>();
    }
    
    public void addListener(CollectionListener<E> listener) {
        listeners.add(listener);
    }
    
    @Override
    public boolean add(E e) {
        boolean result = elements.add(e);
        if (result) {
            for (CollectionListener<E> listener : listeners) {
                listener.onAdd(e);
            }
        }
        return result;
    }
    
    @Override
    public boolean remove(Object o) {
        boolean result = elements.remove(o);
        if (result) {
            for (CollectionListener<E> listener : listeners) {
                listener.onRemove((E) o);
            }
        }
        return result;
    }
    
    // Other methods...
}
```

### 3. ImmutableCollection
```java
public class ImmutableCollection<E> implements Collection<E> {
    
    private List<E> elements;
    
    public ImmutableCollection(Collection<? extends E> c) {
        this.elements = new ArrayList<>(c);
    }
    
    @Override
    public boolean add(E e) {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    @Override
    public boolean remove(Object o) {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    @Override
    public boolean addAll(Collection<? extends E> c) {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    @Override
    public boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    @Override
    public boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    @Override
    public void clear() {
        throw new UnsupportedOperationException("Collection is immutable");
    }
    
    // Read-only methods work normally
    @Override public int size() { return elements.size(); }
    @Override public boolean isEmpty() { return elements.isEmpty(); }
    @Override public boolean contains(Object o) { return elements.contains(o); }
    @Override public Iterator<E> iterator() { return Collections.unmodifiableList(elements).iterator(); }
    @Override public Object[] toArray() { return elements.toArray(); }
    @Override public <T> T[] toArray(T[] a) { return elements.toArray(a); }
    @Override public boolean containsAll(Collection<?> c) { return elements.containsAll(c); }
}
```

### 4. FilteredCollection
```java
public class FilteredCollection<E> implements Collection<E> {
    
    private List<E> elements;
    private Predicate<E> filter;
    
    public FilteredCollection(Predicate<E> filter) {
        this.elements = new ArrayList<>();
        this.filter = filter;
    }
    
    @Override
    public boolean add(E e) {
        if (filter.test(e)) {
            return elements.add(e);
        } else {
            System.out.println("Element rejected by filter: " + e);
            return false;
        }
    }
    
    @Override
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E element : c) {
            if (add(element)) {
                modified = true;
            }
        }
        return modified;
    }
    
    // Other methods...
}
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Not implementing all methods**
```java
// ‚ùå Missing methods
public class MyCollection<E> implements Collection<E> {
    @Override
    public int size() { return 0; }
    // Other methods missing - won't compile!
}

// ‚úÖ Implement all required methods
public class MyCollection<E> implements Collection<E> {
    // All 12+ methods implemented
}
```

2. **Wrong return values**
```java
// ‚ùå Should return boolean indicating modification
@Override
public boolean add(E e) {
    elements.add(e);
    return true;  // Always true, even if duplicate not added
}

// ‚úÖ Return actual modification status
@Override
public boolean add(E e) {
    return elements.add(e);  // Actual result
}
```

3. **Not handling null properly**
```java
// ‚ùå NPE on null
@Override
public boolean contains(Object o) {
    for (E element : elements) {
        if (element.equals(o)) {  // NPE if element is null
            return true;
        }
    }
    return false;
}

// ‚úÖ Handle null
@Override
public boolean contains(Object o) {
    for (E element : elements) {
        if (Objects.equals(element, o)) {  // Safe
            return true;
        }
    }
    return false;
}
```

4. **Not overriding equals and hashCode**
```java
// ‚ùå Default object equality
public class MyCollection<E> implements Collection<E> {
    // Missing equals and hashCode
}

// ‚úÖ Override equals and hashCode
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof MyCollection)) return false;
    MyCollection<?> that = (MyCollection<?>) o;
    return elements.equals(that.elements);
}

@Override
public int hashCode() {
    return elements.hashCode();
}
```

---

## üí° Best Practices

1. **Use composition over inheritance**
```java
// ‚úÖ Delegate to existing collection
public class MyCollection<E> implements Collection<E> {
    private List<E> elements = new ArrayList<>();
    
    @Override
    public boolean add(E e) {
        return elements.add(e);
    }
}
```

2. **Provide constructors**
```java
// ‚úÖ Multiple constructors
public MyCollection() {
    this.elements = new ArrayList<>();
}

public MyCollection(int initialCapacity) {
    this.elements = new ArrayList<>(initialCapacity);
}

public MyCollection(Collection<? extends E> c) {
    this.elements = new ArrayList<>(c);
}
```

3. **Document custom behavior**
```java
/**
 * A collection that only accepts unique elements.
 * Duplicate additions return false and are logged.
 */
public class UniqueCollection<E> implements Collection<E> {
    // Implementation
}
```

4. **Implement Iterable for for-each**
```java
public class MyCollection<E> implements Collection<E> {
    @Override
    public Iterator<E> iterator() {
        return elements.iterator();
    }
}

// Usage
for (E element : myCollection) {
    // Works with for-each
}
```

---

## üìä Collection Interface Hierarchy

```
                    Iterable<E>
                        |
                  Collection<E>
                  /     |     \
                /       |       \
            List<E>  Set<E>  Queue<E>
              |        |         |
         ArrayList  HashSet  LinkedList
        LinkedList  TreeSet  PriorityQueue
```

**When to extend which interface:**
- **Collection** - Basic collection with no ordering guarantees
- **List** - Ordered, allows duplicates, indexed access
- **Set** - No duplicates, unique elements
- **Queue** - FIFO operations (add to end, remove from front)
- **Deque** - Double-ended queue, add/remove both ends

---

## üìö Interview Questions

**Q1: Why implement Collection interface?**
A: For interoperability with Collections framework, standard API, type safety, and custom behavior.

**Q2: Must implement all methods?**
A: Yes, but can throw UnsupportedOperationException for unsupported operations (e.g., immutable collections).

**Q3: Difference between Collection and Collections?**
A: Collection is interface. Collections is utility class with static methods (sort, reverse, etc.).

**Q4: When to extend vs implement?**
A: Extend (ArrayList, HashSet) for partial reuse. Implement (Collection) for full custom behavior.

**Q5: How to make collection immutable?**
A: Throw UnsupportedOperationException in add/remove/clear methods, or use Collections.unmodifiableCollection().

**Q6: What is fail-fast iterator?**
A: Throws ConcurrentModificationException if collection modified during iteration (except via iterator.remove()).

**Q7: Why two toArray methods?**
A: toArray() returns Object[]. toArray(T[]) returns typed array for type safety.

**Q8: Can Collection have null elements?**
A: Depends on implementation. ArrayList allows null, but some custom collections may not.

---

## üéØ Use Cases

1. **UniqueCollection** - Only unique elements
2. **LimitedSizeCollection** - Fixed capacity
3. **ObservableCollection** - Notify on changes
4. **FilteredCollection** - Accept only matching elements
5. **ImmutableCollection** - Read-only view
6. **SynchronizedCollection** - Thread-safe
7. **LoggingCollection** - Log all operations
8. **CachedCollection** - Cache queries

---

## üìö Summary

- **Collection interface**: Base interface for all collections
- **12 required methods**: size, isEmpty, contains, add, remove, clear, etc.
- **Custom behavior**: Tailor to specific needs (unique, limited, observable)
- **Composition**: Use existing collection internally
- **Interoperability**: Works with Collections framework
- **Best practices**: Override equals/hashCode, document behavior, handle null
- **Use cases**: Unique elements, size limits, filtering, immutability
- **Interface hierarchy**: Collection ‚Üí List/Set/Queue ‚Üí concrete implementations
