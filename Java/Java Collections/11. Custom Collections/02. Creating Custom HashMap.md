# üó∫Ô∏è Creating Custom HashMap

## üìñ Overview

Creating a **custom HashMap** demonstrates hash table implementation. Key concepts:
- **Hash function** - Convert key to array index
- **Buckets** - Array of linked lists for collision handling
- **Load factor** - Threshold for resizing (default 0.75)
- **Collision resolution** - Chaining with linked lists

```java
public class CustomHashMap<K, V> {
    private Entry<K, V>[] buckets;
    private int size;
    private static final int DEFAULT_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
}
```

---

## ‚≠ê Key Components

1. **Entry class** - Stores key-value pairs
2. **Hash function** - Maps keys to bucket indices
3. **Collision handling** - Chain entries in linked list
4. **Resizing** - Rehash when load factor exceeded
5. **put/get/remove** - Core operations

---

## üíª Basic Implementation

```java
public class CustomHashMap<K, V> {
    
    // Inner class for key-value pairs
    private static class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> next;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Entry<K, V>[] buckets;
    private int size;
    private int capacity;
    private static final int DEFAULT_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
    
    // Constructor
    @SuppressWarnings("unchecked")
    public CustomHashMap() {
        this.capacity = DEFAULT_CAPACITY;
        this.buckets = new Entry[capacity];
        this.size = 0;
    }
    
    @SuppressWarnings("unchecked")
    public CustomHashMap(int capacity) {
        this.capacity = capacity;
        this.buckets = new Entry[capacity];
        this.size = 0;
    }
    
    // Hash function
    private int hash(K key) {
        if (key == null) {
            return 0;
        }
        int hashCode = key.hashCode();
        return Math.abs(hashCode) % capacity;
    }
    
    // Put key-value pair
    public V put(K key, V value) {
        // Check load factor and resize if needed
        if (size >= capacity * LOAD_FACTOR) {
            resize();
        }
        
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        // Check if key exists (update value)
        while (entry != null) {
            if ((key == null && entry.key == null) || 
                (key != null && key.equals(entry.key))) {
                V oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
            entry = entry.next;
        }
        
        // Add new entry at beginning of chain
        Entry<K, V> newEntry = new Entry<>(key, value);
        newEntry.next = buckets[index];
        buckets[index] = newEntry;
        size++;
        
        return null;
    }
    
    // Get value by key
    public V get(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        while (entry != null) {
            if ((key == null && entry.key == null) || 
                (key != null && key.equals(entry.key))) {
                return entry.value;
            }
            entry = entry.next;
        }
        
        return null;
    }
    
    // Remove key-value pair
    public V remove(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        Entry<K, V> prev = null;
        
        while (entry != null) {
            if ((key == null && entry.key == null) || 
                (key != null && key.equals(entry.key))) {
                
                if (prev == null) {
                    // First entry in chain
                    buckets[index] = entry.next;
                } else {
                    // Remove from middle/end
                    prev.next = entry.next;
                }
                size--;
                return entry.value;
            }
            prev = entry;
            entry = entry.next;
        }
        
        return null;
    }
    
    // Contains key
    public boolean containsKey(K key) {
        return get(key) != null || 
               (get(key) == null && keyExists(key));
    }
    
    private boolean keyExists(K key) {
        int index = hash(key);
        Entry<K, V> entry = buckets[index];
        
        while (entry != null) {
            if ((key == null && entry.key == null) || 
                (key != null && key.equals(entry.key))) {
                return true;
            }
            entry = entry.next;
        }
        return false;
    }
    
    // Size
    public int size() {
        return size;
    }
    
    // Is empty
    public boolean isEmpty() {
        return size == 0;
    }
    
    // Clear
    @SuppressWarnings("unchecked")
    public void clear() {
        buckets = new Entry[capacity];
        size = 0;
    }
    
    // Resize and rehash
    @SuppressWarnings("unchecked")
    private void resize() {
        int newCapacity = capacity * 2;
        Entry<K, V>[] oldBuckets = buckets;
        buckets = new Entry[newCapacity];
        capacity = newCapacity;
        size = 0;
        
        // Rehash all entries
        for (Entry<K, V> entry : oldBuckets) {
            while (entry != null) {
                put(entry.key, entry.value);
                entry = entry.next;
            }
        }
    }
    
    // Get all keys
    public Set<K> keySet() {
        Set<K> keys = new HashSet<>();
        for (Entry<K, V> entry : buckets) {
            while (entry != null) {
                keys.add(entry.key);
                entry = entry.next;
            }
        }
        return keys;
    }
    
    // Get all values
    public Collection<V> values() {
        List<V> values = new ArrayList<>();
        for (Entry<K, V> entry : buckets) {
            while (entry != null) {
                values.add(entry.value);
                entry = entry.next;
            }
        }
        return values;
    }
    
    // Get all entries
    public Set<Map.Entry<K, V>> entrySet() {
        Set<Map.Entry<K, V>> entries = new HashSet<>();
        for (Entry<K, V> entry : buckets) {
            while (entry != null) {
                entries.add(new AbstractMap.SimpleEntry<>(entry.key, entry.value));
                entry = entry.next;
            }
        }
        return entries;
    }
    
    @Override
    public String toString() {
        if (isEmpty()) {
            return "{}";
        }
        
        StringBuilder sb = new StringBuilder("{");
        boolean first = true;
        
        for (Entry<K, V> entry : buckets) {
            while (entry != null) {
                if (!first) {
                    sb.append(", ");
                }
                sb.append(entry.key).append("=").append(entry.value);
                first = false;
                entry = entry.next;
            }
        }
        sb.append("}");
        return sb.toString();
    }
}
```

---

## üéØ Usage Example

```java
public class Main {
    public static void main(String[] args) {
        CustomHashMap<String, Integer> map = new CustomHashMap<>();
        
        // Put entries
        map.put("Alice", 25);
        map.put("Bob", 30);
        map.put("Charlie", 35);
        System.out.println(map);  // {Alice=25, Bob=30, Charlie=35}
        
        // Get value
        System.out.println("Alice age: " + map.get("Alice"));  // 25
        
        // Update value
        map.put("Alice", 26);
        System.out.println("Updated Alice: " + map.get("Alice"));  // 26
        
        // Contains key
        System.out.println("Contains Bob: " + map.containsKey("Bob"));  // true
        
        // Remove
        map.remove("Bob");
        System.out.println("After removing Bob: " + map);
        
        // Size
        System.out.println("Size: " + map.size());  // 2
        
        // Key set
        System.out.println("Keys: " + map.keySet());
        
        // Values
        System.out.println("Values: " + map.values());
    }
}
```

---

## üîç How Hashing Works

```
Key: "Alice" ‚Üí hashCode: 63412156 ‚Üí index: 63412156 % 16 = 12

Buckets Array:
[0] ‚Üí null
[1] ‚Üí null
...
[12] ‚Üí Entry("Alice", 25) ‚Üí Entry("Bob", 30) ‚Üí null  (collision chain)
[13] ‚Üí null
...
```

**Hash Function Steps:**
1. Get hashCode from key
2. Apply modulo with capacity: `Math.abs(hashCode) % capacity`
3. Store entry at computed index

---

## üîó Collision Handling

```java
// Multiple keys hash to same index
put("Alice", 25)  ‚Üí hash = 5
put("Charlie", 35) ‚Üí hash = 5  // Collision!

// Chaining: Store both in linked list at index 5
buckets[5] ‚Üí Entry("Alice", 25) ‚Üí Entry("Charlie", 35) ‚Üí null
```

**Collision Resolution:**
- **Chaining** - Linked list at each bucket
- Alternative: Open addressing (linear probing, quadratic probing)

---

## üöÄ Advanced Features

### 1. Load Factor Check
```java
private boolean needsResize() {
    return size >= capacity * LOAD_FACTOR;
}
```

### 2. Better Hash Function
```java
private int hash(K key) {
    if (key == null) return 0;
    
    int h = key.hashCode();
    // Spread bits for better distribution
    h ^= (h >>> 16);
    return Math.abs(h) % capacity;
}
```

### 3. putIfAbsent
```java
public V putIfAbsent(K key, V value) {
    V existing = get(key);
    if (existing == null && !containsKey(key)) {
        put(key, value);
        return null;
    }
    return existing;
}
```

### 4. Compute Methods
```java
public V computeIfAbsent(K key, Function<K, V> mappingFunction) {
    V value = get(key);
    if (value == null) {
        value = mappingFunction.apply(key);
        if (value != null) {
            put(key, value);
        }
    }
    return value;
}
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Poor hash function**
```java
// ‚ùå All keys go to same bucket
private int hash(K key) {
    return 0;  // Terrible hash!
}

// ‚úÖ Good distribution
private int hash(K key) {
    if (key == null) return 0;
    return Math.abs(key.hashCode()) % capacity;
}
```

2. **Not handling null keys**
```java
// ‚ùå NullPointerException
private int hash(K key) {
    return key.hashCode() % capacity;  // NPE if key is null
}

// ‚úÖ Handle null
private int hash(K key) {
    if (key == null) return 0;
    return Math.abs(key.hashCode()) % capacity;
}
```

3. **Forgetting to resize**
```java
// ‚ùå Performance degrades with many entries
public V put(K key, V value) {
    int index = hash(key);
    // Add entry without checking load factor
}

// ‚úÖ Check and resize
public V put(K key, V value) {
    if (size >= capacity * LOAD_FACTOR) {
        resize();
    }
    // Add entry
}
```

4. **Not rehashing on resize**
```java
// ‚ùå Old indices invalid after resize
private void resize() {
    capacity *= 2;
    Entry<K, V>[] newBuckets = new Entry[capacity];
    buckets = newBuckets;  // Old entries lost!
}

// ‚úÖ Rehash all entries
private void resize() {
    Entry<K, V>[] oldBuckets = buckets;
    capacity *= 2;
    buckets = new Entry[capacity];
    size = 0;
    
    for (Entry<K, V> entry : oldBuckets) {
        while (entry != null) {
            put(entry.key, entry.value);
            entry = entry.next;
        }
    }
}
```

---

## üí° Best Practices

1. **Choose good initial capacity**
```java
// ‚úÖ Reduce resizes if size is known
CustomHashMap<String, Integer> map = new CustomHashMap<>(1000);
```

2. **Use prime numbers for capacity**
```java
// ‚úÖ Better distribution
private static final int DEFAULT_CAPACITY = 17;  // Prime
```

3. **Implement proper equals and hashCode in keys**
```java
class Person {
    String name;
    int age;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

4. **Handle concurrent modification**
```java
// Add modification counter
private int modCount = 0;

public V put(K key, V value) {
    modCount++;
    // ... put logic
}

// Check in iterator
```

---

## üìä Performance Analysis

| Operation | Average | Worst Case | Notes |
|-----------|---------|-----------|-------|
| **put()** | O(1) | O(n) | O(n) with many collisions |
| **get()** | O(1) | O(n) | O(n) if all in one chain |
| **remove()** | O(1) | O(n) | O(n) with many collisions |
| **containsKey()** | O(1) | O(n) | Same as get() |
| **resize()** | O(n) | O(n) | Rehash all entries |

**Load Factor Impact:**
- **Lower** (0.5): Less collisions, more memory
- **Higher** (0.9): More collisions, less memory
- **Optimal** (0.75): Balance performance and memory

---

## üìö Interview Questions

**Q1: How does HashMap handle collisions?**
A: Chaining with linked lists. Java 8+ uses trees for long chains (>8 entries).

**Q2: Why is hashCode important?**
A: Determines bucket index. Poor hashCode causes collisions, degrading performance.

**Q3: Time complexity of put/get?**
A: O(1) average, O(n) worst case (all keys in one bucket).

**Q4: What is load factor?**
A: Ratio of size to capacity. Triggers resize when exceeded (default 0.75).

**Q5: Why resize at 0.75?**
A: Balance between performance (fewer collisions) and memory usage.

**Q6: Can HashMap have null keys?**
A: Yes, custom implementation can support one null key (at index 0).

**Q7: HashMap vs Hashtable?**
A: HashMap is not synchronized, allows null, better performance.

**Q8: How to make HashMap thread-safe?**
A: Use ConcurrentHashMap or Collections.synchronizedMap().

---

## üìö Summary

- **Hash table**: Array of buckets with linked lists
- **Hash function**: Maps keys to bucket indices
- **Collisions**: Handled by chaining (linked lists)
- **Load factor**: 0.75 triggers resize (double capacity)
- **Resizing**: Rehash all entries to new buckets
- **Performance**: O(1) average for put/get/remove
- **Key requirements**: Proper equals() and hashCode()
- **Use case**: Fast key-value lookups
