# üìù Creating Custom ArrayList

## üìñ Overview

Creating a **custom ArrayList** helps understand how dynamic arrays work internally. Key concepts:
- **Dynamic resizing** - Grow capacity when full
- **Array backing** - Use array to store elements
- **Index-based access** - O(1) get/set operations

```java
public class CustomArrayList<E> {
    private Object[] data;
    private int size;
    private static final int DEFAULT_CAPACITY = 10;
}
```

---

## ‚≠ê Key Features to Implement

1. **Dynamic resizing** - Grow when capacity reached
2. **Add/Remove elements** - At end or specific index
3. **Get/Set operations** - Random access
4. **Size tracking** - Current number of elements
5. **Capacity management** - Current array size
6. **Iterator support** - For enhanced for loop

---

## üíª Basic Implementation

```java
public class CustomArrayList<E> {
    private Object[] data;
    private int size;
    private static final int DEFAULT_CAPACITY = 10;
    
    // Constructor
    public CustomArrayList() {
        data = new Object[DEFAULT_CAPACITY];
        size = 0;
    }
    
    public CustomArrayList(int initialCapacity) {
        if (initialCapacity < 0) {
            throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
        }
        data = new Object[initialCapacity];
        size = 0;
    }
    
    // Add element at end
    public boolean add(E element) {
        ensureCapacity();
        data[size++] = element;
        return true;
    }
    
    // Add element at index
    public void add(int index, E element) {
        checkIndexForAdd(index);
        ensureCapacity();
        
        // Shift elements right
        System.arraycopy(data, index, data, index + 1, size - index);
        data[index] = element;
        size++;
    }
    
    // Get element
    @SuppressWarnings("unchecked")
    public E get(int index) {
        checkIndex(index);
        return (E) data[index];
    }
    
    // Set element
    public E set(int index, E element) {
        checkIndex(index);
        E oldValue = get(index);
        data[index] = element;
        return oldValue;
    }
    
    // Remove element
    public E remove(int index) {
        checkIndex(index);
        E oldValue = get(index);
        
        // Shift elements left
        int numMoved = size - index - 1;
        if (numMoved > 0) {
            System.arraycopy(data, index + 1, data, index, numMoved);
        }
        data[--size] = null;  // Clear reference
        
        return oldValue;
    }
    
    // Size
    public int size() {
        return size;
    }
    
    // Is empty
    public boolean isEmpty() {
        return size == 0;
    }
    
    // Clear all elements
    public void clear() {
        for (int i = 0; i < size; i++) {
            data[i] = null;
        }
        size = 0;
    }
    
    // Ensure capacity
    private void ensureCapacity() {
        if (size == data.length) {
            resize();
        }
    }
    
    // Resize array (double capacity)
    private void resize() {
        int newCapacity = data.length * 2;
        data = Arrays.copyOf(data, newCapacity);
    }
    
    // Check index for get/set/remove
    private void checkIndex(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }
    
    // Check index for add
    private void checkIndexForAdd(int index) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
    }
    
    // Contains
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }
    
    // Index of
    public int indexOf(Object o) {
        if (o == null) {
            for (int i = 0; i < size; i++) {
                if (data[i] == null) {
                    return i;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (o.equals(data[i])) {
                    return i;
                }
            }
        }
        return -1;
    }
    
    @Override
    public String toString() {
        if (size == 0) {
            return "[]";
        }
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < size; i++) {
            sb.append(data[i]);
            if (i < size - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

---

## üéØ Usage Example

```java
public class Main {
    public static void main(String[] args) {
        CustomArrayList<String> list = new CustomArrayList<>();
        
        // Add elements
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        System.out.println(list);  // [Apple, Banana, Cherry]
        
        // Add at index
        list.add(1, "Mango");
        System.out.println(list);  // [Apple, Mango, Banana, Cherry]
        
        // Get element
        System.out.println(list.get(2));  // Banana
        
        // Set element
        list.set(0, "Avocado");
        System.out.println(list);  // [Avocado, Mango, Banana, Cherry]
        
        // Remove element
        list.remove(1);
        System.out.println(list);  // [Avocado, Banana, Cherry]
        
        // Size and contains
        System.out.println("Size: " + list.size());  // 3
        System.out.println("Contains Banana: " + list.contains("Banana"));  // true
        
        // Clear
        list.clear();
        System.out.println("After clear: " + list);  // []
    }
}
```

---

## üöÄ Advanced Features

### 1. Trimming Capacity
```java
public void trimToSize() {
    if (size < data.length) {
        data = Arrays.copyOf(data, size);
    }
}
```

### 2. Bulk Operations
```java
public boolean addAll(Collection<? extends E> c) {
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacity(size + numNew);
    System.arraycopy(a, 0, data, size, numNew);
    size += numNew;
    return numNew != 0;
}

private void ensureCapacity(int minCapacity) {
    if (minCapacity > data.length) {
        int newCapacity = Math.max(data.length * 2, minCapacity);
        data = Arrays.copyOf(data, newCapacity);
    }
}
```

### 3. Iterator Support
```java
public Iterator<E> iterator() {
    return new Iterator<E>() {
        private int cursor = 0;
        
        @Override
        public boolean hasNext() {
            return cursor < size;
        }
        
        @Override
        @SuppressWarnings("unchecked")
        public E next() {
            if (cursor >= size) {
                throw new NoSuchElementException();
            }
            return (E) data[cursor++];
        }
        
        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    };
}
```

### 4. SubList
```java
public List<E> subList(int fromIndex, int toIndex) {
    if (fromIndex < 0 || toIndex > size || fromIndex > toIndex) {
        throw new IndexOutOfBoundsException();
    }
    
    CustomArrayList<E> subList = new CustomArrayList<>(toIndex - fromIndex);
    for (int i = fromIndex; i < toIndex; i++) {
        subList.add(get(i));
    }
    return subList;
}
```

---

## üîç How Dynamic Resizing Works

```java
Initial capacity: 10
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, _, _, _, _]
                                  ‚Üë size = 10, capacity = 10

Add 11th element ‚Üí Resize to 20
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, _, _, _, _, _, _, _, _, _]
                                      ‚Üë size = 11, capacity = 20

Add 21st element ‚Üí Resize to 40
[1, 2, ..., 21, _, _, ..., _]
                  ‚Üë size = 21, capacity = 40
```

**Growth Strategy:**
- Double capacity each time: O(1) amortized add
- Alternative: Grow by 50% (Java uses 1.5x for ArrayList)

---

## ‚ö†Ô∏è Common Pitfalls

1. **Forgetting to resize**
```java
// ‚ùå ArrayIndexOutOfBoundsException
public boolean add(E element) {
    data[size++] = element;  // No capacity check!
    return true;
}

// ‚úÖ Check capacity
public boolean add(E element) {
    ensureCapacity();
    data[size++] = element;
    return true;
}
```

2. **Not clearing references**
```java
// ‚ùå Memory leak
public E remove(int index) {
    E oldValue = get(index);
    System.arraycopy(data, index + 1, data, index, size - index - 1);
    size--;  // Old reference still in array!
    return oldValue;
}

// ‚úÖ Clear reference
public E remove(int index) {
    E oldValue = get(index);
    System.arraycopy(data, index + 1, data, index, size - index - 1);
    data[--size] = null;  // Clear reference for GC
    return oldValue;
}
```

3. **Wrong index bounds**
```java
// ‚ùå add(0, "x") on empty list fails
private void checkIndex(int index) {
    if (index < 0 || index >= size) {  // Wrong for add
        throw new IndexOutOfBoundsException();
    }
}

// ‚úÖ Separate check for add
private void checkIndexForAdd(int index) {
    if (index < 0 || index > size) {  // Allow index == size
        throw new IndexOutOfBoundsException();
    }
}
```

4. **Not handling null in equals**
```java
// ‚ùå NullPointerException
public int indexOf(Object o) {
    for (int i = 0; i < size; i++) {
        if (o.equals(data[i])) {  // NPE if o is null
            return i;
        }
    }
    return -1;
}

// ‚úÖ Handle null
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++) {
            if (data[i] == null) return i;
        }
    } else {
        for (int i = 0; i < size; i++) {
            if (o.equals(data[i])) return i;
        }
    }
    return -1;
}
```

---

## üí° Best Practices

1. **Capacity planning**
```java
// ‚úÖ Provide initial capacity if known
CustomArrayList<String> list = new CustomArrayList<>(100);
```

2. **Trim after bulk operations**
```java
// ‚úÖ Reduce memory footprint
list.addAll(collection);
list.trimToSize();
```

3. **Use System.arraycopy()**
```java
// ‚úÖ Efficient array copying
System.arraycopy(source, srcPos, dest, destPos, length);

// ‚ùå Slow manual copy
for (int i = 0; i < length; i++) {
    dest[destPos + i] = source[srcPos + i];
}
```

4. **Implement Iterable**
```java
public class CustomArrayList<E> implements Iterable<E> {
    @Override
    public Iterator<E> iterator() {
        // Return iterator
    }
}

// Enables enhanced for loop
for (String item : list) {
    System.out.println(item);
}
```

---

## üìä Performance Analysis

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(1) amortized | O(n) when resize |
| **add(int, E)** | O(n) | Shift elements |
| **get(int)** | O(1) | Direct access |
| **set(int, E)** | O(1) | Direct access |
| **remove(int)** | O(n) | Shift elements |
| **contains(Object)** | O(n) | Linear search |
| **indexOf(Object)** | O(n) | Linear search |

---

## üìö Interview Questions

**Q1: Why use Object[] instead of E[]?**
A: Can't create generic array directly. Type erasure at runtime.

**Q2: Why double capacity?**
A: Amortizes cost of resizing. Average O(1) add operation.

**Q3: Time complexity of add()?**
A: O(1) amortized. Occasional O(n) for resize.

**Q4: Why clear references on remove?**
A: Prevent memory leaks. Allow garbage collection.

**Q5: ArrayList vs LinkedList?**
A: ArrayList better for random access (O(1)), LinkedList better for insertions/deletions (O(1) at ends).

**Q6: How to make thread-safe?**
A: Synchronize methods or use Collections.synchronizedList().

**Q7: Initial capacity impact?**
A: Reduces resize operations if size is known. Better performance.

**Q8: Why use System.arraycopy()?**
A: Native method, optimized, faster than manual loop.

---

## üìö Summary

- **Dynamic array**: Resizable array-backed list
- **Key operations**: add(), get(), remove(), set()
- **Resizing**: Double capacity when full (O(1) amortized)
- **Random access**: O(1) get/set operations
- **Insertion/deletion**: O(n) due to shifting
- **Memory**: Clear references to prevent leaks
- **Usage**: Best for random access, less for frequent insertions
