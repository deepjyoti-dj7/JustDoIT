# üî¢ Reducing Collections

## üìñ Overview

**Reduction** operations combine stream elements into a single result. Java provides several reduction operations:
- **reduce()** - General purpose reduction
- **collect()** - Mutable reduction (to collections)
- **Terminal aggregates** - sum(), count(), min(), max(), average()

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);
// 15
```

---

## ‚≠ê reduce() Operation

### Overview
Performs a reduction using an associative accumulation function. Combines elements to produce single result.

```java
// With identity
T reduce(T identity, BinaryOperator<T> accumulator)

// Without identity (returns Optional)
Optional<T> reduce(BinaryOperator<T> accumulator)

// With combiner (for parallel)
<U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
```

---

## üíª reduce() Usage

### 1. Sum Numbers
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum with initial value
int sum = numbers.stream()
    .reduce(0, (a, b) -> a + b);
// 15

// Sum with method reference
int sum2 = numbers.stream()
    .reduce(0, Integer::sum);

// Without identity (returns Optional)
Optional<Integer> sum3 = numbers.stream()
    .reduce((a, b) -> a + b);
sum3.ifPresent(System.out::println);  // 15
```

### 2. Product
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int product = numbers.stream()
    .reduce(1, (a, b) -> a * b);
// 120
```

### 3. Find Maximum/Minimum
```java
List<Integer> numbers = Arrays.asList(3, 7, 2, 9, 1);

// Maximum
Optional<Integer> max = numbers.stream()
    .reduce((a, b) -> a > b ? a : b);
// Or use Integer::max
Optional<Integer> max2 = numbers.stream()
    .reduce(Integer::max);

// Minimum
Optional<Integer> min = numbers.stream()
    .reduce(Integer::min);
```

### 4. Concatenate Strings
```java
List<String> words = Arrays.asList("Hello", "World", "Java");

String concatenated = words.stream()
    .reduce("", (a, b) -> a + " " + b);
// " Hello World Java"

// Better with String.join() or Collectors.joining()
String result = String.join(" ", words);
```

### 5. Complex Objects
```java
class Product {
    String name;
    double price;
}

List<Product> products = getProducts();

// Total price
double total = products.stream()
    .map(Product::getPrice)
    .reduce(0.0, Double::sum);

// Cheapest product
Optional<Product> cheapest = products.stream()
    .reduce((p1, p2) -> p1.price < p2.price ? p1 : p2);
```

---

## üéØ Real-World Examples

### 1. Calculate Total Sales
```java
class Order {
    double amount;
}

List<Order> orders = getOrders();

double totalSales = orders.stream()
    .map(Order::getAmount)
    .reduce(0.0, Double::sum);

System.out.println("Total Sales: $" + totalSales);
```

---

### 2. Combine User Permissions
```java
class User {
    Set<String> permissions;
}

List<User> users = getUsers();

Set<String> allPermissions = users.stream()
    .map(User::getPermissions)
    .reduce(new HashSet<>(), (set1, set2) -> {
        set1.addAll(set2);
        return set1;
    });
```

---

### 3. Find Longest String
```java
List<String> strings = Arrays.asList("a", "abc", "ab", "abcd");

Optional<String> longest = strings.stream()
    .reduce((s1, s2) -> s1.length() > s2.length() ? s1 : s2);

longest.ifPresent(s -> System.out.println("Longest: " + s));  // abcd
```

---

### 4. Aggregate Scores
```java
class Student {
    String name;
    int score;
}

List<Student> students = getStudents();

int totalScore = students.stream()
    .mapToInt(Student::getScore)
    .reduce(0, Integer::sum);

double avgScore = (double) totalScore / students.size();
```

---

## üìä Terminal Aggregate Operations

### Built-in Reductions
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// count()
long count = numbers.stream().count();  // 5

// sum() - IntStream, LongStream, DoubleStream only
int sum = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();  // 15

// average()
OptionalDouble avg = numbers.stream()
    .mapToInt(Integer::intValue)
    .average();  // 3.0

// min()
Optional<Integer> min = numbers.stream()
    .min(Integer::compareTo);  // 1

// max()
Optional<Integer> max = numbers.stream()
    .max(Integer::compareTo);  // 5
```

---

## üéØ Aggregate Examples

### 1. Statistics Summary
```java
List<Integer> scores = Arrays.asList(85, 92, 78, 95, 88);

IntSummaryStatistics stats = scores.stream()
    .mapToInt(Integer::intValue)
    .summaryStatistics();

System.out.println("Count: " + stats.getCount());      // 5
System.out.println("Sum: " + stats.getSum());          // 438
System.out.println("Min: " + stats.getMin());          // 78
System.out.println("Max: " + stats.getMax());          // 95
System.out.println("Average: " + stats.getAverage());  // 87.6
```

---

### 2. Calculate Total Price
```java
class Item {
    String name;
    double price;
    int quantity;
}

List<Item> cart = getCart();

double total = cart.stream()
    .mapToDouble(item -> item.price * item.quantity)
    .sum();

System.out.println("Total: $" + String.format("%.2f", total));
```

---

### 3. Count by Condition
```java
List<Employee> employees = getEmployees();

long seniorCount = employees.stream()
    .filter(e -> e.experience > 10)
    .count();

long avgSalary = (long) employees.stream()
    .mapToDouble(Employee::getSalary)
    .average()
    .orElse(0.0);
```

---

## üîÄ Parallel Reduction

### With Combiner
```java
List<Integer> numbers = getLargeList();

// Parallel reduction with combiner
int sum = numbers.parallelStream()
    .reduce(
        0,                    // Identity
        Integer::sum,         // Accumulator
        Integer::sum          // Combiner (combines partial results)
    );
```

**Combiner** is used in parallel streams to combine results from different threads.

---

## ‚ö†Ô∏è Common Pitfalls

1. **Wrong identity value**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// ‚ùå Wrong identity for product (should be 1, not 0)
int product = numbers.stream()
    .reduce(0, (a, b) -> a * b);  // Result: 0

// ‚úÖ Correct identity
int product2 = numbers.stream()
    .reduce(1, (a, b) -> a * b);  // Result: 120
```

2. **Mutable reduction with reduce()**
```java
// ‚ùå Don't use mutable objects with reduce()
List<String> list = Arrays.asList("a", "b", "c");
List<String> result = list.stream()
    .reduce(new ArrayList<>(), (acc, s) -> {
        acc.add(s);  // Mutates accumulator - bad!
        return acc;
    });

// ‚úÖ Use collect() for mutable reduction
List<String> result2 = list.stream()
    .collect(Collectors.toList());
```

3. **Non-associative operations**
```java
// ‚ùå String concatenation is not efficient with reduce
List<String> words = Arrays.asList("a", "b", "c");
String result = words.stream()
    .reduce("", (a, b) -> a + b);  // Creates many String objects

// ‚úÖ Use Collectors.joining()
String result2 = words.stream()
    .collect(Collectors.joining());
```

4. **Empty stream without identity**
```java
List<Integer> empty = new ArrayList<>();

// ‚ùå Returns empty Optional
Optional<Integer> sum = empty.stream()
    .reduce((a, b) -> a + b);

// ‚úÖ Use identity or handle Optional
int sum2 = empty.stream()
    .reduce(0, Integer::sum);  // Returns 0
```

5. **Side effects in reduction**
```java
List<Integer> list = Arrays.asList(1, 2, 3);
AtomicInteger counter = new AtomicInteger();

// ‚ùå Side effects - avoid
int sum = list.stream()
    .reduce(0, (a, b) -> {
        counter.incrementAndGet();  // Side effect!
        return a + b;
    });
```

---

## üí° Best Practices

1. **Use specialized reductions**
```java
// ‚ùå Verbose
int sum = numbers.stream()
    .reduce(0, Integer::sum);

// ‚úÖ Use sum() directly
int sum2 = numbers.stream()
    .mapToInt(Integer::intValue)
    .sum();
```

2. **Choose correct identity**
```java
// Sum: identity = 0
int sum = stream.reduce(0, Integer::sum);

// Product: identity = 1
int product = stream.reduce(1, (a, b) -> a * b);

// Min: no identity (use Optional)
Optional<Integer> min = stream.reduce(Integer::min);
```

3. **Use collect() for mutable reduction**
```java
// ‚úÖ Collect to List
List<String> list = stream.collect(Collectors.toList());

// ‚úÖ Collect to Set
Set<String> set = stream.collect(Collectors.toSet());
```

4. **Handle empty streams**
```java
// ‚úÖ Use identity
int sum = stream.reduce(0, Integer::sum);

// ‚úÖ Or handle Optional
Optional<Integer> max = stream.reduce(Integer::max);
max.ifPresent(m -> System.out.println("Max: " + m));
```

---

## üÜö reduce() vs collect()

| Feature | reduce() | collect() |
|---------|----------|-----------|
| **Purpose** | Immutable reduction | Mutable reduction |
| **Result** | Single value | Collection/container |
| **Performance** | Creates new value each step | Mutates container |
| **Use case** | Sum, max, min, concatenate | toList, toSet, grouping |

```java
List<String> list = Arrays.asList("a", "b", "c");

// reduce() - immutable
String concat = list.stream()
    .reduce("", (a, b) -> a + b);

// collect() - mutable (better for collections)
List<String> collected = list.stream()
    .collect(Collectors.toList());
```

---

## üìö Interview Questions

**Q1: What is reduction?**
A: Combining stream elements into single result using accumulation function.

**Q2: reduce() with vs without identity?**
A: With identity returns T, without returns Optional<T>.

**Q3: What is identity value?**
A: Starting value for reduction. Must be identity for operation (0 for sum, 1 for product).

**Q4: When is combiner used?**
A: In parallel streams to combine partial results from different threads.

**Q5: reduce() vs collect()?**
A: reduce() for immutable reduction (values), collect() for mutable reduction (collections).

**Q6: Can reduce() modify source?**
A: No, streams don't modify source. Reduction creates new result.

**Q7: Why use sum() instead of reduce()?**
A: sum() is specialized, more readable, and optimized for numeric streams.

**Q8: How to handle empty stream?**
A: Use identity value, or handle Optional from reduce without identity.

---

## üìö Summary

### reduce()
- **Purpose**: Combine elements into single result
- **Types**: With identity (returns T), without (returns Optional<T>)
- **Identity**: Starting value, must be identity for operation
- **Use**: Sum, product, max, min, string concatenation

### Aggregate Operations
- **count()**: Number of elements
- **sum()**: Total (primitive streams)
- **average()**: Mean value
- **min()/max()**: Smallest/largest element
- **summaryStatistics()**: All stats at once

### Best Practices
- Use specialized operations (sum, count) when available
- Choose correct identity value
- Use collect() for mutable reduction
- Handle empty streams with identity or Optional
- Avoid side effects in reduction functions
