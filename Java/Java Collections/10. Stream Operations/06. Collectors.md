# üß∞ Collectors

## üìñ Overview

**Collectors** is a utility class providing implementations of Collector interface. Used with Stream's collect() terminal operation to accumulate elements into collections, strings, numbers, or custom results.

```java
List<String> list = stream.collect(Collectors.toList());
String joined = stream.collect(Collectors.joining(", "));
Map<K, V> map = stream.collect(Collectors.toMap(keyMapper, valueMapper));
```

---

## ‚≠ê Common Collectors

### 1. Collection Collectors

#### toList()
```java
List<String> names = people.stream()
    .map(Person::getName)
    .collect(Collectors.toList());
```

#### toSet()
```java
Set<String> uniqueCities = people.stream()
    .map(Person::getCity)
    .collect(Collectors.toSet());
```

#### toCollection()
```java
// Specific collection type
LinkedList<String> linkedList = stream
    .collect(Collectors.toCollection(LinkedList::new));

TreeSet<String> treeSet = stream
    .collect(Collectors.toCollection(TreeSet::new));
```

#### toUnmodifiableList/Set/Map()
```java
List<String> immutableList = stream
    .collect(Collectors.toUnmodifiableList());

Set<String> immutableSet = stream
    .collect(Collectors.toUnmodifiableSet());
```

---

### 2. String Collectors

#### joining()
```java
List<String> words = Arrays.asList("Hello", "World", "Java");

// Simple join
String result1 = words.stream()
    .collect(Collectors.joining());
// "HelloWorldJava"

// With delimiter
String result2 = words.stream()
    .collect(Collectors.joining(", "));
// "Hello, World, Java"

// With delimiter, prefix, suffix
String result3 = words.stream()
    .collect(Collectors.joining(", ", "[", "]"));
// "[Hello, World, Java]"
```

---

### 3. Numeric Collectors

#### counting()
```java
long count = stream.collect(Collectors.counting());
// Same as: stream.count()
```

#### summingInt/Long/Double()
```java
int totalAge = people.stream()
    .collect(Collectors.summingInt(Person::getAge));

double totalPrice = products.stream()
    .collect(Collectors.summingDouble(Product::getPrice));
```

#### averagingInt/Long/Double()
```java
double avgAge = people.stream()
    .collect(Collectors.averagingInt(Person::getAge));

double avgPrice = products.stream()
    .collect(Collectors.averagingDouble(Product::getPrice));
```

#### summarizingInt/Long/Double()
```java
IntSummaryStatistics stats = people.stream()
    .collect(Collectors.summarizingInt(Person::getAge));

System.out.println("Count: " + stats.getCount());
System.out.println("Sum: " + stats.getSum());
System.out.println("Min: " + stats.getMin());
System.out.println("Max: " + stats.getMax());
System.out.println("Average: " + stats.getAverage());
```

---

### 4. Map Collectors

#### toMap()
```java
// Basic toMap
Map<Long, Person> byId = people.stream()
    .collect(Collectors.toMap(
        Person::getId,      // Key mapper
        person -> person    // Value mapper
    ));

// With merge function (handle duplicates)
Map<String, Person> byName = people.stream()
    .collect(Collectors.toMap(
        Person::getName,
        person -> person,
        (existing, replacement) -> existing  // Keep first
    ));

// With specific map type
TreeMap<Long, Person> treeMap = people.stream()
    .collect(Collectors.toMap(
        Person::getId,
        person -> person,
        (e1, e2) -> e1,
        TreeMap::new
    ));
```

---

### 5. Grouping Collectors

#### groupingBy()
```java
// Simple grouping
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// With downstream collector
Map<String, Long> countByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));

// Nested grouping
Map<String, Map<String, List<Person>>> nestedMap = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.groupingBy(Person::getGender)
    ));
```

#### partitioningBy()
```java
// Simple partition
Map<Boolean, List<Person>> adultMinor = people.stream()
    .collect(Collectors.partitioningBy(p -> p.age >= 18));

// With downstream
Map<Boolean, Long> countByAdult = people.stream()
    .collect(Collectors.partitioningBy(
        p -> p.age >= 18,
        Collectors.counting()
    ));
```

---

### 6. Advanced Collectors

#### mapping()
```java
// Extract names grouped by city
Map<String, List<String>> namesByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.mapping(Person::getName, Collectors.toList())
    ));
```

#### filtering()
```java
// Filter within grouping
Map<String, List<Person>> adultsByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.filtering(p -> p.age >= 18, Collectors.toList())
    ));
```

#### flatMapping()
```java
class Person {
    String name;
    List<String> hobbies;
}

// Get all hobbies by city
Map<String, List<String>> hobbiesByCity = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.flatMapping(p -> p.hobbies.stream(), Collectors.toList())
    ));
```

#### collectingAndThen()
```java
// Transform final result
List<String> unmodifiableList = stream
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        Collections::unmodifiableList
    ));

// Get most common city
Optional<String> mostCommon = people.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.groupingBy(Person::getCity, Collectors.counting()),
        map -> map.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
    ));
```

---

## üéØ Real-World Examples

### 1. Employee Report
```java
class Employee {
    String name;
    String department;
    double salary;
}

List<Employee> employees = getEmployees();

// Total salary by department
Map<String, Double> totalByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.summingDouble(Employee::getSalary)
    ));

// Average salary by department
Map<String, Double> avgByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));

// Employee names by department
Map<String, List<String>> namesByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.mapping(Employee::getName, Collectors.toList())
    ));
```

---

### 2. Product Catalog
```java
class Product {
    String id;
    String name;
    String category;
    double price;
}

List<Product> products = getProducts();

// Products by category
Map<String, List<Product>> byCategory = products.stream()
    .collect(Collectors.groupingBy(Product::getCategory));

// Product map by ID
Map<String, Product> byId = products.stream()
    .collect(Collectors.toMap(Product::getId, p -> p));

// Category statistics
Map<String, DoubleSummaryStatistics> priceStats = products.stream()
    .collect(Collectors.groupingBy(
        Product::getCategory,
        Collectors.summarizingDouble(Product::getPrice)
    ));
```

---

### 3. Order Processing
```java
class Order {
    String customerId;
    double amount;
    String status;
}

List<Order> orders = getOrders();

// Total revenue by customer
Map<String, Double> revenueByCustomer = orders.stream()
    .filter(o -> o.status.equals("COMPLETED"))
    .collect(Collectors.groupingBy(
        Order::getCustomerId,
        Collectors.summingDouble(Order::getAmount)
    ));

// Count orders by status
Map<String, Long> countByStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getStatus,
        Collectors.counting()
    ));
```

---

### 4. Student Grades
```java
class Student {
    String name;
    int score;
    String subject;
}

List<Student> students = getStudents();

// Average score by subject
Map<String, Double> avgBySubject = students.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,
        Collectors.averagingInt(Student::getScore)
    ));

// Top students by subject
Map<String, Optional<Student>> topBySubject = students.stream()
    .collect(Collectors.groupingBy(
        Student::getSubject,
        Collectors.maxBy(Comparator.comparingInt(Student::getScore))
    ));
```

---

### 5. Log Analysis
```java
class LogEntry {
    String level;  // INFO, WARN, ERROR
    String message;
    LocalDateTime timestamp;
}

List<LogEntry> logs = getLogs();

// Count by log level
Map<String, Long> countByLevel = logs.stream()
    .collect(Collectors.groupingBy(
        LogEntry::getLevel,
        Collectors.counting()
    ));

// Recent errors
List<String> recentErrors = logs.stream()
    .filter(log -> log.level.equals("ERROR"))
    .sorted(Comparator.comparing(LogEntry::getTimestamp).reversed())
    .limit(10)
    .map(LogEntry::getMessage)
    .collect(Collectors.toList());
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Duplicate keys in toMap()**
```java
List<Person> people = Arrays.asList(
    new Person("Alice", 30),
    new Person("Alice", 25)  // Duplicate name
);

// ‚ùå IllegalStateException - duplicate key
Map<String, Person> map = people.stream()
    .collect(Collectors.toMap(Person::getName, p -> p));

// ‚úÖ Provide merge function
Map<String, Person> map2 = people.stream()
    .collect(Collectors.toMap(
        Person::getName,
        p -> p,
        (existing, replacement) -> existing  // Keep first
    ));
```

2. **Null values in toMap()**
```java
// ‚ùå NullPointerException if value is null
Map<String, String> map = people.stream()
    .collect(Collectors.toMap(
        Person::getName,
        Person::getCity  // Can be null
    ));

// ‚úÖ Handle nulls
Map<String, String> map2 = people.stream()
    .collect(Collectors.toMap(
        Person::getName,
        p -> p.city != null ? p.city : "Unknown"
    ));
```

3. **Mutable vs immutable results**
```java
// ‚ùå Returns mutable list
List<String> list = stream.collect(Collectors.toList());
list.add("new");  // OK - mutable

// ‚úÖ Immutable list
List<String> immutable = stream
    .collect(Collectors.toUnmodifiableList());
// immutable.add("new");  // UnsupportedOperationException
```

---

## üí° Best Practices

1. **Use specific collectors**
```java
// ‚úÖ Clear intent
Set<String> set = stream.collect(Collectors.toSet());

// ‚ùå Generic
Collection<String> collection = stream.collect(Collectors.toList());
```

2. **Chain collectors efficiently**
```java
// ‚úÖ Single pass
Map<String, Long> result = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));

// ‚ùå Two passes
Map<String, List<Person>> grouped = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));
Map<String, Long> counts = grouped.entrySet().stream()
    .collect(Collectors.toMap(Map.Entry::getKey, e -> (long) e.getValue().size()));
```

3. **Use summary statistics**
```java
// ‚úÖ All stats in one pass
IntSummaryStatistics stats = stream
    .collect(Collectors.summarizingInt(Person::getAge));

// ‚ùå Multiple passes
int sum = stream.mapToInt(Person::getAge).sum();
double avg = stream.mapToInt(Person::getAge).average().orElse(0);
// ... stream already consumed!
```

4. **Choose appropriate collection type**
```java
// ‚úÖ Use TreeSet for sorted unique elements
Set<String> sorted = stream
    .collect(Collectors.toCollection(TreeSet::new));

// ‚úÖ Use LinkedHashSet for insertion order
Set<String> ordered = stream
    .collect(Collectors.toCollection(LinkedHashSet::new));
```

---

## üìö Interview Questions

**Q1: What is Collectors?**
A: Utility class providing Collector implementations for Stream's collect() operation.

**Q2: toList() vs toUnmodifiableList()?**
A: toList() returns mutable list, toUnmodifiableList() returns immutable.

**Q3: How to handle duplicate keys in toMap()?**
A: Provide merge function as third argument.

**Q4: joining() vs reduce() for strings?**
A: joining() is specialized, more efficient, and cleaner for string concatenation.

**Q5: What does groupingBy() return?**
A: Map<K, List<V>> where K is key from classifier.

**Q6: Can you nest collectors?**
A: Yes, use downstream collectors: groupingBy(f1, groupingBy(f2)).

**Q7: summingInt() vs mapToInt().sum()?**
A: summingInt() is collector (used with collect()), sum() is terminal operation.

**Q8: How to get all statistics at once?**
A: Use summarizingInt/Long/Double() - returns IntSummaryStatistics with count, sum, min, max, average.

---

## üìö Summary

### Collection Collectors
- **toList/Set/Map()**: Collect to collections
- **toCollection()**: Specify collection type
- **toUnmodifiableList/Set/Map()**: Immutable results

### String Collectors
- **joining()**: Concatenate with delimiter, prefix, suffix

### Numeric Collectors
- **counting()**: Count elements
- **summingInt/Long/Double()**: Sum values
- **averagingInt/Long/Double()**: Average values
- **summarizingInt/Long/Double()**: All statistics

### Map Collectors
- **toMap()**: Create map with key/value mappers
- **groupingBy()**: Group by classifier
- **partitioningBy()**: Split by predicate

### Advanced Collectors
- **mapping()**: Transform within collector
- **filtering()**: Filter within collector
- **flatMapping()**: Flatten within collector
- **collectingAndThen()**: Transform final result

### Best Practices
- Use specific collectors for clarity
- Handle duplicates and nulls in toMap()
- Use summary statistics for multiple aggregations
- Choose appropriate collection types
- Chain collectors for single-pass efficiency
