# üì¶ Grouping & Partitioning

## üìñ Overview

**Grouping** and **partitioning** are advanced collectors that organize stream elements:
- **groupingBy()** - Groups elements by classifier function into Map
- **partitioningBy()** - Splits elements into two groups (true/false) using predicate

```java
// Grouping
Map<String, List<Person>> byDept = people.stream()
    .collect(Collectors.groupingBy(Person::getDepartment));

// Partitioning
Map<Boolean, List<Person>> byAdult = people.stream()
    .collect(Collectors.partitioningBy(p -> p.age >= 18));
```

---

## ‚≠ê groupingBy() Operation

### Overview
Groups elements by a classifier function. Returns Map<K, List<V>>.

```java
// Simple grouping
<T, K> Collector<T, ?, Map<K, List<T>>> groupingBy(
    Function<? super T, ? extends K> classifier
)

// With downstream collector
<T, K, A, D> Collector<T, ?, Map<K, D>> groupingBy(
    Function<? super T, ? extends K> classifier,
    Collector<? super T, A, D> downstream
)

// With map factory
<T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(
    Function<? super T, ? extends K> classifier,
    Supplier<M> mapFactory,
    Collector<? super T, A, D> downstream
)
```

---

## üíª groupingBy() Usage

### 1. Simple Grouping
```java
class Person {
    String name;
    String city;
    int age;
}

List<Person> people = getPeople();

// Group by city
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// Result: {NYC=[Alice, Bob], LA=[Charlie], SF=[David]}
```

### 2. Group by Multiple Criteria
```java
class Employee {
    String name;
    String department;
    int age;
}

List<Employee> employees = getEmployees();

// Group by department
Map<String, List<Employee>> byDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

// Nested grouping: department -> age group
Map<String, Map<String, List<Employee>>> nested = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.groupingBy(e -> e.age < 30 ? "Junior" : "Senior")
    ));
```

### 3. Group with Counting
```java
// Count employees per department
Map<String, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.counting()
    ));

// Result: {Engineering=5, Sales=3, HR=2}
```

### 4. Group with Aggregation
```java
class Product {
    String category;
    double price;
}

List<Product> products = getProducts();

// Average price per category
Map<String, Double> avgPriceByCategory = products.stream()
    .collect(Collectors.groupingBy(
        Product::getCategory,
        Collectors.averagingDouble(Product::getPrice)
    ));

// Sum price per category
Map<String, Double> totalByCategory = products.stream()
    .collect(Collectors.groupingBy(
        Product::getCategory,
        Collectors.summingDouble(Product::getPrice)
    ));
```

### 5. Group with Custom Collector
```java
// Get names per department
Map<String, List<String>> namesByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.mapping(Employee::getName, Collectors.toList())
    ));

// Get unique departments with Set
Map<String, Set<Employee>> setByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.toSet()
    ));
```

---

## üéØ groupingBy() Real-World Examples

### 1. Sales Report by Month
```java
class Sale {
    LocalDate date;
    double amount;
}

List<Sale> sales = getSales();

// Group by month
Map<Month, List<Sale>> byMonth = sales.stream()
    .collect(Collectors.groupingBy(s -> s.date.getMonth()));

// Total sales per month
Map<Month, Double> totalByMonth = sales.stream()
    .collect(Collectors.groupingBy(
        s -> s.date.getMonth(),
        Collectors.summingDouble(Sale::getAmount)
    ));
```

---

### 2. Students by Grade
```java
class Student {
    String name;
    int score;
    
    String getGrade() {
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        return "D";
    }
}

List<Student> students = getStudents();

Map<String, List<Student>> byGrade = students.stream()
    .collect(Collectors.groupingBy(Student::getGrade));

// Count per grade
Map<String, Long> countByGrade = students.stream()
    .collect(Collectors.groupingBy(
        Student::getGrade,
        Collectors.counting()
    ));
```

---

### 3. Orders by Status
```java
class Order {
    String id;
    String status;
    double amount;
}

List<Order> orders = getOrders();

// Group by status
Map<String, List<Order>> byStatus = orders.stream()
    .collect(Collectors.groupingBy(Order::getStatus));

// Revenue by status
Map<String, Double> revenueByStatus = orders.stream()
    .collect(Collectors.groupingBy(
        Order::getStatus,
        Collectors.summingDouble(Order::getAmount)
    ));
```

---

### 4. Word Frequency
```java
String text = "the quick brown fox jumps over the lazy dog";
List<String> words = Arrays.asList(text.split(" "));

Map<String, Long> wordFrequency = words.stream()
    .collect(Collectors.groupingBy(
        word -> word,
        Collectors.counting()
    ));

// Result: {the=2, quick=1, brown=1, ...}
```

---

## ‚≠ê partitioningBy() Operation

### Overview
Splits elements into two groups based on predicate. Returns Map<Boolean, List<T>>.

```java
// Simple partitioning
<T> Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(
    Predicate<? super T> predicate
)

// With downstream collector
<T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(
    Predicate<? super T> predicate,
    Collector<? super T, A, D> downstream
)
```

---

## üíª partitioningBy() Usage

### 1. Simple Partitioning
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Partition by even/odd
Map<Boolean, List<Integer>> evenOdd = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));

System.out.println("Even: " + evenOdd.get(true));   // [2, 4, 6, 8, 10]
System.out.println("Odd: " + evenOdd.get(false));   // [1, 3, 5, 7, 9]
```

### 2. Partition with Counting
```java
List<Person> people = getPeople();

// Partition by adult/minor
Map<Boolean, Long> adultCount = people.stream()
    .collect(Collectors.partitioningBy(
        p -> p.age >= 18,
        Collectors.counting()
    ));

System.out.println("Adults: " + adultCount.get(true));
System.out.println("Minors: " + adultCount.get(false));
```

### 3. Partition with Aggregation
```java
List<Employee> employees = getEmployees();

// Partition by high earners (>100K)
Map<Boolean, Double> avgSalary = employees.stream()
    .collect(Collectors.partitioningBy(
        e -> e.salary > 100000,
        Collectors.averagingDouble(Employee::getSalary)
    ));

System.out.println("Avg (>100K): " + avgSalary.get(true));
System.out.println("Avg (<=100K): " + avgSalary.get(false));
```

---

## üéØ partitioningBy() Real-World Examples

### 1. Pass/Fail Students
```java
List<Student> students = getStudents();

// Partition by passing score (>=60)
Map<Boolean, List<Student>> passFail = students.stream()
    .collect(Collectors.partitioningBy(s -> s.score >= 60));

List<Student> passed = passFail.get(true);
List<Student> failed = passFail.get(false);

System.out.println("Passed: " + passed.size());
System.out.println("Failed: " + failed.size());
```

---

### 2. In Stock vs Out of Stock
```java
class Product {
    String name;
    int quantity;
}

List<Product> products = getProducts();

Map<Boolean, List<Product>> stockStatus = products.stream()
    .collect(Collectors.partitioningBy(p -> p.quantity > 0));

List<Product> inStock = stockStatus.get(true);
List<Product> outOfStock = stockStatus.get(false);
```

---

### 3. Active vs Inactive Users
```java
class User {
    String username;
    LocalDateTime lastLogin;
}

List<User> users = getUsers();

LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);

Map<Boolean, List<User>> activeStatus = users.stream()
    .collect(Collectors.partitioningBy(
        u -> u.lastLogin.isAfter(thirtyDaysAgo)
    ));
```

---

## üÜö groupingBy() vs partitioningBy()

| Feature | groupingBy() | partitioningBy() |
|---------|--------------|------------------|
| **Groups** | N groups | 2 groups (true/false) |
| **Key type** | Any type K | Boolean only |
| **Function** | Classifier function | Predicate |
| **Use case** | Multiple categories | Binary classification |

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

// groupingBy - multiple groups
Map<Integer, List<Integer>> byMod3 = numbers.stream()
    .collect(Collectors.groupingBy(n -> n % 3));
// {0=[3, 6], 1=[1, 4], 2=[2, 5]}

// partitioningBy - two groups
Map<Boolean, List<Integer>> evenOdd = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));
// {true=[2, 4, 6], false=[1, 3, 5]}
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Null keys in groupingBy**
```java
class Person {
    String city;  // Can be null
}

// ‚ùå NullPointerException if city is null
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// ‚úÖ Handle nulls
Map<String, List<Person>> byCity2 = people.stream()
    .collect(Collectors.groupingBy(
        p -> p.city != null ? p.city : "Unknown"
    ));
```

2. **Expecting TreeMap but getting HashMap**
```java
// ‚ùå Returns HashMap (unordered)
Map<String, List<Person>> map = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));

// ‚úÖ Specify TreeMap for sorted keys
Map<String, List<Person>> sortedMap = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        TreeMap::new,
        Collectors.toList()
    ));
```

3. **Forgetting both groups exist in partitioningBy**
```java
Map<Boolean, List<Student>> passFail = students.stream()
    .collect(Collectors.partitioningBy(s -> s.score >= 60));

// ‚ùå Might be null if no failures
List<Student> failed = passFail.get(false);

// ‚úÖ Always returns both keys (empty list if none)
// But still check for safety
List<Student> failed2 = passFail.getOrDefault(false, Collections.emptyList());
```

---

## üí° Best Practices

1. **Use partitioningBy for binary splits**
```java
// ‚úÖ Clear intent
Map<Boolean, List<Integer>> evenOdd = numbers.stream()
    .collect(Collectors.partitioningBy(n -> n % 2 == 0));

// ‚ùå Overkill with groupingBy
Map<Boolean, List<Integer>> evenOdd2 = numbers.stream()
    .collect(Collectors.groupingBy(n -> n % 2 == 0));
```

2. **Specify map type when order matters**
```java
// ‚úÖ Sorted keys
Map<String, List<Person>> sorted = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        TreeMap::new,
        Collectors.toList()
    ));
```

3. **Use downstream collectors for aggregation**
```java
// ‚úÖ Efficient - one pass
Map<String, Long> counts = people.stream()
    .collect(Collectors.groupingBy(
        Person::getCity,
        Collectors.counting()
    ));

// ‚ùå Inefficient - two passes
Map<String, List<Person>> grouped = people.stream()
    .collect(Collectors.groupingBy(Person::getCity));
Map<String, Long> counts2 = new HashMap<>();
grouped.forEach((k, v) -> counts2.put(k, (long) v.size()));
```

4. **Handle nulls in classifier**
```java
// ‚úÖ Provide default for nulls
Map<String, List<Person>> byCity = people.stream()
    .collect(Collectors.groupingBy(
        p -> p.city != null ? p.city : "N/A"
    ));
```

---

## üìö Interview Questions

**Q1: groupingBy() vs partitioningBy()?**
A: groupingBy() creates N groups by classifier, partitioningBy() creates 2 groups (true/false) by predicate.

**Q2: What does groupingBy() return?**
A: Map<K, List<V>> where K is key from classifier, V is list of matching elements.

**Q3: What does partitioningBy() return?**
A: Map<Boolean, List<T>> with keys true and false.

**Q4: Can you nest groupingBy()?**
A: Yes, use as downstream collector: groupingBy(f1, groupingBy(f2)).

**Q5: How to count elements per group?**
A: Use counting() downstream: groupingBy(classifier, counting()).

**Q6: Can classifier return null?**
A: Yes, but may cause NullPointerException. Handle nulls in classifier.

**Q7: Default Map type?**
A: HashMap. Specify TreeMap for sorted keys.

**Q8: When to use partitioningBy?**
A: For binary classification (pass/fail, active/inactive, etc.).

---

## üìö Summary

### groupingBy()
- **Purpose**: Group elements by classifier function
- **Returns**: Map<K, List<V>>
- **Use**: Multiple categories, aggregation by group
- **Downstream**: counting(), summingDouble(), mapping(), etc.

### partitioningBy()
- **Purpose**: Split into two groups by predicate
- **Returns**: Map<Boolean, List<T>>
- **Use**: Binary classification
- **Always**: Both true and false keys present

### Best Practices
- Use partitioningBy for binary splits
- Handle nulls in classifier
- Use downstream collectors for aggregation
- Specify map type when order matters
- Prefer single-pass with downstream over multi-pass
