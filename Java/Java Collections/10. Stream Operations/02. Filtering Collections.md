# üîç Filtering Collections

## üìñ Overview

**filter()** is an intermediate Stream operation that selects elements matching a predicate. Returns a new stream with only matching elements.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// [2, 4, 6]
```

---

## ‚≠ê Key Characteristics

1. **Intermediate operation** - Returns Stream
2. **Lazy** - Evaluated when terminal operation is called
3. **Stateless** - Each element processed independently
4. **Non-modifying** - Doesn't change source collection
5. **Chainable** - Can chain multiple filters

---

## üìù Method Signature

```java
Stream<T> filter(Predicate<? super T> predicate)

// Predicate is a functional interface
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

---

## üíª Basic Usage

### 1. Filter Numbers
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Even numbers
List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
// [2, 4, 6, 8, 10]

// Greater than 5
List<Integer> large = numbers.stream()
    .filter(n -> n > 5)
    .collect(Collectors.toList());
// [6, 7, 8, 9, 10]
```

### 2. Filter Strings
```java
List<String> words = Arrays.asList("apple", "banana", "cherry", "date");

// Length > 5
List<String> long = words.stream()
    .filter(w -> w.length() > 5)
    .collect(Collectors.toList());
// [banana, cherry]

// Starts with 'a'
List<String> aWords = words.stream()
    .filter(w -> w.startsWith("a"))
    .collect(Collectors.toList());
// [apple]
```

### 3. Filter Custom Objects
```java
class Person {
    String name;
    int age;
}

List<Person> people = getPeople();

// Adults (age >= 18)
List<Person> adults = people.stream()
    .filter(p -> p.age >= 18)
    .collect(Collectors.toList());
```

### 4. Multiple Filters (Chaining)
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Even AND greater than 5
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .filter(n -> n > 5)
    .collect(Collectors.toList());
// [6, 8, 10]

// Alternative: single filter with &&
List<Integer> result2 = numbers.stream()
    .filter(n -> n % 2 == 0 && n > 5)
    .collect(Collectors.toList());
```

---

## üéØ Real-World Examples

### 1. Filter Active Users
```java
class User {
    String username;
    boolean active;
    LocalDateTime lastLogin;
}

List<User> users = getUsers();

// Active users who logged in last 30 days
List<User> activeRecent = users.stream()
    .filter(User::isActive)
    .filter(u -> u.lastLogin.isAfter(LocalDateTime.now().minusDays(30)))
    .collect(Collectors.toList());
```

---

### 2. Filter Products by Category and Price
```java
class Product {
    String name;
    String category;
    double price;
    boolean inStock;
}

List<Product> products = getProducts();

// Electronics under $500 that are in stock
List<Product> result = products.stream()
    .filter(p -> p.category.equals("Electronics"))
    .filter(p -> p.price < 500)
    .filter(Product::isInStock)
    .collect(Collectors.toList());
```

---

### 3. Filter Orders by Status
```java
class Order {
    String id;
    String status;
    double amount;
    LocalDate date;
}

List<Order> orders = getOrders();

// Completed orders over $100 from this month
List<Order> filtered = orders.stream()
    .filter(o -> o.status.equals("COMPLETED"))
    .filter(o -> o.amount > 100)
    .filter(o -> o.date.getMonth() == LocalDate.now().getMonth())
    .collect(Collectors.toList());
```

---

### 4. Filter Employees by Department and Salary
```java
class Employee {
    String name;
    String department;
    double salary;
    int experience;
}

List<Employee> employees = getEmployees();

// Senior engineers (>5 years, salary >100K)
List<Employee> seniorEngineers = employees.stream()
    .filter(e -> e.department.equals("Engineering"))
    .filter(e -> e.experience > 5)
    .filter(e -> e.salary > 100000)
    .collect(Collectors.toList());
```

---

### 5. Filter Files by Extension and Size
```java
File[] files = new File("/path").listFiles();

// Large PDF files (> 10MB)
List<File> largePdfs = Arrays.stream(files)
    .filter(f -> f.getName().endsWith(".pdf"))
    .filter(f -> f.length() > 10 * 1024 * 1024)
    .collect(Collectors.toList());
```

---

## üîß Advanced Filtering

### 1. Filter with Method Reference
```java
List<String> strings = Arrays.asList("", "hello", "", "world", "");

// Remove empty strings
List<String> nonEmpty = strings.stream()
    .filter(s -> !s.isEmpty())
    .collect(Collectors.toList());

// Using method reference with helper
List<String> nonEmpty2 = strings.stream()
    .filter(Predicate.not(String::isEmpty))
    .collect(Collectors.toList());
```

### 2. Filter with Predicate Composition
```java
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isGreaterThan10 = n -> n > 10;

List<Integer> numbers = Arrays.asList(-5, 2, 10, 15, -8, 20, 7);

// AND composition
List<Integer> result1 = numbers.stream()
    .filter(isEven.and(isPositive))
    .collect(Collectors.toList());
// [2, 10, 20]

// OR composition
List<Integer> result2 = numbers.stream()
    .filter(isEven.or(isGreaterThan10))
    .collect(Collectors.toList());
// [2, 10, 15, -8, 20]

// NOT composition
List<Integer> result3 = numbers.stream()
    .filter(isEven.negate())
    .collect(Collectors.toList());
// [-5, 15, 7]
```

### 3. Filter with External Conditions
```java
Set<String> allowedDepartments = Set.of("Engineering", "Sales");

List<Employee> employees = getEmployees();

List<Employee> filtered = employees.stream()
    .filter(e -> allowedDepartments.contains(e.department))
    .collect(Collectors.toList());
```

### 4. Filter Null Values
```java
List<String> list = Arrays.asList("A", null, "B", null, "C");

// Remove nulls
List<String> nonNull = list.stream()
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
// [A, B, C]
```

### 5. Filter Distinct After Filtering
```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 4, 5, 5);

// Even numbers, distinct
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .distinct()
    .collect(Collectors.toList());
// [2, 4]
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Null pointer in predicate**
```java
List<Person> people = Arrays.asList(
    new Person("Alice", 30),
    new Person(null, 25)
);

// ‚ùå NullPointerException if name is null
List<Person> filtered = people.stream()
    .filter(p -> p.name.startsWith("A"))
    .collect(Collectors.toList());

// ‚úÖ Null-safe filtering
List<Person> filtered2 = people.stream()
    .filter(p -> p.name != null && p.name.startsWith("A"))
    .collect(Collectors.toList());
```

2. **Side effects in filter**
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> processed = new ArrayList<>();

// ‚ùå Side effects - avoid
list.stream()
    .filter(n -> {
        processed.add(n);  // Side effect!
        return n % 2 == 0;
    })
    .collect(Collectors.toList());

// ‚úÖ Pure function
list.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
```

3. **Complex predicates**
```java
// ‚ùå Hard to read
list.stream()
    .filter(n -> n > 0 && n < 100 && n % 2 == 0 && n % 3 == 0)
    .collect(Collectors.toList());

// ‚úÖ Extract to method
list.stream()
    .filter(this::isValid)
    .collect(Collectors.toList());

private boolean isValid(int n) {
    return n > 0 && n < 100 && n % 2 == 0 && n % 3 == 0;
}
```

4. **Filter after expensive operation**
```java
// ‚ùå Inefficient - map before filter
list.stream()
    .map(this::expensiveTransform)
    .filter(this::isValid)
    .collect(Collectors.toList());

// ‚úÖ Filter first
list.stream()
    .filter(this::isValidInput)
    .map(this::expensiveTransform)
    .collect(Collectors.toList());
```

---

## üí° Best Practices

1. **Filter early in pipeline**
```java
// ‚úÖ Reduce elements processed by subsequent operations
list.stream()
    .filter(predicate)      // Filter early
    .map(mapper)
    .sorted()
    .collect(Collectors.toList());
```

2. **Use method references**
```java
// ‚úÖ Clean and readable
list.stream()
    .filter(String::isEmpty)
    .filter(Objects::nonNull)
    .collect(Collectors.toList());
```

3. **Combine filters logically**
```java
// ‚úÖ Single filter with AND
list.stream()
    .filter(n -> n > 0 && n < 100)
    .collect(Collectors.toList());

// ‚úÖ Multiple filters for readability
list.stream()
    .filter(n -> n > 0)
    .filter(n -> n < 100)
    .collect(Collectors.toList());
```

4. **Extract complex predicates**
```java
// ‚úÖ Reusable and testable
Predicate<Product> isAvailable = p -> p.inStock && p.price > 0;
Predicate<Product> isElectronics = p -> p.category.equals("Electronics");

List<Product> result = products.stream()
    .filter(isAvailable.and(isElectronics))
    .collect(Collectors.toList());
```

---

## üìä Performance Tips

```java
List<Integer> large = generateLargeList(1_000_000);

// Filter early to reduce work
List<Integer> result = large.stream()
    .filter(n -> n > 100)          // Reduces from 1M to ~900K
    .filter(n -> n % 2 == 0)       // Further reduces
    .map(n -> n * 2)               // Process fewer elements
    .collect(Collectors.toList());

// Parallel for large datasets
List<Integer> result2 = large.parallelStream()
    .filter(n -> n > 100)
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());
```

---

## üéì When to Use Filter

### ‚úÖ Use filter() When:
- Selecting subset of elements
- Removing unwanted elements
- Conditional processing
- Multiple filtering criteria

### ‚ùå Don't Use When:
- Need to transform elements (use map)
- Need first match only (use findFirst)
- Simple loop suffices

---

## üìö Interview Questions

**Q1: What does filter() return?**
A: Returns a new Stream containing elements matching the predicate.

**Q2: Is filter() lazy or eager?**
A: Lazy - executed only when terminal operation is invoked.

**Q3: Can you chain multiple filters?**
A: Yes, filter().filter()... or use AND/OR in single predicate.

**Q4: Does filter() modify original collection?**
A: No, streams don't modify source. Returns new stream.

**Q5: filter() vs removeIf()?**
A: filter() returns new stream, removeIf() modifies collection in-place.

**Q6: How to filter nulls?**
A: Use filter(Objects::nonNull).

**Q7: Performance of chained filters?**
A: Multiple filters evaluated for each element. Combine for better performance.

**Q8: Can predicates be reused?**
A: Yes, define Predicate and reuse with and(), or(), negate().

---

## üìö Summary

- **filter()**: Intermediate operation to select elements matching predicate
- **Lazy**: Evaluated only on terminal operation
- **Chainable**: Can chain multiple filters
- **Non-modifying**: Doesn't change source collection
- **Best practices**: Filter early, use method references, extract complex predicates
- **Use cases**: Subset selection, conditional processing, removing unwanted elements
