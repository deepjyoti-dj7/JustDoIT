# üó∫Ô∏è Mapping Collections

## üìñ Overview

**Mapping** transforms elements in a stream from one form to another using functions:
- **map()** - One-to-one transformation
- **flatMap()** - One-to-many transformation (flattens nested structures)
- **mapToInt/Long/Double()** - Transform to primitive streams

```java
List<String> names = Arrays.asList("alice", "bob", "charlie");

List<String> upper = names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
// [ALICE, BOB, CHARLIE]
```

---

## ‚≠ê map() Operation

### Overview
Transforms each element using a function. Returns stream of transformed elements.

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper)
```

### Characteristics
- **Intermediate operation** - Returns Stream
- **Lazy** - Evaluated when terminal operation called
- **Stateless** - Each element transformed independently
- **One-to-one** - Each input produces one output

---

## üíª map() Usage

### 1. Transform Strings
```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// To uppercase
List<String> upper = words.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
// [APPLE, BANANA, CHERRY]

// Get lengths
List<Integer> lengths = words.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 6, 6]
```

### 2. Transform Numbers
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Square each number
List<Integer> squares = numbers.stream()
    .map(n -> n * n)
    .collect(Collectors.toList());
// [1, 4, 9, 16, 25]

// Convert to strings
List<String> strings = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.toList());
// ["1", "2", "3", "4", "5"]
```

### 3. Extract Object Properties
```java
class Person {
    String name;
    int age;
}

List<Person> people = getPeople();

// Extract names
List<String> names = people.stream()
    .map(Person::getName)
    .collect(Collectors.toList());

// Extract ages
List<Integer> ages = people.stream()
    .map(Person::getAge)
    .collect(Collectors.toList());
```

### 4. Transform Objects
```java
class Employee {
    String name;
    double salary;
}

class EmployeeDTO {
    String name;
    String salaryFormatted;
}

List<Employee> employees = getEmployees();

// Transform to DTOs
List<EmployeeDTO> dtos = employees.stream()
    .map(e -> new EmployeeDTO(e.name, "$" + e.salary))
    .collect(Collectors.toList());
```

---

## üéØ map() Real-World Examples

### 1. Format Product Display
```java
class Product {
    String name;
    double price;
}

List<Product> products = getProducts();

// Format for display
List<String> display = products.stream()
    .map(p -> p.name + ": $" + String.format("%.2f", p.price))
    .collect(Collectors.toList());
```

---

### 2. Convert IDs to Objects
```java
List<Long> userIds = Arrays.asList(1L, 2L, 3L);

// Fetch users by ID
List<User> users = userIds.stream()
    .map(this::getUserById)
    .collect(Collectors.toList());
```

---

### 3. Parse Strings to Numbers
```java
List<String> strings = Arrays.asList("10", "20", "30");

List<Integer> numbers = strings.stream()
    .map(Integer::parseInt)
    .collect(Collectors.toList());
// [10, 20, 30]
```

---

## ‚ö° Primitive Mapping

### mapToInt/Long/Double()
```java
List<String> words = Arrays.asList("apple", "banana", "cherry");

// Map to IntStream
IntStream lengths = words.stream()
    .mapToInt(String::length);

int totalLength = words.stream()
    .mapToInt(String::length)
    .sum();  // 17

// Map to DoubleStream
List<Product> products = getProducts();
double avgPrice = products.stream()
    .mapToDouble(Product::getPrice)
    .average()
    .orElse(0.0);
```

**Benefits:**
- Avoid boxing/unboxing
- Access primitive-specific operations (sum, average, max, min)
- Better performance

---

## üîÄ flatMap() Operation

### Overview
Transforms each element to a stream, then flattens all streams into one.

```java
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
```

### Characteristics
- **One-to-many** - Each input can produce multiple outputs
- **Flattens** - Nested structures become flat stream
- **Intermediate** - Returns Stream

---

## üíª flatMap() Usage

### 1. Flatten Nested Lists
```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4),
    Arrays.asList(5, 6)
);

// Flatten to single list
List<Integer> flat = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5, 6]
```

### 2. Split Strings to Words
```java
List<String> sentences = Arrays.asList(
    "Hello world",
    "Java streams",
    "FlatMap example"
);

// Get all words
List<String> words = sentences.stream()
    .flatMap(s -> Arrays.stream(s.split(" ")))
    .collect(Collectors.toList());
// [Hello, world, Java, streams, FlatMap, example]
```

### 3. Expand Objects to Collections
```java
class Order {
    List<Item> items;
}

List<Order> orders = getOrders();

// Get all items from all orders
List<Item> allItems = orders.stream()
    .flatMap(order -> order.items.stream())
    .collect(Collectors.toList());
```

### 4. Optional Flattening
```java
List<Optional<String>> optionals = Arrays.asList(
    Optional.of("A"),
    Optional.empty(),
    Optional.of("B"),
    Optional.empty(),
    Optional.of("C")
);

// Extract present values
List<String> values = optionals.stream()
    .flatMap(Optional::stream)
    .collect(Collectors.toList());
// [A, B, C]
```

---

## üéØ flatMap() Real-World Examples

### 1. Get All Tags from Articles
```java
class Article {
    String title;
    List<String> tags;
}

List<Article> articles = getArticles();

// Get all unique tags
Set<String> allTags = articles.stream()
    .flatMap(a -> a.tags.stream())
    .collect(Collectors.toSet());
```

---

### 2. Expand Nested Departments
```java
class Department {
    String name;
    List<Employee> employees;
}

List<Department> departments = getDepartments();

// Get all employees across departments
List<Employee> allEmployees = departments.stream()
    .flatMap(d -> d.employees.stream())
    .collect(Collectors.toList());
```

---

### 3. Parse Multiple Files
```java
List<Path> files = Arrays.asList(
    Paths.get("file1.txt"),
    Paths.get("file2.txt")
);

// Read all lines from all files
List<String> allLines = files.stream()
    .flatMap(path -> {
        try {
            return Files.lines(path);
        } catch (IOException e) {
            return Stream.empty();
        }
    })
    .collect(Collectors.toList());
```

---

### 4. Cartesian Product
```java
List<String> sizes = Arrays.asList("S", "M", "L");
List<String> colors = Arrays.asList("Red", "Blue");

// Generate all combinations
List<String> combinations = sizes.stream()
    .flatMap(size -> colors.stream()
        .map(color -> size + "-" + color))
    .collect(Collectors.toList());
// [S-Red, S-Blue, M-Red, M-Blue, L-Red, L-Blue]
```

---

## üÜö map() vs flatMap()

| Feature | map() | flatMap() |
|---------|-------|----------|
| **Transformation** | One-to-one | One-to-many |
| **Output** | Single element | Stream of elements |
| **Flattening** | No | Yes |
| **Use case** | Transform elements | Flatten nested structures |

```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);

// map() - keeps nesting
List<List<Integer>> mapped = nested.stream()
    .map(list -> list)
    .collect(Collectors.toList());
// [[1, 2], [3, 4]]

// flatMap() - flattens
List<Integer> flattened = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4]
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Null pointer in mapper**
```java
List<Person> people = Arrays.asList(
    new Person("Alice", 30),
    new Person(null, 25)
);

// ‚ùå NullPointerException
List<String> names = people.stream()
    .map(p -> p.name.toUpperCase())
    .collect(Collectors.toList());

// ‚úÖ Null-safe
List<String> names2 = people.stream()
    .map(p -> p.name != null ? p.name.toUpperCase() : "UNKNOWN")
    .collect(Collectors.toList());
```

2. **Checked exceptions in mapper**
```java
// ‚ùå Compile error - can't throw checked exception
list.stream()
    .map(s -> Integer.parseInt(s))  // NumberFormatException (unchecked - OK)
    .map(path -> Files.readString(path))  // IOException (checked - ERROR)
    .collect(Collectors.toList());

// ‚úÖ Wrap in try-catch or helper method
list.stream()
    .map(path -> {
        try {
            return Files.readString(path);
        } catch (IOException e) {
            return "";
        }
    })
    .collect(Collectors.toList());
```

3. **Using map() instead of flatMap()**
```java
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);

// ‚ùå Wrong - still nested
List<Stream<Integer>> wrong = nested.stream()
    .map(List::stream)
    .collect(Collectors.toList());

// ‚úÖ Use flatMap
List<Integer> correct = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
```

4. **Expensive operations in map**
```java
// ‚ùå Inefficient - maps all, filters later
list.stream()
    .map(this::expensiveTransform)
    .filter(this::isValid)
    .collect(Collectors.toList());

// ‚úÖ Filter first
list.stream()
    .filter(this::canTransform)
    .map(this::expensiveTransform)
    .collect(Collectors.toList());
```

---

## üí° Best Practices

1. **Use method references**
```java
// ‚úÖ Clean and readable
list.stream()
    .map(String::toUpperCase)
    .map(String::trim)
    .collect(Collectors.toList());
```

2. **Use primitive mappers for primitives**
```java
// ‚úÖ Efficient - no boxing
int sum = list.stream()
    .mapToInt(String::length)
    .sum();

// ‚ùå Inefficient - boxing overhead
int sum2 = list.stream()
    .map(String::length)
    .mapToInt(Integer::intValue)
    .sum();
```

3. **Handle nulls gracefully**
```java
// ‚úÖ Use Optional or default values
list.stream()
    .map(s -> s != null ? s.toUpperCase() : "")
    .collect(Collectors.toList());
```

4. **Extract complex mappers**
```java
// ‚úÖ Reusable and testable
Function<Employee, EmployeeDTO> toDTO = e -> new EmployeeDTO(
    e.name,
    e.department,
    String.format("$%.2f", e.salary)
);

List<EmployeeDTO> dtos = employees.stream()
    .map(toDTO)
    .collect(Collectors.toList());
```

---

## üìö Interview Questions

**Q1: map() vs flatMap()?**
A: map() is one-to-one transformation, flatMap() is one-to-many with flattening.

**Q2: When to use mapToInt()?**
A: When mapping to primitives - avoids boxing, enables primitive operations (sum, average).

**Q3: Can map() return null?**
A: Yes, but use filter(Objects::nonNull) or handle in mapper.

**Q4: Is map() lazy or eager?**
A: Lazy - executed only when terminal operation is called.

**Q5: How to flatten nested lists?**
A: Use flatMap(List::stream).

**Q6: Can you chain multiple maps?**
A: Yes, map().map()... - each transforms the previous result.

**Q7: Performance of map vs loop?**
A: Similar for sequential, better for parallel on large datasets.

**Q8: How to handle exceptions in map()?**
A: Wrap in try-catch or extract to helper method.

---

## üìö Summary

### map()
- **Purpose**: One-to-one element transformation
- **Returns**: Stream of transformed elements
- **Use**: Extract properties, convert types, transform objects
- **Variants**: mapToInt/Long/Double for primitives

### flatMap()
- **Purpose**: One-to-many transformation with flattening
- **Returns**: Flattened stream from nested streams
- **Use**: Flatten nested collections, split strings, expand objects
- **Key**: Transforms to Stream, then flattens

### Best Practices
- Use method references for clarity
- Use primitive mappers for performance
- Handle nulls gracefully
- Filter before expensive mapping
- Extract complex mappers to functions
