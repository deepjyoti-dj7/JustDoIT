# üîíüéØ PriorityBlockingQueue

## üìñ Overview

`PriorityBlockingQueue` is an **unbounded** blocking queue that orders elements by **priority** (not FIFO). It combines **PriorityQueue** with **thread-safety** for concurrent producer-consumer scenarios.

```java
public class PriorityBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable
```

**Core Feature:** **Thread-safe priority queue** with blocking operations.

---

## üîë Key Characteristics

1. **Priority Ordering** - Elements ordered by priority (not FIFO)
2. **Unbounded** - No capacity restrictions (grows dynamically)
3. **Thread-Safe** - Safe for concurrent access
4. **Blocking take()** - Blocks when empty
5. **Non-blocking put()** - Never blocks (unbounded)
6. **Binary Heap** - Internal min-heap structure
7. **No Null Elements** - Cannot insert null

---

## üíª Creating PriorityBlockingQueue

```java
import java.util.concurrent.*;
import java.util.*;

// 1. Default constructor - natural ordering
PriorityBlockingQueue<Integer> pq1 = new PriorityBlockingQueue<>();

// 2. With initial capacity
PriorityBlockingQueue<Integer> pq2 = new PriorityBlockingQueue<>(20);

// 3. With comparator (reverse order - max heap)
PriorityBlockingQueue<Integer> maxHeap = 
    new PriorityBlockingQueue<>(10, Collections.reverseOrder());

// 4. From collection
List<Integer> list = Arrays.asList(5, 2, 8, 1, 9);
PriorityBlockingQueue<Integer> pq3 = new PriorityBlockingQueue<>(list);

// 5. With custom comparator
PriorityBlockingQueue<Task> taskQueue = 
    new PriorityBlockingQueue<>(10, Comparator.comparingInt(Task::getPriority));
```

---

## üé® Basic Operations

```java
public class PriorityBlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        PriorityBlockingQueue<Integer> pq = new PriorityBlockingQueue<>();
        
        // Add elements (order doesn't matter)
        pq.offer(5);
        pq.offer(2);
        pq.offer(8);
        pq.offer(1);
        pq.offer(9);
        
        System.out.println("Size: " + pq.size());  // 5
        
        // Peek (minimum element)
        System.out.println("Peek: " + pq.peek());  // 1 (min)
        
        // Take (blocks if empty, removes min)
        System.out.println("Take: " + pq.take());  // 1
        System.out.println("Take: " + pq.take());  // 2
        System.out.println("Take: " + pq.take());  // 5
        
        // Put (never blocks - unbounded)
        pq.put(3);
        pq.put(7);
        
        System.out.println("Size: " + pq.size());  // 4
        
        // Poll with timeout (returns null if empty after timeout)
        Integer item = pq.poll(1, TimeUnit.SECONDS);
        System.out.println("Polled: " + item);  // 3
        
        // Iteration (NOT in sorted order!)
        System.out.print("Iteration: ");
        for (Integer num : pq) {
            System.out.print(num + " ");  // Heap order, not sorted
        }
        System.out.println();
        
        // Drain to list (sorted)
        List<Integer> sorted = new ArrayList<>();
        pq.drainTo(sorted);
        System.out.println("Drained (sorted): " + sorted);  // [7, 8, 9]
    }
}
```

---

## üèóÔ∏è Internal Structure

```java
public class PriorityBlockingQueue<E> {
    // Internal array for heap
    private transient Object[] queue;
    
    // Current size
    private transient int size;
    
    // Comparator (null for natural ordering)
    private transient Comparator<? super E> comparator;
    
    // Single lock for all operations
    private final ReentrantLock lock;
    
    // Condition for blocking take
    private final Condition notEmpty;
}
```

**Binary Heap Structure:**
```
Min-Heap Example: [1, 3, 2, 7, 5, 8, 9]

Tree representation:
       1
      / \
     3   2
    / \ / \
   7  5 8  9

Parent at index i
Left child at 2*i + 1
Right child at 2*i + 2
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `offer(e)` / `put(e)` | O(log n) | Heap insertion |
| `take()` / `poll()` | O(log n) | Heap deletion |
| `peek()` | O(1) | Head of heap |
| `size()` | O(1) | |
| `contains(o)` | O(n) | Linear search |
| `remove(o)` | O(n) | Search + heap fix |
| Iteration | O(n) | Not sorted |

**Space:** O(n) where n is number of elements

---

## üéØ Priority-Based Task Processing

```java
class Task implements Comparable<Task> {
    private String name;
    private int priority;  // Lower number = higher priority
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    public String getName() { return name; }
    public int getPriority() { return priority; }
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public String toString() {
        return String.format("Task{name='%s', priority=%d}", name, priority);
    }
}

class TaskProcessor implements Runnable {
    private PriorityBlockingQueue<Task> taskQueue;
    
    public TaskProcessor(PriorityBlockingQueue<Task> taskQueue) {
        this.taskQueue = taskQueue;
    }
    
    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                Task task = taskQueue.take();  // Blocks if empty
                processTask(task);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    private void processTask(Task task) {
        System.out.println(Thread.currentThread().getName() + 
                         " processing: " + task);
        try { Thread.sleep(100); } catch (InterruptedException e) {}
    }
}

// Usage
public class PriorityTaskDemo {
    public static void main(String[] args) throws InterruptedException {
        PriorityBlockingQueue<Task> queue = new PriorityBlockingQueue<>();
        
        // Start worker threads
        Thread worker1 = new Thread(new TaskProcessor(queue), "Worker-1");
        Thread worker2 = new Thread(new TaskProcessor(queue), "Worker-2");
        worker1.start();
        worker2.start();
        
        // Add tasks with different priorities
        queue.put(new Task("Low priority task", 10));
        queue.put(new Task("Critical task", 1));
        queue.put(new Task("High priority task", 3));
        queue.put(new Task("Medium priority task", 5));
        queue.put(new Task("Urgent task", 2));
        
        // Critical task (priority 1) will be processed first!
        
        Thread.sleep(2000);
        worker1.interrupt();
        worker2.interrupt();
    }
}
```

**Output:**
```
Worker-1 processing: Task{name='Critical task', priority=1}
Worker-2 processing: Task{name='Urgent task', priority=2}
Worker-1 processing: Task{name='High priority task', priority=3}
Worker-2 processing: Task{name='Medium priority task', priority=5}
Worker-1 processing: Task{name='Low priority task', priority=10}
```

---

## üéØ Real-World Examples

### Example 1: Hospital Emergency Room

```java
class Patient implements Comparable<Patient> {
    private String name;
    private int severity;  // 1=critical, 5=minor
    private long arrivalTime;
    
    public Patient(String name, int severity) {
        this.name = name;
        this.severity = severity;
        this.arrivalTime = System.currentTimeMillis();
    }
    
    @Override
    public int compareTo(Patient other) {
        // First by severity, then by arrival time
        int severityCompare = Integer.compare(this.severity, other.severity);
        if (severityCompare != 0) return severityCompare;
        return Long.compare(this.arrivalTime, other.arrivalTime);
    }
    
    @Override
    public String toString() {
        return String.format("Patient{name='%s', severity=%d}", name, severity);
    }
}

class EmergencyRoom {
    private PriorityBlockingQueue<Patient> waitingRoom;
    private Thread[] doctors;
    
    public EmergencyRoom(int numDoctors) {
        this.waitingRoom = new PriorityBlockingQueue<>();
        this.doctors = new Thread[numDoctors];
        
        for (int i = 0; i < numDoctors; i++) {
            final int doctorId = i + 1;
            doctors[i] = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        Patient patient = waitingRoom.take();
                        treatPatient(doctorId, patient);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            doctors[i].start();
        }
    }
    
    public void admitPatient(Patient patient) {
        waitingRoom.put(patient);
        System.out.println("Admitted: " + patient);
    }
    
    private void treatPatient(int doctorId, Patient patient) {
        System.out.println("Doctor-" + doctorId + " treating: " + patient);
        try { Thread.sleep(500); } catch (InterruptedException e) {}
    }
}

// Usage
EmergencyRoom er = new EmergencyRoom(2);
er.admitPatient(new Patient("John", 5));    // Minor
er.admitPatient(new Patient("Alice", 1));   // Critical
er.admitPatient(new Patient("Bob", 3));     // Moderate
er.admitPatient(new Patient("Charlie", 1)); // Critical
// Alice and Charlie (critical) will be treated first!
```

---

### Example 2: Job Scheduler with Deadlines

```java
class Job implements Comparable<Job> {
    private String id;
    private long deadline;  // Timestamp
    
    public Job(String id, long deadlineInSeconds) {
        this.id = id;
        this.deadline = System.currentTimeMillis() + (deadlineInSeconds * 1000);
    }
    
    public String getId() { return id; }
    public long getDeadline() { return deadline; }
    
    @Override
    public int compareTo(Job other) {
        return Long.compare(this.deadline, other.deadline);
    }
    
    @Override
    public String toString() {
        long timeLeft = (deadline - System.currentTimeMillis()) / 1000;
        return String.format("Job{id='%s', deadline in %ds}", id, timeLeft);
    }
}

class JobScheduler {
    private PriorityBlockingQueue<Job> jobQueue;
    
    public JobScheduler() {
        this.jobQueue = new PriorityBlockingQueue<>();
        
        // Start scheduler thread
        new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Job job = jobQueue.take();
                    executeJob(job);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }).start();
    }
    
    public void scheduleJob(Job job) {
        jobQueue.put(job);
        System.out.println("Scheduled: " + job);
    }
    
    private void executeJob(Job job) {
        System.out.println("Executing: " + job);
        try { Thread.sleep(200); } catch (InterruptedException e) {}
    }
}

// Usage
JobScheduler scheduler = new JobScheduler();
scheduler.scheduleJob(new Job("Job-1", 10));  // 10s deadline
scheduler.scheduleJob(new Job("Job-2", 3));   // 3s deadline (urgent)
scheduler.scheduleJob(new Job("Job-3", 7));   // 7s deadline
// Job-2 will execute first (earliest deadline)!
```

---

### Example 3: Stock Order Matching

```java
class Order implements Comparable<Order> {
    private String id;
    private double price;
    private boolean isBuy;  // true=buy, false=sell
    
    public Order(String id, double price, boolean isBuy) {
        this.id = id;
        this.price = price;
        this.isBuy = isBuy;
    }
    
    @Override
    public int compareTo(Order other) {
        if (isBuy) {
            // Buy orders: higher price has priority
            return Double.compare(other.price, this.price);
        } else {
            // Sell orders: lower price has priority
            return Double.compare(this.price, other.price);
        }
    }
    
    @Override
    public String toString() {
        return String.format("Order{id='%s', price=%.2f, type=%s}", 
                           id, price, isBuy ? "BUY" : "SELL");
    }
}

class OrderBook {
    private PriorityBlockingQueue<Order> buyOrders;
    private PriorityBlockingQueue<Order> sellOrders;
    
    public OrderBook() {
        this.buyOrders = new PriorityBlockingQueue<>();
        this.sellOrders = new PriorityBlockingQueue<>();
    }
    
    public void addOrder(Order order) {
        if (order.isBuy) {
            buyOrders.put(order);
        } else {
            sellOrders.put(order);
        }
        matchOrders();
    }
    
    private void matchOrders() {
        Order buyOrder = buyOrders.peek();
        Order sellOrder = sellOrders.peek();
        
        if (buyOrder != null && sellOrder != null &&
            buyOrder.price >= sellOrder.price) {
            buyOrders.poll();
            sellOrders.poll();
            System.out.println("MATCHED: " + buyOrder + " with " + sellOrder);
        }
    }
}
```

---

### Example 4: Event Processing by Priority

```java
enum EventPriority {
    LOW(3), MEDIUM(2), HIGH(1), CRITICAL(0);
    
    private int value;
    EventPriority(int value) { this.value = value; }
    public int getValue() { return value; }
}

class Event implements Comparable<Event> {
    private String name;
    private EventPriority priority;
    private long timestamp;
    
    public Event(String name, EventPriority priority) {
        this.name = name;
        this.priority = priority;
        this.timestamp = System.currentTimeMillis();
    }
    
    @Override
    public int compareTo(Event other) {
        // First by priority, then by timestamp
        int priorityCompare = Integer.compare(
            this.priority.getValue(), 
            other.priority.getValue()
        );
        if (priorityCompare != 0) return priorityCompare;
        return Long.compare(this.timestamp, other.timestamp);
    }
    
    @Override
    public String toString() {
        return String.format("Event{name='%s', priority=%s}", name, priority);
    }
}

class EventProcessor {
    private PriorityBlockingQueue<Event> eventQueue;
    
    public EventProcessor() {
        this.eventQueue = new PriorityBlockingQueue<>();
        
        new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Event event = eventQueue.take();
                    handleEvent(event);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }).start();
    }
    
    public void publishEvent(Event event) {
        eventQueue.put(event);
    }
    
    private void handleEvent(Event event) {
        System.out.println("Handling: " + event);
        try { Thread.sleep(100); } catch (InterruptedException e) {}
    }
}

// Usage
EventProcessor processor = new EventProcessor();
processor.publishEvent(new Event("User login", EventPriority.LOW));
processor.publishEvent(new Event("Security breach", EventPriority.CRITICAL));
processor.publishEvent(new Event("Payment received", EventPriority.HIGH));
// Security breach will be processed first!
```

---

## üÜö PriorityBlockingQueue vs PriorityQueue

| Feature | PriorityBlockingQueue | PriorityQueue |
|---------|----------------------|---------------|
| **Thread-safe** | Yes | No |
| **Blocking** | Yes (take) | No |
| **Capacity** | Unbounded | Unbounded |
| **put() blocks** | No (unbounded) | N/A |
| **take() blocks** | Yes (if empty) | N/A |
| **Performance** | Slower (locks) | Faster |
| **Use case** | Concurrent | Single-threaded |

---

## üÜö PriorityBlockingQueue vs LinkedBlockingQueue

| Feature | PriorityBlockingQueue | LinkedBlockingQueue |
|---------|----------------------|---------------------|
| **Ordering** | Priority | FIFO |
| **Bounded** | No | Optional |
| **Comparator** | Required/Natural | N/A |
| **put() blocks** | No | Yes (if bounded & full) |
| **Use case** | Priority processing | FIFO processing |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. put() never blocks (unbounded)
PriorityBlockingQueue<Integer> pq = new PriorityBlockingQueue<>();
pq.put(1);  // Never blocks!

// 2. Iteration NOT in priority order
for (Integer num : pq) {
    // Heap order, not sorted!
}

// 3. Modifying objects after insertion breaks heap
class Task implements Comparable<Task> {
    int priority;
    // ...
}
Task task = new Task(1);
pq.add(task);
task.priority = 10;  // ‚ùå Breaks heap property!

// 4. Forgetting Comparable or Comparator
// class Task { }  // No Comparable
// PriorityBlockingQueue<Task> pq = new PriorityBlockingQueue<>();
// pq.add(new Task());  // ClassCastException!

// 5. Expecting FIFO for equal priorities
pq.offer(5);
pq.offer(5);
// Order not guaranteed for equal priorities
```

---

## üí° Best Practices

1. **Implement Comparable** or provide Comparator
2. **Don't modify objects** after insertion
3. **Use drainTo()** for sorted retrieval
4. **Monitor memory** - unbounded can cause OOM
5. **Use take()** for blocking retrieval
6. **Don't rely on iteration order** - use poll() for sorted access
7. **Ensure immutable priority** - don't change after insertion
8. **Consider capacity** - unbounded can grow indefinitely

---

## üéØ When to Use PriorityBlockingQueue

**Use PriorityBlockingQueue when:**
- ‚úÖ Need thread-safe priority queue
- ‚úÖ Producer-consumer with priorities
- ‚úÖ Task scheduling by priority
- ‚úÖ Event processing by priority
- ‚úÖ Multiple threads producing/consuming
- ‚úÖ Resource allocation by priority

**Don't use PriorityBlockingQueue when:**
- ‚ùå Need FIFO ordering ‚Üí Use `LinkedBlockingQueue`
- ‚ùå Single-threaded ‚Üí Use `PriorityQueue`
- ‚ùå Need bounded capacity ‚Üí Use `ArrayBlockingQueue` or bounded `LinkedBlockingQueue`
- ‚ùå All equal priority ‚Üí Use `LinkedBlockingQueue` (FIFO)

---

## üéì Interview Questions

**Q: What is PriorityBlockingQueue?**
A: Unbounded thread-safe blocking queue that orders elements by priority.

**Q: Does put() block?**
A: No, it's unbounded so put() never blocks.

**Q: Does take() block?**
A: Yes, blocks when queue is empty.

**Q: Bounded or unbounded?**
A: Unbounded - no capacity restrictions.

**Q: FIFO ordering?**
A: No, priority ordering using Comparable or Comparator.

**Q: Iteration order?**
A: Heap order, NOT sorted. Use poll() repeatedly for sorted access.

**Q: Time complexity?**
A: O(log n) for offer/poll, O(1) for peek, O(n) for remove/contains.

---

## üìö Summary

- **PriorityBlockingQueue**: Unbounded thread-safe priority queue
- **Priority ordering** using Comparable or Comparator (not FIFO)
- **Blocking take()** when empty, **non-blocking put()** (unbounded)
- **Binary heap** internal structure (min-heap by default)
- **Thread-safe** for concurrent producer-consumer
- **Unbounded** - grows dynamically (monitor memory)
- **O(log n)** for insert/remove operations
- Perfect for **priority-based task scheduling**, **event processing**
- **Iteration NOT sorted** - use poll() repeatedly for sorted access
- Don't modify object priority after insertion
