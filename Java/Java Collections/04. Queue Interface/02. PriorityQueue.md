# üéØ PriorityQueue

## üìñ Overview

`PriorityQueue` is a **heap-based** queue where elements are ordered by **priority** (not FIFO). It uses a **min-heap** by default.

```java
public class PriorityQueue<E> extends AbstractQueue<E>
    implements Serializable
```

---

## üîë Key Characteristics

1. **Priority Ordering** - Not FIFO, elements ordered by priority
2. **Min-Heap** - Smallest/highest priority element at head (by default)
3. **No Null** - Does not allow null elements
4. **Unbounded** - Grows dynamically (no capacity limit)
5. **Not Thread-Safe** - Use PriorityBlockingQueue for thread-safety
6. **O(log n)** - Add and remove operations
7. **O(1)** - Peek operation
8. **Not Sorted** - Only head is guaranteed to be min/max

---

## üíª Creating PriorityQueue

```java
import java.util.*;

// 1. Natural ordering (min-heap for numbers)
PriorityQueue<Integer> pq1 = new PriorityQueue<>();
pq1.offer(5);
pq1.offer(2);
pq1.offer(8);
System.out.println(pq1.poll());  // 2 (smallest)

// 2. Reverse order (max-heap)
PriorityQueue<Integer> pq2 = new PriorityQueue<>(Comparator.reverseOrder());
pq2.offer(5);
pq2.offer(2);
pq2.offer(8);
System.out.println(pq2.poll());  // 8 (largest)

// 3. With initial capacity
PriorityQueue<Integer> pq3 = new PriorityQueue<>(20);

// 4. From collection
List<Integer> list = Arrays.asList(5, 2, 8, 1);
PriorityQueue<Integer> pq4 = new PriorityQueue<>(list);

// 5. Custom comparator
PriorityQueue<String> pq5 = new PriorityQueue<>(Comparator.comparing(String::length));
```

---

## üé® Basic Operations

```java
public class PriorityQueueDemo {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        
        // Add elements
        pq.offer(5);
        pq.offer(2);
        pq.offer(8);
        pq.offer(1);
        pq.offer(9);
        
        System.out.println("Queue: " + pq);  // [1, 2, 8, 5, 9] - heap order
        
        // Peek (without removing)
        System.out.println("Head: " + pq.peek());  // 1 (smallest)
        
        // Poll (remove and return head)
        System.out.println("Removed: " + pq.poll());  // 1
        System.out.println("Removed: " + pq.poll());  // 2
        System.out.println("Removed: " + pq.poll());  // 5
        
        System.out.println("Remaining: " + pq);  // [8, 9]
        
        // Size
        System.out.println("Size: " + pq.size());  // 2
        
        // Contains
        System.out.println("Contains 8? " + pq.contains(8));  // true
    }
}
```

---

## üèóÔ∏è Internal Structure (Min-Heap)

```java
// Binary Heap - Complete Binary Tree
// Parent at index i
// Left child at 2*i + 1
// Right child at 2*i + 2

// Example: [1, 2, 5, 8, 9]
//
//        1
//      /   \
//     2     5
//    / \
//   8   9

// Internal array: [1, 2, 5, 8, 9]
// Index:          [0, 1, 2, 3, 4]
```

**Heap Properties:**
- Parent ‚â§ Children (min-heap)
- Complete binary tree (filled left to right)
- No particular order among siblings

---

## üìä Performance

| Operation | Time Complexity |
|-----------|----------------|
| `offer(e)` | O(log n) |
| `poll()` | O(log n) |
| `peek()` | O(1) |
| `remove(o)` | O(n) |
| `contains(o)` | O(n) |
| `size()` | O(1) |

---

## üéì Natural Ordering (Comparable)

```java
class Task implements Comparable<Task> {
    private String name;
    private int priority;  // Lower number = higher priority
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public String toString() {
        return name + "(P" + priority + ")";
    }
}

// Usage
PriorityQueue<Task> tasks = new PriorityQueue<>();
tasks.offer(new Task("Low priority", 5));
tasks.offer(new Task("High priority", 1));
tasks.offer(new Task("Medium priority", 3));

while (!tasks.isEmpty()) {
    System.out.println(tasks.poll());
}
// Output:
// High priority(P1)
// Medium priority(P3)
// Low priority(P5)
```

---

## üéì Custom Comparator

```java
class Student {
    private String name;
    private double gpa;
    
    public Student(String name, double gpa) {
        this.name = name;
        this.gpa = gpa;
    }
    
    public String getName() { return name; }
    public double getGpa() { return gpa; }
    
    @Override
    public String toString() {
        return name + "(" + gpa + ")";
    }
}

// Sort by GPA (descending - highest GPA first)
PriorityQueue<Student> students = new PriorityQueue<>(
    Comparator.comparingDouble(Student::getGpa).reversed()
);

students.offer(new Student("Alice", 3.5));
students.offer(new Student("Bob", 3.9));
students.offer(new Student("Charlie", 3.2));

while (!students.isEmpty()) {
    System.out.println(students.poll());
}
// Output:
// Bob(3.9)
// Alice(3.5)
// Charlie(3.2)
```

---

## üîÑ Iteration

```java
PriorityQueue<Integer> pq = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1, 9));

// 1. For-each (doesn't remove, NOT in sorted order)
for (Integer num : pq) {
    System.out.print(num + " ");  // 1 2 8 5 9 (heap order, NOT sorted)
}
System.out.println();

// 2. While polling (removes, in sorted order)
PriorityQueue<Integer> pq2 = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1, 9));
while (!pq2.isEmpty()) {
    System.out.print(pq2.poll() + " ");  // 1 2 5 8 9 (sorted order)
}
System.out.println();

// 3. Stream (sorted)
PriorityQueue<Integer> pq3 = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1, 9));
pq3.stream().sorted().forEach(n -> System.out.print(n + " "));  // 1 2 5 8 9
```

**Important:** Iteration order is **NOT sorted** - only head is guaranteed to be min/max!

---

## üéØ Real-World Examples

### Example 1: Task Scheduling

```java
class Task {
    private String name;
    private int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    public String getName() { return name; }
    
    public int getPriority() { return priority; }
}

class TaskScheduler {
    private PriorityQueue<Task> taskQueue;
    
    public TaskScheduler() {
        // Higher priority number = higher priority
        taskQueue = new PriorityQueue<>(
            Comparator.comparingInt(Task::getPriority).reversed()
        );
    }
    
    public void addTask(Task task) {
        taskQueue.offer(task);
        System.out.println("Added: " + task.getName() + " (Priority: " + task.getPriority() + ")");
    }
    
    public void executeNext() {
        Task task = taskQueue.poll();
        if (task != null) {
            System.out.println("Executing: " + task.getName());
        } else {
            System.out.println("No tasks to execute");
        }
    }
}

// Usage
TaskScheduler scheduler = new TaskScheduler();
scheduler.addTask(new Task("Backup database", 5));
scheduler.addTask(new Task("Send email", 2));
scheduler.addTask(new Task("Critical fix", 10));

scheduler.executeNext();  // Executes: Critical fix (priority 10)
scheduler.executeNext();  // Executes: Backup database (priority 5)
```

---

### Example 2: Hospital Emergency Room

```java
class Patient implements Comparable<Patient> {
    private String name;
    private int severity;  // 1=critical, 10=minor
    private LocalTime arrivalTime;
    
    public Patient(String name, int severity) {
        this.name = name;
        this.severity = severity;
        this.arrivalTime = LocalTime.now();
    }
    
    @Override
    public int compareTo(Patient other) {
        // First by severity (lower = more critical)
        int severityCompare = Integer.compare(this.severity, other.severity);
        if (severityCompare != 0) return severityCompare;
        
        // Then by arrival time (earlier first)
        return this.arrivalTime.compareTo(other.arrivalTime);
    }
    
    @Override
    public String toString() {
        return name + " (Severity: " + severity + ")";
    }
}

class EmergencyRoom {
    private PriorityQueue<Patient> waitingRoom = new PriorityQueue<>();
    
    public void admitPatient(Patient patient) {
        waitingRoom.offer(patient);
        System.out.println("Admitted: " + patient);
    }
    
    public void treatNext() {
        Patient patient = waitingRoom.poll();
        if (patient != null) {
            System.out.println("Treating: " + patient);
        }
    }
}

// Usage
EmergencyRoom er = new EmergencyRoom();
er.admitPatient(new Patient("John", 5));
er.admitPatient(new Patient("Alice", 1));  // Critical
er.admitPatient(new Patient("Bob", 8));
er.treatNext();  // Treats Alice first (severity 1)
```

---

### Example 3: Merge K Sorted Lists

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> pq = new PriorityQueue<>(
        Comparator.comparingInt(node -> node.val)
    );
    
    // Add first node from each list
    for (ListNode node : lists) {
        if (node != null) {
            pq.offer(node);
        }
    }
    
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (!pq.isEmpty()) {
        ListNode smallest = pq.poll();
        current.next = smallest;
        current = current.next;
        
        if (smallest.next != null) {
            pq.offer(smallest.next);
        }
    }
    
    return dummy.next;
}
```

---

### Example 4: Top K Frequent Elements

```java
public List<Integer> topKFrequent(int[] nums, int k) {
    // Count frequencies
    Map<Integer, Integer> freqMap = new HashMap<>();
    for (int num : nums) {
        freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
    }
    
    // Min-heap of size k
    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>(
        Comparator.comparingInt(Map.Entry::getValue)
    );
    
    for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
        pq.offer(entry);
        if (pq.size() > k) {
            pq.poll();  // Remove least frequent
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!pq.isEmpty()) {
        result.add(pq.poll().getKey());
    }
    
    return result;
}
```

---

### Example 5: Dijkstra's Algorithm

```java
class Node implements Comparable<Node> {
    int vertex;
    int distance;
    
    Node(int vertex, int distance) {
        this.vertex = vertex;
        this.distance = distance;
    }
    
    @Override
    public int compareTo(Node other) {
        return Integer.compare(this.distance, other.distance);
    }
}

public int[] dijkstra(int[][] graph, int start) {
    int n = graph.length;
    int[] distances = new int[n];
    Arrays.fill(distances, Integer.MAX_VALUE);
    distances[start] = 0;
    
    PriorityQueue<Node> pq = new PriorityQueue<>();
    pq.offer(new Node(start, 0));
    
    while (!pq.isEmpty()) {
        Node current = pq.poll();
        int u = current.vertex;
        
        if (current.distance > distances[u]) continue;
        
        for (int v = 0; v < n; v++) {
            if (graph[u][v] != 0) {
                int newDist = distances[u] + graph[u][v];
                if (newDist < distances[v]) {
                    distances[v] = newDist;
                    pq.offer(new Node(v, newDist));
                }
            }
        }
    }
    
    return distances;
}
```

---

## üÜö PriorityQueue vs Queue

| Feature | PriorityQueue | Queue (FIFO) |
|---------|--------------|--------------|
| **Order** | Priority-based | FIFO |
| **Remove** | Highest priority | First added |
| **Use case** | Priority processing | Sequential processing |
| **Performance** | O(log n) | O(1) |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Null not allowed
PriorityQueue<Integer> pq = new PriorityQueue<>();
// pq.offer(null);  // NullPointerException

// 2. Iteration NOT in sorted order
PriorityQueue<Integer> pq2 = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1));
for (Integer num : pq2) {
    System.out.print(num + " ");  // 1 2 8 5 (heap order, NOT sorted!)
}

// 3. Changing priority after insertion
class MutableTask implements Comparable<MutableTask> {
    int priority;
    public int compareTo(MutableTask o) { return Integer.compare(priority, o.priority); }
}
PriorityQueue<MutableTask> tasks = new PriorityQueue<>();
MutableTask task = new MutableTask();
task.priority = 5;
tasks.offer(task);
task.priority = 1;  // ‚ö†Ô∏è Heap structure broken!

// 4. Not implementing Comparable without Comparator
class Person {
    String name;
}
// PriorityQueue<Person> pq = new PriorityQueue<>();  // ClassCastException
PriorityQueue<Person> pq = new PriorityQueue<>(Comparator.comparing(p -> p.name));  // ‚úÖ
```

---

## üí° Best Practices

1. **Ensure elements are Comparable** or provide Comparator
2. **Don't modify priority** after insertion
3. **Use poll() for sorted order**, not iteration
4. **Consider max-heap** with `Comparator.reverseOrder()`
5. **Use for top-K problems** efficiently
6. **Thread-safe?** Use `PriorityBlockingQueue`
7. **Initialize with capacity** if size known: `new PriorityQueue<>(expectedSize)`

---

## üéØ When to Use PriorityQueue

**Use PriorityQueue when:**
- ‚úÖ Need priority-based processing
- ‚úÖ Top K elements problems
- ‚úÖ Task scheduling by priority
- ‚úÖ Dijkstra's/Prim's algorithms
- ‚úÖ Merge K sorted arrays
- ‚úÖ Median finding

**Don't use PriorityQueue when:**
- ‚ùå Need FIFO order ‚Üí Use `Queue` (LinkedList/ArrayDeque)
- ‚ùå Need sorted iteration ‚Üí Sort separately
- ‚ùå Need thread-safety ‚Üí Use `PriorityBlockingQueue`
- ‚ùå Need random access ‚Üí Use `List`

---

## üìö Summary

- **PriorityQueue**: Heap-based queue with priority ordering
- **Min-heap** by default (smallest element at head)
- **O(log n)** for add/remove, **O(1)** for peek
- **No null** elements allowed
- **Not thread-safe** - use PriorityBlockingQueue
- **Iteration NOT sorted** - only head guaranteed
- Must be **Comparable** or use **Comparator**
- Perfect for **priority-based** algorithms and **top-K** problems
