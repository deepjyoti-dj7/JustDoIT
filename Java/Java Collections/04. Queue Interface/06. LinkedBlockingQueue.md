# üîó LinkedBlockingQueue

## üìñ Overview

`LinkedBlockingQueue` is an **optionally-bounded** blocking queue based on **linked nodes**. It provides **higher throughput** than `ArrayBlockingQueue` and is ideal for **producer-consumer** scenarios.

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable
```

**Core Feature:** **Separate locks** for put and take operations for better concurrency.

---

## üîë Key Characteristics

1. **Optionally Bounded** - Can be bounded or unbounded
2. **Linked Nodes** - Singly-linked list structure
3. **FIFO Ordering** - First-In-First-Out
4. **Separate Locks** - Different locks for put and take (higher throughput)
5. **Thread-Safe** - Safe for concurrent access
6. **No Null Elements** - Cannot insert null
7. **Higher Throughput** - Better than ArrayBlockingQueue for concurrent ops

---

## üíª Creating LinkedBlockingQueue

```java
import java.util.concurrent.*;
import java.util.*;

// 1. Unbounded queue (capacity = Integer.MAX_VALUE)
BlockingQueue<Integer> unbounded = new LinkedBlockingQueue<>();

// 2. Bounded queue with specific capacity
BlockingQueue<String> bounded = new LinkedBlockingQueue<>(10);

// 3. From collection
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
BlockingQueue<Integer> fromCollection = new LinkedBlockingQueue<>(list);

// 4. As Queue interface
Queue<String> queue = new LinkedBlockingQueue<>();

// 5. As BlockingQueue interface (most common)
BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>(100);
```

---

## üé® Basic Operations

```java
public class LinkedBlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(5);
        
        // Non-blocking operations
        queue.offer("Task1");
        queue.offer("Task2");
        queue.offer("Task3");
        
        System.out.println("Size: " + queue.size());  // 3
        System.out.println("Remaining capacity: " + queue.remainingCapacity());  // 2
        
        // Blocking put (waits if full)
        queue.put("Task4");
        queue.put("Task5");
        
        System.out.println("Queue is full: " + (queue.remainingCapacity() == 0));  // true
        
        // Blocking take (waits if empty)
        String task = queue.take();
        System.out.println("Taken: " + task);  // Task1 (FIFO)
        
        // Timed operations
        boolean offered = queue.offer("Task6", 1, TimeUnit.SECONDS);
        System.out.println("Offered with timeout: " + offered);  // true
        
        String polled = queue.poll(1, TimeUnit.SECONDS);
        System.out.println("Polled: " + polled);  // Task2
        
        // Peek without removing
        System.out.println("Peek: " + queue.peek());  // Task3
        System.out.println("Size after peek: " + queue.size());  // 4
        
        // Drain to collection
        List<String> drained = new ArrayList<>();
        queue.drainTo(drained);
        System.out.println("Drained: " + drained);  // [Task3, Task4, Task5, Task6]
        System.out.println("Queue size: " + queue.size());  // 0
    }
}
```

---

## üèóÔ∏è Internal Structure

```java
public class LinkedBlockingQueue<E> {
    // Node structure
    static class Node<E> {
        E item;
        Node<E> next;
        
        Node(E x) { item = x; }
    }
    
    // Separate locks for put and take
    private final ReentrantLock takeLock = new ReentrantLock();
    private final ReentrantLock putLock = new ReentrantLock();
    
    // Head and tail of linked list
    transient Node<E> head;
    private transient Node<E> last;
    
    // Capacity
    private final int capacity;
    
    // Current size (atomic)
    private final AtomicInteger count = new AtomicInteger();
}
```

**Structure Visualization:**
```
head -> [Node1] -> [Node2] -> [Node3] -> last
         item1      item2      item3
         
takeLock: Controls take/poll operations (removes from head)
putLock: Controls put/offer operations (adds to tail)
```

**Key Advantage:** Separate locks allow concurrent put and take operations!

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `put(e)` / `offer(e)` | O(1) | Amortized constant |
| `take()` / `poll()` | O(1) | Amortized constant |
| `peek()` | O(1) | |
| `size()` | O(1) | Atomic count |
| `remainingCapacity()` | O(1) | |
| `remove(o)` | O(n) | Linear search, locks both |
| `contains(o)` | O(n) | Linear search, locks both |
| `drainTo(c)` | O(n) | Where n = elements |

**Throughput:** Higher than ArrayBlockingQueue due to separate locks.

---

## üéØ Producer-Consumer Pattern

```java
class Task {
    private int id;
    private String description;
    
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }
    
    @Override
    public String toString() {
        return "Task{id=" + id + ", desc='" + description + "'}";
    }
}

class Producer implements Runnable {
    private BlockingQueue<Task> queue;
    private int taskCount;
    
    public Producer(BlockingQueue<Task> queue, int taskCount) {
        this.queue = queue;
        this.taskCount = taskCount;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= taskCount; i++) {
                Task task = new Task(i, "Process data " + i);
                System.out.println(Thread.currentThread().getName() + " producing: " + task);
                queue.put(task);  // Blocks if queue is full
                Thread.sleep(50);  // Simulate work
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class Consumer implements Runnable {
    private BlockingQueue<Task> queue;
    
    public Consumer(BlockingQueue<Task> queue) {
        this.queue = queue;
    }
    
    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                Task task = queue.take();  // Blocks if queue is empty
                System.out.println(Thread.currentThread().getName() + " consuming: " + task);
                Thread.sleep(100);  // Simulate processing
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// Usage
public class ProducerConsumerExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Task> queue = new LinkedBlockingQueue<>(10);
        
        // Create producers and consumers
        Thread producer1 = new Thread(new Producer(queue, 5), "Producer-1");
        Thread producer2 = new Thread(new Producer(queue, 5), "Producer-2");
        Thread consumer1 = new Thread(new Consumer(queue), "Consumer-1");
        Thread consumer2 = new Thread(new Consumer(queue), "Consumer-2");
        
        // Start all threads
        producer1.start();
        producer2.start();
        consumer1.start();
        consumer2.start();
        
        // Wait for producers to finish
        producer1.join();
        producer2.join();
        
        // Give consumers time to finish
        Thread.sleep(2000);
        consumer1.interrupt();
        consumer2.interrupt();
    }
}
```

---

## üéØ Real-World Examples

### Example 1: Web Crawler Task Queue

```java
class URLTask {
    private String url;
    private int depth;
    
    public URLTask(String url, int depth) {
        this.url = url;
        this.depth = depth;
    }
    
    public String getUrl() { return url; }
    public int getDepth() { return depth; }
}

class WebCrawler {
    private BlockingQueue<URLTask> urlQueue;
    private Set<String> visitedUrls;
    private int maxDepth;
    
    public WebCrawler(int queueCapacity, int maxDepth) {
        this.urlQueue = new LinkedBlockingQueue<>(queueCapacity);
        this.visitedUrls = ConcurrentHashMap.newKeySet();
        this.maxDepth = maxDepth;
    }
    
    public void crawl(String seedUrl) throws InterruptedException {
        urlQueue.put(new URLTask(seedUrl, 0));
        
        // Start crawler threads
        int numThreads = 5;
        Thread[] crawlers = new Thread[numThreads];
        
        for (int i = 0; i < numThreads; i++) {
            crawlers[i] = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        URLTask task = urlQueue.poll(1, TimeUnit.SECONDS);
                        if (task != null) {
                            processURL(task);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            crawlers[i].start();
        }
    }
    
    private void processURL(URLTask task) {
        if (task.getDepth() > maxDepth) return;
        if (!visitedUrls.add(task.getUrl())) return;
        
        System.out.println("Crawling: " + task.getUrl() + " (depth: " + task.getDepth() + ")");
        
        // Extract links and add to queue
        List<String> links = extractLinks(task.getUrl());
        for (String link : links) {
            try {
                urlQueue.offer(new URLTask(link, task.getDepth() + 1), 100, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    private List<String> extractLinks(String url) {
        // Simulate link extraction
        return Arrays.asList(url + "/page1", url + "/page2");
    }
}
```

---

### Example 2: Log Processing System

```java
class LogEntry {
    private String level;
    private String message;
    private long timestamp;
    
    public LogEntry(String level, String message) {
        this.level = level;
        this.message = message;
        this.timestamp = System.currentTimeMillis();
    }
    
    @Override
    public String toString() {
        return String.format("[%s] %d: %s", level, timestamp, message);
    }
}

class LogProcessor {
    private BlockingQueue<LogEntry> logQueue;
    private Thread processorThread;
    
    public LogProcessor(int capacity) {
        this.logQueue = new LinkedBlockingQueue<>(capacity);
        
        processorThread = new Thread(() -> {
            List<LogEntry> batch = new ArrayList<>();
            
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    // Drain up to 100 logs at a time
                    logQueue.drainTo(batch, 100);
                    
                    if (batch.isEmpty()) {
                        // Wait for at least one log
                        LogEntry entry = logQueue.poll(1, TimeUnit.SECONDS);
                        if (entry != null) batch.add(entry);
                    }
                    
                    if (!batch.isEmpty()) {
                        writeToDisk(batch);
                        batch.clear();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        processorThread.start();
    }
    
    public void log(String level, String message) {
        try {
            logQueue.offer(new LogEntry(level, message), 100, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            System.err.println("Failed to log: " + message);
        }
    }
    
    private void writeToDisk(List<LogEntry> batch) {
        System.out.println("Writing batch of " + batch.size() + " logs to disk");
        // Simulate disk write
        for (LogEntry entry : batch) {
            System.out.println("  " + entry);
        }
    }
    
    public void shutdown() {
        processorThread.interrupt();
    }
}

// Usage
LogProcessor logger = new LogProcessor(1000);
logger.log("INFO", "Application started");
logger.log("WARN", "Low memory");
logger.log("ERROR", "Database connection failed");
Thread.sleep(2000);
logger.shutdown();
```

---

### Example 3: Email Sender Service

```java
class Email {
    private String to;
    private String subject;
    private String body;
    
    public Email(String to, String subject, String body) {
        this.to = to;
        this.subject = subject;
        this.body = body;
    }
    
    public String getTo() { return to; }
    public String getSubject() { return subject; }
    public String getBody() { return body; }
}

class EmailSender {
    private BlockingQueue<Email> emailQueue;
    private Thread[] senderThreads;
    private volatile boolean running = true;
    
    public EmailSender(int capacity, int numThreads) {
        this.emailQueue = new LinkedBlockingQueue<>(capacity);
        this.senderThreads = new Thread[numThreads];
        
        // Start sender threads
        for (int i = 0; i < numThreads; i++) {
            senderThreads[i] = new Thread(() -> {
                while (running) {
                    try {
                        Email email = emailQueue.poll(1, TimeUnit.SECONDS);
                        if (email != null) {
                            sendEmail(email);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            senderThreads[i].start();
        }
    }
    
    public boolean queueEmail(Email email) {
        try {
            return emailQueue.offer(email, 5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    private void sendEmail(Email email) {
        System.out.println("Sending email to: " + email.getTo());
        System.out.println("Subject: " + email.getSubject());
        // Simulate sending
        try { Thread.sleep(100); } catch (InterruptedException e) {}
    }
    
    public void shutdown() throws InterruptedException {
        running = false;
        for (Thread thread : senderThreads) {
            thread.join();
        }
    }
    
    public int pendingEmails() {
        return emailQueue.size();
    }
}

// Usage
EmailSender sender = new EmailSender(100, 3);
sender.queueEmail(new Email("user@example.com", "Welcome", "Welcome to our service!"));
sender.queueEmail(new Email("admin@example.com", "Alert", "System maintenance scheduled"));
Thread.sleep(1000);
sender.shutdown();
```

---

### Example 4: Download Manager

```java
class DownloadTask {
    private String url;
    private String destination;
    
    public DownloadTask(String url, String destination) {
        this.url = url;
        this.destination = destination;
    }
    
    public String getUrl() { return url; }
    public String getDestination() { return destination; }
}

class DownloadManager {
    private BlockingQueue<DownloadTask> downloadQueue;
    private Thread[] downloaderThreads;
    
    public DownloadManager(int capacity, int numThreads) {
        this.downloadQueue = new LinkedBlockingQueue<>(capacity);
        this.downloaderThreads = new Thread[numThreads];
        
        for (int i = 0; i < numThreads; i++) {
            downloaderThreads[i] = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    try {
                        DownloadTask task = downloadQueue.take();
                        download(task);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            downloaderThreads[i].start();
        }
    }
    
    public void addDownload(String url, String destination) throws InterruptedException {
        downloadQueue.put(new DownloadTask(url, destination));
    }
    
    private void download(DownloadTask task) {
        System.out.println("Downloading: " + task.getUrl() + " to " + task.getDestination());
        // Simulate download
        try { Thread.sleep(500); } catch (InterruptedException e) {}
        System.out.println("Completed: " + task.getUrl());
    }
    
    public int pendingDownloads() {
        return downloadQueue.size();
    }
}

// Usage
DownloadManager manager = new DownloadManager(50, 5);
manager.addDownload("http://example.com/file1.zip", "/downloads/file1.zip");
manager.addDownload("http://example.com/file2.zip", "/downloads/file2.zip");
manager.addDownload("http://example.com/file3.zip", "/downloads/file3.zip");
```

---

## üÜö LinkedBlockingQueue vs ArrayBlockingQueue

| Feature | LinkedBlockingQueue | ArrayBlockingQueue |
|---------|--------------------|--------------------|
| **Structure** | Linked nodes | Circular array |
| **Capacity** | Optionally bounded | Always bounded |
| **Memory** | More (node overhead) | Less (contiguous) |
| **Locks** | Two (put & take) | One |
| **Throughput** | Higher (concurrent) | Lower |
| **Fairness** | No | Optional |
| **GC** | More (nodes) | Less |
| **Cache** | Worse locality | Better locality |
| **Best for** | High concurrency | Lower contention |

```java
// Benchmark comparison
BlockingQueue<Integer> linked = new LinkedBlockingQueue<>(10000);
BlockingQueue<Integer> array = new ArrayBlockingQueue<>(10000);

// LinkedBlockingQueue: Better for high concurrent put/take
// ArrayBlockingQueue: Better for lower contention, less memory
```

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Unbounded queue can cause OOM
BlockingQueue<Integer> unbounded = new LinkedBlockingQueue<>();
// for (int i = 0; i < Integer.MAX_VALUE; i++) unbounded.put(i);  // OOM!

// 2. Not handling InterruptedException
try {
    queue.put(item);
} catch (InterruptedException e) {
    // ‚ùå Don't ignore
    Thread.currentThread().interrupt();  // ‚úÖ Restore status
}

// 3. Using remove() or contains() frequently
// queue.remove(item);  // O(n) and locks both locks!

// 4. Forgetting to check poll() result
Integer item = queue.poll(1, TimeUnit.SECONDS);
// if (item == null) { ... }  // ‚úÖ Check for timeout

// 5. Creating unbounded queue accidentally
BlockingQueue<String> oops = new LinkedBlockingQueue<>();  // Unbounded!
BlockingQueue<String> bounded = new LinkedBlockingQueue<>(100);  // ‚úÖ Bounded
```

---

## üí° Best Practices

1. **Always specify capacity** unless you truly need unbounded
2. **Use put/take** for blocking behavior
3. **Handle InterruptedException** - restore interrupt status
4. **Use drainTo()** for batch processing (efficient)
5. **Avoid remove/contains** on large queues (O(n))
6. **Monitor queue size** - prevent unbounded growth
7. **Use separate locks advantage** - high concurrent throughput
8. **Prefer over ArrayBlockingQueue** for high concurrency
9. **Set reasonable timeouts** for offer/poll operations

---

## üéØ When to Use LinkedBlockingQueue

**Use LinkedBlockingQueue when:**
- ‚úÖ Producer-consumer with high concurrency
- ‚úÖ Variable capacity needs (optionally bounded)
- ‚úÖ Higher throughput required
- ‚úÖ Multiple producers and consumers
- ‚úÖ Thread pool work queues
- ‚úÖ Message queues
- ‚úÖ Event processing systems

**Don't use LinkedBlockingQueue when:**
- ‚ùå Need fairness ‚Üí Use `ArrayBlockingQueue(capacity, true)`
- ‚ùå Memory constrained ‚Üí Use `ArrayBlockingQueue`
- ‚ùå Low contention ‚Üí Use `ArrayBlockingQueue`
- ‚ùå Need priority ‚Üí Use `PriorityBlockingQueue`
- ‚ùå Single producer/consumer ‚Üí Use `ArrayBlockingQueue`

---

## üéì Interview Questions

**Q: What is LinkedBlockingQueue?**
A: Optionally-bounded blocking queue based on linked nodes with separate locks for put/take.

**Q: Bounded or unbounded?**
A: Optionally bounded. Default is unbounded (Integer.MAX_VALUE).

**Q: LinkedBlockingQueue vs ArrayBlockingQueue?**
A: LinkedBlockingQueue has separate locks (higher throughput), ArrayBlockingQueue uses single lock.

**Q: Why separate locks?**
A: Allows concurrent put and take operations for better throughput.

**Q: Time complexity of operations?**
A: O(1) for put/take/poll/offer, O(n) for remove/contains.

**Q: Is it fair?**
A: No, doesn't guarantee fairness.

**Q: Can it be unbounded?**
A: Yes, if no capacity specified (Integer.MAX_VALUE).

---

## üìö Summary

- **LinkedBlockingQueue**: Optionally-bounded blocking queue with linked nodes
- **Separate locks** for put and take - **higher throughput**
- **FIFO ordering** - First-In-First-Out
- **Thread-safe** with better concurrency than ArrayBlockingQueue
- **Optionally bounded** - can be bounded or unbounded
- **O(1) operations** for put/take at ends
- Perfect for **high-concurrency producer-consumer** scenarios
- **More memory** than ArrayBlockingQueue (node overhead)
- **Better throughput** than ArrayBlockingQueue (concurrent put/take)
- Ideal for **thread pools, task queues, message processing**
