# üéØ Deque Interface

## üìñ Overview

`Deque` (Double-Ended Queue) is a linear collection that supports **insertion and removal at both ends**. It can be used as both **Queue (FIFO)** and **Stack (LIFO)**.

```java
public interface Deque<E> extends Queue<E>
```

**Pronunciation:** "deck" (like a deck of cards)

---

## üîë Key Characteristics

1. **Double-Ended** - Add/remove from both front and back
2. **Queue + Stack** - Can function as either
3. **No Capacity Restrictions** - Typically unbounded
4. **Allows Duplicates** - Can contain duplicate elements
5. **Null Handling** - Some implementations allow null, some don't
6. **Not Thread-Safe** - Most implementations (use BlockingDeque if needed)

---

## üìä Deque Hierarchy

```
Deque (Interface)
‚îú‚îÄ‚îÄ ArrayDeque (Class) - Resizable array, fast
‚îú‚îÄ‚îÄ LinkedList (Class) - Doubly-linked list
‚îî‚îÄ‚îÄ BlockingDeque (Interface) - Thread-safe
    ‚îî‚îÄ‚îÄ LinkedBlockingDeque (Class)
```

---

## üíª Deque Operations

### Three Operation Styles

| Operation | First Element | Last Element |
|-----------|--------------|--------------|
| **Insert** | `addFirst(e)` / `offerFirst(e)` | `addLast(e)` / `offerLast(e)` |
| **Remove** | `removeFirst()` / `pollFirst()` | `removeLast()` / `pollLast()` |
| **Examine** | `getFirst()` / `peekFirst()` | `getLast()` / `peekLast()` |

**Exception-throwing vs Null-returning:**

| Operation Type | Exception | Returns null |
|---------------|-----------|--------------|
| Insert | `addFirst/Last(e)` | `offerFirst/Last(e)` |
| Remove | `removeFirst/Last()` | `pollFirst/Last()` |
| Examine | `getFirst/Last()` | `peekFirst/Last()` |

---

## üîß Common Methods

```java
Deque<String> deque = new ArrayDeque<>();

// Insert at front
void addFirst(E e)         // Throws exception if full
boolean offerFirst(E e)    // Returns false if full

// Insert at back
void addLast(E e)          // Throws exception if full
boolean offerLast(E e)     // Returns false if full

// Remove from front
E removeFirst()            // Throws exception if empty
E pollFirst()              // Returns null if empty

// Remove from back
E removeLast()             // Throws exception if empty
E pollLast()               // Returns null if empty

// Examine front
E getFirst()               // Throws exception if empty
E peekFirst()              // Returns null if empty

// Examine back
E getLast()                // Throws exception if empty
E peekLast()               // Returns null if empty

// Stack operations
void push(E e)             // Same as addFirst(e)
E pop()                    // Same as removeFirst()
E peek()                   // Same as peekFirst()

// Queue operations (inherited)
boolean offer(E e)         // Same as offerLast(e)
E poll()                   // Same as pollFirst()
E peek()                   // Same as peekFirst()
```

---

## üé® Basic Operations

```java
import java.util.*;

public class DequeDemo {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        
        // Add at both ends
        deque.addFirst("Front1");
        deque.addLast("Back1");
        deque.addFirst("Front2");
        deque.addLast("Back2");
        
        System.out.println(deque);  // [Front2, Front1, Back1, Back2]
        
        // Examine both ends
        System.out.println("First: " + deque.peekFirst());  // Front2
        System.out.println("Last: " + deque.peekLast());    // Back2
        
        // Remove from both ends
        System.out.println("Removed first: " + deque.pollFirst());  // Front2
        System.out.println("Removed last: " + deque.pollLast());    // Back2
        
        System.out.println(deque);  // [Front1, Back1]
    }
}
```

---

## üîÑ Deque as Queue (FIFO)

```java
// Using Deque as Queue
Deque<Integer> queue = new ArrayDeque<>();

// Add to back (enqueue)
queue.offerLast(1);
queue.offerLast(2);
queue.offerLast(3);

// Or use Queue methods
queue.offer(4);  // Same as offerLast()

System.out.println(queue);  // [1, 2, 3, 4]

// Remove from front (dequeue)
System.out.println(queue.pollFirst());  // 1
System.out.println(queue.poll());       // 2 (same as pollFirst)

System.out.println(queue);  // [3, 4]
```

---

## üìö Deque as Stack (LIFO)

```java
// Using Deque as Stack
Deque<String> stack = new ArrayDeque<>();

// Push (add to front)
stack.push("First");
stack.push("Second");
stack.push("Third");

System.out.println(stack);  // [Third, Second, First]

// Peek (examine top without removing)
System.out.println("Top: " + stack.peek());  // Third

// Pop (remove from front)
System.out.println("Popped: " + stack.pop());  // Third
System.out.println("Popped: " + stack.pop());  // Second

System.out.println(stack);  // [First]
```

**Note:** Prefer `Deque` over `Stack` class (Stack is legacy).

---

## üéØ Comparison with Queue Methods

| Deque Method | Equivalent Queue Method |
|-------------|------------------------|
| `offerLast(e)` | `offer(e)` |
| `pollFirst()` | `poll()` |
| `peekFirst()` | `peek()` |
| `addLast(e)` | `add(e)` |
| `removeFirst()` | `remove()` |
| `getFirst()` | `element()` |

---

## üéØ Comparison with Stack Methods

| Deque Method | Equivalent Stack Method |
|-------------|------------------------|
| `push(e)` = `addFirst(e)` | `push(e)` |
| `pop()` = `removeFirst()` | `pop()` |
| `peek()` = `peekFirst()` | `peek()` |

---

## üéì Real-World Examples

### Example 1: Browser History (Back/Forward)

```java
class BrowserHistory {
    private Deque<String> backStack = new ArrayDeque<>();
    private Deque<String> forwardStack = new ArrayDeque<>();
    private String currentPage;
    
    public BrowserHistory(String homepage) {
        currentPage = homepage;
    }
    
    public void visit(String url) {
        if (currentPage != null) {
            backStack.push(currentPage);
        }
        currentPage = url;
        forwardStack.clear();  // Clear forward history
        System.out.println("Visited: " + url);
    }
    
    public String back() {
        if (backStack.isEmpty()) {
            return currentPage;
        }
        forwardStack.push(currentPage);
        currentPage = backStack.pop();
        System.out.println("Back to: " + currentPage);
        return currentPage;
    }
    
    public String forward() {
        if (forwardStack.isEmpty()) {
            return currentPage;
        }
        backStack.push(currentPage);
        currentPage = forwardStack.pop();
        System.out.println("Forward to: " + currentPage);
        return currentPage;
    }
}

// Usage
BrowserHistory browser = new BrowserHistory("google.com");
browser.visit("youtube.com");
browser.visit("facebook.com");
browser.back();      // Back to youtube.com
browser.back();      // Back to google.com
browser.forward();   // Forward to youtube.com
```

---

### Example 2: Undo/Redo Operations

```java
class TextEditor {
    private Deque<String> undoStack = new ArrayDeque<>();
    private Deque<String> redoStack = new ArrayDeque<>();
    private String currentText = "";
    
    public void write(String text) {
        undoStack.push(currentText);
        currentText = currentText + text;
        redoStack.clear();
        System.out.println("Current: " + currentText);
    }
    
    public void undo() {
        if (!undoStack.isEmpty()) {
            redoStack.push(currentText);
            currentText = undoStack.pop();
            System.out.println("After undo: " + currentText);
        }
    }
    
    public void redo() {
        if (!redoStack.isEmpty()) {
            undoStack.push(currentText);
            currentText = redoStack.pop();
            System.out.println("After redo: " + currentText);
        }
    }
}

// Usage
TextEditor editor = new TextEditor();
editor.write("Hello");
editor.write(" World");
editor.undo();   // Back to "Hello"
editor.redo();   // Forward to "Hello World"
```

---

### Example 3: Sliding Window Maximum

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();  // Stores indices
    int[] result = new int[nums.length - k + 1];
    int ri = 0;
    
    for (int i = 0; i < nums.length; i++) {
        // Remove indices outside window
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }
        
        // Remove smaller elements from back
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }
        
        deque.offerLast(i);
        
        // Add to result when window is full
        if (i >= k - 1) {
            result[ri++] = nums[deque.peekFirst()];
        }
    }
    
    return result;
}
```

---

### Example 4: Palindrome Check

```java
public boolean isPalindrome(String str) {
    Deque<Character> deque = new ArrayDeque<>();
    
    // Add all characters
    for (char c : str.toLowerCase().toCharArray()) {
        if (Character.isLetterOrDigit(c)) {
            deque.offerLast(c);
        }
    }
    
    // Compare from both ends
    while (deque.size() > 1) {
        if (!deque.pollFirst().equals(deque.pollLast())) {
            return false;
        }
    }
    
    return true;
}

// Test
isPalindrome("A man a plan a canal Panama");  // true
```

---

### Example 5: Task Scheduling (Priority with Preemption)

```java
class TaskScheduler {
    private Deque<Task> highPriorityQueue = new ArrayDeque<>();
    private Deque<Task> normalQueue = new ArrayDeque<>();
    
    public void addTask(Task task) {
        if (task.isHighPriority()) {
            highPriorityQueue.offerLast(task);
        } else {
            normalQueue.offerLast(task);
        }
    }
    
    public void addUrgentTask(Task task) {
        highPriorityQueue.offerFirst(task);  // Add at front
    }
    
    public Task getNextTask() {
        if (!highPriorityQueue.isEmpty()) {
            return highPriorityQueue.pollFirst();
        }
        return normalQueue.pollFirst();
    }
}
```

---

## üÜö Deque Implementations Comparison

| Feature | ArrayDeque | LinkedList |
|---------|-----------|------------|
| **Structure** | Resizable array | Doubly-linked list |
| **Performance (add/remove ends)** | O(1) amortized | O(1) |
| **Performance (add/remove middle)** | O(n) | O(1) if node known |
| **Memory** | Less overhead | More (node objects) |
| **Null allowed** | No | Yes |
| **Better for** | General use | Frequent middle operations |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. ArrayDeque doesn't allow null
Deque<String> deque = new ArrayDeque<>();
// deque.addFirst(null);  // NullPointerException

// 2. Confusing push/pop with offer/poll
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);  // Adds at front
stack.offerLast(2);  // Adds at back
System.out.println(stack);  // [1, 2]

// 3. Using wrong end methods
Deque<String> queue = new ArrayDeque<>();
queue.offerLast("A");  // Queue: add at back
queue.offerLast("B");
System.out.println(queue.pollFirst());  // Queue: remove from front

// 4. Mixing Queue and Stack operations
Deque<Integer> mixed = new ArrayDeque<>();
mixed.offer(1);    // Adds at back (Queue style)
mixed.push(2);     // Adds at front (Stack style)
System.out.println(mixed);  // [2, 1] - confusing!
```

---

## üí° Best Practices

1. **Prefer ArrayDeque** over LinkedList (better performance, less memory)
2. **Use as Stack** instead of Stack class
3. **Consistent operations**: Either Queue style OR Stack style, not both
4. **Use offer/poll/peek** for null-returning methods
5. **Don't use null** with ArrayDeque
6. **Choose right implementation**:
   - ArrayDeque: General use (faster, less memory)
   - LinkedList: Need null or middle insertions

---

## üéØ When to Use Deque

**Use Deque when:**
- ‚úÖ Need both ends access
- ‚úÖ Implementing Stack (better than Stack class)
- ‚úÖ Implementing Queue (better than LinkedList alone)
- ‚úÖ Sliding window problems
- ‚úÖ Browser history / Undo-redo
- ‚úÖ Palindrome checking

**Don't use Deque when:**
- ‚ùå Only need one end access ‚Üí Use Queue
- ‚ùå Need indexed access ‚Üí Use List
- ‚ùå Need priority ordering ‚Üí Use PriorityQueue
- ‚ùå Need thread-safety ‚Üí Use BlockingDeque

---

## üéì Interview Questions

**Q: What is Deque?**
A: Double-ended queue that supports insertion/removal from both ends.

**Q: Difference between Deque and Queue?**
A: Queue is single-ended (FIFO), Deque is double-ended (both ends).

**Q: Can Deque be used as Stack?**
A: Yes, using push(), pop(), peek() methods. Preferred over Stack class.

**Q: ArrayDeque vs LinkedList?**
A: ArrayDeque is faster and uses less memory. LinkedList allows null.

**Q: Time complexity of Deque operations?**
A: O(1) for add/remove from both ends.

**Q: Why prefer Deque over Stack?**
A: Stack is legacy (synchronized), Deque is modern and faster.

---

## üìö Summary

- **Deque**: Double-ended queue with operations at both ends
- Can function as **Queue (FIFO)** or **Stack (LIFO)**
- **ArrayDeque**: Preferred implementation (fast, efficient)
- **LinkedList**: Alternative (allows null, slower)
- **O(1)** operations at both ends
- **Preferred over Stack class** for stack operations
- **Not thread-safe** - use BlockingDeque if needed
- Perfect for **sliding window**, **undo/redo**, **palindrome** problems
