# üéØ ArrayDeque

## üìñ Overview

`ArrayDeque` is a **resizable-array** implementation of the `Deque` interface. It's **faster than LinkedList** and is the **preferred implementation** for both Queue and Stack.

```java
public class ArrayDeque<E> extends AbstractCollection<E>
    implements Deque<E>, Cloneable, Serializable
```

---

## üîë Key Characteristics

1. **Resizable Array** - Dynamically grows as needed
2. **No Capacity Restrictions** - Unbounded (grows automatically)
3. **Faster than LinkedList** - Better cache locality, less memory
4. **No Null Elements** - Does not allow null
5. **Not Thread-Safe** - Use external synchronization if needed
6. **FIFO and LIFO** - Can function as Queue or Stack
7. **O(1) Operations** - Amortized constant time for most operations

---

## üíª Creating ArrayDeque

```java
import java.util.*;

// 1. Default constructor - initial capacity 16
Deque<String> deque1 = new ArrayDeque<>();

// 2. With initial capacity
Deque<Integer> deque2 = new ArrayDeque<>(20);

// 3. From collection
List<String> list = Arrays.asList("A", "B", "C");
Deque<String> deque3 = new ArrayDeque<>(list);

// 4. As Queue
Queue<Integer> queue = new ArrayDeque<>();

// 5. As Stack (preferred over Stack class)
Deque<String> stack = new ArrayDeque<>();
```

---

## üé® Basic Operations

```java
public class ArrayDequeDemo {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        
        // Add at both ends
        deque.offerFirst("Front");
        deque.offerLast("Back");
        deque.addFirst("NewFront");
        deque.addLast("NewBack");
        
        System.out.println(deque);  // [NewFront, Front, Back, NewBack]
        
        // Examine both ends
        System.out.println("First: " + deque.peekFirst());  // NewFront
        System.out.println("Last: " + deque.peekLast());    // NewBack
        
        // Remove from both ends
        System.out.println("Removed first: " + deque.pollFirst());  // NewFront
        System.out.println("Removed last: " + deque.pollLast());    // NewBack
        
        System.out.println("Size: " + deque.size());  // 2
        System.out.println("Is empty? " + deque.isEmpty());  // false
        
        // Cannot add null
        // deque.offer(null);  // NullPointerException
    }
}
```

---

## üèóÔ∏è Internal Structure

```java
// Circular array implementation
public class ArrayDeque<E> {
    transient Object[] elements;  // Array to store elements
    transient int head;           // Index of first element
    transient int tail;           // Index of next available slot
    
    // Default initial capacity
    private static final int MIN_INITIAL_CAPACITY = 8;
}
```

**Circular Array Visualization:**
```
Initial: capacity = 8
[_, _, _, _, _, _, _, _]
 ^head/tail

After offerLast("A", "B", "C"):
[A, B, C, _, _, _, _, _]
 ^head        ^tail

After offerFirst("X"):
[A, B, C, _, _, _, _, X]
 ^head        ^tail   ^head (wrapped)

When full, array doubles in size
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `offerFirst(e)` / `offerLast(e)` | O(1) | Amortized |
| `pollFirst()` / `pollLast()` | O(1) | |
| `peekFirst()` / `peekLast()` | O(1) | |
| `size()` | O(1) | |
| `contains(o)` | O(n) | Linear search |
| `remove(o)` | O(n) | Linear search + shift |
| Iteration | O(n) | |

**Space:** O(n) where n is number of elements

---

## üîÑ ArrayDeque as Queue (FIFO)

```java
Queue<Integer> queue = new ArrayDeque<>();

// Enqueue (add to back)
queue.offer(1);
queue.offer(2);
queue.offer(3);

System.out.println(queue);  // [1, 2, 3]

// Peek (examine front)
System.out.println("Front: " + queue.peek());  // 1

// Dequeue (remove from front)
System.out.println("Removed: " + queue.poll());  // 1
System.out.println("Removed: " + queue.poll());  // 2

System.out.println(queue);  // [3]
```

---

## üìö ArrayDeque as Stack (LIFO)

```java
Deque<String> stack = new ArrayDeque<>();

// Push (add to front)
stack.push("First");
stack.push("Second");
stack.push("Third");

System.out.println(stack);  // [Third, Second, First]

// Peek (examine top)
System.out.println("Top: " + stack.peek());  // Third

// Pop (remove from front)
System.out.println("Popped: " + stack.pop());  // Third
System.out.println("Popped: " + stack.pop());  // Second

System.out.println(stack);  // [First]
System.out.println("Is empty? " + stack.isEmpty());  // false
```

**Note:** ArrayDeque is **preferred over Stack class** (Stack is legacy).

---

## üéØ Real-World Examples

### Example 1: Balanced Parentheses

```java
public boolean isValid(String s) {
    Deque<Character> stack = new ArrayDeque<>();
    Map<Character, Character> pairs = Map.of(')', '(', '}', '{', ']', '[');
    
    for (char c : s.toCharArray()) {
        if (pairs.containsValue(c)) {
            stack.push(c);  // Opening bracket
        } else if (pairs.containsKey(c)) {
            if (stack.isEmpty() || stack.pop() != pairs.get(c)) {
                return false;
            }
        }
    }
    
    return stack.isEmpty();
}

// Test
isValid("()[]{}");     // true
isValid("([)]");       // false
isValid("{[()]}");     // true
```

---

### Example 2: Reverse First K Elements

```java
public void reverseFirstK(Queue<Integer> queue, int k) {
    Deque<Integer> stack = new ArrayDeque<>();
    
    // Push first k elements to stack
    for (int i = 0; i < k; i++) {
        stack.push(queue.poll());
    }
    
    // Pop from stack and add to queue
    while (!stack.isEmpty()) {
        queue.offer(stack.pop());
    }
    
    // Move remaining elements to back
    int remaining = queue.size() - k;
    for (int i = 0; i < remaining; i++) {
        queue.offer(queue.poll());
    }
}

// Test
Queue<Integer> q = new ArrayDeque<>(Arrays.asList(1, 2, 3, 4, 5));
reverseFirstK(q, 3);
System.out.println(q);  // [3, 2, 1, 4, 5]
```

---

### Example 3: Recent Counter

```java
class RecentCounter {
    private Deque<Integer> requests;
    
    public RecentCounter() {
        requests = new ArrayDeque<>();
    }
    
    public int ping(int t) {
        requests.offerLast(t);
        
        // Remove requests older than 3000ms
        while (!requests.isEmpty() && requests.peekFirst() < t - 3000) {
            requests.pollFirst();
        }
        
        return requests.size();
    }
}

// Usage
RecentCounter counter = new RecentCounter();
counter.ping(1);      // returns 1
counter.ping(100);    // returns 2
counter.ping(3001);   // returns 3
counter.ping(3002);   // returns 3 (request at 1ms is removed)
```

---

### Example 4: Generate Binary Numbers

```java
public List<String> generateBinaryNumbers(int n) {
    List<String> result = new ArrayList<>();
    Queue<String> queue = new ArrayDeque<>();
    
    queue.offer("1");
    
    for (int i = 0; i < n; i++) {
        String current = queue.poll();
        result.add(current);
        
        queue.offer(current + "0");
        queue.offer(current + "1");
    }
    
    return result;
}

// Test
generateBinaryNumbers(5);  // [1, 10, 11, 100, 101]
```

---

### Example 5: Implement Queue using Stacks

```java
class QueueUsingStacks {
    private Deque<Integer> input;
    private Deque<Integer> output;
    
    public QueueUsingStacks() {
        input = new ArrayDeque<>();
        output = new ArrayDeque<>();
    }
    
    public void enqueue(int x) {
        input.push(x);
    }
    
    public int dequeue() {
        if (output.isEmpty()) {
            while (!input.isEmpty()) {
                output.push(input.pop());
            }
        }
        return output.pop();
    }
    
    public int peek() {
        if (output.isEmpty()) {
            while (!input.isEmpty()) {
                output.push(input.pop());
            }
        }
        return output.peek();
    }
    
    public boolean isEmpty() {
        return input.isEmpty() && output.isEmpty();
    }
}
```

---

## üÜö ArrayDeque vs LinkedList

| Feature | ArrayDeque | LinkedList |
|---------|-----------|------------|
| **Structure** | Circular array | Doubly-linked list |
| **Memory** | Less (no node overhead) | More (node objects) |
| **Performance (ends)** | O(1) amortized | O(1) |
| **Performance (middle)** | O(n) | O(1) if node known |
| **Cache locality** | Better | Worse |
| **Null allowed** | No | Yes |
| **Initial capacity** | 16 | N/A |
| **Resizing** | Doubles when full | N/A |
| **Best for** | General use (Queue/Stack) | Need null or middle ops |

```java
// Performance comparison
long start = System.nanoTime();
Deque<Integer> arrayDeque = new ArrayDeque<>();
for (int i = 0; i < 100_000; i++) {
    arrayDeque.offerLast(i);
}
long arrayTime = System.nanoTime() - start;

start = System.nanoTime();
Deque<Integer> linkedList = new LinkedList<>();
for (int i = 0; i < 100_000; i++) {
    linkedList.offerLast(i);
}
long linkedTime = System.nanoTime() - start;

System.out.println("ArrayDeque: " + arrayTime + " ns");
System.out.println("LinkedList: " + linkedTime + " ns");
// ArrayDeque is typically 2-3x faster
```

---

## üÜö ArrayDeque vs Stack

| Feature | ArrayDeque | Stack (Legacy) |
|---------|-----------|----------------|
| **Thread-safe** | No | Yes (synchronized) |
| **Performance** | Faster | Slower (locks) |
| **Extends** | AbstractCollection | Vector |
| **Modern** | Yes | No (legacy) |
| **Recommended** | ‚úÖ Yes | ‚ùå No |

```java
// ‚ùå Don't use Stack (legacy)
Stack<Integer> stack = new Stack<>();

// ‚úÖ Use ArrayDeque instead
Deque<Integer> stack = new ArrayDeque<>();
```

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Null elements not allowed
Deque<String> deque = new ArrayDeque<>();
// deque.offer(null);  // NullPointerException

// 2. Mixing Queue and Stack operations
Deque<Integer> mixed = new ArrayDeque<>();
mixed.offer(1);    // Adds at back (Queue)
mixed.push(2);     // Adds at front (Stack)
System.out.println(mixed);  // [2, 1] - confusing order!

// 3. Using as Stack but polling from wrong end
Deque<String> stack = new ArrayDeque<>();
stack.push("A");
stack.push("B");
// String wrong = stack.pollLast();  // Wrong end!
String correct = stack.pop();  // Correct (same as pollFirst)

// 4. Expecting thread-safety
Deque<Integer> deque = new ArrayDeque<>();
// Not thread-safe for concurrent access!

// 5. Contains/remove are O(n)
Deque<Integer> large = new ArrayDeque<>();
for (int i = 0; i < 100000; i++) large.offer(i);
// large.contains(50000);  // O(n) - slow!
```

---

## üí° Best Practices

1. **Use ArrayDeque** as default Queue/Stack implementation
2. **Don't use null** - not allowed
3. **Consistent operations**: Either Queue style OR Stack style
4. **Initialize with capacity** if size known: `new ArrayDeque<>(expectedSize)`
5. **Avoid contains/remove** on large deques (O(n))
6. **Use for Stack** instead of Stack class
7. **Synchronize externally** for thread-safety
8. **Prefer over LinkedList** (faster, less memory)

---

## üéØ When to Use ArrayDeque

**Use ArrayDeque when:**
- ‚úÖ Need Queue (FIFO operations)
- ‚úÖ Need Stack (LIFO operations)
- ‚úÖ Need Deque (both ends operations)
- ‚úÖ Performance matters (faster than LinkedList)
- ‚úÖ Memory efficiency important
- ‚úÖ Single-threaded environment
- ‚úÖ Don't need null elements

**Don't use ArrayDeque when:**
- ‚ùå Need null elements ‚Üí Use `LinkedList`
- ‚ùå Need thread-safety ‚Üí Use `LinkedBlockingDeque`
- ‚ùå Need indexed access ‚Üí Use `ArrayList`
- ‚ùå Need priority ordering ‚Üí Use `PriorityQueue`
- ‚ùå Frequent middle insertions ‚Üí Use `LinkedList`

---

## üéì Interview Questions

**Q: What is ArrayDeque?**
A: Resizable-array implementation of Deque interface for both Queue and Stack operations.

**Q: ArrayDeque vs LinkedList?**
A: ArrayDeque is faster and uses less memory. LinkedList allows null.

**Q: Can ArrayDeque contain null?**
A: No, throws NullPointerException.

**Q: Time complexity of ArrayDeque operations?**
A: O(1) amortized for add/remove from ends.

**Q: Why prefer ArrayDeque over Stack?**
A: Stack is legacy (synchronized), ArrayDeque is faster and modern.

**Q: How does ArrayDeque grow?**
A: Doubles capacity when full (like ArrayList).

**Q: Is ArrayDeque thread-safe?**
A: No, use Collections.synchronizedDeque() or LinkedBlockingDeque.

---

## üìö Summary

- **ArrayDeque**: Resizable array implementation of Deque
- **Faster than LinkedList** - better cache locality
- **Less memory** than LinkedList - no node overhead
- **O(1) amortized** for operations at both ends
- **No null** elements allowed
- **Not thread-safe** - use synchronization or BlockingDeque
- **Preferred over Stack class** for stack operations
- **Default choice** for Queue and Stack needs
- **Circular array** structure with dynamic resizing
- Perfect for **Queue, Stack, and Deque** use cases
