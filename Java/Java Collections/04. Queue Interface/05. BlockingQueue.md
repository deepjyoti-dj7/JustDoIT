# üîí BlockingQueue

## üìñ Overview

`BlockingQueue` is a **thread-safe** queue that supports operations that **wait for the queue to become non-empty** when retrieving and **wait for space to become available** when storing.

```java
public interface BlockingQueue<E> extends Queue<E>
```

**Core Feature:** **Blocking operations** for producer-consumer patterns.

---

## üîë Key Characteristics

1. **Thread-Safe** - Safe for concurrent access
2. **Blocking Operations** - Threads wait when queue is empty/full
3. **Bounded or Unbounded** - Can have capacity restrictions
4. **FIFO Ordering** - Most implementations maintain insertion order
5. **Null Not Allowed** - Cannot insert null elements
6. **Producer-Consumer** - Ideal for handoff scenarios
7. **Four Operation Types** - Throws exception, returns special value, blocks, times out

---

## üé® Four Types of Operations

| Type | Insert | Remove | Examine |
|------|--------|--------|---------|
| **Throws exception** | `add(e)` | `remove()` | `element()` |
| **Returns special value** | `offer(e)` | `poll()` | `peek()` |
| **Blocks** | `put(e)` | `take()` | N/A |
| **Times out** | `offer(e, time, unit)` | `poll(time, unit)` | N/A |

**Key Methods:**
- `put(E e)` - Waits if full
- `take()` - Waits if empty
- `offer(E e, long timeout, TimeUnit unit)` - Waits with timeout
- `poll(long timeout, TimeUnit unit)` - Waits with timeout
- `remainingCapacity()` - Available space
- `drainTo(Collection<? super E> c)` - Remove all to collection

---

## üèóÔ∏è BlockingQueue Hierarchy

```
BlockingQueue (Interface)
    ‚îú‚îÄ‚îÄ ArrayBlockingQueue       (Bounded, array-based)
    ‚îú‚îÄ‚îÄ LinkedBlockingQueue      (Optionally bounded, linked nodes)
    ‚îú‚îÄ‚îÄ PriorityBlockingQueue    (Unbounded, priority heap)
    ‚îú‚îÄ‚îÄ SynchronousQueue         (No capacity, direct handoff)
    ‚îî‚îÄ‚îÄ DelayQueue              (Unbounded, delayed elements)
```

---

## üíª Basic Operations

```java
import java.util.concurrent.*;

public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);
        
        // Non-blocking operations
        System.out.println(queue.offer(1));   // true
        System.out.println(queue.offer(2));   // true
        System.out.println(queue.offer(3));   // true
        System.out.println(queue.offer(4));   // false (full)
        
        System.out.println("Size: " + queue.size());  // 3
        
        // Blocking operations
        queue.put(5);  // Would block here if full
        
        Integer item = queue.take();  // Removes 1
        System.out.println("Taken: " + item);  // 1
        
        // Timed operations
        boolean offered = queue.offer(6, 1, TimeUnit.SECONDS);
        System.out.println("Offered with timeout: " + offered);  // true
        
        Integer polled = queue.poll(1, TimeUnit.SECONDS);
        System.out.println("Polled: " + polled);  // 2
        
        System.out.println("Remaining capacity: " + queue.remainingCapacity());
    }
}
```

---

## üéØ Producer-Consumer Pattern

```java
import java.util.concurrent.*;

// Producer thread
class Producer implements Runnable {
    private BlockingQueue<Integer> queue;
    
    public Producer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 10; i++) {
                System.out.println("Producing: " + i);
                queue.put(i);  // Blocks if queue is full
                Thread.sleep(100);
            }
            queue.put(-1);  // Poison pill to stop consumer
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// Consumer thread
class Consumer implements Runnable {
    private BlockingQueue<Integer> queue;
    
    public Consumer(BlockingQueue<Integer> queue) {
        this.queue = queue;
    }
    
    @Override
    public void run() {
        try {
            while (true) {
                Integer item = queue.take();  // Blocks if queue is empty
                if (item == -1) break;  // Poison pill
                System.out.println("Consuming: " + item);
                Thread.sleep(200);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// Usage
public class ProducerConsumerDemo {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);
        
        Thread producer = new Thread(new Producer(queue));
        Thread consumer = new Thread(new Consumer(queue));
        
        producer.start();
        consumer.start();
    }
}
```

**Output:**
```
Producing: 1
Consuming: 1
Producing: 2
Producing: 3
Consuming: 2
Producing: 4
...
```

---

## üéØ Real-World Examples

### Example 1: Thread Pool Task Queue

```java
class SimpleThreadPool {
    private BlockingQueue<Runnable> taskQueue;
    private Thread[] workers;
    private volatile boolean shutdown = false;
    
    public SimpleThreadPool(int poolSize, int queueCapacity) {
        taskQueue = new LinkedBlockingQueue<>(queueCapacity);
        workers = new Thread[poolSize];
        
        for (int i = 0; i < poolSize; i++) {
            workers[i] = new Thread(() -> {
                while (!shutdown) {
                    try {
                        Runnable task = taskQueue.poll(1, TimeUnit.SECONDS);
                        if (task != null) {
                            task.run();
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
            workers[i].start();
        }
    }
    
    public void submit(Runnable task) throws InterruptedException {
        if (!shutdown) {
            taskQueue.put(task);
        }
    }
    
    public void shutdown() {
        shutdown = true;
    }
}

// Usage
SimpleThreadPool pool = new SimpleThreadPool(3, 10);
for (int i = 0; i < 5; i++) {
    final int taskId = i;
    pool.submit(() -> {
        System.out.println("Executing task " + taskId);
    });
}
pool.shutdown();
```

---

### Example 2: Message Processing System

```java
class Message {
    private String id;
    private String content;
    
    public Message(String id, String content) {
        this.id = id;
        this.content = content;
    }
    
    public String getId() { return id; }
    public String getContent() { return content; }
}

class MessageProcessor {
    private BlockingQueue<Message> messageQueue;
    private Thread processorThread;
    
    public MessageProcessor(int capacity) {
        messageQueue = new LinkedBlockingQueue<>(capacity);
        
        processorThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    Message msg = messageQueue.take();
                    processMessage(msg);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        processorThread.start();
    }
    
    public void submit(Message message) throws InterruptedException {
        messageQueue.put(message);
    }
    
    private void processMessage(Message msg) {
        System.out.println("Processing: " + msg.getId() + " - " + msg.getContent());
        // Simulate processing
        try { Thread.sleep(100); } catch (InterruptedException e) {}
    }
    
    public void shutdown() {
        processorThread.interrupt();
    }
}

// Usage
MessageProcessor processor = new MessageProcessor(10);
processor.submit(new Message("1", "Order placed"));
processor.submit(new Message("2", "Payment received"));
processor.submit(new Message("3", "Shipment dispatched"));
```

---

### Example 3: Rate Limiter

```java
class RateLimiter {
    private BlockingQueue<Long> timestamps;
    private int maxRequests;
    private long timeWindowMillis;
    
    public RateLimiter(int maxRequests, long timeWindowMillis) {
        this.maxRequests = maxRequests;
        this.timeWindowMillis = timeWindowMillis;
        this.timestamps = new LinkedBlockingQueue<>(maxRequests);
    }
    
    public boolean tryAcquire() {
        long now = System.currentTimeMillis();
        
        // Remove expired timestamps
        while (!timestamps.isEmpty() && 
               now - timestamps.peek() > timeWindowMillis) {
            timestamps.poll();
        }
        
        // Check if we can add new request
        if (timestamps.size() < maxRequests) {
            timestamps.offer(now);
            return true;
        }
        
        return false;
    }
}

// Usage: Allow 5 requests per second
RateLimiter limiter = new RateLimiter(5, 1000);
for (int i = 0; i < 10; i++) {
    if (limiter.tryAcquire()) {
        System.out.println("Request " + i + " allowed");
    } else {
        System.out.println("Request " + i + " rate limited");
    }
}
```

---

### Example 4: Batch Processing

```java
class BatchProcessor<T> {
    private BlockingQueue<T> queue;
    private int batchSize;
    private Thread processorThread;
    
    public BatchProcessor(int capacity, int batchSize) {
        this.queue = new LinkedBlockingQueue<>(capacity);
        this.batchSize = batchSize;
        
        processorThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                try {
                    List<T> batch = new ArrayList<>();
                    queue.drainTo(batch, batchSize);
                    
                    if (batch.isEmpty()) {
                        // Wait for at least one item
                        T item = queue.poll(1, TimeUnit.SECONDS);
                        if (item != null) batch.add(item);
                    }
                    
                    if (!batch.isEmpty()) {
                        processBatch(batch);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        processorThread.start();
    }
    
    public void add(T item) throws InterruptedException {
        queue.put(item);
    }
    
    private void processBatch(List<T> batch) {
        System.out.println("Processing batch of " + batch.size() + " items");
        // Process batch...
    }
}

// Usage
BatchProcessor<Integer> processor = new BatchProcessor<>(100, 10);
for (int i = 0; i < 25; i++) {
    processor.add(i);
}
// Will process in batches of 10
```

---

### Example 5: Work Stealing Queue

```java
class WorkStealingExample {
    public static void main(String[] args) throws InterruptedException {
        int numWorkers = 3;
        List<BlockingQueue<Integer>> queues = new ArrayList<>();
        
        // Create queue for each worker
        for (int i = 0; i < numWorkers; i++) {
            queues.add(new LinkedBlockingQueue<>(10));
        }
        
        // Create workers
        for (int i = 0; i < numWorkers; i++) {
            final int workerId = i;
            new Thread(() -> {
                while (true) {
                    try {
                        // Try own queue first
                        Integer task = queues.get(workerId).poll(100, TimeUnit.MILLISECONDS);
                        
                        if (task == null) {
                            // Try stealing from other queues
                            for (int j = 0; j < numWorkers; j++) {
                                if (j != workerId) {
                                    task = queues.get(j).poll();
                                    if (task != null) {
                                        System.out.println("Worker " + workerId + " stole task " + task + " from worker " + j);
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (task != null) {
                            System.out.println("Worker " + workerId + " processing task " + task);
                            Thread.sleep(100);
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }).start();
        }
        
        // Distribute tasks unevenly
        for (int i = 0; i < 20; i++) {
            queues.get(0).put(i);  // All to worker 0
        }
    }
}
```

---

## üÜö BlockingQueue Implementations

| Implementation | Bounded | Ordering | Use Case |
|---------------|---------|----------|----------|
| **ArrayBlockingQueue** | Yes | FIFO | Fixed capacity, fairness option |
| **LinkedBlockingQueue** | Optional | FIFO | Variable capacity, higher throughput |
| **PriorityBlockingQueue** | No | Priority | Priority-based processing |
| **SynchronousQueue** | No (0) | N/A | Direct handoff, no storage |
| **DelayQueue** | No | Delay time | Scheduled tasks, caching |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Not handling InterruptedException
try {
    queue.put(item);
} catch (InterruptedException e) {
    // ‚ùå Don't ignore
    // Thread.currentThread().interrupt();  // ‚úÖ Restore interrupt status
}

// 2. Using blocking operations with timeout incorrectly
Integer item = queue.poll(1, TimeUnit.SECONDS);
// if (item != null) { ... }  // ‚úÖ Check for null

// 3. Deadlock with multiple BlockingQueues
BlockingQueue<Integer> q1 = new ArrayBlockingQueue<>(1);
BlockingQueue<Integer> q2 = new ArrayBlockingQueue<>(1);
// Thread 1: q1.take() then q2.put()
// Thread 2: q2.take() then q1.put()  // Deadlock!

// 4. Not using poison pills for termination
// Producer:
queue.put(-1);  // ‚úÖ Poison pill
// Consumer:
Integer item = queue.take();
if (item == -1) break;  // ‚úÖ Exit condition

// 5. Forgetting capacity limits
BlockingQueue<Integer> bounded = new ArrayBlockingQueue<>(10);
// for (int i = 0; i < 100; i++) queue.put(i);  // ‚ùå Will block if no consumers
```

---

## üí° Best Practices

1. **Use put/take** for blocking behavior (preferred for producer-consumer)
2. **Use offer/poll with timeout** for non-critical scenarios
3. **Handle InterruptedException** properly - restore interrupt status
4. **Use poison pills** for clean thread termination
5. **Choose right implementation** - bounded vs unbounded
6. **Avoid blocking in synchronized blocks** - can cause deadlocks
7. **Use drainTo()** for batch processing efficiency
8. **Set reasonable timeouts** - don't wait forever
9. **Monitor queue size** - avoid unbounded growth

---

## üéØ When to Use BlockingQueue

**Use BlockingQueue when:**
- ‚úÖ Producer-consumer pattern
- ‚úÖ Thread pool task queues
- ‚úÖ Message processing systems
- ‚úÖ Rate limiting
- ‚úÖ Batch processing
- ‚úÖ Work distribution across threads
- ‚úÖ Need thread-safe queue operations

**Don't use BlockingQueue when:**
- ‚ùå Single-threaded application ‚Üí Use `ArrayDeque` or `LinkedList`
- ‚ùå Don't need blocking ‚Üí Use `ConcurrentLinkedQueue`
- ‚ùå Need lock-free operations ‚Üí Use `ConcurrentLinkedQueue`
- ‚ùå Simple synchronization ‚Üí Use `synchronized` blocks

---

## üéì Interview Questions

**Q: What is BlockingQueue?**
A: Thread-safe queue with blocking operations for producer-consumer patterns.

**Q: Difference between put() and offer()?**
A: `put()` blocks if full, `offer()` returns false immediately.

**Q: How to stop consumer thread?**
A: Use poison pill (sentinel value like -1 or null object).

**Q: ArrayBlockingQueue vs LinkedBlockingQueue?**
A: ArrayBlockingQueue is bounded (fixed), LinkedBlockingQueue is optionally bounded (higher throughput).

**Q: What is SynchronousQueue?**
A: Zero-capacity queue for direct handoff between threads.

**Q: Is BlockingQueue fair?**
A: ArrayBlockingQueue can be fair (pass true to constructor), others depend on implementation.

**Q: Can BlockingQueue contain null?**
A: No, throws NullPointerException.

---

## üìö Summary

- **BlockingQueue**: Thread-safe queue with blocking operations
- **Four operation types**: Exception, special value, blocks, times out
- **Key methods**: `put()` (blocks if full), `take()` (blocks if empty)
- **Thread-safe** - safe for concurrent producer-consumer
- **Bounded or unbounded** - capacity restrictions optional
- **Producer-consumer** - ideal for handoff between threads
- Perfect for **thread pools, message queues, work distribution**
- **Handles InterruptedException** - proper thread interruption
- **Poison pills** for clean termination
- Multiple implementations for different use cases
