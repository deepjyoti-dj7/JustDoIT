# üéØ Queue Interface Basics

## üìñ Overview

`Queue` is a collection that holds elements **prior to processing**. It follows **FIFO (First-In-First-Out)** ordering by default.

```java
public interface Queue<E> extends Collection<E>
```

---

## üîë Key Characteristics

1. **FIFO Order** - First element added is first to be removed (default)
2. **Head and Tail** - Add at tail, remove from head
3. **Two Method Styles** - Exception-throwing and null-returning
4. **No Index Access** - Cannot access elements by position
5. **Allows Duplicates** - Can contain duplicate elements
6. **Null Handling** - Depends on implementation

---

## üìä Queue Hierarchy

```
Queue (Interface)
‚îú‚îÄ‚îÄ PriorityQueue (Class) - Heap-based, ordered by priority
‚îú‚îÄ‚îÄ LinkedList (Class) - Doubly-linked list, FIFO
‚îú‚îÄ‚îÄ Deque (Interface)
‚îÇ   ‚îú‚îÄ‚îÄ ArrayDeque (Class) - Resizable array, double-ended
‚îÇ   ‚îî‚îÄ‚îÄ LinkedList (Class) - Doubly-linked list
‚îî‚îÄ‚îÄ BlockingQueue (Interface) - Thread-safe, blocking operations
    ‚îú‚îÄ‚îÄ LinkedBlockingQueue (Class)
    ‚îú‚îÄ‚îÄ ArrayBlockingQueue (Class)
    ‚îú‚îÄ‚îÄ PriorityBlockingQueue (Class)
    ‚îú‚îÄ‚îÄ DelayQueue (Class)
    ‚îî‚îÄ‚îÄ SynchronousQueue (Class)
```

---

## üíª Queue Operations

### Two Styles of Methods

| Operation | Throws Exception | Returns Special Value |
|-----------|-----------------|----------------------|
| **Insert** | `add(e)` | `offer(e)` |
| **Remove** | `remove()` | `poll()` |
| **Examine** | `element()` | `peek()` |

```java
Queue<String> queue = new LinkedList<>();

// Insert operations
queue.add("First");      // Throws IllegalStateException if full
queue.offer("Second");   // Returns false if full

// Examine operations
String head = queue.element();  // Throws NoSuchElementException if empty
String head2 = queue.peek();    // Returns null if empty

// Remove operations
String removed = queue.remove();  // Throws NoSuchElementException if empty
String removed2 = queue.poll();   // Returns null if empty
```

---

## üé® Basic Queue Operations

```java
import java.util.*;

public class QueueBasics {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // Add elements (enqueue)
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        
        System.out.println(queue);  // [First, Second, Third]
        
        // Peek at head (without removing)
        System.out.println("Head: " + queue.peek());  // First
        
        // Remove elements (dequeue) - FIFO order
        System.out.println("Removed: " + queue.poll());  // First
        System.out.println("Removed: " + queue.poll());  // Second
        
        System.out.println("Remaining: " + queue);  // [Third]
        
        // Check size
        System.out.println("Size: " + queue.size());  // 1
        
        // Check empty
        System.out.println("Is empty? " + queue.isEmpty());  // false
    }
}
```

---

## üîß Common Methods

```java
Queue<Integer> queue = new LinkedList<>();

// Basic operations
boolean offer(E e)        // Add element to tail
E poll()                  // Remove and return head (null if empty)
E peek()                  // Return head without removing (null if empty)

// Inherited from Collection
boolean add(E e)          // Add element (throws exception if full)
E remove()                // Remove head (throws exception if empty)
E element()               // Return head (throws exception if empty)
int size()                // Number of elements
boolean isEmpty()         // Check if empty
void clear()              // Remove all elements
boolean contains(Object o) // Check if contains element

// Iteration
Iterator<E> iterator()    // Iterator over queue
```

---

## üìù Common Queue Implementations

### 1. LinkedList (FIFO Queue)

```java
Queue<String> queue = new LinkedList<>();
queue.offer("A");
queue.offer("B");
queue.offer("C");

while (!queue.isEmpty()) {
    System.out.println(queue.poll());  // A, B, C (FIFO)
}
```

**Use when:**
- ‚úÖ Need simple FIFO queue
- ‚úÖ Variable size
- ‚úÖ No capacity restrictions

---

### 2. PriorityQueue (Priority-based)

```java
Queue<Integer> pq = new PriorityQueue<>();
pq.offer(5);
pq.offer(2);
pq.offer(8);
pq.offer(1);

while (!pq.isEmpty()) {
    System.out.println(pq.poll());  // 1, 2, 5, 8 (sorted)
}
```

**Use when:**
- ‚úÖ Need priority-based ordering
- ‚úÖ Elements should be processed by priority (not FIFO)

---

### 3. ArrayDeque (Double-ended Queue)

```java
Deque<String> deque = new ArrayDeque<>();
deque.offerFirst("Front");
deque.offerLast("Back");

System.out.println(deque.pollFirst());  // Front
System.out.println(deque.pollLast());   // Back
```

**Use when:**
- ‚úÖ Need both ends access
- ‚úÖ Stack or queue operations
- ‚úÖ Better performance than LinkedList

---

## üîÑ Iteration

```java
Queue<String> queue = new LinkedList<>(Arrays.asList("A", "B", "C"));

// 1. For-each loop (doesn't remove)
for (String item : queue) {
    System.out.println(item);  // A, B, C
}
System.out.println(queue);  // [A, B, C] - still there

// 2. While polling (removes)
while (!queue.isEmpty()) {
    System.out.println(queue.poll());  // A, B, C
}
System.out.println(queue);  // [] - empty

// 3. Iterator
Queue<String> q2 = new LinkedList<>(Arrays.asList("X", "Y", "Z"));
Iterator<String> iterator = q2.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}

// 4. Java 8 forEach
Queue<String> q3 = new LinkedList<>(Arrays.asList("1", "2", "3"));
q3.forEach(System.out::println);
```

---

## üéØ Real-World Examples

### Example 1: Task Queue

```java
class TaskQueue {
    private Queue<String> tasks = new LinkedList<>();
    
    public void addTask(String task) {
        tasks.offer(task);
        System.out.println("Added task: " + task);
    }
    
    public void processNextTask() {
        String task = tasks.poll();
        if (task != null) {
            System.out.println("Processing: " + task);
        } else {
            System.out.println("No tasks to process");
        }
    }
    
    public int pendingTasks() {
        return tasks.size();
    }
}

// Usage
TaskQueue taskQueue = new TaskQueue();
taskQueue.addTask("Send email");
taskQueue.addTask("Generate report");
taskQueue.addTask("Update database");

taskQueue.processNextTask();  // Processing: Send email
taskQueue.processNextTask();  // Processing: Generate report
System.out.println("Pending: " + taskQueue.pendingTasks());  // 1
```

---

### Example 2: Print Queue

```java
class PrintQueue {
    private Queue<Document> documents = new LinkedList<>();
    
    public void addDocument(Document doc) {
        documents.offer(doc);
    }
    
    public void printNext() {
        Document doc = documents.poll();
        if (doc != null) {
            System.out.println("Printing: " + doc.getName());
        }
    }
    
    public List<String> viewQueue() {
        return documents.stream()
                       .map(Document::getName)
                       .collect(Collectors.toList());
    }
}

class Document {
    private String name;
    public Document(String name) { this.name = name; }
    public String getName() { return name; }
}
```

---

### Example 3: Customer Service Queue

```java
class CustomerServiceQueue {
    private Queue<Customer> waitingCustomers = new LinkedList<>();
    
    public void addCustomer(Customer customer) {
        waitingCustomers.offer(customer);
        System.out.println(customer.getName() + " joined the queue");
    }
    
    public Customer serveNext() {
        Customer customer = waitingCustomers.poll();
        if (customer != null) {
            System.out.println("Now serving: " + customer.getName());
        }
        return customer;
    }
    
    public int queueSize() {
        return waitingCustomers.size();
    }
    
    public Customer checkNext() {
        return waitingCustomers.peek();
    }
}

class Customer {
    private String name;
    private int number;
    
    public Customer(String name, int number) {
        this.name = name;
        this.number = number;
    }
    
    public String getName() { return name; }
}
```

---

### Example 4: Breadth-First Search (BFS)

```java
class Graph {
    private Map<Integer, List<Integer>> adjacencyList = new HashMap<>();
    
    public void addEdge(int from, int to) {
        adjacencyList.computeIfAbsent(from, k -> new ArrayList<>()).add(to);
    }
    
    public void bfs(int start) {
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        
        queue.offer(start);
        visited.add(start);
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            System.out.print(node + " ");
            
            for (int neighbor : adjacencyList.getOrDefault(node, new ArrayList<>())) {
                if (!visited.contains(neighbor)) {
                    visited.add(neighbor);
                    queue.offer(neighbor);
                }
            }
        }
    }
}

// Usage
Graph graph = new Graph();
graph.addEdge(1, 2);
graph.addEdge(1, 3);
graph.addEdge(2, 4);
graph.addEdge(3, 5);
graph.bfs(1);  // Output: 1 2 3 4 5
```

---

## üÜö Queue vs Stack vs List

| Feature | Queue | Stack | List |
|---------|-------|-------|------|
| **Order** | FIFO | LIFO | Index-based |
| **Add** | End (tail) | Top | Any position |
| **Remove** | Front (head) | Top | Any position |
| **Primary ops** | offer, poll | push, pop | add, get, remove |
| **Use case** | Task scheduling | Undo/redo | Random access |

---

## üìä Queue Implementations Comparison

| Implementation | Order | Thread-Safe | Null | Performance |
|---------------|-------|-------------|------|-------------|
| **LinkedList** | FIFO | No | Yes | O(1) for add/remove |
| **PriorityQueue** | Priority | No | No | O(log n) for add/remove |
| **ArrayDeque** | FIFO/LIFO | No | No | O(1) for add/remove |
| **LinkedBlockingQueue** | FIFO | Yes | No | O(1) for add/remove |
| **PriorityBlockingQueue** | Priority | Yes | No | O(log n) for add/remove |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Using exception-throwing methods on empty queue
Queue<String> queue = new LinkedList<>();
// String item = queue.remove();  // NoSuchElementException
String item = queue.poll();  // null (safe)

// 2. Using element() instead of peek()
// String head = queue.element();  // NoSuchElementException if empty
String head = queue.peek();  // null if empty (safe)

// 3. Modifying queue during iteration
Queue<Integer> q = new LinkedList<>(Arrays.asList(1, 2, 3));
for (Integer num : q) {
    // q.poll();  // ConcurrentModificationException
}

// 4. Assuming index access
// Queue has no get(index) method
// Use List if index access is needed

// 5. Not checking isEmpty() before poll
while (!queue.isEmpty()) {  // ‚úÖ Good
    process(queue.poll());
}
```

---

## üí° Best Practices

1. **Prefer `offer()` over `add()`** - Returns false instead of throwing exception
2. **Prefer `poll()` over `remove()`** - Returns null instead of throwing exception
3. **Prefer `peek()` over `element()`** - Returns null instead of throwing exception
4. **Check `isEmpty()`** before polling
5. **Use appropriate implementation**:
   - Simple FIFO ‚Üí `LinkedList` or `ArrayDeque`
   - Priority-based ‚Üí `PriorityQueue`
   - Thread-safe ‚Üí `LinkedBlockingQueue`
   - Stack-like ‚Üí `ArrayDeque` (as Deque)

---

## üéì Choosing the Right Queue

```
Need Queue?
‚îÇ
‚îú‚îÄ Need thread-safety?
‚îÇ  ‚îî‚îÄ YES ‚Üí BlockingQueue (LinkedBlockingQueue, ArrayBlockingQueue)
‚îÇ
‚îú‚îÄ Need priority ordering?
‚îÇ  ‚îî‚îÄ YES ‚Üí PriorityQueue (or PriorityBlockingQueue if thread-safe)
‚îÇ
‚îú‚îÄ Need double-ended operations (both ends)?
‚îÇ  ‚îî‚îÄ YES ‚Üí Deque (ArrayDeque or LinkedList)
‚îÇ
‚îî‚îÄ Need simple FIFO?
   ‚îî‚îÄ ArrayDeque or LinkedList
```

---

## üéØ Interview Questions

**Q: What is a Queue?**
A: Collection that holds elements for processing in FIFO order (typically).

**Q: Difference between offer() and add()?**
A: `offer()` returns false if capacity full, `add()` throws exception.

**Q: Difference between poll() and remove()?**
A: `poll()` returns null if empty, `remove()` throws exception.

**Q: Can Queue contain duplicates?**
A: Yes, Queue allows duplicates.

**Q: Can Queue contain null?**
A: Depends on implementation. LinkedList allows null, PriorityQueue doesn't.

**Q: When to use Queue vs Stack?**
A: Queue for FIFO (task scheduling), Stack for LIFO (undo operations).

---

## üìö Summary

- **Queue**: FIFO collection for holding elements before processing
- **Two method styles**: Exception-throwing (`add`, `remove`, `element`) vs null-returning (`offer`, `poll`, `peek`)
- **Common implementations**: LinkedList, PriorityQueue, ArrayDeque, BlockingQueues
- **Use cases**: Task queues, BFS, print queues, event handling
- **Best practice**: Use null-returning methods (`offer`, `poll`, `peek`)
- **Thread-safe**: Use BlockingQueue implementations
- **Priority ordering**: Use PriorityQueue
