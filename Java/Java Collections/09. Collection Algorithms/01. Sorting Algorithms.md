# üìä Sorting Algorithms

## üìñ Overview

Java Collections Framework uses optimized sorting algorithms for different data types:
- **TimSort** - For objects (Collections.sort(), Arrays.sort() for objects)
- **DualPivotQuicksort** - For primitives (Arrays.sort() for primitives)

Both have **O(n log n)** time complexity with excellent real-world performance.

---

## ‚≠ê TimSort

### Overview
- **Hybrid** algorithm combining merge sort + insertion sort
- **Stable** - maintains relative order of equal elements
- **Adaptive** - exploits existing order in data
- Used for **object arrays** and **Lists**

### Characteristics
```java
Time complexity:
- Best: O(n) - already sorted
- Average: O(n log n)
- Worst: O(n log n)

Space complexity: O(n) - temporary array
Stable: Yes
```

### How It Works
1. Divide data into small "runs" (min 32-64 elements)
2. Sort runs using insertion sort
3. Merge runs using merge sort
4. Exploits naturally ordered subsequences

### Usage
```java
// Collections.sort() - uses TimSort
List<String> list = new ArrayList<>(Arrays.asList("Charlie", "Alice", "Bob"));
Collections.sort(list);  // [Alice, Bob, Charlie]

// Arrays.sort() for objects - uses TimSort
String[] arr = {"Charlie", "Alice", "Bob"};
Arrays.sort(arr);  // [Alice, Bob, Charlie]
```

### Advantages
- Fast on partially sorted data
- Stable sorting
- Good worst-case guarantee O(n log n)
- Low overhead for small arrays

---

## ‚ö° DualPivotQuicksort

### Overview
- **Enhanced Quicksort** with two pivots instead of one
- **Not stable** - may change relative order
- **In-place** - minimal extra space
- Used for **primitive arrays**

### Characteristics
```java
Time complexity:
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n log n) - improved with dual pivots

Space complexity: O(log n) - recursion stack
Stable: No
```

### How It Works
1. Choose two pivots (p1 < p2) from array
2. Partition into 3 regions: < p1, between p1-p2, > p2
3. Recursively sort each region
4. Falls back to insertion sort for small arrays

### Usage
```java
// Arrays.sort() for primitives - uses DualPivotQuicksort
int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};
Arrays.sort(numbers);  // [1, 1, 2, 3, 4, 5, 6, 9]

// All primitive types
double[] prices = {19.99, 5.49, 12.99};
Arrays.sort(prices);
```

### Advantages
- Faster than traditional quicksort (fewer comparisons)
- In-place sorting (less memory)
- Excellent cache locality
- Optimized for primitives

---

## üÜö TimSort vs DualPivotQuicksort

| Feature | TimSort | DualPivotQuicksort |
|---------|---------|-------------------|
| **Used for** | Objects, Lists | Primitives |
| **Stability** | Stable | Not stable |
| **Best case** | O(n) | O(n log n) |
| **Space** | O(n) | O(log n) |
| **Adaptive** | Yes | No |
| **Algorithm** | Merge + Insertion | Quicksort variant |

---

## üìä Performance Comparison

```java
// Benchmark
int[] primitives = new int[1_000_000];
Integer[] objects = new Integer[1_000_000];

// Fill with random data
Random rand = new Random();
for (int i = 0; i < primitives.length; i++) {
    primitives[i] = rand.nextInt();
    objects[i] = primitives[i];
}

// Sort primitives (DualPivotQuicksort)
long start = System.nanoTime();
Arrays.sort(primitives);
long time1 = System.nanoTime() - start;

// Sort objects (TimSort)
start = System.nanoTime();
Arrays.sort(objects);
long time2 = System.nanoTime() - start;

System.out.println("Primitives: " + time1/1_000_000 + " ms");
System.out.println("Objects: " + time2/1_000_000 + " ms");

// Primitives typically 2-3x faster due to:
// - No object overhead
// - Better cache locality
// - Fewer memory allocations
```

---

## üéØ Real-World Usage

### 1. Sort by Natural Order
```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5);
Collections.sort(numbers);  // TimSort
// [1, 1, 3, 4, 5]
```

### 2. Sort with Custom Comparator
```java
List<String> names = Arrays.asList("Alice", "Charlie", "Bob");
Collections.sort(names, Comparator.comparingInt(String::length));  // TimSort
// [Bob, Alice, Charlie]
```

### 3. Sort Primitive Array
```java
int[] scores = {85, 92, 78, 95, 88};
Arrays.sort(scores);  // DualPivotQuicksort
// [78, 85, 88, 92, 95]
```

### 4. Partial Sort
```java
int[] arr = {5, 3, 8, 1, 9, 2, 7};
Arrays.sort(arr, 1, 5);  // Sort indices 1-4
// [5, 1, 3, 8, 9, 2, 7]
```

---

## üöÄ Optimization Tips

### 1. Use Primitives When Possible
```java
// ‚úÖ Faster - primitives with DualPivotQuicksort
int[] primitives = {3, 1, 4, 1, 5};
Arrays.sort(primitives);

// ‚ö†Ô∏è Slower - objects with TimSort
Integer[] objects = {3, 1, 4, 1, 5};
Arrays.sort(objects);

// Primitives are 2-3x faster
```

### 2. Pre-Sorted Data
```java
// TimSort excels with partially sorted data
List<Integer> mostlySorted = Arrays.asList(1, 2, 3, 5, 4, 6, 7);
Collections.sort(mostlySorted);  // Very fast O(n)
```

### 3. Parallel Sort for Large Arrays
```java
int[] large = new int[10_000_000];
// ... fill array

// For large arrays (> 8192 elements)
Arrays.parallelSort(large);  // Faster than Arrays.sort()
```

### 4. Avoid Repeated Sorting
```java
// ‚ùå Sorting multiple times
Collections.sort(list);
// ... use list
Collections.sort(list);  // Wasteful if already sorted

// ‚úÖ Sort once, use multiple times
Collections.sort(list);
// ... use list many times
```

---

## üîç Stability Matters

```java
class Person {
    String name;
    int age;
}

List<Person> people = Arrays.asList(
    new Person("Alice", 30),
    new Person("Bob", 25),
    new Person("Charlie", 30)
);

// First sort by name
Collections.sort(people, Comparator.comparing(Person::getName));

// Then sort by age (stable - maintains name order for same age)
Collections.sort(people, Comparator.comparingInt(Person::getAge));

// Result: Bob(25), Alice(30), Charlie(30)
// Alice before Charlie because TimSort is stable
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Assuming stability for primitives**
```java
int[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr);
// ‚ùå DualPivotQuicksort is NOT stable
// The two 1's may swap positions
```

2. **Sorting while iterating**
```java
// ‚ùå ConcurrentModificationException
for (Integer num : list) {
    Collections.sort(list);  // Don't do this
}
```

3. **Not checking if already sorted**
```java
// ‚úÖ Check if sort needed
if (!isSorted(list)) {
    Collections.sort(list);
}
```

---

## üí° Best Practices

1. **Choose appropriate type**
```java
// ‚úÖ Use primitives for performance
int[] primitives = {3, 1, 4, 1, 5};
Arrays.sort(primitives);  // Fast DualPivotQuicksort

// ‚úÖ Use objects for stability
Integer[] objects = {3, 1, 4, 1, 5};
Arrays.sort(objects);  // Stable TimSort
```

2. **Leverage TimSort's adaptiveness**
```java
// ‚úÖ TimSort is fast on nearly sorted data
List<Integer> nearlySorted = getNearlySortedData();
Collections.sort(nearlySorted);  // Very efficient
```

3. **Use parallel sort for large data**
```java
// ‚úÖ Parallel for large arrays
if (arr.length > 10_000) {
    Arrays.parallelSort(arr);
}
```

---

## üìö Interview Questions

**Q1: What algorithm does Collections.sort() use?**
A: TimSort - hybrid of merge sort and insertion sort.

**Q2: What algorithm does Arrays.sort() use for primitives?**
A: DualPivotQuicksort - optimized quicksort with two pivots.

**Q3: Is TimSort stable?**
A: Yes, maintains relative order of equal elements.

**Q4: Why use different algorithms for primitives vs objects?**
A: Primitives optimize for speed (no stability needed). Objects need stability for multi-field sorting.

**Q5: Time complexity of TimSort?**
A: Best O(n), Average/Worst O(n log n).

**Q6: Why is TimSort adaptive?**
A: Exploits existing runs of sorted data for O(n) best case.

**Q7: When is DualPivotQuicksort faster?**
A: On primitive arrays due to cache locality and no object overhead.

**Q8: Can you make primitive sort stable?**
A: No, but convert to wrapper class (int[] ‚Üí Integer[]) for stable sort.

---

## üìö Summary

- **TimSort**: Hybrid merge+insertion sort for objects/Lists, stable, O(n log n), adaptive
- **DualPivotQuicksort**: Enhanced quicksort for primitives, not stable, O(n log n), in-place
- **Use primitives** for speed, **objects** for stability
- **Parallel sort** for large datasets (> 8192 elements)
- **Both algorithms** highly optimized for real-world data
