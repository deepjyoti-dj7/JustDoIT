# ğŸ” Searching Algorithms

## ğŸ“– Overview

Java provides two main searching algorithms:
- **Binary Search** - O(log n) on sorted data
- **Linear Search** - O(n) on any data

Collections Framework provides built-in methods for both approaches.

---

## â­ Binary Search

### Overview
**Binary search** divides the search space in half repeatedly. Requires **sorted** data.

```java
// Arrays.binarySearch()
int index = Arrays.binarySearch(array, key);

// Collections.binarySearch()
int index = Collections.binarySearch(list, key);
```

### Time Complexity
```java
Time: O(log n)
Space: O(1)
Requirement: Data must be sorted
```

---

## ğŸ’» Binary Search Usage

### 1. Search Primitive Arrays
```java
int[] numbers = {10, 20, 30, 40, 50};  // MUST be sorted

int index = Arrays.binarySearch(numbers, 30);
System.out.println("Found at: " + index);  // 2

int notFound = Arrays.binarySearch(numbers, 25);
System.out.println("Not found: " + notFound);  // -3
```

### 2. Search Object Arrays
```java
String[] names = {"Alice", "Bob", "Charlie", "David"};  // Sorted

int index = Arrays.binarySearch(names, "Charlie");
System.out.println(index);  // 2
```

### 3. Search Lists
```java
List<Integer> list = Arrays.asList(10, 20, 30, 40, 50);

int index = Collections.binarySearch(list, 30);
System.out.println(index);  // 2
```

### 4. Search with Comparator
```java
String[] names = {"alice", "bob", "charlie"};
Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);

int index = Arrays.binarySearch(names, "BOB", String.CASE_INSENSITIVE_ORDER);
System.out.println(index);  // 1
```

---

## ğŸ“Š Return Values

```java
int[] arr = {10, 20, 30, 40, 50};

// Found: returns index
int found = Arrays.binarySearch(arr, 30);  // 2

// Not found: returns -(insertion point) - 1
int notFound = Arrays.binarySearch(arr, 25);  // -3

// Get insertion point
int insertionPoint = -(notFound) - 1;  // 2
System.out.println("Insert at index: " + insertionPoint);
```

**Formula**: 
- **Found**: returns index (â‰¥ 0)
- **Not found**: returns -(insertion point) - 1 (< 0)

---

## ğŸ”„ Linear Search

### Overview
**Linear search** checks each element sequentially. Works on **any** data (sorted or unsorted).

```java
// Manual implementation
public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;  // Not found
}
```

### Time Complexity
```java
Time: O(n)
Space: O(1)
Requirement: None (works on any data)
```

---

## ğŸ’» Linear Search Usage

### 1. Using indexOf()
```java
List<String> list = Arrays.asList("Alice", "Bob", "Charlie");

// indexOf() - linear search
int index = list.indexOf("Bob");  // 1

int notFound = list.indexOf("David");  // -1
```

### 2. Using contains()
```java
List<Integer> numbers = Arrays.asList(10, 20, 30);

boolean exists = numbers.contains(20);  // true - O(n)
```

### 3. Custom Linear Search
```java
class Person {
    String name;
    int age;
}

List<Person> people = getPeople();

// Find by custom criteria
Person found = null;
for (Person p : people) {
    if (p.age > 30) {
        found = p;
        break;
    }
}
```

### 4. Stream Search
```java
List<Integer> numbers = Arrays.asList(10, 20, 30, 40, 50);

// Find first match
Optional<Integer> result = numbers.stream()
    .filter(n -> n > 25)
    .findFirst();

System.out.println(result.get());  // 30
```

---

## ğŸ†š Binary Search vs Linear Search

| Feature | Binary Search | Linear Search |
|---------|--------------|---------------|
| **Time** | O(log n) | O(n) |
| **Requirement** | Sorted data | Any data |
| **Best for** | Large sorted data | Small/unsorted data |
| **Implementation** | Complex | Simple |
| **Methods** | binarySearch() | indexOf(), contains() |

---

## ğŸ¯ Real-World Examples

### 1. Find Student by ID (Binary Search)
```java
class Student implements Comparable<Student> {
    int id;
    String name;
    
    @Override
    public int compareTo(Student o) {
        return Integer.compare(this.id, o.id);
    }
}

Student[] students = getStudents();
Arrays.sort(students);  // Sort by id

Student search = new Student(12345, null);
int index = Arrays.binarySearch(students, search);

if (index >= 0) {
    System.out.println("Found: " + students[index].name);
}
```

---

### 2. Check Product Availability (Linear Search)
```java
List<String> availableProducts = Arrays.asList("Laptop", "Phone", "Tablet");

String product = "Phone";
if (availableProducts.contains(product)) {
    System.out.println(product + " is available");
}
```

---

### 3. Find First Match (Stream)
```java
List<Order> orders = getOrders();

// Find first pending order
Optional<Order> pending = orders.stream()
    .filter(o -> o.status == Status.PENDING)
    .findFirst();

pending.ifPresent(o -> System.out.println("Process: " + o.id));
```

---

### 4. Search in Range
```java
int[] sortedScores = {65, 72, 78, 85, 90, 95, 98};

// Search in subarray (indices 2 to 5)
int index = Arrays.binarySearch(sortedScores, 2, 5, 85);
System.out.println("Found at: " + index);  // 3
```

---

### 5. Find All Matches (Linear)
```java
List<Product> products = getProducts();

// Find all products in category
List<Product> electronics = products.stream()
    .filter(p -> p.category.equals("Electronics"))
    .collect(Collectors.toList());
```

---

## âš ï¸ Common Pitfalls

1. **Binary search on unsorted data**
```java
int[] arr = {5, 2, 8, 1, 9};  // NOT sorted

// âŒ Undefined behavior
int result = Arrays.binarySearch(arr, 5);  // May return wrong result

// âœ… Sort first
Arrays.sort(arr);
int result2 = Arrays.binarySearch(arr, 5);
```

2. **Wrong comparator**
```java
String[] arr = {"alice", "bob", "charlie"};
Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);

// âŒ Search without comparator
int wrong = Arrays.binarySearch(arr, "BOB");  // Wrong result

// âœ… Use same comparator
int correct = Arrays.binarySearch(arr, "BOB", String.CASE_INSENSITIVE_ORDER);
```

3. **Not checking negative result**
```java
int[] arr = {10, 20, 30};
int index = Arrays.binarySearch(arr, 25);

// âŒ Direct access
// System.out.println(arr[index]);  // ArrayIndexOutOfBoundsException

// âœ… Check first
if (index >= 0) {
    System.out.println(arr[index]);
}
```

4. **Linear search on large sorted data**
```java
List<Integer> large = getLargeSortedList();  // 1,000,000 elements

// âŒ Slow - O(n)
int index = large.indexOf(target);

// âœ… Fast - O(log n)
int index2 = Collections.binarySearch(large, target);
```

5. **LinkedList with binary search**
```java
// âš ï¸ O(n) - LinkedList doesn't implement RandomAccess
List<Integer> linkedList = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(linkedList, 3);  // Falls back to linear search!

// âœ… Use ArrayList for O(log n)
List<Integer> arrayList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(arrayList, 3);
```

---

## ğŸ’¡ Best Practices

1. **Sort before binary search**
```java
// âœ… Always sort first
int[] arr = {5, 2, 8, 1, 9};
Arrays.sort(arr);
int index = Arrays.binarySearch(arr, 5);
```

2. **Use binary search for large sorted data**
```java
// âœ… Binary search for large sorted collections
if (list.size() > 100 && isSorted(list)) {
    int index = Collections.binarySearch(list, target);
}
```

3. **Use linear search for small or unsorted data**
```java
// âœ… Linear search for small lists
if (list.size() < 50) {
    int index = list.indexOf(target);  // Simple and fast enough
}
```

4. **Check return value**
```java
// âœ… Always check if found
int index = Arrays.binarySearch(arr, key);
if (index >= 0) {
    // Found - use arr[index]
} else {
    // Not found - insertion point = -(index) - 1
}
```

5. **Use ArrayList for Collections.binarySearch()**
```java
// âœ… ArrayList provides O(log n)
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(list, 3);

// âŒ LinkedList degrades to O(n)
List<Integer> linkedList = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(linkedList, 3);  // Slow!
```

---

## ğŸš€ Performance Comparison

```java
int size = 1_000_000;
List<Integer> sorted = new ArrayList<>();
for (int i = 0; i < size; i++) {
    sorted.add(i);
}

int target = size - 1;

// Binary search - O(log n)
long start = System.nanoTime();
int result1 = Collections.binarySearch(sorted, target);
long time1 = System.nanoTime() - start;

// Linear search - O(n)
start = System.nanoTime();
int result2 = sorted.indexOf(target);
long time2 = System.nanoTime() - start;

System.out.println("Binary: " + time1 + " ns");  // ~100 ns
System.out.println("Linear: " + time2 + " ns");  // ~10,000,000 ns

// Binary search is ~100,000x faster for large sorted data!
```

---

## ğŸ“ When to Use

### âœ… Binary Search When:
- Data is **sorted**
- **Large** dataset (> 100 elements)
- **Frequent** searches
- Need O(log n) performance

### âœ… Linear Search When:
- Data is **unsorted**
- **Small** dataset (< 50 elements)
- **Rare** searches
- Simple implementation needed

---

## ğŸ“š Interview Questions

**Q1: Binary search time complexity?**
A: O(log n) - divides search space in half each step.

**Q2: Can you use binary search on unsorted data?**
A: No, results are undefined. Must sort first.

**Q3: What does negative return value mean in binarySearch()?**
A: Element not found. Value = -(insertion point) - 1.

**Q4: Linear search time complexity?**
A: O(n) - checks each element sequentially.

**Q5: When is linear search better than binary search?**
A: On small datasets or unsorted data where sorting overhead > search benefit.

**Q6: Why is Collections.binarySearch() slow on LinkedList?**
A: LinkedList lacks RandomAccess, so it falls back to O(n) linear search.

**Q7: How to get insertion point from binarySearch()?**
A: If result < 0, insertion point = -(result) - 1.

**Q8: Can binary search find all occurrences?**
A: Finds one occurrence. Expand left/right to find all.

---

## ğŸ“š Summary

- **Binary search**: O(log n), requires sorted data, uses binarySearch()
- **Linear search**: O(n), works on any data, uses indexOf()/contains()
- **Binary search** for large sorted data
- **Linear search** for small or unsorted data
- Always **sort before** binary search
- Check **return value** (negative = not found)
- Use **ArrayList** for O(log n) binary search performance
