# üî∫ Min & Max

## üìñ Overview

Java Collections provides methods to find minimum and maximum elements:
- **Collections.min()** - Find smallest element
- **Collections.max()** - Find largest element

Both work with natural ordering or custom comparators.

---

## ‚≠ê Key Characteristics

1. **Time complexity** - O(n) - single pass through collection
2. **Space complexity** - O(1) - constant space
3. **Natural ordering** - Uses Comparable
4. **Custom ordering** - Uses Comparator
5. **Throws exception** - If collection is empty (NoSuchElementException)

---

## üìù Method Signatures

```java
// Natural ordering (Comparable)
<T extends Comparable<? super T>> T min(Collection<? extends T> coll)
<T extends Comparable<? super T>> T max(Collection<? extends T> coll)

// Custom ordering (Comparator)
<T> T min(Collection<? extends T> coll, Comparator<? super T> comp)
<T> T max(Collection<? extends T> coll, Comparator<? super T> comp)
```

---

## üíª Basic Usage

### 1. Find Min/Max in Integer List
```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6);

int min = Collections.min(numbers);
int max = Collections.max(numbers);

System.out.println("Min: " + min);  // 1
System.out.println("Max: " + max);  // 9
```

### 2. Find Min/Max in String List
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

String min = Collections.min(names);  // Lexicographic order
String max = Collections.max(names);

System.out.println("Min: " + min);  // Alice
System.out.println("Max: " + max);  // David
```

### 3. Min/Max with Comparator
```java
List<String> words = Arrays.asList("apple", "pie", "banana", "kiwi");

// By length
String shortest = Collections.min(words, Comparator.comparingInt(String::length));
String longest = Collections.max(words, Comparator.comparingInt(String::length));

System.out.println("Shortest: " + shortest);  // pie
System.out.println("Longest: " + longest);    // banana
```

### 4. Custom Objects with Natural Ordering
```java
class Person implements Comparable<Person> {
    String name;
    int age;
    
    @Override
    public int compareTo(Person o) {
        return Integer.compare(this.age, o.age);
    }
}

List<Person> people = Arrays.asList(
    new Person("Alice", 30),
    new Person("Bob", 25),
    new Person("Charlie", 35)
);

Person youngest = Collections.min(people);  // Bob (25)
Person oldest = Collections.max(people);    // Charlie (35)
```

---

## üéØ Real-World Examples

### 1. Find Price Range
```java
class Product {
    String name;
    double price;
}

List<Product> products = getProducts();

Product cheapest = Collections.min(products, Comparator.comparingDouble(Product::getPrice));
Product mostExpensive = Collections.max(products, Comparator.comparingDouble(Product::getPrice));

System.out.println("Price range: $" + cheapest.price + " - $" + mostExpensive.price);
```

---

### 2. Temperature Range
```java
List<Double> temperatures = Arrays.asList(72.5, 68.3, 75.1, 70.2, 73.8);

double minTemp = Collections.min(temperatures);
double maxTemp = Collections.max(temperatures);

System.out.println("Temperature range: " + minTemp + "¬∞F - " + maxTemp + "¬∞F");
// Temperature range: 68.3¬∞F - 75.1¬∞F
```

---

### 3. Earliest/Latest Date
```java
List<LocalDate> dates = Arrays.asList(
    LocalDate.of(2024, 1, 15),
    LocalDate.of(2024, 3, 20),
    LocalDate.of(2024, 2, 10)
);

LocalDate earliest = Collections.min(dates);
LocalDate latest = Collections.max(dates);

System.out.println("Period: " + earliest + " to " + latest);
// Period: 2024-01-15 to 2024-03-20
```

---

### 4. Best/Worst Score
```java
class Student {
    String name;
    int score;
}

List<Student> students = getStudents();

Student lowest = Collections.min(students, Comparator.comparingInt(Student::getScore));
Student highest = Collections.max(students, Comparator.comparingInt(Student::getScore));

System.out.println("Score range: " + lowest.score + " - " + highest.score);
System.out.println("Best: " + highest.name + " (" + highest.score + ")");
System.out.println("Needs help: " + lowest.name + " (" + lowest.score + ")");
```

---

### 5. File Size Range
```java
File[] files = new File("/path").listFiles();
List<File> fileList = Arrays.asList(files);

File smallest = Collections.min(fileList, Comparator.comparingLong(File::length));
File largest = Collections.max(fileList, Comparator.comparingLong(File::length));

System.out.println("Smallest: " + smallest.getName() + " (" + smallest.length() + " bytes)");
System.out.println("Largest: " + largest.getName() + " (" + largest.length() + " bytes)");
```

---

### 6. Stock Price Range
```java
class StockPrice {
    LocalDateTime timestamp;
    double price;
}

List<StockPrice> prices = getTodayPrices();

StockPrice dayLow = Collections.min(prices, Comparator.comparingDouble(StockPrice::getPrice));
StockPrice dayHigh = Collections.max(prices, Comparator.comparingDouble(StockPrice::getPrice));

System.out.println("Day Range: $" + dayLow.price + " - $" + dayHigh.price);
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Empty collection**
```java
List<Integer> empty = new ArrayList<>();

// ‚ùå NoSuchElementException
int min = Collections.min(empty);

// ‚úÖ Check if empty
if (!empty.isEmpty()) {
    int min = Collections.min(empty);
}

// ‚úÖ Or use Stream with Optional
Optional<Integer> min = empty.stream().min(Comparator.naturalOrder());
```

2. **No Comparable implementation**
```java
class Person {
    String name;
    int age;
    // ‚ùå Doesn't implement Comparable
}

List<Person> people = getPeople();

// ‚ùå ClassCastException
Person min = Collections.min(people);

// ‚úÖ Provide Comparator
Person youngest = Collections.min(people, Comparator.comparingInt(Person::getAge));
```

3. **Null elements**
```java
List<Integer> numbers = Arrays.asList(1, 2, null, 3);

// ‚ùå NullPointerException
int min = Collections.min(numbers);

// ‚úÖ Filter nulls
int min = Collections.min(numbers.stream()
    .filter(Objects::nonNull)
    .collect(Collectors.toList()));
```

4. **Wrong comparator**
```java
List<String> words = Arrays.asList("apple", "pie", "banana");

// ‚ùå Gets "apple" (shortest), not "banana" (longest alphabetically)
String result = Collections.max(words, Comparator.comparingInt(String::length));

// ‚úÖ Use natural ordering for alphabetical
String max = Collections.max(words);  // "pie" (lexicographic)
```

5. **Performance on large collections**
```java
List<Integer> large = generateLargeList(10_000_000);

// ‚ùå Calling min() and max() separately - O(2n)
int min = Collections.min(large);
int max = Collections.max(large);

// ‚úÖ Single pass to find both - O(n)
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int n : large) {
    if (n < min) min = n;
    if (n > max) max = n;
}
```

---

## üí° Best Practices

1. **Check for empty collection**
```java
// ‚úÖ Safe approach
if (!list.isEmpty()) {
    int min = Collections.min(list);
    int max = Collections.max(list);
}
```

2. **Use Stream for optional result**
```java
// ‚úÖ Returns Optional
Optional<Integer> min = list.stream()
    .min(Comparator.naturalOrder());

min.ifPresent(m -> System.out.println("Min: " + m));
```

3. **Find both min and max in single pass**
```java
// ‚úÖ Efficient for large collections
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int n : numbers) {
    if (n < min) min = n;
    if (n > max) max = n;
}
```

4. **Reuse comparators**
```java
// ‚úÖ Define once, use multiple times
Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);

Product cheapest = Collections.min(products, byPrice);
Product expensive = Collections.max(products, byPrice);
```

5. **Handle nulls explicitly**
```java
// ‚úÖ Null-safe comparator
Comparator<String> nullSafe = Comparator.nullsLast(Comparator.naturalOrder());

String min = Collections.min(list, nullSafe);
String max = Collections.max(list, nullSafe);
```

---

## üÜö Alternatives

### 1. Stream min/max
```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9);

// Collections.min/max
int min1 = Collections.min(numbers);
int max1 = Collections.max(numbers);

// Stream (returns Optional)
Optional<Integer> min2 = numbers.stream().min(Comparator.naturalOrder());
Optional<Integer> max2 = numbers.stream().max(Comparator.naturalOrder());

// For primitives
int[] arr = {3, 1, 4, 1, 5, 9};
int min3 = Arrays.stream(arr).min().getAsInt();
int max3 = Arrays.stream(arr).max().getAsInt();
```

### 2. Manual loop
```java
// Find min and max in single pass
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;

for (int n : numbers) {
    if (n < min) min = n;
    if (n > max) max = n;
}
```

### 3. Sorting approach (inefficient)
```java
// ‚ùå O(n log n) - inefficient
List<Integer> sorted = new ArrayList<>(numbers);
Collections.sort(sorted);
int min = sorted.get(0);
int max = sorted.get(sorted.size() - 1);

// ‚úÖ O(n) - use Collections.min/max
```

---

## üìä Performance Comparison

```java
List<Integer> large = new ArrayList<>();
for (int i = 0; i < 10_000_000; i++) {
    large.add(i);
}

// 1. Collections.min() + Collections.max() - O(2n)
long start = System.nanoTime();
int min1 = Collections.min(large);
int max1 = Collections.max(large);
long time1 = System.nanoTime() - start;

// 2. Single pass manual - O(n)
start = System.nanoTime();
int min2 = Integer.MAX_VALUE;
int max2 = Integer.MIN_VALUE;
for (int n : large) {
    if (n < min2) min2 = n;
    if (n > max2) max2 = n;
}
long time2 = System.nanoTime() - start;

// 3. Sorting approach - O(n log n)
start = System.nanoTime();
List<Integer> sorted = new ArrayList<>(large);
Collections.sort(sorted);
int min3 = sorted.get(0);
int max3 = sorted.get(sorted.size() - 1);
long time3 = System.nanoTime() - start;

System.out.println("Collections min+max: " + time1/1_000_000 + " ms");  // ~80 ms
System.out.println("Single pass: " + time2/1_000_000 + " ms");          // ~40 ms
System.out.println("Sorting: " + time3/1_000_000 + " ms");              // ~800 ms
```

---

## üéì When to Use

### ‚úÖ Use Collections.min/max When:
- Need min OR max (not both)
- Small to medium collections
- Simple, readable code
- Working with any Collection type

### ‚úÖ Use Manual Loop When:
- Need BOTH min AND max
- Very large collections (performance critical)
- Custom logic during traversal

### ‚ùå Don't Use:
- Sorting just to find min/max (O(n log n) vs O(n))

---

## üìö Interview Questions

**Q1: Time complexity of Collections.min/max?**
A: O(n) - single pass through collection.

**Q2: Space complexity?**
A: O(1) - constant space.

**Q3: What if collection is empty?**
A: Throws NoSuchElementException.

**Q4: Can it work without Comparable?**
A: Yes, provide Comparator as second argument.

**Q5: How to handle null elements?**
A: Use nullsFirst/nullsLast comparators or filter nulls.

**Q6: Collections.min/max vs Stream min/max?**
A: Collections throws exception if empty, Stream returns Optional.

**Q7: How to find both min and max efficiently?**
A: Single manual loop O(n) instead of two separate calls O(2n).

**Q8: Why not sort to find min/max?**
A: Sorting is O(n log n), min/max is O(n) - much more efficient.

---

## üìö Summary

### Collections.min()
- **Purpose**: Find smallest element in collection
- **Time**: O(n), **Space**: O(1)
- **Ordering**: Natural (Comparable) or custom (Comparator)
- **Exception**: NoSuchElementException if empty

### Collections.max()
- **Purpose**: Find largest element in collection
- **Time**: O(n), **Space**: O(1)
- **Ordering**: Natural (Comparable) or custom (Comparator)
- **Exception**: NoSuchElementException if empty

### Best Practices
- Check for empty collection before calling
- Use Stream for Optional result
- Find both min and max in single pass for large data
- Reuse comparators
- Handle nulls explicitly
- Don't sort just to find min/max
