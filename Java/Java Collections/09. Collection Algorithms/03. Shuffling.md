# üé≤ Shuffling

## üìñ Overview

**Collections.shuffle()** randomly permutes a list using a **Fisher-Yates algorithm**. Useful for randomization, games, sampling, and testing.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.shuffle(list);
System.out.println(list);  // [3, 1, 5, 2, 4] (random order)
```

---

## ‚≠ê Key Characteristics

1. **Algorithm** - Fisher-Yates shuffle (unbiased)
2. **Time complexity** - O(n)
3. **In-place** - Modifies original list
4. **Randomness** - Uses Random or SecureRandom
5. **Unbiased** - All permutations equally likely
6. **Thread-safe** - Can provide custom Random instance

---

## üìù Method Signatures

```java
// Default randomness
void shuffle(List<?> list)

// Custom random source
void shuffle(List<?> list, Random rnd)
```

---

## üíª Basic Usage

### 1. Simple Shuffle
```java
List<String> deck = new ArrayList<>(Arrays.asList(
    "A‚ô†", "K‚ô†", "Q‚ô†", "J‚ô†", "10‚ô†"
));

Collections.shuffle(deck);
System.out.println(deck);  // Random order
```

### 2. Shuffle with Custom Random
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// Reproducible shuffle with seed
Random random = new Random(42);
Collections.shuffle(numbers, random);
System.out.println(numbers);  // Same result with same seed
```

### 3. Multiple Shuffles
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// Shuffle multiple times
for (int i = 0; i < 3; i++) {
    Collections.shuffle(list);
    System.out.println(list);
}
```

### 4. Shuffle with SecureRandom (Cryptographic)
```java
List<String> passwords = new ArrayList<>(Arrays.asList("pass1", "pass2", "pass3"));

// Cryptographically secure randomness
SecureRandom secureRandom = new SecureRandom();
Collections.shuffle(passwords, secureRandom);
```

---

## üéØ Real-World Examples

### 1. Shuffle Card Deck
```java
class Card {
    String rank;
    String suit;
    
    @Override
    public String toString() {
        return rank + suit;
    }
}

List<Card> deck = new ArrayList<>();
String[] ranks = {"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"};
String[] suits = {"‚ô†", "‚ô•", "‚ô¶", "‚ô£"};

// Create deck
for (String suit : suits) {
    for (String rank : ranks) {
        deck.add(new Card(rank, suit));
    }
}

// Shuffle deck
Collections.shuffle(deck);

// Deal cards
System.out.println("Dealing 5 cards:");
for (int i = 0; i < 5; i++) {
    System.out.println(deck.get(i));
}
```

---

### 2. Random Quiz Questions
```java
class Question {
    String text;
    String[] options;
    int correctAnswer;
}

List<Question> questions = loadQuestions();  // 50 questions

// Shuffle for random quiz
Collections.shuffle(questions);

// Take first 10 questions
List<Question> quiz = questions.subList(0, 10);
System.out.println("Quiz has " + quiz.size() + " random questions");
```

---

### 3. Random Team Assignment
```java
List<String> students = new ArrayList<>(Arrays.asList(
    "Alice", "Bob", "Charlie", "David", "Eve", "Frank"
));

Collections.shuffle(students);

// Divide into teams of 2
int teamSize = 2;
for (int i = 0; i < students.size(); i += teamSize) {
    List<String> team = students.subList(i, Math.min(i + teamSize, students.size()));
    System.out.println("Team " + (i/teamSize + 1) + ": " + team);
}
// Team 1: [Eve, Charlie]
// Team 2: [David, Alice]
// Team 3: [Bob, Frank]
```

---

### 4. Random Playlist
```java
class Song {
    String title;
    String artist;
}

List<Song> playlist = loadPlaylist();

// Shuffle playlist
Collections.shuffle(playlist);

System.out.println("Now playing in random order:");
playlist.forEach(song -> System.out.println(song.title));
```

---

### 5. A/B Testing
```java
List<User> users = getActiveUsers();

// Shuffle users
Collections.shuffle(users);

// Split 50-50 for A/B test
int mid = users.size() / 2;
List<User> groupA = users.subList(0, mid);
List<User> groupB = users.subList(mid, users.size());

System.out.println("Group A: " + groupA.size() + " users (Feature ON)");
System.out.println("Group B: " + groupB.size() + " users (Feature OFF)");
```

---

## üîç Fisher-Yates Algorithm

```java
// How Collections.shuffle() works internally
public static void shuffle(List<?> list, Random rnd) {
    int size = list.size();
    
    // Iterate from end to start
    for (int i = size; i > 1; i--) {
        // Pick random index from 0 to i-1
        int j = rnd.nextInt(i);
        
        // Swap elements at i-1 and j
        swap(list, i-1, j);
    }
}

// Helper method
private static void swap(List<?> list, int i, int j) {
    final List l = list;
    l.set(i, l.set(j, l.get(i)));
}
```

**Why it works:**
- Each position has equal probability of any element
- Time: O(n) - single pass
- Space: O(1) - in-place
- Unbiased - all n! permutations equally likely

---

## ‚ö†Ô∏è Common Pitfalls

1. **Shuffling immutable list**
```java
List<Integer> immutable = List.of(1, 2, 3, 4, 5);

// ‚ùå UnsupportedOperationException
Collections.shuffle(immutable);

// ‚úÖ Create mutable copy
List<Integer> mutable = new ArrayList<>(immutable);
Collections.shuffle(mutable);
```

2. **Shuffling fixed-size list**
```java
// ‚ùå Arrays.asList() returns fixed-size list
List<Integer> fixed = Arrays.asList(1, 2, 3, 4, 5);
Collections.shuffle(fixed);  // UnsupportedOperationException

// ‚úÖ Create ArrayList
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.shuffle(list);
```

3. **Expecting same random sequence**
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// ‚ùå Different results each time
Collections.shuffle(list);  // [3, 1, 5, 2, 4]
Collections.shuffle(list);  // [2, 5, 1, 4, 3] - different!

// ‚úÖ Use seed for reproducibility
Random rand = new Random(42);
Collections.shuffle(list, rand);  // Same result with same seed
```

4. **Not preserving original order**
```java
List<Integer> original = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// ‚ùå Original lost after shuffle
Collections.shuffle(original);

// ‚úÖ Create copy if needed
List<Integer> shuffled = new ArrayList<>(original);
Collections.shuffle(shuffled);
// original is preserved
```

5. **Shuffling while iterating**
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// ‚ùå ConcurrentModificationException
for (Integer num : list) {
    Collections.shuffle(list);  // Don't do this
}
```

---

## üí° Best Practices

1. **Use mutable list**
```java
// ‚úÖ ArrayList for shuffling
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.shuffle(list);
```

2. **Use seed for reproducible results**
```java
// ‚úÖ Reproducible shuffle for testing
Random random = new Random(12345);
Collections.shuffle(list, random);
```

3. **Create copy to preserve original**
```java
// ‚úÖ Keep original intact
List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> shuffled = new ArrayList<>(original);
Collections.shuffle(shuffled);
```

4. **Use SecureRandom for security-sensitive operations**
```java
// ‚úÖ Cryptographic randomness
List<String> tokens = getSecurityTokens();
Collections.shuffle(tokens, new SecureRandom());
```

---

## üÜö Alternatives

### 1. Manual Shuffle
```java
// Fisher-Yates implementation
public static <T> void shuffle(List<T> list) {
    Random rand = new Random();
    for (int i = list.size() - 1; i > 0; i--) {
        int j = rand.nextInt(i + 1);
        T temp = list.get(i);
        list.set(i, list.get(j));
        list.set(j, temp);
    }
}
```

### 2. Stream Shuffle (Creates New List)
```java
List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);

// Shuffle using Stream
List<Integer> shuffled = original.stream()
    .sorted((a, b) -> new Random().nextInt(3) - 1)  // ‚ö†Ô∏è Not truly random
    .collect(Collectors.toList());

// Better: Use Collections.shuffle()
```

### 3. Random Sampling (Without Replacement)
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.shuffle(list);

// Take first n elements for random sample
List<Integer> sample = list.subList(0, 3);  // Random 3 elements
```

---

## üéì When to Use

### ‚úÖ Use Collections.shuffle() When:
- Need random permutation
- Games, quizzes, randomization
- Random sampling
- Testing with varied data order

### ‚ùå Don't Use When:
- Need sorted order
- Working with immutable collections
- Need deterministic behavior (unless using seed)

---

## üìö Interview Questions

**Q1: Time complexity of Collections.shuffle()?**
A: O(n) - single pass through list.

**Q2: What algorithm does it use?**
A: Fisher-Yates shuffle - unbiased randomization.

**Q3: Is it truly random?**
A: Pseudo-random with Random, cryptographically secure with SecureRandom.

**Q4: Can you shuffle immutable list?**
A: No, throws UnsupportedOperationException. Create mutable copy.

**Q5: How to get reproducible shuffle?**
A: Use Random with specific seed: `new Random(seed)`.

**Q6: Does it return new list?**
A: No, shuffles in-place. Original list is modified.

**Q7: Can you shuffle arrays?**
A: No direct method. Convert to List, shuffle, convert back.

**Q8: Why Fisher-Yates is unbiased?**
A: Each element has equal probability (1/n) of being in any position.

---

## üìö Summary

- **Collections.shuffle()**: Randomly permutes list elements
- **Algorithm**: Fisher-Yates shuffle - O(n), unbiased
- **In-place**: Modifies original list
- **Randomness**: Uses Random (pseudo-random) or SecureRandom (cryptographic)
- **Use seed**: For reproducible results in testing
- **Real-world**: Card games, quizzes, random sampling, A/B testing
- **Pitfall**: Cannot shuffle immutable or fixed-size lists
