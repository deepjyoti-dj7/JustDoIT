# ğŸ”„ Reversing

## ğŸ“– Overview

**Collections.reverse()** reverses the order of elements in a list. Operates **in-place** with **O(n/2)** time complexity.

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.reverse(list);
System.out.println(list);  // [5, 4, 3, 2, 1]
```

---

## â­ Key Characteristics

1. **Time complexity** - O(n/2) â‰ˆ O(n)
2. **Space complexity** - O(1) - in-place
3. **In-place** - Modifies original list
4. **Works with** - Any List implementation
5. **Not for arrays** - Use manual loop or convert to List

---

## ğŸ“ Method Signature

```java
// Reverse list in-place
public static void reverse(List<?> list)
```

---

## ğŸ’» Basic Usage

### 1. Reverse Integer List
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.reverse(numbers);
System.out.println(numbers);  // [5, 4, 3, 2, 1]
```

### 2. Reverse String List
```java
List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie"));
Collections.reverse(names);
System.out.println(names);  // [Charlie, Bob, Alice]
```

### 3. Reverse Custom Objects
```java
class Task {
    int priority;
    String name;
}

List<Task> tasks = getTasks();
Collections.reverse(tasks);  // Reverse order
```

### 4. Reverse Sublist
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7));

// Reverse middle portion (indices 2-5)
List<Integer> subList = list.subList(2, 5);
Collections.reverse(subList);

System.out.println(list);  // [1, 2, 5, 4, 3, 6, 7]
```

---

## ğŸ¯ Real-World Examples

### 1. Reverse Chronological Order
```java
class Post {
    LocalDateTime timestamp;
    String content;
}

List<Post> posts = getPosts();  // Oldest first

// Sort by timestamp (ascending)
posts.sort(Comparator.comparing(Post::getTimestamp));

// Reverse for newest first
Collections.reverse(posts);

System.out.println("Latest posts:");
posts.forEach(p -> System.out.println(p.content));
```

---

### 2. Undo History
```java
class Action {
    String type;
    String data;
}

List<Action> history = new ArrayList<>();
history.add(new Action("CREATE", "file.txt"));
history.add(new Action("EDIT", "line 1"));
history.add(new Action("EDIT", "line 2"));

// Reverse to undo in reverse order
Collections.reverse(history);

for (Action action : history) {
    undo(action);  // Undo from most recent to oldest
}
```

---

### 3. Reverse File Lines
```java
List<String> lines = Files.readAllLines(Paths.get("input.txt"));

// Reverse lines
Collections.reverse(lines);

// Write reversed
Files.write(Paths.get("output.txt"), lines);
```

---

### 4. Display Stack (Bottom to Top)
```java
Stack<String> stack = new Stack<>();
stack.push("First");
stack.push("Second");
stack.push("Third");

// Convert to list and reverse to show bottom to top
List<String> list = new ArrayList<>(stack);
Collections.reverse(list);

System.out.println("Stack (bottom to top): " + list);
// [First, Second, Third]
```

---

### 5. Reverse Sort
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9));

// Sort ascending
Collections.sort(numbers);  // [1, 1, 3, 4, 5, 9]

// Reverse to descending
Collections.reverse(numbers);  // [9, 5, 4, 3, 1, 1]

// Alternative: Use Comparator.reverseOrder()
Collections.sort(numbers, Comparator.reverseOrder());
```

---

## ğŸ”§ How It Works

```java
// Internal implementation (simplified)
public static void reverse(List<?> list) {
    int size = list.size();
    
    // Swap elements from both ends toward middle
    for (int i = 0, mid = size >> 1, j = size - 1; i < mid; i++, j--) {
        swap(list, i, j);
    }
}

// Helper to swap elements
private static void swap(List<?> list, int i, int j) {
    final List l = list;
    l.set(i, l.set(j, l.get(i)));
}
```

**Algorithm:**
1. Start with two pointers: start (0) and end (n-1)
2. Swap elements at start and end
3. Move start forward, end backward
4. Repeat until start >= end
5. Time: O(n/2) swaps, Space: O(1)

---

## âš ï¸ Common Pitfalls

1. **Reversing immutable list**
```java
List<Integer> immutable = List.of(1, 2, 3, 4, 5);

// âŒ UnsupportedOperationException
Collections.reverse(immutable);

// âœ… Create mutable copy
List<Integer> mutable = new ArrayList<>(immutable);
Collections.reverse(mutable);
```

2. **Reversing fixed-size list**
```java
// âŒ Arrays.asList() can be modified but is fixed-size
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Collections.reverse(list);  // Works, but list is still fixed-size

// âœ… Create ArrayList for full mutability
List<Integer> arrayList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.reverse(arrayList);
```

3. **Not preserving original**
```java
List<Integer> original = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// âŒ Original is modified
Collections.reverse(original);

// âœ… Create copy if needed
List<Integer> reversed = new ArrayList<>(original);
Collections.reverse(reversed);
```

4. **Reversing array directly**
```java
int[] arr = {1, 2, 3, 4, 5};

// âŒ Cannot use Collections.reverse() on arrays
// Collections.reverse(arr);  // Compile error

// âœ… Convert to List
List<Integer> list = Arrays.stream(arr).boxed().collect(Collectors.toList());
Collections.reverse(list);

// âœ… Or manual loop
for (int i = 0; i < arr.length / 2; i++) {
    int temp = arr[i];
    arr[i] = arr[arr.length - 1 - i];
    arr[arr.length - 1 - i] = temp;
}
```

5. **Reversing while iterating**
```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// âŒ ConcurrentModificationException
for (Integer num : list) {
    Collections.reverse(list);  // Don't do this
}
```

---

## ğŸ’¡ Best Practices

1. **Use mutable list**
```java
// âœ… ArrayList for reversing
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.reverse(list);
```

2. **Create copy to preserve original**
```java
// âœ… Keep original intact
List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> reversed = new ArrayList<>(original);
Collections.reverse(reversed);
```

3. **Use Comparator.reverseOrder() for sorting**
```java
// âŒ Less efficient
Collections.sort(list);
Collections.reverse(list);

// âœ… Sort descending directly
Collections.sort(list, Comparator.reverseOrder());
```

4. **Document intent**
```java
// âœ… Clear comment
// Reverse to show newest posts first
Collections.reverse(posts);
```

---

## ğŸ†š Alternatives

### 1. Manual Reverse Loop
```java
// For arrays
public static void reverse(int[] arr) {
    for (int i = 0; i < arr.length / 2; i++) {
        int temp = arr[i];
        arr[i] = arr[arr.length - 1 - i];
        arr[arr.length - 1 - i] = temp;
    }
}

int[] arr = {1, 2, 3, 4, 5};
reverse(arr);
```

### 2. Stream Reverse (Creates New List)
```java
List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);

// Reverse using Stream (creates new list)
List<Integer> reversed = IntStream.rangeClosed(1, original.size())
    .map(i -> original.get(original.size() - i))
    .boxed()
    .collect(Collectors.toList());
```

### 3. Guava Lists.reverse() (View)
```java
import com.google.common.collect.Lists;

List<Integer> original = Arrays.asList(1, 2, 3, 4, 5);

// Returns reversed view (doesn't modify original)
List<Integer> reversed = Lists.reverse(original);
System.out.println(reversed);  // [5, 4, 3, 2, 1]
System.out.println(original);  // [1, 2, 3, 4, 5] - unchanged
```

### 4. Stack for Reverse Order
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Stack<Integer> stack = new Stack<>();

// Push all elements
list.forEach(stack::push);

// Pop to get reversed order
List<Integer> reversed = new ArrayList<>();
while (!stack.isEmpty()) {
    reversed.add(stack.pop());
}
```

---

## ğŸ“Š Performance Comparison

```java
int size = 1_000_000;
List<Integer> list = new ArrayList<>();
for (int i = 0; i < size; i++) {
    list.add(i);
}

// Collections.reverse() - O(n/2)
List<Integer> copy1 = new ArrayList<>(list);
long start = System.nanoTime();
Collections.reverse(copy1);
long time1 = System.nanoTime() - start;

// Stream reverse - O(n)
List<Integer> copy2 = new ArrayList<>(list);
start = System.nanoTime();
List<Integer> reversed = IntStream.rangeClosed(1, copy2.size())
    .map(i -> copy2.get(copy2.size() - i))
    .boxed()
    .collect(Collectors.toList());
long time2 = System.nanoTime() - start;

System.out.println("Collections.reverse(): " + time1/1_000_000 + " ms");
System.out.println("Stream reverse: " + time2/1_000_000 + " ms");

// Collections.reverse() is 10-20x faster
```

---

## ğŸ“ When to Use

### âœ… Use Collections.reverse() When:
- Need to reverse List in-place
- Simple reversal operation
- Performance matters (O(n/2))
- Working with mutable lists

### âŒ Don't Use When:
- Need to preserve original (create copy first)
- Working with immutable collections
- Can achieve with sorting (use Comparator.reverseOrder())

---

## ğŸ“š Interview Questions

**Q1: Time complexity of Collections.reverse()?**
A: O(n/2) â‰ˆ O(n) - swaps elements from both ends to middle.

**Q2: Space complexity?**
A: O(1) - in-place reversal, no extra space.

**Q3: Does it return a new list?**
A: No, reverses in-place. Original list is modified.

**Q4: Can you reverse arrays?**
A: No direct method. Convert to List or use manual loop.

**Q5: How to preserve original?**
A: Create copy: `new ArrayList<>(original)`, then reverse copy.

**Q6: Reverse while maintaining sort?**
A: Use `Collections.sort(list, Comparator.reverseOrder())` instead.

**Q7: Can you reverse immutable list?**
A: No, throws UnsupportedOperationException. Create mutable copy.

**Q8: Algorithm used?**
A: Two-pointer swap - start and end pointers moving toward middle.

---

## ğŸ“š Summary

- **Collections.reverse()**: Reverses list order in-place
- **Time**: O(n/2) â‰ˆ O(n), **Space**: O(1)
- **In-place**: Modifies original list
- **Algorithm**: Two-pointer swap from both ends
- **Use cases**: Chronological reversal, undo history, reverse sort
- **Pitfall**: Cannot reverse immutable lists or arrays directly
- **Best practice**: Create copy if need to preserve original
