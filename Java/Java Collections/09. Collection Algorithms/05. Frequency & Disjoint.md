# üìä Frequency & Disjoint

## üìñ Overview

Java Collections provides utility methods for counting occurrences and checking set relationships:
- **Collections.frequency()** - Count occurrences of element
- **Collections.disjoint()** - Check if two collections have no common elements

---

## ‚≠ê Collections.frequency()

### Overview
Counts how many times a specified element appears in a collection.

```java
int count = Collections.frequency(Collection<?> c, Object o)
```

### Time Complexity
```java
Time: O(n) - iterates through collection
Space: O(1) - constant space
```

---

## üíª frequency() Usage

### 1. Count in List
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4, 2, 5);

int count = Collections.frequency(numbers, 2);
System.out.println("Count of 2: " + count);  // 3
```

### 2. Count String Occurrences
```java
List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");

int apples = Collections.frequency(words, "apple");
System.out.println("Apple count: " + apples);  // 3
```

### 3. Count Custom Objects
```java
class Status {
    String value;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Status)) return false;
        Status status = (Status) o;
        return value.equals(status.value);
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }
}

List<Status> statuses = getStatuses();
int pendingCount = Collections.frequency(statuses, new Status("PENDING"));
```

### 4. Count Nulls
```java
List<String> list = Arrays.asList("A", null, "B", null, "C", null);

int nullCount = Collections.frequency(list, null);
System.out.println("Null count: " + nullCount);  // 3
```

---

## üéØ frequency() Real-World Examples

### 1. Vote Counting
```java
List<String> votes = Arrays.asList("Alice", "Bob", "Alice", "Charlie", "Alice", "Bob");

int aliceVotes = Collections.frequency(votes, "Alice");
int bobVotes = Collections.frequency(votes, "Bob");
int charlieVotes = Collections.frequency(votes, "Charlie");

System.out.println("Alice: " + aliceVotes);    // 3
System.out.println("Bob: " + bobVotes);        // 2
System.out.println("Charlie: " + charlieVotes); // 1
```

---

### 2. Item Inventory
```java
class Product {
    String id;
    
    // equals() and hashCode() based on id
}

List<Product> cart = getShoppingCart();
Product item = new Product("LAPTOP-001");

int quantity = Collections.frequency(cart, item);
System.out.println("Quantity in cart: " + quantity);
```

---

### 3. Grade Distribution
```java
List<String> grades = Arrays.asList("A", "B", "A", "C", "B", "A", "D", "B", "A");

System.out.println("Grade Distribution:");
System.out.println("A: " + Collections.frequency(grades, "A"));  // 4
System.out.println("B: " + Collections.frequency(grades, "B"));  // 3
System.out.println("C: " + Collections.frequency(grades, "C"));  // 1
System.out.println("D: " + Collections.frequency(grades, "D"));  // 1
```

---

### 4. Word Frequency
```java
String text = "the quick brown fox jumps over the lazy dog the fox";
List<String> words = Arrays.asList(text.split(" "));

Map<String, Integer> frequency = new HashMap<>();
Set<String> uniqueWords = new HashSet<>(words);

for (String word : uniqueWords) {
    frequency.put(word, Collections.frequency(words, word));
}

System.out.println(frequency);
// {the=3, quick=1, brown=1, fox=2, ...}
```

---

## ‚≠ê Collections.disjoint()

### Overview
Returns `true` if two collections have **no elements in common**.

```java
boolean disjoint = Collections.disjoint(Collection<?> c1, Collection<?> c2)
```

### Time Complexity
```java
Time: O(n + m) - iterates through both collections
Space: O(1) - constant space
```

---

## üíª disjoint() Usage

### 1. Check Disjoint Sets
```java
List<Integer> set1 = Arrays.asList(1, 2, 3);
List<Integer> set2 = Arrays.asList(4, 5, 6);
List<Integer> set3 = Arrays.asList(3, 4, 5);

boolean disjoint1 = Collections.disjoint(set1, set2);
System.out.println("set1 and set2 disjoint: " + disjoint1);  // true

boolean disjoint2 = Collections.disjoint(set1, set3);
System.out.println("set1 and set3 disjoint: " + disjoint2);  // false (3 is common)
```

### 2. String Collections
```java
List<String> list1 = Arrays.asList("A", "B", "C");
List<String> list2 = Arrays.asList("D", "E", "F");
List<String> list3 = Arrays.asList("C", "D", "E");

System.out.println(Collections.disjoint(list1, list2));  // true
System.out.println(Collections.disjoint(list1, list3));  // false
```

### 3. Different Collection Types
```java
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3));
List<Integer> list = Arrays.asList(4, 5, 6);

boolean disjoint = Collections.disjoint(set, list);
System.out.println("Disjoint: " + disjoint);  // true
```

### 4. Empty Collections
```java
List<Integer> empty = new ArrayList<>();
List<Integer> list = Arrays.asList(1, 2, 3);

boolean disjoint = Collections.disjoint(empty, list);
System.out.println("Disjoint: " + disjoint);  // true (empty set is disjoint)
```

---

## üéØ disjoint() Real-World Examples

### 1. Check User Permissions
```java
Set<String> userPermissions = new HashSet<>(Arrays.asList("READ", "WRITE"));
Set<String> restrictedPermissions = new HashSet<>(Arrays.asList("DELETE", "ADMIN"));

boolean isValid = Collections.disjoint(userPermissions, restrictedPermissions);
if (isValid) {
    System.out.println("User has no restricted permissions");
}
```

---

### 2. Schedule Conflict Detection
```java
class TimeSlot {
    int start;
    int end;
    
    // equals() and hashCode()
}

List<TimeSlot> meeting1 = Arrays.asList(
    new TimeSlot(9, 10),
    new TimeSlot(11, 12)
);

List<TimeSlot> meeting2 = Arrays.asList(
    new TimeSlot(10, 11),
    new TimeSlot(13, 14)
);

boolean noConflict = Collections.disjoint(meeting1, meeting2);
System.out.println("No conflicts: " + noConflict);  // true
```

---

### 3. Allergen Check
```java
Set<String> productIngredients = new HashSet<>(Arrays.asList("wheat", "milk", "sugar"));
Set<String> userAllergies = new HashSet<>(Arrays.asList("peanuts", "shellfish"));

boolean isSafe = Collections.disjoint(productIngredients, userAllergies);
if (isSafe) {
    System.out.println("Product is safe for user");
}
```

---

### 4. Tag Intersection
```java
Set<String> article1Tags = new HashSet<>(Arrays.asList("java", "programming", "tutorial"));
Set<String> article2Tags = new HashSet<>(Arrays.asList("python", "data-science", "ml"));

boolean noCommonTags = Collections.disjoint(article1Tags, article2Tags);
System.out.println("Articles have different topics: " + noCommonTags);  // true
```

---

### 5. Access Control
```java
Set<String> requiredRoles = new HashSet<>(Arrays.asList("ADMIN", "MANAGER"));
Set<String> userRoles = new HashSet<>(Arrays.asList("USER", "GUEST"));

boolean hasAccess = !Collections.disjoint(requiredRoles, userRoles);
if (!hasAccess) {
    System.out.println("Access denied - insufficient permissions");
}
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **frequency() with incorrect equals()**
```java
class Person {
    String name;
    // ‚ùå No equals() override
}

List<Person> people = Arrays.asList(new Person("Alice"), new Person("Alice"));
int count = Collections.frequency(people, new Person("Alice"));
System.out.println(count);  // 0 - uses object identity, not value!

// ‚úÖ Override equals() and hashCode()
```

2. **disjoint() with null elements**
```java
List<Integer> list1 = Arrays.asList(1, 2, null);
List<Integer> list2 = Arrays.asList(null, 3, 4);

// Works - null is considered an element
boolean disjoint = Collections.disjoint(list1, list2);
System.out.println(disjoint);  // false (both have null)
```

3. **Performance with large collections**
```java
List<Integer> large1 = generateLargeList(1_000_000);
List<Integer> large2 = generateLargeList(1_000_000);

// ‚ùå O(n * m) if not optimized
boolean disjoint = Collections.disjoint(large1, large2);

// ‚úÖ Convert to Set first for better performance
Set<Integer> set1 = new HashSet<>(large1);
boolean disjoint2 = Collections.disjoint(set1, large2);  // O(m)
```

4. **frequency() counting time**
```java
List<Integer> list = Arrays.asList(1, 2, 3, 1, 2, 1);

// ‚ùå Multiple calls - O(n) each time
int count1 = Collections.frequency(list, 1);  // O(n)
int count2 = Collections.frequency(list, 2);  // O(n)
int count3 = Collections.frequency(list, 3);  // O(n)

// ‚úÖ Use Map for multiple frequencies
Map<Integer, Long> freqMap = list.stream()
    .collect(Collectors.groupingBy(e -> e, Collectors.counting()));
```

---

## üí° Best Practices

1. **Override equals() for custom objects**
```java
// ‚úÖ Proper equals() for frequency()
class Item {
    String id;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Item)) return false;
        return id.equals(((Item) o).id);
    }
    
    @Override
    public int hashCode() {
        return id.hashCode();
    }
}
```

2. **Use Set for better disjoint() performance**
```java
// ‚úÖ Convert one collection to Set
List<Integer> list1 = getLargeList();
List<Integer> list2 = getAnotherLargeList();

Set<Integer> set1 = new HashSet<>(list1);
boolean disjoint = Collections.disjoint(set1, list2);  // Faster
```

3. **Build frequency map for multiple counts**
```java
// ‚úÖ Single pass for all frequencies
List<String> items = getItems();
Map<String, Long> frequencies = items.stream()
    .collect(Collectors.groupingBy(e -> e, Collectors.counting()));

// Access any frequency in O(1)
long count = frequencies.getOrDefault("item", 0L);
```

4. **Cache disjoint results if reused**
```java
// ‚úÖ Cache if checking multiple times
Map<String, Boolean> disjointCache = new HashMap<>();
String key = set1.hashCode() + "-" + set2.hashCode();

if (!disjointCache.containsKey(key)) {
    disjointCache.put(key, Collections.disjoint(set1, set2));
}
```

---

## üÜö Alternatives

### frequency() Alternatives
```java
List<Integer> list = Arrays.asList(1, 2, 3, 2, 1, 2);

// 1. Collections.frequency()
int count1 = Collections.frequency(list, 2);

// 2. Stream count
long count2 = list.stream().filter(n -> n == 2).count();

// 3. Manual count
int count3 = 0;
for (int n : list) {
    if (n == 2) count3++;
}

// 4. Frequency map (for multiple counts)
Map<Integer, Long> freqMap = list.stream()
    .collect(Collectors.groupingBy(e -> e, Collectors.counting()));
```

### disjoint() Alternatives
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6));

// 1. Collections.disjoint()
boolean disjoint1 = Collections.disjoint(set1, set2);

// 2. Manual check
boolean disjoint2 = set1.stream().noneMatch(set2::contains);

// 3. Set operations
Set<Integer> intersection = new HashSet<>(set1);
intersection.retainAll(set2);
boolean disjoint3 = intersection.isEmpty();
```

---

## üìö Interview Questions

**Q1: Time complexity of Collections.frequency()?**
A: O(n) - iterates through entire collection once.

**Q2: Time complexity of Collections.disjoint()?**
A: O(n + m) where n and m are sizes of collections.

**Q3: Does frequency() work with null?**
A: Yes, counts null as a valid element.

**Q4: What does disjoint() return for empty collections?**
A: True - empty set is disjoint with any set.

**Q5: Why override equals() for frequency()?**
A: frequency() uses equals() to compare elements. Default equals() uses object identity.

**Q6: How to optimize disjoint() for large collections?**
A: Convert one collection to HashSet first for O(m) instead of O(n*m).

**Q7: Can disjoint() work with different collection types?**
A: Yes, works with any Collection implementations.

**Q8: How to count multiple elements efficiently?**
A: Use Stream groupingBy with counting() instead of multiple frequency() calls.

---

## üìö Summary

### Collections.frequency()
- **Purpose**: Count occurrences of element in collection
- **Time**: O(n)
- **Uses equals()**: Must override for custom objects
- **Real-world**: Vote counting, inventory, grade distribution

### Collections.disjoint()
- **Purpose**: Check if two collections have no common elements
- **Time**: O(n + m)
- **Returns**: true if no overlap, false if any common element
- **Optimization**: Convert to Set for better performance
- **Real-world**: Permission checks, schedule conflicts, allergen detection
