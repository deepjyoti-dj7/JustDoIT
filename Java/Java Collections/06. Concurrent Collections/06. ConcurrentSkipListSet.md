# üóÇÔ∏è ConcurrentSkipListSet

## üìñ Overview

**ConcurrentSkipListSet** is a thread-safe, **sorted** set based on **ConcurrentSkipListMap**. It provides **O(log n)** operations with high concurrency.

```java
public class ConcurrentSkipListSet<E> 
    extends AbstractSet<E> 
    implements NavigableSet<E>, Cloneable, Serializable
```

**Internally:** Backed by `ConcurrentSkipListMap<E, Boolean>` (set = map keys).

---

## ‚≠ê Key Characteristics

1. **Thread-safe** - Lock-free for most operations
2. **Sorted** - Elements maintained in natural or custom order
3. **O(log n) operations** - Average case for add/remove/contains
4. **No null elements** - Throws NullPointerException
5. **NavigableSet** - Rich navigation methods (ceiling, floor, etc.)
6. **Skip List** - Probabilistic data structure
7. **No duplicates** - Set semantics (unique elements)
8. **Weakly consistent iterators** - Don't throw ConcurrentModificationException

---

## üéØ Creating ConcurrentSkipListSet

```java
// 1. Natural ordering
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();

// 2. Custom comparator (reverse order)
ConcurrentSkipListSet<Integer> reverseSet = 
    new ConcurrentSkipListSet<>(Collections.reverseOrder());

// 3. Custom comparator (case-insensitive)
ConcurrentSkipListSet<String> caseInsensitive = 
    new ConcurrentSkipListSet<>(String.CASE_INSENSITIVE_ORDER);

// 4. From collection
List<Integer> list = Arrays.asList(3, 1, 4, 1, 5);
ConcurrentSkipListSet<Integer> set2 = new ConcurrentSkipListSet<>(list);

// 5. From sorted set
SortedSet<Integer> sorted = new TreeSet<>(Arrays.asList(1, 2, 3));
ConcurrentSkipListSet<Integer> set3 = new ConcurrentSkipListSet<>(sorted);
```

---

## üíª Basic Operations

```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();

// Add elements
set.add(3);
set.add(1);
set.add(2);
set.add(1);  // Duplicate - ignored

// Sorted iteration (ascending)
for (Integer num : set) {
    System.out.println(num);
}
// Output: 1, 2, 3

// Contains
boolean has = set.contains(2);  // true

// Remove
set.remove(2);

// Size
int size = set.size();  // 2

// No null elements
// set.add(null);  // NullPointerException

// Clear
set.clear();
```

---

## ‚ö° Performance

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add** | O(log n) | Skip list insertion |
| **remove** | O(log n) | Skip list deletion |
| **contains** | O(log n) | Skip list search |
| **first/last** | O(1) | Head/tail access |
| **ceiling/floor** | O(log n) | Navigation |
| **subSet** | O(log n) | Range view creation |
| **Iteration** | O(n) | Ordered traversal |

---

## üéØ Real-World Examples

### 1. Active User Sessions (Sorted by Login Time)
```java
ConcurrentSkipListSet<Session> activeSessions = 
    new ConcurrentSkipListSet<>(Comparator.comparing(Session::getLoginTime));

// Add session
void login(Session session) {
    activeSessions.add(session);
}

// Remove session
void logout(Session session) {
    activeSessions.remove(session);
}

// Get oldest sessions
List<Session> getOldestSessions(int count) {
    return activeSessions.stream()
                         .limit(count)
                         .collect(Collectors.toList());
}

// Clean expired sessions
void cleanExpired() {
    long cutoff = System.currentTimeMillis() - SESSION_TIMEOUT;
    activeSessions.removeIf(s -> s.getLoginTime() < cutoff);
}
```

---

### 2. Priority Queue of Tasks
```java
ConcurrentSkipListSet<Task> taskQueue = 
    new ConcurrentSkipListSet<>(Comparator.comparing(Task::getPriority).reversed());

// Submit task
void submitTask(Task task) {
    taskQueue.add(task);
}

// Get highest priority task
Task getNextTask() {
    return taskQueue.pollFirst();  // Highest priority
}

// Get all high-priority tasks (priority > 5)
Set<Task> getHighPriorityTasks() {
    return taskQueue.headSet(new Task("", 5), false);
}
```

---

### 3. Real-Time Leaderboard (Unique Players by Score)
```java
ConcurrentSkipListSet<Player> leaderboard = 
    new ConcurrentSkipListSet<>(Comparator.comparing(Player::getScore).reversed());

// Update player score
void updateScore(Player player) {
    leaderboard.remove(player);  // Remove old
    leaderboard.add(player);     // Add with new score
}

// Get top N players
List<Player> getTopPlayers(int n) {
    return leaderboard.stream()
                      .limit(n)
                      .collect(Collectors.toList());
}

// Get player rank
int getRank(Player player) {
    return (int) leaderboard.headSet(player, false).size() + 1;
}
```

---

### 4. Event Timeline (Sorted by Timestamp)
```java
ConcurrentSkipListSet<Event> timeline = 
    new ConcurrentSkipListSet<>(Comparator.comparing(Event::getTimestamp));

// Add event
void addEvent(Event event) {
    timeline.add(event);
}

// Get events in time range
Set<Event> getEventsInRange(long start, long end) {
    Event startEvent = new Event(start, "");
    Event endEvent = new Event(end, "");
    return timeline.subSet(startEvent, true, endEvent, true);
}

// Get most recent events
List<Event> getRecentEvents(int count) {
    return timeline.descendingSet().stream()
                   .limit(count)
                   .collect(Collectors.toList());
}
```

---

### 5. Unique Sorted IDs
```java
ConcurrentSkipListSet<Long> uniqueIds = new ConcurrentSkipListSet<>();

// Generate unique ID
long generateUniqueId() {
    long id;
    do {
        id = System.nanoTime();
    } while (!uniqueIds.add(id));  // Retry if duplicate
    return id;
}

// Get available ID in range
Long getAvailableId(long start, long end) {
    for (long i = start; i <= end; i++) {
        if (uniqueIds.add(i)) {
            return i;
        }
    }
    return null;  // No available ID
}

// Clean IDs older than cutoff
void cleanOldIds(long cutoff) {
    uniqueIds.headSet(cutoff).clear();
}
```

---

## üß≠ NavigableSet Methods

```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.addAll(Arrays.asList(10, 20, 30, 40, 50));

// First and last
Integer first = set.first();  // 10
Integer last = set.last();    // 50

// Ceiling (‚â• element)
Integer ceil = set.ceiling(25);  // 30

// Floor (‚â§ element)
Integer floor = set.floor(25);   // 20

// Higher (> element)
Integer higher = set.higher(30);  // 40

// Lower (< element)
Integer lower = set.lower(30);    // 20

// Poll first/last (remove and return)
Integer pollFirst = set.pollFirst();  // 10 (removed)
Integer pollLast = set.pollLast();    // 50 (removed)

// Remaining: {20, 30, 40}
```

---

## üìä Range Views

```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

// SubSet [3, 7]
NavigableSet<Integer> subSet = set.subSet(3, true, 7, true);
// {3, 4, 5, 6, 7}

// HeadSet (< 5)
NavigableSet<Integer> headSet = set.headSet(5, false);
// {1, 2, 3, 4}

// TailSet (‚â• 5)
NavigableSet<Integer> tailSet = set.tailSet(5, true);
// {5, 6, 7, 8, 9, 10}

// Descending view
NavigableSet<Integer> descending = set.descendingSet();
// {10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
```

---

## üÜö ConcurrentSkipListSet vs TreeSet

| Feature | ConcurrentSkipListSet | TreeSet |
|---------|----------------------|---------|
| **Thread-safe** | ‚úÖ Yes | ‚ùå No |
| **Locking** | Lock-free | Must synchronize |
| **Structure** | Skip List | Red-Black Tree |
| **Performance** | O(log n) | O(log n) |
| **Concurrency** | High | Low (external sync) |
| **Memory** | Higher | Lower |
| **Null elements** | ‚ùå No | ‚ùå No |

---

## üÜö ConcurrentSkipListSet vs ConcurrentHashMap.newKeySet()

| Feature | ConcurrentSkipListSet | ConcurrentHashMap.newKeySet() |
|---------|----------------------|------------------------------|
| **Sorted** | ‚úÖ Yes | ‚ùå No |
| **Performance** | O(log n) | O(1) |
| **Navigation** | ‚úÖ Yes | ‚ùå No |
| **Memory** | Higher | Lower |
| **Use Case** | Need sorting | Just unique values |

---

## ‚ö†Ô∏è Common Pitfalls

1. **No null elements**
```java
// ‚ùå NullPointerException
set.add(null);

// ‚úÖ Use Optional if needed
Set<Optional<String>> set = new ConcurrentSkipListSet<>();
set.add(Optional.empty());
```

2. **Comparator consistency**
```java
// Elements must be comparable
class Person implements Comparable<Person> {
    String name;
    
    // ‚úÖ Must implement compareTo
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}
```

3. **Weakly consistent iterators**
```java
// Iterator may not reflect concurrent changes
for (Integer num : set) {
    // May not see elements added during iteration
}
```

4. **Range views are live**
```java
NavigableSet<Integer> subSet = set.subSet(1, 5);
subSet.clear();  // ‚úÖ Also clears from original set!
```

---

## üí° Best Practices

1. **Use for sorted concurrent sets**
```java
// ‚úÖ Need both sorting and concurrency
ConcurrentSkipListSet<Event> events = new ConcurrentSkipListSet<>();
```

2. **Leverage navigation methods**
```java
// ‚úÖ Efficient range queries
Set<Event> recent = set.tailSet(startEvent).stream()
                       .limit(100)
                       .collect(Collectors.toSet());
```

3. **Clean old data with range views**
```java
// ‚úÖ Efficient cleanup
set.headSet(cutoffTime).clear();
```

4. **Use pollFirst/pollLast for atomic removal**
```java
// ‚úÖ Atomic get and remove
Integer min = set.pollFirst();
```

---

## üéì When to Use ConcurrentSkipListSet

### ‚úÖ Use When:
- Need sorted, thread-safe set
- High-concurrency scenarios
- Navigation methods needed (ceiling, floor)
- Range queries required
- Unique sorted elements

### ‚ùå Don't Use When:
- Don't need sorting (use ConcurrentHashMap.newKeySet())
- Single-threaded (use TreeSet)
- Need O(1) operations (use ConcurrentHashMap.newKeySet())

---

## üìö Interview Questions

**Q1: What's ConcurrentSkipListSet backed by?**
A: ConcurrentSkipListMap<E, Boolean> internally.

**Q2: Time complexity of add/remove/contains?**
A: O(log n) average case (skip list).

**Q3: Can it have null elements?**
A: No, throws NullPointerException.

**Q4: ConcurrentSkipListSet vs TreeSet?**
A: SkipListSet is thread-safe with better concurrency; TreeSet needs external sync.

**Q5: ConcurrentSkipListSet vs ConcurrentHashMap.newKeySet()?**
A: SkipListSet is sorted (O(log n)); newKeySet() is unsorted (O(1)).

**Q6: Is it thread-safe?**
A: Yes, uses lock-free skip list operations.

**Q7: Are duplicates allowed?**
A: No, it's a Set (unique elements only).

**Q8: Can multiple threads iterate simultaneously?**
A: Yes, iterators are weakly consistent and don't block.

---

## üìö Summary

- **ConcurrentSkipListSet**: Thread-safe sorted set using skip list
- **O(log n) operations**: add, remove, contains
- **No null elements**: Throws NullPointerException
- **NavigableSet**: ceiling, floor, higher, lower, subSet
- **Backed by**: ConcurrentSkipListMap internally
- **Use for**: Sorted concurrent sets, unique sorted elements, navigation
- **Alternative**: ConcurrentHashMap.newKeySet() if sorting not needed
