# üîó ConcurrentLinkedQueue

## üìñ Overview

**ConcurrentLinkedQueue** is a thread-safe, unbounded, **lock-free** queue based on linked nodes. It uses **CAS (Compare-And-Swap)** operations for thread-safety without locks, making it highly efficient for concurrent scenarios.

```java
public class ConcurrentLinkedQueue<E> 
    extends AbstractQueue<E> 
    implements Queue<E>, Serializable
```

---

## ‚≠ê Key Characteristics

1. **Lock-free** - Uses CAS instead of locks (non-blocking)
2. **Thread-safe** - Safe for concurrent access
3. **Unbounded** - No capacity limit (limited by memory)
4. **FIFO** - First-In-First-Out order
5. **No null elements** - Throws NullPointerException
6. **Non-blocking** - poll() returns null if empty (doesn't block)
7. **Weakly consistent iterators** - May not reflect concurrent changes
8. **O(1) operations** - Amortized constant time for add/poll

---

## üéØ Creating ConcurrentLinkedQueue

```java
// 1. Empty queue
ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();

// 2. From collection
List<String> list = Arrays.asList("A", "B", "C");
ConcurrentLinkedQueue<String> queue2 = new ConcurrentLinkedQueue<>(list);
```

---

## üíª Basic Operations

```java
ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();

// Add elements (always succeeds for unbounded queue)
queue.add("A");      // Throws exception on failure
queue.offer("B");    // Returns false on failure (never for unbounded)

// Peek (doesn't remove)
String head = queue.peek();  // "A" or null if empty

// Remove and retrieve
String item = queue.poll();  // "A" or null if empty
// String item2 = queue.remove();  // Throws NoSuchElementException if empty

// Check empty
boolean empty = queue.isEmpty();

// Size (O(n) - iterates all nodes!)
int size = queue.size();  // Expensive!

// Contains (O(n))
boolean has = queue.contains("B");

// Clear
queue.clear();
```

**Note:** `size()` is **O(n)** - avoid in performance-critical code!

---

## ‚ö° Performance

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **offer** | O(1) amortized | Lock-free CAS |
| **poll** | O(1) amortized | Lock-free CAS |
| **peek** | O(1) | Read head |
| **size** | O(n) | ‚ö†Ô∏è Iterates all! |
| **contains** | O(n) | Linear search |
| **remove(obj)** | O(n) | Linear search |
| **Iterator** | O(n) | Weakly consistent |

---

## üèóÔ∏è Internal Structure

```java
private static class Node<E> {
    volatile E item;
    volatile Node<E> next;
    
    Node(E item) {
        UNSAFE.putObject(this, itemOffset, item);
    }
}

private transient volatile Node<E> head;
private transient volatile Node<E> tail;
```

### Visual Representation
```
head ‚Üí [A | next] ‚Üí [B | next] ‚Üí [C | null] ‚Üê tail
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           CAS updates (lock-free)
```

### CAS Operations
```java
// Atomic update using CAS
boolean casNext(Node<E> cmp, Node<E> val) {
    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
}

boolean casItem(E cmp, E val) {
    return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
}
```

---

## üéØ Real-World Examples

### 1. Producer-Consumer Pattern
```java
ConcurrentLinkedQueue<Task> taskQueue = new ConcurrentLinkedQueue<>();

// Producer threads
class Producer implements Runnable {
    public void run() {
        for (int i = 0; i < 100; i++) {
            Task task = new Task("Task-" + i);
            taskQueue.offer(task);
            System.out.println("Produced: " + task);
        }
    }
}

// Consumer threads
class Consumer implements Runnable {
    public void run() {
        while (true) {
            Task task = taskQueue.poll();
            if (task != null) {
                System.out.println("Consumed: " + task);
                task.process();
            } else {
                // Queue empty, wait a bit
                Thread.sleep(10);
            }
        }
    }
}

// Start threads
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(new Producer());
executor.submit(new Producer());
executor.submit(new Consumer());
executor.submit(new Consumer());
```

---

### 2. Event Logging System
```java
ConcurrentLinkedQueue<LogEvent> logQueue = new ConcurrentLinkedQueue<>();

// Multiple threads log events
void logEvent(String message, Level level) {
    LogEvent event = new LogEvent(System.currentTimeMillis(), level, message);
    logQueue.offer(event);
}

// Single logger thread processes
class LogWriter implements Runnable {
    public void run() {
        while (true) {
            LogEvent event = logQueue.poll();
            if (event != null) {
                writeToFile(event);  // Write to log file
            }
        }
    }
}
```

---

### 3. Request Queue for Web Server
```java
ConcurrentLinkedQueue<HttpRequest> requestQueue = new ConcurrentLinkedQueue<>();

// Request handler adds to queue
void handleIncomingRequest(HttpRequest request) {
    requestQueue.offer(request);
}

// Worker threads process
class RequestProcessor implements Runnable {
    public void run() {
        while (true) {
            HttpRequest request = requestQueue.poll();
            if (request != null) {
                processRequest(request);
            }
        }
    }
}

// Start worker pool
ExecutorService workers = Executors.newFixedThreadPool(10);
for (int i = 0; i < 10; i++) {
    workers.submit(new RequestProcessor());
}
```

---

### 4. Message Bus
```java
ConcurrentLinkedQueue<Message> messageBus = new ConcurrentLinkedQueue<>();

// Publishers
void publishMessage(String topic, String content) {
    Message msg = new Message(topic, content, System.currentTimeMillis());
    messageBus.offer(msg);
}

// Subscribers
class Subscriber implements Runnable {
    private String interestedTopic;
    
    public void run() {
        while (true) {
            Message msg = messageBus.poll();
            if (msg != null && msg.getTopic().equals(interestedTopic)) {
                handleMessage(msg);
            }
        }
    }
}
```

---

### 5. Job Scheduler
```java
ConcurrentLinkedQueue<Job> jobQueue = new ConcurrentLinkedQueue<>();

// Submit jobs from multiple threads
void submitJob(Job job) {
    jobQueue.offer(job);
    System.out.println("Job submitted: " + job.getId());
}

// Scheduler picks jobs
class JobScheduler implements Runnable {
    public void run() {
        while (true) {
            Job job = jobQueue.poll();
            if (job != null) {
                if (job.isReady()) {
                    executeJob(job);
                } else {
                    // Put back if not ready
                    jobQueue.offer(job);
                }
            }
        }
    }
}
```

---

## üÜö ConcurrentLinkedQueue vs Other Queues

| Feature | ConcurrentLinkedQueue | LinkedBlockingQueue | ArrayBlockingQueue |
|---------|----------------------|---------------------|-------------------|
| **Blocking** | No (poll returns null) | Yes (take blocks) | Yes (take blocks) |
| **Capacity** | Unbounded | Unbounded/Bounded | Bounded |
| **Locking** | Lock-free (CAS) | ReentrantLock | ReentrantLock |
| **Performance** | Highest | Medium | Medium |
| **size()** | O(n) | O(1) | O(1) |
| **Memory** | Dynamic | Dynamic | Fixed array |
| **Use Case** | High throughput | Producer-consumer | Bounded buffer |

---

## ‚ö†Ô∏è Common Pitfalls

1. **size() is expensive**
```java
// ‚ùå Avoid in loops or hot paths
while (!queue.isEmpty()) {  // O(1) - OK
    int size = queue.size();  // O(n) - Expensive!
}

// ‚úÖ Use isEmpty() or just poll
while (true) {
    Item item = queue.poll();
    if (item == null) break;
    process(item);
}
```

2. **No null elements**
```java
// ‚ùå Will throw NullPointerException
queue.offer(null);

// ‚úÖ Use Optional or special marker
queue.offer(Optional.of(value));
```

3. **Iterators are weakly consistent**
```java
// Iterator may not see concurrent additions
for (String item : queue) {
    // May not see items added during iteration
}
```

4. **poll() doesn't block**
```java
// ‚ùå Busy waiting
while (true) {
    Item item = queue.poll();
    if (item == null) continue;  // Wastes CPU!
    process(item);
}

// ‚úÖ Add sleep or use BlockingQueue
while (true) {
    Item item = queue.poll();
    if (item == null) {
        Thread.sleep(10);  // Avoid busy wait
        continue;
    }
    process(item);
}
```

---

## üí° Best Practices

1. **Avoid size()** - Use isEmpty() or just try poll()
```java
// ‚úÖ Don't check size
Item item = queue.poll();
if (item != null) {
    process(item);
}
```

2. **Use for high-throughput scenarios**
```java
// ‚úÖ Lock-free is fastest
ConcurrentLinkedQueue<Event> events = new ConcurrentLinkedQueue<>();
```

3. **Consider BlockingQueue for blocking**
```java
// If you need blocking, use BlockingQueue
BlockingQueue<Task> tasks = new LinkedBlockingQueue<>();
Task task = tasks.take();  // Blocks until available
```

4. **Batch processing**
```java
// Process multiple items at once
List<Item> batch = new ArrayList<>();
Item item;
while ((item = queue.poll()) != null && batch.size() < 100) {
    batch.add(item);
}
processBatch(batch);
```

---

## üéì When to Use ConcurrentLinkedQueue

### ‚úÖ Use When:
- Need lock-free, non-blocking queue
- High-throughput concurrent access
- Unbounded queue is acceptable
- Don't need blocking operations
- Multiple producers and consumers

### ‚ùå Don't Use When:
- Need blocking operations (use BlockingQueue)
- Need bounded capacity (use ArrayBlockingQueue)
- Need O(1) size() (use LinkedBlockingQueue)
- Single-threaded (use LinkedList or ArrayDeque)

---

## üìö Interview Questions

**Q1: Is ConcurrentLinkedQueue thread-safe?**
A: Yes, it uses lock-free CAS operations for thread-safety.

**Q2: Does poll() block?**
A: No, it returns null if empty (non-blocking).

**Q3: What's the time complexity of size()?**
A: O(n) - it iterates through all nodes (expensive!).

**Q4: Can it contain null elements?**
A: No, throws NullPointerException.

**Q5: How does it achieve lock-free operation?**
A: Uses CAS (Compare-And-Swap) atomic operations on volatile fields.

**Q6: Is it bounded or unbounded?**
A: Unbounded (limited only by memory).

**Q7: ConcurrentLinkedQueue vs LinkedBlockingQueue?**
A: CLQ is lock-free and non-blocking; LBQ uses locks and can block.

**Q8: Are iterators fail-fast?**
A: No, they're weakly consistent (don't throw ConcurrentModificationException).

---

## üìö Summary

- **ConcurrentLinkedQueue**: Lock-free, thread-safe, unbounded FIFO queue
- **Lock-free**: Uses CAS operations (no locks, non-blocking)
- **Non-blocking**: poll() returns null if empty (doesn't block)
- **O(n) size()**: Avoid in performance-critical code
- **No null elements**: Throws NullPointerException
- **Weakly consistent iterators**: May not reflect concurrent changes
- **Use for**: High-throughput concurrent scenarios without blocking needs
