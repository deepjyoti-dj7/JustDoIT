# ğŸ” ConcurrentHashMap Internals

## ğŸ“– Overview

Deep dive into **ConcurrentHashMap** internal structure and algorithms. The implementation changed significantly between **Java 7** (segments) and **Java 8+** (synchronized nodes + CAS).

---

## ğŸ—ï¸ Architecture Evolution

### Java 7: Segment-Based Locking
```
ConcurrentHashMap
â”œâ”€â”€ Segment 0 (ReentrantLock)
â”‚   â”œâ”€â”€ Bucket 0 â†’ Entry â†’ Entry â†’ ...
â”‚   â”œâ”€â”€ Bucket 1 â†’ Entry
â”‚   â””â”€â”€ ...
â”œâ”€â”€ Segment 1 (ReentrantLock)
â”‚   â”œâ”€â”€ Bucket 0 â†’ Entry â†’ Entry
â”‚   â””â”€â”€ ...
â””â”€â”€ Segment N (ReentrantLock)
    â””â”€â”€ ...
```

### Java 8+: Node Array + CAS
```
ConcurrentHashMap
â”œâ”€â”€ Node[] table
â”‚   â”œâ”€â”€ Bucket 0 â†’ Node â†’ Node â†’ ...
â”‚   â”œâ”€â”€ Bucket 1 â†’ TreeNode (Red-Black Tree)
â”‚   â”œâ”€â”€ Bucket 2 â†’ null
â”‚   â””â”€â”€ ...
â”œâ”€â”€ CAS operations for lock-free updates
â””â”€â”€ Synchronized blocks for collisions
```

---

## ğŸ¯ Java 7 Implementation (Legacy)

### 1. Segment Structure
```java
// ConcurrentHashMap divided into segments
Segment<K,V>[] segments;  // Default: 16 segments

class Segment<K,V> extends ReentrantLock {
    transient volatile HashEntry<K,V>[] table;
    transient int count;
    transient int threshold;
    
    // Each segment has its own lock
}

class HashEntry<K,V> {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry<K,V> next;
}
```

### 2. Lock Striping
```
Concurrency Level = 16 (default)
â”œâ”€â”€ Thread 1: Locks Segment 5
â”œâ”€â”€ Thread 2: Locks Segment 12  â† Can proceed (different segment)
â””â”€â”€ Thread 3: Locks Segment 5   â† Must wait (same segment)

Key â†’ hash â†’ segment index (hash >>> 28)
```

### 3. Operations (Java 7)

**Put Operation:**
```java
// 1. Calculate segment
int hash = hash(key);
int segmentIndex = (hash >>> 28) & (segments.length - 1);
Segment<K,V> segment = segments[segmentIndex];

// 2. Lock segment
segment.lock();
try {
    // 3. Find bucket in segment
    int bucketIndex = hash & (segment.table.length - 1);
    HashEntry<K,V> first = segment.table[bucketIndex];
    
    // 4. Insert or update
    // ... (similar to HashMap)
} finally {
    segment.unlock();
}
```

**Get Operation (Lock-Free):**
```java
// No locking needed (volatile reads)
V get(Object key) {
    int hash = hash(key);
    Segment<K,V> segment = segments[(hash >>> 28) & (segments.length - 1)];
    HashEntry<K,V> e = segment.table[hash & (segment.table.length - 1)];
    
    while (e != null) {
        if (e.hash == hash && key.equals(e.key))
            return e.value;  // Volatile read
        e = e.next;
    }
    return null;
}
```

---

## ğŸš€ Java 8+ Implementation (Modern)

### 1. Node Structure
```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;        // Volatile for visibility
    volatile Node<K,V> next;
}

// For tree buckets (8+ collisions)
static final class TreeNode<K,V> extends Node<K,V> {
    TreeNode<K,V> parent;
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;
    boolean red;
}
```

### 2. Table and State
```java
transient volatile Node<K,V>[] table;     // Bucket array
private transient volatile int sizeCtl;   // Control for resize
private transient volatile long baseCount; // Size counter

// Special node types
static final int MOVED     = -1;  // ForwardingNode (during resize)
static final int TREEBIN   = -2;  // TreeBin root
static final int RESERVED  = -3;  // ReservationNode
```

### 3. CAS Operations
```java
// Compare-And-Swap for atomic updates
static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, 
                                    Node<K,V> c, Node<K,V> v) {
    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
}

// Volatile get
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
}

// Volatile set
static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {
    U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);
}
```

---

## ğŸ’» Put Operation (Java 8+)

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    
    int hash = spread(key.hashCode());  // Spread bits
    int binCount = 0;
    
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        
        // 1. Initialize table if needed
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
            
        // 2. Empty bucket - CAS insert (lock-free)
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;  // Success!
        }
        
        // 3. Forwarding node (resize in progress) - help resize
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
            
        // 4. Collision - synchronized block
        else {
            V oldVal = null;
            synchronized (f) {  // Lock first node in bucket
                if (tabAt(tab, i) == f) {  // Recheck
                    if (fh >= 0) {  // Linked list
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash && ((ek = e.key) == key || key.equals(ek))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    }
                    else if (f instanceof TreeBin) {  // Red-Black Tree
                        binCount = 2;
                        TreeBin<K,V> t = (TreeBin<K,V>)f;
                        TreeNode<K,V> r, p;
                        if ((r = t.root) != null && 
                            (p = r.findTreeNode(hash, key, null)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                        else {
                            t.putTreeVal(hash, key, value);
                        }
                    }
                }
            }
            
            // 5. Treeify if needed (8+ nodes)
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    
    // 6. Update size
    addCount(1L, binCount);
    return null;
}
```

---

## ğŸ” Get Operation (Java 8+)

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        
        // 1. Check first node
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        
        // 2. Tree or forwarding node
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        
        // 3. Traverse linked list
        while ((e = e.next) != null) {
            if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

**Lock-Free:** No synchronization needed - relies on volatile reads!

---

## ğŸ”„ Resize Operation

```java
private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
    int n = tab.length, stride;
    
    // 1. Divide work among threads
    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE;
    
    // 2. Process each bucket
    for (int i = 0, bound = 0;;) {
        Node<K,V> f; int fh;
        
        // Claim next bucket
        while (advance) { ... }
        
        if ((f = tabAt(tab, i)) == null)
            // Empty bucket - place ForwardingNode
            casTabAt(tab, i, null, new ForwardingNode<K,V>(nextTab));
        else {
            synchronized (f) {
                // Move nodes to new table
                // Low nodes stay at index i
                // High nodes move to index i + n
            }
        }
    }
}
```

**Multiple threads** can help with resizing!

---

## ğŸ“Š Size Counting

```java
// LongAdder-like approach for concurrent counting
private transient volatile long baseCount;
private transient volatile CounterCell[] counterCells;

static final class CounterCell {
    volatile long value;
}

// Add to count
private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    
    // Try base count first
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        
        // Contention - use counter cells
        // Each thread updates different cell
        // Sum all cells for total count
    }
}

// Get size
public int size() {
    long n = sumCount();  // Sum base + all cells
    return ((n < 0L) ? 0 : (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);
}
```

---

## ğŸ†š Java 7 vs Java 8+

| Feature | Java 7 | Java 8+ |
|---------|--------|---------|
| **Structure** | Segments | Node array |
| **Locking** | Segment locks | Synchronized nodes + CAS |
| **Concurrency** | Limited by segments | Better (per-bucket) |
| **Read** | Lock-free | Lock-free |
| **Write** | Lock segment | CAS or sync first node |
| **Resize** | Per segment | Parallel transfer |
| **Size** | Sum segments | LongAdder approach |
| **Collision** | Linked list | List â†’ Tree (8+) |
| **Memory** | Higher | Lower |

---

## âš¡ Performance Optimizations

### 1. Spread Function
```java
static final int spread(int h) {
    return (h ^ (h >>> 16)) & HASH_BITS;
}
```
- Better bit distribution
- Prevents hash clustering

### 2. CAS for Empty Buckets
```java
// No lock needed for empty bucket
if (casTabAt(tab, i, null, newNode))
    break;  // Lock-free insert!
```

### 3. Helping Resize
```java
// Threads encountering ForwardingNode help resize
else if (fh == MOVED)
    tab = helpTransfer(tab, f);
```

### 4. TreeBin for Collisions
```java
// When 8+ nodes in bucket â†’ Red-Black Tree
if (binCount >= TREEIFY_THRESHOLD)
    treeifyBin(tab, i);  // O(n) â†’ O(log n)
```

### 5. LongAdder for Size
```java
// Reduce contention on size counter
// Each thread updates different CounterCell
```

---

## ğŸ“ Key Takeaways

1. **Java 7**: Segment-based locking (16 segments default)
2. **Java 8+**: CAS + synchronized nodes (finer granularity)
3. **Lock-free reads**: Volatile reads ensure visibility
4. **CAS for empty buckets**: No lock needed
5. **Synchronized for collisions**: Lock only first node
6. **Parallel resize**: Multiple threads help transfer
7. **TreeBin for collisions**: O(log n) worst case
8. **LongAdder for size**: Reduce contention

---

## ğŸ’¡ Why Java 8+ is Better

1. **Finer-grained locking** - Lock per bucket (not segment)
2. **Better scalability** - Not limited to 16 segments
3. **Lower memory** - No segment overhead
4. **Parallel resize** - Faster table growth
5. **Tree for collisions** - Better worst case (O(log n))
6. **Simpler code** - Easier to understand and maintain

---

## ğŸ“š Interview Questions

**Q1: How does ConcurrentHashMap achieve thread-safety?**
A: Java 8+ uses CAS for empty buckets and synchronized blocks on first node for collisions.

**Q2: Why no locks for reads?**
A: All fields are volatile, ensuring visibility without locks.

**Q3: What's lock striping?**
A: Java 7 divided map into segments, each with its own lock (16 by default).

**Q4: How does Java 8+ improve over Java 7?**
A: Finer-grained locking (per bucket vs per segment), parallel resize, tree for collisions.

**Q5: Why is size() approximate?**
A: During concurrent modifications, summing counters may not reflect exact count.

**Q6: What's CAS?**
A: Compare-And-Swap - atomic operation to update value if it matches expected.

**Q7: When does bucket become a tree?**
A: When 8+ nodes collide in same bucket (like HashMap).

**Q8: Can multiple threads help resize?**
A: Yes, threads encountering ForwardingNode help transfer nodes to new table.

---

## ğŸ“š Summary

- **Java 7**: Segment-based locking (16 segments)
- **Java 8+**: CAS + synchronized nodes (better concurrency)
- **Lock-free reads**: Volatile reads ensure visibility
- **CAS for empty buckets**: No lock needed for new keys
- **Synchronized for collisions**: Lock only first node
- **Parallel resize**: Multiple threads help transfer
- **Tree for collisions**: O(log n) worst case (8+ nodes)
- **LongAdder for size**: Reduce contention on counter
