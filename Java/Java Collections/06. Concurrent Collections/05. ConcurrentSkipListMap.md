# ğŸ—ºï¸ ConcurrentSkipListMap

## ğŸ“– Overview

**ConcurrentSkipListMap** is a thread-safe, **sorted** map based on **Skip List** data structure. It provides **O(log n)** operations with better concurrency than synchronized TreeMap.

```java
public class ConcurrentSkipListMap<K,V> 
    extends AbstractMap<K,V> 
    implements ConcurrentNavigableMap<K,V>, Serializable
```

---

## â­ Key Characteristics

1. **Thread-safe** - Lock-free for most operations
2. **Sorted** - Keys maintained in natural or custom order
3. **O(log n) operations** - Average case for get/put/remove
4. **No null keys** - Throws NullPointerException
5. **Null values allowed** - Can store null values
6. **NavigableMap** - Rich navigation methods (ceiling, floor, etc.)
7. **Skip List** - Probabilistic data structure (faster than balanced trees)
8. **Weakly consistent iterators** - Don't throw ConcurrentModificationException

---

## ğŸ¯ Creating ConcurrentSkipListMap

```java
// 1. Natural ordering
ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();

// 2. Custom comparator (reverse order)
ConcurrentSkipListMap<Integer, String> reverseMap = 
    new ConcurrentSkipListMap<>(Collections.reverseOrder());

// 3. Custom comparator (case-insensitive)
ConcurrentSkipListMap<String, Integer> caseInsensitive = 
    new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);

// 4. From another map
Map<Integer, String> existing = new HashMap<>();
ConcurrentSkipListMap<Integer, String> map2 = new ConcurrentSkipListMap<>(existing);

// 5. From sorted map
SortedMap<Integer, String> sorted = new TreeMap<>();
ConcurrentSkipListMap<Integer, String> map3 = new ConcurrentSkipListMap<>(sorted);
```

---

## ğŸ’» Basic Operations

```java
ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();

// Put
map.put(3, "Three");
map.put(1, "One");
map.put(2, "Two");

// Get
String value = map.get(2);  // "Two"

// Sorted iteration (ascending)
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
// Output: 1=One, 2=Two, 3=Three

// No null keys
// map.put(null, "Null");  // NullPointerException

// Null values allowed
map.put(4, null);  // OK

// Remove
map.remove(2);

// Size
int size = map.size();
```

---

## âš¡ Performance

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **get** | O(log n) | Skip list traversal |
| **put** | O(log n) | Skip list insertion |
| **remove** | O(log n) | Skip list deletion |
| **containsKey** | O(log n) | Skip list search |
| **firstKey/lastKey** | O(1) | Head/tail access |
| **ceilingKey/floorKey** | O(log n) | Navigation |
| **subMap** | O(log n) | Range view creation |

**Better concurrency than TreeMap** - Multiple threads can operate simultaneously.

---

## ğŸ—ï¸ Skip List Structure

### What is a Skip List?
A probabilistic data structure with multiple levels of linked lists.

```
Level 3:  HEAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 40 â”€â”€â†’ NULL
                                             â†“
Level 2:  HEAD â”€â”€â”€â”€â”€â”€â”€â”€â†’ 20 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ 40 â”€â”€â†’ NULL
                         â†“                   â†“
Level 1:  HEAD â”€â”€â†’ 10 â”€â”€â†’ 20 â”€â”€â†’ 30 â”€â”€â”€â”€â”€â”€â†’ 40 â”€â”€â†’ NULL
               â†“      â†“      â†“      â†“        â†“
Level 0:  HEAD â†’ 10 â†’ 20 â†’ 30 â†’ 35 â†’ 40 â†’ 50 â†’ NULL
         (Base level with all elements)

Search for 35:
1. Start at top level (Level 3)
2. Move right while next < 35
3. Drop down when next > 35
4. Continue until found
```

### Why Skip List?
- **Simpler** than balanced trees (Red-Black, AVL)
- **Lock-free** operations possible
- **Better concurrency** - Less contention
- **Predictable** performance (probabilistic O(log n))

---

## ğŸ¯ Real-World Examples

### 1. Leaderboard System
```java
ConcurrentSkipListMap<Integer, String> leaderboard = 
    new ConcurrentSkipListMap<>(Collections.reverseOrder());

// Update scores (thread-safe)
void updateScore(String player, int score) {
    leaderboard.put(score, player);
}

// Get top 10
List<String> getTop10() {
    return leaderboard.values().stream()
                      .limit(10)
                      .collect(Collectors.toList());
}

// Get rank by score
int getRank(int score) {
    return (int) leaderboard.tailMap(score).size();
}
```

---

### 2. Time-Series Data Store
```java
ConcurrentSkipListMap<Long, SensorReading> timeSeries = new ConcurrentSkipListMap<>();

// Store reading
void storeReading(SensorReading reading) {
    timeSeries.put(reading.getTimestamp(), reading);
}

// Get readings in time range
List<SensorReading> getReadings(long startTime, long endTime) {
    return new ArrayList<>(timeSeries.subMap(startTime, true, endTime, true).values());
}

// Get latest reading
SensorReading getLatest() {
    return timeSeries.isEmpty() ? null : timeSeries.lastEntry().getValue();
}

// Clean old data
void cleanOldData(long cutoffTime) {
    timeSeries.headMap(cutoffTime).clear();
}
```

---

### 3. Priority-Based Task Scheduler
```java
ConcurrentSkipListMap<Integer, Queue<Task>> tasksByPriority = new ConcurrentSkipListMap<>();

// Submit task
void submitTask(Task task) {
    tasksByPriority.computeIfAbsent(task.getPriority(), k -> new ConcurrentLinkedQueue<>())
                   .offer(task);
}

// Get next task (highest priority)
Task getNextTask() {
    for (Queue<Task> queue : tasksByPriority.descendingMap().values()) {
        Task task = queue.poll();
        if (task != null) return task;
    }
    return null;
}
```

---

### 4. Distributed Rate Limiter
```java
ConcurrentSkipListMap<Long, Integer> requestCounts = new ConcurrentSkipListMap<>();

// Record request
boolean allowRequest(String userId) {
    long now = System.currentTimeMillis();
    long windowStart = now - 60000;  // 1-minute window
    
    // Clean old entries
    requestCounts.headMap(windowStart).clear();
    
    // Count requests in window
    int count = requestCounts.tailMap(windowStart).values().stream()
                             .mapToInt(Integer::intValue).sum();
    
    if (count < MAX_REQUESTS) {
        requestCounts.put(now, 1);
        return true;  // Allow
    }
    return false;  // Deny
}
```

---

### 5. Version Control System
```java
ConcurrentSkipListMap<Integer, FileVersion> versions = new ConcurrentSkipListMap<>();

// Commit version
void commit(FileVersion version) {
    versions.put(version.getVersionNumber(), version);
}

// Get specific version
FileVersion getVersion(int versionNumber) {
    return versions.get(versionNumber);
}

// Get versions in range
List<FileVersion> getVersionRange(int start, int end) {
    return new ArrayList<>(versions.subMap(start, true, end, true).values());
}

// Get latest version
FileVersion getLatest() {
    return versions.isEmpty() ? null : versions.lastEntry().getValue();
}

// Rollback to version
void rollback(int versionNumber) {
    versions.tailMap(versionNumber + 1).clear();
}
```

---

## ğŸ§­ NavigableMap Methods

```java
ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();
map.put(10, "Ten");
map.put(20, "Twenty");
map.put(30, "Thirty");
map.put(40, "Forty");

// First and last
Integer first = map.firstKey();    // 10
Integer last = map.lastKey();      // 40

// Ceiling (â‰¥ key)
Integer ceil = map.ceilingKey(25);  // 30

// Floor (â‰¤ key)
Integer floor = map.floorKey(25);   // 20

// Higher (> key)
Integer higher = map.higherKey(20); // 30

// Lower (< key)
Integer lower = map.lowerKey(20);   // 10

// Poll first/last (remove and return)
Map.Entry<Integer, String> firstEntry = map.pollFirstEntry();  // 10=Ten
Map.Entry<Integer, String> lastEntry = map.pollLastEntry();    // 40=Forty
```

---

## ğŸ“Š Range Views

```java
ConcurrentSkipListMap<Integer, String> map = new ConcurrentSkipListMap<>();
map.put(1, "One");
map.put(2, "Two");
map.put(3, "Three");
map.put(4, "Four");
map.put(5, "Five");

// SubMap [2, 4]
NavigableMap<Integer, String> subMap = map.subMap(2, true, 4, true);
// {2=Two, 3=Three, 4=Four}

// HeadMap (< 3)
NavigableMap<Integer, String> headMap = map.headMap(3, false);
// {1=One, 2=Two}

// TailMap (â‰¥ 3)
NavigableMap<Integer, String> tailMap = map.tailMap(3, true);
// {3=Three, 4=Four, 5=Five}

// Descending view
NavigableMap<Integer, String> descending = map.descendingMap();
// {5=Five, 4=Four, 3=Three, 2=Two, 1=One}
```

---

## ğŸ†š ConcurrentSkipListMap vs TreeMap

| Feature | ConcurrentSkipListMap | TreeMap |
|---------|----------------------|---------|
| **Thread-safe** | âœ… Yes | âŒ No |
| **Locking** | Lock-free | Must synchronize |
| **Structure** | Skip List | Red-Black Tree |
| **Performance** | O(log n) | O(log n) |
| **Concurrency** | High | Low (external sync) |
| **Memory** | Higher | Lower |
| **Null keys** | âŒ No | âŒ No |

---

## âš ï¸ Common Pitfalls

1. **No null keys**
```java
// âŒ NullPointerException
map.put(null, "Value");

// âœ… Null values OK
map.put(1, null);
```

2. **Comparator consistency**
```java
// Keys must be comparable
class Person implements Comparable<Person> {
    String name;
    int age;
    
    // âœ… Must implement compareTo
    public int compareTo(Person other) {
        return this.name.compareTo(other.name);
    }
}
```

3. **Weakly consistent iterators**
```java
// Iterator may not reflect concurrent changes
for (Integer key : map.keySet()) {
    // May not see keys added during iteration
}
```

---

## ğŸ’¡ Best Practices

1. **Use for sorted concurrent maps**
```java
// âœ… Need both sorting and concurrency
ConcurrentSkipListMap<Long, Event> events = new ConcurrentSkipListMap<>();
```

2. **Leverage navigation methods**
```java
// âœ… Efficient range queries
List<Event> recent = map.tailMap(startTime).values().stream()
                        .limit(100)
                        .collect(Collectors.toList());
```

3. **Clean old data periodically**
```java
// âœ… For time-series data
void cleanOldData() {
    long cutoff = System.currentTimeMillis() - RETENTION_PERIOD;
    map.headMap(cutoff).clear();
}
```

---

## ğŸ“ When to Use ConcurrentSkipListMap

### âœ… Use When:
- Need sorted, thread-safe map
- High-concurrency scenarios
- Range queries needed
- Navigation methods (ceiling, floor) required
- Better than synchronized TreeMap

### âŒ Don't Use When:
- Don't need sorting (use ConcurrentHashMap)
- Single-threaded (use TreeMap)
- Need null keys (no alternative in concurrent)

---

## ğŸ“š Interview Questions

**Q1: What's a skip list?**
A: Probabilistic data structure with multiple levels of linked lists for O(log n) operations.

**Q2: Why skip list instead of balanced tree?**
A: Simpler implementation, better concurrency, lock-free operations possible.

**Q3: Can it have null keys?**
A: No, throws NullPointerException.

**Q4: ConcurrentSkipListMap vs ConcurrentHashMap?**
A: SkipListMap is sorted (O(log n)), HashMap is unsorted (O(1)).

**Q5: Is it thread-safe?**
A: Yes, mostly lock-free with CAS operations.

**Q6: Time complexity?**
A: O(log n) for get/put/remove (probabilistic average).

**Q7: Better than synchronized TreeMap?**
A: Yes, better concurrency and no global lock.

**Q8: Can multiple threads iterate simultaneously?**
A: Yes, iterators are weakly consistent and don't block.

---

## ğŸ“š Summary

- **ConcurrentSkipListMap**: Thread-safe sorted map using skip list
- **O(log n) operations**: get, put, remove, containsKey
- **No null keys**: Throws NullPointerException
- **NavigableMap**: ceiling, floor, higher, lower, subMap
- **Better concurrency**: Lock-free, multiple threads can operate
- **Use for**: Sorted concurrent maps, time-series, leaderboards, range queries
