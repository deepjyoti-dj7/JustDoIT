# üîí ConcurrentHashMap

## üìñ Overview

**ConcurrentHashMap** is a thread-safe Map implementation with better concurrency than `Hashtable` or `synchronized HashMap`. Instead of locking the entire map, it uses **lock striping** to allow multiple threads to read/write simultaneously.

```java
public class ConcurrentHashMap<K,V> 
    extends AbstractMap<K,V> 
    implements ConcurrentMap<K,V>, Serializable
```

---

## ‚≠ê Key Characteristics

1. **Thread-safe** - No external synchronization needed
2. **High concurrency** - Lock striping allows parallel operations
3. **No null keys/values** - Throws NullPointerException
4. **Lock-free reads** - Retrievals don't block (Java 8+)
5. **Atomic operations** - putIfAbsent, remove, replace
6. **Fail-safe iterators** - Won't throw ConcurrentModificationException
7. **Better than Hashtable** - Faster, more scalable

---

## üéØ Creating ConcurrentHashMap

```java
// 1. Default (capacity 16)
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// 2. With initial capacity
ConcurrentHashMap<String, Integer> map2 = new ConcurrentHashMap<>(32);

// 3. With capacity and load factor
ConcurrentHashMap<String, Integer> map3 = new ConcurrentHashMap<>(32, 0.75f);

// 4. With concurrency level (deprecated in Java 8+)
ConcurrentHashMap<String, Integer> map4 = new ConcurrentHashMap<>(16, 0.75f, 4);

// 5. From another map
Map<String, Integer> existing = new HashMap<>();
ConcurrentHashMap<String, Integer> map5 = new ConcurrentHashMap<>(existing);
```

---

## üíª Basic Operations

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// Put
map.put("A", 1);
map.put("B", 2);

// Get
Integer value = map.get("A");  // 1

// No null keys/values
// map.put(null, 3);        // NullPointerException
// map.put("C", null);      // NullPointerException

// Atomic operations
map.putIfAbsent("C", 3);     // Only if absent
map.remove("A", 1);          // Remove only if matches
map.replace("B", 2, 20);     // Replace only if matches
map.replace("B", 30);        // Replace unconditionally

// Thread-safe iteration
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}
```

---

## ‚ö° Performance

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **get** | O(1) | Lock-free |
| **put** | O(1) | Fine-grained locks |
| **remove** | O(1) | Fine-grained locks |
| **containsKey** | O(1) | Lock-free |
| **size** | O(1) | Approximate |
| **Iteration** | O(n) | Fail-safe |

**Note:** `size()` returns approximate count during concurrent modifications.

---

## üÜö ConcurrentHashMap vs Hashtable vs HashMap

| Feature | ConcurrentHashMap | Hashtable | synchronized HashMap |
|---------|-------------------|-----------|---------------------|
| **Thread-safe** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| **Locking** | Lock striping | Entire table | Entire map |
| **Concurrency** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê High | ‚≠ê Low | ‚≠ê Low |
| **Null keys** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Null values** | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Iteration** | Fail-safe | Fail-fast | Fail-fast |
| **Performance** | Fast | Slow | Slow |
| **Recommended** | ‚úÖ | ‚ùå Legacy | ‚ö†Ô∏è Simple cases |

---

## üéØ Real-World Examples

### 1. Thread-Safe Cache
```java
ConcurrentHashMap<String, User> userCache = new ConcurrentHashMap<>();

// Multiple threads can safely access
void getUser(String id) {
    return userCache.computeIfAbsent(id, k -> loadFromDatabase(k));
}

// Atomic update
void updateUser(String id, User user) {
    userCache.put(id, user);
}
```

---

### 2. Request Counting (Thread-Safe)
```java
ConcurrentHashMap<String, AtomicInteger> requestCounts = new ConcurrentHashMap<>();

void recordRequest(String endpoint) {
    requestCounts.computeIfAbsent(endpoint, k -> new AtomicInteger(0))
                 .incrementAndGet();
}

// Print stats
requestCounts.forEach((endpoint, count) -> {
    System.out.println(endpoint + ": " + count.get() + " requests");
});
```

---

### 3. Concurrent Word Frequency
```java
ConcurrentHashMap<String, Integer> wordCount = new ConcurrentHashMap<>();

// Process files in parallel
List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
files.parallelStream().forEach(file -> {
    String[] words = readFile(file).split("\\s+");
    for (String word : words) {
        wordCount.merge(word, 1, Integer::sum);  // Atomic increment
    }
});

// Print top 5
wordCount.entrySet().stream()
         .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
         .limit(5)
         .forEach(e -> System.out.println(e.getKey() + ": " + e.getValue()));
```

---

### 4. Session Management
```java
ConcurrentHashMap<String, Session> sessions = new ConcurrentHashMap<>();

// Add session
void createSession(String sessionId, Session session) {
    sessions.put(sessionId, session);
}

// Get and update
void updateLastAccess(String sessionId) {
    sessions.computeIfPresent(sessionId, (k, session) -> {
        session.setLastAccess(System.currentTimeMillis());
        return session;
    });
}

// Remove expired sessions
void cleanupExpired() {
    long now = System.currentTimeMillis();
    sessions.entrySet().removeIf(entry -> 
        now - entry.getValue().getLastAccess() > TIMEOUT
    );
}
```

---

### 5. Rate Limiter
```java
ConcurrentHashMap<String, AtomicInteger> rateLimiter = new ConcurrentHashMap<>();
int MAX_REQUESTS = 100;

boolean allowRequest(String userId) {
    AtomicInteger count = rateLimiter.computeIfAbsent(userId, k -> new AtomicInteger(0));
    
    if (count.incrementAndGet() <= MAX_REQUESTS) {
        return true;  // Allow
    } else {
        count.decrementAndGet();  // Rollback
        return false;  // Deny
    }
}

// Reset every minute
void resetCounts() {
    rateLimiter.clear();
}
```

---

## üîÑ Atomic Operations

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// putIfAbsent - atomic
Integer prev = map.putIfAbsent("A", 1);  // null if absent

// remove with value check - atomic
boolean removed = map.remove("A", 1);  // true if matches

// replace with value check - atomic
boolean replaced = map.replace("B", 2, 20);  // true if matches

// replace unconditionally - atomic
Integer old = map.replace("B", 30);  // returns old value

// computeIfAbsent - atomic
map.computeIfAbsent("C", k -> k.length());

// computeIfPresent - atomic
map.computeIfPresent("C", (k, v) -> v + 1);

// compute - atomic
map.compute("D", (k, v) -> (v == null) ? 1 : v + 1);

// merge - atomic
map.merge("E", 1, Integer::sum);  // Add or sum
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **No null keys/values**
```java
// ‚ùå Will throw NullPointerException
map.put(null, 1);
map.put("A", null);

// ‚úÖ Use Optional or special marker
map.put("A", -1);  // Use -1 as "no value"
```

2. **size() is approximate**
```java
// During concurrent modifications, size() may not be exact
int size = map.size();  // Approximate count
```

3. **Iteration doesn't reflect current state**
```java
// Iterator is fail-safe but may not see concurrent updates
for (String key : map.keySet()) {
    // May not see keys added during iteration
}
```

4. **Don't rely on ordering**
```java
// ConcurrentHashMap is unordered like HashMap
// Don't assume any iteration order
```

---

## üí° Best Practices

1. **Use atomic operations** - Avoid check-then-act patterns
```java
// ‚ùå Not atomic
if (!map.containsKey("A")) {
    map.put("A", 1);
}

// ‚úÖ Atomic
map.putIfAbsent("A", 1);
```

2. **Use compute methods** - For complex updates
```java
// ‚úÖ Atomic increment
map.compute("count", (k, v) -> (v == null) ? 1 : v + 1);

// ‚úÖ Atomic merge
map.merge("sum", 5, Integer::sum);
```

3. **Use for multi-threaded scenarios**
```java
// ‚úÖ Multiple threads accessing
ExecutorService executor = Executors.newFixedThreadPool(10);
ConcurrentHashMap<String, Integer> shared = new ConcurrentHashMap<>();
```

4. **Don't use for single-threaded**
```java
// For single-threaded, use HashMap (faster)
Map<String, Integer> single = new HashMap<>();
```

---

## üéì When to Use ConcurrentHashMap

### ‚úÖ Use When:
- Multiple threads read/write the map
- Need better concurrency than Hashtable
- Fail-safe iteration needed
- Atomic operations required
- High-performance thread-safe map

### ‚ùå Don't Use When:
- Single-threaded application (use HashMap)
- Need null keys/values (use synchronized HashMap)
- Need strict consistency (use synchronized HashMap)
- Small map with rare updates (overhead not worth it)

---

## üìö Interview Questions

**Q1: Why ConcurrentHashMap over Hashtable?**
A: Better concurrency through lock striping, faster reads (lock-free), fail-safe iterators.

**Q2: Can ConcurrentHashMap have null keys/values?**
A: No, both throw NullPointerException (ambiguity in concurrent scenarios).

**Q3: How does ConcurrentHashMap achieve thread-safety?**
A: Lock striping (Java 7) or CAS operations with synchronized nodes (Java 8+).

**Q4: Is size() accurate?**
A: Approximate during concurrent modifications, exact otherwise.

**Q5: What's lock striping?**
A: Dividing map into segments, each with its own lock, allowing parallel access.

**Q6: Are atomic operations really atomic?**
A: Yes, putIfAbsent, remove, replace, compute, merge are atomic.

**Q7: Can multiple threads iterate simultaneously?**
A: Yes, iterators are fail-safe and don't block each other.

**Q8: What's the difference from synchronized HashMap?**
A: ConcurrentHashMap has finer-grained locking, better concurrency, no null keys/values.

---

## üìö Summary

- **ConcurrentHashMap**: Thread-safe Map with high concurrency
- **Lock striping**: Allows parallel operations (better than Hashtable)
- **No null keys/values**: Throws NullPointerException
- **Atomic operations**: putIfAbsent, compute, merge
- **Lock-free reads**: Fast retrieval operations (Java 8+)
- **Fail-safe iterators**: Won't throw ConcurrentModificationException
- **Use for**: Multi-threaded scenarios requiring high performance
