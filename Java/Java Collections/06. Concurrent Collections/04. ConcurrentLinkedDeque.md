# üîóüîó ConcurrentLinkedDeque

## üìñ Overview

**ConcurrentLinkedDeque** is a thread-safe, unbounded, **lock-free** double-ended queue (deque) based on linked nodes. It supports **FIFO** and **LIFO** operations from both ends, using **CAS** operations for thread-safety.

```java
public class ConcurrentLinkedDeque<E> 
    extends AbstractCollection<E> 
    implements Deque<E>, Serializable
```

---

## ‚≠ê Key Characteristics

1. **Lock-free** - Uses CAS instead of locks (non-blocking)
2. **Thread-safe** - Safe for concurrent access
3. **Unbounded** - No capacity limit
4. **Double-ended** - Add/remove from both head and tail
5. **No null elements** - Throws NullPointerException
6. **Non-blocking** - Operations return null if empty
7. **Weakly consistent iterators** - May not reflect concurrent changes
8. **O(1) operations** - Amortized constant time

---

## üéØ Creating ConcurrentLinkedDeque

```java
// 1. Empty deque
ConcurrentLinkedDeque<String> deque = new ConcurrentLinkedDeque<>();

// 2. From collection
List<String> list = Arrays.asList("A", "B", "C");
ConcurrentLinkedDeque<String> deque2 = new ConcurrentLinkedDeque<>(list);
```

---

## üíª Basic Operations

```java
ConcurrentLinkedDeque<String> deque = new ConcurrentLinkedDeque<>();

// ========== Add at HEAD ==========
deque.addFirst("A");     // Throws exception on failure
deque.offerFirst("B");   // Returns false on failure (never for unbounded)
deque.push("C");         // Same as addFirst (stack operation)

// ========== Add at TAIL ==========
deque.addLast("D");      // Throws exception on failure
deque.offerLast("E");    // Returns false on failure
deque.add("F");          // Same as addLast
deque.offer("G");        // Same as offerLast

// ========== Peek (no removal) ==========
String first = deque.peekFirst();  // "C" or null
String last = deque.peekLast();    // "G" or null
String head = deque.peek();        // Same as peekFirst

// ========== Remove from HEAD ==========
String item1 = deque.pollFirst();  // "C" or null
String item2 = deque.removeFirst(); // Throws NoSuchElementException if empty
String item3 = deque.poll();       // Same as pollFirst
String item4 = deque.pop();        // Same as removeFirst (stack)

// ========== Remove from TAIL ==========
String item5 = deque.pollLast();   // Last element or null
String item6 = deque.removeLast(); // Throws NoSuchElementException if empty

// ========== Other operations ==========
boolean empty = deque.isEmpty();
int size = deque.size();  // O(n) - expensive!
boolean has = deque.contains("A");  // O(n)
```

---

## ‚ö° Performance

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **offerFirst/Last** | O(1) amortized | Lock-free CAS |
| **pollFirst/Last** | O(1) amortized | Lock-free CAS |
| **peekFirst/Last** | O(1) | Read head/tail |
| **size** | O(n) | ‚ö†Ô∏è Iterates all! |
| **contains** | O(n) | Linear search |
| **remove(obj)** | O(n) | Linear search |

---

## üèóÔ∏è Internal Structure

```java
private static class Node<E> {
    volatile E item;
    volatile Node<E> prev;
    volatile Node<E> next;
    
    Node(E item) {
        UNSAFE.putObject(this, itemOffset, item);
    }
}

private transient volatile Node<E> head;
private transient volatile Node<E> tail;
```

### Visual Representation
```
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚Üì                             ‚Üë
head ‚Üí [A] ‚Üê‚Üí [B] ‚Üê‚Üí [C] ‚Üê‚Üí [D] ‚Üê tail
       ‚Üì       ‚Üì      ‚Üì      ‚Üì
     item   item   item   item

Doubly-linked with CAS updates at both ends
```

---

## üéØ Real-World Examples

### 1. Work Stealing Queue
```java
ConcurrentLinkedDeque<Task> workQueue = new ConcurrentLinkedDeque<>();

// Worker adds tasks to its own queue (at head)
class Worker implements Runnable {
    public void run() {
        while (true) {
            // Process own tasks (LIFO - stack behavior)
            Task task = workQueue.pollFirst();
            
            if (task != null) {
                task.execute();
            } else {
                // Try stealing from others (from tail)
                Task stolen = otherWorkerQueue.pollLast();
                if (stolen != null) {
                    stolen.execute();
                }
            }
        }
    }
}
```

---

### 2. Browser History (Back/Forward)
```java
ConcurrentLinkedDeque<String> history = new ConcurrentLinkedDeque<>();
ConcurrentLinkedDeque<String> forward = new ConcurrentLinkedDeque<>();

String currentPage = "home.html";

// Navigate to new page
void navigate(String url) {
    history.offerFirst(currentPage);  // Save current
    currentPage = url;
    forward.clear();  // Clear forward history
}

// Back button
void goBack() {
    if (!history.isEmpty()) {
        forward.offerFirst(currentPage);  // Save for forward
        currentPage = history.pollFirst();
    }
}

// Forward button
void goForward() {
    if (!forward.isEmpty()) {
        history.offerFirst(currentPage);  // Save for back
        currentPage = forward.pollFirst();
    }
}
```

---

### 3. Undo/Redo Manager
```java
ConcurrentLinkedDeque<Command> undoStack = new ConcurrentLinkedDeque<>();
ConcurrentLinkedDeque<Command> redoStack = new ConcurrentLinkedDeque<>();

// Execute command
void execute(Command cmd) {
    cmd.execute();
    undoStack.offerFirst(cmd);
    redoStack.clear();  // Clear redo on new action
}

// Undo
void undo() {
    Command cmd = undoStack.pollFirst();
    if (cmd != null) {
        cmd.undo();
        redoStack.offerFirst(cmd);
    }
}

// Redo
void redo() {
    Command cmd = redoStack.pollFirst();
    if (cmd != null) {
        cmd.execute();
        undoStack.offerFirst(cmd);
    }
}
```

---

### 4. Priority Task Queue
```java
ConcurrentLinkedDeque<Task> taskQueue = new ConcurrentLinkedDeque<>();

// High-priority tasks go to front
void submitHighPriority(Task task) {
    taskQueue.offerFirst(task);
}

// Normal tasks go to back
void submitNormalPriority(Task task) {
    taskQueue.offerLast(task);
}

// Process tasks
Task getNextTask() {
    return taskQueue.pollFirst();  // High priority first
}
```

---

### 5. Message Buffer with Overflow
```java
ConcurrentLinkedDeque<Message> buffer = new ConcurrentLinkedDeque<>();
int MAX_SIZE = 1000;

// Add message (newer at tail)
void addMessage(Message msg) {
    buffer.offerLast(msg);
    
    // Remove oldest if overflow
    if (buffer.size() > MAX_SIZE) {
        buffer.pollFirst();
    }
}

// Get messages (newest first)
List<Message> getRecentMessages(int count) {
    List<Message> recent = new ArrayList<>();
    Iterator<Message> it = buffer.descendingIterator();
    
    while (it.hasNext() && count-- > 0) {
        recent.add(it.next());
    }
    return recent;
}
```

---

## üîÑ Stack Operations (LIFO)

```java
ConcurrentLinkedDeque<String> stack = new ConcurrentLinkedDeque<>();

// Push (add to front)
stack.push("A");
stack.push("B");
stack.push("C");

// Pop (remove from front)
String top = stack.pop();  // "C" (LIFO)

// Peek
String peek = stack.peek();  // "B"
```

---

## üîÑ Queue Operations (FIFO)

```java
ConcurrentLinkedDeque<String> queue = new ConcurrentLinkedDeque<>();

// Enqueue (add to tail)
queue.offer("A");
queue.offer("B");
queue.offer("C");

// Dequeue (remove from head)
String first = queue.poll();  // "A" (FIFO)

// Peek
String peek = queue.peek();  // "B"
```

---

## üÜö ConcurrentLinkedDeque vs Others

| Feature | ConcurrentLinkedDeque | ConcurrentLinkedQueue | LinkedBlockingDeque |
|---------|----------------------|----------------------|-------------------|
| **Ends** | Both (Deque) | One (Queue) | Both (Deque) |
| **Blocking** | No | No | Yes |
| **Locking** | Lock-free (CAS) | Lock-free (CAS) | ReentrantLock |
| **Capacity** | Unbounded | Unbounded | Unbounded/Bounded |
| **Performance** | Highest | Highest | Medium |
| **size()** | O(n) | O(n) | O(1) |

---

## ‚ö†Ô∏è Common Pitfalls

1. **size() is expensive**
```java
// ‚ùå Avoid
while (deque.size() > 0) {  // O(n) each time!
    process(deque.pollFirst());
}

// ‚úÖ Better
while (!deque.isEmpty()) {  // O(1)
    Item item = deque.pollFirst();
    if (item == null) break;
    process(item);
}
```

2. **No null elements**
```java
// ‚ùå NullPointerException
deque.offerFirst(null);

// ‚úÖ Use Optional
deque.offerFirst(Optional.ofNullable(value));
```

3. **Weakly consistent iterators**
```java
// Iterator may not see concurrent modifications
for (String item : deque) {
    // May miss items added during iteration
}
```

---

## üí° Best Practices

1. **Avoid size()** - Use isEmpty()
```java
// ‚úÖ Check empty instead
if (!deque.isEmpty()) {
    Item item = deque.pollFirst();
}
```

2. **Choose right end for your use case**
```java
// Stack (LIFO) - use First
deque.offerFirst(item);
Item top = deque.pollFirst();

// Queue (FIFO) - use Last for add, First for remove
deque.offerLast(item);
Item front = deque.pollFirst();
```

3. **Use for work stealing**
```java
// Own work: LIFO from head
Task mine = myQueue.pollFirst();

// Steal work: FIFO from tail
Task stolen = otherQueue.pollLast();
```

---

## üéì When to Use ConcurrentLinkedDeque

### ‚úÖ Use When:
- Need double-ended operations (both ends)
- Stack and queue operations needed
- Lock-free, high-throughput required
- Work stealing scenarios
- Unbounded capacity acceptable

### ‚ùå Don't Use When:
- Need blocking (use LinkedBlockingDeque)
- Need bounded capacity (use LinkedBlockingDeque)
- Need O(1) size() (use LinkedBlockingDeque)
- Only single-ended (use ConcurrentLinkedQueue)

---

## üìö Interview Questions

**Q1: What's the difference from ConcurrentLinkedQueue?**
A: Deque supports operations at both ends; Queue only at one end.

**Q2: Is it thread-safe?**
A: Yes, uses lock-free CAS operations.

**Q3: Can it be used as a stack?**
A: Yes, using push/pop (or offerFirst/pollFirst).

**Q4: Does it block?**
A: No, operations return null if empty (non-blocking).

**Q5: What's work stealing?**
A: Workers process own tasks (LIFO from head), steal others' tasks (FIFO from tail).

**Q6: Time complexity of size()?**
A: O(n) - avoid in performance-critical code.

**Q7: ConcurrentLinkedDeque vs LinkedBlockingDeque?**
A: CLD is lock-free and non-blocking; LBD uses locks and can block.

**Q8: Can it contain null?**
A: No, throws NullPointerException.

---

## üìö Summary

- **ConcurrentLinkedDeque**: Lock-free, thread-safe, unbounded deque
- **Double-ended**: Add/remove from both head and tail
- **Lock-free**: Uses CAS operations (no locks)
- **Non-blocking**: Operations return null if empty
- **O(n) size()**: Avoid in hot paths
- **Use for**: Stack, queue, work stealing, undo/redo
- **Work stealing**: Own tasks LIFO from head, steal FIFO from tail
