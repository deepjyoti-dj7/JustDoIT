# üì¶ Java Collections Framework

## üìö Complete Guide for Interview Preparation

This folder contains comprehensive coverage of the Java Collections Framework with implementations, internals, and best practices.

---

## üìñ Table of Contents

### 1. Collection Framework Overview
- [01. Introduction to Collections](01.%20Collection%20Framework%20Overview/01.%20Introduction%20to%20Collections.md)
- [02. Collection Hierarchy](01.%20Collection%20Framework%20Overview/02.%20Collection%20Hierarchy.md)
- [03. Collection vs Collections](01.%20Collection%20Framework%20Overview/03.%20Collection%20vs%20Collections.md)
- [04. Iterable & Iterator](01.%20Collection%20Framework%20Overview/04.%20Iterable%20%26%20Iterator.md)
- [05. Comparable vs Comparator](01.%20Collection%20Framework%20Overview/05.%20Comparable%20vs%20Comparator.md)
- [06. Fail-Fast vs Fail-Safe](01.%20Collection%20Framework%20Overview/06.%20Fail-Fast%20vs%20Fail-Safe.md)

### 2. List Interface
- [01. List Interface Basics](02.%20List%20Interface/01.%20List%20Interface%20Basics.md)
- [02. ArrayList](02.%20List%20Interface/02.%20ArrayList.md)
- [03. LinkedList](02.%20List%20Interface/03.%20LinkedList.md)
- [04. Vector](02.%20List%20Interface/04.%20Vector.md)
- [05. Stack](02.%20List%20Interface/05.%20Stack.md)
- [06. ArrayList vs LinkedList](02.%20List%20Interface/06.%20ArrayList%20vs%20LinkedList.md)
- [07. CopyOnWriteArrayList](02.%20List%20Interface/07.%20CopyOnWriteArrayList.md)

### 3. Set Interface
- [01. Set Interface Basics](03.%20Set%20Interface/01.%20Set%20Interface%20Basics.md)
- [02. HashSet](03.%20Set%20Interface/02.%20HashSet.md)
- [03. LinkedHashSet](03.%20Set%20Interface/03.%20LinkedHashSet.md)
- [04. TreeSet](03.%20Set%20Interface/04.%20TreeSet.md)
- [05. EnumSet](03.%20Set%20Interface/05.%20EnumSet.md)
- [06. Set Comparisons](03.%20Set%20Interface/06.%20Set%20Comparisons.md)
- [07. CopyOnWriteArraySet](03.%20Set%20Interface/07.%20CopyOnWriteArraySet.md)

### 4. Queue Interface
- [01. Queue Interface Basics](04.%20Queue%20Interface/01.%20Queue%20Interface%20Basics.md)
- [02. PriorityQueue](04.%20Queue%20Interface/02.%20PriorityQueue.md)
- [03. Deque Interface](04.%20Queue%20Interface/03.%20Deque%20Interface.md)
- [04. ArrayDeque](04.%20Queue%20Interface/04.%20ArrayDeque.md)
- [05. BlockingQueue](04.%20Queue%20Interface/05.%20BlockingQueue.md)
- [06. LinkedBlockingQueue](04.%20Queue%20Interface/06.%20LinkedBlockingQueue.md)
- [07. PriorityBlockingQueue](04.%20Queue%20Interface/07.%20PriorityBlockingQueue.md)

### 5. Map Interface
- [01. Map Interface Basics](05.%20Map%20Interface/01.%20Map%20Interface%20Basics.md)
- [02. HashMap](05.%20Map%20Interface/02.%20HashMap.md)
- [03. HashMap Internals](05.%20Map%20Interface/03.%20HashMap%20Internals.md)
- [04. LinkedHashMap](05.%20Map%20Interface/04.%20LinkedHashMap.md)
- [05. TreeMap](05.%20Map%20Interface/05.%20TreeMap.md)
- [06. Hashtable](05.%20Map%20Interface/06.%20Hashtable.md)
- [07. WeakHashMap](05.%20Map%20Interface/07.%20WeakHashMap.md)
- [08. IdentityHashMap](05.%20Map%20Interface/08.%20IdentityHashMap.md)
- [09. EnumMap](05.%20Map%20Interface/09.%20EnumMap.md)
- [10. Map Comparisons](05.%20Map%20Interface/10.%20Map%20Comparisons.md)

### 6. Concurrent Collections
- [01. ConcurrentHashMap](06.%20Concurrent%20Collections/01.%20ConcurrentHashMap.md)
- [02. ConcurrentHashMap Internals](06.%20Concurrent%20Collections/02.%20ConcurrentHashMap%20Internals.md)
- [03. ConcurrentLinkedQueue](06.%20Concurrent%20Collections/03.%20ConcurrentLinkedQueue.md)
- [04. ConcurrentLinkedDeque](06.%20Concurrent%20Collections/04.%20ConcurrentLinkedDeque.md)
- [05. ConcurrentSkipListMap](06.%20Concurrent%20Collections/05.%20ConcurrentSkipListMap.md)
- [06. ConcurrentSkipListSet](06.%20Concurrent%20Collections/06.%20ConcurrentSkipListSet.md)

### 7. Special Purpose Collections
- [01. Collections Class](07.%20Special%20Purpose%20Collections/01.%20Collections%20Class.md)
- [02. Arrays Class](07.%20Special%20Purpose%20Collections/02.%20Arrays%20Class.md)
- [03. Synchronized Collections](07.%20Special%20Purpose%20Collections/03.%20Synchronized%20Collections.md)
- [04. Unmodifiable Collections](07.%20Special%20Purpose%20Collections/04.%20Unmodifiable%20Collections.md)
- [05. Empty Collections](07.%20Special%20Purpose%20Collections/05.%20Empty%20Collections.md)
- [06. Singleton Collections](07.%20Special%20Purpose%20Collections/06.%20Singleton%20Collections.md)

### 8. Sorting & Searching
- [01. Comparable Interface](08.%20Sorting%20%26%20Searching/01.%20Comparable%20Interface.md)
- [02. Comparator Interface](08.%20Sorting%20%26%20Searching/02.%20Comparator%20Interface.md)
- [03. Collections.sort()](08.%20Sorting%20%26%20Searching/03.%20Collections.sort%28%29.md)
- [04. Arrays.sort()](08.%20Sorting%20%26%20Searching/04.%20Arrays.sort%28%29.md)
- [05. Binary Search](08.%20Sorting%20%26%20Searching/05.%20Binary%20Search.md)
- [06. Custom Sorting](08.%20Sorting%20%26%20Searching/06.%20Custom%20Sorting.md)

### 9. Collection Algorithms
- [01. Sorting Algorithms](09.%20Collection%20Algorithms/01.%20Sorting%20Algorithms.md)
- [02. Searching Algorithms](09.%20Collection%20Algorithms/02.%20Searching%20Algorithms.md)
- [03. Shuffling](09.%20Collection%20Algorithms/03.%20Shuffling.md)
- [04. Reversing](09.%20Collection%20Algorithms/04.%20Reversing.md)
- [05. Frequency & Disjoint](09.%20Collection%20Algorithms/05.%20Frequency%20%26%20Disjoint.md)
- [06. Min & Max](09.%20Collection%20Algorithms/06.%20Min%20%26%20Max.md)

### 10. Stream Operations on Collections
- [01. Collection to Stream](10.%20Stream%20Operations/01.%20Collection%20to%20Stream.md)
- [02. Filtering Collections](10.%20Stream%20Operations/02.%20Filtering%20Collections.md)
- [03. Mapping Collections](10.%20Stream%20Operations/03.%20Mapping%20Collections.md)
- [04. Reducing Collections](10.%20Stream%20Operations/04.%20Reducing%20Collections.md)
- [05. Grouping & Partitioning](10.%20Stream%20Operations/05.%20Grouping%20%26%20Partitioning.md)
- [06. Collectors](10.%20Stream%20Operations/06.%20Collectors.md)

### 11. Custom Collections
- [01. Creating Custom ArrayList](11.%20Custom%20Collections/01.%20Creating%20Custom%20ArrayList.md)
- [02. Creating Custom HashMap](11.%20Custom%20Collections/02.%20Creating%20Custom%20HashMap.md)
- [03. Creating Custom LinkedList](11.%20Custom%20Collections/03.%20Creating%20Custom%20LinkedList.md)
- [04. Implementing Collection Interface](11.%20Custom%20Collections/04.%20Implementing%20Collection%20Interface.md)

### 12. Performance & Best Practices
- [01. Time Complexity](12.%20Performance%20%26%20Best%20Practices/01.%20Time%20Complexity.md)
- [02. Space Complexity](12.%20Performance%20%26%20Best%20Practices/02.%20Space%20Complexity.md)
- [03. When to Use Which Collection](12.%20Performance%20%26%20Best%20Practices/03.%20When%20to%20Use%20Which%20Collection.md)
- [04. Common Pitfalls](12.%20Performance%20%26%20Best%20Practices/04.%20Common%20Pitfalls.md)
- [05. Memory Optimization](12.%20Performance%20%26%20Best%20Practices/05.%20Memory%20Optimization.md)
- [06. Thread Safety](12.%20Performance%20%26%20Best%20Practices/06.%20Thread%20Safety.md)

---

## üìã Study Guide - Recommended Learning Path

### Phase 1: Collection Basics (Week 1)
**Goal**: Understand collection framework architecture

- Collection hierarchy
- Iterable and Iterator
- Comparable vs Comparator
- Fail-fast vs fail-safe iterators
- Collections utility class

**Practice**: Iterate collections, sort custom objects

---

### Phase 2: List Interface (Week 2)
**Goal**: Master List implementations

- ArrayList internals (dynamic array, growth)
- LinkedList internals (doubly-linked list)
- Vector and Stack (legacy)
- ArrayList vs LinkedList performance
- When to use which

**Practice**: Implement custom ArrayList, solve list problems

---

### Phase 3: Set Interface (Week 3)
**Goal**: Master Set implementations

- HashSet internals (backed by HashMap)
- LinkedHashSet (insertion order)
- TreeSet (sorted, red-black tree)
- Set operations (union, intersection, difference)

**Practice**: Remove duplicates, find unique elements

---

### Phase 4: Queue Interface (Week 4)
**Goal**: Master Queue implementations

- Queue operations (offer, poll, peek)
- PriorityQueue (heap-based)
- Deque interface
- ArrayDeque vs LinkedList
- BlockingQueue for producer-consumer

**Practice**: Implement priority-based systems, BFS algorithms

---

### Phase 5: Map Interface (Week 5-6)
**Goal**: Deep dive into Map implementations

- HashMap internals (hashing, collision, load factor)
- HashMap in Java 8+ (tree nodes)
- LinkedHashMap (access/insertion order)
- TreeMap (sorted keys)
- WeakHashMap, IdentityHashMap
- Hashtable vs HashMap vs ConcurrentHashMap

**Practice**: Implement custom HashMap, solve map-based problems

---

### Phase 6: Concurrent Collections (Week 7)
**Goal**: Thread-safe collections

- ConcurrentHashMap internals (segmentation)
- ConcurrentLinkedQueue
- CopyOnWriteArrayList
- Blocking queues
- When to use concurrent collections

**Practice**: Multi-threaded collection access, producer-consumer

---

### Phase 7: Advanced Topics (Week 8)
**Goal**: Sorting, searching, and algorithms

- Custom sorting with Comparator
- Binary search
- Collections algorithms (reverse, shuffle, frequency)
- Stream operations on collections
- Performance optimization

**Practice**: Sort complex objects, optimize collection operations

---

### Phase 8: Interview Preparation (Week 9)
**Goal**: Master interview problems

- Collection-based coding problems
- Design problems (LRU cache, HashMap)
- Performance trade-offs
- Thread safety scenarios

**Practice**: LeetCode, HackerRank collection problems

---

## üéØ Interview Focus Areas

### Must Know ‚≠ê‚≠ê‚≠ê
1. **HashMap internals** (hashing, collision, load factor, Java 8 changes)
2. **ArrayList vs LinkedList** (when to use, performance)
3. **HashSet internals** (backed by HashMap)
4. **equals() and hashCode() contract**
5. **Comparable vs Comparator**
6. **Iterator vs ListIterator**
7. **Fail-fast vs fail-safe**
8. **Collection hierarchy**
9. **ConcurrentHashMap** (thread-safety, vs Hashtable)
10. **Time complexity** of operations

### Should Know ‚≠ê‚≠ê
1. LinkedHashMap and LRU cache
2. TreeMap and TreeSet (Red-Black tree)
3. PriorityQueue (heap)
4. Deque interface
5. WeakHashMap use cases
6. CopyOnWriteArrayList
7. Collections utility methods
8. Stream operations on collections
9. BlockingQueue variants
10. Custom collection implementation

### Good to Know ‚≠ê
1. EnumSet and EnumMap
2. IdentityHashMap
3. ConcurrentSkipListMap
4. Synchronized wrappers
5. Unmodifiable collections
6. NavigableSet and NavigableMap
7. SortedSet and SortedMap
8. Collection performance tuning

---

## üéØ Common Interview Questions

### ArrayList
- How does ArrayList work internally?
- What is the default capacity?
- How does ArrayList grow?
- ArrayList vs Array?
- How to make ArrayList thread-safe?

### HashMap
- How does HashMap work internally?
- What is hashing?
- How are collisions handled?
- What is load factor?
- Changes in Java 8 (tree nodes)?
- Why override equals() and hashCode()?
- HashMap vs Hashtable vs ConcurrentHashMap?

### HashSet
- How does HashSet work?
- How does HashSet maintain uniqueness?
- Can HashSet contain null?
- Internal implementation?

### LinkedList
- Doubly-linked list implementation?
- ArrayList vs LinkedList?
- When to use LinkedList?
- Time complexity of operations?

### TreeMap/TreeSet
- How are elements sorted?
- Red-Black tree basics?
- Comparable vs Comparator?
- Time complexity?

### General
- Fail-fast vs fail-safe?
- Iterator vs ListIterator?
- Comparable vs Comparator?
- Synchronized vs concurrent collections?
- When to use which collection?

---

## üìä Time Complexity Cheat Sheet

### ArrayList
- **Add**: O(1) amortized, O(n) worst case
- **Get**: O(1)
- **Remove**: O(n)
- **Contains**: O(n)
- **Size**: O(1)

### LinkedList
- **Add (first/last)**: O(1)
- **Add (middle)**: O(n)
- **Get**: O(n)
- **Remove**: O(n)
- **Contains**: O(n)

### HashSet/HashMap
- **Add/Put**: O(1) average, O(n) worst
- **Get/Contains**: O(1) average, O(n) worst
- **Remove**: O(1) average, O(n) worst

### TreeSet/TreeMap
- **Add/Put**: O(log n)
- **Get/Contains**: O(log n)
- **Remove**: O(log n)

### PriorityQueue
- **Offer**: O(log n)
- **Poll**: O(log n)
- **Peek**: O(1)

---

## üí° Best Practices

1. ‚úÖ **Choose the right collection** based on use case
2. ‚úÖ **Program to interfaces** (List, Set, Map) not implementations
3. ‚úÖ **Initialize with capacity** if size is known
4. ‚úÖ **Override equals() and hashCode()** for custom objects in HashMap/HashSet
5. ‚úÖ **Use generics** for type safety
6. ‚úÖ **Prefer ArrayList** over LinkedList in most cases
7. ‚úÖ **Use EnumSet** for enum types
8. ‚úÖ **Use ConcurrentHashMap** instead of Hashtable
9. ‚úÖ **Avoid modifying collection** while iterating (use Iterator.remove())
10. ‚úÖ **Use streams** for collection operations (Java 8+)

---

## üîç When to Use Which Collection?

### Use ArrayList when:
- Random access is frequent
- Few deletions/insertions in middle
- Size is relatively stable

### Use LinkedList when:
- Frequent insertions/deletions at ends
- Random access is rare
- Implementing stack/queue

### Use HashSet when:
- Need unique elements
- Order doesn't matter
- Fast lookups required

### Use TreeSet when:
- Need sorted unique elements
- Range operations needed

### Use HashMap when:
- Key-value pairs needed
- Fast lookups by key
- Order doesn't matter

### Use TreeMap when:
- Sorted keys needed
- Range queries required

### Use PriorityQueue when:
- Need elements in priority order
- Implementing heap algorithms

### Use ConcurrentHashMap when:
- Thread-safe map needed
- High concurrent reads/writes

---

## üìö Additional Resources

**Books**:
- Effective Java (Joshua Bloch) - Items 25-33
- Java Generics and Collections

**Online**:
- Oracle Collections Tutorial
- Baeldung Collections Guide
- GeeksforGeeks Collections

**Practice**:
- LeetCode Array/HashMap problems
- HackerRank Data Structures
- InterviewBit Collections

**Tools**:
- Java VisualVM (memory analysis)
- JMH (benchmarking)

---

## ‚úÖ Pre-Interview Checklist

**Core Concepts:**
- [ ] Collection hierarchy diagram
- [ ] HashMap internals (hashing, collision, Java 8)
- [ ] ArrayList vs LinkedList
- [ ] HashSet internals
- [ ] Time complexity of all operations
- [ ] equals() and hashCode() contract
- [ ] Comparable vs Comparator
- [ ] Fail-fast vs fail-safe

**Coding:**
- [ ] Implement custom ArrayList
- [ ] Implement custom HashMap
- [ ] LRU Cache implementation
- [ ] Sort custom objects
- [ ] Solve 20+ collection problems

**Theory:**
- [ ] Explain each collection with examples
- [ ] When to use which collection
- [ ] Thread-safety options
- [ ] Performance trade-offs

---

Happy Learning! üöÄ
