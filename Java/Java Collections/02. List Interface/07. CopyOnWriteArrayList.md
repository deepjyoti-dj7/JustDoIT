# üîê CopyOnWriteArrayList

## üìñ Overview

**CopyOnWriteArrayList** is a thread-safe variant of ArrayList where all mutative operations (add, set, remove) are implemented by making a fresh copy of the underlying array.

**Key Features:**
- Thread-safe without explicit synchronization
- Copy-on-write mechanism
- Fail-safe iterators
- Best for read-heavy scenarios
- No ConcurrentModificationException
- High write cost, low read cost
- Snapshot iteration

---

## üéØ How it Works

```
Read Operations (get, iterator):
    - No locking required
    - Read from current array snapshot
    - O(1) time complexity
    
Write Operations (add, set, remove):
    1. Lock acquired
    2. Copy entire array
    3. Modify copied array
    4. Replace reference to new array
    5. Lock released
    
Why Thread-Safe?
    - Readers see consistent snapshot
    - Writers work on copy
    - No interference between reads/writes
```

---

## üíª Example 1: Basic Operations

```java
import java.util.*;
import java.util.concurrent.*;

public class CopyOnWriteBasicsDemo {
    public static void main(String[] args) {
        // Create CopyOnWriteArrayList
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        
        // 1. Add elements
        list.add("Java");
        list.add("Python");
        list.add("JavaScript");
        System.out.println("List: " + list);
        
        // 2. Add at index
        list.add(1, "C++");
        System.out.println("After add at index: " + list);
        
        // 3. Get element
        String element = list.get(2);
        System.out.println("Element at index 2: " + element);
        
        // 4. Set element
        list.set(2, "Ruby");
        System.out.println("After set: " + list);
        
        // 5. Remove element
        list.remove("C++");
        System.out.println("After remove: " + list);
        
        // 6. Size
        System.out.println("Size: " + list.size());
        
        // 7. Contains
        System.out.println("Contains Java? " + list.contains("Java"));
        
        // 8. Clear
        list.clear();
        System.out.println("After clear: " + list);
        
        // Key difference: Thread-safe without synchronization!
        System.out.println("\nNo explicit synchronization needed!");
    }
}
```

---

## üíª Example 2: Thread-Safety Demonstration

```java
import java.util.*;
import java.util.concurrent.*;

public class CopyOnWriteThreadSafetyDemo {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== ArrayList (Not Thread-Safe) ===");
        
        List<Integer> arrayList = new ArrayList<>();
        
        // Multiple threads modifying ArrayList
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                arrayList.add(i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                arrayList.add(i);
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("Expected: 2000, Actual: " + arrayList.size());
        if (arrayList.size() < 2000) {
            System.out.println("Data lost! Not thread-safe.\n");
        }
        
        // CopyOnWriteArrayList (Thread-Safe)
        System.out.println("=== CopyOnWriteArrayList (Thread-Safe) ===");
        
        CopyOnWriteArrayList<Integer> cowList = new CopyOnWriteArrayList<>();
        
        Thread t3 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                cowList.add(i);
            }
        });
        
        Thread t4 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                cowList.add(i);
            }
        });
        
        t3.start();
        t4.start();
        t3.join();
        t4.join();
        
        System.out.println("Expected: 2000, Actual: " + cowList.size());
        System.out.println("No data lost! Thread-safe without explicit synchronization.");
    }
}
```

---

## üíª Example 3: Fail-Safe Iterator

```java
import java.util.*;
import java.util.concurrent.*;

public class FailSafeIteratorDemo {
    public static void main(String[] args) {
        System.out.println("=== ArrayList (Fail-Fast) ===");
        
        List<String> arrayList = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
        
        try {
            for (String item : arrayList) {
                System.out.print(item + " ");
                if (item.equals("B")) {
                    arrayList.remove("C");  // Concurrent modification!
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("\n‚úó ConcurrentModificationException thrown!");
        }
        
        System.out.println("\n=== CopyOnWriteArrayList (Fail-Safe) ===");
        
        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>(
            Arrays.asList("A", "B", "C", "D")
        );
        
        // Iterate and modify simultaneously - NO EXCEPTION!
        for (String item : cowList) {
            System.out.print(item + " ");
            if (item.equals("B")) {
                cowList.remove("C");  // Safe to modify during iteration
            }
        }
        
        System.out.println("\n‚úì No exception! Iterator works on snapshot.");
        System.out.println("List after iteration: " + cowList);
        
        // Explanation
        System.out.println("\n=== Why? ===");
        System.out.println("ArrayList Iterator: Checks for modifications (fail-fast)");
        System.out.println("CopyOnWrite Iterator: Works on snapshot (fail-safe)");
        System.out.println("Note: Iterator doesn't see changes made during iteration");
    }
}
```

---

## üíª Example 4: Read-Heavy vs Write-Heavy Performance

```java
import java.util.*;
import java.util.concurrent.*;

public class PerformanceComparisonDemo {
    public static void main(String[] args) {
        int size = 10000;
        
        // Scenario 1: Read-Heavy (90% reads, 10% writes)
        System.out.println("=== Read-Heavy Scenario ===");
        
        List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < size; i++) syncList.add(i);
        
        long start = System.nanoTime();
        // 90% reads
        for (int i = 0; i < 9000; i++) {
            syncList.get(i % size);
        }
        // 10% writes
        for (int i = 0; i < 1000; i++) {
            syncList.set(i, i * 2);
        }
        long end = System.nanoTime();
        System.out.println("Synchronized ArrayList: " + (end - start) / 1000000 + " ms");
        
        CopyOnWriteArrayList<Integer> cowList = new CopyOnWriteArrayList<>();
        for (int i = 0; i < size; i++) cowList.add(i);
        
        start = System.nanoTime();
        // 90% reads
        for (int i = 0; i < 9000; i++) {
            cowList.get(i % size);
        }
        // 10% writes
        for (int i = 0; i < 1000; i++) {
            cowList.set(i, i * 2);
        }
        end = System.nanoTime();
        System.out.println("CopyOnWriteArrayList: " + (end - start) / 1000000 + " ms");
        System.out.println("Winner: CopyOnWriteArrayList (no read locking)\n");
        
        // Scenario 2: Write-Heavy (10% reads, 90% writes)
        System.out.println("=== Write-Heavy Scenario ===");
        
        syncList = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < 100; i++) syncList.add(i);
        
        start = System.nanoTime();
        // 90% writes
        for (int i = 0; i < 900; i++) {
            syncList.add(i);
        }
        // 10% reads
        for (int i = 0; i < 100; i++) {
            syncList.get(i % syncList.size());
        }
        end = System.nanoTime();
        System.out.println("Synchronized ArrayList: " + (end - start) / 1000000 + " ms");
        
        cowList = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 100; i++) cowList.add(i);
        
        start = System.nanoTime();
        // 90% writes
        for (int i = 0; i < 900; i++) {
            cowList.add(i);
        }
        // 10% reads
        for (int i = 0; i < 100; i++) {
            cowList.get(i % cowList.size());
        }
        end = System.nanoTime();
        System.out.println("CopyOnWriteArrayList: " + (end - start) / 1000000 + " ms");
        System.out.println("Winner: Synchronized ArrayList (copying is expensive)");
    }
}
```

---

## üíª Example 5: Listener/Observer Pattern

```java
import java.util.*;
import java.util.concurrent.*;

public class ListenerPatternDemo {
    interface EventListener {
        void onEvent(String event);
    }
    
    static class EventPublisher {
        // Perfect use case: Listeners rarely change, but events are frequent
        private CopyOnWriteArrayList<EventListener> listeners = 
            new CopyOnWriteArrayList<>();
        
        public void addListener(EventListener listener) {
            listeners.add(listener);
            System.out.println("Listener added. Total: " + listeners.size());
        }
        
        public void removeListener(EventListener listener) {
            listeners.remove(listener);
            System.out.println("Listener removed. Total: " + listeners.size());
        }
        
        public void publishEvent(String event) {
            System.out.println("\nPublishing: " + event);
            
            // Safe to iterate even if listeners are being added/removed
            for (EventListener listener : listeners) {
                listener.onEvent(event);
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        EventPublisher publisher = new EventPublisher();
        
        // Add listeners
        EventListener listener1 = event -> 
            System.out.println("  Listener1 received: " + event);
        EventListener listener2 = event -> 
            System.out.println("  Listener2 received: " + event);
        EventListener listener3 = event -> 
            System.out.println("  Listener3 received: " + event);
        
        publisher.addListener(listener1);
        publisher.addListener(listener2);
        publisher.addListener(listener3);
        
        // Publish events
        publisher.publishEvent("Event1");
        
        // Remove listener while publishing (thread-safe!)
        new Thread(() -> publisher.removeListener(listener2)).start();
        Thread.sleep(10);
        
        publisher.publishEvent("Event2");
        
        System.out.println("\n‚úì No ConcurrentModificationException!");
        System.out.println("‚úì Listeners can be added/removed safely during publishing");
    }
}
```

---

## üíª Example 6: Snapshot Iteration

```java
import java.util.*;
import java.util.concurrent.*;

public class SnapshotIterationDemo {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(
            Arrays.asList("A", "B", "C")
        );
        
        System.out.println("Initial list: " + list);
        
        // Get iterator (creates snapshot)
        Iterator<String> iterator = list.iterator();
        
        System.out.println("\n=== Modifying list after getting iterator ===");
        list.add("D");
        list.add("E");
        list.remove("A");
        System.out.println("List after modifications: " + list);
        
        // Iterator still sees original snapshot
        System.out.println("\n=== What iterator sees ===");
        System.out.print("Iterator elements: ");
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        System.out.println("\n\nIterator sees: [A, B, C] (original snapshot)");
        System.out.println("Actual list: " + list);
        
        // New iterator sees current state
        System.out.println("\n=== New iterator ===");
        System.out.print("New iterator elements: ");
        for (String item : list) {
            System.out.print(item + " ");
        }
        
        System.out.println("\n\nKey Point: Iterators work on immutable snapshots");
    }
}
```

---

## üíª Example 7: When to Use CopyOnWriteArrayList

```java
import java.util.*;
import java.util.concurrent.*;

public class WhenToUseDemo {
    public static void main(String[] args) {
        System.out.println("=== Use Cases for CopyOnWriteArrayList ===\n");
        
        // Use Case 1: Event listeners/observers
        System.out.println("1. Event Listeners/Observers:");
        System.out.println("   - Listeners rarely added/removed");
        System.out.println("   - Events published frequently");
        System.out.println("   - Safe iteration during event firing\n");
        
        CopyOnWriteArrayList<String> listeners = new CopyOnWriteArrayList<>();
        listeners.add("Listener1");
        listeners.add("Listener2");
        
        // Can safely iterate and modify
        for (String listener : listeners) {
            System.out.println("   Notifying: " + listener);
            // Safe to add/remove listeners here
        }
        
        // Use Case 2: Configuration settings
        System.out.println("\n2. Configuration Settings:");
        System.out.println("   - Settings loaded once");
        System.out.println("   - Read frequently by many threads");
        System.out.println("   - Rarely modified\n");
        
        CopyOnWriteArrayList<String> config = new CopyOnWriteArrayList<>(
            Arrays.asList("setting1=value1", "setting2=value2")
        );
        
        // Many threads can read without locking
        String setting = config.get(0);
        System.out.println("   Read setting: " + setting);
        
        // Use Case 3: Cache with infrequent updates
        System.out.println("\n3. Cache with Infrequent Updates:");
        System.out.println("   - Data cached for quick access");
        System.out.println("   - Updated periodically");
        System.out.println("   - Read by many threads\n");
        
        // DON'T use when:
        System.out.println("=== DON'T Use When ===\n");
        System.out.println("‚úó Frequent writes (copying is expensive)");
        System.out.println("‚úó Large lists (copying overhead)");
        System.out.println("‚úó Memory-constrained environment");
        System.out.println("‚úó Need to see modifications during iteration");
        
        // Rule of thumb
        System.out.println("\n=== Rule of Thumb ===");
        System.out.println("Use if: (Reads / Writes) > 10:1");
        System.out.println("Example: 1000 reads, 10 writes per second ‚Üí ‚úì");
        System.out.println("Example: 100 reads, 100 writes per second ‚Üí ‚úó");
    }
}
```

---

## üíª Example 8: CopyOnWrite vs Synchronized

```java
import java.util.*;
import java.util.concurrent.*;

public class CopyOnWriteVsSynchronizedDemo {
    public static void main(String[] args) {
        System.out.println("=== CopyOnWriteArrayList vs Synchronized List ===\n");
        
        // Feature comparison
        System.out.println("1. Locking:");
        System.out.println("   CopyOnWrite: No read locking");
        System.out.println("   Synchronized: Locks on every operation\n");
        
        System.out.println("2. Iterator:");
        System.out.println("   CopyOnWrite: Fail-safe, works on snapshot");
        System.out.println("   Synchronized: Fail-fast, needs manual sync\n");
        
        System.out.println("3. Performance:");
        System.out.println("   CopyOnWrite: Fast reads, slow writes");
        System.out.println("   Synchronized: Consistent (both locked)\n");
        
        System.out.println("4. Memory:");
        System.out.println("   CopyOnWrite: Higher (creates copies)");
        System.out.println("   Synchronized: Lower\n");
        
        // Code comparison
        System.out.println("=== Code Examples ===\n");
        
        // Synchronized List
        System.out.println("Synchronized List:");
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        syncList.add("Item");
        
        // Must synchronize for iteration
        synchronized (syncList) {
            for (String item : syncList) {
                System.out.println("  " + item);
            }
        }
        System.out.println("  (Manual synchronization needed)\n");
        
        // CopyOnWriteArrayList
        System.out.println("CopyOnWriteArrayList:");
        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();
        cowList.add("Item");
        
        // No synchronization needed
        for (String item : cowList) {
            System.out.println("  " + item);
        }
        System.out.println("  (No manual synchronization)\n");
        
        // Decision guide
        System.out.println("=== When to Use Which ===");
        System.out.println("CopyOnWriteArrayList:");
        System.out.println("  ‚úì Read-heavy (90%+ reads)");
        System.out.println("  ‚úì Small to medium size");
        System.out.println("  ‚úì Fail-safe iteration needed");
        
        System.out.println("\nSynchronized List:");
        System.out.println("  ‚úì Balanced read/write");
        System.out.println("  ‚úì Large lists");
        System.out.println("  ‚úì Memory constrained");
    }
}
```

---

## üìä CopyOnWriteArrayList Characteristics

| Feature | Value |
|---------|-------|
| **Thread-safe** | Yes |
| **Synchronization** | Internal (copy-on-write) |
| **Iterator** | Fail-safe (snapshot) |
| **Null elements** | Allowed |
| **Duplicates** | Allowed |
| **Ordering** | Insertion order |
| **Read locking** | No |
| **Write locking** | Yes |
| **Best for** | Read-heavy scenarios |

---

## üìä Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **get(index)** | O(1) | No locking |
| **add(element)** | O(n) | Copies array |
| **add(index, element)** | O(n) | Copies array |
| **remove(index)** | O(n) | Copies array |
| **set(index, element)** | O(n) | Copies array |
| **contains(object)** | O(n) | Linear search |
| **iterator()** | O(1) | Returns snapshot |

---

## üìä CopyOnWrite vs Synchronized vs Concurrent

| Feature | CopyOnWriteArrayList | Collections.synchronizedList | ArrayList |
|---------|---------------------|------------------------------|-----------|
| **Thread-safe** | Yes | Yes | No |
| **Read locking** | No | Yes | N/A |
| **Write cost** | High (copy) | Medium | Low |
| **Read cost** | Low | Medium | Low |
| **Iterator** | Fail-safe | Fail-fast | Fail-fast |
| **Best for** | Read-heavy | Balanced | Single-threaded |
| **Memory** | High | Medium | Low |

---

## üí° Best Practices

1. ‚úÖ **Use for read-heavy scenarios**
   ```java
   // Good: 1000 reads, 10 writes
   CopyOnWriteArrayList<String> listeners = new CopyOnWriteArrayList<>();
   ```

2. ‚úÖ **Perfect for observers/listeners**
   ```java
   private CopyOnWriteArrayList<EventListener> listeners = 
       new CopyOnWriteArrayList<>();
   ```

3. ‚úÖ **No synchronization needed for iteration**
   ```java
   for (String item : cowList) {
       // Safe, no sync required
   }
   ```

4. ‚úÖ **Avoid for write-heavy scenarios**
   ```java
   // Bad: Frequent writes
   // Use Collections.synchronizedList() instead
   ```

5. ‚úÖ **Keep lists small to medium**
   ```java
   // Good: 10-1000 elements
   // Bad: 100,000+ elements (copying expensive)
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;
import java.util.concurrent.*;

public class CopyOnWritePitfalls {
    public static void main(String[] args) {
        // 1. Using for write-heavy operations
        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
        
        // BAD: Copying on every add!
        // for (int i = 0; i < 100000; i++) {
        //     list.add(i);  // Very slow!
        // }
        
        // GOOD: Use addAll for bulk operations
        List<Integer> temp = new ArrayList<>();
        for (int i = 0; i < 1000; i++) temp.add(i);
        list.addAll(temp);  // Single copy
        
        // 2. Iterator sees snapshot, not current state
        list = new CopyOnWriteArrayList<>(Arrays.asList(1, 2, 3));
        Iterator<Integer> it = list.iterator();
        list.add(4);
        
        System.out.println("List: " + list);
        System.out.print("Iterator sees: ");
        while (it.hasNext()) {
            System.out.print(it.next() + " ");
        }
        System.out.println("(no 4!)");
        
        // 3. High memory usage for large lists
        // CopyOnWriteArrayList<byte[]> huge = new CopyOnWriteArrayList<>();
        // huge.add(new byte[1000000]);  // Each write copies everything!
        
        // 4. iterator.remove() not supported
        list = new CopyOnWriteArrayList<>(Arrays.asList(1, 2, 3));
        Iterator<Integer> it2 = list.iterator();
        it2.next();
        try {
            it2.remove();  // UnsupportedOperationException!
        } catch (UnsupportedOperationException e) {
            System.out.println("\nError: iterator.remove() not supported");
        }
        
        System.out.println("\nKey Takeaway: Use only for read-heavy scenarios!");
    }
}
```

---

## üéØ Interview Questions

1. **What is CopyOnWriteArrayList?**
2. **How does copy-on-write mechanism work?**
3. **Is CopyOnWriteArrayList thread-safe?**
4. **What is a fail-safe iterator?**
5. **Difference between fail-fast and fail-safe?**
6. **When to use CopyOnWriteArrayList?**
7. **What is the time complexity of add()?**
8. **Why are write operations expensive?**
9. **Does iterator.remove() work?**
10. **CopyOnWrite vs Collections.synchronizedList()?**
11. **What does iterator see during iteration?**
12. **Best use case for CopyOnWriteArrayList?**
13. **Memory overhead of CopyOnWriteArrayList?**
14. **Can it contain null elements?**
15. **What happens when list is modified during iteration?**

---

## üìö Next Topics

- [ArrayList](02.%20ArrayList.md)
- [Vector](04.%20Vector.md)
- [Concurrent Collections](../07.%20Special%20Purpose%20Collections/01.%20Concurrent%20Collections.md)
- [Thread Safety](../12.%20Performance%20%26%20Best%20Practices/06.%20Thread%20Safety.md)
- [Fail-Fast vs Fail-Safe](../01.%20Collection%20Framework%20Overview/06.%20Fail-Fast%20vs%20Fail-Safe.md)
