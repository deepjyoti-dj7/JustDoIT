# üìä ArrayList

## üìñ Overview

**ArrayList** is a resizable array implementation of the List interface. It's one of the most commonly used collection classes in Java.

**Key Features:**
- Dynamic array that can grow/shrink automatically
- Fast random access O(1)
- Slower insertions/deletions O(n) in middle
- Not synchronized (not thread-safe)
- Allows null and duplicate elements
- Maintains insertion order

---

## üéØ ArrayList Internals

```
ArrayList internally:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Object[] elementData = new Object[10] ‚îÇ  ‚Üê Underlying array
‚îÇ  int size = 0                          ‚îÇ  ‚Üê Number of elements
‚îÇ  Default capacity = 10                 ‚îÇ  ‚Üê Initial size
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Growth:
Old capacity = 10
New capacity = old + (old >> 1) = 10 + 5 = 15  (50% growth)
```

---

## üíª Example 1: Creating ArrayList

```java
import java.util.*;

public class ArrayListCreationDemo {
    public static void main(String[] args) {
        // 1. Default constructor (capacity 10)
        ArrayList<String> list1 = new ArrayList<>();
        System.out.println("Empty ArrayList: " + list1);
        
        // 2. With initial capacity
        ArrayList<String> list2 = new ArrayList<>(20);
        System.out.println("With capacity 20: " + list2);
        
        // 3. From another collection
        List<String> source = Arrays.asList("A", "B", "C");
        ArrayList<String> list3 = new ArrayList<>(source);
        System.out.println("From collection: " + list3);
        
        // 4. Using Arrays.asList() (fixed size, then copy)
        ArrayList<Integer> list4 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("From Arrays.asList: " + list4);
        
        // 5. Using List.of() - Java 9+ (immutable, then copy)
        ArrayList<String> list5 = new ArrayList<>(List.of("X", "Y", "Z"));
        System.out.println("From List.of: " + list5);
        
        // 6. Anonymous inner class initialization
        ArrayList<String> list6 = new ArrayList<>() {{
            add("One");
            add("Two");
            add("Three");
        }};
        System.out.println("Anonymous initialization: " + list6);
        
        // 7. Stream-based creation (Java 8+)
        ArrayList<Integer> list7 = IntStream.range(1, 6)
                                           .boxed()
                                           .collect(Collectors.toCollection(ArrayList::new));
        System.out.println("From Stream: " + list7);
    }
}
```

---

## üíª Example 2: Add Operations

```java
import java.util.*;

public class ArrayListAddDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        
        // 1. add(E e) - Add to end
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        System.out.println("After add: " + list);
        
        // 2. add(int index, E element) - Add at position
        list.add(1, "Apricot");
        System.out.println("After add at index 1: " + list);
        
        // 3. addAll(Collection c) - Add all elements
        List<String> more = Arrays.asList("Date", "Elderberry");
        list.addAll(more);
        System.out.println("After addAll: " + list);
        
        // 4. addAll(int index, Collection c) - Add all at position
        list.addAll(2, Arrays.asList("Blueberry", "Cranberry"));
        System.out.println("After addAll at index 2: " + list);
        
        // 5. Add null
        list.add(null);
        System.out.println("After adding null: " + list);
        
        // 6. Add duplicate
        list.add("Apple");
        System.out.println("After adding duplicate: " + list);
        
        // Performance test
        System.out.println("\n=== Performance Test ===");
        ArrayList<Integer> numbers = new ArrayList<>();
        long start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            numbers.add(i);  // Add at end: O(1) amortized
        }
        long end = System.nanoTime();
        System.out.println("Add at end (100K elements): " + (end - start) + " ns");
        
        // Add at beginning (slower)
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            numbers.add(0, i);  // Add at beginning: O(n)
        }
        end = System.nanoTime();
        System.out.println("Add at beginning (1K elements): " + (end - start) + " ns");
    }
}
```

---

## üíª Example 3: Access and Modify Operations

```java
import java.util.*;

public class ArrayListAccessDemo {
    public static void main(String[] args) {
        ArrayList<String> fruits = new ArrayList<>(
            Arrays.asList("Apple", "Banana", "Cherry", "Date", "Elderberry")
        );
        
        System.out.println("Original list: " + fruits);
        
        // 1. get(int index) - O(1)
        String first = fruits.get(0);
        String last = fruits.get(fruits.size() - 1);
        System.out.println("First: " + first + ", Last: " + last);
        
        // 2. set(int index, E element) - Replace
        fruits.set(2, "Cranberry");
        System.out.println("After set at index 2: " + fruits);
        
        // 3. indexOf(Object o) - First occurrence
        System.out.println("Index of 'Banana': " + fruits.indexOf("Banana"));
        
        // 4. lastIndexOf(Object o) - Last occurrence
        fruits.add("Apple");  // Add duplicate
        System.out.println("Last index of 'Apple': " + fruits.lastIndexOf("Apple"));
        
        // 5. contains(Object o) - Check existence
        System.out.println("Contains 'Date': " + fruits.contains("Date"));
        
        // 6. isEmpty()
        System.out.println("Is empty: " + fruits.isEmpty());
        
        // 7. size()
        System.out.println("Size: " + fruits.size());
        
        // 8. toArray()
        String[] array = fruits.toArray(new String[0]);
        System.out.println("As array: " + Arrays.toString(array));
        
        // Performance: Random access
        ArrayList<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            numbers.add(i);
        }
        
        long start = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int value = numbers.get(i);  // O(1) - Very fast!
        }
        long end = System.nanoTime();
        System.out.println("\nRandom access (10K gets): " + (end - start) + " ns");
    }
}
```

---

## üíª Example 4: Remove Operations

```java
import java.util.*;

public class ArrayListRemoveDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(
            Arrays.asList("A", "B", "C", "D", "E", "F")
        );
        
        System.out.println("Original: " + list);
        
        // 1. remove(int index) - Remove by position
        String removed = list.remove(2);
        System.out.println("Removed element: " + removed);
        System.out.println("After remove(2): " + list);
        
        // 2. remove(Object o) - Remove first occurrence
        list.add("B");  // Add duplicate
        boolean success = list.remove("B");
        System.out.println("Removed 'B': " + success);
        System.out.println("After remove('B'): " + list);
        
        // 3. removeAll(Collection c) - Remove all matching
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E", "F"));
        list.removeAll(Arrays.asList("B", "D", "F"));
        System.out.println("After removeAll: " + list);
        
        // 4. retainAll(Collection c) - Keep only matching
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E", "F"));
        list.retainAll(Arrays.asList("B", "D", "F"));
        System.out.println("After retainAll: " + list);
        
        // 5. removeIf(Predicate) - Java 8+
        ArrayList<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
        numbers.removeIf(n -> n % 2 == 0);  // Remove even numbers
        System.out.println("After removeIf (even): " + numbers);
        
        // 6. clear() - Remove all
        list.clear();
        System.out.println("After clear: " + list + " (empty: " + list.isEmpty() + ")");
        
        // 7. removeRange (protected method - available in subclass)
        CustomArrayList<Integer> custom = new CustomArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
        custom.removeRange(2, 6);
        System.out.println("After removeRange(2, 6): " + custom);
    }
    
    static class CustomArrayList<E> extends ArrayList<E> {
        public CustomArrayList(Collection<? extends E> c) {
            super(c);
        }
        
        @Override
        public void removeRange(int fromIndex, int toIndex) {
            super.removeRange(fromIndex, toIndex);
        }
    }
}
```

---

## üíª Example 5: ArrayList Growth and Capacity

```java
import java.util.*;
import java.lang.reflect.*;

public class ArrayListCapacityDemo {
    public static void main(String[] args) throws Exception {
        ArrayList<Integer> list = new ArrayList<>();
        
        System.out.println("=== ArrayList Growth Demonstration ===");
        System.out.println("Initial capacity: " + getCapacity(list));
        
        // Add elements and observe capacity growth
        for (int i = 1; i <= 15; i++) {
            list.add(i);
            System.out.println("Size: " + i + ", Capacity: " + getCapacity(list));
        }
        
        System.out.println("\n=== Growth Formula ===");
        System.out.println("New capacity = old capacity + (old capacity >> 1)");
        System.out.println("Example: 10 + (10 >> 1) = 10 + 5 = 15");
        
        // Specify initial capacity
        System.out.println("\n=== With Initial Capacity ===");
        ArrayList<Integer> list2 = new ArrayList<>(25);
        System.out.println("Initial capacity (specified 25): " + getCapacity(list2));
        
        // ensureCapacity() method
        ArrayList<Integer> list3 = new ArrayList<>();
        list3.ensureCapacity(100);
        System.out.println("\nAfter ensureCapacity(100): " + getCapacity(list3));
        
        // trimToSize() method
        ArrayList<Integer> list4 = new ArrayList<>(100);
        for (int i = 0; i < 10; i++) {
            list4.add(i);
        }
        System.out.println("\nBefore trimToSize - Size: " + list4.size() + 
                          ", Capacity: " + getCapacity(list4));
        list4.trimToSize();
        System.out.println("After trimToSize - Size: " + list4.size() + 
                          ", Capacity: " + getCapacity(list4));
    }
    
    // Helper method to get capacity using reflection
    static int getCapacity(ArrayList<?> list) throws Exception {
        Field field = ArrayList.class.getDeclaredField("elementData");
        field.setAccessible(true);
        return ((Object[]) field.get(list)).length;
    }
}
```

---

## üíª Example 6: ArrayList Iteration and Modification

```java
import java.util.*;

public class ArrayListIterationDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        // 1. For-each loop (read-only)
        System.out.println("=== For-each loop ===");
        for (String item : list) {
            System.out.print(item + " ");
        }
        
        // 2. Traditional for loop
        System.out.println("\n\n=== Traditional for loop ===");
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + " ");
        }
        
        // 3. Iterator (can remove safely)
        System.out.println("\n\n=== Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (item.equals("C")) {
                iterator.remove();  // Safe removal
            }
        }
        System.out.println("After removing 'C': " + list);
        
        // 4. ListIterator (bidirectional)
        System.out.println("\n=== ListIterator ===");
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        ListIterator<String> listIter = list.listIterator();
        
        System.out.print("Forward: ");
        while (listIter.hasNext()) {
            System.out.print(listIter.next() + " ");
        }
        
        System.out.print("\nBackward: ");
        while (listIter.hasPrevious()) {
            System.out.print(listIter.previous() + " ");
        }
        
        // 5. forEach with lambda (Java 8+)
        System.out.println("\n\n=== forEach lambda ===");
        list.forEach(item -> System.out.print(item + " "));
        
        // 6. Stream (Java 8+)
        System.out.println("\n\n=== Stream ===");
        list.stream()
            .filter(s -> !s.equals("B"))
            .map(String::toLowerCase)
            .forEach(s -> System.out.print(s + " "));
        
        // 7. Indexed iteration with forEach (Java 9+)
        System.out.println("\n\n=== Indexed forEach ===");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(i + ": " + list.get(i));
        }
    }
}
```

---

## üíª Example 7: ArrayList Bulk Operations

```java
import java.util.*;
import java.util.stream.*;

public class ArrayListBulkOpsDemo {
    public static void main(String[] args) {
        // 1. addAll()
        ArrayList<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3));
        ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(4, 5, 6));
        list1.addAll(list2);
        System.out.println("After addAll: " + list1);
        
        // 2. removeAll() - Remove all elements in collection
        ArrayList<Integer> list3 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
        list3.removeAll(Arrays.asList(2, 4, 6, 8));
        System.out.println("After removeAll (evens): " + list3);
        
        // 3. retainAll() - Keep only elements in collection
        ArrayList<Integer> list4 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        list4.retainAll(Arrays.asList(2, 3, 4));
        System.out.println("After retainAll: " + list4);
        
        // 4. replaceAll() - Transform all elements (Java 8+)
        ArrayList<Integer> list5 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        list5.replaceAll(n -> n * n);
        System.out.println("After replaceAll (square): " + list5);
        
        // 5. removeIf() - Remove matching elements (Java 8+)
        ArrayList<Integer> list6 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        list6.removeIf(n -> n % 3 == 0);
        System.out.println("After removeIf (divisible by 3): " + list6);
        
        // 6. sort() - In-place sorting (Java 8+)
        ArrayList<String> list7 = new ArrayList<>(Arrays.asList("Charlie", "Alice", "Bob"));
        list7.sort(Comparator.naturalOrder());
        System.out.println("After sort: " + list7);
        
        // 7. Collections utility methods
        ArrayList<Integer> list8 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Collections.reverse(list8);
        System.out.println("After reverse: " + list8);
        
        Collections.shuffle(list8);
        System.out.println("After shuffle: " + list8);
        
        Collections.fill(list8, 0);
        System.out.println("After fill(0): " + list8);
    }
}
```

---

## üíª Example 8: ArrayList Thread-Safety

```java
import java.util.*;
import java.util.concurrent.*;

public class ArrayListThreadSafetyDemo {
    public static void main(String[] args) throws InterruptedException {
        // Problem: ArrayList is not thread-safe
        System.out.println("=== ArrayList (Not Thread-Safe) ===");
        ArrayList<Integer> unsafeList = new ArrayList<>();
        
        // Multiple threads adding to ArrayList
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                unsafeList.add(i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                unsafeList.add(i);
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("Expected size: 2000, Actual: " + unsafeList.size());
        
        // Solution 1: Collections.synchronizedList()
        System.out.println("\n=== Solution 1: Collections.synchronizedList ===");
        List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());
        
        Thread t3 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                syncList.add(i);
            }
        });
        
        Thread t4 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                syncList.add(i);
            }
        });
        
        t3.start();
        t4.start();
        t3.join();
        t4.join();
        
        System.out.println("Size: " + syncList.size());
        
        // Note: Must synchronize for iteration
        synchronized (syncList) {
            for (Integer num : syncList) {
                // Safe iteration
            }
        }
        
        // Solution 2: CopyOnWriteArrayList
        System.out.println("\n=== Solution 2: CopyOnWriteArrayList ===");
        List<Integer> cowList = new CopyOnWriteArrayList<>();
        
        Thread t5 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                cowList.add(i);
            }
        });
        
        Thread t6 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                cowList.add(i);
            }
        });
        
        t5.start();
        t6.start();
        t5.join();
        t6.join();
        
        System.out.println("Size: " + cowList.size());
        
        // Solution 3: Manual synchronization
        System.out.println("\n=== Solution 3: Manual Synchronization ===");
        ArrayList<Integer> list = new ArrayList<>();
        Object lock = new Object();
        
        Thread t7 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                synchronized (lock) {
                    list.add(i);
                }
            }
        });
        
        Thread t8 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                synchronized (lock) {
                    list.add(i);
                }
            }
        });
        
        t7.start();
        t8.start();
        t7.join();
        t8.join();
        
        System.out.println("Size: " + list.size());
    }
}
```

---

## üìä ArrayList Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **get(index)** | O(1) | Direct array access |
| **add(element)** | O(1) amortized | O(n) when resizing needed |
| **add(index, element)** | O(n) | Shift elements |
| **remove(index)** | O(n) | Shift elements |
| **remove(object)** | O(n) | Search + shift |
| **contains(object)** | O(n) | Linear search |
| **indexOf(object)** | O(n) | Linear search |
| **set(index, element)** | O(1) | Direct array access |
| **size()** | O(1) | Field access |
| **clear()** | O(n) | Set all to null |

---

## üìä ArrayList Space Complexity

- **Space**: O(n) where n is the number of elements
- **Internal array**: May have unused capacity (max 50% overhead)
- **Memory overhead per element**: ~4 bytes (object reference) + object size

---

## üí° Best Practices

1. ‚úÖ **Initialize with capacity if size is known**
   ```java
   ArrayList<String> list = new ArrayList<>(1000);  // Avoids resizing
   ```

2. ‚úÖ **Use trimToSize() after final additions**
   ```java
   list.trimToSize();  // Reduces memory footprint
   ```

3. ‚úÖ **Use ensureCapacity() for bulk additions**
   ```java
   list.ensureCapacity(list.size() + 5000);  // Before adding 5000 elements
   ```

4. ‚úÖ **Don't modify during iteration (use Iterator)**
   ```java
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       if (condition) it.remove();  // Safe
   }
   ```

5. ‚úÖ **Use ArrayList for random access**
   ```java
   List<String> list = new ArrayList<>();  // Fast get(index)
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class ArrayListPitfalls {
    public static void main(String[] args) {
        // 1. Not thread-safe
        ArrayList<Integer> list = new ArrayList<>();
        // Use Collections.synchronizedList() or CopyOnWriteArrayList for concurrency
        
        // 2. ConcurrentModificationException
        list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        try {
            for (Integer n : list) {
                if (n == 3) list.remove(n);  // Exception!
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("Cannot modify during iteration!");
        }
        
        // 3. autoboxing/unboxing confusion
        list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        list.remove(2);  // Removes element at index 2 (value 3)
        list.remove(Integer.valueOf(2));  // Removes value 2
        System.out.println("After removes: " + list);
        
        // 4. Inefficient insertions at beginning
        ArrayList<Integer> list2 = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            list2.add(0, i);  // Very slow! O(n) each time
        }
        // Use LinkedList for frequent insertions at beginning
        
        // 5. Not using initial capacity
        ArrayList<Integer> list3 = new ArrayList<>();  // Starts at 10, grows to 15, 22, 33...
        // Better: ArrayList<Integer> list3 = new ArrayList<>(10000);
    }
}
```

---

## üéØ Interview Questions

1. **How does ArrayList work internally?**
2. **What is the default capacity of ArrayList?**
3. **How does ArrayList grow?**
4. **What is the time complexity of get() and add()?**
5. **ArrayList vs Array?**
6. **How to make ArrayList thread-safe?**
7. **What is ensureCapacity() and trimToSize()?**
8. **Can ArrayList contain duplicates?**
9. **Can ArrayList contain null?**
10. **What is the difference between size() and capacity()?**
11. **How to remove duplicates from ArrayList?**
12. **How to convert ArrayList to Array?**
13. **What is ConcurrentModificationException?**
14. **When to use ArrayList vs LinkedList?**
15. **How to synchronize ArrayList?**

---

## üìö Next Topics

- [LinkedList](03.%20LinkedList.md)
- [ArrayList vs LinkedList](06.%20ArrayList%20vs%20LinkedList.md)
- [Vector](04.%20Vector.md)
- [CopyOnWriteArrayList](07.%20CopyOnWriteArrayList.md)
- [Time Complexity](../12.%20Performance%20%26%20Best%20Practices/01.%20Time%20Complexity.md)
