# üìö Stack

## üìñ Overview

**Stack** is a legacy class that extends Vector and implements LIFO (Last-In-First-Out) data structure.

**Key Features:**
- Extends Vector (inherits all Vector methods)
- LIFO operations: push, pop, peek
- Legacy class (since Java 1.0)
- Thread-safe (inherits synchronization from Vector)
- Deque is preferred alternative
- Used for: expression evaluation, backtracking, undo/redo

---

## üéØ Stack Operations

```
Stack Structure (LIFO):
    TOP ‚Üí [5]     ‚Üê pop() returns 5
          [4]
          [3]
          [2]
    BOTTOM ‚Üí [1]
    
push(6) ‚Üí [6] goes on top
pop()   ‚Üí removes top element
peek()  ‚Üí returns top without removing
```

---

## üíª Example 1: Basic Stack Operations

```java
import java.util.*;

public class StackBasicsDemo {
    public static void main(String[] args) {
        // Create Stack
        Stack<Integer> stack = new Stack<>();
        
        // 1. push() - Add to top
        stack.push(10);
        stack.push(20);
        stack.push(30);
        stack.push(40);
        stack.push(50);
        System.out.println("Stack: " + stack);
        
        // 2. pop() - Remove and return top
        int top = stack.pop();
        System.out.println("Popped: " + top);
        System.out.println("Stack after pop: " + stack);
        
        // 3. peek() - View top without removing
        int peeked = stack.peek();
        System.out.println("Peeked: " + peeked);
        System.out.println("Stack after peek: " + stack);
        
        // 4. empty() - Check if empty
        System.out.println("Is empty? " + stack.empty());
        
        // 5. search() - Position from top (1-indexed)
        int position = stack.search(20);
        System.out.println("Position of 20 from top: " + position);
        
        System.out.println("\nPosition explanation:");
        System.out.println("  40 is at position 1 (top)");
        System.out.println("  30 is at position 2");
        System.out.println("  20 is at position 3");
        System.out.println("  10 is at position 4");
        
        // search() returns -1 if not found
        System.out.println("Position of 100: " + stack.search(100));
        
        // Stack extends Vector, so Vector methods work
        System.out.println("\nSize: " + stack.size());
        System.out.println("Capacity: " + stack.capacity());
        System.out.println("Element at index 0: " + stack.get(0));
    }
}
```

**Output:**
```
Stack: [10, 20, 30, 40, 50]
Popped: 50
Stack after pop: [10, 20, 30, 40]
Peeked: 40
Stack after peek: [10, 20, 30, 40]
Is empty? false
Position of 20 from top: 3
...
```

---

## üíª Example 2: Stack for Balanced Parentheses

```java
import java.util.*;

public class BalancedParenthesesDemo {
    public static void main(String[] args) {
        String[] testCases = {
            "{[()]}",
            "{[(])}",
            "((()))",
            "({[}])",
            "(())()",
            "((("
        };
        
        for (String expr : testCases) {
            boolean result = isBalanced(expr);
            System.out.println(expr + " ‚Üí " + (result ? "Balanced ‚úì" : "Not Balanced ‚úó"));
        }
    }
    
    static boolean isBalanced(String expr) {
        Stack<Character> stack = new Stack<>();
        
        for (char ch : expr.toCharArray()) {
            // Push opening brackets
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            }
            // Pop and match closing brackets
            else if (ch == ')' || ch == '}' || ch == ']') {
                if (stack.empty()) {
                    return false;  // No matching opening
                }
                
                char top = stack.pop();
                if (!isMatchingPair(top, ch)) {
                    return false;  // Mismatch
                }
            }
        }
        
        return stack.empty();  // All opened must be closed
    }
    
    static boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')') ||
               (open == '{' && close == '}') ||
               (open == '[' && close == ']');
    }
}
```

**Output:**
```
{[()]} ‚Üí Balanced ‚úì
{[(])} ‚Üí Not Balanced ‚úó
((())) ‚Üí Balanced ‚úì
({[}]) ‚Üí Not Balanced ‚úó
(())() ‚Üí Balanced ‚úì
((( ‚Üí Not Balanced ‚úó
```

---

## üíª Example 3: Expression Evaluation (Postfix)

```java
import java.util.*;

public class PostfixEvaluationDemo {
    public static void main(String[] args) {
        String[] expressions = {
            "5 3 +",           // 5 + 3 = 8
            "5 3 + 2 *",       // (5 + 3) * 2 = 16
            "4 2 / 3 -",       // (4 / 2) - 3 = -1
            "10 5 + 60 6 / *"  // (10 + 5) * (60 / 6) = 150
        };
        
        for (String expr : expressions) {
            int result = evaluatePostfix(expr);
            System.out.println(expr + " = " + result);
        }
    }
    
    static int evaluatePostfix(String expr) {
        Stack<Integer> stack = new Stack<>();
        String[] tokens = expr.split(" ");
        
        for (String token : tokens) {
            // If operand, push to stack
            if (isOperand(token)) {
                stack.push(Integer.parseInt(token));
            }
            // If operator, pop two operands and apply
            else {
                int operand2 = stack.pop();  // Note: order matters!
                int operand1 = stack.pop();
                
                int result = applyOperator(token, operand1, operand2);
                stack.push(result);
            }
        }
        
        return stack.pop();  // Final result
    }
    
    static boolean isOperand(String token) {
        return !token.equals("+") && !token.equals("-") && 
               !token.equals("*") && !token.equals("/");
    }
    
    static int applyOperator(String operator, int a, int b) {
        switch (operator) {
            case "+": return a + b;
            case "-": return a - b;
            case "*": return a * b;
            case "/": return a / b;
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
}
```

**Output:**
```
5 3 + = 8
5 3 + 2 * = 16
4 2 / 3 - = -1
10 5 + 60 6 / * = 150
```

---

## üíª Example 4: Browser History (Back/Forward)

```java
import java.util.*;

public class BrowserHistoryDemo {
    static class Browser {
        private Stack<String> backStack = new Stack<>();
        private Stack<String> forwardStack = new Stack<>();
        private String currentPage;
        
        public void visit(String url) {
            if (currentPage != null) {
                backStack.push(currentPage);
            }
            currentPage = url;
            forwardStack.clear();  // Clear forward history
            System.out.println("Visited: " + url);
        }
        
        public void back() {
            if (backStack.empty()) {
                System.out.println("No previous page!");
                return;
            }
            
            forwardStack.push(currentPage);
            currentPage = backStack.pop();
            System.out.println("Back to: " + currentPage);
        }
        
        public void forward() {
            if (forwardStack.empty()) {
                System.out.println("No forward page!");
                return;
            }
            
            backStack.push(currentPage);
            currentPage = forwardStack.pop();
            System.out.println("Forward to: " + currentPage);
        }
        
        public void showStatus() {
            System.out.println("\n=== Browser Status ===");
            System.out.println("Current: " + currentPage);
            System.out.println("Back stack: " + backStack);
            System.out.println("Forward stack: " + forwardStack);
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        Browser browser = new Browser();
        
        browser.visit("google.com");
        browser.visit("youtube.com");
        browser.visit("facebook.com");
        browser.showStatus();
        
        browser.back();
        browser.showStatus();
        
        browser.back();
        browser.showStatus();
        
        browser.forward();
        browser.showStatus();
        
        browser.visit("twitter.com");  // Forward history cleared
        browser.showStatus();
        
        browser.forward();  // No forward page
    }
}
```

---

## üíª Example 5: Undo/Redo Functionality

```java
import java.util.*;

public class UndoRedoDemo {
    static class TextEditor {
        private StringBuilder content = new StringBuilder();
        private Stack<String> undoStack = new Stack<>();
        private Stack<String> redoStack = new Stack<>();
        
        public void write(String text) {
            undoStack.push(content.toString());  // Save current state
            content.append(text);
            redoStack.clear();  // Clear redo stack
            System.out.println("Write: " + text);
            System.out.println("Content: " + content);
        }
        
        public void undo() {
            if (undoStack.empty()) {
                System.out.println("Nothing to undo!");
                return;
            }
            
            redoStack.push(content.toString());
            content = new StringBuilder(undoStack.pop());
            System.out.println("Undo ‚Üí Content: " + content);
        }
        
        public void redo() {
            if (redoStack.empty()) {
                System.out.println("Nothing to redo!");
                return;
            }
            
            undoStack.push(content.toString());
            content = new StringBuilder(redoStack.pop());
            System.out.println("Redo ‚Üí Content: " + content);
        }
        
        public void showStacks() {
            System.out.println("Undo stack: " + undoStack);
            System.out.println("Redo stack: " + redoStack);
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        
        editor.write("Hello");
        editor.write(" World");
        editor.write("!");
        editor.showStacks();
        
        editor.undo();
        editor.showStacks();
        
        editor.undo();
        editor.showStacks();
        
        editor.redo();
        editor.showStacks();
        
        editor.write(" Java");  // Redo stack cleared
        editor.showStacks();
    }
}
```

---

## üíª Example 6: Stack vs Deque (Modern Alternative)

```java
import java.util.*;

public class StackVsDequeDemo {
    public static void main(String[] args) {
        System.out.println("=== Stack (Legacy) ===");
        Stack<String> stack = new Stack<>();
        stack.push("A");
        stack.push("B");
        stack.push("C");
        System.out.println("Stack: " + stack);
        System.out.println("Pop: " + stack.pop());
        System.out.println("Peek: " + stack.peek());
        
        System.out.println("\n=== Deque (Modern - Recommended) ===");
        Deque<String> deque = new ArrayDeque<>();
        deque.push("A");
        deque.push("B");
        deque.push("C");
        System.out.println("Deque: " + deque);
        System.out.println("Pop: " + deque.pop());
        System.out.println("Peek: " + deque.peek());
        
        // Performance comparison
        System.out.println("\n=== Performance Test (100K operations) ===");
        int size = 100000;
        
        long start = System.nanoTime();
        Stack<Integer> stackTest = new Stack<>();
        for (int i = 0; i < size; i++) {
            stackTest.push(i);
        }
        for (int i = 0; i < size; i++) {
            stackTest.pop();
        }
        long end = System.nanoTime();
        System.out.println("Stack: " + (end - start) / 1000000 + " ms");
        
        start = System.nanoTime();
        Deque<Integer> dequeTest = new ArrayDeque<>();
        for (int i = 0; i < size; i++) {
            dequeTest.push(i);
        }
        for (int i = 0; i < size; i++) {
            dequeTest.pop();
        }
        end = System.nanoTime();
        System.out.println("ArrayDeque: " + (end - start) / 1000000 + " ms");
        
        System.out.println("\nConclusion: ArrayDeque is faster (no synchronization)");
        System.out.println("Recommendation: Use Deque<E> = new ArrayDeque<>()");
    }
}
```

---

## üíª Example 7: Why Stack is Legacy

```java
import java.util.*;

public class WhyStackIsLegacyDemo {
    public static void main(String[] args) {
        System.out.println("=== Why Stack is Considered Legacy ===\n");
        
        // 1. Extends Vector (unnecessary synchronization)
        System.out.println("1. Extends Vector:");
        System.out.println("   - Inherits all Vector methods");
        System.out.println("   - Synchronized (thread-safe but slow)");
        System.out.println("   - Breaks Stack abstraction\n");
        
        Stack<String> stack = new Stack<>();
        stack.push("Top");
        stack.push("Middle");
        stack.push("Bottom");
        
        // Problem: Can access/modify middle elements (breaks LIFO)
        System.out.println("Stack: " + stack);
        stack.add(1, "Inserted");  // Inherited from Vector!
        System.out.println("After add(1, 'Inserted'): " + stack);
        System.out.println("This breaks LIFO principle!\n");
        
        // 2. Performance overhead
        System.out.println("2. Performance Overhead:");
        System.out.println("   - Synchronization on every operation");
        System.out.println("   - Slower than ArrayDeque\n");
        
        // 3. Limited API
        System.out.println("3. Limited API:");
        System.out.println("   - Only 5 Stack-specific methods");
        System.out.println("   - Deque has richer API\n");
        
        // 4. Modern Alternative
        System.out.println("4. Modern Alternative - Deque:");
        Deque<String> dequeStack = new ArrayDeque<>();
        dequeStack.push("A");
        dequeStack.push("B");
        System.out.println("Deque as Stack: " + dequeStack);
        
        // Cannot break LIFO with Deque (no index-based access)
        // dequeStack.add(1, "X");  // Compile error!
        
        System.out.println("\n=== Recommendation ===");
        System.out.println("DON'T: Stack<String> stack = new Stack<>();");
        System.out.println("DO:    Deque<String> stack = new ArrayDeque<>();");
    }
}
```

---

## üíª Example 8: Depth-First Search (DFS)

```java
import java.util.*;

public class DFSDemo {
    static class Graph {
        private Map<Integer, List<Integer>> adjList = new HashMap<>();
        
        public void addEdge(int from, int to) {
            adjList.putIfAbsent(from, new ArrayList<>());
            adjList.putIfAbsent(to, new ArrayList<>());
            adjList.get(from).add(to);
        }
        
        public void dfs(int start) {
            Set<Integer> visited = new HashSet<>();
            Stack<Integer> stack = new Stack<>();
            
            stack.push(start);
            System.out.print("DFS Traversal: ");
            
            while (!stack.empty()) {
                int node = stack.pop();
                
                if (!visited.contains(node)) {
                    System.out.print(node + " ");
                    visited.add(node);
                    
                    // Push neighbors in reverse order (for consistent order)
                    List<Integer> neighbors = adjList.getOrDefault(node, new ArrayList<>());
                    for (int i = neighbors.size() - 1; i >= 0; i--) {
                        int neighbor = neighbors.get(i);
                        if (!visited.contains(neighbor)) {
                            stack.push(neighbor);
                        }
                    }
                }
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        Graph graph = new Graph();
        
        // Build graph:
        //     1
        //    / \
        //   2   3
        //  / \   \
        // 4   5   6
        
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        graph.addEdge(2, 5);
        graph.addEdge(3, 6);
        
        graph.dfs(1);
        
        // Modern alternative using Deque
        System.out.println("\nUsing ArrayDeque instead:");
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(1);
        System.out.println("Stack: " + stack);
    }
}
```

---

## üìä Stack Methods

| Method | Description | Returns | Exception |
|--------|-------------|---------|-----------|
| **push(E item)** | Add to top | E | - |
| **pop()** | Remove and return top | E | EmptyStackException |
| **peek()** | View top | E | EmptyStackException |
| **empty()** | Check if empty | boolean | - |
| **search(Object o)** | Position from top (1-indexed) | int | - |

**Inherited from Vector:**
- `add()`, `remove()`, `get()`, `set()`, `size()`, etc.

---

## üìä Stack vs Deque

| Feature | Stack | ArrayDeque |
|---------|-------|------------|
| **LIFO operations** | ‚úì | ‚úì |
| **Thread-safe** | Yes | No |
| **Synchronization** | Yes | No |
| **Performance** | Slower | Faster |
| **Extends** | Vector | AbstractCollection |
| **Index access** | Yes (breaks LIFO) | No |
| **Recommended** | ‚ùå | ‚úÖ |
| **Since** | Java 1.0 | Java 1.6 |

---

## üìä Time Complexity

| Operation | Stack | ArrayDeque |
|-----------|-------|------------|
| **push()** | O(1) | O(1) |
| **pop()** | O(1) | O(1) |
| **peek()** | O(1) | O(1) |
| **search()** | O(n) | N/A |
| **empty()** | O(1) | O(1) |

---

## üí° Best Practices

1. ‚úÖ **Use Deque instead of Stack**
   ```java
   // Don't
   Stack<String> stack = new Stack<>();
   
   // Do
   Deque<String> stack = new ArrayDeque<>();
   ```

2. ‚úÖ **Check empty before pop/peek**
   ```java
   if (!stack.empty()) {
       String item = stack.pop();
   }
   ```

3. ‚úÖ **Use for LIFO operations only**
   ```java
   // Don't access middle elements
   // stack.get(index);  // Breaks LIFO abstraction
   ```

4. ‚úÖ **Clear after use**
   ```java
   stack.clear();  // Free memory
   ```

5. ‚úÖ **Use ArrayDeque for better performance**
   ```java
   Deque<String> stack = new ArrayDeque<>();
   stack.push("item");
   stack.pop();
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class StackPitfalls {
    public static void main(String[] args) {
        // 1. EmptyStackException
        Stack<String> stack = new Stack<>();
        try {
            stack.pop();  // Exception!
        } catch (EmptyStackException e) {
            System.out.println("Error: " + e.getClass().getSimpleName());
        }
        
        // Always check
        if (!stack.empty()) {
            stack.pop();
        }
        
        // 2. Breaking LIFO with inherited methods
        stack.push("A");
        stack.push("B");
        stack.push("C");
        
        // This breaks Stack abstraction!
        stack.add(1, "X");  // Inserts in middle
        System.out.println("Stack: " + stack);
        
        // 3. search() is 1-indexed (not 0-indexed)
        stack.clear();
        stack.push("A");
        stack.push("B");
        System.out.println("Position of B: " + stack.search("B"));  // 1, not 0!
        
        // 4. Performance in multi-threaded (unnecessary sync)
        // Use Deque instead for single-threaded
        
        // 5. Not clearing forward stack on new action
        Stack<String> backStack = new Stack<>();
        Stack<String> forwardStack = new Stack<>();
        
        forwardStack.push("page1");
        // When visiting new page:
        forwardStack.clear();  // Don't forget!
        
        System.out.println("\nKey Takeaway: Use ArrayDeque, not Stack!");
    }
}
```

---

## üéØ Interview Questions

1. **What is Stack in Java?**
2. **What are the main methods of Stack?**
3. **What does push() do?**
4. **Difference between pop() and peek()?**
5. **What exception does pop() throw?**
6. **Is Stack thread-safe?**
7. **Why is Stack considered legacy?**
8. **What is the alternative to Stack?**
9. **What does search() return?**
10. **Does Stack extend Vector?**
11. **Can Stack contain null?**
12. **How to check if Stack is empty?**
13. **Implement balanced parentheses check**
14. **Implement browser back/forward**
15. **Stack vs Deque - which is better?**

---

## üìö Next Topics

- [Vector](04.%20Vector.md)
- [ArrayDeque](../03.%20Queue%20Interface/05.%20ArrayDeque.md)
- [Deque Interface](../03.%20Queue%20Interface/01.%20Deque%20Interface.md)
- [ArrayList vs LinkedList](06.%20ArrayList%20vs%20LinkedList.md)
- [When to Use Which Collection](../12.%20Performance%20%26%20Best%20Practices/01.%20Choosing%20Right%20Collection.md)
