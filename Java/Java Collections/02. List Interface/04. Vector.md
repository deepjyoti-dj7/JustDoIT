# üîí Vector

## üìñ Overview

**Vector** is a legacy synchronized implementation of List interface. It's similar to ArrayList but with synchronized methods for thread-safety.

**Key Features:**
- Dynamic array (like ArrayList)
- Synchronized (thread-safe)
- Legacy class (since Java 1.0)
- Doubles capacity when full (vs 50% for ArrayList)
- Slower than ArrayList due to synchronization
- Stack class extends Vector
- Allows null and duplicates

---

## üéØ Vector vs ArrayList

```
Vector:
- Synchronized (thread-safe)
- Growth: 2x capacity
- Legacy (Java 1.0)
- Slower performance
- Stack extends it

ArrayList:
- Not synchronized
- Growth: 1.5x capacity
- Modern (Java 1.2)
- Faster performance
- Preferred choice
```

---

## üíª Example 1: Basic Vector Operations

```java
import java.util.*;

public class VectorBasicsDemo {
    public static void main(String[] args) {
        // Create Vector
        Vector<String> vector = new Vector<>();
        
        // 1. add()
        vector.add("Java");
        vector.add("Python");
        vector.add("JavaScript");
        System.out.println("Vector: " + vector);
        
        // 2. add at index
        vector.add(1, "C++");
        System.out.println("After add at index 1: " + vector);
        
        // 3. get()
        String element = vector.get(2);
        System.out.println("Element at index 2: " + element);
        
        // 4. set()
        vector.set(2, "Ruby");
        System.out.println("After set: " + vector);
        
        // 5. remove()
        vector.remove(1);
        System.out.println("After remove: " + vector);
        
        // 6. size() and capacity()
        System.out.println("Size: " + vector.size());
        System.out.println("Capacity: " + vector.capacity());
        
        // 7. firstElement() and lastElement()
        System.out.println("First: " + vector.firstElement());
        System.out.println("Last: " + vector.lastElement());
        
        // 8. elements() - Returns Enumeration (legacy)
        Enumeration<String> e = vector.elements();
        System.out.print("Elements: ");
        while (e.hasMoreElements()) {
            System.out.print(e.nextElement() + " ");
        }
    }
}
```

---

## üíª Example 2: Vector Capacity Management

```java
import java.util.*;

public class VectorCapacityDemo {
    public static void main(String[] args) {
        // Default constructor
        Vector<Integer> v1 = new Vector<>();
        System.out.println("Default - Size: " + v1.size() + ", Capacity: " + v1.capacity());
        
        // Constructor with initial capacity
        Vector<Integer> v2 = new Vector<>(20);
        System.out.println("Initial 20 - Size: " + v2.size() + ", Capacity: " + v2.capacity());
        
        // Constructor with capacity and increment
        Vector<Integer> v3 = new Vector<>(10, 5);  // Increment by 5 when full
        System.out.println("Capacity 10, Increment 5 - Capacity: " + v3.capacity());
        
        // Growth demonstration
        System.out.println("\n=== Growth Pattern ===");
        Vector<Integer> vector = new Vector<>(2);  // Start small
        System.out.println("Initial capacity: " + vector.capacity());
        
        for (int i = 0; i < 10; i++) {
            vector.add(i);
            System.out.println("Size: " + vector.size() + ", Capacity: " + vector.capacity());
        }
        
        // ensureCapacity()
        vector.ensureCapacity(50);
        System.out.println("\nAfter ensureCapacity(50): " + vector.capacity());
        
        // trimToSize()
        vector.trimToSize();
        System.out.println("After trimToSize(): " + vector.capacity());
        
        // setSize()
        vector.setSize(5);
        System.out.println("After setSize(5) - Size: " + vector.size() + ", Capacity: " + vector.capacity());
    }
}
```

---

## üíª Example 3: Vector Thread-Safety

```java
import java.util.*;

public class VectorThreadSafetyDemo {
    public static void main(String[] args) throws InterruptedException {
        // Vector is thread-safe
        Vector<Integer> vector = new Vector<>();
        
        // Multiple threads adding elements
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                vector.add(i);
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                vector.add(i);
            }
        });
        
        Thread t3 = new Thread(() -> {
            for (int i = 2000; i < 3000; i++) {
                vector.add(i);
            }
        });
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        System.out.println("Expected size: 3000");
        System.out.println("Actual size: " + vector.size());
        System.out.println("Thread-safe: No data lost!");
        
        // Compare with ArrayList (not thread-safe)
        System.out.println("\n=== ArrayList (Not Thread-Safe) ===");
        ArrayList<Integer> arrayList = new ArrayList<>();
        
        Thread t4 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                arrayList.add(i);
            }
        });
        
        Thread t5 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                arrayList.add(i);
            }
        });
        
        t4.start();
        t5.start();
        t4.join();
        t5.join();
        
        System.out.println("Expected size: 2000");
        System.out.println("Actual size: " + arrayList.size());
        if (arrayList.size() < 2000) {
            System.out.println("Data lost due to race condition!");
        }
    }
}
```

---

## üíª Example 4: Vector vs ArrayList Performance

```java
import java.util.*;

public class VectorPerformanceDemo {
    public static void main(String[] args) {
        int size = 100000;
        
        // Test 1: Add operations
        System.out.println("=== Add Operations (100K elements) ===");
        
        long start = System.nanoTime();
        ArrayList<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) / 1000000 + " ms");
        
        start = System.nanoTime();
        Vector<Integer> vector = new Vector<>();
        for (int i = 0; i < size; i++) {
            vector.add(i);
        }
        end = System.nanoTime();
        System.out.println("Vector: " + (end - start) / 1000000 + " ms");
        
        // Test 2: Get operations
        System.out.println("\n=== Get Operations (100K gets) ===");
        
        start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            arrayList.get(i);
        }
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) / 1000000 + " ms");
        
        start = System.nanoTime();
        for (int i = 0; i < size; i++) {
            vector.get(i);
        }
        end = System.nanoTime();
        System.out.println("Vector: " + (end - start) / 1000000 + " ms");
        
        // Test 3: Iteration
        System.out.println("\n=== Iteration ===");
        
        start = System.nanoTime();
        for (Integer num : arrayList) {
            // Iterate
        }
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) / 1000000 + " ms");
        
        start = System.nanoTime();
        for (Integer num : vector) {
            // Iterate
        }
        end = System.nanoTime();
        System.out.println("Vector: " + (end - start) / 1000000 + " ms");
        
        System.out.println("\nConclusion: ArrayList is faster due to no synchronization overhead");
    }
}
```

---

## üíª Example 5: Vector Legacy Methods

```java
import java.util.*;

public class VectorLegacyMethodsDemo {
    public static void main(String[] args) {
        Vector<String> vector = new Vector<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        // 1. firstElement() and lastElement()
        System.out.println("First element: " + vector.firstElement());
        System.out.println("Last element: " + vector.lastElement());
        
        // 2. elementAt(index) - like get()
        System.out.println("Element at 2: " + vector.elementAt(2));
        
        // 3. setElementAt(element, index) - like set()
        vector.setElementAt("X", 2);
        System.out.println("After setElementAt: " + vector);
        
        // 4. removeElementAt(index)
        vector.removeElementAt(2);
        System.out.println("After removeElementAt: " + vector);
        
        // 5. insertElementAt(element, index)
        vector.insertElementAt("Y", 2);
        System.out.println("After insertElementAt: " + vector);
        
        // 6. removeElement(object) - like remove(object)
        vector.removeElement("B");
        System.out.println("After removeElement: " + vector);
        
        // 7. removeAllElements() - like clear()
        Vector<String> temp = new Vector<>(vector);
        temp.removeAllElements();
        System.out.println("After removeAllElements: " + temp);
        
        // 8. elements() - Returns Enumeration
        System.out.println("\nUsing Enumeration:");
        Enumeration<String> enumeration = vector.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println("  " + enumeration.nextElement());
        }
        
        // 9. copyInto(array)
        String[] array = new String[vector.size()];
        vector.copyInto(array);
        System.out.println("\nCopied to array: " + Arrays.toString(array));
    }
}
```

---

## üíª Example 6: Why Vector is Legacy

```java
import java.util.*;

public class WhyVectorIsLegacyDemo {
    public static void main(String[] args) {
        System.out.println("=== Why Vector is Considered Legacy ===\n");
        
        // 1. Unnecessary synchronization overhead
        System.out.println("1. Performance Overhead:");
        System.out.println("   - Every method is synchronized");
        System.out.println("   - Slower than ArrayList even in single-threaded scenarios");
        System.out.println("   - Synchronization on every operation is overkill\n");
        
        // 2. Growth factor (doubles vs 50%)
        System.out.println("2. Memory Inefficiency:");
        Vector<Integer> vector = new Vector<>(10);
        System.out.println("   - Initial capacity: " + vector.capacity());
        for (int i = 0; i < 11; i++) vector.add(i);
        System.out.println("   - After 11 elements: " + vector.capacity() + " (doubled!)");
        System.out.println("   - ArrayList would grow to only 15 (50% increase)\n");
        
        // 3. Legacy API (Enumeration vs Iterator)
        System.out.println("3. Legacy API:");
        System.out.println("   - Uses Enumeration (old)");
        System.out.println("   - Iterator is preferred\n");
        
        // 4. Better alternatives exist
        System.out.println("4. Better Alternatives:\n");
        
        // Alternative 1: ArrayList with manual synchronization
        System.out.println("   a) ArrayList + synchronized block:");
        ArrayList<String> arrayList = new ArrayList<>();
        Object lock = new Object();
        synchronized (lock) {
            arrayList.add("Item");
        }
        
        // Alternative 2: Collections.synchronizedList()
        System.out.println("   b) Collections.synchronizedList():");
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        syncList.add("Item");
        
        // Alternative 3: CopyOnWriteArrayList
        System.out.println("   c) CopyOnWriteArrayList (for read-heavy):");
        List<String> cowList = new CopyOnWriteArrayList<>();
        cowList.add("Item");
        
        System.out.println("\nRecommendation: Use ArrayList for single-threaded,");
        System.out.println("Collections.synchronizedList() or CopyOnWriteArrayList for multi-threaded.");
    }
}
```

---

## üíª Example 7: Vector in Modern Code

```java
import java.util.*;

public class VectorModernAlternativesDemo {
    public static void main(String[] args) {
        // DON'T use Vector in new code
        // Vector<String> vector = new Vector<>();  // Legacy!
        
        System.out.println("=== Modern Alternatives to Vector ===\n");
        
        // Scenario 1: Single-threaded application
        System.out.println("1. Single-threaded: Use ArrayList");
        List<String> list1 = new ArrayList<>();
        list1.add("Item");
        System.out.println("   " + list1);
        
        // Scenario 2: Multi-threaded, balanced read/write
        System.out.println("\n2. Multi-threaded (balanced R/W): Collections.synchronizedList");
        List<String> list2 = Collections.synchronizedList(new ArrayList<>());
        list2.add("Item");
        
        // Must synchronize for iteration
        synchronized (list2) {
            for (String item : list2) {
                System.out.println("   " + item);
            }
        }
        
        // Scenario 3: Multi-threaded, read-heavy
        System.out.println("\n3. Multi-threaded (read-heavy): CopyOnWriteArrayList");
        List<String> list3 = new CopyOnWriteArrayList<>();
        list3.add("Item");
        
        // No synchronization needed for iteration
        for (String item : list3) {
            System.out.println("   " + item);
        }
        
        // Scenario 4: Need Stack (LIFO)
        System.out.println("\n4. Stack operations: Use Deque");
        Deque<String> stack = new ArrayDeque<>();  // NOT Stack class!
        stack.push("Bottom");
        stack.push("Top");
        System.out.println("   Pop: " + stack.pop());
        
        // Performance comparison
        System.out.println("\n=== Performance Comparison ===");
        int size = 50000;
        
        long start = System.nanoTime();
        Vector<Integer> vector = new Vector<>();
        for (int i = 0; i < size; i++) vector.add(i);
        long end = System.nanoTime();
        System.out.println("Vector: " + (end - start) / 1000000 + " ms");
        
        start = System.nanoTime();
        ArrayList<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) arrayList.add(i);
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) / 1000000 + " ms");
    }
}
```

---

## üíª Example 8: When You Might Still Use Vector

```java
import java.util.*;

public class WhenToUseVectorDemo {
    public static void main(String[] args) {
        System.out.println("=== Rare Cases Where Vector Might Be Used ===\n");
        
        // 1. Legacy codebase
        System.out.println("1. Working with legacy code that uses Vector");
        System.out.println("   - Maintaining old applications");
        System.out.println("   - API compatibility\n");
        
        // 2. Stack class extends Vector
        System.out.println("2. Using Stack class (which extends Vector)");
        Stack<String> stack = new Stack<>();
        stack.push("Item");
        System.out.println("   Stack: " + stack);
        System.out.println("   But prefer: Deque<String> = new ArrayDeque<>()\n");
        
        // 3. Simple thread-safe list needed
        System.out.println("3. Very simple thread-safe list");
        Vector<String> vector = new Vector<>();
        
        // Multiple threads can safely add
        Thread t1 = new Thread(() -> vector.add("Thread1"));
        Thread t2 = new Thread(() -> vector.add("Thread2"));
        
        try {
            t1.start();
            t2.start();
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println("   Vector: " + vector);
        System.out.println("   But better: Collections.synchronizedList()\n");
        
        // Decision tree
        System.out.println("=== Decision Tree ===");
        System.out.println("Need thread-safety?");
        System.out.println("  No  ‚Üí ArrayList");
        System.out.println("  Yes ‚Üí Read-heavy? ");
        System.out.println("          Yes ‚Üí CopyOnWriteArrayList");
        System.out.println("          No  ‚Üí Collections.synchronizedList(new ArrayList<>())");
        System.out.println("\nVector: Use only for legacy compatibility");
    }
}
```

---

## üìä Vector vs ArrayList vs Collections.synchronizedList()

| Feature | Vector | ArrayList | Collections.synchronizedList() |
|---------|--------|-----------|-------------------------------|
| **Thread-safe** | Yes | No | Yes |
| **Synchronization** | Method-level | None | Method-level |
| **Growth** | 100% (doubles) | 50% | 50% |
| **Performance** | Slow | Fast | Medium |
| **Legacy** | Yes (Java 1.0) | No (Java 1.2) | No |
| **Iteration sync** | Not required | N/A | Required |
| **Use case** | Legacy code | Single-threaded | Multi-threaded |

---

## üìä Vector Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(element)** | O(1) amortized | Synchronized |
| **add(index, element)** | O(n) | Synchronized + shift |
| **get(index)** | O(1) | Synchronized |
| **set(index, element)** | O(1) | Synchronized |
| **remove(index)** | O(n) | Synchronized + shift |
| **contains(object)** | O(n) | Synchronized + search |
| **size()** | O(1) | Synchronized |

---

## üí° Best Practices

1. ‚úÖ **Avoid Vector in new code**
   ```java
   // Don't
   Vector<String> vector = new Vector<>();
   
   // Do
   List<String> list = new ArrayList<>();
   ```

2. ‚úÖ **Use Collections.synchronizedList() for thread-safety**
   ```java
   List<String> syncList = Collections.synchronizedList(new ArrayList<>());
   ```

3. ‚úÖ **Synchronize iteration manually**
   ```java
   synchronized (syncList) {
       for (String item : syncList) {
           // Safe iteration
       }
   }
   ```

4. ‚úÖ **Consider CopyOnWriteArrayList for read-heavy scenarios**
   ```java
   List<String> cowList = new CopyOnWriteArrayList<>();
   ```

5. ‚úÖ **Use Deque instead of Stack**
   ```java
   Deque<String> stack = new ArrayDeque<>();  // Not Stack!
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class VectorPitfalls {
    public static void main(String[] args) {
        // 1. Using Vector when ArrayList would suffice
        // Vector<String> list = new Vector<>();  // Unnecessary overhead!
        List<String> list = new ArrayList<>();  // Better
        
        // 2. Assuming Vector is always thread-safe
        Vector<Integer> vector = new Vector<>();
        
        // Individual operations are atomic, but compound operations are NOT:
        // if (!vector.isEmpty()) {
        //     vector.remove(0);  // Race condition! Another thread might empty it
        // }
        
        // Correct way:
        synchronized (vector) {
            if (!vector.isEmpty()) {
                vector.remove(0);
            }
        }
        
        // 3. Iteration without synchronization (with synchronizedList)
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        syncList.add("Item");
        
        // Wrong:
        // for (String item : syncList) {  // May throw ConcurrentModificationException
        // }
        
        // Correct:
        synchronized (syncList) {
            for (String item : syncList) {
                // Safe
            }
        }
        
        // 4. Not knowing about capacity doubling
        Vector<Integer> v = new Vector<>(100);
        System.out.println("Capacity: " + v.capacity());
        for (int i = 0; i < 101; i++) v.add(i);
        System.out.println("After 101 adds: " + v.capacity());  // 200! Wasteful
        
        System.out.println("\nKey Takeaway: Avoid Vector in modern Java code!");
    }
}
```

---

## üéØ Interview Questions

1. **What is Vector in Java?**
2. **Difference between Vector and ArrayList?**
3. **Is Vector thread-safe?**
4. **How does Vector grow its capacity?**
5. **Why is Vector considered legacy?**
6. **What is the default capacity of Vector?**
7. **What is Enumeration?**
8. **Difference between Iterator and Enumeration?**
9. **Can Vector contain null elements?**
10. **What class extends Vector?**
11. **How to make ArrayList thread-safe?**
12. **What is the performance impact of synchronization?**
13. **When should you use Vector?**
14. **What are alternatives to Vector?**
15. **What is Collections.synchronizedList()?**

---

## üìö Next Topics

- [Stack](05.%20Stack.md)
- [ArrayList](02.%20ArrayList.md)
- [CopyOnWriteArrayList](07.%20CopyOnWriteArrayList.md)
- [Synchronized Collections](../07.%20Special%20Purpose%20Collections/03.%20Synchronized%20Collections.md)
- [Thread Safety](../12.%20Performance%20%26%20Best%20Practices/06.%20Thread%20Safety.md)
