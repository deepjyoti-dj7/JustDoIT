# üîó LinkedList

## üìñ Overview

**LinkedList** is a doubly-linked list implementation of the List and Deque interfaces. Each element (node) contains data and references to both the next and previous nodes.

**Key Features:**
- Doubly-linked list structure
- Fast insertions/deletions O(1) at ends
- Slow random access O(n)
- Not synchronized (not thread-safe)
- Implements both List and Deque
- Allows null and duplicate elements
- More memory overhead than ArrayList

---

## üéØ LinkedList Internals

```
LinkedList Node Structure:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  class Node<E> {             ‚îÇ
‚îÇ    E item;                   ‚îÇ  ‚Üê Data
‚îÇ    Node<E> next;             ‚îÇ  ‚Üê Reference to next node
‚îÇ    Node<E> prev;             ‚îÇ  ‚Üê Reference to previous node
‚îÇ  }                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Structure:
null ‚Üê [A] ‚Üî [B] ‚Üî [C] ‚Üî [D] ‚Üí null
       ‚Üë                    ‚Üë
      first               last
```

---

## üíª Example 1: Creating LinkedList

```java
import java.util.*;

public class LinkedListCreationDemo {
    public static void main(String[] args) {
        // 1. Default constructor
        LinkedList<String> list1 = new LinkedList<>();
        System.out.println("Empty LinkedList: " + list1);
        
        // 2. From another collection
        List<String> source = Arrays.asList("A", "B", "C");
        LinkedList<String> list2 = new LinkedList<>(source);
        System.out.println("From collection: " + list2);
        
        // 3. Using addAll
        LinkedList<Integer> list3 = new LinkedList<>();
        list3.addAll(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("Using addAll: " + list3);
        
        // 4. Using Stream (Java 8+)
        LinkedList<Integer> list4 = IntStream.range(1, 6)
                                            .boxed()
                                            .collect(Collectors.toCollection(LinkedList::new));
        System.out.println("From Stream: " + list4);
        
        // 5. Anonymous inner class
        LinkedList<String> list5 = new LinkedList<>() {{
            add("First");
            add("Second");
            add("Third");
        }};
        System.out.println("Anonymous initialization: " + list5);
    }
}
```

---

## üíª Example 2: List Operations

```java
import java.util.*;

public class LinkedListOperationsDemo {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        
        // 1. add() - Add to end
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        System.out.println("After add: " + list);
        
        // 2. add(index, element)
        list.add(1, "Apricot");
        System.out.println("After add at index 1: " + list);
        
        // 3. get(index)
        String element = list.get(2);
        System.out.println("Element at index 2: " + element);
        
        // 4. set(index, element)
        list.set(2, "Blueberry");
        System.out.println("After set: " + list);
        
        // 5. remove(index)
        String removed = list.remove(1);
        System.out.println("Removed: " + removed);
        System.out.println("After remove: " + list);
        
        // 6. indexOf()
        list.add("Apple");  // Duplicate
        System.out.println("Index of 'Apple': " + list.indexOf("Apple"));
        System.out.println("Last index of 'Apple': " + list.lastIndexOf("Apple"));
        
        // 7. contains()
        System.out.println("Contains 'Banana': " + list.contains("Banana"));
        
        // 8. size()
        System.out.println("Size: " + list.size());
        
        // 9. clear()
        list.clear();
        System.out.println("After clear: " + list + " (empty: " + list.isEmpty() + ")");
    }
}
```

---

## üíª Example 3: Deque Operations (Special Features)

```java
import java.util.*;

public class LinkedListDequeDemo {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>();
        
        // First element operations
        System.out.println("=== First Element Operations ===");
        list.addFirst("A");
        list.addFirst("B");
        list.addFirst("C");
        System.out.println("After addFirst: " + list);  // [C, B, A]
        
        System.out.println("getFirst(): " + list.getFirst());
        System.out.println("peekFirst(): " + list.peekFirst());
        
        String removed = list.removeFirst();
        System.out.println("removeFirst(): " + removed);
        System.out.println("After removeFirst: " + list);
        
        // Last element operations
        System.out.println("\n=== Last Element Operations ===");
        list.addLast("X");
        list.addLast("Y");
        list.addLast("Z");
        System.out.println("After addLast: " + list);
        
        System.out.println("getLast(): " + list.getLast());
        System.out.println("peekLast(): " + list.peekLast());
        
        removed = list.removeLast();
        System.out.println("removeLast(): " + removed);
        System.out.println("After removeLast: " + list);
        
        // Offer/Poll operations (Queue interface)
        System.out.println("\n=== Queue Operations ===");
        list.offer("End");      // Add to end
        list.offerFirst("Start");
        list.offerLast("Finish");
        System.out.println("After offers: " + list);
        
        System.out.println("poll(): " + list.poll());      // Remove from front
        System.out.println("pollFirst(): " + list.pollFirst());
        System.out.println("pollLast(): " + list.pollLast());
        System.out.println("After polls: " + list);
        
        // Push/Pop operations (Stack interface)
        System.out.println("\n=== Stack Operations ===");
        LinkedList<Integer> stack = new LinkedList<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println("After pushes: " + stack);  // [3, 2, 1]
        
        System.out.println("pop(): " + stack.pop());
        System.out.println("pop(): " + stack.pop());
        System.out.println("After pops: " + stack);
    }
}
```

---

## üíª Example 4: LinkedList vs ArrayList Performance

```java
import java.util.*;

public class LinkedListPerformanceDemo {
    public static void main(String[] args) {
        int size = 100000;
        
        // Test 1: Add at end
        System.out.println("=== Add at End ===");
        
        long start = System.nanoTime();
        ArrayList<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) + " ns");
        
        start = System.nanoTime();
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        end = System.nanoTime();
        System.out.println("LinkedList: " + (end - start) + " ns");
        
        // Test 2: Add at beginning
        System.out.println("\n=== Add at Beginning (10K elements) ===");
        
        start = System.nanoTime();
        arrayList = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            arrayList.add(0, i);  // Slow: shifts all elements
        }
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) + " ns");
        
        start = System.nanoTime();
        linkedList = new LinkedList<>();
        for (int i = 0; i < 10000; i++) {
            linkedList.addFirst(i);  // Fast: O(1)
        }
        end = System.nanoTime();
        System.out.println("LinkedList: " + (end - start) + " ns");
        
        // Test 3: Random access
        System.out.println("\n=== Random Access (10K gets) ===");
        
        arrayList = new ArrayList<>();
        linkedList = new LinkedList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        start = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int val = arrayList.get(i);  // Fast: O(1)
        }
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) + " ns");
        
        start = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            int val = linkedList.get(i);  // Slow: O(n)
        }
        end = System.nanoTime();
        System.out.println("LinkedList: " + (end - start) + " ns");
        
        // Test 4: Iterator traversal
        System.out.println("\n=== Iterator Traversal ===");
        
        start = System.nanoTime();
        for (Integer num : arrayList) {
            // Traverse
        }
        end = System.nanoTime();
        System.out.println("ArrayList: " + (end - start) + " ns");
        
        start = System.nanoTime();
        for (Integer num : linkedList) {
            // Traverse
        }
        end = System.nanoTime();
        System.out.println("LinkedList: " + (end - start) + " ns");
    }
}
```

---

## üíª Example 5: LinkedList as Queue

```java
import java.util.*;

public class LinkedListQueueDemo {
    public static void main(String[] args) {
        // FIFO Queue implementation
        Queue<String> queue = new LinkedList<>();
        
        System.out.println("=== FIFO Queue (LinkedList) ===");
        
        // Enqueue (add to rear)
        queue.offer("Customer 1");
        queue.offer("Customer 2");
        queue.offer("Customer 3");
        System.out.println("Queue: " + queue);
        
        // Peek (view front without removing)
        System.out.println("Peek: " + queue.peek());
        System.out.println("Queue after peek: " + queue);
        
        // Dequeue (remove from front)
        System.out.println("Poll: " + queue.poll());
        System.out.println("Poll: " + queue.poll());
        System.out.println("Queue after polls: " + queue);
        
        // Check if empty
        System.out.println("Is empty: " + queue.isEmpty());
        
        // Real-world example: Task Queue
        System.out.println("\n=== Task Queue Example ===");
        Queue<Task> taskQueue = new LinkedList<>();
        
        taskQueue.offer(new Task("Process Payment", 1));
        taskQueue.offer(new Task("Send Email", 2));
        taskQueue.offer(new Task("Update Database", 3));
        
        while (!taskQueue.isEmpty()) {
            Task task = taskQueue.poll();
            task.execute();
        }
    }
    
    static class Task {
        String name;
        int priority;
        
        Task(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }
        
        void execute() {
            System.out.println("Executing: " + name + " (Priority: " + priority + ")");
        }
    }
}
```

---

## üíª Example 6: LinkedList as Stack

```java
import java.util.*;

public class LinkedListStackDemo {
    public static void main(String[] args) {
        // LIFO Stack implementation
        Deque<String> stack = new LinkedList<>();
        
        System.out.println("=== LIFO Stack (LinkedList) ===");
        
        // Push (add to top)
        stack.push("Bottom");
        stack.push("Middle");
        stack.push("Top");
        System.out.println("Stack: " + stack);
        
        // Peek (view top without removing)
        System.out.println("Peek: " + stack.peek());
        
        // Pop (remove from top)
        System.out.println("Pop: " + stack.pop());
        System.out.println("Pop: " + stack.pop());
        System.out.println("Stack after pops: " + stack);
        
        // Real-world example: Browser History
        System.out.println("\n=== Browser History Example ===");
        Deque<String> history = new LinkedList<>();
        
        history.push("google.com");
        history.push("stackoverflow.com");
        history.push("github.com");
        history.push("leetcode.com");
        
        System.out.println("Current page: " + history.peek());
        
        System.out.println("\nGoing back:");
        while (!history.isEmpty()) {
            System.out.println("  " + history.pop());
        }
        
        // Undo/Redo example
        System.out.println("\n=== Undo/Redo Example ===");
        Deque<String> undoStack = new LinkedList<>();
        Deque<String> redoStack = new LinkedList<>();
        
        // Perform actions
        undoStack.push("Type 'Hello'");
        undoStack.push("Type 'World'");
        undoStack.push("Type '!'");
        
        System.out.println("Current state: " + undoStack);
        
        // Undo
        String undone = undoStack.pop();
        redoStack.push(undone);
        System.out.println("After undo: " + undoStack);
        System.out.println("Can redo: " + redoStack);
        
        // Redo
        String redone = redoStack.pop();
        undoStack.push(redone);
        System.out.println("After redo: " + undoStack);
    }
}
```

---

## üíª Example 7: LinkedList Iteration

```java
import java.util.*;

public class LinkedListIterationDemo {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<>(
            Arrays.asList("Java", "Python", "JavaScript", "C++", "Ruby")
        );
        
        // 1. For-each loop
        System.out.println("=== For-each loop ===");
        for (String lang : list) {
            System.out.print(lang + " ");
        }
        
        // 2. Iterator
        System.out.println("\n\n=== Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        
        // 3. ListIterator (bidirectional)
        System.out.println("\n\n=== ListIterator ===");
        ListIterator<String> listIterator = list.listIterator();
        
        System.out.print("Forward: ");
        while (listIterator.hasNext()) {
            System.out.print(listIterator.next() + " ");
        }
        
        System.out.print("\nBackward: ");
        while (listIterator.hasPrevious()) {
            System.out.print(listIterator.previous() + " ");
        }
        
        // 4. descendingIterator() - Special for LinkedList
        System.out.println("\n\n=== descendingIterator ===");
        Iterator<String> descending = list.descendingIterator();
        while (descending.hasNext()) {
            System.out.print(descending.next() + " ");
        }
        
        // 5. forEach with lambda
        System.out.println("\n\n=== forEach lambda ===");
        list.forEach(lang -> System.out.print(lang + " "));
        
        // 6. Stream
        System.out.println("\n\n=== Stream ===");
        list.stream()
            .filter(lang -> lang.length() > 4)
            .forEach(lang -> System.out.print(lang + " "));
    }
}
```

---

## üíª Example 8: LinkedList Practical Examples

```java
import java.util.*;

public class LinkedListPracticalDemo {
    public static void main(String[] args) {
        // Example 1: LRU Cache using LinkedList
        System.out.println("=== LRU Cache Example ===");
        LRUCache<Integer, String> cache = new LRUCache<>(3);
        
        cache.put(1, "One");
        cache.put(2, "Two");
        cache.put(3, "Three");
        System.out.println("Cache: " + cache);
        
        cache.get(1);  // Access 1
        cache.put(4, "Four");  // Evicts 2 (least recently used)
        System.out.println("After adding 4: " + cache);
        
        // Example 2: Playlist
        System.out.println("\n=== Music Playlist ===");
        LinkedList<String> playlist = new LinkedList<>();
        playlist.add("Song 1");
        playlist.add("Song 2");
        playlist.add("Song 3");
        
        System.out.println("Now playing: " + playlist.getFirst());
        System.out.println("Next: " + playlist.get(1));
        
        // Move to next song
        playlist.removeFirst();
        System.out.println("Now playing: " + playlist.getFirst());
        
        // Example 3: Navigation history
        System.out.println("\n=== Navigation History ===");
        NavigationHistory nav = new NavigationHistory();
        nav.visit("Home");
        nav.visit("Products");
        nav.visit("Cart");
        nav.visit("Checkout");
        
        nav.back();
        nav.back();
        nav.forward();
        nav.visit("Payment");  // Clears forward history
    }
    
    static class LRUCache<K, V> extends LinkedHashMap<K, V> {
        private int capacity;
        
        public LRUCache(int capacity) {
            super(capacity, 0.75f, true);  // Access order
            this.capacity = capacity;
        }
        
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > capacity;
        }
    }
    
    static class NavigationHistory {
        private LinkedList<String> backStack = new LinkedList<>();
        private LinkedList<String> forwardStack = new LinkedList<>();
        private String current;
        
        void visit(String page) {
            if (current != null) {
                backStack.push(current);
            }
            current = page;
            forwardStack.clear();
            System.out.println("Visited: " + page);
        }
        
        void back() {
            if (!backStack.isEmpty()) {
                forwardStack.push(current);
                current = backStack.pop();
                System.out.println("Back to: " + current);
            }
        }
        
        void forward() {
            if (!forwardStack.isEmpty()) {
                backStack.push(current);
                current = forwardStack.pop();
                System.out.println("Forward to: " + current);
            }
        }
    }
}
```

---

## üìä LinkedList Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **addFirst()/addLast()** | O(1) | Direct pointer manipulation |
| **add(element)** | O(1) | Adds to end |
| **add(index, element)** | O(n) | Must traverse to index |
| **removeFirst()/removeLast()** | O(1) | Direct pointer manipulation |
| **remove(index)** | O(n) | Must traverse to index |
| **get(index)** | O(n) | Must traverse to index |
| **set(index, element)** | O(n) | Must traverse to index |
| **contains(object)** | O(n) | Linear search |
| **size()** | O(1) | Field access |
| **Iterator operations** | O(1) per operation | Sequential access |

---

## üìä LinkedList vs ArrayList

| Feature | LinkedList | ArrayList |
|---------|-----------|-----------|
| **Structure** | Doubly-linked list | Dynamic array |
| **Random access** | O(n) - Slow | O(1) - Fast |
| **Add at end** | O(1) | O(1) amortized |
| **Add at beginning** | O(1) - Fast | O(n) - Slow |
| **Add in middle** | O(n) | O(n) |
| **Remove** | O(1) if node known | O(n) |
| **Memory** | Higher (node overhead) | Lower |
| **Best for** | Frequent insert/delete | Random access |

---

## üí° Best Practices

1. ‚úÖ **Use LinkedList for frequent insertions/deletions**
   ```java
   LinkedList<String> list = new LinkedList<>();  // Good for deque operations
   ```

2. ‚úÖ **Use as Queue/Deque**
   ```java
   Queue<String> queue = new LinkedList<>();
   Deque<String> deque = new LinkedList<>();
   ```

3. ‚úÖ **Avoid get(index) in loops**
   ```java
   // Bad: O(n¬≤)
   for (int i = 0; i < list.size(); i++) {
       list.get(i);
   }
   
   // Good: O(n)
   for (String item : list) {
       // Use item
   }
   ```

4. ‚úÖ **Use iterator for traversal**
   ```java
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       String item = it.next();
   }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class LinkedListPitfalls {
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // 1. Inefficient random access
        // Bad: O(n¬≤) complexity
        long start = System.nanoTime();
        for (int i = 0; i < list.size(); i++) {
            int val = list.get(i);  // Each get() is O(n)!
        }
        long end = System.nanoTime();
        System.out.println("Bad approach: " + (end - start) + " ns");
        
        // Good: O(n) complexity
        start = System.nanoTime();
        for (Integer val : list) {  // Iterator is O(1) per element
            // Process val
        }
        end = System.nanoTime();
        System.out.println("Good approach: " + (end - start) + " ns");
        
        // 2. Not using Deque interface
        // LinkedList<String> stack = new LinkedList<>();  // Less flexible
        Deque<String> stack = new LinkedList<>();  // Better
        
        // 3. Using when ArrayList would be better
        // If you need random access, use ArrayList instead
        
        // 4. Memory overhead
        // Each node has 2 extra references (next, prev)
        // Consider ArrayList if memory is critical
        
        System.out.println("\nLinkedList is best for:");
        System.out.println("- Frequent insertions/deletions at ends");
        System.out.println("- Queue/Deque implementations");
        System.out.println("- When you iterate sequentially");
        
        System.out.println("\nUse ArrayList when:");
        System.out.println("- Random access is frequent");
        System.out.println("- Memory efficiency matters");
        System.out.println("- Mostly reading, few modifications");
    }
}
```

---

## üéØ Interview Questions

1. **How does LinkedList work internally?**
2. **What is a doubly-linked list?**
3. **LinkedList vs ArrayList?**
4. **When to use LinkedList?**
5. **Time complexity of get() in LinkedList?**
6. **Can LinkedList be used as Stack/Queue?**
7. **What interfaces does LinkedList implement?**
8. **What is the difference between add() and offer()?**
9. **What is descendingIterator()?**
10. **How much memory does LinkedList use?**
11. **Why is LinkedList slower for random access?**
12. **What are first/last operations?**
13. **How to make LinkedList thread-safe?**
14. **Can LinkedList contain null?**
15. **What is the node structure?**

---

## üìö Next Topics

- [ArrayList vs LinkedList](06.%20ArrayList%20vs%20LinkedList.md)
- [Vector](04.%20Vector.md)
- [Stack](05.%20Stack.md)
- [ArrayDeque](../04.%20Queue%20Interface/04.%20ArrayDeque.md)
- [Time Complexity](../12.%20Performance%20%26%20Best%20Practices/01.%20Time%20Complexity.md)
