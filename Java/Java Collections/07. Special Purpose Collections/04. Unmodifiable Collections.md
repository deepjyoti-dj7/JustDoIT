# üîê Unmodifiable Collections

## üìñ Overview

**Unmodifiable Collections** are **read-only views** created using `Collections.unmodifiableXxx()` methods. They prevent modifications but are **not truly immutable** - changes to the underlying collection are reflected.

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
List<String> unmodifiable = Collections.unmodifiableList(list);

// unmodifiable.add("D");  // UnsupportedOperationException
// But: list.add("D") affects unmodifiable!
```

---

## ‚≠ê Key Characteristics

1. **Read-only** - Cannot modify through unmodifiable view
2. **Wrapper pattern** - Wraps existing collection
3. **Not truly immutable** - Changes to original reflect in view
4. **Fail-fast** - Throws UnsupportedOperationException on modification
5. **Defensive copying** - Useful for returning internal collections
6. **No performance overhead** - Just a view wrapper

---

## üéØ Creating Unmodifiable Collections

```java
// 1. Unmodifiable List
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
List<String> unmodList = Collections.unmodifiableList(list);

// 2. Unmodifiable Set
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> unmodSet = Collections.unmodifiableSet(set);

// 3. Unmodifiable Map
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
Map<String, Integer> unmodMap = Collections.unmodifiableMap(map);

// 4. Unmodifiable SortedSet
SortedSet<Integer> sortedSet = new TreeSet<>(Arrays.asList(3, 1, 2));
SortedSet<Integer> unmodSortedSet = Collections.unmodifiableSortedSet(sortedSet);

// 5. Unmodifiable SortedMap
SortedMap<String, Integer> sortedMap = new TreeMap<>();
SortedMap<String, Integer> unmodSortedMap = Collections.unmodifiableSortedMap(sortedMap);

// 6. Unmodifiable NavigableSet
NavigableSet<Integer> navSet = new TreeSet<>(Arrays.asList(1, 2, 3));
NavigableSet<Integer> unmodNavSet = Collections.unmodifiableNavigableSet(navSet);

// 7. Unmodifiable NavigableMap
NavigableMap<String, Integer> navMap = new TreeMap<>();
NavigableMap<String, Integer> unmodNavMap = Collections.unmodifiableNavigableMap(navMap);
```

---

## üíª Allowed Operations

```java
List<String> unmodList = Collections.unmodifiableList(Arrays.asList("A", "B", "C"));

// ‚úÖ Read operations work
String item = unmodList.get(0);       // "A"
int size = unmodList.size();          // 3
boolean contains = unmodList.contains("B");  // true
boolean isEmpty = unmodList.isEmpty();       // false

// ‚úÖ Iteration works
for (String s : unmodList) {
    System.out.println(s);
}

// ‚úÖ Stream operations
unmodList.stream().forEach(System.out::println);

// ‚úÖ Copying works
List<String> copy = new ArrayList<>(unmodList);
```

---

## ‚õî Disallowed Operations

```java
List<String> unmodList = Collections.unmodifiableList(new ArrayList<>(Arrays.asList("A", "B")));

// ‚ùå All throw UnsupportedOperationException
// unmodList.add("C");
// unmodList.remove("A");
// unmodList.clear();
// unmodList.set(0, "X");
// unmodList.addAll(Arrays.asList("D", "E"));
// unmodList.removeAll(Arrays.asList("A", "B"));
// unmodList.retainAll(Arrays.asList("A"));
// unmodList.replaceAll(String::toUpperCase);
// unmodList.sort(Comparator.naturalOrder());

// Even iterator cannot remove
Iterator<String> it = unmodList.iterator();
// it.remove();  // UnsupportedOperationException
```

---

## ‚ö†Ô∏è Not Truly Immutable

```java
// Original mutable list
List<String> original = new ArrayList<>(Arrays.asList("A", "B", "C"));

// Create unmodifiable view
List<String> unmodifiable = Collections.unmodifiableList(original);

System.out.println(unmodifiable);  // [A, B, C]

// ‚ö†Ô∏è Modifying original affects unmodifiable view
original.add("D");
System.out.println(unmodifiable);  // [A, B, C, D] - Changed!

original.remove("A");
System.out.println(unmodifiable);  // [B, C, D] - Changed!
```

---

## üéØ True Immutability (Java 9+)

```java
// Java 9+ - Truly immutable (no backing collection)
List<String> immutable = List.of("A", "B", "C");
Set<Integer> immutableSet = Set.of(1, 2, 3);
Map<String, Integer> immutableMap = Map.of("A", 1, "B", 2);

// ‚ùå Cannot modify
// immutable.add("D");  // UnsupportedOperationException

// ‚úÖ No backing collection - truly immutable
```

---

## üéØ Real-World Examples

### 1. Defensive Copying (Return Internal Collection)
```java
class Library {
    private List<Book> books = new ArrayList<>();
    
    // ‚ùå Bad - exposes internal collection
    public List<Book> getBooks() {
        return books;  // Caller can modify!
    }
    
    // ‚úÖ Good - return unmodifiable view
    public List<Book> getBooks() {
        return Collections.unmodifiableList(books);
    }
    
    // ‚úÖ Better - return truly immutable (Java 9+)
    public List<Book> getBooks() {
        return List.copyOf(books);
    }
}
```

---

### 2. Configuration Object
```java
class AppConfig {
    private Map<String, String> properties = new HashMap<>();
    
    public AppConfig() {
        properties.put("host", "localhost");
        properties.put("port", "8080");
        properties.put("timeout", "30");
    }
    
    // Return unmodifiable view
    public Map<String, String> getProperties() {
        return Collections.unmodifiableMap(properties);
    }
    
    // Internal modification still allowed
    void updateProperty(String key, String value) {
        properties.put(key, value);
    }
}
```

---

### 3. Constants
```java
class Constants {
    // ‚ùå Not final, can be modified
    public static List<String> ALLOWED_ROLES = Arrays.asList("ADMIN", "USER", "GUEST");
    
    // ‚úÖ Unmodifiable
    public static final List<String> ALLOWED_ROLES = 
        Collections.unmodifiableList(Arrays.asList("ADMIN", "USER", "GUEST"));
    
    // ‚úÖ Better - truly immutable (Java 9+)
    public static final List<String> ALLOWED_ROLES = 
        List.of("ADMIN", "USER", "GUEST");
}
```

---

### 4. API Response
```java
class UserService {
    private Set<User> activeUsers = new HashSet<>();
    
    // Return unmodifiable view
    public Set<User> getActiveUsers() {
        return Collections.unmodifiableSet(activeUsers);
    }
    
    // Only service can modify
    void addUser(User user) {
        activeUsers.add(user);
    }
    
    void removeUser(User user) {
        activeUsers.remove(user);
    }
}
```

---

### 5. Builder Pattern
```java
class QueryBuilder {
    private List<String> conditions = new ArrayList<>();
    
    public QueryBuilder where(String condition) {
        conditions.add(condition);
        return this;
    }
    
    public Query build() {
        // Pass unmodifiable copy to Query
        return new Query(Collections.unmodifiableList(new ArrayList<>(conditions)));
    }
}

class Query {
    private final List<String> conditions;
    
    Query(List<String> conditions) {
        this.conditions = conditions;  // Already unmodifiable
    }
    
    public List<String> getConditions() {
        return conditions;  // Safe to return
    }
}
```

---

## üÜö Unmodifiable vs Immutable

| Feature | Unmodifiable (Collections) | Immutable (List.of, etc.) |
|---------|---------------------------|---------------------------|
| **Java Version** | 1.2+ | 9+ |
| **Type** | View wrapper | Standalone collection |
| **Backing collection** | Yes (changes reflect) | No (truly immutable) |
| **Null elements** | Depends on wrapped | Not allowed |
| **Performance** | Lightweight wrapper | Optimized structure |
| **Use case** | Defensive copying | Constants, immutability |

---

## ‚ö†Ô∏è Common Pitfalls

1. **Assuming true immutability**
```java
List<String> original = new ArrayList<>(Arrays.asList("A", "B"));
List<String> unmod = Collections.unmodifiableList(original);

original.add("C");
System.out.println(unmod);  // [A, B, C] - Changed!

// ‚úÖ For true immutability
List<String> immutable = List.of("A", "B");
```

2. **Nested mutable objects**
```java
List<List<String>> original = new ArrayList<>();
original.add(new ArrayList<>(Arrays.asList("A", "B")));

List<List<String>> unmod = Collections.unmodifiableList(original);

// ‚ùå Cannot modify outer list
// unmod.add(new ArrayList<>());  // UnsupportedOperationException

// ‚ö†Ô∏è But can modify inner lists!
unmod.get(0).add("C");  // Works! Inner list is mutable
System.out.println(unmod);  // [[A, B, C]]

// ‚úÖ Make inner lists unmodifiable too
List<List<String>> fullyUnmod = Collections.unmodifiableList(
    original.stream()
            .map(Collections::unmodifiableList)
            .collect(Collectors.toList())
);
```

3. **Returning unmodifiable without copying**
```java
class Team {
    private List<Player> players = new ArrayList<>();
    
    // ‚ö†Ô∏è Caller cannot modify, but internal changes reflect
    public List<Player> getPlayers() {
        return Collections.unmodifiableList(players);
    }
    
    // If internal modification happens
    void addPlayer(Player p) {
        players.add(p);  // Reflects in returned list!
    }
}

// ‚úÖ Return true copy if needed
public List<Player> getPlayers() {
    return List.copyOf(players);  // Java 9+
}
```

4. **Collection.of() doesn't accept null**
```java
// ‚ùå NullPointerException
List<String> list = List.of("A", null, "C");

// ‚úÖ Use unmodifiable if null needed
List<String> list = Collections.unmodifiableList(Arrays.asList("A", null, "C"));
```

---

## üí° Best Practices

1. **Use for defensive copying**
```java
// ‚úÖ Return unmodifiable view
public List<Item> getItems() {
    return Collections.unmodifiableList(items);
}
```

2. **Make constants truly immutable**
```java
// ‚úÖ Java 9+
public static final List<String> STATUSES = List.of("ACTIVE", "INACTIVE");

// ‚úÖ Java 8
public static final List<String> STATUSES = 
    Collections.unmodifiableList(Arrays.asList("ACTIVE", "INACTIVE"));
```

3. **Copy before wrapping for true immutability**
```java
// ‚úÖ True immutability (no backing reference)
public List<String> getItems() {
    return Collections.unmodifiableList(new ArrayList<>(items));
}
```

4. **Document unmodifiability**
```java
/**
 * Returns an unmodifiable view of items.
 * @return unmodifiable list
 */
public List<Item> getItems() {
    return Collections.unmodifiableList(items);
}
```

---

## üéì When to Use Unmodifiable Collections

### ‚úÖ Use When:
- Defensive copying (return internal collections)
- Prevent accidental modification
- API contract requires immutability
- Java 8 or earlier (no List.of())

### ‚ùå Don't Use When:
- Need true immutability (use List.of() in Java 9+)
- Nested collections with mutable elements
- Null elements needed with immutability

---

## üìö Interview Questions

**Q1: Are unmodifiable collections immutable?**
A: No, they're views - changes to original reflect in unmodifiable view.

**Q2: What happens if you try to modify?**
A: Throws UnsupportedOperationException.

**Q3: Difference from List.of()?**
A: List.of() is truly immutable (no backing collection), unmodifiableList is a view.

**Q4: Can unmodifiable collections contain null?**
A: Depends on wrapped collection (List.of() doesn't allow null).

**Q5: Is there performance overhead?**
A: Minimal - just a lightweight wrapper.

**Q6: Can you iterate over unmodifiable collections?**
A: Yes, all read operations work.

**Q7: How to make nested collections unmodifiable?**
A: Wrap each level: `Collections.unmodifiableList(list.stream().map(Collections::unmodifiableList).collect(...))`.

**Q8: When to use unmodifiable vs truly immutable?**
A: Use truly immutable (List.of) for constants, unmodifiable for defensive copying.

---

## üìö Summary

- **Unmodifiable Collections**: Read-only views (not truly immutable)
- **Created by**: Collections.unmodifiableList/Set/Map()
- **Purpose**: Defensive copying, prevent accidental modification
- **Not immutable**: Changes to original reflect in view
- **Java 9+**: Use List.of/Set.of/Map.of for true immutability
- **Throws**: UnsupportedOperationException on modification attempts
- **Use case**: Return internal collections safely, API contracts
