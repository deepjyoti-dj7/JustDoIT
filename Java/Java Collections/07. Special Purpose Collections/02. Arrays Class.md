# üîß Arrays Class

## üìñ Overview

**Arrays** is a utility class in `java.util` package that provides **static methods** for manipulating arrays. It offers algorithms for sorting, searching, filling, copying, and converting arrays.

```java
public class Arrays {
    // All methods are static
    private Arrays() {}  // Cannot instantiate
}
```

---

## ‚≠ê Key Categories

1. **Sorting** - sort, parallelSort
2. **Searching** - binarySearch
3. **Comparison** - equals, deepEquals, compare, mismatch
4. **Filling** - fill, setAll
5. **Copying** - copyOf, copyOfRange
6. **Conversion** - toString, asList, stream
7. **Hashing** - hashCode, deepHashCode

---

## üìä Sorting Methods

```java
// 1. Sort entire array
int[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr);  // [1, 1, 3, 4, 5]

// 2. Sort range
int[] arr2 = {5, 3, 1, 4, 2};
Arrays.sort(arr2, 1, 4);  // Sort index 1 to 3: [5, 1, 3, 4, 2]

// 3. Sort with comparator (objects only)
String[] names = {"John", "Alice", "Bob"};
Arrays.sort(names);  // [Alice, Bob, John]
Arrays.sort(names, Collections.reverseOrder());  // [John, Bob, Alice]

// 4. Parallel sort (multi-threaded for large arrays)
int[] large = new int[1_000_000];
Arrays.parallelSort(large);  // Faster for large arrays

// 5. Custom comparator
Integer[] nums = {3, 1, 4, 1, 5};
Arrays.sort(nums, (a, b) -> b - a);  // Descending: [5, 4, 3, 1, 1]
```

---

## üîç Searching Methods

```java
// Binary search (array must be sorted!)
int[] sorted = {1, 2, 3, 4, 5, 6, 7, 8, 9};

int index = Arrays.binarySearch(sorted, 5);  // 4

// Not found (returns -(insertion point) - 1)
int notFound = Arrays.binarySearch(sorted, 10);  // -10

// Range search
int rangeIndex = Arrays.binarySearch(sorted, 2, 7, 5);  // Search in [2, 7)

// With comparator (objects)
String[] names = {"Alice", "Bob", "Charlie"};
int idx = Arrays.binarySearch(names, "Bob");  // 1
```

---

## ‚úèÔ∏è Filling Methods

```java
// 1. Fill entire array
int[] arr = new int[5];
Arrays.fill(arr, 7);  // [7, 7, 7, 7, 7]

// 2. Fill range
int[] arr2 = {1, 2, 3, 4, 5};
Arrays.fill(arr2, 1, 4, 0);  // [1, 0, 0, 0, 5]

// 3. setAll (functional approach)
int[] arr3 = new int[5];
Arrays.setAll(arr3, i -> i * 2);  // [0, 2, 4, 6, 8]

// 4. parallelSetAll (parallel)
int[] arr4 = new int[1000];
Arrays.parallelSetAll(arr4, i -> i * i);  // [0, 1, 4, 9, ...]

// 5. Object arrays
String[] strings = new String[3];
Arrays.fill(strings, "Java");  // [Java, Java, Java]
```

---

## üìã Copying Methods

```java
// 1. Copy entire array
int[] original = {1, 2, 3, 4, 5};
int[] copy = Arrays.copyOf(original, original.length);  // [1, 2, 3, 4, 5]

// 2. Copy with different length
int[] shorter = Arrays.copyOf(original, 3);  // [1, 2, 3]
int[] longer = Arrays.copyOf(original, 7);   // [1, 2, 3, 4, 5, 0, 0]

// 3. Copy range
int[] range = Arrays.copyOfRange(original, 1, 4);  // [2, 3, 4]

// 4. Clone (alternative)
int[] cloned = original.clone();  // [1, 2, 3, 4, 5]
```

---

## üÜö Comparison Methods

```java
// 1. equals (element-by-element)
int[] arr1 = {1, 2, 3};
int[] arr2 = {1, 2, 3};
int[] arr3 = {1, 2, 4};
boolean equal = Arrays.equals(arr1, arr2);  // true
boolean notEqual = Arrays.equals(arr1, arr3);  // false

// 2. deepEquals (for nested arrays)
int[][] matrix1 = {{1, 2}, {3, 4}};
int[][] matrix2 = {{1, 2}, {3, 4}};
boolean deepEqual = Arrays.deepEquals(matrix1, matrix2);  // true

// 3. compare (lexicographic comparison)
int[] a = {1, 2, 3};
int[] b = {1, 2, 4};
int result = Arrays.compare(a, b);  // < 0 (a < b)

// 4. compareUnsigned (unsigned comparison)
byte[] unsigned1 = {-1};  // 255 unsigned
byte[] unsigned2 = {1};
int cmp = Arrays.compareUnsigned(unsigned1, unsigned2);  // > 0

// 5. mismatch (find first difference)
int[] x = {1, 2, 3, 4};
int[] y = {1, 2, 5, 4};
int mismatchIndex = Arrays.mismatch(x, y);  // 2
```

---

## üîÑ Conversion Methods

```java
// 1. toString (single-dimensional)
int[] arr = {1, 2, 3};
String str = Arrays.toString(arr);  // "[1, 2, 3]"

// 2. deepToString (multi-dimensional)
int[][] matrix = {{1, 2}, {3, 4}};
String matrixStr = Arrays.deepToString(matrix);  // "[[1, 2], [3, 4]]"

// 3. asList (array to List)
String[] array = {"A", "B", "C"};
List<String> list = Arrays.asList(array);  // [A, B, C]

// ‚ö†Ô∏è Fixed-size list (backed by array)
// list.add("D");  // UnsupportedOperationException

// ‚úÖ Mutable ArrayList
List<String> mutableList = new ArrayList<>(Arrays.asList(array));
mutableList.add("D");  // OK

// 4. stream (array to Stream)
int[] nums = {1, 2, 3, 4, 5};
int sum = Arrays.stream(nums).sum();  // 15

String[] words = {"a", "b", "c"};
long count = Arrays.stream(words).count();  // 3
```

---

## #Ô∏è‚É£ Hashing Methods

```java
// 1. hashCode (single-dimensional)
int[] arr = {1, 2, 3};
int hash = Arrays.hashCode(arr);

// 2. deepHashCode (multi-dimensional)
int[][] matrix = {{1, 2}, {3, 4}};
int deepHash = Arrays.deepHashCode(matrix);

// Use in custom classes
class Person {
    String name;
    int[] scores;
    
    @Override
    public int hashCode() {
        return Objects.hash(name, Arrays.hashCode(scores));
    }
}
```

---

## üéØ Real-World Examples

### 1. Sort Students by Grade
```java
Student[] students = getStudents();

// Sort by grade (descending)
Arrays.sort(students, (a, b) -> b.getGrade() - a.getGrade());

// Or with Comparator
Arrays.sort(students, Comparator.comparing(Student::getGrade).reversed());
```

---

### 2. Find Median
```java
int[] numbers = {5, 2, 8, 1, 9};
Arrays.sort(numbers);

int median;
if (numbers.length % 2 == 0) {
    median = (numbers[numbers.length/2] + numbers[numbers.length/2 - 1]) / 2;
} else {
    median = numbers[numbers.length/2];
}
```

---

### 3. Initialize Matrix
```java
// All zeros
int[][] matrix = new int[3][4];
Arrays.stream(matrix).forEach(row -> Arrays.fill(row, 0));

// Or
int[][] matrix2 = new int[3][4];
for (int[] row : matrix2) {
    Arrays.fill(row, 0);
}
```

---

### 4. Check if Array Contains Value
```java
String[] array = {"apple", "banana", "cherry"};
Arrays.sort(array);  // Must sort first!

boolean contains = Arrays.binarySearch(array, "banana") >= 0;  // true
```

---

### 5. Remove Duplicates
```java
int[] arr = {1, 2, 2, 3, 3, 3, 4};
int[] unique = Arrays.stream(arr).distinct().toArray();  // [1, 2, 3, 4]
```

---

### 6. Array of Squares
```java
int[] nums = {1, 2, 3, 4, 5};
int[] squares = Arrays.stream(nums).map(x -> x * x).toArray();  // [1, 4, 9, 16, 25]
```

---

### 7. Parallel Processing
```java
int[] large = new int[10_000_000];
Arrays.fill(large, 1);

// Parallel sort (faster for large arrays)
Arrays.parallelSort(large);

// Parallel prefix (cumulative sum)
Arrays.parallelPrefix(large, (a, b) -> a + b);
// [1, 2, 3, 4, ...]
```

---

## ‚ö° Performance Comparison

| Method | Small Arrays | Large Arrays | Notes |
|--------|-------------|-------------|-------|
| **sort** | Fast | Fast | DualPivotQuicksort |
| **parallelSort** | Slower | Faster | Use for large arrays (>8192) |
| **fill** | Fast | Fast | O(n) |
| **setAll** | Slower | Slower | Functional overhead |
| **parallelSetAll** | Slower | Faster | Use for large arrays |

---

## üÜö Arrays vs Collections

| Operation | Arrays | Collections |
|-----------|--------|-------------|
| **Sort** | Arrays.sort(arr) | Collections.sort(list) |
| **Search** | Arrays.binarySearch(arr) | Collections.binarySearch(list) |
| **Fill** | Arrays.fill(arr) | Collections.fill(list) |
| **Copy** | Arrays.copyOf(arr) | new ArrayList<>(list) |
| **toString** | Arrays.toString(arr) | list.toString() |

---

## ‚ö†Ô∏è Common Pitfalls

1. **asList() creates fixed-size list**
```java
List<String> list = Arrays.asList("A", "B");
// ‚ùå UnsupportedOperationException
list.add("C");

// ‚úÖ Create mutable list
List<String> mutable = new ArrayList<>(Arrays.asList("A", "B"));
mutable.add("C");  // OK
```

2. **binarySearch on unsorted array**
```java
int[] arr = {3, 1, 4};
// ‚ùå Undefined behavior
int index = Arrays.binarySearch(arr, 1);

// ‚úÖ Sort first
Arrays.sort(arr);
int correctIndex = Arrays.binarySearch(arr, 1);
```

3. **Primitive vs Object arrays**
```java
int[] primitives = {1, 2, 3};
// ‚ùå Cannot do this
// List<int> list = Arrays.asList(primitives);

// ‚úÖ Use wrapper or stream
List<Integer> list = Arrays.stream(primitives).boxed().collect(Collectors.toList());
```

4. **Modifying asList() affects original array**
```java
String[] arr = {"A", "B", "C"};
List<String> list = Arrays.asList(arr);
list.set(0, "X");
System.out.println(Arrays.toString(arr));  // [X, B, C] - modified!
```

5. **deepEquals vs equals**
```java
int[][] a = {{1, 2}};
int[][] b = {{1, 2}};

// ‚ùå Compares references
boolean wrong = Arrays.equals(a, b);  // false

// ‚úÖ Compares content
boolean correct = Arrays.deepEquals(a, b);  // true
```

---

## üí° Best Practices

1. **Use parallelSort for large arrays**
```java
// ‚úÖ Use parallel for > 8192 elements
if (arr.length > 8192) {
    Arrays.parallelSort(arr);
} else {
    Arrays.sort(arr);
}
```

2. **Use streams for transformations**
```java
// ‚úÖ Functional and concise
int[] squares = Arrays.stream(nums).map(x -> x * x).toArray();
```

3. **Use copyOf for safe copying**
```java
// ‚úÖ Safe copy
int[] copy = Arrays.copyOf(original, original.length);

// ‚ö†Ô∏è Shallow copy (use carefully)
int[] ref = original;
```

4. **Use deepEquals for nested arrays**
```java
// ‚úÖ For multi-dimensional arrays
boolean equal = Arrays.deepEquals(matrix1, matrix2);
```

---

## üéì Interview Questions

**Q1: What's Arrays.sort() algorithm?**
A: DualPivotQuicksort for primitives, TimSort for objects.

**Q2: When to use parallelSort()?**
A: For large arrays (>8192 elements) to leverage multi-core processors.

**Q3: Can asList() list be modified?**
A: Can set elements but cannot add/remove (fixed-size, backed by array).

**Q4: Difference between equals() and deepEquals()?**
A: equals() compares 1D arrays, deepEquals() compares nested arrays.

**Q5: Arrays.toString() vs deepToString()?**
A: toString() for 1D, deepToString() for multi-dimensional.

**Q6: Time complexity of binarySearch()?**
A: O(log n) if sorted, undefined if unsorted.

**Q7: What does mismatch() return?**
A: Index of first difference, or -1 if arrays are equal.

**Q8: copyOf vs clone?**
A: copyOf can change size, clone creates exact copy.

---

## üìö Summary

- **Arrays**: Utility class for array operations
- **Sorting**: sort (sequential), parallelSort (parallel)
- **Searching**: binarySearch (requires sorted array)
- **Filling**: fill, setAll, parallelSetAll
- **Copying**: copyOf, copyOfRange, clone
- **Comparison**: equals, deepEquals, compare, mismatch
- **Conversion**: toString, asList, stream
- **Best practices**: Use parallelSort for large arrays, streams for transformations
