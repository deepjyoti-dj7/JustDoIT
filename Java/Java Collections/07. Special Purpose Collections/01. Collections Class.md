# üõ†Ô∏è Collections Class

## üìñ Overview

**Collections** is a utility class in `java.util` package that provides **static methods** for operating on collections. It offers algorithms for sorting, searching, synchronization, and creating specialized collections.

```java
public class Collections {
    // All methods are static
    private Collections() {}  // Cannot instantiate
}
```

---

## ‚≠ê Key Categories

1. **Sorting** - sort, reverse, shuffle, rotate
2. **Searching** - binarySearch, min, max
3. **Modification** - fill, copy, replaceAll, swap
4. **Thread-safety** - synchronizedList, synchronizedSet, synchronizedMap
5. **Immutability** - unmodifiableList, unmodifiableSet, unmodifiableMap
6. **Special collections** - emptyList, singletonList, nCopies
7. **Comparison** - disjoint, frequency

---

## üìä Sorting Methods

```java
List<Integer> list = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5));

// 1. Sort (natural order)
Collections.sort(list);  // [1, 1, 3, 4, 5]

// 2. Sort with comparator (reverse)
Collections.sort(list, Collections.reverseOrder());  // [5, 4, 3, 1, 1]

// 3. Reverse
Collections.reverse(list);  // [1, 1, 3, 4, 5]

// 4. Shuffle (random order)
Collections.shuffle(list);  // Random order

// 5. Rotate (shift elements)
Collections.rotate(list, 2);  // Shift right by 2
// [4, 5, 1, 1, 3] if original was [1, 1, 3, 4, 5]

// 6. Swap elements
Collections.swap(list, 0, 4);  // Swap index 0 and 4
```

---

## üîç Searching Methods

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

// Binary search (list must be sorted!)
int index = Collections.binarySearch(list, 5);  // 4

// Not found
int notFound = Collections.binarySearch(list, 10);  // -10 (-(insertion point) - 1)

// Min/Max
Integer min = Collections.min(list);  // 1
Integer max = Collections.max(list);  // 9

// Min/Max with comparator
List<String> words = Arrays.asList("cat", "dog", "elephant");
String shortest = Collections.min(words, Comparator.comparing(String::length));  // "cat"
String longest = Collections.max(words, Comparator.comparing(String::length));   // "elephant"

// Frequency (count occurrences)
List<Integer> nums = Arrays.asList(1, 2, 2, 3, 2, 4);
int count = Collections.frequency(nums, 2);  // 3
```

---

## ‚úèÔ∏è Modification Methods

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// 1. Fill (replace all with value)
Collections.fill(list, 0);  // [0, 0, 0, 0, 0]

// 2. Copy
List<Integer> src = Arrays.asList(10, 20, 30);
List<Integer> dest = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.copy(dest, src);  // dest = [10, 20, 30, 4, 5]

// 3. Replace all
List<Integer> nums = new ArrayList<>(Arrays.asList(1, 2, 1, 3, 1));
Collections.replaceAll(nums, 1, 99);  // [99, 2, 99, 3, 99]

// 4. Add all
List<String> list2 = new ArrayList<>();
Collections.addAll(list2, "A", "B", "C");  // [A, B, C]
```

---

## üîí Synchronized Collections

```java
// Create thread-safe collections
List<String> list = new ArrayList<>();
List<String> syncList = Collections.synchronizedList(list);

Set<Integer> set = new HashSet<>();
Set<Integer> syncSet = Collections.synchronizedSet(set);

Map<String, Integer> map = new HashMap<>();
Map<String, Integer> syncMap = Collections.synchronizedMap(map);

// Must manually synchronize iteration!
synchronized(syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}
```

---

## üîê Unmodifiable Collections

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

// Create unmodifiable view
List<String> unmodifiable = Collections.unmodifiableList(list);

// ‚ùå Throws UnsupportedOperationException
// unmodifiable.add("D");
// unmodifiable.remove("A");
// unmodifiable.clear();

// ‚ö†Ô∏è Changes to original affect unmodifiable view
list.add("D");
System.out.println(unmodifiable);  // [A, B, C, D]

// Other unmodifiable wrappers
Set<Integer> unmodSet = Collections.unmodifiableSet(new HashSet<>());
Map<String, Integer> unmodMap = Collections.unmodifiableMap(new HashMap<>());
```

---

## üéØ Special Collections

### 1. Empty Collections
```java
// Immutable empty collections
List<String> emptyList = Collections.emptyList();
Set<Integer> emptySet = Collections.emptySet();
Map<String, Integer> emptyMap = Collections.emptyMap();

// Type-safe and memory efficient
Iterator<String> emptyIter = Collections.emptyIterator();
ListIterator<String> emptyListIter = Collections.emptyListIterator();
Enumeration<String> emptyEnum = Collections.emptyEnumeration();
```

### 2. Singleton Collections
```java
// Immutable single-element collections
List<String> singleton = Collections.singletonList("A");
Set<Integer> singletonSet = Collections.singleton(42);
Map<String, Integer> singletonMap = Collections.singletonMap("key", 100);

// ‚ùå Cannot add/remove
// singleton.add("B");  // UnsupportedOperationException
```

### 3. N Copies
```java
// Immutable list with n copies of element
List<String> copies = Collections.nCopies(5, "X");
// [X, X, X, X, X]

// Useful for initialization
List<Integer> zeros = new ArrayList<>(Collections.nCopies(10, 0));
// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

---

## üÜö Comparison Methods

```java
List<Integer> list1 = Arrays.asList(1, 2, 3);
List<Integer> list2 = Arrays.asList(4, 5, 6);
List<Integer> list3 = Arrays.asList(1, 2);

// Disjoint (no common elements)
boolean disjoint = Collections.disjoint(list1, list2);  // true
boolean notDisjoint = Collections.disjoint(list1, list3);  // false

// Frequency
List<String> words = Arrays.asList("a", "b", "a", "c", "a");
int count = Collections.frequency(words, "a");  // 3

// Index of sublist
List<Integer> source = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> target = Arrays.asList(3, 4, 5);
int index = Collections.indexOfSubList(source, target);  // 2

int lastIndex = Collections.lastIndexOfSubList(source, target);  // 2
```

---

## üéØ Real-World Examples

### 1. Sort Students by Multiple Criteria
```java
List<Student> students = getStudents();

// Sort by grade (descending), then name (ascending)
Collections.sort(students, 
    Comparator.comparing(Student::getGrade).reversed()
              .thenComparing(Student::getName));
```

---

### 2. Thread-Safe Cache
```java
Map<String, Data> cache = new HashMap<>();
Map<String, Data> threadSafeCache = Collections.synchronizedMap(cache);

// Safe to use from multiple threads
threadSafeCache.put("key", data);
Data value = threadSafeCache.get("key");
```

---

### 3. Immutable Configuration
```java
Map<String, String> config = new HashMap<>();
config.put("host", "localhost");
config.put("port", "8080");

// Make immutable before returning
return Collections.unmodifiableMap(config);
```

---

### 4. Shuffle Deck of Cards
```java
List<Card> deck = createDeck();
Collections.shuffle(deck);  // Random shuffle

// Or with specific Random
Random random = new Random(42);  // Seeded for reproducibility
Collections.shuffle(deck, random);
```

---

### 5. Find Top K Elements
```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9, 3, 7);

// Find top 3
Collections.sort(numbers, Collections.reverseOrder());
List<Integer> top3 = numbers.subList(0, 3);  // [9, 8, 7]
```

---

### 6. Rotate Queue
```java
Queue<Task> queue = new LinkedList<>(Arrays.asList(t1, t2, t3, t4, t5));

// Move first element to back
Collections.rotate((List<Task>) queue, -1);
// Or: queue.offer(queue.poll());
```

---

## ‚ö° Performance Tips

```java
// ‚úÖ Use binarySearch on sorted lists (O(log n))
Collections.sort(list);
int index = Collections.binarySearch(list, target);

// ‚ùå Don't use binarySearch on unsorted (wrong result!)
int wrong = Collections.binarySearch(unsortedList, target);

// ‚úÖ Use emptyList() instead of new ArrayList<>() for empty
List<String> empty = Collections.emptyList();  // Singleton, no allocation

// ‚úÖ Use singletonList for single element
List<String> single = Collections.singletonList("A");  // Immutable, efficient

// ‚úÖ Use nCopies for repeated elements
List<Integer> zeros = Collections.nCopies(1000, 0);  // Memory efficient
```

---

## üÜö Collections vs Arrays Class

| Feature | Collections | Arrays |
|---------|-------------|--------|
| **Target** | Collections | Arrays |
| **sort** | sort(List) | sort(array) |
| **binarySearch** | binarySearch(List) | binarySearch(array) |
| **fill** | fill(List) | fill(array) |
| **Synchronization** | synchronizedList | N/A |
| **Immutability** | unmodifiableList | N/A |

---

## ‚ö†Ô∏è Common Pitfalls

1. **binarySearch on unsorted list**
```java
List<Integer> list = Arrays.asList(3, 1, 4);
// ‚ùå Wrong result (list not sorted)
int index = Collections.binarySearch(list, 1);

// ‚úÖ Sort first
Collections.sort(list);
int correctIndex = Collections.binarySearch(list, 1);
```

2. **Modifying unmodifiable collection**
```java
List<String> list = Collections.unmodifiableList(Arrays.asList("A"));
// ‚ùå UnsupportedOperationException
list.add("B");
```

3. **Forgetting to synchronize iteration**
```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
// ‚ùå Not thread-safe!
for (String item : syncList) { }

// ‚úÖ Thread-safe
synchronized(syncList) {
    for (String item : syncList) { }
}
```

4. **copy() destination too small**
```java
List<Integer> src = Arrays.asList(1, 2, 3);
List<Integer> dest = new ArrayList<>(Arrays.asList(0));
// ‚ùå IndexOutOfBoundsException
Collections.copy(dest, src);

// ‚úÖ Destination must be large enough
List<Integer> dest2 = new ArrayList<>(Arrays.asList(0, 0, 0));
Collections.copy(dest2, src);
```

---

## üí° Best Practices

1. **Prefer List.sort() over Collections.sort()**
```java
// ‚úÖ Modern (Java 8+)
list.sort(Comparator.naturalOrder());

// ‚ö†Ô∏è Legacy
Collections.sort(list);
```

2. **Use empty collections instead of null**
```java
// ‚úÖ No null checks needed
return Collections.emptyList();

// ‚ùå Requires null checks
return null;
```

3. **Use unmodifiable for defensive copying**
```java
// ‚úÖ Prevent external modification
public List<String> getItems() {
    return Collections.unmodifiableList(items);
}
```

4. **Use singletonList for single element**
```java
// ‚úÖ Efficient
return Collections.singletonList(result);

// ‚ö†Ô∏è Overhead
return Arrays.asList(result);
```

---

## üéì Interview Questions

**Q1: What's Collections.sort() time complexity?**
A: O(n log n) - uses TimSort (merge sort + insertion sort).

**Q2: Can you use binarySearch on unsorted list?**
A: No, undefined behavior (wrong result).

**Q3: Are synchronized collections fully thread-safe?**
A: No, must manually synchronize iteration.

**Q4: unmodifiableList vs ImmutableList?**
A: unmodifiableList is a view (changes to original reflect), ImmutableList is truly immutable.

**Q5: What's the difference between emptyList() and new ArrayList()?**
A: emptyList() is immutable singleton (more efficient).

**Q6: Collections.sort vs List.sort?**
A: List.sort() is preferred (Java 8+), cleaner API.

**Q7: Is shuffle truly random?**
A: Yes, uses Random internally (can provide custom Random for reproducibility).

**Q8: What does rotate(list, 2) do?**
A: Shifts elements right by 2 positions (last 2 become first 2).

---

## üìö Summary

- **Collections**: Utility class with static methods for collections
- **Sorting**: sort, reverse, shuffle, rotate
- **Searching**: binarySearch (requires sorted), min, max, frequency
- **Synchronization**: synchronizedList/Set/Map (manual sync for iteration)
- **Immutability**: unmodifiableList/Set/Map (views, not true immutability)
- **Special**: emptyList, singletonList, nCopies
- **Best practices**: Use List.sort(), emptyList() over null, defensive copying
