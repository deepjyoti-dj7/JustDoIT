# üì¶ Empty Collections

## üìñ Overview

**Empty Collections** are **immutable, singleton** empty collections created using `Collections.emptyXxx()` methods. They're memory-efficient and type-safe alternatives to `null`.

```java
List<String> emptyList = Collections.emptyList();
Set<Integer> emptySet = Collections.emptySet();
Map<String, Integer> emptyMap = Collections.emptyMap();
```

---

## ‚≠ê Key Characteristics

1. **Immutable** - Cannot be modified
2. **Singleton** - Same instance reused (memory efficient)
3. **Type-safe** - Parameterized generics
4. **No null checks needed** - Better than returning null
5. **Zero allocation** - Reuses single instance
6. **Thread-safe** - Immutable by nature

---

## üéØ Available Empty Collections

```java
// 1. Empty List
List<String> emptyList = Collections.emptyList();

// 2. Empty Set
Set<Integer> emptySet = Collections.emptySet();

// 3. Empty Map
Map<String, Integer> emptyMap = Collections.emptyMap();

// 4. Empty SortedSet
SortedSet<String> emptySortedSet = Collections.emptySortedSet();

// 5. Empty SortedMap
SortedMap<String, Integer> emptySortedMap = Collections.emptySortedMap();

// 6. Empty NavigableSet
NavigableSet<Integer> emptyNavSet = Collections.emptyNavigableSet();

// 7. Empty NavigableMap
NavigableMap<String, Integer> emptyNavMap = Collections.emptyNavigableMap();

// 8. Empty Iterator
Iterator<String> emptyIter = Collections.emptyIterator();

// 9. Empty ListIterator
ListIterator<String> emptyListIter = Collections.emptyListIterator();

// 10. Empty Enumeration
Enumeration<String> emptyEnum = Collections.emptyEnumeration();
```

---

## üíª Basic Operations

```java
List<String> empty = Collections.emptyList();

// ‚úÖ Read operations work
int size = empty.size();              // 0
boolean isEmpty = empty.isEmpty();    // true
boolean contains = empty.contains("A");  // false

// ‚úÖ Iteration works (but iterates zero times)
for (String s : empty) {
    System.out.println(s);  // Never executes
}

// ‚úÖ Stream operations
empty.stream().forEach(System.out::println);  // Does nothing

// ‚ùå Modification throws UnsupportedOperationException
// empty.add("A");
// empty.remove("A");
// empty.clear();
```

---

## üÜö Empty Collections vs null vs new

```java
// ‚ùå Using null (requires null checks)
public List<String> getItems() {
    if (noItems) return null;  // Caller must check null
    return items;
}

// Usage
List<String> items = getItems();
if (items != null) {  // Null check required
    for (String item : items) { }
}

// ‚ö†Ô∏è Creating new empty collection (unnecessary allocation)
public List<String> getItems() {
    if (noItems) return new ArrayList<>();  // Allocates memory
    return items;
}

// ‚úÖ Using empty collection (no null checks, no allocation)
public List<String> getItems() {
    if (noItems) return Collections.emptyList();  // Singleton, efficient
    return items;
}

// Usage
List<String> items = getItems();  // No null check needed
for (String item : items) { }  // Works even if empty
```

---

## üéØ Real-World Examples

### 1. No Results Found
```java
class UserRepository {
    public List<User> findByRole(String role) {
        List<User> results = database.query("SELECT * FROM users WHERE role = ?", role);
        
        // ‚úÖ Return empty list instead of null
        return results.isEmpty() ? Collections.emptyList() : results;
    }
}

// Usage - no null check needed
List<User> admins = repo.findByRole("ADMIN");
for (User admin : admins) {  // Safe even if empty
    System.out.println(admin);
}
```

---

### 2. Optional Results
```java
class OrderService {
    public List<Order> getRecentOrders(User user) {
        if (user == null) {
            return Collections.emptyList();  // Safe default
        }
        
        return orderRepository.findByUser(user);
    }
}
```

---

### 3. Filter Results
```java
class ProductService {
    public Set<Product> filterByCategory(String category) {
        if (category == null || category.isEmpty()) {
            return Collections.emptySet();  // No results
        }
        
        return products.stream()
                      .filter(p -> p.getCategory().equals(category))
                      .collect(Collectors.toSet());
    }
}
```

---

### 4. Default Configuration
```java
class ConfigLoader {
    public Map<String, String> loadConfig(String environment) {
        try {
            return parseConfigFile(environment);
        } catch (FileNotFoundException e) {
            // Return empty map if config not found
            return Collections.emptyMap();
        }
    }
}

// Usage
Map<String, String> config = loader.loadConfig("dev");
String host = config.getOrDefault("host", "localhost");  // Safe
```

---

### 5. Conditional Processing
```java
class ReportGenerator {
    public List<Report> generateReports(Date startDate, Date endDate) {
        if (startDate.after(endDate)) {
            return Collections.emptyList();  // Invalid date range
        }
        
        return fetchReports(startDate, endDate);
    }
}
```

---

### 6. Empty Iterator
```java
class CustomCollection<E> implements Iterable<E> {
    private List<E> items = new ArrayList<>();
    
    @Override
    public Iterator<E> iterator() {
        if (items.isEmpty()) {
            return Collections.emptyIterator();  // Efficient
        }
        return items.iterator();
    }
}
```

---

## üé® Singleton Pattern

```java
// All empty collections are singletons
List<String> empty1 = Collections.emptyList();
List<String> empty2 = Collections.emptyList();
List<Integer> empty3 = Collections.emptyList();

// Same instance for all
System.out.println(empty1 == empty2);  // true
System.out.println(empty1 == empty3);  // true (type erasure)

// Memory efficient - single instance reused
```

---

## üÜö Collections.emptyXxx() vs Java 9+ Xxx.of()

```java
// Java 1.5+ - Collections.emptyXxx()
List<String> empty1 = Collections.emptyList();
Set<Integer> empty2 = Collections.emptySet();
Map<String, Integer> empty3 = Collections.emptyMap();

// Java 9+ - Xxx.of()
List<String> empty4 = List.of();
Set<Integer> empty5 = Set.of();
Map<String, Integer> empty6 = Map.of();

// Both are immutable and efficient
// Use List.of() if Java 9+ for consistency
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Attempting to modify**
```java
List<String> empty = Collections.emptyList();
// ‚ùå UnsupportedOperationException
empty.add("A");

// ‚úÖ Create mutable if needed
List<String> mutable = new ArrayList<>(empty);
mutable.add("A");  // OK
```

2. **Type inference issues**
```java
// ‚ùå May need explicit type
List<String> list = condition ? Collections.emptyList() : getList();

// ‚úÖ Explicit type
List<String> list = condition ? Collections.<String>emptyList() : getList();
```

3. **Assuming different instances**
```java
List<String> list1 = Collections.emptyList();
List<String> list2 = Collections.emptyList();

// ‚ö†Ô∏è Same instance
System.out.println(list1 == list2);  // true
```

---

## üí° Best Practices

1. **Return empty collections instead of null**
```java
// ‚úÖ No null checks needed
public List<Item> getItems() {
    return items.isEmpty() ? Collections.emptyList() : items;
}

// ‚ùå Requires null checks
public List<Item> getItems() {
    return items.isEmpty() ? null : items;
}
```

2. **Use for default/fallback values**
```java
// ‚úÖ Safe default
List<String> results = database.query(sql).orElse(Collections.emptyList());
```

3. **Combine with Optional**
```java
// ‚úÖ Clean API
public Optional<List<User>> findUsers(String query) {
    List<User> results = search(query);
    return results.isEmpty() ? Optional.empty() : Optional.of(results);
}

// Or just return empty list
public List<User> findUsers(String query) {
    List<User> results = search(query);
    return results.isEmpty() ? Collections.emptyList() : results;
}
```

4. **Use in Stream operations**
```java
// ‚úÖ Safe default in flatMap
List<List<String>> lists = Arrays.asList(list1, list2, null, list3);
List<String> flattened = lists.stream()
    .flatMap(list -> list == null ? Collections.emptyList().stream() : list.stream())
    .collect(Collectors.toList());
```

---

## üéì When to Use Empty Collections

### ‚úÖ Use When:
- No results to return
- Default/fallback value needed
- Avoid null checks
- Memory efficiency important
- Type-safe empty collection needed

### ‚ùå Don't Use When:
- Need mutable empty collection
- Distinction between "no result" and "empty result" matters

---

## üìä Performance Benefits

```java
// ‚ùå Creates new object each time
public List<String> getItems() {
    return new ArrayList<>();  // Allocates memory
}

// ‚úÖ Reuses singleton
public List<String> getItems() {
    return Collections.emptyList();  // No allocation
}

// Performance comparison (1 million calls):
// new ArrayList<>():        ~50ms + GC overhead
// Collections.emptyList():  ~5ms (10x faster!)
```

---

## üìö Interview Questions

**Q1: Are empty collections immutable?**
A: Yes, they throw UnsupportedOperationException on modification.

**Q2: Are they singletons?**
A: Yes, same instance reused for all calls (memory efficient).

**Q3: Why use over null?**
A: Avoids null checks, type-safe, enables functional programming.

**Q4: Can you add elements?**
A: No, they're immutable (throws UnsupportedOperationException).

**Q5: Collections.emptyList() vs List.of()?**
A: Both immutable and efficient, List.of() is Java 9+ for consistency.

**Q6: Are they thread-safe?**
A: Yes, immutable by nature (no state changes).

**Q7: Performance benefit?**
A: Singleton pattern - no allocation overhead.

**Q8: When to use new ArrayList<>() instead?**
A: When you need a mutable empty collection to add elements later.

---

## üìö Summary

- **Empty Collections**: Immutable, singleton, type-safe empty collections
- **Methods**: emptyList(), emptySet(), emptyMap(), emptyIterator()
- **Benefits**: No null checks, memory efficient, thread-safe
- **Immutable**: Cannot modify (throws UnsupportedOperationException)
- **Singleton**: Same instance reused for all calls
- **Use case**: Return value when no results, default/fallback values
- **Modern alternative**: Java 9+ List.of(), Set.of(), Map.of()
