# üîí Synchronized Collections

## üìñ Overview

**Synchronized Collections** are thread-safe wrappers created using `Collections.synchronizedXxx()` methods. They provide **thread-safety** by synchronizing all methods, but require **manual synchronization for iteration**.

```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Set<Integer> syncSet = Collections.synchronizedSet(new HashSet<>());
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
```

---

## ‚≠ê Key Characteristics

1. **Thread-safe** - All methods synchronized
2. **Wrapper pattern** - Wraps existing collection
3. **Coarse-grained locking** - Locks entire collection (not scalable)
4. **Manual iteration sync** - Must synchronize iteration manually
5. **Performance** - Slower than concurrent collections
6. **Legacy approach** - Modern: Use `java.util.concurrent` collections

---

## üéØ Creating Synchronized Collections

```java
// 1. Synchronized List
List<String> list = new ArrayList<>();
List<String> syncList = Collections.synchronizedList(list);

// 2. Synchronized Set
Set<Integer> set = new HashSet<>();
Set<Integer> syncSet = Collections.synchronizedSet(set);

// 3. Synchronized Map
Map<String, Integer> map = new HashMap<>();
Map<String, Integer> syncMap = Collections.synchronizedMap(map);

// 4. Synchronized SortedSet
SortedSet<Integer> sortedSet = new TreeSet<>();
SortedSet<Integer> syncSortedSet = Collections.synchronizedSortedSet(sortedSet);

// 5. Synchronized SortedMap
SortedMap<String, Integer> sortedMap = new TreeMap<>();
SortedMap<String, Integer> syncSortedMap = Collections.synchronizedSortedMap(sortedMap);

// 6. Synchronized NavigableSet
NavigableSet<Integer> navSet = new TreeSet<>();
NavigableSet<Integer> syncNavSet = Collections.synchronizedNavigableSet(navSet);

// 7. Synchronized NavigableMap
NavigableMap<String, Integer> navMap = new TreeMap<>();
NavigableMap<String, Integer> syncNavMap = Collections.synchronizedNavigableMap(navMap);
```

---

## üíª Basic Operations (Thread-Safe)

```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// All these are thread-safe (internally synchronized)
syncList.add("A");        // ‚úÖ Thread-safe
syncList.remove("A");     // ‚úÖ Thread-safe
syncList.get(0);          // ‚úÖ Thread-safe
syncList.size();          // ‚úÖ Thread-safe
syncList.contains("A");   // ‚úÖ Thread-safe

// Compound operations are atomic
syncList.addAll(Arrays.asList("B", "C", "D"));  // ‚úÖ Thread-safe
```

---

## ‚ö†Ô∏è Manual Synchronization for Iteration

```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// ‚ùå NOT thread-safe!
for (String item : syncList) {
    System.out.println(item);  // ConcurrentModificationException possible
}

// ‚úÖ Thread-safe - synchronized block
synchronized(syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}

// ‚úÖ Thread-safe - iterator
synchronized(syncList) {
    Iterator<String> it = syncList.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}

// ‚úÖ Thread-safe - Stream
synchronized(syncList) {
    syncList.stream().forEach(System.out::println);
}
```

---

## üèóÔ∏è Internal Structure

```java
// Simplified internal implementation
static class SynchronizedList<E> extends SynchronizedCollection<E> implements List<E> {
    final List<E> list;
    final Object mutex;  // Lock object
    
    SynchronizedList(List<E> list) {
        this.list = list;
        this.mutex = this;  // Lock on this object
    }
    
    public E get(int index) {
        synchronized(mutex) {
            return list.get(index);
        }
    }
    
    public void add(int index, E element) {
        synchronized(mutex) {
            list.add(index, element);
        }
    }
    
    // All methods synchronized on mutex
}
```

---

## üéØ Real-World Examples

### 1. Shared Cache
```java
Map<String, User> userCache = Collections.synchronizedMap(new HashMap<>());

// Thread 1: Add user
userCache.put("user123", new User("John"));

// Thread 2: Get user
User user = userCache.get("user123");

// Thread 3: Remove user
userCache.remove("user123");

// Iterate safely
synchronized(userCache) {
    for (Map.Entry<String, User> entry : userCache.entrySet()) {
        System.out.println(entry.getKey() + ": " + entry.getValue());
    }
}
```

---

### 2. Task Queue
```java
List<Task> taskQueue = Collections.synchronizedList(new ArrayList<>());

// Producer thread
void addTask(Task task) {
    taskQueue.add(task);  // Thread-safe
}

// Consumer thread
Task getNextTask() {
    synchronized(taskQueue) {
        if (!taskQueue.isEmpty()) {
            return taskQueue.remove(0);
        }
    }
    return null;
}
```

---

### 3. Event Listeners
```java
Set<EventListener> listeners = Collections.synchronizedSet(new HashSet<>());

// Register listener
void addListener(EventListener listener) {
    listeners.add(listener);
}

// Notify all listeners
void notifyListeners(Event event) {
    synchronized(listeners) {
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
}

// Remove listener
void removeListener(EventListener listener) {
    listeners.remove(listener);
}
```

---

### 4. Configuration Store
```java
Map<String, String> config = Collections.synchronizedMap(new LinkedHashMap<>());

// Load configuration
void loadConfig() {
    config.put("host", "localhost");
    config.put("port", "8080");
    config.put("timeout", "30");
}

// Get config value
String getValue(String key) {
    return config.get(key);
}

// Print all config (need synchronization)
void printConfig() {
    synchronized(config) {
        config.forEach((key, value) -> 
            System.out.println(key + "=" + value)
        );
    }
}
```

---

### 5. Session Management
```java
Map<String, Session> sessions = Collections.synchronizedMap(new HashMap<>());

// Create session
String createSession(User user) {
    String sessionId = UUID.randomUUID().toString();
    sessions.put(sessionId, new Session(user));
    return sessionId;
}

// Validate session
boolean isValid(String sessionId) {
    return sessions.containsKey(sessionId);
}

// Clean expired sessions
void cleanExpired() {
    long now = System.currentTimeMillis();
    synchronized(sessions) {
        sessions.entrySet().removeIf(entry -> 
            entry.getValue().isExpired(now)
        );
    }
}
```

---

## üÜö Synchronized vs Concurrent Collections

| Feature | Synchronized | Concurrent (e.g., ConcurrentHashMap) |
|---------|-------------|--------------------------------------|
| **Locking** | Entire collection | Lock striping / CAS |
| **Concurrency** | Low (single lock) | High (multiple locks) |
| **Iteration** | Manual sync needed | Weakly consistent |
| **Performance** | Lower | Higher |
| **Reads** | Blocked by writes | Non-blocking |
| **Null support** | Depends on wrapped | Usually no null |
| **Use case** | Simple sync | High concurrency |

---

## ‚ö†Ô∏è Common Pitfalls

1. **Forgetting to synchronize iteration**
```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// ‚ùå ConcurrentModificationException possible
for (String item : syncList) {
    System.out.println(item);
}

// ‚úÖ Safe
synchronized(syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}
```

2. **Deadlock risk**
```java
// ‚ùå Potential deadlock
synchronized(syncList1) {
    synchronized(syncList2) {
        // ...
    }
}

// In another thread (reverse order)
synchronized(syncList2) {
    synchronized(syncList1) {
        // ...
    }
}

// ‚úÖ Always acquire locks in same order
```

3. **Performance bottleneck**
```java
// ‚ùå All threads blocked by single lock
List<Data> syncList = Collections.synchronizedList(new ArrayList<>());
// Heavy contention

// ‚úÖ Use concurrent collections for high contention
CopyOnWriteArrayList<Data> concurrentList = new CopyOnWriteArrayList<>();
```

4. **Compound operations not atomic**
```java
List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());

// ‚ùå Not atomic (check-then-act)
if (!syncList.isEmpty()) {
    syncList.remove(0);  // Another thread may remove first!
}

// ‚úÖ Atomic
synchronized(syncList) {
    if (!syncList.isEmpty()) {
        syncList.remove(0);
    }
}
```

5. **View collections need sync too**
```java
List<Integer> syncList = Collections.synchronizedList(new ArrayList<>());
List<Integer> subList = syncList.subList(0, 10);

// ‚ùå subList is NOT automatically synchronized
synchronized(syncList) {  // Must sync on original
    for (Integer num : subList) {
        System.out.println(num);
    }
}
```

---

## üí° Best Practices

1. **Use concurrent collections instead**
```java
// ‚ùå Legacy approach
List<String> list = Collections.synchronizedList(new ArrayList<>());

// ‚úÖ Modern approach
List<String> list = new CopyOnWriteArrayList<>();

// ‚úÖ For maps
Map<String, Integer> map = new ConcurrentHashMap<>();
```

2. **Always synchronize iteration**
```java
// ‚úÖ Synchronize on the collection
synchronized(syncList) {
    for (String item : syncList) {
        process(item);
    }
}
```

3. **Keep synchronized blocks short**
```java
// ‚ùå Long critical section
synchronized(syncList) {
    for (String item : syncList) {
        expensiveOperation(item);  // Blocks other threads
    }
}

// ‚úÖ Copy and process outside lock
List<String> copy;
synchronized(syncList) {
    copy = new ArrayList<>(syncList);
}
for (String item : copy) {
    expensiveOperation(item);
}
```

4. **Document synchronization requirements**
```java
/**
 * Thread-safe list. Iteration requires external synchronization:
 * synchronized(list) { for (Item item : list) {...} }
 */
private final List<Item> items = Collections.synchronizedList(new ArrayList<>());
```

---

## üéì When to Use Synchronized Collections

### ‚úÖ Use When:
- Simple synchronization needed
- Low contention scenarios
- Legacy code compatibility
- Wrapping existing collections

### ‚ùå Don't Use When:
- High concurrency required (use `java.util.concurrent`)
- Need lock-free operations (use `ConcurrentHashMap`)
- Frequent iterations (use `CopyOnWriteArrayList`)
- Need better scalability (use concurrent collections)

---

## üîÑ Migration to Concurrent Collections

```java
// Old: Synchronized collections
List<String> list = Collections.synchronizedList(new ArrayList<>());
Set<Integer> set = Collections.synchronizedSet(new HashSet<>());
Map<String, Data> map = Collections.synchronizedMap(new HashMap<>());

// New: Concurrent collections
List<String> list = new CopyOnWriteArrayList<>();
Set<Integer> set = ConcurrentHashMap.newKeySet();
Map<String, Data> map = new ConcurrentHashMap<>();
```

---

## üìö Interview Questions

**Q1: Are synchronized collections fully thread-safe?**
A: No, iteration requires manual synchronization.

**Q2: Why manual sync needed for iteration?**
A: Iteration involves multiple operations (hasNext, next) that must be atomic.

**Q3: Synchronized vs Concurrent collections?**
A: Synchronized uses single lock (lower concurrency), Concurrent uses lock striping/CAS (higher concurrency).

**Q4: Can compound operations cause issues?**
A: Yes, check-then-act requires external synchronization.

**Q5: What's the lock object?**
A: The synchronized collection itself (or specified mutex).

**Q6: Performance of synchronized collections?**
A: Lower than concurrent collections due to coarse-grained locking.

**Q7: Are they still recommended?**
A: No, use `java.util.concurrent` collections for new code.

**Q8: Do view collections (subList) need sync?**
A: Yes, must synchronize on original collection.

---

## üìö Summary

- **Synchronized Collections**: Thread-safe wrappers using single lock
- **Created by**: Collections.synchronizedList/Set/Map()
- **Thread-safety**: All methods synchronized
- **Iteration**: Requires manual synchronization
- **Performance**: Lower than concurrent collections (coarse-grained locking)
- **Modern alternative**: Use `java.util.concurrent` collections
- **Use case**: Simple synchronization, low contention, legacy compatibility
