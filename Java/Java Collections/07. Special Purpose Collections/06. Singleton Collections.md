# üéØ Singleton Collections

## üìñ Overview

**Singleton Collections** are **immutable collections** containing exactly **one element**, created using `Collections.singletonXxx()` methods. They're memory-efficient and type-safe.

```java
List<String> singletonList = Collections.singletonList("A");
Set<Integer> singletonSet = Collections.singleton(42);
Map<String, Integer> singletonMap = Collections.singletonMap("key", 100);
```

---

## ‚≠ê Key Characteristics

1. **Immutable** - Cannot be modified
2. **Single element** - Contains exactly one element
3. **Memory efficient** - Minimal memory footprint
4. **Type-safe** - Parameterized generics
5. **Thread-safe** - Immutable by nature
6. **No null elements** - Allows null but discouraged

---

## üéØ Available Singleton Collections

```java
// 1. Singleton List
List<String> list = Collections.singletonList("A");

// 2. Singleton Set
Set<Integer> set = Collections.singleton(42);

// 3. Singleton Map
Map<String, Integer> map = Collections.singletonMap("key", 100);
```

**Note:** Only these three types available (no SortedSet, NavigableMap, etc.)

---

## üíª Basic Operations

```java
List<String> list = Collections.singletonList("A");

// ‚úÖ Read operations work
String item = list.get(0);           // "A"
int size = list.size();              // 1
boolean isEmpty = list.isEmpty();    // false
boolean contains = list.contains("A");  // true

// ‚úÖ Iteration works
for (String s : list) {
    System.out.println(s);  // Prints "A"
}

// ‚úÖ Stream operations
list.stream().forEach(System.out::println);  // Prints "A"

// ‚ùå Modification throws UnsupportedOperationException
// list.add("B");
// list.remove("A");
// list.clear();
// list.set(0, "B");
```

---

## üéØ Real-World Examples

### 1. Single Result Query
```java
class UserRepository {
    public List<User> findById(Long id) {
        User user = database.queryOne("SELECT * FROM users WHERE id = ?", id);
        
        // ‚úÖ Return singleton list for single result
        return user != null ? Collections.singletonList(user) : Collections.emptyList();
    }
}

// Usage - consistent API (always returns List)
List<User> users = repo.findById(123L);
users.forEach(user -> System.out.println(user));  // Process if exists
```

---

### 2. Method Parameter
```java
class EmailService {
    public void sendEmail(List<String> recipients, String message) {
        // Send email to all recipients
        for (String email : recipients) {
            send(email, message);
        }
    }
}

// Send to single recipient
emailService.sendEmail(Collections.singletonList("user@example.com"), "Hello");

// Send to multiple recipients
emailService.sendEmail(Arrays.asList("user1@example.com", "user2@example.com"), "Hello");
```

---

### 3. Single Permission
```java
class User {
    private Set<String> permissions;
    
    // Grant single permission
    public void grantPermission(String permission) {
        if (permissions.isEmpty()) {
            permissions = Collections.singleton(permission);  // Efficient
        } else {
            permissions = new HashSet<>(permissions);
            permissions.add(permission);
        }
    }
}
```

---

### 4. Configuration Override
```java
class AppConfig {
    private Map<String, String> overrides = new HashMap<>();
    
    // Override single property
    public void overrideProperty(String key, String value) {
        overrides.put(key, value);
    }
    
    // Get overrides for specific key
    public Map<String, String> getOverride(String key) {
        String value = overrides.get(key);
        return value != null ? Collections.singletonMap(key, value) : Collections.emptyMap();
    }
}
```

---

### 5. Test Data
```java
@Test
public void testProcessSingleItem() {
    // ‚úÖ Create test data efficiently
    List<Order> orders = Collections.singletonList(new Order("ORD-001"));
    
    OrderProcessor processor = new OrderProcessor();
    processor.process(orders);
    
    // Verify...
}
```

---

### 6. Builder Pattern
```java
class QueryBuilder {
    private List<String> tables;
    
    public QueryBuilder from(String table) {
        this.tables = Collections.singletonList(table);
        return this;
    }
    
    public QueryBuilder from(String... tables) {
        this.tables = Arrays.asList(tables);
        return this;
    }
    
    public String build() {
        return "SELECT * FROM " + String.join(", ", tables);
    }
}

// Usage
String query = new QueryBuilder().from("users").build();
```

---

### 7. removeAll with Single Element
```java
List<String> items = new ArrayList<>(Arrays.asList("A", "B", "C", "B", "D"));

// ‚úÖ Remove all occurrences of "B" efficiently
items.removeAll(Collections.singleton("B"));
// Result: [A, C, D]

// More efficient than:
// items.removeIf(item -> item.equals("B"));
```

---

## üÜö Singleton vs Other Approaches

```java
// ‚ùå Creating single-element array
String[] array = {"A"};  // Array, not Collection

// ‚ùå Creating single-element ArrayList
List<String> list = new ArrayList<>();
list.add("A");  // Unnecessary allocation and mutability

// ‚ùå Using Arrays.asList()
List<String> list = Arrays.asList("A");  // Works but less clear intent

// ‚úÖ Using singletonList (best)
List<String> list = Collections.singletonList("A");  // Immutable, efficient, clear intent
```

---

## üÜö Collections.singletonXxx() vs Java 9+ Xxx.of()

```java
// Java 1.3+ - Collections.singletonXxx()
List<String> list1 = Collections.singletonList("A");
Set<Integer> set1 = Collections.singleton(42);
Map<String, Integer> map1 = Collections.singletonMap("key", 100);

// Java 9+ - Xxx.of() (preferred)
List<String> list2 = List.of("A");
Set<Integer> set2 = Set.of(42);
Map<String, Integer> map2 = Map.of("key", 100);

// Both are immutable and efficient
// Use Xxx.of() if Java 9+ for consistency
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Attempting to modify**
```java
List<String> list = Collections.singletonList("A");
// ‚ùå UnsupportedOperationException
list.add("B");
list.remove("A");
list.clear();

// ‚úÖ Create mutable if needed
List<String> mutable = new ArrayList<>(list);
mutable.add("B");  // OK
```

2. **Null elements (allowed but discouraged)**
```java
// ‚ö†Ô∏è Allowed but not recommended
List<String> list = Collections.singletonList(null);
Set<Integer> set = Collections.singleton(null);
Map<String, Integer> map = Collections.singletonMap("key", null);

// ‚úÖ Use Optional or avoid null
List<Optional<String>> list = Collections.singletonList(Optional.empty());
```

3. **Type inference issues**
```java
// ‚ùå May need explicit type
List<String> list = condition ? Collections.singletonList("A") : getList();

// ‚úÖ Explicit type
List<String> list = condition ? Collections.<String>singletonList("A") : getList();
```

4. **Confusion with singleton pattern**
```java
// ‚ö†Ô∏è Different instances (not singleton pattern)
List<String> list1 = Collections.singletonList("A");
List<String> list2 = Collections.singletonList("A");
System.out.println(list1 == list2);  // false (different instances)

// Each call creates new instance (unlike emptyList() which is singleton)
```

---

## üí° Best Practices

1. **Use for single-element scenarios**
```java
// ‚úÖ Clear intent
return Collections.singletonList(result);

// ‚ùå Unnecessary overhead
List<String> list = new ArrayList<>();
list.add(result);
return list;
```

2. **Use in removeAll/retainAll**
```java
// ‚úÖ Efficient removal of single element
list.removeAll(Collections.singleton("X"));

// ‚ùå Less efficient
list.removeIf(item -> item.equals("X"));
```

3. **Use for method parameters expecting collections**
```java
// ‚úÖ Pass single value as collection
processor.process(Collections.singletonList(item));

// ‚ùå Overload method unnecessarily
// processor.process(item);
```

4. **Combine with streams**
```java
// ‚úÖ Stream operations
Collections.singletonList("A")
           .stream()
           .map(String::toUpperCase)
           .forEach(System.out::println);
```

---

## üéì When to Use Singleton Collections

### ‚úÖ Use When:
- Returning single result as collection
- Method expects collection but you have one element
- Efficient single-element immutable collection needed
- Testing with single-element data
- removeAll/retainAll with single element

### ‚ùå Don't Use When:
- Need mutable single-element collection
- May need to add more elements later
- Java 9+ available (use List.of() instead)

---

## üìä Performance Benefits

```java
// Performance comparison (1 million calls):

// ‚ùå ArrayList with one element
List<String> list = new ArrayList<>();
list.add("A");
// ~80ms + GC overhead

// ‚úÖ singletonList
List<String> list = Collections.singletonList("A");
// ~15ms (5x faster!)

// Memory comparison:
// ArrayList: ~36 bytes (array + ArrayList overhead)
// singletonList: ~16 bytes (minimal wrapper)
```

---

## üÜö Comparison Summary

| Feature | singletonList | List.of("A") | Arrays.asList("A") | new ArrayList() |
|---------|--------------|--------------|-------------------|-----------------|
| **Immutable** | ‚úÖ Yes | ‚úÖ Yes | ‚ö†Ô∏è Fixed-size | ‚ùå No |
| **Memory** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Java Version** | 1.3+ | 9+ | 1.2+ | 1.0+ |
| **Null allowed** | Yes | No | Yes | Yes |
| **Use case** | Single element | Single element | Fixed array | Mutable list |

---

## üìö Interview Questions

**Q1: Are singleton collections immutable?**
A: Yes, they throw UnsupportedOperationException on modification.

**Q2: Can they contain null?**
A: Yes, but discouraged (List.of() doesn't allow null).

**Q3: Are they singletons (design pattern)?**
A: No, each call creates new instance (unlike emptyList() which is singleton).

**Q4: singletonList vs List.of("A")?**
A: Both immutable, List.of() is Java 9+ and preferred for consistency.

**Q5: Why use over ArrayList with one element?**
A: More efficient (memory and performance), immutable, clear intent.

**Q6: Can you add more elements?**
A: No, immutable (throws UnsupportedOperationException).

**Q7: When to use in removeAll()?**
A: Efficiently remove all occurrences of single element from collection.

**Q8: Are they thread-safe?**
A: Yes, immutable by nature.

---

## üìö Summary

- **Singleton Collections**: Immutable single-element collections
- **Methods**: singletonList(), singleton(), singletonMap()
- **Immutable**: Cannot modify (throws UnsupportedOperationException)
- **Memory efficient**: Minimal overhead compared to ArrayList
- **Use case**: Single result, method parameters, test data, removeAll()
- **Modern alternative**: Java 9+ List.of(), Set.of(), Map.of()
- **Thread-safe**: Immutable by nature
