# üé® Custom Sorting

## üìñ Overview

**Custom sorting** involves creating advanced sorting strategies using multiple comparators, lambda expressions, and specialized sorting patterns for complex requirements.

```java
// Multi-field sorting
list.sort(Comparator.comparing(Person::getAge)
                    .thenComparing(Person::getName));

// Custom logic
list.sort((a, b) -> customCompareLogic(a, b));
```

---

## ‚≠ê Key Patterns

1. **Multi-field sorting** - Chain multiple comparators
2. **Null-safe sorting** - Handle null values gracefully
3. **Custom business logic** - Domain-specific ordering
4. **Reverse/Mixed order** - Some ascending, some descending
5. **Conditional sorting** - Different logic based on condition
6. **Complex object graphs** - Nested object comparisons

---

## üíª Multi-Field Sorting

### 1. Chaining Comparators
```java
class Employee {
    String department;
    int salary;
    String name;
}

List<Employee> employees = getEmployees();

// Sort by department, then salary (desc), then name
employees.sort(
    Comparator.comparing(Employee::getDepartment)
              .thenComparingInt(Employee::getSalary).reversed()
              .thenComparing(Employee::getName)
);
```

### 2. Mixed Ascending/Descending
```java
// Age ascending, name descending
list.sort(
    Comparator.comparingInt(Person::getAge)
              .thenComparing(Person::getName, Comparator.reverseOrder())
);
```

### 3. Nested Objects
```java
class Student {
    Address address;
    int grade;
}

class Address {
    String city;
    String street;
}

// Sort by city, then street, then grade
students.sort(
    Comparator.comparing((Student s) -> s.address.city)
              .thenComparing(s -> s.address.street)
              .thenComparingInt(Student::getGrade)
);
```

---

## üéØ Real-World Examples

### 1. E-Commerce Product Sorting
```java
class Product {
    String category;
    double rating;
    int sales;
    double price;
    boolean inStock;
}

List<Product> products = getProducts();

// Priority: in stock > rating > sales > price (low to high)
products.sort(
    Comparator.comparing(Product::isInStock).reversed()  // In stock first
              .thenComparing(Product::getRating).reversed()  // High rating
              .thenComparingInt(Product::getSales).reversed()  // High sales
              .thenComparingDouble(Product::getPrice)  // Low price
);
```

---

### 2. Task Priority System
```java
class Task {
    Priority priority;  // HIGH, MEDIUM, LOW
    LocalDate dueDate;
    boolean isUrgent;
    String name;
}

enum Priority { HIGH(1), MEDIUM(2), LOW(3); }

// Sort: urgent first > priority > due date > name
tasks.sort(
    Comparator.comparing(Task::isUrgent).reversed()
              .thenComparingInt(t -> t.priority.value)
              .thenComparing(Task::getDueDate)
              .thenComparing(Task::getName)
);
```

---

### 3. Social Media Feed Ranking
```java
class Post {
    LocalDateTime timestamp;
    int likes;
    int comments;
    int shares;
    boolean isPinned;
    User author;
}

// Pinned > engagement score > recency
posts.sort(
    Comparator.comparing(Post::isPinned).reversed()
              .thenComparingInt(p -> p.likes + p.comments * 2 + p.shares * 3).reversed()
              .thenComparing(Post::getTimestamp).reversed()
);
```

---

### 4. Sports Leaderboard
```java
class Player {
    int wins;
    int losses;
    int pointDifference;
    String name;
}

// Win rate > point diff > name
players.sort(
    Comparator.comparingDouble((Player p) -> (double) p.wins / (p.wins + p.losses)).reversed()
              .thenComparingInt(Player::getPointDifference).reversed()
              .thenComparing(Player::getName)
);
```

---

### 5. File System Sorting
```java
class FileEntry {
    boolean isDirectory;
    String extension;
    long size;
    LocalDateTime modified;
    String name;
}

// Directories first > extension > size (desc) > name
files.sort(
    Comparator.comparing(FileEntry::isDirectory).reversed()
              .thenComparing(FileEntry::getExtension)
              .thenComparingLong(FileEntry::getSize).reversed()
              .thenComparing(FileEntry::getName, String.CASE_INSENSITIVE_ORDER)
);
```

---

## üõ°Ô∏è Null-Safe Sorting

### 1. Nulls First/Last
```java
List<String> names = Arrays.asList("Alice", null, "Bob", null, "Charlie");

// Nulls last
names.sort(Comparator.nullsLast(Comparator.naturalOrder()));
// [Alice, Bob, Charlie, null, null]

// Nulls first
names.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
// [null, null, Alice, Bob, Charlie]
```

### 2. Null Fields
```java
class Person {
    String name;  // Can be null
    Integer age;  // Can be null
}

// Null-safe multi-field
list.sort(
    Comparator.comparing(Person::getName, Comparator.nullsLast(String::compareTo))
              .thenComparing(Person::getAge, Comparator.nullsLast(Integer::compareTo))
);
```

### 3. Custom Null Handling
```java
// Treat null as empty string
list.sort(Comparator.comparing(
    p -> p.getName() != null ? p.getName() : "",
    String.CASE_INSENSITIVE_ORDER
));
```

---

## üßÆ Custom Business Logic

### 1. Version Numbers
```java
class Version {
    int major;
    int minor;
    int patch;
}

// Sort by major.minor.patch
versions.sort((v1, v2) -> {
    int cmp = Integer.compare(v1.major, v2.major);
    if (cmp != 0) return cmp;
    
    cmp = Integer.compare(v1.minor, v2.minor);
    if (cmp != 0) return cmp;
    
    return Integer.compare(v1.patch, v2.patch);
});

// Or using Comparator
versions.sort(
    Comparator.comparingInt(Version::getMajor)
              .thenComparingInt(Version::getMinor)
              .thenComparingInt(Version::getPatch)
);
```

---

### 2. Status Priority Mapping
```java
enum Status { CRITICAL, HIGH, MEDIUM, LOW }

Map<Status, Integer> priorityMap = Map.of(
    Status.CRITICAL, 1,
    Status.HIGH, 2,
    Status.MEDIUM, 3,
    Status.LOW, 4
);

tasks.sort(Comparator.comparingInt(t -> priorityMap.get(t.status)));
```

---

### 3. Distance-Based Sorting
```java
class Location {
    double lat;
    double lon;
    
    double distanceTo(Location other) {
        // Haversine formula
        return Math.sqrt(Math.pow(lat - other.lat, 2) + Math.pow(lon - other.lon, 2));
    }
}

Location userLocation = getCurrentLocation();

// Sort by distance from user
locations.sort(Comparator.comparingDouble(loc -> loc.distanceTo(userLocation)));
```

---

### 4. Weighted Score
```java
class Candidate {
    int experience;  // Weight: 40%
    int education;   // Weight: 30%
    int skills;      // Weight: 30%
    
    double getScore() {
        return experience * 0.4 + education * 0.3 + skills * 0.3;
    }
}

// Sort by weighted score
candidates.sort(Comparator.comparingDouble(Candidate::getScore).reversed());
```

---

## üîÄ Conditional Sorting

### 1. Different Sort by User Preference
```java
enum SortOption { PRICE, RATING, POPULARITY }

SortOption userChoice = SortOption.RATING;

Comparator<Product> comparator = switch (userChoice) {
    case PRICE -> Comparator.comparingDouble(Product::getPrice);
    case RATING -> Comparator.comparingDouble(Product::getRating).reversed();
    case POPULARITY -> Comparator.comparingInt(Product::getSales).reversed();
};

products.sort(comparator);
```

---

### 2. Time-Based Sorting
```java
LocalDateTime now = LocalDateTime.now();

// Different sort for recent vs old posts
posts.sort((p1, p2) -> {
    boolean p1Recent = p1.timestamp.isAfter(now.minusDays(7));
    boolean p2Recent = p2.timestamp.isAfter(now.minusDays(7));
    
    if (p1Recent && !p2Recent) return -1;
    if (!p1Recent && p2Recent) return 1;
    
    // Both recent or both old: sort by engagement
    return Integer.compare(p2.likes, p1.likes);
});
```

---

## üé≠ Advanced Techniques

### 1. Group Then Sort
```java
// Sort students: top performers first, then by name
students.sort(
    Comparator.<Student>comparingInt(s -> s.grade >= 90 ? 0 : 1)
              .thenComparing(Student::getName)
);
```

---

### 2. Stable Sort with Index
```java
// Preserve original order for equal elements
List<Item> items = getItems();

// Add index
for (int i = 0; i < items.size(); i++) {
    items.get(i).originalIndex = i;
}

// Sort by value, then by original index
items.sort(
    Comparator.comparingInt(Item::getValue)
              .thenComparingInt(Item::getOriginalIndex)
);
```

---

### 3. Custom Collation (Internationalization)
```java
Collator collator = Collator.getInstance(new Locale("sv", "SE"));  // Swedish

List<String> words = Arrays.asList("√§", "z", "a");
words.sort(collator);  // Uses locale-specific rules
```

---

### 4. Partial Sorting (Top-K)
```java
// Get top 10 without sorting entire list
List<Product> products = getProducts();

// Use Stream
List<Product> top10 = products.stream()
    .sorted(Comparator.comparingDouble(Product::getRating).reversed())
    .limit(10)
    .collect(Collectors.toList());

// Or PriorityQueue for large datasets
PriorityQueue<Product> pq = new PriorityQueue<>(
    10, 
    Comparator.comparingDouble(Product::getRating)
);
products.forEach(pq::offer);
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Overflow in subtraction**
```java
// ‚ùå Can overflow
list.sort((a, b) -> a.value - b.value);

// ‚úÖ Use compare methods
list.sort(Comparator.comparingInt(Item::getValue));
```

2. **Inconsistent comparator**
```java
// ‚ùå Violates transitivity
list.sort((a, b) -> {
    if (a.x > b.x) return 1;
    if (a.y > b.y) return -1;
    return 0;
});

// ‚úÖ Consistent logic
list.sort(Comparator.comparingInt(Item::getX)
                    .thenComparingInt(Item::getY));
```

3. **Modifying objects during sort**
```java
// ‚ùå Don't modify during sort
list.sort((a, b) -> {
    a.visited = true;  // Bad!
    return a.value - b.value;
});
```

4. **Not handling nulls**
```java
// ‚ùå NullPointerException
list.sort(Comparator.comparing(Person::getName));

// ‚úÖ Null-safe
list.sort(Comparator.comparing(Person::getName, Comparator.nullsLast(String::compareTo)));
```

---

## üí° Best Practices

1. **Use factory methods**
```java
// ‚úÖ Clear and concise
Comparator.comparing(Person::getName)
          .thenComparingInt(Person::getAge);
```

2. **Extract comparators for reuse**
```java
// ‚úÖ Reusable comparators
Comparator<Product> byRating = Comparator.comparingDouble(Product::getRating).reversed();
Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);

products.sort(byRating.thenComparing(byPrice));
```

3. **Document complex sorting logic**
```java
// ‚úÖ Clear documentation
/**
 * Sorts employees by:
 * 1. Department (ascending)
 * 2. Salary (descending)
 * 3. Name (ascending, case-insensitive)
 */
employees.sort(
    Comparator.comparing(Employee::getDepartment)
              .thenComparingInt(Employee::getSalary).reversed()
              .thenComparing(Employee::getName, String.CASE_INSENSITIVE_ORDER)
);
```

4. **Use method references**
```java
// ‚úÖ Concise
list.sort(Comparator.comparing(Person::getName));

// ‚ùå Verbose
list.sort((a, b) -> a.getName().compareTo(b.getName()));
```

---

## üìö Interview Questions

**Q1: How to sort by multiple fields?**
A: Chain comparators using thenComparing(): `comparing(A).thenComparing(B)`.

**Q2: How to handle nulls?**
A: Use nullsFirst() or nullsLast(): `nullsLast(naturalOrder())`.

**Q3: Sort some ascending, some descending?**
A: Use reversed() selectively: `comparing(A).thenComparing(B).reversed()`.

**Q4: Best practice for custom comparator?**
A: Use Comparator factory methods, avoid subtraction, handle nulls.

**Q5: How to sort by computed value?**
A: Use comparing() with method reference or lambda computing value.

**Q6: Stable sort importance?**
A: Maintains relative order of equal elements, important for multi-pass sorting.

**Q7: Performance of chained comparators?**
A: O(n log n) same as simple sort, small constant overhead for chaining.

**Q8: Extract top K elements efficiently?**
A: Use PriorityQueue or Stream with limit(), avoids full sort.

---

## üìö Summary

- **Custom sorting**: Advanced comparator patterns for complex requirements
- **Multi-field**: Chain comparators with thenComparing()
- **Null-safe**: Use nullsFirst/nullsLast
- **Business logic**: Custom comparison based on domain rules
- **Best practices**: Use factory methods, handle nulls, document complex logic
- **Patterns**: Multi-field, conditional, weighted, distance-based, status priority
