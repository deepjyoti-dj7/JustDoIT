# ğŸ” Binary Search

## ğŸ“– Overview

**Binary Search** is an efficient search algorithm for finding an element in a **sorted** array or collection. It uses divide-and-conquer with **O(log n)** time complexity.

```java
// Arrays.binarySearch()
int index = Arrays.binarySearch(array, key);

// Collections.binarySearch()
int index = Collections.binarySearch(list, key);
```

**Prerequisite**: Array/List must be **sorted** in ascending order.

---

## â­ Key Characteristics

1. **Time complexity** - O(log n) - very fast
2. **Requirement** - Array/List must be sorted
3. **Return value** - Index if found, -(insertion point) - 1 if not
4. **Works with** - Arrays and Lists
5. **Custom comparator** - Supported for objects
6. **Range search** - Can search in subarray/sublist

---

## ğŸ“ Method Signatures

### Arrays.binarySearch()
```java
// Primitives
int binarySearch(int[] a, int key)
int binarySearch(int[] a, int fromIndex, int toIndex, int key)

// Objects (Comparable)
<T> int binarySearch(T[] a, T key)
<T> int binarySearch(T[] a, int fromIndex, int toIndex, T key)

// Objects (Comparator)
<T> int binarySearch(T[] a, T key, Comparator<? super T> c)
<T> int binarySearch(T[] a, int fromIndex, int toIndex, T key, Comparator<? super T> c)
```

### Collections.binarySearch()
```java
// Comparable
<T extends Comparable<? super T>> int binarySearch(List<? extends T> list, T key)

// Comparator
<T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c)
```

---

## ğŸ’» Basic Usage

### 1. Search Primitive Arrays
```java
int[] numbers = {1, 3, 5, 7, 9, 11, 13};  // MUST be sorted

int index = Arrays.binarySearch(numbers, 7);
System.out.println("Found at index: " + index);  // 3

int notFound = Arrays.binarySearch(numbers, 8);
System.out.println("Not found: " + notFound);  // -5 (insertion point 4)
```

### 2. Search Object Arrays
```java
String[] names = {"Alice", "Bob", "Charlie", "David"};  // Sorted

int index = Arrays.binarySearch(names, "Charlie");
System.out.println("Found at: " + index);  // 2

int notFound = Arrays.binarySearch(names, "Eve");
System.out.println("Not found: " + notFound);  // -5 (insertion point 4)
```

### 3. Search Lists
```java
List<Integer> list = Arrays.asList(10, 20, 30, 40, 50);  // Sorted

int index = Collections.binarySearch(list, 30);
System.out.println("Found at: " + index);  // 2

int notFound = Collections.binarySearch(list, 25);
System.out.println("Not found: " + notFound);  // -3 (insertion point 2)
```

### 4. Search with Comparator
```java
String[] names = {"alice", "bob", "charlie", "david"};
Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);

// Must use same comparator for search
int index = Arrays.binarySearch(names, "BOB", String.CASE_INSENSITIVE_ORDER);
System.out.println("Found at: " + index);  // 1
```

---

## ğŸ“Š Understanding Return Values

```java
int[] arr = {10, 20, 30, 40, 50};

// Found: returns index
int result1 = Arrays.binarySearch(arr, 30);  // 2

// Not found: returns -(insertion point) - 1
int result2 = Arrays.binarySearch(arr, 25);  // -3

// Convert to insertion point
int insertionPoint = -(result2) - 1;  // 2
System.out.println("Insert at: " + insertionPoint);  // 25 should go at index 2
```

**Formula**: If not found, return value = -(insertion point) - 1
- **Insertion point** = index where element would be inserted
- To get insertion point: `int insertion = -(result) - 1`

---

## ğŸ¯ Real-World Examples

### 1. Check if Element Exists
```java
int[] scores = {65, 72, 78, 85, 90, 95};

int searchScore = 85;
int index = Arrays.binarySearch(scores, searchScore);

if (index >= 0) {
    System.out.println("Score " + searchScore + " found at index " + index);
} else {
    System.out.println("Score " + searchScore + " not found");
}
```

---

### 2. Find Insertion Point
```java
List<Integer> sorted = new ArrayList<>(Arrays.asList(10, 30, 50, 70, 90));

int newValue = 60;
int result = Collections.binarySearch(sorted, newValue);

if (result < 0) {
    int insertionPoint = -(result) - 1;
    sorted.add(insertionPoint, newValue);
    System.out.println("Inserted at index: " + insertionPoint);
}

System.out.println(sorted);  // [10, 30, 50, 60, 70, 90]
```

---

### 3. Search in Employee Database
```java
class Employee implements Comparable<Employee> {
    int id;
    String name;
    
    // Constructor
    
    @Override
    public int compareTo(Employee o) {
        return Integer.compare(this.id, o.id);
    }
}

Employee[] employees = {
    new Employee(101, "Alice"),
    new Employee(205, "Bob"),
    new Employee(310, "Charlie")
};

Arrays.sort(employees);  // Sort by id

Employee search = new Employee(205, null);
int index = Arrays.binarySearch(employees, search);

if (index >= 0) {
    System.out.println("Found: " + employees[index].name);
}
```

---

### 4. Count Occurrences
```java
int[] arr = {1, 2, 2, 2, 3, 4, 5};

// Find first occurrence
int target = 2;
int index = Arrays.binarySearch(arr, target);

if (index >= 0) {
    // Expand left
    int left = index;
    while (left > 0 && arr[left - 1] == target) {
        left--;
    }
    
    // Expand right
    int right = index;
    while (right < arr.length - 1 && arr[right + 1] == target) {
        right++;
    }
    
    int count = right - left + 1;
    System.out.println("Count: " + count);  // 3
}
```

---

### 5. Range Search
```java
int[] arr = {10, 20, 30, 40, 50, 60, 70, 80, 90};

// Search in range [2, 6)
int result = Arrays.binarySearch(arr, 2, 6, 40);
System.out.println("Found at: " + result);  // 3

// Search outside range
int result2 = Arrays.binarySearch(arr, 2, 6, 70);
System.out.println("Not in range: " + result2);  // Negative
```

---

## âš ï¸ Common Pitfalls

1. **Array/List not sorted**
```java
int[] arr = {3, 1, 4, 1, 5};  // NOT sorted

// âŒ Undefined behavior - may return wrong result
int result = Arrays.binarySearch(arr, 4);

// âœ… Sort first
Arrays.sort(arr);
int result2 = Arrays.binarySearch(arr, 4);
```

2. **Wrong comparator**
```java
String[] arr = {"alice", "bob", "charlie"};
Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);

// âŒ Search without comparator - wrong result
int result1 = Arrays.binarySearch(arr, "BOB");

// âœ… Use same comparator
int result2 = Arrays.binarySearch(arr, "BOB", String.CASE_INSENSITIVE_ORDER);
```

3. **Not checking negative result**
```java
int[] arr = {10, 20, 30};

int index = Arrays.binarySearch(arr, 25);

// âŒ Direct access without checking
// System.out.println(arr[index]);  // ArrayIndexOutOfBoundsException

// âœ… Check if found
if (index >= 0) {
    System.out.println(arr[index]);
} else {
    System.out.println("Not found");
}
```

4. **Misinterpreting insertion point**
```java
int[] arr = {10, 20, 30, 40};

int result = Arrays.binarySearch(arr, 25);  // -3

// âŒ Using negative value directly
// arr[result] = 25;  // ArrayIndexOutOfBoundsException

// âœ… Calculate insertion point
int insertionPoint = -(result) - 1;  // 2
```

5. **RandomAccess list performance**
```java
// âœ… Fast - ArrayList (RandomAccess)
List<Integer> arrayList = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(arrayList, 3);  // O(log n)

// âš ï¸ Slow - LinkedList (no RandomAccess)
List<Integer> linkedList = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(linkedList, 3);  // O(n) - linear search!
```

---

## ğŸ’¡ Best Practices

1. **Always sort before binary search**
```java
// âœ… Sort first
int[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr);
int index = Arrays.binarySearch(arr, 4);
```

2. **Check if element exists before accessing**
```java
// âœ… Safe access
int index = Arrays.binarySearch(arr, key);
if (index >= 0) {
    System.out.println(arr[index]);
}
```

3. **Use same comparator for sort and search**
```java
// âœ… Consistent comparator
Comparator<String> cmp = String.CASE_INSENSITIVE_ORDER;
Arrays.sort(arr, cmp);
int index = Arrays.binarySearch(arr, key, cmp);
```

4. **Calculate insertion point correctly**
```java
// âœ… Get insertion point
int result = Arrays.binarySearch(arr, key);
if (result < 0) {
    int insertionPoint = -(result) - 1;
    // Use insertionPoint
}
```

5. **Use ArrayList for Collections.binarySearch()**
```java
// âœ… Use RandomAccess list for O(log n)
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
Collections.binarySearch(list, 3);
```

---

## ğŸ†š Binary Search vs Linear Search

| Feature | Binary Search | Linear Search |
|---------|--------------|---------------|
| **Time complexity** | O(log n) | O(n) |
| **Requirement** | Sorted | Any order |
| **Best for** | Large sorted data | Small/unsorted data |
| **Implementation** | Complex | Simple |

```java
int[] arr = {10, 20, 30, 40, 50};

// Binary search - O(log n)
Arrays.sort(arr);  // If not sorted
int binary = Arrays.binarySearch(arr, 30);

// Linear search - O(n)
int linear = -1;
for (int i = 0; i < arr.length; i++) {
    if (arr[i] == 30) {
        linear = i;
        break;
    }
}
```

---

## ğŸ”„ Manual Binary Search Implementation

```java
public static int binarySearch(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // Avoid overflow
        
        if (arr[mid] == target) {
            return mid;  // Found
        } else if (arr[mid] < target) {
            left = mid + 1;  // Search right half
        } else {
            right = mid - 1;  // Search left half
        }
    }
    
    return -(left) - 1;  // Not found, return insertion point
}

// Usage
int[] arr = {10, 20, 30, 40, 50};
int index = binarySearch(arr, 35);  // -4 (insertion point 3)
```

---

## ğŸ“ When to Use Binary Search

### âœ… Use When:
- Data is sorted
- Frequent searches on same data
- Large datasets (> 100 elements)
- O(log n) performance needed

### âŒ Don't Use When:
- Data is unsorted (cost of sorting > benefit)
- Small datasets (linear search simpler)
- Frequent insertions/deletions (sorting overhead)

---

## ğŸ“š Interview Questions

**Q1: Time complexity of binary search?**
A: O(log n) - divides search space in half each step.

**Q2: Prerequisite for binary search?**
A: Array/List must be sorted in ascending order.

**Q3: What does negative return value mean?**
A: Element not found. Value = -(insertion point) - 1.

**Q4: Can you use binary search on unsorted data?**
A: No, results are undefined. Must sort first.

**Q5: Binary search on LinkedList?**
A: O(n) - no random access. Use ArrayList instead.

**Q6: How to get insertion point?**
A: If result < 0, insertion point = -(result) - 1.

**Q7: Why use same comparator for sort and search?**
A: Ensures consistent ordering, correct results.

**Q8: Binary search vs linear search?**
A: Binary O(log n) but requires sorted data. Linear O(n) works on any data.

---

## ğŸ“š Summary

- **Binary search**: O(log n) search algorithm
- **Requirement**: Sorted array/list
- **Return value**: Index if found, -(insertion point) - 1 if not
- **Methods**: Arrays.binarySearch(), Collections.binarySearch()
- **Best for**: Large sorted datasets with frequent searches
- **Pitfall**: Must be sorted, use same comparator
