# ‚öñÔ∏è Comparator Interface

## üìñ Overview

**Comparator** interface defines **custom ordering** for objects. It's external to the class, allowing multiple sort orders without modifying the class.

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
    
    // Default and static methods (Java 8+)
    default Comparator<T> reversed() { ... }
    default Comparator<T> thenComparing(...) { ... }
    static <T> Comparator<T> comparing(...) { ... }
    // ... more methods
}
```

---

## ‚≠ê Key Characteristics

1. **External ordering** - Separate from class definition
2. **Functional interface** - Can use lambda expressions
3. **Multiple orderings** - Different comparators for different needs
4. **Doesn't modify class** - Works with third-party classes
5. **Chainable** - `thenComparing()` for multi-field sorting
6. **Factory methods** - `comparing()`, `comparingInt()`, etc.
7. **Null-safe** - `nullsFirst()`, `nullsLast()`

---

## üìù Basic Implementation

```java
// Anonymous class (traditional)
Comparator<Student> byGrade = new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        return Integer.compare(s1.getGrade(), s2.getGrade());
    }
};

// Lambda expression (Java 8+)
Comparator<Student> byGrade = (s1, s2) -> Integer.compare(s1.getGrade(), s2.getGrade());

// Method reference (Java 8+)
Comparator<Student> byName = Comparator.comparing(Student::getName);
```

---

## üéØ Factory Methods (Java 8+)

### 1. comparing() - For Objects
```java
// Single field
Comparator<Employee> byName = Comparator.comparing(Employee::getName);

// With custom comparator
Comparator<Employee> byNameIgnoreCase = 
    Comparator.comparing(Employee::getName, String.CASE_INSENSITIVE_ORDER);
```

### 2. comparingInt/Long/Double - For Primitives
```java
Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);
Comparator<User> byAge = Comparator.comparingInt(User::getAge);
Comparator<File> bySize = Comparator.comparingLong(File::length);
```

### 3. naturalOrder() / reverseOrder()
```java
Comparator<String> natural = Comparator.naturalOrder();  // A-Z
Comparator<String> reverse = Comparator.reverseOrder();  // Z-A
```

### 4. nullsFirst() / nullsLast()
```java
Comparator<String> nullsFirst = Comparator.nullsFirst(Comparator.naturalOrder());
Comparator<String> nullsLast = Comparator.nullsLast(Comparator.naturalOrder());
```

---

## üîó Chaining Comparators

### thenComparing()
```java
// Sort by grade (ascending), then by name (ascending)
Comparator<Student> comparator = Comparator.comparing(Student::getGrade)
                                           .thenComparing(Student::getName);

// Sort by department, then by salary (descending), then by name
Comparator<Employee> comparator = Comparator.comparing(Employee::getDepartment)
                                            .thenComparing(Employee::getSalary, Comparator.reverseOrder())
                                            .thenComparing(Employee::getName);
```

---

## üíª Common Patterns

### 1. Ascending Order
```java
Comparator<Integer> ascending = Comparator.naturalOrder();
Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);
```

### 2. Descending Order
```java
Comparator<Integer> descending = Comparator.reverseOrder();
Comparator<Product> byPriceDesc = Comparator.comparingDouble(Product::getPrice).reversed();
```

### 3. Case-Insensitive String
```java
Comparator<String> caseInsensitive = String.CASE_INSENSITIVE_ORDER;
Comparator<Person> byNameIgnoreCase = 
    Comparator.comparing(Person::getName, String.CASE_INSENSITIVE_ORDER);
```

### 4. Null-Safe Comparison
```java
Comparator<String> nullSafe = Comparator.nullsLast(Comparator.naturalOrder());

Comparator<Employee> byName = Comparator.comparing(
    Employee::getName,
    Comparator.nullsLast(String::compareTo)
);
```

### 5. Multi-Field Comparison
```java
Comparator<Student> comparator = 
    Comparator.comparing(Student::getGrade)           // Primary: grade
              .thenComparing(Student::getName)        // Secondary: name
              .thenComparingInt(Student::getRollNo);  // Tertiary: roll number
```

---

## üéØ Real-World Examples

### 1. Leaderboard (Score Descending)
```java
List<Player> players = getPlayers();

// Sort by score (highest first), then by name
Comparator<Player> leaderboard = 
    Comparator.comparingInt(Player::getScore).reversed()
              .thenComparing(Player::getName);

players.sort(leaderboard);
```

---

### 2. Employee Directory
```java
List<Employee> employees = getEmployees();

// Sort by department, then by salary (highest first), then by name
Comparator<Employee> comparator = 
    Comparator.comparing(Employee::getDepartment)
              .thenComparingDouble(Employee::getSalary).reversed()
              .thenComparing(Employee::getName);

employees.sort(comparator);
```

---

### 3. Event Timeline
```java
List<Event> events = getEvents();

// Sort by date, then by priority
Comparator<Event> timeline = 
    Comparator.comparing(Event::getDate)
              .thenComparingInt(Event::getPriority);

events.sort(timeline);
```

---

### 4. File Sorting
```java
List<File> files = getFiles();

// Sort by size (largest first), then by name
Comparator<File> comparator = 
    Comparator.comparingLong(File::length).reversed()
              .thenComparing(File::getName);

files.sort(comparator);
```

---

### 5. Product Catalog
```java
List<Product> products = getProducts();

// Sort by category, then by price (lowest first), then by rating (highest first)
Comparator<Product> comparator = 
    Comparator.comparing(Product::getCategory)
              .thenComparingDouble(Product::getPrice)
              .thenComparingDouble(Product::getRating).reversed();

products.sort(comparator);
```

---

### 6. Custom Business Logic
```java
// Sort tasks by status (URGENT > HIGH > NORMAL), then by deadline
Comparator<Task> comparator = Comparator.comparing(
    Task::getStatus,
    (s1, s2) -> {
        Map<Status, Integer> priority = Map.of(
            Status.URGENT, 1,
            Status.HIGH, 2,
            Status.NORMAL, 3
        );
        return Integer.compare(priority.get(s1), priority.get(s2));
    }
).thenComparing(Task::getDeadline);
```

---

## üÜö Comparable vs Comparator

| Feature | Comparable | Comparator |
|---------|-----------|-----------|
| **Interface** | Comparable\<T> | Comparator\<T> |
| **Method** | compareTo(T o) | compare(T o1, T o2) |
| **Location** | Inside class | External |
| **Orderings** | Single (natural) | Multiple |
| **Modification** | Requires class change | No class change |
| **Usage** | sort(list) | sort(list, comparator) |
| **Lambda** | No | Yes (functional interface) |
| **Example** | String, Integer | Custom sorting |

---

## üîÑ Converting Comparators

```java
// Reverse any comparator
Comparator<Student> byGrade = Comparator.comparingInt(Student::getGrade);
Comparator<Student> reversed = byGrade.reversed();

// Null handling
Comparator<String> nullsFirst = Comparator.nullsFirst(Comparator.naturalOrder());
Comparator<String> nullsLast = Comparator.nullsLast(Comparator.naturalOrder());

// From Comparable
Comparator<String> natural = Comparator.naturalOrder();
Comparator<String> reverse = Comparator.reverseOrder();
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Subtraction for comparison (overflow)**
```java
// ‚ùå Can overflow
Comparator<Employee> bad = (e1, e2) -> e1.getSalary() - e2.getSalary();

// ‚úÖ Safe
Comparator<Employee> good = Comparator.comparingInt(Employee::getSalary);
```

2. **Inconsistent comparison logic**
```java
// ‚ùå Violates contract
Comparator<Person> bad = (p1, p2) -> {
    if (p1.getAge() > 30 && p2.getAge() > 30) return 0;  // Both old = equal?
    return Integer.compare(p1.getAge(), p2.getAge());
};

// Violates transitivity!
```

3. **Null pointer exceptions**
```java
// ‚ùå NPE if getName() returns null
Comparator<Person> bad = Comparator.comparing(Person::getName);

// ‚úÖ Null-safe
Comparator<Person> good = Comparator.comparing(
    Person::getName, 
    Comparator.nullsLast(String::compareTo)
);
```

4. **Forgetting reversed() applies to last only**
```java
// ‚ö†Ô∏è Only name is reversed, not grade
Comparator<Student> wrong = Comparator.comparing(Student::getGrade)
                                      .thenComparing(Student::getName)
                                      .reversed();  // Reverses everything!

// ‚úÖ Reverse only name
Comparator<Student> correct = Comparator.comparing(Student::getGrade)
                                        .thenComparing(Student::getName, Comparator.reverseOrder());
```

---

## üí° Best Practices

1. **Use factory methods for clarity**
```java
// ‚úÖ Clear and concise
Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);

// ‚ùå Verbose
Comparator<Product> byPrice = (p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice());
```

2. **Chain for multi-field sorting**
```java
// ‚úÖ Readable chaining
Comparator<Employee> comparator = 
    Comparator.comparing(Employee::getDepartment)
              .thenComparing(Employee::getName);
```

3. **Handle nulls explicitly**
```java
// ‚úÖ Null-safe
Comparator<Person> comparator = Comparator.comparing(
    Person::getName,
    Comparator.nullsLast(String::compareTo)
);
```

4. **Reuse comparators**
```java
// ‚úÖ Define once, reuse
class Comparators {
    public static final Comparator<Student> BY_GRADE = 
        Comparator.comparingInt(Student::getGrade);
    
    public static final Comparator<Student> BY_NAME = 
        Comparator.comparing(Student::getName);
}

// Usage
students.sort(Comparators.BY_GRADE);
```

---

## üéì When to Use Comparator

### ‚úÖ Use When:
- Need multiple sort orders
- Cannot modify class (third-party)
- Natural ordering not suitable
- Need flexible sorting logic
- Sorting collections/arrays

### ‚ùå Don't Use When:
- Class has obvious natural order (use Comparable)
- You control the class and need single order
- Natural ordering sufficient

---

## üìö Interview Questions

**Q1: Comparable vs Comparator?**
A: Comparable is natural ordering (in class), Comparator is custom ordering (external).

**Q2: Can you use lambda with Comparator?**
A: Yes, it's a functional interface with single abstract method `compare()`.

**Q3: How to sort by multiple fields?**
A: Use `thenComparing()` to chain comparators.

**Q4: How to reverse a comparator?**
A: Call `.reversed()` on the comparator.

**Q5: How to handle nulls?**
A: Use `Comparator.nullsFirst()` or `Comparator.nullsLast()`.

**Q6: What's the return value of compare()?**
A: Negative if o1 < o2, zero if equal, positive if o1 > o2.

**Q7: Can you sort in descending order?**
A: Use `.reversed()` or `Comparator.reverseOrder()`.

**Q8: What's comparing() vs comparingInt()?**
A: `comparingInt()` is optimized for primitives (avoids boxing).

---

## üìö Summary

- **Comparator**: Interface for custom ordering (`compare()`)
- **External**: Doesn't require class modification
- **Functional**: Can use lambda expressions (Java 8+)
- **Factory methods**: `comparing()`, `comparingInt()`, `naturalOrder()`
- **Chaining**: `thenComparing()` for multi-field sorting
- **Null-safe**: `nullsFirst()`, `nullsLast()`
- **Reversible**: `.reversed()` for descending order
- **Use case**: Multiple orderings, third-party classes, flexible sorting
