# üî¢ Arrays.sort()

## üìñ Overview

**Arrays.sort()** is a static utility method for sorting arrays in Java. It uses **DualPivotQuicksort** for primitives and **TimSort** for objects, both with O(n log n) time complexity.

```java
// Sort entire array
Arrays.sort(array);

// Sort range
Arrays.sort(array, fromIndex, toIndex);

// Sort with comparator (objects only)
Arrays.sort(array, comparator);
```

---

## ‚≠ê Key Characteristics

1. **Algorithm** - DualPivotQuicksort (primitives), TimSort (objects)
2. **Time complexity** - O(n log n) average and worst case
3. **In-place** - Modifies original array
4. **Stable** - Only for objects (TimSort), not primitives
5. **Parallel version** - `Arrays.parallelSort()` for large arrays
6. **Range sorting** - Can sort subarrays
7. **Type-specific** - Different overloads for each primitive type

---

## üìù Method Signatures

```java
// Primitives (int, long, double, char, etc.)
void sort(int[] a)
void sort(int[] a, int fromIndex, int toIndex)

// Objects (Comparable)
<T extends Comparable<? super T>> void sort(T[] a)
<T extends Comparable<? super T>> void sort(T[] a, int fromIndex, int toIndex)

// Objects (Comparator)
<T> void sort(T[] a, Comparator<? super T> c)
<T> void sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c)
```

---

## üíª Basic Usage

### 1. Sort Primitive Arrays
```java
// Integer array
int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};
Arrays.sort(numbers);  // [1, 1, 2, 3, 4, 5, 6, 9]

// Double array
double[] prices = {19.99, 5.49, 12.99, 3.99};
Arrays.sort(prices);  // [3.99, 5.49, 12.99, 19.99]

// Character array
char[] letters = {'d', 'a', 'c', 'b'};
Arrays.sort(letters);  // [a, b, c, d]
```

### 2. Sort Object Arrays (Natural Ordering)
```java
// String array
String[] names = {"Charlie", "Alice", "Bob"};
Arrays.sort(names);  // [Alice, Bob, Charlie]

// Integer array (wrapper)
Integer[] nums = {3, 1, 4, 1, 5};
Arrays.sort(nums);  // [1, 1, 3, 4, 5]
```

### 3. Sort with Comparator (Objects Only)
```java
String[] names = {"Alice", "Bob", "Charlie"};

// Reverse order
Arrays.sort(names, Collections.reverseOrder());  // [Charlie, Bob, Alice]

// Case-insensitive
Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);

// By length
Arrays.sort(names, Comparator.comparingInt(String::length));

// Lambda
Arrays.sort(names, (a, b) -> a.length() - b.length());
```

### 4. Sort Range
```java
int[] arr = {5, 3, 8, 1, 9, 2, 7};

// Sort indices 1 to 5 (exclusive)
Arrays.sort(arr, 1, 5);  // [5, 1, 3, 8, 9, 2, 7]
//                             ^  sorted  ^
```

---

## üéØ Real-World Examples

### 1. Sort Student Grades
```java
class Student {
    String name;
    int grade;
    
    // Constructor, getters
}

Student[] students = {
    new Student("Alice", 85),
    new Student("Bob", 92),
    new Student("Charlie", 78)
};

// Sort by grade (ascending)
Arrays.sort(students, Comparator.comparingInt(Student::getGrade));

// Sort by grade (descending)
Arrays.sort(students, Comparator.comparingInt(Student::getGrade).reversed());

// Sort by name
Arrays.sort(students, Comparator.comparing(Student::getName));
```

---

### 2. Find Median
```java
int[] scores = {85, 92, 78, 95, 88, 76, 90};
Arrays.sort(scores);

int median;
if (scores.length % 2 == 0) {
    median = (scores[scores.length/2] + scores[scores.length/2 - 1]) / 2;
} else {
    median = scores[scores.length/2];
}

System.out.println("Median: " + median);
```

---

### 3. Sort Files by Size
```java
File[] files = new File("/path").listFiles();

// Sort by size (largest first)
Arrays.sort(files, Comparator.comparingLong(File::length).reversed());

// Display
for (File file : files) {
    System.out.println(file.getName() + ": " + file.length() + " bytes");
}
```

---

### 4. Sort Multi-Dimensional Array
```java
int[][] intervals = {{1, 5}, {3, 7}, {2, 4}, {6, 8}};

// Sort by start time, then by end time
Arrays.sort(intervals, (a, b) -> {
    int cmp = Integer.compare(a[0], b[0]);
    return cmp != 0 ? cmp : Integer.compare(a[1], b[1]);
});

// Result: [[1, 5], [2, 4], [3, 7], [6, 8]]
```

---

### 5. Remove Duplicates After Sorting
```java
int[] arr = {3, 1, 4, 1, 5, 9, 2, 6, 5};
Arrays.sort(arr);  // [1, 1, 2, 3, 4, 5, 5, 6, 9]

// Remove duplicates
int j = 0;
for (int i = 1; i < arr.length; i++) {
    if (arr[i] != arr[j]) {
        arr[++j] = arr[i];
    }
}

// Create array with unique elements
int[] unique = Arrays.copyOf(arr, j + 1);  // [1, 2, 3, 4, 5, 6, 9]
```

---

## ‚ö° Parallel Sort

```java
int[] large = new int[10_000_000];
// ... fill array

// Regular sort
long start = System.nanoTime();
Arrays.sort(large);
long time1 = System.nanoTime() - start;

// Parallel sort (uses ForkJoin framework)
int[] large2 = large.clone();
start = System.nanoTime();
Arrays.parallelSort(large2);
long time2 = System.nanoTime() - start;

System.out.println("Regular: " + time1/1_000_000 + " ms");
System.out.println("Parallel: " + time2/1_000_000 + " ms");

// Parallel is faster for large arrays (> 8192 elements)
```

---

## üÜö Sort Algorithms

| Array Type | Algorithm | Stable | Time Complexity |
|-----------|-----------|--------|-----------------|
| **Primitives** | DualPivotQuicksort | No | O(n log n) |
| **Objects** | TimSort | Yes | O(n log n) |
| **Parallel** | Parallel merge sort | Yes | O(n log n) |

---

## üÜö Arrays.sort() vs Collections.sort()

```java
// Arrays.sort() - for arrays
int[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr);

String[] names = {"Charlie", "Alice", "Bob"};
Arrays.sort(names);

// Collections.sort() - for Lists
List<Integer> list = Arrays.asList(3, 1, 4, 1, 5);
Collections.sort(list);

List<String> nameList = Arrays.asList("Charlie", "Alice", "Bob");
Collections.sort(nameList);
```

| Feature | Arrays.sort() | Collections.sort() |
|---------|--------------|-------------------|
| **Target** | Arrays | Lists |
| **Algorithm** | DualPivotQuicksort/TimSort | TimSort |
| **Primitives** | Yes | No |
| **Objects** | Yes | Yes |
| **Parallel** | parallelSort() | No |

---

## ‚ö†Ô∏è Common Pitfalls

1. **Cannot sort primitive arrays in descending order**
```java
int[] arr = {3, 1, 4, 1, 5};

// ‚ùå Cannot use Comparator with primitives
// Arrays.sort(arr, Collections.reverseOrder());  // Compile error

// ‚úÖ Sort ascending, then reverse manually
Arrays.sort(arr);
for (int i = 0; i < arr.length / 2; i++) {
    int temp = arr[i];
    arr[i] = arr[arr.length - 1 - i];
    arr[arr.length - 1 - i] = temp;
}

// ‚úÖ Or use Integer[] instead
Integer[] arr2 = {3, 1, 4, 1, 5};
Arrays.sort(arr2, Collections.reverseOrder());
```

2. **Sorting range with wrong indices**
```java
int[] arr = {5, 3, 8, 1, 9};

// ‚ùå IndexOutOfBoundsException
Arrays.sort(arr, 0, 10);  // toIndex > length

// ‚úÖ Valid range
Arrays.sort(arr, 0, 3);  // Sorts indices 0, 1, 2
```

3. **NullPointerException with null elements**
```java
String[] arr = {"A", null, "B"};

// ‚ùå NullPointerException
Arrays.sort(arr);

// ‚úÖ Null-safe comparator
Arrays.sort(arr, Comparator.nullsLast(Comparator.naturalOrder()));
```

4. **Objects without Comparable**
```java
class Person {
    String name;
    int age;
}

Person[] people = getPeople();

// ‚ùå ClassCastException (Person doesn't implement Comparable)
Arrays.sort(people);

// ‚úÖ Provide Comparator
Arrays.sort(people, Comparator.comparing(Person::getName));
```

5. **Modifying array during sort (rare but possible)**
```java
// ‚ùå Don't modify array during sort
// Undefined behavior
```

---

## üí° Best Practices

1. **Use parallelSort for large arrays**
```java
// ‚úÖ Use parallel for > 8192 elements
if (arr.length > 8192) {
    Arrays.parallelSort(arr);
} else {
    Arrays.sort(arr);
}
```

2. **Use wrapper classes for descending primitive sort**
```java
// ‚úÖ Use Integer[] instead of int[] for custom ordering
Integer[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr, Collections.reverseOrder());
```

3. **Verify range indices**
```java
// ‚úÖ Ensure valid range
if (fromIndex >= 0 && toIndex <= arr.length && fromIndex < toIndex) {
    Arrays.sort(arr, fromIndex, toIndex);
}
```

4. **Consider stability for objects**
```java
// ‚úÖ Arrays.sort() is stable for objects
// Equal elements maintain original order
Employee[] employees = getEmployees();
Arrays.sort(employees, Comparator.comparing(Employee::getDepartment));
```

---

## üîÑ Alternative Approaches

```java
int[] numbers = {3, 1, 4, 1, 5};

// 1. Arrays.sort()
Arrays.sort(numbers);

// 2. Stream sorted (creates new array)
int[] sorted = Arrays.stream(numbers).sorted().toArray();

// 3. Parallel stream (for large arrays)
int[] sorted = Arrays.stream(numbers).parallel().sorted().toArray();

// 4. Convert to List and sort
List<Integer> list = Arrays.stream(numbers).boxed().collect(Collectors.toList());
Collections.sort(list);
```

---

## üéì When to Use Arrays.sort()

### ‚úÖ Use When:
- Sorting arrays (primitive or object)
- In-place sorting needed
- Simple sorting requirements
- High performance needed

### ‚ùå Don't Use When:
- Need sorted copy (use Stream)
- Sorting collections (use Collections.sort())
- Custom complex sorting logic better with List

---

## üìö Interview Questions

**Q1: What algorithm does Arrays.sort() use?**
A: DualPivotQuicksort for primitives, TimSort for objects.

**Q2: Time complexity?**
A: O(n log n) average and worst case.

**Q3: Is it stable?**
A: Yes for objects (TimSort), no for primitives (Quicksort).

**Q4: Can you sort primitives in descending order?**
A: No, use wrapper class (Integer[]) with comparator.

**Q5: Arrays.sort() vs Collections.sort()?**
A: Arrays.sort() for arrays, Collections.sort() for Lists.

**Q6: When to use parallelSort()?**
A: For large arrays (> 8192 elements) to leverage multi-core.

**Q7: Can you sort a range?**
A: Yes, `Arrays.sort(arr, fromIndex, toIndex)`.

**Q8: Does it modify original array?**
A: Yes, it's an in-place sort.

---

## üìö Summary

- **Arrays.sort()**: Static method to sort arrays
- **Algorithm**: DualPivotQuicksort (primitives), TimSort (objects)
- **Time complexity**: O(n log n)
- **In-place**: Modifies original array
- **Stable**: Only for objects
- **Parallel version**: Arrays.parallelSort() for large arrays
- **Use case**: Sorting arrays of any type
