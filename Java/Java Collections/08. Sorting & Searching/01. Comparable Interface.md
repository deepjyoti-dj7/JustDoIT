# üî§ Comparable Interface

## üìñ Overview

**Comparable** interface defines **natural ordering** for objects. Classes implementing Comparable can be sorted using `Collections.sort()` or `Arrays.sort()` without a custom comparator.

```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

---

## ‚≠ê Key Characteristics

1. **Natural ordering** - Default sort order for class
2. **Single method** - `compareTo(T o)`
3. **Return values** - Negative (<), Zero (=), Positive (>)
4. **Reflexive** - `x.compareTo(x) == 0`
5. **Symmetric** - `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`
6. **Transitive** - `x > y` and `y > z` implies `x > z`
7. **Consistent with equals** - `compareTo() == 0` should match `equals()`

---

## üìù Implementing Comparable

```java
class Student implements Comparable<Student> {
    private String name;
    private int grade;
    
    public Student(String name, int grade) {
        this.name = name;
        this.grade = grade;
    }
    
    @Override
    public int compareTo(Student other) {
        // Natural ordering by grade (ascending)
        return Integer.compare(this.grade, other.grade);
        
        // Alternative implementations:
        // return this.grade - other.grade;  // Simple but can overflow!
        // return this.grade < other.grade ? -1 : (this.grade > other.grade ? 1 : 0);
    }
}
```

---

## üéØ Return Values

```java
int result = obj1.compareTo(obj2);

// result < 0  ‚Üí  obj1 is less than obj2 (obj1 comes before obj2)
// result == 0 ‚Üí  obj1 equals obj2 (same position)
// result > 0  ‚Üí  obj1 is greater than obj2 (obj1 comes after obj2)
```

### Example:
```java
Student s1 = new Student("Alice", 85);
Student s2 = new Student("Bob", 90);

int result = s1.compareTo(s2);  // -1 (85 < 90, Alice before Bob)
```

---

## üíª Common Implementations

### 1. Integer Comparison
```java
class Employee implements Comparable<Employee> {
    private int id;
    
    @Override
    public int compareTo(Employee other) {
        return Integer.compare(this.id, other.id);  // ‚úÖ Safe
        // return this.id - other.id;  // ‚ö†Ô∏è Can overflow!
    }
}
```

### 2. String Comparison
```java
class Book implements Comparable<Book> {
    private String title;
    
    @Override
    public int compareTo(Book other) {
        return this.title.compareTo(other.title);  // Lexicographic order
    }
}
```

### 3. Double Comparison
```java
class Product implements Comparable<Product> {
    private double price;
    
    @Override
    public int compareTo(Product other) {
        return Double.compare(this.price, other.price);  // ‚úÖ Handles NaN
    }
}
```

### 4. Date Comparison
```java
class Event implements Comparable<Event> {
    private LocalDate date;
    
    @Override
    public int compareTo(Event other) {
        return this.date.compareTo(other.date);  // Chronological order
    }
}
```

### 5. Multi-Field Comparison
```java
class Person implements Comparable<Person> {
    private String lastName;
    private String firstName;
    
    @Override
    public int compareTo(Person other) {
        // Compare by lastName first, then firstName
        int lastNameCmp = this.lastName.compareTo(other.lastName);
        if (lastNameCmp != 0) {
            return lastNameCmp;
        }
        return this.firstName.compareTo(other.firstName);
    }
}
```

---

## üéØ Real-World Examples

### 1. Priority-Based Task
```java
class Task implements Comparable<Task> {
    private String name;
    private int priority;  // 1 = highest, 5 = lowest
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
}

// Usage
List<Task> tasks = Arrays.asList(
    new Task("Deploy", 1),
    new Task("Test", 3),
    new Task("Review", 2)
);
Collections.sort(tasks);  // Sorted by priority: Deploy, Review, Test
```

---

### 2. Leaderboard Entry
```java
class Player implements Comparable<Player> {
    private String name;
    private int score;
    
    @Override
    public int compareTo(Player other) {
        // Higher score comes first (descending)
        return Integer.compare(other.score, this.score);
    }
}

// Usage
List<Player> leaderboard = getPlayers();
Collections.sort(leaderboard);  // Highest score first
```

---

### 3. Version Number
```java
class Version implements Comparable<Version> {
    private int major;
    private int minor;
    private int patch;
    
    @Override
    public int compareTo(Version other) {
        int majorCmp = Integer.compare(this.major, other.major);
        if (majorCmp != 0) return majorCmp;
        
        int minorCmp = Integer.compare(this.minor, other.minor);
        if (minorCmp != 0) return minorCmp;
        
        return Integer.compare(this.patch, other.patch);
    }
}

// Usage: 1.0.0 < 1.0.1 < 1.1.0 < 2.0.0
```

---

### 4. File Size
```java
class FileInfo implements Comparable<FileInfo> {
    private String name;
    private long sizeInBytes;
    
    @Override
    public int compareTo(FileInfo other) {
        return Long.compare(this.sizeInBytes, other.sizeInBytes);
    }
}
```

---

## üìä Built-in Comparable Classes

```java
// Java classes that implement Comparable:
Integer, Long, Double, Float, Short, Byte, Character, Boolean
String, LocalDate, LocalDateTime, Instant, Duration
BigInteger, BigDecimal
File, Path
Enum (by declaration order)
```

---

## üÜö Comparable vs Comparator

| Feature | Comparable | Comparator |
|---------|-----------|-----------|
| **Location** | Inside class | Separate class/lambda |
| **Method** | compareTo(T o) | compare(T o1, T o2) |
| **Purpose** | Natural ordering | Custom ordering |
| **Sorting** | Collections.sort(list) | Collections.sort(list, comparator) |
| **Use case** | Single default order | Multiple orderings |
| **Modifies class** | Yes | No |

---

## ‚ö†Ô∏è Common Pitfalls

1. **Integer overflow with subtraction**
```java
// ‚ùå Can overflow
@Override
public int compareTo(Employee other) {
    return this.salary - other.salary;  // Overflow if difference > Integer.MAX_VALUE
}

// ‚úÖ Safe
@Override
public int compareTo(Employee other) {
    return Integer.compare(this.salary, other.salary);
}
```

2. **Null handling**
```java
// ‚ùå NullPointerException
@Override
public int compareTo(Person other) {
    return this.name.compareTo(other.name);  // If name is null
}

// ‚úÖ Handle nulls
@Override
public int compareTo(Person other) {
    if (this.name == null && other.name == null) return 0;
    if (this.name == null) return -1;  // Nulls first
    if (other.name == null) return 1;
    return this.name.compareTo(other.name);
}
```

3. **Inconsistent with equals**
```java
// ‚ö†Ô∏è Inconsistent
class BadExample implements Comparable<BadExample> {
    private int value;
    
    @Override
    public int compareTo(BadExample other) {
        return 0;  // Always equal for sorting
    }
    
    @Override
    public boolean equals(Object obj) {
        return this.value == ((BadExample) obj).value;  // Different logic!
    }
}

// ‚úÖ Consistent
// If compareTo() returns 0, equals() should return true
```

4. **Violating transitivity**
```java
// ‚ùå Transitive violation
@Override
public int compareTo(Item other) {
    if (this.weight > 100 && other.weight > 100) return 0;  // Both heavy
    return Integer.compare(this.weight, other.weight);
}

// If A(150) == B(120) and B(120) == C(80), but A(150) > C(80) - violation!
```

---

## üí° Best Practices

1. **Use wrapper compare methods**
```java
// ‚úÖ Safe and clear
return Integer.compare(this.age, other.age);
return Double.compare(this.price, other.price);
return Long.compare(this.id, other.id);
```

2. **Handle nulls explicitly**
```java
@Override
public int compareTo(Person other) {
    return Comparator.nullsFirst(String::compareTo).compare(this.name, other.name);
}
```

3. **Be consistent with equals**
```java
// If compareTo returns 0, equals should return true
@Override
public int compareTo(Student other) {
    return Integer.compare(this.id, other.id);
}

@Override
public boolean equals(Object obj) {
    if (!(obj instanceof Student)) return false;
    return this.id == ((Student) obj).id;
}

@Override
public int hashCode() {
    return Integer.hashCode(id);
}
```

4. **Document natural ordering**
```java
/**
 * Natural ordering: by priority (ascending), then by name (lexicographic)
 */
class Task implements Comparable<Task> {
    // ...
}
```

---

## üéì When to Use Comparable

### ‚úÖ Use When:
- Class has obvious natural ordering
- Single default sort order needed
- You control the class source code
- Most use cases need same ordering

### ‚ùå Don't Use When:
- Multiple sort orders needed (use Comparator)
- Cannot modify class (use Comparator)
- Natural ordering unclear/controversial
- Third-party class (use Comparator)

---

## üìö Interview Questions

**Q1: What does compareTo() return?**
A: Negative if less, zero if equal, positive if greater.

**Q2: Can you give an example of integer overflow?**
A: `Integer.MAX_VALUE - (-1)` overflows. Use `Integer.compare()` instead.

**Q3: What does "consistent with equals" mean?**
A: If `compareTo() == 0`, then `equals()` should return `true`.

**Q4: Comparable vs Comparator?**
A: Comparable defines natural ordering (in class), Comparator defines custom ordering (external).

**Q5: How to compare multiple fields?**
A: Compare first field, if equal (0) then compare second field, etc.

**Q6: Is String Comparable?**
A: Yes, lexicographic (dictionary) order.

**Q7: How to handle null in compareTo()?**
A: Check for null and return -1 (nulls first) or 1 (nulls last).

**Q8: What's natural ordering?**
A: Default sort order defined by Comparable implementation.

---

## üìö Summary

- **Comparable**: Interface for natural ordering (`compareTo()`)
- **Natural ordering**: Default sort order for a class
- **Return values**: Negative (<), Zero (=), Positive (>)
- **Use**: `Integer.compare()`, `Double.compare()` for safety
- **Consistency**: `compareTo() == 0` should match `equals()`
- **Multi-field**: Compare first field, if equal compare next
- **Use case**: Single default ordering when you control the class
