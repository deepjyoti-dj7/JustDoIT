# üìä Collections.sort()

## üìñ Overview

**Collections.sort()** is a static utility method for sorting `List` collections in Java. It uses **TimSort** algorithm (hybrid of merge sort and insertion sort) with O(n log n) time complexity.

```java
// Natural ordering
Collections.sort(list);

// Custom comparator
Collections.sort(list, comparator);
```

---

## ‚≠ê Key Characteristics

1. **Algorithm** - TimSort (stable sort)
2. **Time complexity** - O(n log n) worst case
3. **Space complexity** - O(n) auxiliary space
4. **Stable** - Equal elements maintain relative order
5. **In-place** - Modifies original list
6. **Requires List** - Not for Set or other collections
7. **Null elements** - Allowed (with custom comparator)

---

## üìù Method Signatures

```java
// 1. Natural ordering (requires Comparable)
public static <T extends Comparable<? super T>> void sort(List<T> list)

// 2. Custom ordering (with Comparator)
public static <T> void sort(List<T> list, Comparator<? super T> c)
```

---

## üíª Basic Usage

### 1. Sort with Natural Ordering
```java
// Integers
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5));
Collections.sort(numbers);  // [1, 1, 3, 4, 5]

// Strings (lexicographic order)
List<String> names = new ArrayList<>(Arrays.asList("Charlie", "Alice", "Bob"));
Collections.sort(names);  // [Alice, Bob, Charlie]

// Custom objects (must implement Comparable)
List<Student> students = getStudents();
Collections.sort(students);  // Uses Student.compareTo()
```

### 2. Sort with Comparator
```java
List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie"));

// Reverse order
Collections.sort(names, Collections.reverseOrder());  // [Charlie, Bob, Alice]

// Case-insensitive
Collections.sort(names, String.CASE_INSENSITIVE_ORDER);

// Custom comparator (lambda)
Collections.sort(names, (a, b) -> Integer.compare(a.length(), b.length()));

// Method reference
Collections.sort(names, Comparator.comparing(String::length));
```

---

## üéØ Common Sorting Scenarios

### 1. Sort Integers
```java
List<Integer> nums = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9));

// Ascending
Collections.sort(nums);  // [1, 2, 5, 8, 9]

// Descending
Collections.sort(nums, Collections.reverseOrder());  // [9, 8, 5, 2, 1]
```

### 2. Sort Strings
```java
List<String> words = new ArrayList<>(Arrays.asList("cat", "dog", "Apple", "banana"));

// Natural (case-sensitive)
Collections.sort(words);  // [Apple, banana, cat, dog]

// Case-insensitive
Collections.sort(words, String.CASE_INSENSITIVE_ORDER);  // [Apple, banana, cat, dog]

// By length
Collections.sort(words, Comparator.comparingInt(String::length));  // [cat, dog, Apple, banana]

// Reverse
Collections.sort(words, Collections.reverseOrder());  // [dog, cat, banana, Apple]
```

### 3. Sort Custom Objects
```java
class Employee {
    String name;
    int salary;
    String department;
    
    // ... constructors, getters
}

List<Employee> employees = getEmployees();

// By salary (ascending)
Collections.sort(employees, Comparator.comparingInt(Employee::getSalary));

// By salary (descending)
Collections.sort(employees, Comparator.comparingInt(Employee::getSalary).reversed());

// By department, then salary
Collections.sort(employees, 
    Comparator.comparing(Employee::getDepartment)
              .thenComparingInt(Employee::getSalary));
```

---

## üéØ Real-World Examples

### 1. Student Grade Report
```java
List<Student> students = getStudents();

// Sort by grade (highest first), then by name
Collections.sort(students, 
    Comparator.comparingInt(Student::getGrade).reversed()
              .thenComparing(Student::getName));

students.forEach(s -> System.out.println(s.getName() + ": " + s.getGrade()));
```

---

### 2. Product Catalog
```java
List<Product> products = getProducts();

// Sort by category, then price (lowest first)
Collections.sort(products,
    Comparator.comparing(Product::getCategory)
              .thenComparingDouble(Product::getPrice));

// Display
products.forEach(p -> 
    System.out.println(p.getCategory() + " - " + p.getName() + ": $" + p.getPrice())
);
```

---

### 3. Event Timeline
```java
List<Event> events = getEvents();

// Sort by date chronologically
Collections.sort(events, Comparator.comparing(Event::getDate));

// Or if Event implements Comparable
Collections.sort(events);
```

---

### 4. Leaderboard
```java
List<Player> players = getPlayers();

// Sort by score (highest first), then by name
Collections.sort(players,
    Comparator.comparingInt(Player::getScore).reversed()
              .thenComparing(Player::getName));

// Display top 10
players.stream().limit(10).forEach(p -> 
    System.out.println(p.getRank() + ". " + p.getName() + " - " + p.getScore())
);
```

---

### 5. File Manager
```java
List<File> files = Arrays.asList(new File("/path").listFiles());

// Sort by size (largest first), then by name
Collections.sort(files,
    Comparator.comparingLong(File::length).reversed()
              .thenComparing(File::getName));
```

---

## üÜö Collections.sort() vs List.sort()

```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5);

// Collections.sort() - Traditional (Java 1.2+)
Collections.sort(numbers);
Collections.sort(numbers, Collections.reverseOrder());

// List.sort() - Modern (Java 8+)
numbers.sort(Comparator.naturalOrder());
numbers.sort(Comparator.reverseOrder());

// Both do the same thing, List.sort() is preferred in modern Java
```

### Comparison:

| Feature | Collections.sort() | List.sort() |
|---------|-------------------|-------------|
| **Java Version** | 1.2+ | 8+ |
| **Style** | Static utility | Instance method |
| **Syntax** | Collections.sort(list) | list.sort(comparator) |
| **Recommendation** | Legacy | Preferred |

---

## ‚ö° Performance

```java
// TimSort characteristics:
// - Best case: O(n) - already sorted
// - Average case: O(n log n)
// - Worst case: O(n log n)
// - Space: O(n) auxiliary space
// - Stable: Yes

List<Integer> list = generateList(1_000_000);

// Benchmark
long start = System.nanoTime();
Collections.sort(list);
long end = System.nanoTime();

System.out.println("Time: " + (end - start) / 1_000_000 + " ms");
```

---

## ‚ö†Ô∏è Common Pitfalls

1. **Sorting immutable lists**
```java
List<String> immutable = List.of("C", "A", "B");
// ‚ùå UnsupportedOperationException
Collections.sort(immutable);

// ‚úÖ Copy to mutable list
List<String> mutable = new ArrayList<>(immutable);
Collections.sort(mutable);
```

2. **Sorting fixed-size lists (Arrays.asList)**
```java
List<String> list = Arrays.asList("C", "A", "B");
Collections.sort(list);  // ‚úÖ Works (can modify elements)

// But cannot add/remove
// list.add("D");  // ‚ùå UnsupportedOperationException
```

3. **NullPointerException with null elements**
```java
List<String> list = new ArrayList<>(Arrays.asList("A", null, "B"));

// ‚ùå NullPointerException
Collections.sort(list);

// ‚úÖ Null-safe comparator
Collections.sort(list, Comparator.nullsLast(Comparator.naturalOrder()));
```

4. **Objects without Comparable**
```java
class Person {
    String name;
    int age;
}

List<Person> people = getPeople();

// ‚ùå ClassCastException (Person doesn't implement Comparable)
Collections.sort(people);

// ‚úÖ Provide Comparator
Collections.sort(people, Comparator.comparing(Person::getName));
```

5. **Sorting while iterating**
```java
// ‚ùå ConcurrentModificationException possible
for (String item : list) {
    if (condition) {
        Collections.sort(list);  // Don't modify while iterating!
    }
}

// ‚úÖ Sort before or after iteration
Collections.sort(list);
for (String item : list) {
    process(item);
}
```

---

## üí° Best Practices

1. **Prefer List.sort() in modern Java**
```java
// ‚úÖ Modern (Java 8+)
list.sort(Comparator.naturalOrder());

// ‚ö†Ô∏è Legacy
Collections.sort(list);
```

2. **Sort once, use multiple times**
```java
// ‚úÖ Sort once
Collections.sort(list);

// Use multiple times
int min = list.get(0);
int max = list.get(list.size() - 1);
```

3. **Use method references**
```java
// ‚úÖ Concise
Collections.sort(employees, Comparator.comparing(Employee::getName));

// ‚ùå Verbose
Collections.sort(employees, (e1, e2) -> e1.getName().compareTo(e2.getName()));
```

4. **Handle nulls explicitly**
```java
// ‚úÖ Null-safe
Collections.sort(list, Comparator.nullsLast(Comparator.naturalOrder()));
```

---

## üîÑ Alternative Approaches

```java
List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5);

// 1. Collections.sort()
Collections.sort(numbers);

// 2. List.sort() (Java 8+)
numbers.sort(Comparator.naturalOrder());

// 3. Stream sorted() (creates new list)
List<Integer> sorted = numbers.stream()
                              .sorted()
                              .collect(Collectors.toList());

// 4. Parallel stream (for large lists)
List<Integer> sorted = numbers.parallelStream()
                              .sorted()
                              .collect(Collectors.toList());
```

---

## üéì When to Use Collections.sort()

### ‚úÖ Use When:
- Need to sort a List in-place
- Working with Java 7 or earlier
- Simple sorting requirements
- Need stable sort

### ‚ùå Don't Use When:
- Need to create sorted copy (use Stream)
- Sorting arrays (use Arrays.sort())
- List is immutable (copy first)
- Java 8+ available (prefer List.sort())

---

## üìö Interview Questions

**Q1: What algorithm does Collections.sort() use?**
A: TimSort (hybrid of merge sort and insertion sort).

**Q2: Time complexity?**
A: O(n log n) worst case, O(n) best case (already sorted).

**Q3: Is it stable?**
A: Yes, equal elements maintain relative order.

**Q4: Can you sort arrays with Collections.sort()?**
A: No, use Arrays.sort() for arrays.

**Q5: Collections.sort() vs List.sort()?**
A: Same functionality, List.sort() is preferred in Java 8+.

**Q6: Can you sort immutable lists?**
A: No, throws UnsupportedOperationException. Copy to mutable list first.

**Q7: How to handle nulls?**
A: Use Comparator.nullsFirst() or nullsLast().

**Q8: Does it modify the original list?**
A: Yes, it's an in-place sort.

---

## üìö Summary

- **Collections.sort()**: Static method to sort Lists
- **Algorithm**: TimSort (O(n log n), stable)
- **Two variants**: Natural ordering, custom Comparator
- **In-place**: Modifies original list
- **Stable**: Equal elements maintain order
- **Modern alternative**: List.sort() (Java 8+)
- **Use case**: Sorting mutable Lists
