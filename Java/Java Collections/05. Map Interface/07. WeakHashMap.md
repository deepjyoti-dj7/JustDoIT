# üßπ WeakHashMap

## üìñ Overview

`WeakHashMap` is a Map where keys are **weak references** that can be **garbage collected** when no longer strongly referenced. Perfect for **memory-sensitive caches**.

```java
public class WeakHashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>
```

**Core Feature:** Keys can be automatically removed by garbage collector.

---

## üîë Key Characteristics

1. **Weak Key References** - Keys held weakly (can be GC'd)
2. **Automatic Cleanup** - Entries removed when key is GC'd
3. **Memory-Sensitive** - Won't prevent garbage collection
4. **One Null Key** - Allows one null key
5. **Not Thread-Safe** - Synchronize externally if needed
6. **Perfect for Caches** - Self-cleaning when memory needed
7. **Hash Table Based** - Similar to HashMap

---

## üß† Weak References Explained

```java
// STRONG reference (normal)
String strongKey = new String("key");
Map<String, String> normalMap = new HashMap<>();
normalMap.put(strongKey, "value");
strongKey = null;  // Entry remains in map (strong reference prevents GC)

// WEAK reference
String weakKey = new String("key");
Map<String, String> weakMap = new WeakHashMap<>();
weakMap.put(weakKey, "value");
weakKey = null;  // Entry can be GC'd (weak reference allows GC)
System.gc();     // Request GC
// Entry may be removed from weakMap!
```

**Reference Strength:**
- **Strong** (normal): Object won't be GC'd while referenced
- **Weak** (WeakHashMap): Object can be GC'd even if referenced
- **Soft**: GC'd only when memory needed (not used in WeakHashMap)
- **Phantom**: For cleanup tasks (not used in WeakHashMap)

---

## üíª Creating WeakHashMap

```java
import java.util.*;

// 1. Default constructor
Map<String, Integer> map1 = new WeakHashMap<>();

// 2. With initial capacity
Map<String, Integer> map2 = new WeakHashMap<>(32);

// 3. With capacity and load factor
Map<String, Integer> map3 = new WeakHashMap<>(32, 0.75f);

// 4. From another map
Map<String, Integer> original = new HashMap<>();
original.put("A", 1);
Map<String, Integer> map4 = new WeakHashMap<>(original);
```

---

## üé® Basic Example

```java
public class WeakHashMapDemo {
    public static void main(String[] args) throws InterruptedException {
        WeakHashMap<Object, String> weakMap = new WeakHashMap<>();
        
        // Create keys
        Object key1 = new Object();
        Object key2 = new Object();
        Object key3 = new Object();
        
        // Add entries
        weakMap.put(key1, "Value 1");
        weakMap.put(key2, "Value 2");
        weakMap.put(key3, "Value 3");
        
        System.out.println("Initial size: " + weakMap.size());  // 3
        
        // Remove strong references
        key1 = null;
        key2 = null;
        // key3 still referenced
        
        // Request garbage collection
        System.gc();
        Thread.sleep(100);  // Give GC time
        
        System.out.println("After GC size: " + weakMap.size());  // 1
        System.out.println("Remaining: " + weakMap.values());    // [Value 3]
    }
}
```

---

## üéØ Cache Example

```java
class ImageCache {
    private WeakHashMap<String, byte[]> cache;
    
    public ImageCache() {
        cache = new WeakHashMap<>();
    }
    
    public byte[] getImage(String url) {
        // Check cache first
        if (cache.containsKey(url)) {
            System.out.println("Cache hit: " + url);
            return cache.get(url);
        }
        
        // Load image
        System.out.println("Cache miss, loading: " + url);
        byte[] imageData = loadImage(url);
        cache.put(url, imageData);
        
        return imageData;
    }
    
    private byte[] loadImage(String url) {
        // Simulate loading from network
        return new byte[1024];  // Dummy data
    }
    
    public int getCacheSize() {
        return cache.size();
    }
}

// Usage
ImageCache imgCache = new ImageCache();
String url1 = "http://example.com/image1.jpg";
String url2 = "http://example.com/image2.jpg";

imgCache.getImage(url1);  // Cache miss, loading
imgCache.getImage(url1);  // Cache hit
imgCache.getImage(url2);  // Cache miss, loading

System.out.println("Cache size: " + imgCache.getCacheSize());

// If memory pressure, entries may be removed automatically
System.gc();
Thread.sleep(100);
System.out.println("Cache size after GC: " + imgCache.getCacheSize());
```

---

## üéØ Real-World Examples

### Example 1: Metadata Cache

```java
class ClassMetadataCache {
    private WeakHashMap<Class<?>, Map<String, Object>> metadata;
    
    public ClassMetadataCache() {
        metadata = new WeakHashMap<>();
    }
    
    public void cacheMetadata(Class<?> clazz, String key, Object value) {
        metadata.computeIfAbsent(clazz, k -> new HashMap<>())
                .put(key, value);
    }
    
    public Object getMetadata(Class<?> clazz, String key) {
        Map<String, Object> classMetadata = metadata.get(clazz);
        return classMetadata == null ? null : classMetadata.get(key);
    }
}

// When Class is unloaded, metadata is automatically removed
ClassMetadataCache cache = new ClassMetadataCache();
Class<?> clazz = String.class;
cache.cacheMetadata(clazz, "version", "1.0");
// Metadata removed when clazz is no longer referenced and GC'd
```

---

### Example 2: Object-to-ID Mapping

```java
class ObjectIdMapper {
    private WeakHashMap<Object, Integer> objectToId;
    private int nextId = 1;
    
    public ObjectIdMapper() {
        objectToId = new WeakHashMap<>();
    }
    
    public int getId(Object obj) {
        return objectToId.computeIfAbsent(obj, k -> nextId++);
    }
    
    public int getMapSize() {
        return objectToId.size();
    }
}

// Usage
ObjectIdMapper mapper = new ObjectIdMapper();
Object obj1 = new Object();
Object obj2 = new Object();

System.out.println("ID for obj1: " + mapper.getId(obj1));  // 1
System.out.println("ID for obj2: " + mapper.getId(obj2));  // 2
System.out.println("Map size: " + mapper.getMapSize());    // 2

obj1 = null;  // No longer referenced
System.gc();
Thread.sleep(100);

System.out.println("Map size after GC: " + mapper.getMapSize());  // 1
```

---

### Example 3: Listener Registry

```java
interface ChangeListener {
    void onChange(String event);
}

class EventSource {
    private WeakHashMap<ChangeListener, Boolean> listeners;
    
    public EventSource() {
        listeners = new WeakHashMap<>();
    }
    
    public void addListener(ChangeListener listener) {
        listeners.put(listener, Boolean.TRUE);
    }
    
    public void fireEvent(String event) {
        for (ChangeListener listener : listeners.keySet()) {
            listener.onChange(event);
        }
    }
    
    public int getListenerCount() {
        return listeners.size();
    }
}

// Usage
EventSource source = new EventSource();
ChangeListener listener1 = event -> System.out.println("Listener1: " + event);
ChangeListener listener2 = event -> System.out.println("Listener2: " + event);

source.addListener(listener1);
source.addListener(listener2);
source.fireEvent("Event1");  // Both listeners notified

listener1 = null;  // No longer referenced
System.gc();
Thread.sleep(100);

source.fireEvent("Event2");  // Only listener2 notified
// listener1 automatically removed by GC
```

---

### Example 4: Canonicalization Map

```java
class StringCanonicalizer {
    private WeakHashMap<String, String> canonicalStrings;
    
    public StringCanonicalizer() {
        canonicalStrings = new WeakHashMap<>();
    }
    
    public String canonicalize(String str) {
        String canonical = canonicalStrings.get(str);
        if (canonical == null) {
            canonical = str;
            canonicalStrings.put(str, canonical);
        }
        return canonical;
    }
    
    public int getCacheSize() {
        return canonicalStrings.size();
    }
}

// Ensures only one instance of each string in memory
// Automatically cleaned when no longer needed
StringCanonicalizer canon = new StringCanonicalizer();
String s1 = canon.canonicalize(new String("hello"));
String s2 = canon.canonicalize(new String("hello"));
System.out.println(s1 == s2);  // true (same instance)
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `get(key)` | O(1) | Average |
| `put(key, value)` | O(1) | Average |
| `remove(key)` | O(1) | Average |
| `containsKey(key)` | O(1) | |
| `size()` | O(1) | May trigger cleanup |

**Note:** Occasional cleanup when accessing (removes GC'd entries).

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Using String literals (interned, never GC'd)
WeakHashMap<String, Integer> map = new WeakHashMap<>();
map.put("literal", 1);  // ‚ùå String literal never GC'd!
// String literals are interned in String pool (strong reference)

// ‚úÖ Use new String for testing
map.put(new String("key"), 1);  // Can be GC'd

// 2. Not understanding when GC happens
WeakHashMap<Object, String> map = new WeakHashMap<>();
Object key = new Object();
map.put(key, "value");
key = null;
System.out.println(map.size());  // Still 1! GC hasn't run yet
System.gc();  // Request GC (not guaranteed to run immediately)
Thread.sleep(100);
System.out.println(map.size());  // May be 0 now

// 3. Iterating during cleanup
// ConcurrentModificationException possible during iteration

// 4. Expecting immediate removal
// Entries removed lazily, not immediately after key is nulled

// 5. Value holds reference to key
class Value {
    Object keyReference;  // ‚ùå Prevents key from being GC'd!
}
```

---

## üí° Best Practices

1. **Use for caches** - automatic memory management
2. **Don't use String literals** - they're never GC'd
3. **Values shouldn't reference keys** - prevents GC
4. **Understand GC timing** - cleanup is lazy
5. **Not for important data** - entries can disappear
6. **Thread-safety**: Synchronize if multi-threaded
7. **Testing**: Force GC and wait for cleanup

---

## üÜö WeakHashMap vs HashMap

| Feature | WeakHashMap | HashMap |
|---------|-------------|---------|
| **Key references** | Weak | Strong |
| **Auto cleanup** | Yes | No |
| **Memory leaks** | Prevents | Possible |
| **Use case** | Caches, metadata | General purpose |
| **Predictability** | Less | More |
| **Performance** | Slightly slower | Faster |

---

## üéØ When to Use WeakHashMap

**Use WeakHashMap when:**
- ‚úÖ Implementing caches (memory-sensitive)
- ‚úÖ Storing metadata about objects
- ‚úÖ Canonicalization maps
- ‚úÖ Event listener registries
- ‚úÖ Preventing memory leaks
- ‚úÖ Object-to-data associations

**Don't use WeakHashMap when:**
- ‚ùå Need guaranteed retention ‚Üí Use `HashMap`
- ‚ùå Keys are String literals ‚Üí Won't be GC'd
- ‚ùå Values reference keys ‚Üí Prevents GC
- ‚ùå Need predictable behavior ‚Üí Use `HashMap`
- ‚ùå Critical data storage ‚Üí Use `HashMap`

---

## üéì Interview Questions

**Q: What is WeakHashMap?**
A: Map with weak key references that can be garbage collected.

**Q: When are entries removed?**
A: When key is no longer strongly referenced and GC runs.

**Q: WeakHashMap vs HashMap?**
A: WeakHashMap has weak keys (GC-able), HashMap has strong keys (retained).

**Q: Can WeakHashMap prevent memory leaks?**
A: Yes, entries automatically removed when keys are GC'd.

**Q: Why not use String literals?**
A: String literals are interned (strong reference), never GC'd.

**Q: Is WeakHashMap thread-safe?**
A: No, synchronize externally if needed.

**Q: When to use WeakHashMap?**
A: For caches, metadata storage, preventing memory leaks.

**Q: Do values also have weak references?**
A: No, only keys are weak. Values have strong references.

---

## üìö Summary

- **WeakHashMap**: Map with weak key references
- **Automatic cleanup** when keys are garbage collected
- **Perfect for caches** - self-cleaning based on memory
- **Prevents memory leaks** - entries removed when no longer needed
- **Not for critical data** - entries can disappear
- **Keys must be objects** - not String literals
- **Values shouldn't reference keys** - prevents GC
- Use for **caches, metadata, canonicalization**
- Choose HashMap if need guaranteed retention
