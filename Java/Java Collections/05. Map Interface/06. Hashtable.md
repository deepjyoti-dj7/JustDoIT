# üîê Hashtable

## üìñ Overview

`Hashtable` is a **legacy synchronized Map** implementation from Java 1.0. It's **thread-safe** but **slower** than HashMap. **Use ConcurrentHashMap instead** for modern concurrent applications.

```java
public class Hashtable<K,V> extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, Serializable
```

**Status:** Legacy - Prefer ConcurrentHashMap or synchronized HashMap.

---

## üîë Key Characteristics

1. **Thread-Safe** - All methods synchronized
2. **No Null Keys/Values** - Throws NullPointerException
3. **Legacy Class** - From Java 1.0
4. **Hash Table Based** - Similar to HashMap
5. **Extends Dictionary** - Old collection class
6. **Unordered** - No iteration order guarantee
7. **Slower** - Synchronization overhead

---

## üíª Creating Hashtable

```java
import java.util.*;

// 1. Default constructor (capacity 11, load factor 0.75)
Hashtable<String, Integer> table1 = new Hashtable<>();

// 2. With initial capacity
Hashtable<String, Integer> table2 = new Hashtable<>(20);

// 3. With capacity and load factor
Hashtable<String, Integer> table3 = new Hashtable<>(20, 0.80f);

// 4. From another map
Map<String, Integer> map = Map.of("A", 1, "B", 2);
Hashtable<String, Integer> table4 = new Hashtable<>(map);
```

---

## üé® Basic Operations

```java
public class HashtableDemo {
    public static void main(String[] args) {
        Hashtable<String, Integer> table = new Hashtable<>();
        
        // PUT
        table.put("Alice", 25);
        table.put("Bob", 30);
        table.put("Charlie", 35);
        
        System.out.println(table);  // {Charlie=35, Bob=30, Alice=25}
        
        // GET
        Integer age = table.get("Alice");
        System.out.println("Alice's age: " + age);  // 25
        
        // CONTAINS
        System.out.println("Has Bob? " + table.containsKey("Bob"));  // true
        System.out.println("Has value 30? " + table.containsValue(30));  // true
        
        // REMOVE
        Integer removed = table.remove("Charlie");
        System.out.println("Removed: " + removed);  // 35
        
        // SIZE
        System.out.println("Size: " + table.size());  // 2
        
        // NULL not allowed
        try {
            table.put(null, 40);  // NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Null key not allowed");
        }
        
        try {
            table.put("David", null);  // NullPointerException
        } catch (NullPointerException e) {
            System.out.println("Null value not allowed");
        }
    }
}
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `get(key)` | O(1) | Average, synchronized |
| `put(key, value)` | O(1) | Average, synchronized |
| `remove(key)` | O(1) | Average, synchronized |
| `containsKey(key)` | O(1) | Synchronized |
| `containsValue(value)` | O(n) | Must scan all |
| Iteration | O(n + capacity) | Synchronized |

**All operations are synchronized** ‚Üí Thread-safe but slower.

---

## üîí Thread Safety

```java
// Hashtable - Thread-safe (built-in synchronization)
Hashtable<String, Integer> table = new Hashtable<>();

// Multiple threads can safely access
Thread t1 = new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        table.put("key" + i, i);
    }
});

Thread t2 = new Thread(() -> {
    for (int i = 1000; i < 2000; i++) {
        table.put("key" + i, i);
    }
});

t1.start();
t2.start();
t1.join();
t2.join();

System.out.println("Size: " + table.size());  // 2000 (thread-safe)
```

**All methods synchronized:**
- ‚úÖ Thread-safe
- ‚ùå Slow (locks entire table)
- ‚ùå Poor concurrency (one thread at a time)

---

## üÜö Hashtable vs HashMap vs ConcurrentHashMap

| Feature | Hashtable | HashMap | ConcurrentHashMap |
|---------|-----------|---------|-------------------|
| **Thread-safe** | Yes | No | Yes |
| **Null key** | No | 1 | No |
| **Null value** | No | Yes | No |
| **Synchronization** | Full | None | Segment-level |
| **Performance** | Slow | Fast | Medium-Fast |
| **Since** | Java 1.0 | Java 1.2 | Java 1.5 |
| **Status** | Legacy | Modern | Modern |
| **Concurrency** | Poor | N/A | Excellent |
| **Recommended** | ‚ùå | ‚úÖ (single-threaded) | ‚úÖ (multi-threaded) |

---

## ‚ö†Ô∏è Why Not Use Hashtable?

```java
// ‚ùå Hashtable - Legacy, slow
Hashtable<String, Integer> old = new Hashtable<>();

// ‚úÖ Better alternatives:

// 1. For single-threaded - Use HashMap
Map<String, Integer> fast = new HashMap<>();

// 2. For multi-threaded - Use ConcurrentHashMap
Map<String, Integer> concurrent = new ConcurrentHashMap<>();

// 3. For multi-threaded simple cases - Synchronized HashMap
Map<String, Integer> synced = Collections.synchronizedMap(new HashMap<>());
```

**Problems with Hashtable:**
1. **Slow**: Locks entire table for every operation
2. **No null**: Can't use null keys or values
3. **Legacy**: Old design, better alternatives exist
4. **Poor concurrency**: Only one thread can access at a time
5. **Extends Dictionary**: Old, deprecated base class

---

## üîÑ Migration to Modern Alternatives

```java
// OLD WAY (Hashtable)
Hashtable<String, Integer> old = new Hashtable<>();
old.put("A", 1);
old.put("B", 2);

// NEW WAY 1: ConcurrentHashMap (for concurrent access)
ConcurrentHashMap<String, Integer> concurrent = new ConcurrentHashMap<>();
concurrent.put("A", 1);
concurrent.put("B", 2);

// NEW WAY 2: Synchronized HashMap (simple thread-safety)
Map<String, Integer> synced = Collections.synchronizedMap(new HashMap<>());
synced.put("A", 1);
synced.put("B", 2);

// NEW WAY 3: HashMap (if single-threaded)
Map<String, Integer> fast = new HashMap<>();
fast.put("A", 1);
fast.put("B", 2);
```

---

## üéØ When Hashtable Is (Rarely) Acceptable

```java
// Very limited scenarios:

// 1. Legacy code maintenance
// If existing codebase uses Hashtable, may need to maintain

// 2. Simple thread-safety without null
// If you need thread-safety and don't use null keys/values
// But ConcurrentHashMap is still better!

// 3. Backward compatibility
// If targeting very old Java versions (< 1.5)
// But modern Java is recommended
```

---

## üí° Best Practices

1. **Don't use Hashtable** in new code
2. **Use ConcurrentHashMap** for concurrent access
3. **Use HashMap** for single-threaded
4. **Migrate legacy code** to modern alternatives
5. **Null handling**: ConcurrentHashMap and Hashtable don't allow null
6. **Performance**: HashMap > ConcurrentHashMap > Hashtable

---

## üîÑ Iteration

```java
Hashtable<String, Integer> table = new Hashtable<>();
table.put("A", 1);
table.put("B", 2);
table.put("C", 3);

// 1. EntrySet
for (Map.Entry<String, Integer> entry : table.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}

// 2. KeySet
for (String key : table.keySet()) {
    System.out.println(key + " = " + table.get(key));
}

// 3. Values
for (Integer value : table.values()) {
    System.out.println("Value: " + value);
}

// 4. Enumeration (legacy, don't use)
Enumeration<String> keys = table.keys();
while (keys.hasMoreElements()) {
    String key = keys.nextElement();
    System.out.println(key + " = " + table.get(key));
}
```

---

## üéì Interview Questions

**Q: What is Hashtable?**
A: Legacy thread-safe Map from Java 1.0, all methods synchronized.

**Q: Hashtable vs HashMap?**
A: Hashtable is synchronized (slower), no null. HashMap is unsynchronized (faster), allows null.

**Q: Can Hashtable have null keys/values?**
A: No, both throw NullPointerException.

**Q: Is Hashtable thread-safe?**
A: Yes, but use ConcurrentHashMap instead (better performance).

**Q: Why not use Hashtable?**
A: Legacy, slow, poor concurrency. Use ConcurrentHashMap or synchronized HashMap.

**Q: Hashtable vs ConcurrentHashMap?**
A: Both thread-safe. ConcurrentHashMap has better concurrency (segment locking), Hashtable locks entire table.

**Q: When to use Hashtable?**
A: Almost never. Use ConcurrentHashMap or HashMap instead.

**Q: What does Hashtable extend?**
A: Dictionary (deprecated base class).

---

## üìö Summary

- **Hashtable**: Legacy synchronized Map from Java 1.0
- **Thread-safe** but **slow** (locks entire table)
- **No null** keys or values
- **Poor concurrency** - only one thread at a time
- **Status**: **Legacy - Don't use in new code**
- **Modern alternatives**:
  - **ConcurrentHashMap** - for concurrent access
  - **HashMap** - for single-threaded
  - **Collections.synchronizedMap(HashMap)** - for simple thread-safety
- Use only for **legacy code maintenance**
- Migrate to ConcurrentHashMap for better performance and concurrency
