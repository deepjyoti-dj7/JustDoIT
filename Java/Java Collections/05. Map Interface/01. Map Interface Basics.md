# ğŸ—ºï¸ Map Interface Basics

## ğŸ“– Overview

`Map` is a **key-value pair** collection that maps **unique keys** to **values**. Unlike Collection, Map is a **separate interface** in the Java Collections Framework.

```java
public interface Map<K, V>
```

**Key Features:** Unique keys, key-value mapping, no duplicate keys.

---

## ğŸ”‘ Key Characteristics

1. **Key-Value Pairs** - Each entry has a key and a value
2. **Unique Keys** - No duplicate keys allowed
3. **One Value per Key** - Each key maps to at most one value
4. **Null Keys/Values** - Some implementations allow null
5. **Not a Collection** - Separate interface hierarchy
6. **Three Views** - keySet(), values(), entrySet()
7. **No Order Guarantee** - Order depends on implementation

---

## ğŸ—ï¸ Map Hierarchy

```
Map (Interface)
    â”œâ”€â”€ HashMap              (Unordered, O(1) operations)
    â”‚   â””â”€â”€ LinkedHashMap    (Insertion/access order)
    â”œâ”€â”€ TreeMap              (Sorted, O(log n) operations)
    â”œâ”€â”€ Hashtable            (Legacy, synchronized)
    â”œâ”€â”€ WeakHashMap          (Weak key references)
    â”œâ”€â”€ IdentityHashMap      (Reference equality)
    â””â”€â”€ EnumMap              (Enum keys, highly efficient)

SortedMap (Interface)
    â””â”€â”€ NavigableMap (Interface)
        â””â”€â”€ TreeMap

ConcurrentMap (Interface)
    â””â”€â”€ ConcurrentHashMap    (Thread-safe)
```

---

## ğŸ¨ Basic Operations

```java
import java.util.*;

public class MapBasicsDemo {
    public static void main(String[] args) {
        // Create a HashMap
        Map<String, Integer> map = new HashMap<>();
        
        // 1. PUT - Add key-value pairs
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Orange", 15);
        
        System.out.println("Map: " + map);
        // {Apple=10, Banana=20, Orange=15}
        
        // 2. GET - Retrieve value by key
        Integer apples = map.get("Apple");
        System.out.println("Apples: " + apples);  // 10
        
        // 3. GET with default
        Integer grapes = map.getOrDefault("Grapes", 0);
        System.out.println("Grapes: " + grapes);  // 0 (not found)
        
        // 4. PUT if absent
        map.putIfAbsent("Banana", 25);  // Won't update (key exists)
        map.putIfAbsent("Mango", 30);   // Will add (new key)
        
        // 5. UPDATE - Replace value
        map.put("Apple", 12);  // Updates existing
        map.replace("Banana", 22);
        
        // 6. CONTAINS - Check existence
        System.out.println("Has Apple? " + map.containsKey("Apple"));    // true
        System.out.println("Has value 15? " + map.containsValue(15));   // true
        
        // 7. SIZE
        System.out.println("Size: " + map.size());  // 4
        
        // 8. REMOVE
        Integer removed = map.remove("Orange");
        System.out.println("Removed: " + removed);  // 15
        
        // 9. REMOVE with value check
        boolean removed2 = map.remove("Banana", 22);
        System.out.println("Removed Banana? " + removed2);  // true
        
        // 10. CLEAR
        // map.clear();
        
        // 11. IS EMPTY
        System.out.println("Is empty? " + map.isEmpty());  // false
    }
}
```

---

## ğŸ”„ Map Views (Three Ways to Traverse)

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

// 1. KEY SET VIEW
Set<String> keys = map.keySet();
System.out.println("Keys: " + keys);  // [A, B, C]

for (String key : keys) {
    System.out.println(key + " -> " + map.get(key));
}

// 2. VALUES VIEW (Collection, not Set - can have duplicates)
Collection<Integer> values = map.values();
System.out.println("Values: " + values);  // [1, 2, 3]

for (Integer value : values) {
    System.out.println("Value: " + value);
}

// 3. ENTRY SET VIEW (Most efficient for iteration)
Set<Map.Entry<String, Integer>> entries = map.entrySet();

for (Map.Entry<String, Integer> entry : entries) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}

// Modern approach - forEach
map.forEach((key, value) -> {
    System.out.println(key + " => " + value);
});
```

---

## ğŸ¯ Common Map Operations

### Put Operations

```java
Map<String, Integer> map = new HashMap<>();

// put() - Add or update
Integer old = map.put("key", 10);  // Returns null (new key)
old = map.put("key", 20);          // Returns 10 (updated)

// putIfAbsent() - Only if key doesn't exist
map.putIfAbsent("key", 30);  // Won't update (returns 20)
map.putIfAbsent("new", 40);  // Will add (returns null)

// putAll() - Copy from another map
Map<String, Integer> other = Map.of("a", 1, "b", 2);
map.putAll(other);
```

### Get Operations

```java
// get() - Returns null if key not found
Integer value = map.get("key");

// getOrDefault() - Returns default if not found
Integer value2 = map.getOrDefault("missing", 0);

// containsKey() / containsValue()
boolean hasKey = map.containsKey("key");
boolean hasValue = map.containsValue(10);
```

### Remove Operations

```java
// remove(key) - Returns removed value
Integer removed = map.remove("key");

// remove(key, value) - Only removes if value matches
boolean removed2 = map.remove("key", 10);
```

### Replace Operations

```java
// replace(key, value) - Only if key exists
Integer old = map.replace("key", 50);

// replace(key, oldValue, newValue) - Only if current value matches
boolean replaced = map.replace("key", 50, 60);

// replaceAll() - Apply function to all entries
map.replaceAll((k, v) -> v * 2);
```

---

## ğŸ¯ Compute Operations (Java 8+)

```java
Map<String, Integer> inventory = new HashMap<>();
inventory.put("Apple", 10);
inventory.put("Banana", 20);

// compute() - Compute new value based on key and current value
inventory.compute("Apple", (key, value) -> value == null ? 1 : value + 5);
System.out.println(inventory.get("Apple"));  // 15

// computeIfAbsent() - Only compute if key absent
inventory.computeIfAbsent("Orange", key -> 30);
System.out.println(inventory.get("Orange"));  // 30

inventory.computeIfAbsent("Apple", key -> 100);  // Won't update
System.out.println(inventory.get("Apple"));  // Still 15

// computeIfPresent() - Only compute if key present
inventory.computeIfPresent("Banana", (key, value) -> value + 10);
System.out.println(inventory.get("Banana"));  // 30

inventory.computeIfPresent("Grapes", (key, value) -> 50);  // Won't add
System.out.println(inventory.get("Grapes"));  // null

// merge() - Merge value with existing value
inventory.merge("Apple", 5, (oldVal, newVal) -> oldVal + newVal);
System.out.println(inventory.get("Apple"));  // 20 (15 + 5)

inventory.merge("Mango", 25, (oldVal, newVal) -> oldVal + newVal);
System.out.println(inventory.get("Mango"));  // 25 (new key, uses newVal)
```

---

## ğŸ¯ Real-World Examples

### Example 1: Word Frequency Counter

```java
String text = "hello world hello java world";
String[] words = text.split(" ");

Map<String, Integer> frequency = new HashMap<>();

// Traditional approach
for (String word : words) {
    frequency.put(word, frequency.getOrDefault(word, 0) + 1);
}

// Modern approach with merge()
Map<String, Integer> frequency2 = new HashMap<>();
for (String word : words) {
    frequency2.merge(word, 1, Integer::sum);
}

System.out.println(frequency2);
// {java=1, world=2, hello=2}
```

### Example 2: Group Students by Grade

```java
class Student {
    String name;
    String grade;
    
    Student(String name, String grade) {
        this.name = name;
        this.grade = grade;
    }
}

List<Student> students = Arrays.asList(
    new Student("Alice", "A"),
    new Student("Bob", "B"),
    new Student("Charlie", "A"),
    new Student("David", "B")
);

Map<String, List<Student>> byGrade = new HashMap<>();

for (Student student : students) {
    byGrade.computeIfAbsent(student.grade, k -> new ArrayList<>())
           .add(student);
}

System.out.println("Grade A: " + byGrade.get("A").size());  // 2
System.out.println("Grade B: " + byGrade.get("B").size());  // 2
```

### Example 3: Cache with Default Values

```java
class Cache {
    private Map<String, String> cache = new HashMap<>();
    
    public String get(String key) {
        return cache.computeIfAbsent(key, k -> {
            System.out.println("Computing value for: " + k);
            return "Default_" + k;
        });
    }
}

Cache cache = new Cache();
System.out.println(cache.get("user1"));  // Computing... Default_user1
System.out.println(cache.get("user1"));  // Default_user1 (from cache)
```

### Example 4: Two Sum Problem

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        
        if (map.containsKey(complement)) {
            return new int[] {map.get(complement), i};
        }
        
        map.put(nums[i], i);
    }
    
    return new int[] {-1, -1};
}

// Test
int[] result = twoSum(new int[]{2, 7, 11, 15}, 9);
System.out.println(Arrays.toString(result));  // [0, 1]
```

### Example 5: Phone Directory

```java
Map<String, String> phoneBook = new HashMap<>();

phoneBook.put("Alice", "123-4567");
phoneBook.put("Bob", "234-5678");
phoneBook.put("Charlie", "345-6789");

// Lookup
String phone = phoneBook.get("Alice");
System.out.println("Alice's phone: " + phone);

// Update
phoneBook.replace("Bob", "999-9999");

// Remove
phoneBook.remove("Charlie");

// Check existence
if (phoneBook.containsKey("Alice")) {
    System.out.println("Found: " + phoneBook.get("Alice"));
}
```

---

## ğŸ†š Map vs Other Collections

| Feature | Map | List | Set |
|---------|-----|------|-----|
| **Structure** | Key-Value pairs | Indexed elements | Unique elements |
| **Duplicates** | Values yes, Keys no | Yes | No |
| **Null** | Depends on impl | Yes (ArrayList) | Depends on impl |
| **Order** | Depends on impl | Insertion order | Depends on impl |
| **Access** | By key | By index | By value |
| **Use case** | Lookup, mapping | Ordered collection | Uniqueness |

---

## ğŸ“Š Map Implementations Quick Comparison

| Implementation | Ordered | Sorted | Null Key | Null Value | Thread-Safe |
|---------------|---------|--------|----------|------------|-------------|
| **HashMap** | No | No | 1 | Yes | No |
| **LinkedHashMap** | Yes | No | 1 | Yes | No |
| **TreeMap** | Yes | Yes | No | Yes | No |
| **Hashtable** | No | No | No | No | Yes |
| **ConcurrentHashMap** | No | No | No | No | Yes |
| **WeakHashMap** | No | No | 1 | Yes | No |
| **IdentityHashMap** | No | No | Yes | Yes | No |
| **EnumMap** | Yes | Natural | No | Yes | No |

---

## âš ï¸ Common Pitfalls

```java
// 1. Modifying map while iterating (ConcurrentModificationException)
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

// âŒ Wrong
// for (String key : map.keySet()) {
//     map.remove(key);  // ConcurrentModificationException
// }

// âœ… Correct - Use iterator
Iterator<String> iterator = map.keySet().iterator();
while (iterator.hasNext()) {
    iterator.remove();
}

// âœ… Or removeIf
map.keySet().removeIf(key -> key.equals("A"));

// 2. Null key in TreeMap
// TreeMap<String, Integer> treeMap = new TreeMap<>();
// treeMap.put(null, 1);  // NullPointerException

// 3. Using mutable objects as keys
class MutableKey {
    int value;
    // If hashCode depends on value, changing value breaks map!
}

// 4. Not overriding equals() and hashCode()
class Person {
    String name;
    // Without equals/hashCode, two Person("Alice") are different keys!
}

// 5. Assuming order in HashMap
Map<String, Integer> hmap = new HashMap<>();
// Order is NOT guaranteed!
```

---

## ğŸ’¡ Best Practices

1. **Use HashMap** as default (fastest for most cases)
2. **Override equals() and hashCode()** for custom key objects
3. **Immutable keys** - Don't modify keys after insertion
4. **Use entrySet()** for iteration (more efficient)
5. **Use computeIfAbsent()** instead of get() + put()
6. **Choose right implementation** based on needs
7. **Don't assume order** unless using LinkedHashMap/TreeMap
8. **Avoid null keys/values** unless necessary

---

## ğŸ¯ When to Use Which Map

**HashMap:**
- âœ… Default choice (O(1) operations)
- âœ… No ordering needed
- âœ… Best performance

**LinkedHashMap:**
- âœ… Need insertion order
- âœ… Need access order (LRU cache)
- âœ… Predictable iteration order

**TreeMap:**
- âœ… Need sorted keys
- âœ… Range queries (subMap, headMap, tailMap)
- âœ… Navigable operations (floor, ceiling)

**Hashtable:**
- âŒ Legacy - Use ConcurrentHashMap instead

**ConcurrentHashMap:**
- âœ… Thread-safe operations
- âœ… High concurrency

---

## ğŸ“ Interview Questions

**Q: What is Map in Java?**
A: Key-value pair collection with unique keys.

**Q: Difference between Map and Collection?**
A: Map is separate interface, stores key-value pairs; Collection stores single elements.

**Q: Can Map have duplicate keys?**
A: No, keys must be unique. Duplicate keys replace old values.

**Q: Can Map have duplicate values?**
A: Yes, values can be duplicate.

**Q: What are three views of Map?**
A: keySet(), values(), entrySet().

**Q: What is difference between put() and putIfAbsent()?**
A: put() always updates, putIfAbsent() only adds if key doesn't exist.

**Q: What is computeIfAbsent() used for?**
A: Compute and add value only if key is absent. Useful for default values.

**Q: How to iterate over Map?**
A: Use entrySet() with for-each loop or forEach() method.

---

## ğŸ“š Summary

- **Map**: Key-value pair collection with unique keys
- **Not a Collection** - separate interface hierarchy
- **Three views**: keySet(), values(), entrySet()
- **Basic operations**: put(), get(), remove(), containsKey()
- **Compute operations**: compute(), computeIfAbsent(), merge()
- **No duplicate keys** - values can be duplicate
- **Order depends** on implementation (HashMap unordered, LinkedHashMap ordered, TreeMap sorted)
- **Immutable keys** - don't modify after insertion
- **Override equals/hashCode** for custom keys
- Choose implementation based on needs: speed, order, sorting
