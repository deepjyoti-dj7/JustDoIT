# ğŸ“Š Map Comparisons

## ğŸ“– Overview

Comprehensive comparison of all **Map implementations** to help choose the right one for your use case.

---

## ğŸ—ºï¸ Complete Map Hierarchy

```
Map (Interface)
â”œâ”€â”€ HashMap
â”‚   â””â”€â”€ LinkedHashMap
â”œâ”€â”€ TreeMap (implements NavigableMap â†’ SortedMap â†’ Map)
â”œâ”€â”€ Hashtable (Legacy)
â”œâ”€â”€ WeakHashMap
â”œâ”€â”€ IdentityHashMap
â”œâ”€â”€ EnumMap
â””â”€â”€ ConcurrentHashMap (java.util.concurrent)

SortedMap (Interface)
â””â”€â”€ NavigableMap (Interface)
    â””â”€â”€ TreeMap
```

---

## ğŸ“Š Comprehensive Comparison Table

| Feature | HashMap | LinkedHashMap | TreeMap | Hashtable | EnumMap | WeakHashMap | IdentityHashMap |
|---------|---------|---------------|---------|-----------|---------|-------------|-----------------|
| **Structure** | Hash table | Hash + List | Red-Black Tree | Hash table | Array | Hash table | Array |
| **Ordering** | None | Insertion/Access | Sorted | None | Enum order | None | None |
| **get() Time** | O(1) | O(1) | O(log n) | O(1) | O(1) | O(1) | O(n) |
| **put() Time** | O(1) | O(1) | O(log n) | O(1) | O(1) | O(1) | O(1) avg |
| **Null Key** | 1 | 1 | 0 | 0 | 0 | 1 | Multiple |
| **Null Values** | Yes | Yes | Yes | No | Yes | Yes | Yes |
| **Thread-Safe** | No | No | No | Yes | No | No | No |
| **Memory** | Medium | High | High | Medium | Low | Medium | Medium |
| **Use Case** | General | Need order | Sorted | Legacy | Enums | Caches | Identity |
| **Recommended** | âœ… Default | âœ… | âœ… | âŒ Legacy | âœ… Enums | âœ… Caches | âš ï¸ Special |

---

## ğŸ¯ Quick Decision Tree

```
Need a Map?
â”‚
â”œâ”€ Keys are enums?
â”‚  â””â”€ YES â†’ EnumMap â­
â”‚
â”œâ”€ Need sorting?
â”‚  â””â”€ YES â†’ TreeMap ğŸŒ³
â”‚
â”œâ”€ Need insertion order?
â”‚  â””â”€ YES â†’ LinkedHashMap ğŸ”—
â”‚
â”œâ”€ Need access order (LRU)?
â”‚  â””â”€ YES â†’ LinkedHashMap(accessOrder=true) ğŸ”—
â”‚
â”œâ”€ Memory-sensitive cache?
â”‚  â””â”€ YES â†’ WeakHashMap ğŸ§¹
â”‚
â”œâ”€ Need reference equality?
â”‚  â””â”€ YES â†’ IdentityHashMap ğŸ†”
â”‚
â”œâ”€ Need thread-safety?
â”‚  â””â”€ YES â†’ ConcurrentHashMap ğŸ”’
â”‚
â””â”€ Default choice?
   â””â”€ HashMap ğŸ—‚ï¸ (fastest)
```

---

## ğŸ† Performance Comparison

### Time Complexity

| Operation | HashMap | LinkedHashMap | TreeMap | EnumMap | IdentityHashMap |
|-----------|---------|---------------|---------|---------|-----------------|
| **get** | O(1) | O(1) | O(log n) | O(1) | O(n) |
| **put** | O(1) | O(1) | O(log n) | O(1) | O(1) avg |
| **remove** | O(1) | O(1) | O(log n) | O(1) | O(n) |
| **containsKey** | O(1) | O(1) | O(log n) | O(1) | O(n) |
| **Iteration** | O(n+capacity) | O(n) | O(n) | O(n) | O(capacity) |

### Benchmark (1 million operations)

```java
// Rough performance comparison
HashMap:           ~50ms   â­ Fastest
LinkedHashMap:     ~70ms   
EnumMap:           ~40ms   â­â­ (for enums)
TreeMap:           ~200ms  
Hashtable:         ~80ms   (synchronized overhead)
WeakHashMap:       ~60ms   
IdentityHashMap:   ~100ms
```

---

## ğŸ¨ Feature Comparison

### 1. Ordering

```java
Map<String, Integer> map;

// No order
map = new HashMap<>();
// {B=2, A=1, C=3} - Random

// Insertion order
map = new LinkedHashMap<>();
// {A=1, B=2, C=3} - As inserted

// Sorted order
map = new TreeMap<>();
// {A=1, B=2, C=3} - Alphabetical

// Enum declaration order
EnumMap<Day, String> enumMap = new EnumMap<>(Day.class);
// MON, TUE, WED... - Enum order
```

---

### 2. Null Handling

```java
// ONE null key, multiple null values
HashMap<String, Integer> hash = new HashMap<>();
hash.put(null, 1);     // âœ… OK
hash.put("A", null);   // âœ… OK

// NO null keys or values
Hashtable<String, Integer> table = new Hashtable<>();
// table.put(null, 1);    // âŒ NullPointerException
// table.put("A", null);  // âŒ NullPointerException

// NO null keys
TreeMap<String, Integer> tree = new TreeMap<>();
// tree.put(null, 1);     // âŒ NullPointerException
tree.put("A", null);      // âœ… OK (values allowed)

// NO null keys (enum)
EnumMap<Day, String> enumMap = new EnumMap<>(Day.class);
// enumMap.put(null, "X"); // âŒ NullPointerException
enumMap.put(Day.MON, null); // âœ… OK

// Multiple null keys (identity)
IdentityHashMap<String, Integer> identity = new IdentityHashMap<>();
identity.put(null, 1);  // âœ… OK (multiple allowed)
```

---

### 3. Memory Usage

```java
// From most to least memory efficient:

EnumMap          â­â­â­â­â­ (Array, size = enum constants)
HashMap          â­â­â­â­   (Hash table, capacity-based)
WeakHashMap      â­â­â­â­   (Hash table)
IdentityHashMap  â­â­â­â­   (Array)
Hashtable        â­â­â­    (Hash table + synchronization)
LinkedHashMap    â­â­      (Hash + doubly-linked list)
TreeMap          â­â­      (Red-Black tree nodes)
```

---

### 4. Thread Safety

```java
// NOT thread-safe (default)
HashMap<String, Integer> map = new HashMap<>();
LinkedHashMap<String, Integer> linked = new LinkedHashMap<>();
TreeMap<String, Integer> tree = new TreeMap<>();
// Need external synchronization

// Make thread-safe
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());

// Thread-safe (legacy)
Hashtable<String, Integer> table = new Hashtable<>();

// Thread-safe (modern)
ConcurrentHashMap<String, Integer> concurrent = new ConcurrentHashMap<>();
```

---

## ğŸ¯ Use Case Recommendations

### HashMap - Default Choice
```java
// âœ… Use for:
- General key-value storage
- Fast lookups
- No ordering needed
- Single-threaded or externally synchronized

// Example:
Map<String, User> users = new HashMap<>();
Map<Integer, Order> orders = new HashMap<>();
```

---

### LinkedHashMap - Predictable Order
```java
// âœ… Use for:
- Insertion order preservation
- LRU cache (accessOrder=true)
- Predictable iteration
- Recently used items

// Example: LRU Cache
Map<String, Image> cache = new LinkedHashMap<>(16, 0.75f, true) {
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > 100;
    }
};
```

---

### TreeMap - Sorted Keys
```java
// âœ… Use for:
- Sorted key order
- Range queries (subMap, headMap, tailMap)
- Navigation (ceiling, floor, higher, lower)
- First/last key operations

// Example: Leaderboard
TreeMap<Integer, String> scores = new TreeMap<>(Collections.reverseOrder());
scores.put(100, "Alice");
scores.put(95, "Bob");
System.out.println("Winner: " + scores.firstEntry());  // 100=Alice
```

---

### Hashtable - Don't Use
```java
// âŒ Don't use in new code
// âœ… Use instead:
ConcurrentHashMap<String, Integer> modern = new ConcurrentHashMap<>();
```

---

### EnumMap - Enum Keys
```java
// âœ… Always use for enum keys
enum Status { ACTIVE, INACTIVE, PENDING }

// âœ… EnumMap - Fast, compact
EnumMap<Status, Integer> counts = new EnumMap<>(Status.class);

// âŒ Don't use HashMap for enums
// HashMap<Status, Integer> counts = new HashMap<>();  // Slower!
```

---

### WeakHashMap - Memory-Sensitive
```java
// âœ… Use for:
- Caches that shouldn't prevent GC
- Metadata about objects
- Canonicalization maps

// Example: Metadata cache
WeakHashMap<Object, Metadata> cache = new WeakHashMap<>();
```

---

### IdentityHashMap - Reference Equality
```java
// âœ… Use for:
- Object proxies
- Topology preservation (serialization, cloning)
- Visited object tracking
- Mutable keys

// Example: Object graph traversal
IdentityHashMap<Node, Boolean> visited = new IdentityHashMap<>();
```

---

## ğŸ†š Direct Comparisons

### HashMap vs LinkedHashMap
```java
// HashMap: Faster, less memory, no order
Map<String, Integer> fast = new HashMap<>();

// LinkedHashMap: Slightly slower, more memory, has order
Map<String, Integer> ordered = new LinkedHashMap<>();

// Choose HashMap unless you need order
```

---

### HashMap vs TreeMap
```java
// HashMap: O(1) operations, no order
Map<String, Integer> fast = new HashMap<>();

// TreeMap: O(log n) operations, sorted
Map<String, Integer> sorted = new TreeMap<>();

// Choose HashMap unless you need sorting
```

---

### HashMap vs EnumMap
```java
// For enum keys, ALWAYS use EnumMap
enum Day { MON, TUE, WED }

// âœ… EnumMap - Faster, more compact
EnumMap<Day, String> best = new EnumMap<>(Day.class);

// âŒ HashMap - Slower, more memory
// HashMap<Day, String> worse = new HashMap<>();
```

---

### HashMap vs ConcurrentHashMap
```java
// Single-threaded: HashMap
Map<String, Integer> single = new HashMap<>();

// Multi-threaded: ConcurrentHashMap
Map<String, Integer> multi = new ConcurrentHashMap<>();
```

---

## ğŸ’¡ Best Practices Summary

1. **Default to HashMap** - fastest for most cases
2. **EnumMap for enums** - always faster
3. **LinkedHashMap for order** - when order matters
4. **TreeMap for sorting** - when need sorted keys
5. **WeakHashMap for caches** - memory-sensitive
6. **ConcurrentHashMap for threads** - modern thread-safety
7. **Avoid Hashtable** - legacy, use alternatives
8. **IdentityHashMap rarely** - only for special cases

---

## ğŸ“ Interview Quick Reference

**Q: Best Map for general use?**
A: HashMap (O(1), fast, no overhead)

**Q: Need order?**
A: LinkedHashMap (insertion) or TreeMap (sorted)

**Q: Enum keys?**
A: EnumMap (always fastest for enums)

**Q: Thread-safe?**
A: ConcurrentHashMap (modern) or synchronized HashMap

**Q: Memory-sensitive cache?**
A: WeakHashMap (auto GC cleanup)

**Q: Can't use equals()?**
A: IdentityHashMap (reference equality)

**Q: Legacy code with Hashtable?**
A: Migrate to ConcurrentHashMap or HashMap

---

## ğŸ“š Summary

- **HashMap**: Default choice - O(1), fast, unordered
- **LinkedHashMap**: HashMap + order - insertion or access order
- **TreeMap**: Sorted map - O(log n), Red-Black Tree
- **Hashtable**: Legacy - use ConcurrentHashMap instead
- **EnumMap**: For enums - fastest, most compact
- **WeakHashMap**: Memory-sensitive caches - auto cleanup
- **IdentityHashMap**: Reference equality - special cases

**Golden Rule:** Start with HashMap, change only if specific needs require it.
