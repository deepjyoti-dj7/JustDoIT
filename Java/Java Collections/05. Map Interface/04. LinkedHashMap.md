# üîó LinkedHashMap

## üìñ Overview

`LinkedHashMap` is a **HashMap with predictable iteration order**. It maintains a **doubly-linked list** of entries in **insertion order** (or access order for LRU cache).

```java
public class LinkedHashMap<K,V> extends HashMap<K,V>
    implements Map<K,V>
```

**Core Feature:** Maintains insertion/access order with doubly-linked list.

---

## üîë Key Characteristics

1. **Ordered** - Maintains insertion or access order
2. **Hash Table + Linked List** - Combines both structures
3. **O(1) Operations** - Same as HashMap
4. **One Null Key** - Allows one null key
5. **Multiple Null Values** - Allows null values
6. **Not Thread-Safe** - Synchronize externally if needed
7. **Predictable Iteration** - Always same order

---

## üíª Creating LinkedHashMap

```java
import java.util.*;

// 1. Default - insertion order
Map<String, Integer> map1 = new LinkedHashMap<>();

// 2. With initial capacity
Map<String, Integer> map2 = new LinkedHashMap<>(32);

// 3. With capacity and load factor
Map<String, Integer> map3 = new LinkedHashMap<>(32, 0.75f);

// 4. Access order (for LRU cache)
Map<String, Integer> lruMap = new LinkedHashMap<>(16, 0.75f, true);
//                                                         accessOrder ‚Üë

// 5. From another map
Map<String, Integer> original = Map.of("A", 1, "B", 2);
Map<String, Integer> map4 = new LinkedHashMap<>(original);
```

**Constructor Parameters:**
- `initialCapacity`: Initial capacity (default 16)
- `loadFactor`: Load factor (default 0.75)
- `accessOrder`: 
  - `false` ‚Üí insertion order (default)
  - `true` ‚Üí access order (for LRU)

---

## üé® Insertion Order Example

```java
public class InsertionOrderDemo {
    public static void main(String[] args) {
        // LinkedHashMap - maintains insertion order
        Map<String, Integer> linked = new LinkedHashMap<>();
        linked.put("Zebra", 3);
        linked.put("Apple", 1);
        linked.put("Mango", 2);
        
        System.out.println("LinkedHashMap:");
        for (Map.Entry<String, Integer> entry : linked.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
        // Output: Zebra=3, Apple=1, Mango=2 (insertion order)
        
        // HashMap - no order guarantee
        Map<String, Integer> hash = new HashMap<>();
        hash.put("Zebra", 3);
        hash.put("Apple", 1);
        hash.put("Mango", 2);
        
        System.out.println("\nHashMap:");
        for (Map.Entry<String, Integer> entry : hash.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
        // Output: May vary (Mango=2, Zebra=3, Apple=1)
    }
}
```

---

## üîÑ Access Order Example (LRU)

```java
public class AccessOrderDemo {
    public static void main(String[] args) {
        // Access order: true
        Map<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);
        
        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);
        
        System.out.println("Initial: " + map.keySet());
        // [A, B, C]
        
        // Access B (moves to end)
        map.get("B");
        System.out.println("After get(B): " + map.keySet());
        // [A, C, B]
        
        // Access A (moves to end)
        map.get("A");
        System.out.println("After get(A): " + map.keySet());
        // [C, B, A]
        
        // Put existing key C (moves to end)
        map.put("C", 30);
        System.out.println("After put(C): " + map.keySet());
        // [B, A, C]
    }
}
```

---

## üèóÔ∏è Internal Structure

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> {
    // Entry with before/after pointers
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;  // Doubly-linked list
        
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    
    // Head and tail of doubly-linked list
    transient Entry<K,V> head;
    transient Entry<K,V> tail;
    
    // Access order flag
    final boolean accessOrder;
}
```

**Structure Visualization:**
```
HashMap bucket array:
Index 0: null
Index 1: Entry(B) ‚îÄ‚îÄ‚Üí Entry(E)
Index 2: Entry(A)
Index 3: Entry(C) ‚îÄ‚îÄ‚Üí Entry(D)
Index 4: null

Doubly-linked list (insertion order):
head ‚Üí [A] ‚Üî [B] ‚Üî [C] ‚Üî [D] ‚Üî [E] ‚Üê tail

- HashMap structure: Fast O(1) lookup
- Linked list: Maintains order
- Each entry in both structures
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `get(key)` | O(1) | Same as HashMap |
| `put(key, value)` | O(1) | Slightly slower than HashMap |
| `remove(key)` | O(1) | Update linked list |
| `containsKey(key)` | O(1) | |
| `containsValue(value)` | O(n) | Must scan list |
| Iteration | O(n) | Follows linked list (efficient) |

**Space:** O(n) + overhead for linked list pointers

---

## üéØ LRU Cache Implementation

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75f, true);  // accessOrder = true
        this.capacity = capacity;
    }
    
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        // Remove eldest when size exceeds capacity
        return size() > capacity;
    }
}

// Usage
LRUCache<Integer, String> cache = new LRUCache<>(3);

cache.put(1, "One");
cache.put(2, "Two");
cache.put(3, "Three");
System.out.println(cache.keySet());  // [1, 2, 3]

cache.get(1);  // Access 1 (moves to end)
System.out.println(cache.keySet());  // [2, 3, 1]

cache.put(4, "Four");  // Evicts 2 (least recently used)
System.out.println(cache.keySet());  // [3, 1, 4]

cache.get(3);  // Access 3
System.out.println(cache.keySet());  // [1, 4, 3]
```

**removeEldestEntry():**
- Called after `put()` and `putAll()`
- Returns `true` to remove eldest entry
- Useful for size-bounded caches

---

## üéØ Real-World Examples

### Example 1: Browser History

```java
class BrowserHistory {
    private LinkedHashMap<String, String> history;
    private static final int MAX_SIZE = 10;
    
    public BrowserHistory() {
        history = new LinkedHashMap<String, String>(16, 0.75f, false) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > MAX_SIZE;
            }
        };
    }
    
    public void visit(String url, String title) {
        history.put(url, title);
    }
    
    public void showHistory() {
        System.out.println("Browser History (oldest to newest):");
        for (Map.Entry<String, String> entry : history.entrySet()) {
            System.out.println(entry.getValue() + " - " + entry.getKey());
        }
    }
}

// Usage
BrowserHistory browser = new BrowserHistory();
browser.visit("google.com", "Google");
browser.visit("github.com", "GitHub");
browser.visit("stackoverflow.com", "Stack Overflow");
browser.showHistory();
```

---

### Example 2: Recent Files

```java
class RecentFiles {
    private LinkedHashMap<String, Long> files;
    
    public RecentFiles(int capacity) {
        files = new LinkedHashMap<String, Long>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, Long> eldest) {
                return size() > capacity;
            }
        };
    }
    
    public void openFile(String filename) {
        files.put(filename, System.currentTimeMillis());
    }
    
    public List<String> getRecentFiles() {
        List<String> recent = new ArrayList<>(files.keySet());
        Collections.reverse(recent);  // Most recent first
        return recent;
    }
}

// Usage
RecentFiles recents = new RecentFiles(5);
recents.openFile("document.txt");
recents.openFile("report.pdf");
recents.openFile("code.java");
recents.openFile("notes.md");

recents.openFile("document.txt");  // Access again (moves to end)

System.out.println("Recent files: " + recents.getRecentFiles());
// [document.txt, notes.md, code.java, report.pdf]
```

---

### Example 3: Session Manager

```java
class SessionManager {
    private LinkedHashMap<String, String> sessions;
    private static final int MAX_SESSIONS = 100;
    
    public SessionManager() {
        sessions = new LinkedHashMap<String, String>(16, 0.75f, false) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                if (size() > MAX_SESSIONS) {
                    System.out.println("Evicting session: " + eldest.getKey());
                    return true;
                }
                return false;
            }
        };
    }
    
    public void createSession(String sessionId, String userId) {
        sessions.put(sessionId, userId);
    }
    
    public String getUser(String sessionId) {
        return sessions.get(sessionId);
    }
    
    public void removeSession(String sessionId) {
        sessions.remove(sessionId);
    }
    
    public int getActiveSessionCount() {
        return sessions.size();
    }
}
```

---

### Example 4: Build Cache

```java
class BuildCache {
    private LinkedHashMap<String, String> cache;
    
    public BuildCache(int maxSize) {
        cache = new LinkedHashMap<String, String>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > maxSize;
            }
        };
    }
    
    public String getBuildResult(String sourceHash) {
        return cache.get(sourceHash);
    }
    
    public void cacheBuild(String sourceHash, String buildOutput) {
        cache.put(sourceHash, buildOutput);
    }
    
    public boolean isCached(String sourceHash) {
        return cache.containsKey(sourceHash);
    }
}

// Usage
BuildCache buildCache = new BuildCache(50);
buildCache.cacheBuild("abc123", "BUILD SUCCESS");
buildCache.cacheBuild("def456", "BUILD SUCCESS");

if (buildCache.isCached("abc123")) {
    System.out.println("Using cached build");
    String result = buildCache.getBuildResult("abc123");
}
```

---

### Example 5: Ordered Configuration

```java
class Configuration {
    private LinkedHashMap<String, String> config;
    
    public Configuration() {
        config = new LinkedHashMap<>();  // Insertion order
    }
    
    public void set(String key, String value) {
        config.put(key, value);
    }
    
    public String get(String key) {
        return config.get(key);
    }
    
    public void printConfig() {
        System.out.println("Configuration (in order):");
        for (Map.Entry<String, String> entry : config.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
}

// Usage
Configuration cfg = new Configuration();
cfg.set("database.host", "localhost");
cfg.set("database.port", "5432");
cfg.set("database.name", "mydb");
cfg.set("app.name", "MyApp");
cfg.printConfig();
// Prints in insertion order
```

---

## üÜö LinkedHashMap vs HashMap vs TreeMap

| Feature | HashMap | LinkedHashMap | TreeMap |
|---------|---------|---------------|---------|
| **Order** | None | Insertion/Access | Sorted |
| **Performance (get)** | O(1) | O(1) | O(log n) |
| **Performance (put)** | O(1) | O(1) slightly slower | O(log n) |
| **Memory** | Less | More (linked list) | More (tree) |
| **Iteration** | Random | Predictable | Sorted |
| **Null key** | 1 | 1 | 0 |
| **Use case** | Fast lookup | Need order | Need sorting |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Confusing insertion vs access order
Map<String, Integer> map1 = new LinkedHashMap<>();  // Insertion order
Map<String, Integer> map2 = new LinkedHashMap<>(16, 0.75f, true);  // Access order

// 2. Not overriding removeEldestEntry for size limit
// Without override, LinkedHashMap grows unbounded

// 3. Using wrong order mode for LRU
Map<String, Integer> wrong = new LinkedHashMap<>();  // Won't work as LRU!
Map<String, Integer> right = new LinkedHashMap<>(16, 0.75f, true);  // LRU

// 4. Expecting sorted order
// LinkedHashMap maintains insertion/access order, NOT sorted order
// Use TreeMap for sorting

// 5. Thread safety
// LinkedHashMap is NOT thread-safe
// Synchronize: Map<K,V> m = Collections.synchronizedMap(new LinkedHashMap<>());
```

---

## üí° Best Practices

1. **Use for predictable iteration** - when order matters
2. **Implement LRU cache** - with accessOrder=true
3. **Override removeEldestEntry()** - for size-bounded cache
4. **Choose order mode** - insertion (default) vs access (LRU)
5. **Same hashCode rules** - as HashMap (immutable keys)
6. **Memory consideration** - uses more memory than HashMap
7. **Don't assume sorting** - use TreeMap if need sorted order

---

## üéØ When to Use LinkedHashMap

**Use LinkedHashMap when:**
- ‚úÖ Need predictable iteration order
- ‚úÖ Implementing LRU cache
- ‚úÖ Recent items tracking
- ‚úÖ Maintain insertion order
- ‚úÖ Need both fast lookup AND order

**Don't use LinkedHashMap when:**
- ‚ùå Don't need order ‚Üí Use `HashMap` (faster, less memory)
- ‚ùå Need sorted order ‚Üí Use `TreeMap`
- ‚ùå Memory constrained ‚Üí Use `HashMap`
- ‚ùå Need thread-safety ‚Üí Synchronize or use `ConcurrentHashMap`

---

## üéì Interview Questions

**Q: What is LinkedHashMap?**
A: HashMap with doubly-linked list maintaining insertion or access order.

**Q: LinkedHashMap vs HashMap?**
A: LinkedHashMap maintains order, uses more memory. HashMap is faster, no order.

**Q: How to implement LRU cache?**
A: LinkedHashMap with accessOrder=true and override removeEldestEntry().

**Q: What is accessOrder parameter?**
A: false (default) = insertion order, true = access order (for LRU).

**Q: Time complexity of operations?**
A: Same as HashMap - O(1) for get/put/remove.

**Q: Can LinkedHashMap have null keys?**
A: Yes, one null key allowed (like HashMap).

**Q: Is LinkedHashMap thread-safe?**
A: No, use Collections.synchronizedMap() or external synchronization.

**Q: What is removeEldestEntry()?**
A: Override to remove oldest entry when size limit reached.

---

## üìö Summary

- **LinkedHashMap**: HashMap with predictable iteration order
- **Doubly-linked list** maintains insertion or access order
- **O(1) operations** - same performance as HashMap
- **Two modes**: insertion order (default) or access order (LRU)
- **LRU cache**: Use accessOrder=true + removeEldestEntry()
- **More memory** than HashMap (linked list overhead)
- **Not thread-safe** - synchronize if needed
- Perfect for **caches, recent items, ordered configs**
- Choose based on need: HashMap (speed), LinkedHashMap (order), TreeMap (sorting)
