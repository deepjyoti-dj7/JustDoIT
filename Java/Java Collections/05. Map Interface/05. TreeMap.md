# üå≥ TreeMap

## üìñ Overview

`TreeMap` is a **sorted Map** implementation based on **Red-Black Tree**. It maintains keys in **natural order** or by a **custom comparator**, with **O(log n)** operations.

```java
public class TreeMap<K,V> extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, Serializable
```

**Core Feature:** Sorted key-value map with O(log n) performance.

---

## üîë Key Characteristics

1. **Sorted** - Keys in natural or custom order
2. **Red-Black Tree** - Self-balancing binary search tree
3. **O(log n) Operations** - For get, put, remove
4. **No Null Keys** - Keys must be non-null (values can be null)
5. **NavigableMap** - Rich navigation methods
6. **Not Thread-Safe** - Synchronize externally if needed
7. **Comparator or Comparable** - Keys must be comparable

---

## üíª Creating TreeMap

```java
import java.util.*;

// 1. Natural ordering (Comparable)
Map<String, Integer> map1 = new TreeMap<>();

// 2. Custom comparator (reverse order)
Map<String, Integer> map2 = new TreeMap<>(Collections.reverseOrder());

// 3. Custom comparator (by length)
Map<String, Integer> map3 = new TreeMap<>(
    Comparator.comparingInt(String::length)
);

// 4. From another map
Map<String, Integer> original = Map.of("B", 2, "A", 1, "C", 3);
Map<String, Integer> map4 = new TreeMap<>(original);
// Keys will be sorted: A, B, C

// 5. From SortedMap (keeps comparator)
SortedMap<String, Integer> sorted = new TreeMap<>(Collections.reverseOrder());
sorted.put("A", 1);
Map<String, Integer> map5 = new TreeMap<>(sorted);
```

---

## üé® Basic Operations

```java
public class TreeMapDemo {
    public static void main(String[] args) {
        TreeMap<String, Integer> map = new TreeMap<>();
        
        // PUT - Keys automatically sorted
        map.put("Mango", 3);
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Zebra", 4);
        
        System.out.println(map);
        // {Apple=1, Banana=2, Mango=3, Zebra=4} - Sorted!
        
        // GET
        Integer value = map.get("Apple");
        System.out.println("Apple: " + value);  // 1
        
        // FIRST and LAST keys
        System.out.println("First key: " + map.firstKey());  // Apple
        System.out.println("Last key: " + map.lastKey());    // Zebra
        
        // FIRST and LAST entries
        System.out.println("First entry: " + map.firstEntry());  // Apple=1
        System.out.println("Last entry: " + map.lastEntry());    // Zebra=4
        
        // CEILING (>= key)
        System.out.println("Ceiling of Cat: " + map.ceilingKey("Cat"));  // Mango
        
        // FLOOR (<= key)
        System.out.println("Floor of Cat: " + map.floorKey("Cat"));  // Banana
        
        // HIGHER (> key)
        System.out.println("Higher than Mango: " + map.higherKey("Mango"));  // Zebra
        
        // LOWER (< key)
        System.out.println("Lower than Mango: " + map.lowerKey("Mango"));  // Banana
        
        // REMOVE first/last
        map.pollFirstEntry();  // Removes Apple=1
        map.pollLastEntry();   // Removes Zebra=4
        System.out.println("After polls: " + map);  // {Banana=2, Mango=3}
    }
}
```

---

## üß≠ NavigableMap Methods

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(10, "Ten");
map.put(20, "Twenty");
map.put(30, "Thirty");
map.put(40, "Forty");
map.put(50, "Fifty");

// CEILING - least key >= given key
System.out.println(map.ceilingKey(25));  // 30
System.out.println(map.ceilingEntry(25));  // 30=Thirty

// FLOOR - greatest key <= given key
System.out.println(map.floorKey(25));  // 20
System.out.println(map.floorEntry(25));  // 20=Twenty

// HIGHER - least key > given key
System.out.println(map.higherKey(30));  // 40
System.out.println(map.higherEntry(30));  // 40=Forty

// LOWER - greatest key < given key
System.out.println(map.lowerKey(30));  // 20
System.out.println(map.lowerEntry(30));  // 20=Twenty

// FIRST and LAST
System.out.println(map.firstKey());  // 10
System.out.println(map.lastKey());   // 50

// POLL first/last (remove and return)
Map.Entry<Integer, String> first = map.pollFirstEntry();  // 10=Ten
Map.Entry<Integer, String> last = map.pollLastEntry();    // 50=Fifty

System.out.println("After polls: " + map);  // {20=Twenty, 30=Thirty, 40=Forty}
```

---

## üìä Range Views (SubMap, HeadMap, TailMap)

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(10, "A");
map.put(20, "B");
map.put(30, "C");
map.put(40, "D");
map.put(50, "E");
map.put(60, "F");

// SUBMAP - range [fromKey, toKey)
SortedMap<Integer, String> subMap = map.subMap(20, 50);
System.out.println("SubMap [20, 50): " + subMap);  // {20=B, 30=C, 40=D}

// HEADMAP - all keys < toKey
SortedMap<Integer, String> headMap = map.headMap(40);
System.out.println("HeadMap < 40: " + headMap);  // {10=A, 20=B, 30=C}

// TAILMAP - all keys >= fromKey
SortedMap<Integer, String> tailMap = map.tailMap(40);
System.out.println("TailMap >= 40: " + tailMap);  // {40=D, 50=E, 60=F}

// Inclusive/Exclusive variants (NavigableMap)
NavigableMap<Integer, String> subMap2 = map.subMap(20, true, 50, true);
System.out.println("SubMap [20, 50]: " + subMap2);  // {20=B, 30=C, 40=D, 50=E}

// DESCENDING map
NavigableMap<Integer, String> descending = map.descendingMap();
System.out.println("Descending: " + descending);  // {60=F, 50=E, ..., 10=A}

// Changes to views reflect in original map
subMap.put(25, "B2");
System.out.println("Original after view change: " + map);
// {10=A, 20=B, 25=B2, 30=C, 40=D, 50=E, 60=F}
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `get(key)` | O(log n) | Tree traversal |
| `put(key, value)` | O(log n) | Insert + rebalance |
| `remove(key)` | O(log n) | Delete + rebalance |
| `containsKey(key)` | O(log n) | |
| `firstKey() / lastKey()` | O(log n) | Navigate to leftmost/rightmost |
| `ceilingKey() / floorKey()` | O(log n) | Tree search |
| Iteration | O(n) | In-order traversal |

**Space:** O(n) where n is number of entries

---

## üéØ Real-World Examples

### Example 1: Leaderboard (Score Ranking)

```java
class Leaderboard {
    // TreeMap with reverse order (highest score first)
    private TreeMap<Integer, String> scores;
    
    public Leaderboard() {
        scores = new TreeMap<>(Collections.reverseOrder());
    }
    
    public void addScore(String player, int score) {
        scores.put(score, player);
    }
    
    public void showTopN(int n) {
        System.out.println("Top " + n + " players:");
        int count = 0;
        for (Map.Entry<Integer, String> entry : scores.entrySet()) {
            if (count++ >= n) break;
            System.out.println(entry.getValue() + ": " + entry.getKey());
        }
    }
    
    public String getWinner() {
        return scores.isEmpty() ? null : scores.firstEntry().getValue();
    }
}

// Usage
Leaderboard board = new Leaderboard();
board.addScore("Alice", 100);
board.addScore("Bob", 150);
board.addScore("Charlie", 120);
board.showTopN(2);
// Bob: 150
// Charlie: 120
System.out.println("Winner: " + board.getWinner());  // Bob
```

---

### Example 2: Event Timeline

```java
class EventTimeline {
    private TreeMap<Long, String> events;
    
    public EventTimeline() {
        events = new TreeMap<>();
    }
    
    public void addEvent(long timestamp, String description) {
        events.put(timestamp, description);
    }
    
    public List<String> getEventsInRange(long start, long end) {
        return new ArrayList<>(events.subMap(start, true, end, true).values());
    }
    
    public String getNextEvent(long currentTime) {
        Map.Entry<Long, String> entry = events.higherEntry(currentTime);
        return entry == null ? null : entry.getValue();
    }
    
    public String getPreviousEvent(long currentTime) {
        Map.Entry<Long, String> entry = events.lowerEntry(currentTime);
        return entry == null ? null : entry.getValue();
    }
}

// Usage
EventTimeline timeline = new EventTimeline();
timeline.addEvent(1000, "App started");
timeline.addEvent(2000, "User logged in");
timeline.addEvent(3000, "Data loaded");
timeline.addEvent(4000, "User action");

System.out.println("Next after 2500: " + timeline.getNextEvent(2500));
// Data loaded
System.out.println("Previous before 2500: " + timeline.getPreviousEvent(2500));
// User logged in
```

---

### Example 3: Price Range Query

```java
class ProductCatalog {
    // Price -> Product name
    private TreeMap<Double, String> products;
    
    public ProductCatalog() {
        products = new TreeMap<>();
    }
    
    public void addProduct(String name, double price) {
        products.put(price, name);
    }
    
    public List<String> getProductsInRange(double minPrice, double maxPrice) {
        return new ArrayList<>(
            products.subMap(minPrice, true, maxPrice, true).values()
        );
    }
    
    public String getCheapest() {
        return products.isEmpty() ? null : products.firstEntry().getValue();
    }
    
    public String getMostExpensive() {
        return products.isEmpty() ? null : products.lastEntry().getValue();
    }
    
    public String getCheapestAbove(double price) {
        Map.Entry<Double, String> entry = products.higherEntry(price);
        return entry == null ? null : entry.getValue();
    }
}

// Usage
ProductCatalog catalog = new ProductCatalog();
catalog.addProduct("Laptop", 999.99);
catalog.addProduct("Mouse", 29.99);
catalog.addProduct("Keyboard", 79.99);
catalog.addProduct("Monitor", 299.99);

System.out.println("Products $50-$500: " + catalog.getProductsInRange(50, 500));
// [Keyboard, Monitor]
System.out.println("Cheapest: " + catalog.getCheapest());  // Mouse
System.out.println("Cheapest above $80: " + catalog.getCheapestAbove(80));  // Monitor
```

---

### Example 4: Task Scheduler by Priority

```java
class Task {
    String name;
    int priority;
    
    Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public String toString() {
        return name + "(P" + priority + ")";
    }
}

class TaskScheduler {
    private TreeMap<Integer, List<Task>> tasksByPriority;
    
    public TaskScheduler() {
        tasksByPriority = new TreeMap<>();  // Ascending priority
    }
    
    public void scheduleTask(Task task) {
        tasksByPriority.computeIfAbsent(task.priority, k -> new ArrayList<>())
                       .add(task);
    }
    
    public Task getNextTask() {
        if (tasksByPriority.isEmpty()) return null;
        
        // Get highest priority (first key)
        Integer priority = tasksByPriority.firstKey();
        List<Task> tasks = tasksByPriority.get(priority);
        Task task = tasks.remove(0);
        
        if (tasks.isEmpty()) {
            tasksByPriority.remove(priority);
        }
        
        return task;
    }
    
    public List<Task> getTasksWithPriority(int priority) {
        return tasksByPriority.getOrDefault(priority, new ArrayList<>());
    }
}

// Usage
TaskScheduler scheduler = new TaskScheduler();
scheduler.scheduleTask(new Task("Database backup", 3));
scheduler.scheduleTask(new Task("Critical fix", 1));
scheduler.scheduleTask(new Task("Send email", 5));
scheduler.scheduleTask(new Task("Security patch", 1));

System.out.println("Next task: " + scheduler.getNextTask());
// Critical fix(P1)
```

---

### Example 5: Grade Book

```java
class GradeBook {
    // Score -> Student name
    private TreeMap<Integer, String> grades;
    
    public GradeBook() {
        grades = new TreeMap<>(Collections.reverseOrder());  // Highest first
    }
    
    public void addGrade(String student, int score) {
        grades.put(score, student);
    }
    
    public char getLetterGrade(int score) {
        if (score >= 90) return 'A';
        if (score >= 80) return 'B';
        if (score >= 70) return 'C';
        if (score >= 60) return 'D';
        return 'F';
    }
    
    public List<String> getTopStudents(int n) {
        return grades.values().stream()
                     .limit(n)
                     .collect(Collectors.toList());
    }
    
    public String getMedianStudent() {
        if (grades.isEmpty()) return null;
        int middle = grades.size() / 2;
        return new ArrayList<>(grades.values()).get(middle);
    }
    
    public int getPercentile(int score) {
        int below = (int) grades.keySet().stream()
                                .filter(s -> s < score)
                                .count();
        return (below * 100) / grades.size();
    }
}
```

---

## üÜö TreeMap vs HashMap vs LinkedHashMap

| Feature | TreeMap | HashMap | LinkedHashMap |
|---------|---------|---------|---------------|
| **Order** | Sorted | None | Insertion/Access |
| **Performance** | O(log n) | O(1) | O(1) |
| **Null key** | No | 1 | 1 |
| **Comparator** | Required/Natural | No | No |
| **Memory** | More (tree nodes) | Less | Medium |
| **Range queries** | Yes | No | No |
| **Navigation** | Yes | No | No |
| **Use case** | Sorted, ranges | Fast lookup | Need order |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Null keys not allowed
TreeMap<String, Integer> map = new TreeMap<>();
// map.put(null, 1);  // NullPointerException

// 2. Keys must be Comparable or provide Comparator
class Person {
    String name;  // No Comparable!
}
// TreeMap<Person, Integer> map = new TreeMap<>();
// map.put(new Person(), 1);  // ClassCastException

// 3. Modifying keys affects order
class MutableKey implements Comparable<MutableKey> {
    int value;
    
    @Override
    public int compareTo(MutableKey other) {
        return Integer.compare(this.value, other.value);
    }
}
MutableKey key = new MutableKey();
key.value = 5;
map.put(key, 100);
key.value = 10;  // ‚ùå Breaks tree structure!

// 4. Custom comparator inconsistency
Comparator<String> badComparator = (a, b) -> 0;  // All equal!
// TreeMap<String, Integer> bad = new TreeMap<>(badComparator);
// bad.put("A", 1);
// bad.put("B", 2);  // Won't add (considered equal to "A")

// 5. SubMap views are backed by original
SortedMap<Integer, String> sub = map.subMap(10, 50);
sub.clear();  // Also clears entries in original map!
```

---

## üí° Best Practices

1. **Ensure Comparable** or provide Comparator
2. **Immutable keys** - don't modify after insertion
3. **Use for sorted order** - when you need sorting
4. **Range queries** - leverage subMap, headMap, tailMap
5. **NavigableMap methods** - use ceiling, floor, higher, lower
6. **Avoid null keys** - TreeMap doesn't allow them
7. **Consider performance** - O(log n) vs HashMap's O(1)

---

## üéØ When to Use TreeMap

**Use TreeMap when:**
- ‚úÖ Need sorted keys
- ‚úÖ Range queries (subMap, headMap, tailMap)
- ‚úÖ Navigation (ceiling, floor, higher, lower)
- ‚úÖ First/last key operations
- ‚úÖ Ordered iteration
- ‚úÖ Rank/percentile calculations

**Don't use TreeMap when:**
- ‚ùå Don't need sorting ‚Üí Use `HashMap` (faster)
- ‚ùå Need insertion order ‚Üí Use `LinkedHashMap`
- ‚ùå Need O(1) operations ‚Üí Use `HashMap`
- ‚ùå Keys not comparable ‚Üí Fix or use HashMap

---

## üéì Interview Questions

**Q: What is TreeMap?**
A: Sorted Map based on Red-Black Tree with O(log n) operations.

**Q: TreeMap vs HashMap?**
A: TreeMap is sorted (O(log n)), HashMap is unsorted (O(1)).

**Q: Can TreeMap have null keys?**
A: No, null keys not allowed (NullPointerException).

**Q: What is Red-Black Tree?**
A: Self-balancing binary search tree ensuring O(log n) height.

**Q: How to reverse order in TreeMap?**
A: Use `Collections.reverseOrder()` comparator.

**Q: What is subMap()?**
A: Returns view of map for keys in range [fromKey, toKey).

**Q: Difference between ceiling and higher?**
A: ceiling includes key (>=), higher excludes key (>).

**Q: When to use TreeMap?**
A: When need sorted keys, range queries, or navigation methods.

---

## üìö Summary

- **TreeMap**: Sorted Map based on Red-Black Tree
- **O(log n)** for get, put, remove operations
- **Sorted order** by natural ordering or custom Comparator
- **No null keys** - values can be null
- **NavigableMap** - rich navigation methods (ceiling, floor, higher, lower)
- **Range views** - subMap, headMap, tailMap
- **Perfect for**: sorted data, range queries, leaderboards, timelines
- Use when sorting/navigation needed, else prefer HashMap (faster)
