# üÜî IdentityHashMap

## üìñ Overview

`IdentityHashMap` uses **reference equality (==)** instead of **object equality (equals())** for key comparison. It's used for special cases where **object identity** matters more than value.

```java
public class IdentityHashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Serializable, Cloneable
```

**Core Feature:** Uses reference equality (==) for keys, not equals().

---

## üîë Key Characteristics

1. **Reference Equality** - Uses == for key comparison
2. **Not equals()** - Ignores equals() and hashCode() methods
3. **Identity Hash** - Uses System.identityHashCode()
4. **Allows Null** - Both null keys and values allowed
5. **Not Thread-Safe** - Synchronize externally if needed
6. **Special Purpose** - For specific use cases only
7. **Linear Array** - Not a true hash table

---

## üé® Reference Equality vs Object Equality

```java
public class EqualityDemo {
    public static void main(String[] args) {
        String s1 = new String("key");
        String s2 = new String("key");
        
        System.out.println(s1.equals(s2));  // true (same content)
        System.out.println(s1 == s2);       // false (different objects)
        
        // HASHMAP - Uses equals()
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put(s1, 1);
        hashMap.put(s2, 2);  // Overwrites s1 (equals() returns true)
        System.out.println("HashMap size: " + hashMap.size());  // 1
        System.out.println(hashMap.get(s1));  // 2
        System.out.println(hashMap.get(s2));  // 2
        
        // IDENTITYHASHMAP - Uses ==
        Map<String, Integer> identityMap = new IdentityHashMap<>();
        identityMap.put(s1, 1);
        identityMap.put(s2, 2);  // Different entry (== returns false)
        System.out.println("IdentityHashMap size: " + identityMap.size());  // 2
        System.out.println(identityMap.get(s1));  // 1
        System.out.println(identityMap.get(s2));  // 2
    }
}
```

---

## üíª Creating IdentityHashMap

```java
import java.util.*;

// 1. Default constructor (expected max size)
Map<String, Integer> map1 = new IdentityHashMap<>();

// 2. With expected maximum size
Map<String, Integer> map2 = new IdentityHashMap<>(50);

// 3. From another map
Map<String, Integer> original = new HashMap<>();
original.put("A", 1);
Map<String, Integer> map3 = new IdentityHashMap<>(original);
```

---

## üé® Basic Operations

```java
public class IdentityHashMapDemo {
    public static void main(String[] args) {
        IdentityHashMap<String, String> map = new IdentityHashMap<>();
        
        // Create separate String objects
        String key1 = new String("key");
        String key2 = new String("key");  // Same content, different object
        
        // PUT
        map.put(key1, "Value 1");
        map.put(key2, "Value 2");  // Different entry (different objects)
        
        System.out.println("Size: " + map.size());  // 2
        
        // GET by reference
        System.out.println(map.get(key1));  // Value 1
        System.out.println(map.get(key2));  // Value 2
        
        // GET with new String (same content)
        String key3 = new String("key");
        System.out.println(map.get(key3));  // null (different object reference)
        
        // CONTAINS KEY
        System.out.println(map.containsKey(key1));  // true
        System.out.println(map.containsKey(key3));  // false (different object)
        
        // String literals (interned - same reference)
        map.put("literal", "Value");
        System.out.println(map.get("literal"));  // Value (same reference)
    }
}
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `get(key)` | O(n) | Linear search in worst case |
| `put(key, value)` | O(n) | Amortized O(1) typical |
| `remove(key)` | O(n) | Linear search |
| `containsKey(key)` | O(n) | Linear search |
| Iteration | O(capacity) | |

**Note:** Not optimized for performance, used for specific scenarios.

---

## üéØ Real-World Examples

### Example 1: Object Proxies

```java
class ObjectProxy {
    private IdentityHashMap<Object, Object> realObjects;
    
    public ObjectProxy() {
        realObjects = new IdentityHashMap<>();
    }
    
    public void registerProxy(Object proxy, Object real) {
        realObjects.put(proxy, real);
    }
    
    public Object getRealObject(Object proxy) {
        return realObjects.get(proxy);
    }
}

// Usage
ObjectProxy proxyManager = new ObjectProxy();
Object proxy1 = new Object();
Object real1 = new String("Real object 1");

proxyManager.registerProxy(proxy1, real1);
Object retrieved = proxyManager.getRealObject(proxy1);
System.out.println(retrieved);  // Real object 1
```

---

### Example 2: Topology Preservation

```java
class DeepCloner {
    private IdentityHashMap<Object, Object> clones;
    
    public DeepCloner() {
        clones = new IdentityHashMap<>();
    }
    
    public Object clone(Object original) {
        // Check if already cloned (by reference)
        if (clones.containsKey(original)) {
            return clones.get(original);
        }
        
        // Create clone
        Object clone = createClone(original);
        clones.put(original, clone);
        
        return clone;
    }
    
    private Object createClone(Object obj) {
        // Simplified clone logic
        return new String(obj.toString());
    }
}

// Preserves object identity graph during cloning
DeepCloner cloner = new DeepCloner();
Object obj1 = new Object();
Object clone1a = cloner.clone(obj1);
Object clone1b = cloner.clone(obj1);  // Same clone returned
System.out.println(clone1a == clone1b);  // true
```

---

### Example 3: Serialization Context

```java
class SerializationContext {
    private IdentityHashMap<Object, Integer> objectIds;
    private int nextId = 1;
    
    public SerializationContext() {
        objectIds = new IdentityHashMap<>();
    }
    
    public int getObjectId(Object obj) {
        return objectIds.computeIfAbsent(obj, k -> nextId++);
    }
    
    public boolean isAlreadySerialized(Object obj) {
        return objectIds.containsKey(obj);
    }
}

// Usage
SerializationContext context = new SerializationContext();
Object obj1 = new Object();
Object obj2 = new Object();

System.out.println("ID for obj1: " + context.getObjectId(obj1));  // 1
System.out.println("ID for obj2: " + context.getObjectId(obj2));  // 2
System.out.println("ID for obj1 again: " + context.getObjectId(obj1));  // 1
```

---

### Example 4: Mutable Object Tracking

```java
class MutableKeyMap {
    private IdentityHashMap<MutableKey, String> map;
    
    static class MutableKey {
        int value;
        
        MutableKey(int value) {
            this.value = value;
        }
    }
    
    public MutableKeyMap() {
        map = new IdentityHashMap<>();
    }
    
    public void put(MutableKey key, String value) {
        map.put(key, value);
    }
    
    public String get(MutableKey key) {
        return map.get(key);
    }
}

// Usage - Safe to modify key
MutableKeyMap mkMap = new MutableKeyMap<>();
MutableKeyMap.MutableKey key = new MutableKeyMap.MutableKey(10);
mkMap.put(key, "Value");

key.value = 20;  // Modify key (safe with IdentityHashMap)
System.out.println(mkMap.get(key));  // Still finds "Value"
```

---

### Example 5: Visited Objects Tracker

```java
class ObjectGraph {
    static class Node {
        String name;
        List<Node> children = new ArrayList<>();
        
        Node(String name) {
            this.name = name;
        }
    }
    
    public void traverse(Node root) {
        IdentityHashMap<Node, Boolean> visited = new IdentityHashMap<>();
        traverseHelper(root, visited);
    }
    
    private void traverseHelper(Node node, IdentityHashMap<Node, Boolean> visited) {
        if (node == null || visited.containsKey(node)) {
            return;  // Already visited this exact object
        }
        
        visited.put(node, true);
        System.out.println("Visiting: " + node.name);
        
        for (Node child : node.children) {
            traverseHelper(child, visited);
        }
    }
}

// Usage - Handles cycles correctly
ObjectGraph.Node a = new ObjectGraph.Node("A");
ObjectGraph.Node b = new ObjectGraph.Node("B");
ObjectGraph.Node c = new ObjectGraph.Node("C");

a.children.add(b);
b.children.add(c);
c.children.add(a);  // Cycle!

new ObjectGraph().traverse(a);  // Won't infinite loop
```

---

## üÜö IdentityHashMap vs HashMap

| Feature | IdentityHashMap | HashMap |
|---------|----------------|---------|
| **Key comparison** | Reference (==) | Value (equals()) |
| **Hash function** | System.identityHashCode() | obj.hashCode() |
| **equals() used** | No | Yes |
| **hashCode() used** | No | Yes |
| **Performance** | Slower (O(n) worst) | Faster (O(1) avg) |
| **Use case** | Object identity | General purpose |
| **Mutable keys** | Safe | Unsafe |

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Using with String literals (interned)
IdentityHashMap<String, Integer> map = new IdentityHashMap<>();
map.put("literal1", 1);
map.put("literal1", 2);  // Same reference (interned)
System.out.println(map.size());  // 1 (not 2!)

// 2. Expecting equals() behavior
String s1 = new String("key");
String s2 = new String("key");
map.put(s1, 1);
System.out.println(map.get(s2));  // null (different reference!)

// 3. Using for general purpose
// ‚ùå Don't use IdentityHashMap for normal key-value storage
// ‚úÖ Use HashMap instead

// 4. Forgetting about interned Strings
Integer i1 = 127;  // Cached
Integer i2 = 127;  // Same object (cache)
map.put(i1, "A");
map.put(i2, "B");  // Overwrites (same reference)
System.out.println(map.size());  // 1

// 5. Slower performance
// IdentityHashMap is O(n) for lookups in worst case
// Not suitable for large datasets
```

---

## üí° Best Practices

1. **Use only for specific cases** - object identity matters
2. **Not for general purpose** - use HashMap instead
3. **Understand reference equality** - == vs equals()
4. **Beware of interned objects** - String literals, small Integers
5. **Mutable keys safe** - identity doesn't change
6. **Performance consideration** - slower than HashMap
7. **Document usage** - clarify why using IdentityHashMap

---

## üéØ When to Use IdentityHashMap

**Use IdentityHashMap when:**
- ‚úÖ Need reference equality (==)
- ‚úÖ Object proxies/wrappers
- ‚úÖ Topology preservation (cloning, serialization)
- ‚úÖ Visited object tracking (graph traversal)
- ‚úÖ Mutable keys needed
- ‚úÖ Object identity matters
- ‚úÖ Debugging/profiling tools

**Don't use IdentityHashMap when:**
- ‚ùå Need value equality ‚Üí Use `HashMap`
- ‚ùå General key-value storage ‚Üí Use `HashMap`
- ‚ùå Large datasets ‚Üí Use `HashMap` (faster)
- ‚ùå String keys ‚Üí Use `HashMap` (unless identity needed)

---

## üéì Interview Questions

**Q: What is IdentityHashMap?**
A: Map that uses reference equality (==) instead of equals() for keys.

**Q: When to use IdentityHashMap?**
A: When object identity matters, like proxies, topology preservation, graph traversal.

**Q: IdentityHashMap vs HashMap?**
A: IdentityHashMap uses == (reference), HashMap uses equals() (value).

**Q: Can IdentityHashMap use mutable keys?**
A: Yes, safe because uses reference (doesn't depend on value).

**Q: Performance of IdentityHashMap?**
A: O(n) worst case for lookups (linear array), slower than HashMap.

**Q: Does IdentityHashMap call hashCode()?**
A: No, uses System.identityHashCode().

**Q: Why not use for general purpose?**
A: Slower, special semantics. HashMap is better for most cases.

**Q: Can two Strings with same content have different entries?**
A: Yes, if different objects (new String("x") creates different instances).

---

## üìö Summary

- **IdentityHashMap**: Uses reference equality (==) for keys
- **Ignores equals/hashCode** - uses System.identityHashCode()
- **Allows mutable keys** - safe because identity doesn't change
- **Slower than HashMap** - O(n) worst case
- **Special purpose only** - object identity matters
- Perfect for **proxies, cloning, serialization, graph traversal**
- **Not for general use** - use HashMap instead
- Understand **reference vs value equality** before using
