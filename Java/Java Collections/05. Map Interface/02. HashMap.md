# üóÇÔ∏è HashMap

## üìñ Overview

`HashMap` is the **most commonly used** Map implementation, providing **O(1)** average-time performance for get() and put() operations using **hash table** data structure.

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```

**Core Feature:** Fast key-value lookups using hashing.

---

## üîë Key Characteristics

1. **Hash Table Based** - Uses array + linked list/tree
2. **O(1) Average Time** - For get/put operations
3. **Unordered** - No guarantee on iteration order
4. **One Null Key** - Allows one null key
5. **Multiple Null Values** - Allows null values
6. **Not Thread-Safe** - Use ConcurrentHashMap for concurrency
7. **Capacity & Load Factor** - Configurable performance tuning

---

## üíª Creating HashMap

```java
import java.util.*;

// 1. Default constructor - initial capacity 16, load factor 0.75
Map<String, Integer> map1 = new HashMap<>();

// 2. With initial capacity
Map<String, Integer> map2 = new HashMap<>(32);

// 3. With initial capacity and load factor
Map<String, Integer> map3 = new HashMap<>(32, 0.80f);

// 4. From another map
Map<String, Integer> original = Map.of("A", 1, "B", 2);
Map<String, Integer> map4 = new HashMap<>(original);

// 5. Using diamond operator
Map<String, Integer> map5 = new HashMap<>();
```

---

## üé® Basic Operations

```java
public class HashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> scores = new HashMap<>();
        
        // PUT - Add entries
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);
        
        System.out.println(scores);
        // {Alice=95, Bob=87, Charlie=92} - Order not guaranteed
        
        // GET
        Integer aliceScore = scores.get("Alice");
        System.out.println("Alice's score: " + aliceScore);  // 95
        
        // GET with default
        Integer davidScore = scores.getOrDefault("David", 0);
        System.out.println("David's score: " + davidScore);  // 0
        
        // UPDATE
        scores.put("Alice", 98);  // Updates existing
        System.out.println("Updated Alice: " + scores.get("Alice"));  // 98
        
        // PUT IF ABSENT
        scores.putIfAbsent("Bob", 90);  // Won't update (exists)
        scores.putIfAbsent("David", 85);  // Will add (new)
        
        // CONTAINS
        System.out.println("Has Alice? " + scores.containsKey("Alice"));  // true
        System.out.println("Has score 92? " + scores.containsValue(92)); // true
        
        // REMOVE
        Integer removed = scores.remove("Charlie");
        System.out.println("Removed: " + removed);  // 92
        
        // SIZE
        System.out.println("Size: " + scores.size());  // 3
        
        // ITERATION
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // CLEAR
        // scores.clear();
    }
}
```

---

## üìä Performance

| Operation | Average Case | Worst Case | Note |
|-----------|--------------|------------|------|
| `get(key)` | O(1) | O(n) | Worst case if all keys collide |
| `put(key, value)` | O(1) | O(n) | Amortized O(1) |
| `remove(key)` | O(1) | O(n) | |
| `containsKey(key)` | O(1) | O(n) | |
| `containsValue(value)` | O(n) | O(n) | Must scan all entries |
| Iteration | O(n + capacity) | O(n + capacity) | |

**Space:** O(n) where n is number of entries

---

## üéØ Capacity and Load Factor

```java
// Default values
// Initial capacity: 16
// Load factor: 0.75
// Resize threshold: capacity * loadFactor = 16 * 0.75 = 12

Map<String, Integer> map = new HashMap<>();
// When 12th element added, capacity doubles to 32

// Custom capacity and load factor
Map<String, Integer> customMap = new HashMap<>(100, 0.80f);
// Resize when 80 elements added (100 * 0.80)
```

**Load Factor:**
- **Lower (e.g., 0.5)**: Less collisions, more memory
- **Higher (e.g., 0.9)**: More collisions, less memory
- **Default (0.75)**: Good balance

**Initial Capacity:**
- Set based on expected size
- Reduces resize operations
- Formula: `expectedSize / loadFactor + 1`

```java
// If expecting 1000 elements
int capacity = (int) (1000 / 0.75 + 1);  // ~1334
Map<String, Integer> map = new HashMap<>(capacity);
```

---

## üéØ Null Handling

```java
Map<String, Integer> map = new HashMap<>();

// One null key allowed
map.put(null, 100);
map.put(null, 200);  // Updates the null key
System.out.println(map.get(null));  // 200

// Multiple null values allowed
map.put("A", null);
map.put("B", null);
map.put("C", null);

System.out.println(map);
// {null=200, A=null, B=null, C=null}

// Check for null
if (map.containsKey(null)) {
    System.out.println("Has null key");
}
```

---

## üéØ Real-World Examples

### Example 1: Character Frequency Count

```java
public Map<Character, Integer> countCharacters(String str) {
    Map<Character, Integer> frequency = new HashMap<>();
    
    for (char c : str.toCharArray()) {
        frequency.merge(c, 1, Integer::sum);
        // Or: frequency.put(c, frequency.getOrDefault(c, 0) + 1);
    }
    
    return frequency;
}

// Test
Map<Character, Integer> freq = countCharacters("hello");
System.out.println(freq);  // {e=1, h=1, l=2, o=1}
```

---

### Example 2: First Non-Repeating Character

```java
public char firstNonRepeating(String str) {
    Map<Character, Integer> frequency = new HashMap<>();
    
    // Count frequency
    for (char c : str.toCharArray()) {
        frequency.merge(c, 1, Integer::sum);
    }
    
    // Find first with frequency 1
    for (char c : str.toCharArray()) {
        if (frequency.get(c) == 1) {
            return c;
        }
    }
    
    return '\0';
}

// Test
char result = firstNonRepeating("leetcode");
System.out.println(result);  // l
```

---

### Example 3: Group Anagrams

```java
public Map<String, List<String>> groupAnagrams(String[] words) {
    Map<String, List<String>> groups = new HashMap<>();
    
    for (String word : words) {
        // Sort characters as key
        char[] chars = word.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        
        groups.computeIfAbsent(key, k -> new ArrayList<>()).add(word);
    }
    
    return groups;
}

// Test
String[] words = {"eat", "tea", "tan", "ate", "nat", "bat"};
Map<String, List<String>> result = groupAnagrams(words);
// {aet=[eat, tea, ate], ant=[tan, nat], abt=[bat]}
```

---

### Example 4: LRU Cache Basic (Using HashMap + LinkedList)

```java
class LRUCache {
    private Map<Integer, Integer> cache;
    private LinkedList<Integer> order;
    private int capacity;
    
    public LRUCache(int capacity) {
        this.cache = new HashMap<>();
        this.order = new LinkedList<>();
        this.capacity = capacity;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        
        // Move to end (most recently used)
        order.remove(Integer.valueOf(key));
        order.addLast(key);
        
        return cache.get(key);
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            order.remove(Integer.valueOf(key));
        } else if (cache.size() >= capacity) {
            // Remove least recently used
            Integer lru = order.removeFirst();
            cache.remove(lru);
        }
        
        cache.put(key, value);
        order.addLast(key);
    }
}

// Usage
LRUCache lru = new LRUCache(2);
lru.put(1, 1);
lru.put(2, 2);
System.out.println(lru.get(1));  // 1
lru.put(3, 3);  // Evicts key 2
System.out.println(lru.get(2));  // -1 (evicted)
```

---

### Example 5: Isomorphic Strings

```java
public boolean isIsomorphic(String s, String t) {
    if (s.length() != t.length()) return false;
    
    Map<Character, Character> mapS = new HashMap<>();
    Map<Character, Character> mapT = new HashMap<>();
    
    for (int i = 0; i < s.length(); i++) {
        char c1 = s.charAt(i);
        char c2 = t.charAt(i);
        
        if (mapS.containsKey(c1)) {
            if (mapS.get(c1) != c2) return false;
        } else {
            mapS.put(c1, c2);
        }
        
        if (mapT.containsKey(c2)) {
            if (mapT.get(c2) != c1) return false;
        } else {
            mapT.put(c2, c1);
        }
    }
    
    return true;
}

// Test
System.out.println(isIsomorphic("egg", "add"));  // true
System.out.println(isIsomorphic("foo", "bar"));  // false
```

---

### Example 6: Employee Directory

```java
class Employee {
    String id;
    String name;
    String department;
    
    Employee(String id, String name, String department) {
        this.id = id;
        this.name = name;
        this.department = department;
    }
    
    @Override
    public String toString() {
        return name + " (" + department + ")";
    }
}

Map<String, Employee> directory = new HashMap<>();

// Add employees
directory.put("E001", new Employee("E001", "Alice", "IT"));
directory.put("E002", new Employee("E002", "Bob", "HR"));
directory.put("E003", new Employee("E003", "Charlie", "Finance"));

// Lookup
Employee emp = directory.get("E001");
System.out.println(emp);  // Alice (IT)

// Update
directory.put("E001", new Employee("E001", "Alice Smith", "IT"));

// Remove
directory.remove("E003");

// Search by department
for (Employee e : directory.values()) {
    if (e.department.equals("IT")) {
        System.out.println(e);
    }
}
```

---

## üîÑ Iteration Methods

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

// 1. EntrySet (Most efficient)
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}

// 2. KeySet
for (String key : map.keySet()) {
    System.out.println(key + " = " + map.get(key));
}

// 3. Values
for (Integer value : map.values()) {
    System.out.println("Value: " + value);
}

// 4. forEach (Java 8+)
map.forEach((key, value) -> {
    System.out.println(key + " => " + value);
});

// 5. Stream API
map.entrySet().stream()
   .filter(e -> e.getValue() > 1)
   .forEach(e -> System.out.println(e.getKey()));
```

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Using mutable objects as keys
class MutableKey {
    int value;
    
    @Override
    public int hashCode() {
        return value;
    }
}

MutableKey key = new MutableKey();
key.value = 1;
map.put(key, "A");
key.value = 2;  // ‚ùå Changes hashCode, can't find entry!
System.out.println(map.get(key));  // null!

// 2. Not overriding equals() and hashCode()
class Person {
    String name;
    // Without equals/hashCode, two Person("Alice") are different keys!
}

// 3. Concurrent modification
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("B", 2);

// ‚ùå ConcurrentModificationException
// for (String key : map.keySet()) {
//     map.remove(key);
// }

// ‚úÖ Use iterator or removeIf
map.keySet().removeIf(key -> key.equals("A"));

// 4. Assuming order
// HashMap does NOT guarantee order!
// Use LinkedHashMap if you need insertion order

// 5. containsValue() is slow (O(n))
// Avoid if checking frequently
```

---

## üí° Best Practices

1. **Override equals() and hashCode()** for custom key objects
2. **Use immutable keys** - don't modify after insertion
3. **Set initial capacity** if size known: `new HashMap<>(expectedSize / 0.75 + 1)`
4. **Use computeIfAbsent()** for default values
5. **Use merge()** for counting/aggregation
6. **Use entrySet()** for iteration (efficient)
7. **Don't rely on order** - use LinkedHashMap if needed
8. **Thread-safety**: Use ConcurrentHashMap or synchronize externally

---

## üÜö HashMap vs Other Maps

| Feature | HashMap | LinkedHashMap | TreeMap |
|---------|---------|---------------|---------|
| **Order** | None | Insertion/Access | Sorted |
| **Performance (get)** | O(1) | O(1) | O(log n) |
| **Performance (put)** | O(1) | O(1) | O(log n) |
| **Null key** | 1 allowed | 1 allowed | Not allowed |
| **Memory** | Less | More (links) | More (tree) |
| **Use case** | Default | Need order | Need sorting |

---

## üéØ When to Use HashMap

**Use HashMap when:**
- ‚úÖ Need fast lookups (O(1))
- ‚úÖ Don't need ordering
- ‚úÖ Default choice for most cases
- ‚úÖ Key-value mapping
- ‚úÖ Frequency counting
- ‚úÖ Caching

**Don't use HashMap when:**
- ‚ùå Need insertion order ‚Üí Use `LinkedHashMap`
- ‚ùå Need sorted keys ‚Üí Use `TreeMap`
- ‚ùå Need thread-safety ‚Üí Use `ConcurrentHashMap`
- ‚ùå Single key-value ‚Üí Consider simple variable

---

## üéì Interview Questions

**Q: What is HashMap?**
A: Hash table based Map implementation with O(1) average time for get/put.

**Q: How does HashMap work?**
A: Uses hash function to determine bucket, handles collisions with linked list/tree.

**Q: Can HashMap have null keys/values?**
A: One null key allowed, multiple null values allowed.

**Q: What is load factor?**
A: Threshold (default 0.75) at which HashMap resizes. Balances space and time.

**Q: What happens when load factor exceeded?**
A: HashMap doubles capacity and rehashes all entries.

**Q: HashMap vs Hashtable?**
A: HashMap is not synchronized (faster), allows null key. Hashtable is legacy, synchronized, no null.

**Q: Is HashMap thread-safe?**
A: No, use ConcurrentHashMap for thread-safety.

**Q: Time complexity of HashMap operations?**
A: O(1) average for get/put/remove. O(n) worst case (all collisions).

---

## üìö Summary

- **HashMap**: Hash table based Map with O(1) operations
- **Unordered** - no guarantee on iteration order
- **One null key** - multiple null values allowed
- **Not thread-safe** - use ConcurrentHashMap for concurrency
- **Load factor** (0.75 default) controls resize threshold
- **Capacity** doubles when threshold exceeded
- **Use immutable keys** - don't modify after insertion
- **Override equals/hashCode** for custom keys
- **Most common Map** - default choice for key-value storage
- Perfect for **lookups, caching, frequency counting**
