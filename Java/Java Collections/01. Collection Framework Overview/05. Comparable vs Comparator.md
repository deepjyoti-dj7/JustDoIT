# ‚öñÔ∏è Comparable vs Comparator

## üìñ Overview

**Comparable** and **Comparator** are interfaces used for sorting objects in Java:
- **Comparable**: Defines natural ordering of objects (one way to compare)
- **Comparator**: Defines custom ordering of objects (multiple ways to compare)

Both are used with Collections.sort(), Arrays.sort(), TreeSet, TreeMap, etc.

---

## üéØ Key Differences

| Aspect | Comparable | Comparator |
|--------|-----------|------------|
| **Package** | java.lang | java.util |
| **Interface method** | compareTo(T o) | compare(T o1, T o2) |
| **Sorting logic** | Within the class (natural order) | Separate class or lambda |
| **Modification** | Modifies the actual class | External, doesn't modify class |
| **Single/Multiple** | Single sorting sequence | Multiple sorting sequences |
| **Usage** | Collections.sort(list) | Collections.sort(list, comparator) |
| **Example** | String, Integer classes | Custom comparators |

---

## üíª Example 1: Comparable Interface

```java
import java.util.*;

// Student class implementing Comparable
class Student implements Comparable<Student> {
    private String name;
    private int age;
    private double gpa;
    
    public Student(String name, int age, double gpa) {
        this.name = name;
        this.age = age;
        this.gpa = gpa;
    }
    
    // Natural ordering based on age
    @Override
    public int compareTo(Student other) {
        return this.age - other.age;  // Ascending order by age
        // return other.age - this.age;  // Descending order
        // return Integer.compare(this.age, other.age);  // Better way
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ", GPA:" + gpa + ")";
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getGpa() { return gpa; }
}

public class ComparableDemo {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 22, 3.8));
        students.add(new Student("Bob", 20, 3.5));
        students.add(new Student("Charlie", 21, 3.9));
        students.add(new Student("David", 23, 3.6));
        
        System.out.println("Before sorting:");
        students.forEach(System.out::println);
        
        // Sort using natural ordering (Comparable)
        Collections.sort(students);
        
        System.out.println("\nAfter sorting (by age - natural ordering):");
        students.forEach(System.out::println);
    }
}
```

**Output:**
```
Before sorting:
Alice(22, GPA:3.8)
Bob(20, GPA:3.5)
Charlie(21, GPA:3.9)
David(23, GPA:3.6)

After sorting (by age - natural ordering):
Bob(20, GPA:3.5)
Charlie(21, GPA:3.9)
Alice(22, GPA:3.8)
David(23, GPA:3.6)
```

---

## üíª Example 2: Comparator Interface

```java
import java.util.*;

class Employee {
    private String name;
    private int age;
    private double salary;
    
    public Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ", $" + salary + ")";
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
}

public class ComparatorDemo {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("Alice", 30, 75000));
        employees.add(new Employee("Bob", 25, 65000));
        employees.add(new Employee("Charlie", 35, 85000));
        employees.add(new Employee("David", 28, 70000));
        
        System.out.println("Original list:");
        employees.forEach(System.out::println);
        
        // 1. Sort by name using Comparator (lambda)
        Collections.sort(employees, (e1, e2) -> e1.getName().compareTo(e2.getName()));
        System.out.println("\nSorted by name:");
        employees.forEach(System.out::println);
        
        // 2. Sort by age
        Collections.sort(employees, (e1, e2) -> Integer.compare(e1.getAge(), e2.getAge()));
        System.out.println("\nSorted by age:");
        employees.forEach(System.out::println);
        
        // 3. Sort by salary (descending)
        Collections.sort(employees, (e1, e2) -> Double.compare(e2.getSalary(), e1.getSalary()));
        System.out.println("\nSorted by salary (descending):");
        employees.forEach(System.out::println);
        
        // 4. Using Comparator.comparing() - cleaner syntax
        employees.sort(Comparator.comparing(Employee::getName));
        System.out.println("\nSorted by name (using Comparator.comparing):");
        employees.forEach(System.out::println);
    }
}
```

---

## üíª Example 3: Multiple Comparators

```java
import java.util.*;

class Product {
    private String name;
    private String category;
    private double price;
    
    public Product(String name, String category, double price) {
        this.name = name;
        this.category = category;
        this.price = price;
    }
    
    @Override
    public String toString() {
        return String.format("%-15s %-12s $%.2f", name, category, price);
    }
    
    public String getName() { return name; }
    public String getCategory() { return category; }
    public double getPrice() { return price; }
}

public class MultipleComparatorsDemo {
    public static void main(String[] args) {
        List<Product> products = new ArrayList<>();
        products.add(new Product("Laptop", "Electronics", 1200));
        products.add(new Product("Mouse", "Electronics", 25));
        products.add(new Product("Desk", "Furniture", 300));
        products.add(new Product("Chair", "Furniture", 150));
        products.add(new Product("Keyboard", "Electronics", 75));
        
        System.out.println("Original list:");
        products.forEach(System.out::println);
        
        // 1. Comparator by price
        Comparator<Product> byPrice = Comparator.comparingDouble(Product::getPrice);
        products.sort(byPrice);
        System.out.println("\nSorted by price:");
        products.forEach(System.out::println);
        
        // 2. Comparator by category
        Comparator<Product> byCategory = Comparator.comparing(Product::getCategory);
        products.sort(byCategory);
        System.out.println("\nSorted by category:");
        products.forEach(System.out::println);
        
        // 3. Comparator by category, then by price
        Comparator<Product> byCategoryThenPrice = 
            Comparator.comparing(Product::getCategory)
                      .thenComparingDouble(Product::getPrice);
        products.sort(byCategoryThenPrice);
        System.out.println("\nSorted by category, then by price:");
        products.forEach(System.out::println);
        
        // 4. Reverse order
        products.sort(byPrice.reversed());
        System.out.println("\nSorted by price (descending):");
        products.forEach(System.out::println);
        
        // 5. Null-safe comparator
        List<Product> withNull = new ArrayList<>(products);
        withNull.add(null);
        
        Comparator<Product> nullSafeComparator = 
            Comparator.nullsLast(Comparator.comparing(Product::getName));
        withNull.sort(nullSafeComparator);
        System.out.println("\nWith null (nulls last):");
        withNull.forEach(System.out::println);
    }
}
```

---

## üíª Example 4: Built-in Comparable Classes

```java
import java.util.*;

public class BuiltInComparableDemo {
    public static void main(String[] args) {
        // String implements Comparable (lexicographic order)
        List<String> names = Arrays.asList("Charlie", "Alice", "Bob", "David");
        Collections.sort(names);
        System.out.println("Sorted strings: " + names);
        
        // Integer implements Comparable (numeric order)
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        Collections.sort(numbers);
        System.out.println("Sorted integers: " + numbers);
        
        // Date implements Comparable (chronological order)
        List<Date> dates = Arrays.asList(
            new Date(2024, 1, 15),
            new Date(2023, 6, 20),
            new Date(2024, 3, 10)
        );
        Collections.sort(dates);
        System.out.println("Sorted dates: " + dates);
        
        // Character implements Comparable
        List<Character> chars = Arrays.asList('z', 'a', 'm', 'b');
        Collections.sort(chars);
        System.out.println("Sorted characters: " + chars);
        
        // Reverse order using Comparator
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("\nReverse sorted integers: " + numbers);
        
        // Case-insensitive string comparison
        List<String> words = Arrays.asList("apple", "Banana", "cherry", "Apple");
        Collections.sort(words, String.CASE_INSENSITIVE_ORDER);
        System.out.println("Case-insensitive sorted: " + words);
    }
}
```

---

## üíª Example 5: Comparator Factory Methods (Java 8+)

```java
import java.util.*;

class Book {
    private String title;
    private String author;
    private int year;
    private double rating;
    
    public Book(String title, String author, int year, double rating) {
        this.title = title;
        this.author = author;
        this.year = year;
        this.rating = rating;
    }
    
    @Override
    public String toString() {
        return String.format("%-25s by %-15s (%d) Rating: %.1f", 
                           title, author, year, rating);
    }
    
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public int getYear() { return year; }
    public double getRating() { return rating; }
}

public class ComparatorFactoryMethodsDemo {
    public static void main(String[] args) {
        List<Book> books = new ArrayList<>();
        books.add(new Book("1984", "Orwell", 1949, 4.7));
        books.add(new Book("To Kill a Mockingbird", "Lee", 1960, 4.8));
        books.add(new Book("Pride and Prejudice", "Austen", 1813, 4.6));
        books.add(new Book("The Great Gatsby", "Fitzgerald", 1925, 4.5));
        books.add(new Book("Animal Farm", "Orwell", 1945, 4.3));
        
        System.out.println("Original list:");
        books.forEach(System.out::println);
        
        // 1. comparing()
        books.sort(Comparator.comparing(Book::getTitle));
        System.out.println("\nSorted by title:");
        books.forEach(System.out::println);
        
        // 2. comparingInt()
        books.sort(Comparator.comparingInt(Book::getYear));
        System.out.println("\nSorted by year:");
        books.forEach(System.out::println);
        
        // 3. comparingDouble()
        books.sort(Comparator.comparingDouble(Book::getRating));
        System.out.println("\nSorted by rating:");
        books.forEach(System.out::println);
        
        // 4. reversed()
        books.sort(Comparator.comparingDouble(Book::getRating).reversed());
        System.out.println("\nSorted by rating (descending):");
        books.forEach(System.out::println);
        
        // 5. thenComparing() - multiple criteria
        books.sort(Comparator.comparing(Book::getAuthor)
                             .thenComparingInt(Book::getYear));
        System.out.println("\nSorted by author, then year:");
        books.forEach(System.out::println);
        
        // 6. naturalOrder() and reverseOrder()
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        numbers.sort(Comparator.naturalOrder());
        System.out.println("\nNatural order: " + numbers);
        
        numbers.sort(Comparator.reverseOrder());
        System.out.println("Reverse order: " + numbers);
        
        // 7. nullsFirst() and nullsLast()
        List<String> withNulls = new ArrayList<>();
        withNulls.add("Beta");
        withNulls.add(null);
        withNulls.add("Alpha");
        withNulls.add(null);
        withNulls.add("Gamma");
        
        withNulls.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
        System.out.println("\nNulls first: " + withNulls);
        
        withNulls.sort(Comparator.nullsLast(Comparator.naturalOrder()));
        System.out.println("Nulls last: " + withNulls);
    }
}
```

---

## üíª Example 6: Chaining Comparators

```java
import java.util.*;

class Employee {
    private String department;
    private String name;
    private int age;
    private double salary;
    
    public Employee(String department, String name, int age, double salary) {
        this.department = department;
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
    
    @Override
    public String toString() {
        return String.format("%-10s %-12s Age:%2d Salary:$%.0f", 
                           department, name, age, salary);
    }
    
    public String getDepartment() { return department; }
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
}

public class ChainingComparatorsDemo {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("IT", "Alice", 30, 75000));
        employees.add(new Employee("HR", "Bob", 25, 65000));
        employees.add(new Employee("IT", "Charlie", 35, 85000));
        employees.add(new Employee("IT", "David", 28, 75000));
        employees.add(new Employee("HR", "Eve", 32, 70000));
        
        System.out.println("Original list:");
        employees.forEach(System.out::println);
        
        // Chain multiple criteria: department ‚Üí salary (desc) ‚Üí name
        Comparator<Employee> complexComparator = 
            Comparator.comparing(Employee::getDepartment)
                      .thenComparing(Comparator.comparingDouble(Employee::getSalary).reversed())
                      .thenComparing(Employee::getName);
        
        employees.sort(complexComparator);
        
        System.out.println("\nSorted by department, then salary (desc), then name:");
        employees.forEach(System.out::println);
    }
}
```

---

## üíª Example 7: Custom Comparator Class

```java
import java.util.*;

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}

// Custom Comparator class
class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
}

class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.getAge(), p2.getAge());
    }
}

public class CustomComparatorClassDemo {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Charlie", 25));
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 22));
        people.add(new Person("David", 28));
        
        System.out.println("Original list:");
        people.forEach(System.out::println);
        
        // Sort by name using custom Comparator class
        Collections.sort(people, new NameComparator());
        System.out.println("\nSorted by name:");
        people.forEach(System.out::println);
        
        // Sort by age using custom Comparator class
        Collections.sort(people, new AgeComparator());
        System.out.println("\nSorted by age:");
        people.forEach(System.out::println);
    }
}
```

---

## üíª Example 8: Comparable with compareTo() Best Practices

```java
import java.util.*;

class Score implements Comparable<Score> {
    private String player;
    private int points;
    
    public Score(String player, int points) {
        this.player = player;
        this.points = points;
    }
    
    @Override
    public int compareTo(Score other) {
        // Best practice: Use wrapper compare methods
        // return this.points - other.points;  // Bad: overflow risk!
        return Integer.compare(this.points, other.points);  // Good
    }
    
    // compareTo() should be consistent with equals()
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Score score = (Score) obj;
        return points == score.points && 
               Objects.equals(player, score.player);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(player, points);
    }
    
    @Override
    public String toString() {
        return player + ": " + points;
    }
}

public class CompareToBestPracticesDemo {
    public static void main(String[] args) {
        List<Score> scores = new ArrayList<>();
        scores.add(new Score("Alice", 95));
        scores.add(new Score("Bob", 87));
        scores.add(new Score("Charlie", 92));
        scores.add(new Score("David", 88));
        
        Collections.sort(scores);
        System.out.println("Sorted scores:");
        scores.forEach(System.out::println);
        
        // Demonstrating compareTo() consistency
        Score s1 = new Score("Test", 100);
        Score s2 = new Score("Test", 100);
        
        System.out.println("\ncompareTo() result: " + s1.compareTo(s2));
        System.out.println("equals() result: " + s1.equals(s2));
        System.out.println("Consistent: " + ((s1.compareTo(s2) == 0) == s1.equals(s2)));
    }
}
```

---

## üìä Detailed Comparison Table

| Feature | Comparable | Comparator |
|---------|-----------|------------|
| **Interface** | java.lang.Comparable<T> | java.util.Comparator<T> |
| **Method** | int compareTo(T o) | int compare(T o1, T o2) |
| **Implementation** | Inside the class | Outside the class |
| **Sorting logic** | Natural ordering (one way) | Custom ordering (multiple ways) |
| **Modifies class** | Yes | No |
| **Flexibility** | Less (only one way) | More (multiple ways) |
| **Sort call** | Collections.sort(list) | Collections.sort(list, comparator) |
| **TreeSet/TreeMap** | new TreeSet<>() | new TreeSet<>(comparator) |
| **Use case** | Default sorting | Multiple sorting criteria |
| **Examples** | String, Integer, Date | Custom comparators |

---

## üìä Return Values

### compareTo(T o) / compare(T o1, T o2)

| Return Value | Meaning |
|--------------|---------|
| **Negative (<0)** | this < other (or o1 < o2) |
| **Zero (0)** | this == other (or o1 == o2) |
| **Positive (>0)** | this > other (or o1 > o2) |

---

## üí° Best Practices

1. ‚úÖ **Use Comparable for natural ordering**
   ```java
   class Student implements Comparable<Student> {
       public int compareTo(Student other) {
           return this.id - other.id;  // Natural order by ID
       }
   }
   ```

2. ‚úÖ **Use Comparator for custom/multiple orderings**
   ```java
   Comparator<Student> byName = Comparator.comparing(Student::getName);
   Comparator<Student> byGpa = Comparator.comparingDouble(Student::getGpa);
   ```

3. ‚úÖ **Use wrapper compare methods to avoid overflow**
   ```java
   return Integer.compare(this.value, other.value);  // Good
   // return this.value - other.value;  // Bad: overflow risk
   ```

4. ‚úÖ **Keep compareTo() consistent with equals()**
   ```java
   (x.compareTo(y) == 0) == x.equals(y)  // Should be true
   ```

5. ‚úÖ **Use Comparator factory methods (Java 8+)**
   ```java
   list.sort(Comparator.comparing(Person::getName)
                       .thenComparingInt(Person::getAge));
   ```

6. ‚úÖ **Handle null values**
   ```java
   Comparator<String> nullSafe = Comparator.nullsFirst(Comparator.naturalOrder());
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class ComparatorPitfalls {
    public static void main(String[] args) {
        // 1. Overflow in subtraction
        class BadComparison implements Comparable<BadComparison> {
            int value;
            public int compareTo(BadComparison other) {
                return this.value - other.value;  // Bad: can overflow!
            }
        }
        
        // Good: Use wrapper methods
        class GoodComparison implements Comparable<GoodComparison> {
            int value;
            public int compareTo(GoodComparison other) {
                return Integer.compare(this.value, other.value);  // Safe
            }
        }
        
        // 2. Inconsistent with equals()
        // If compareTo() returns 0, equals() should return true
        
        // 3. Not handling null in Comparator
        List<String> list = new ArrayList<>(Arrays.asList("A", null, "B"));
        // list.sort(Comparator.naturalOrder());  // NullPointerException!
        list.sort(Comparator.nullsLast(Comparator.naturalOrder()));  // Safe
        System.out.println("Null-safe sort: " + list);
        
        // 4. Modifying objects during sorting
        // Don't modify fields used in comparison during sort!
        
        System.out.println("All pitfalls demonstrated!");
    }
}
```

---

## üéØ Interview Questions

1. **What is the difference between Comparable and Comparator?**
2. **Which package do Comparable and Comparator belong to?**
3. **What methods do they provide?**
4. **Can a class implement both Comparable and Comparator?**
5. **How to sort in descending order?**
6. **What is natural ordering?**
7. **Can we have multiple Comparators for a class?**
8. **What is the return type of compareTo() and compare()?**
9. **How to sort by multiple fields?**
10. **What is Comparator.comparing()?**
11. **Difference between thenComparing() and thenComparingInt()?**
12. **How to handle null values in sorting?**
13. **Should compareTo() be consistent with equals()?**
14. **What is the risk of using subtraction in compareTo()?**
15. **How does TreeSet use Comparable/Comparator?**

---

## üìö Next Topics

- [Fail-Fast vs Fail-Safe](06.%20Fail-Fast%20vs%20Fail-Safe.md)
- [ArrayList](../02.%20List%20Interface/02.%20ArrayList.md)
- [TreeSet](../03.%20Set%20Interface/04.%20TreeSet.md)
- [TreeMap](../05.%20Map%20Interface/05.%20TreeMap.md)
- [Sorting & Searching](../08.%20Sorting%20%26%20Searching/01.%20Comparable%20Interface.md)
