# ‚ö° Fail-Fast vs Fail-Safe

## üìñ Overview

**Fail-Fast** and **Fail-Safe** are two iterator behaviors when a collection is modified during iteration:
- **Fail-Fast**: Immediately throws `ConcurrentModificationException` if collection is modified during iteration
- **Fail-Safe**: Creates a copy of collection, iterates over copy, no exception thrown

---

## üéØ Key Differences

| Aspect | Fail-Fast | Fail-Safe |
|--------|-----------|-----------|
| **Behavior** | Throws ConcurrentModificationException | No exception thrown |
| **Mechanism** | Uses modCount to detect changes | Works on cloned copy |
| **Memory** | Efficient (no extra memory) | Requires extra memory for copy |
| **Performance** | Faster | Slower (due to copying) |
| **Reflects changes** | Yes (if detected) | No (works on snapshot) |
| **Collections** | ArrayList, HashMap, HashSet | CopyOnWriteArrayList, ConcurrentHashMap |
| **Package** | java.util.* | java.util.concurrent.* |
| **Thread-safe** | No | Yes |
| **Use case** | Single-threaded | Multi-threaded |

---

## üíª Example 1: Fail-Fast Behavior (ArrayList)

```java
import java.util.*;

public class FailFastDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        System.out.println("Original list: " + list);
        System.out.println("\n=== Fail-Fast Behavior ===");
        
        try {
            // Using enhanced for-loop
            for (String item : list) {
                System.out.println("Current: " + item);
                if (item.equals("C")) {
                    list.remove(item);  // Modifying during iteration
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("\nConcurrentModificationException caught!");
            System.out.println("Cannot modify collection during iteration");
        }
        
        System.out.println("\n=== Correct Way: Use Iterator.remove() ===");
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        Iterator<String> iterator = list.iterator();
        
        while (iterator.hasNext()) {
            String item = iterator.next();
            System.out.println("Current: " + item);
            if (item.equals("C")) {
                iterator.remove();  // Safe removal
                System.out.println("Removed: " + item);
            }
        }
        System.out.println("Final list: " + list);
    }
}
```

**Output:**
```
Original list: [A, B, C, D, E]

=== Fail-Fast Behavior ===
Current: A
Current: B
Current: C

ConcurrentModificationException caught!
Cannot modify collection during iteration

=== Correct Way: Use Iterator.remove() ===
Current: A
Current: B
Current: C
Removed: C
Current: D
Current: E
Final list: [A, B, D, E]
```

---

## üíª Example 2: Fail-Safe Behavior (CopyOnWriteArrayList)

```java
import java.util.*;
import java.util.concurrent.*;

public class FailSafeDemo {
    public static void main(String[] args) {
        // Fail-safe collection
        List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        System.out.println("Original list: " + list);
        System.out.println("\n=== Fail-Safe Behavior ===");
        
        // No exception thrown!
        for (String item : list) {
            System.out.println("Current: " + item);
            if (item.equals("C")) {
                list.remove(item);  // Safe, but iterator won't see the change
                System.out.println("Removed: " + item);
            }
        }
        
        System.out.println("\nIterator completed without exception");
        System.out.println("Final list: " + list);
        
        System.out.println("\n=== Demonstrating Snapshot Behavior ===");
        list = new CopyOnWriteArrayList<>(Arrays.asList("1", "2", "3", "4", "5"));
        
        Iterator<String> iterator = list.iterator();
        
        // Add element after creating iterator
        list.add("6");
        System.out.println("Added '6' to list");
        
        System.out.println("\nIterating (iterator created before adding '6'):");
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        
        System.out.println("\n\nActual list: " + list);
        System.out.println("Iterator works on snapshot, doesn't see '6'");
    }
}
```

**Output:**
```
Original list: [A, B, C, D, E]

=== Fail-Safe Behavior ===
Current: A
Current: B
Current: C
Removed: C
Current: D
Current: E

Iterator completed without exception
Final list: [A, B, D, E]

=== Demonstrating Snapshot Behavior ===
Added '6' to list

Iterating (iterator created before adding '6'):
1 2 3 4 5 

Actual list: [1, 2, 3, 4, 5, 6]
Iterator works on snapshot, doesn't see '6'
```

---

## üíª Example 3: Fail-Fast with Different Collections

```java
import java.util.*;

public class FailFastCollectionsDemo {
    public static void main(String[] args) {
        // 1. ArrayList - Fail-Fast
        System.out.println("=== ArrayList (Fail-Fast) ===");
        testFailFast(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5)));
        
        // 2. HashSet - Fail-Fast
        System.out.println("\n=== HashSet (Fail-Fast) ===");
        testFailFast(new HashSet<>(Arrays.asList(1, 2, 3, 4, 5)));
        
        // 3. HashMap - Fail-Fast
        System.out.println("\n=== HashMap (Fail-Fast) ===");
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");
        
        try {
            for (Integer key : map.keySet()) {
                System.out.println("Key: " + key);
                if (key == 2) {
                    map.put(4, "D");  // Structural modification
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException in HashMap!");
        }
        
        // 4. LinkedList - Fail-Fast
        System.out.println("\n=== LinkedList (Fail-Fast) ===");
        testFailFast(new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5)));
    }
    
    static void testFailFast(Collection<Integer> collection) {
        try {
            for (Integer num : collection) {
                System.out.print(num + " ");
                if (num == 3) {
                    collection.remove(num);  // Throws exception
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("\nConcurrentModificationException caught!");
        }
    }
}
```

---

## üíª Example 4: Fail-Safe Collections

```java
import java.util.*;
import java.util.concurrent.*;

public class FailSafeCollectionsDemo {
    public static void main(String[] args) {
        // 1. CopyOnWriteArrayList - Fail-Safe
        System.out.println("=== CopyOnWriteArrayList (Fail-Safe) ===");
        List<Integer> cowList = new CopyOnWriteArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        for (Integer num : cowList) {
            System.out.print(num + " ");
            if (num == 3) {
                cowList.remove(num);  // No exception
            }
        }
        System.out.println("\nNo exception! Final list: " + cowList);
        
        // 2. CopyOnWriteArraySet - Fail-Safe
        System.out.println("\n=== CopyOnWriteArraySet (Fail-Safe) ===");
        Set<Integer> cowSet = new CopyOnWriteArraySet<>(Arrays.asList(1, 2, 3, 4, 5));
        
        for (Integer num : cowSet) {
            System.out.print(num + " ");
            if (num == 3) {
                cowSet.remove(num);  // No exception
            }
        }
        System.out.println("\nNo exception! Final set: " + cowSet);
        
        // 3. ConcurrentHashMap - Fail-Safe (weakly consistent)
        System.out.println("\n=== ConcurrentHashMap (Fail-Safe) ===");
        Map<Integer, String> concurrentMap = new ConcurrentHashMap<>();
        concurrentMap.put(1, "A");
        concurrentMap.put(2, "B");
        concurrentMap.put(3, "C");
        
        for (Integer key : concurrentMap.keySet()) {
            System.out.println("Key: " + key + ", Value: " + concurrentMap.get(key));
            if (key == 2) {
                concurrentMap.put(4, "D");  // No exception
            }
        }
        System.out.println("No exception! Final map: " + concurrentMap);
    }
}
```

---

## üíª Example 5: modCount Mechanism (Fail-Fast)

```java
import java.util.*;
import java.lang.reflect.*;

public class ModCountDemo {
    public static void main(String[] args) throws Exception {
        ArrayList<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        
        // Access modCount using reflection
        Field modCountField = ArrayList.class.getDeclaredField("modCount");
        modCountField.setAccessible(true);
        
        System.out.println("Initial modCount: " + modCountField.get(list));
        
        list.add("D");
        System.out.println("After add(): " + modCountField.get(list));
        
        list.remove("B");
        System.out.println("After remove(): " + modCountField.get(list));
        
        list.set(0, "X");
        System.out.println("After set(): " + modCountField.get(list));
        
        System.out.println("\n=== How Fail-Fast Works ===");
        System.out.println("1. Iterator stores expectedModCount = modCount when created");
        System.out.println("2. Before each next(), checks: expectedModCount == modCount");
        System.out.println("3. If not equal, throws ConcurrentModificationException");
        
        // Demonstrate fail-fast
        Iterator<String> iterator = list.iterator();
        int expectedModCount = (Integer) modCountField.get(list);
        System.out.println("\nIterator created, expectedModCount: " + expectedModCount);
        
        iterator.next();  // First element
        System.out.println("First next() successful");
        
        list.add("Y");  // Modifies modCount
        System.out.println("Added element, modCount now: " + modCountField.get(list));
        
        try {
            iterator.next();  // expectedModCount != modCount
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException: expectedModCount != modCount");
        }
    }
}
```

---

## üíª Example 6: Thread-Safety Comparison

```java
import java.util.*;
import java.util.concurrent.*;

public class ThreadSafetyDemo {
    public static void main(String[] args) throws InterruptedException {
        // Fail-Fast (not thread-safe)
        System.out.println("=== ArrayList (Fail-Fast, Not Thread-Safe) ===");
        List<Integer> arrayList = new ArrayList<>();
        testConcurrent(arrayList);
        
        // Fail-Safe (thread-safe)
        System.out.println("\n=== CopyOnWriteArrayList (Fail-Safe, Thread-Safe) ===");
        List<Integer> cowList = new CopyOnWriteArrayList<>();
        testConcurrent(cowList);
    }
    
    static void testConcurrent(List<Integer> list) throws InterruptedException {
        // Writer thread
        Thread writer = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // Reader thread
        Thread reader = new Thread(() -> {
            try {
                Thread.sleep(10);  // Let writer start first
                
                int count = 0;
                for (Integer num : list) {  // Iterate while writer is modifying
                    count++;
                    Thread.sleep(1);
                }
                System.out.println("Successfully read " + count + " elements");
            } catch (ConcurrentModificationException e) {
                System.out.println("ConcurrentModificationException in reader!");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        writer.start();
        reader.start();
        
        writer.join();
        reader.join();
        
        System.out.println("Final list size: " + list.size());
    }
}
```

---

## üíª Example 7: Performance Comparison

```java
import java.util.*;
import java.util.concurrent.*;

public class PerformanceComparisonDemo {
    public static void main(String[] args) {
        int size = 10000;
        
        // 1. ArrayList (Fail-Fast) - Read performance
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        
        long start = System.nanoTime();
        for (Integer num : arrayList) {
            // Read operation
        }
        long end = System.nanoTime();
        System.out.println("ArrayList read time: " + (end - start) + " ns");
        
        // 2. CopyOnWriteArrayList (Fail-Safe) - Read performance
        List<Integer> cowList = new CopyOnWriteArrayList<>();
        for (int i = 0; i < size; i++) {
            cowList.add(i);
        }
        
        start = System.nanoTime();
        for (Integer num : cowList) {
            // Read operation
        }
        end = System.nanoTime();
        System.out.println("CopyOnWriteArrayList read time: " + (end - start) + " ns");
        
        System.out.println("\n=== Write Performance ===");
        
        // ArrayList write
        arrayList.clear();
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            arrayList.add(i);
        }
        end = System.nanoTime();
        System.out.println("ArrayList write time: " + (end - start) + " ns");
        
        // CopyOnWriteArrayList write (creates copy on each write)
        cowList.clear();
        start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            cowList.add(i);
        }
        end = System.nanoTime();
        System.out.println("CopyOnWriteArrayList write time: " + (end - start) + " ns");
        
        System.out.println("\nConclusion:");
        System.out.println("- Fail-Fast: Fast reads AND writes");
        System.out.println("- Fail-Safe: Fast reads, SLOW writes (copies entire array)");
    }
}
```

---

## üíª Example 8: When to Use Which

```java
import java.util.*;
import java.util.concurrent.*;

public class WhenToUseDemo {
    public static void main(String[] args) {
        System.out.println("=== Use Fail-Fast (ArrayList, HashMap) ===");
        System.out.println("‚úì Single-threaded applications");
        System.out.println("‚úì When you want to detect concurrent modifications");
        System.out.println("‚úì When performance is critical");
        System.out.println("‚úì When memory usage should be minimal");
        System.out.println("‚úì Example: Simple desktop applications, batch processing");
        
        // Example: Single-threaded processing
        List<String> tasks = new ArrayList<>(Arrays.asList("Task1", "Task2", "Task3"));
        for (String task : tasks) {
            System.out.println("Processing: " + task);
            // Process task
        }
        
        System.out.println("\n=== Use Fail-Safe (CopyOnWriteArrayList, ConcurrentHashMap) ===");
        System.out.println("‚úì Multi-threaded applications");
        System.out.println("‚úì When iteration happens more frequently than modification");
        System.out.println("‚úì When you need thread-safe iteration");
        System.out.println("‚úì When you can afford extra memory");
        System.out.println("‚úì Example: Event listeners, observer patterns, caching");
        
        // Example: Event listeners (read-heavy)
        List<EventListener> listeners = new CopyOnWriteArrayList<>();
        listeners.add(() -> System.out.println("Listener 1 executed"));
        listeners.add(() -> System.out.println("Listener 2 executed"));
        
        // Notify all listeners (thread-safe iteration)
        listeners.forEach(EventListener::onEvent);
        
        System.out.println("\n=== Decision Guide ===");
        System.out.println("Use Fail-Fast if:");
        System.out.println("  - Single-threaded OR externally synchronized");
        System.out.println("  - Performance matters");
        System.out.println("  - Memory is limited");
        System.out.println("\nUse Fail-Safe if:");
        System.out.println("  - Multi-threaded without external synchronization");
        System.out.println("  - Reads >> Writes");
        System.out.println("  - Need consistent iteration even during modifications");
    }
    
    interface EventListener {
        void onEvent();
    }
}
```

---

## üìä Collection Types Summary

### Fail-Fast Collections (java.util.*)
- ArrayList
- LinkedList
- HashMap
- HashSet
- LinkedHashMap
- LinkedHashSet
- TreeMap
- TreeSet
- Vector (synchronized but still fail-fast)
- Hashtable (synchronized but still fail-fast)

### Fail-Safe Collections (java.util.concurrent.*)
- CopyOnWriteArrayList
- CopyOnWriteArraySet
- ConcurrentHashMap
- ConcurrentLinkedQueue
- ConcurrentLinkedDeque
- ConcurrentSkipListMap
- ConcurrentSkipListSet

---

## üìä Detailed Comparison

| Feature | Fail-Fast | Fail-Safe |
|---------|-----------|-----------|
| **Exception** | ConcurrentModificationException | No exception |
| **Detection mechanism** | modCount field | Cloned copy / Segment locking |
| **Memory overhead** | Low | High (copy or segments) |
| **Performance (read)** | Fast | Fast |
| **Performance (write)** | Fast | Slow (CopyOnWrite) / Moderate (Concurrent) |
| **Iteration consistency** | May see changes | Snapshot / Weakly consistent |
| **Thread-safety** | No | Yes |
| **Best for** | Single-threaded | Multi-threaded |
| **Write frequency** | Any | Low (CopyOnWrite) / Any (Concurrent) |
| **Read frequency** | Any | High (especially CopyOnWrite) |

---

## üí° Best Practices

1. ‚úÖ **Use fail-fast collections for single-threaded apps**
   ```java
   List<String> list = new ArrayList<>();  // Fast and efficient
   ```

2. ‚úÖ **Use fail-safe collections for concurrent access**
   ```java
   List<String> list = new CopyOnWriteArrayList<>();  // Thread-safe
   ```

3. ‚úÖ **Use Iterator.remove() for fail-fast collections**
   ```java
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       if (condition) it.remove();  // Safe
   }
   ```

4. ‚úÖ **Choose CopyOnWriteArrayList for read-heavy scenarios**
   ```java
   List<EventListener> listeners = new CopyOnWriteArrayList<>();  // Many reads, few writes
   ```

5. ‚úÖ **Choose ConcurrentHashMap for balanced read/write**
   ```java
   Map<String, Object> cache = new ConcurrentHashMap<>();  // Better for frequent writes
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;
import java.util.concurrent.*;

public class CommonPitfalls {
    public static void main(String[] args) {
        // 1. Assuming Collections.synchronizedList is fail-safe
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        syncList.add("A");
        syncList.add("B");
        
        // Still need manual synchronization for iteration!
        synchronized (syncList) {
            for (String item : syncList) {
                // Safe only inside synchronized block
            }
        }
        
        // 2. Using CopyOnWriteArrayList for write-heavy scenarios
        List<Integer> cowList = new CopyOnWriteArrayList<>();
        // Bad: Too many writes, very slow!
        for (int i = 0; i < 10000; i++) {
            cowList.add(i);  // Creates copy each time!
        }
        
        // 3. Expecting fail-safe to reflect immediate changes
        cowList = new CopyOnWriteArrayList<>(Arrays.asList(1, 2, 3));
        Iterator<Integer> it = cowList.iterator();
        cowList.add(4);  // Iterator won't see this
        
        while (it.hasNext()) {
            System.out.print(it.next() + " ");  // Prints: 1 2 3 (not 4)
        }
        
        System.out.println("\n\n4. Not using Iterator.remove() for fail-fast");
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        try {
            for (String item : list) {
                list.remove(item);  // Wrong!
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("ConcurrentModificationException caught!");
        }
    }
}
```

---

## üéØ Interview Questions

1. **What is the difference between fail-fast and fail-safe iterators?**
2. **Which collections are fail-fast and which are fail-safe?**
3. **What is ConcurrentModificationException?**
4. **How does fail-fast iterator detect modifications?**
5. **What is modCount?**
6. **Can we avoid ConcurrentModificationException?**
7. **Is CopyOnWriteArrayList always better than ArrayList?**
8. **What is the performance impact of fail-safe collections?**
9. **How does CopyOnWriteArrayList work internally?**
10. **Is synchronized collection fail-safe?**
11. **Can fail-safe iterator throw ConcurrentModificationException?**
12. **When should we use fail-fast vs fail-safe?**
13. **What is weakly consistent iterator?**
14. **How is ConcurrentHashMap different from CopyOnWriteArrayList?**
15. **What happens if we modify collection using Iterator.remove()?**

---

## üìö Next Topics

- [ArrayList](../02.%20List%20Interface/02.%20ArrayList.md)
- [CopyOnWriteArrayList](../02.%20List%20Interface/07.%20CopyOnWriteArrayList.md)
- [HashMap](../05.%20Map%20Interface/02.%20HashMap.md)
- [ConcurrentHashMap](../06.%20Concurrent%20Collections/01.%20ConcurrentHashMap.md)
- [Thread Safety](../12.%20Performance%20%26%20Best%20Practices/06.%20Thread%20Safety.md)
