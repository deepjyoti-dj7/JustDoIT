# üîÑ Collection vs Collections

## üìñ Overview

**Collection** and **Collections** are two different entities in Java that are often confused:
- **Collection** is an **interface** (singular) - the root of the collection hierarchy
- **Collections** is a **utility class** (plural) - provides static methods for collection operations

---

## üéØ Key Differences

| Aspect | Collection (Interface) | Collections (Class) |
|--------|----------------------|---------------------|
| **Type** | Interface | Utility Class |
| **Package** | java.util.Collection | java.util.Collections |
| **Purpose** | Represents a group of objects | Provides utility methods for collections |
| **Methods** | Instance methods (add, remove, size, etc.) | Static methods (sort, reverse, shuffle, etc.) |
| **Instantiation** | Cannot be instantiated directly | Cannot be instantiated (all methods are static) |
| **Usage** | Implemented by List, Set, Queue | Used to operate on collections |
| **Example** | Collection<String> c = new ArrayList<>(); | Collections.sort(list); |

---

## üíª Example 1: Collection Interface

```java
import java.util.*;

public class CollectionInterfaceDemo {
    public static void main(String[] args) {
        // Collection is an interface
        // Cannot instantiate: Collection<String> c = new Collection<>();  // Error!
        
        // Must use implementing classes
        Collection<String> list = new ArrayList<>();
        Collection<String> set = new HashSet<>();
        Collection<String> queue = new LinkedList<>();
        
        // Common Collection interface methods
        System.out.println("=== Collection Interface Methods ===");
        
        list.add("Java");
        list.add("Python");
        list.add("JavaScript");
        
        System.out.println("Collection: " + list);
        System.out.println("Size: " + list.size());
        System.out.println("Is empty: " + list.isEmpty());
        System.out.println("Contains 'Java': " + list.contains("Java"));
        
        list.remove("Python");
        System.out.println("After removal: " + list);
        
        // Bulk operations
        Collection<String> languages = new ArrayList<>();
        languages.add("C++");
        languages.add("Ruby");
        
        list.addAll(languages);
        System.out.println("After addAll: " + list);
        
        // Clear all elements
        list.clear();
        System.out.println("After clear: " + list + " (empty: " + list.isEmpty() + ")");
    }
}
```

**Output:**
```
=== Collection Interface Methods ===
Collection: [Java, Python, JavaScript]
Size: 3
Is empty: false
Contains 'Java': true
After removal: [Java, JavaScript]
After addAll: [Java, JavaScript, C++, Ruby]
After clear: [] (empty: true)
```

---

## üíª Example 2: Collections Utility Class

```java
import java.util.*;

public class CollectionsClassDemo {
    public static void main(String[] args) {
        // Collections is a utility class with static methods
        // Cannot instantiate: Collections c = new Collections();  // Error!
        
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9, 3));
        System.out.println("Original: " + numbers);
        
        // 1. Sort
        Collections.sort(numbers);
        System.out.println("Sorted: " + numbers);
        
        // 2. Reverse
        Collections.reverse(numbers);
        System.out.println("Reversed: " + numbers);
        
        // 3. Shuffle
        Collections.shuffle(numbers);
        System.out.println("Shuffled: " + numbers);
        
        // 4. Max and Min
        int max = Collections.max(numbers);
        int min = Collections.min(numbers);
        System.out.println("Max: " + max + ", Min: " + min);
        
        // 5. Frequency
        List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");
        int freq = Collections.frequency(words, "apple");
        System.out.println("\nFrequency of 'apple': " + freq);
        
        // 6. Binary Search (on sorted list)
        List<Integer> sorted = new ArrayList<>(Arrays.asList(1, 3, 5, 7, 9));
        int index = Collections.binarySearch(sorted, 5);
        System.out.println("Index of 5: " + index);
        
        // 7. Fill
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
        Collections.fill(list, "X");
        System.out.println("After fill: " + list);
        
        // 8. Copy
        List<String> source = Arrays.asList("1", "2", "3");
        List<String> dest = new ArrayList<>(Arrays.asList("A", "B", "C"));
        Collections.copy(dest, source);
        System.out.println("After copy: " + dest);
    }
}
```

**Output:**
```
Original: [5, 2, 8, 1, 9, 3]
Sorted: [1, 2, 3, 5, 8, 9]
Reversed: [9, 8, 5, 3, 2, 1]
Shuffled: [3, 1, 9, 2, 8, 5]  // Random order
Max: 9, Min: 1

Frequency of 'apple': 3
Index of 5: 2
After fill: [X, X, X, X]
After copy: [1, 2, 3]
```

---

## üíª Example 3: Collection Interface Methods

```java
import java.util.*;

public class CollectionMethodsDemo {
    public static void main(String[] args) {
        Collection<String> collection = new ArrayList<>();
        
        // 1. add() - Add single element
        collection.add("Java");
        collection.add("Python");
        System.out.println("After add: " + collection);
        
        // 2. addAll() - Add multiple elements
        Collection<String> more = Arrays.asList("C++", "Ruby");
        collection.addAll(more);
        System.out.println("After addAll: " + collection);
        
        // 3. remove() - Remove single element
        collection.remove("Python");
        System.out.println("After remove: " + collection);
        
        // 4. removeAll() - Remove all matching elements
        collection.removeAll(Arrays.asList("C++", "Ruby"));
        System.out.println("After removeAll: " + collection);
        
        // 5. retainAll() - Keep only matching elements
        collection.addAll(Arrays.asList("Go", "Rust", "Swift"));
        collection.retainAll(Arrays.asList("Java", "Go", "TypeScript"));
        System.out.println("After retainAll: " + collection);
        
        // 6. contains() - Check if element exists
        System.out.println("Contains 'Java': " + collection.contains("Java"));
        
        // 7. containsAll() - Check if all elements exist
        System.out.println("Contains all [Java, Go]: " + 
                          collection.containsAll(Arrays.asList("Java", "Go")));
        
        // 8. size() - Number of elements
        System.out.println("Size: " + collection.size());
        
        // 9. isEmpty() - Check if empty
        System.out.println("Is empty: " + collection.isEmpty());
        
        // 10. clear() - Remove all elements
        collection.clear();
        System.out.println("After clear, is empty: " + collection.isEmpty());
        
        // 11. toArray() - Convert to array
        Collection<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Object[] array1 = numbers.toArray();
        Integer[] array2 = numbers.toArray(new Integer[0]);
        System.out.println("toArray(): " + Arrays.toString(array1));
        System.out.println("toArray(T[]): " + Arrays.toString(array2));
    }
}
```

---

## üíª Example 4: Collections Class Methods

```java
import java.util.*;

public class CollectionsMethodsDemo {
    public static void main(String[] args) {
        // Sorting methods
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9));
        
        // 1. sort() - Natural order
        Collections.sort(numbers);
        System.out.println("Sorted: " + numbers);
        
        // 2. sort() with Comparator - Reverse order
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("Reverse sorted: " + numbers);
        
        // 3. reverse() - Reverse list
        Collections.reverse(numbers);
        System.out.println("Reversed: " + numbers);
        
        // 4. shuffle() - Random order
        Collections.shuffle(numbers);
        System.out.println("Shuffled: " + numbers);
        
        // Search methods
        Collections.sort(numbers);
        
        // 5. binarySearch() - Must be sorted first
        int index = Collections.binarySearch(numbers, 5);
        System.out.println("\nBinary search for 5: " + index);
        
        // 6. max() - Maximum element
        int max = Collections.max(numbers);
        System.out.println("Max: " + max);
        
        // 7. min() - Minimum element
        int min = Collections.min(numbers);
        System.out.println("Min: " + min);
        
        // 8. frequency() - Count occurrences
        List<String> words = Arrays.asList("a", "b", "a", "c", "a");
        int freq = Collections.frequency(words, "a");
        System.out.println("\nFrequency of 'a': " + freq);
        
        // 9. disjoint() - Check if no common elements
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(4, 5, 6);
        List<Integer> list3 = Arrays.asList(3, 4, 5);
        System.out.println("list1 and list2 disjoint: " + Collections.disjoint(list1, list2));
        System.out.println("list1 and list3 disjoint: " + Collections.disjoint(list1, list3));
        
        // 10. fill() - Replace all elements
        List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
        Collections.fill(list, "X");
        System.out.println("\nAfter fill: " + list);
        
        // 11. replaceAll() - Replace matching elements
        list = new ArrayList<>(Arrays.asList("a", "b", "a", "c", "a"));
        Collections.replaceAll(list, "a", "Z");
        System.out.println("After replaceAll: " + list);
        
        // 12. rotate() - Rotate elements
        list = new ArrayList<>(Arrays.asList("a", "b", "c", "d", "e"));
        Collections.rotate(list, 2);
        System.out.println("After rotate(2): " + list);
        
        // 13. swap() - Swap two elements
        Collections.swap(list, 0, 4);
        System.out.println("After swap(0,4): " + list);
    }
}
```

---

## üíª Example 5: Synchronized Collections

```java
import java.util.*;

public class SynchronizedCollectionsDemo {
    public static void main(String[] args) {
        // Collections class provides synchronized wrappers
        
        // Regular (non-thread-safe) collections
        List<String> list = new ArrayList<>();
        Set<String> set = new HashSet<>();
        Map<String, Integer> map = new HashMap<>();
        
        // Make them thread-safe using Collections utility methods
        List<String> syncList = Collections.synchronizedList(list);
        Set<String> syncSet = Collections.synchronizedSet(set);
        Map<String, Integer> syncMap = Collections.synchronizedMap(map);
        
        // Use synchronized collections in multi-threaded environment
        syncList.add("Thread-safe");
        syncSet.add("Thread-safe");
        syncMap.put("Thread", 1);
        
        System.out.println("Synchronized List: " + syncList);
        System.out.println("Synchronized Set: " + syncSet);
        System.out.println("Synchronized Map: " + syncMap);
        
        // Note: When iterating, must manually synchronize
        synchronized (syncList) {
            for (String item : syncList) {
                System.out.println(item);
            }
        }
    }
}
```

---

## üíª Example 6: Unmodifiable Collections

```java
import java.util.*;

public class UnmodifiableCollectionsDemo {
    public static void main(String[] args) {
        // Collections class provides unmodifiable wrappers
        
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        Set<String> set = new HashSet<>(Arrays.asList("X", "Y", "Z"));
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);
        
        // Create unmodifiable views
        List<String> unmodList = Collections.unmodifiableList(list);
        Set<String> unmodSet = Collections.unmodifiableSet(set);
        Map<String, Integer> unmodMap = Collections.unmodifiableMap(map);
        
        // Can read
        System.out.println("Unmodifiable List: " + unmodList);
        System.out.println("Unmodifiable Set: " + unmodSet);
        System.out.println("Unmodifiable Map: " + unmodMap);
        
        // Cannot modify
        try {
            unmodList.add("D");
        } catch (UnsupportedOperationException e) {
            System.out.println("\nCannot add to unmodifiable list!");
        }
        
        try {
            unmodSet.remove("X");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot remove from unmodifiable set!");
        }
        
        try {
            unmodMap.put("Three", 3);
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot put in unmodifiable map!");
        }
        
        // But original collections can still be modified
        list.add("D");
        System.out.println("\nOriginal list modified: " + list);
        System.out.println("Unmodifiable view reflects changes: " + unmodList);
    }
}
```

---

## üíª Example 7: Empty and Singleton Collections

```java
import java.util.*;

public class EmptySingletonDemo {
    public static void main(String[] args) {
        // Empty collections (immutable)
        List<String> emptyList = Collections.emptyList();
        Set<String> emptySet = Collections.emptySet();
        Map<String, Integer> emptyMap = Collections.emptyMap();
        
        System.out.println("Empty List: " + emptyList);
        System.out.println("Empty Set: " + emptySet);
        System.out.println("Empty Map: " + emptyMap);
        
        // Singleton collections (immutable, single element)
        List<String> singletonList = Collections.singletonList("Only One");
        Set<String> singletonSet = Collections.singleton("Only One");
        Map<String, Integer> singletonMap = Collections.singletonMap("Key", 100);
        
        System.out.println("\nSingleton List: " + singletonList);
        System.out.println("Singleton Set: " + singletonSet);
        System.out.println("Singleton Map: " + singletonMap);
        
        // These are immutable
        try {
            singletonList.add("Two");
        } catch (UnsupportedOperationException e) {
            System.out.println("\nCannot modify singleton collections!");
        }
        
        // Use cases
        System.out.println("\n=== Use Cases ===");
        
        // 1. Default return values
        public List<String> getNames() {
            // Instead of returning null
            return Collections.emptyList();
        }
        
        // 2. Method parameters
        processItems(Collections.singletonList("OnlyThis"));
        
        // 3. Constant collections
        public static final List<String> CONSTANTS = 
            Collections.unmodifiableList(Arrays.asList("CONST1", "CONST2"));
    }
    
    static void processItems(List<String> items) {
        System.out.println("Processing: " + items);
    }
}
```

---

## üíª Example 8: Comparison Summary

```java
import java.util.*;

public class ComparisonSummaryDemo {
    public static void main(String[] args) {
        System.out.println("=== Collection (Interface) ===");
        
        // Collection interface - provides methods for implementations
        Collection<String> collection = new ArrayList<>();
        collection.add("Element");
        collection.remove("Element");
        System.out.println("Size: " + collection.size());
        System.out.println("Empty: " + collection.isEmpty());
        
        System.out.println("\n=== Collections (Utility Class) ===");
        
        // Collections class - provides algorithms for collections
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9));
        
        Collections.sort(numbers);
        System.out.println("Sorted: " + numbers);
        
        Collections.shuffle(numbers);
        System.out.println("Shuffled: " + numbers);
        
        int max = Collections.max(numbers);
        System.out.println("Max: " + max);
        
        // Collections class also provides wrappers
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        List<String> unmodList = Collections.unmodifiableList(Arrays.asList("A", "B"));
        List<String> emptyList = Collections.emptyList();
        
        System.out.println("\n=== Key Difference ===");
        System.out.println("Collection: Interface for data structure");
        System.out.println("Collections: Utility class for operations on collections");
    }
}
```

---

## üìä Detailed Comparison Table

| Feature | Collection | Collections |
|---------|-----------|-------------|
| **Nature** | Interface | Final utility class |
| **Implements** | Iterable | Nothing |
| **Extended by** | List, Set, Queue | Cannot be extended (final) |
| **Purpose** | Define contract for collections | Provide algorithms/utilities |
| **Methods** | Instance methods | Static methods |
| **Instantiation** | No (interface) | No (private constructor) |
| **Example methods** | add(), remove(), size(), contains() | sort(), reverse(), shuffle(), max() |
| **Thread-safety** | Depends on implementation | Provides synchronizedXxx() methods |
| **Immutability** | Depends on implementation | Provides unmodifiableXxx() methods |
| **When to use** | Declaring collection variables | Operating on collections |

---

## üìä Common Methods Comparison

### Collection Interface Methods
```java
boolean add(E e)
boolean remove(Object o)
int size()
boolean isEmpty()
boolean contains(Object o)
void clear()
Iterator<E> iterator()
Object[] toArray()
boolean addAll(Collection<? extends E> c)
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c)
boolean containsAll(Collection<?> c)
```

### Collections Class Methods
```java
static <T> void sort(List<T> list)
static <T> void reverse(List<T> list)
static <T> void shuffle(List<T> list)
static <T> T max(Collection<T> coll)
static <T> T min(Collection<T> coll)
static <T> int binarySearch(List<T> list, T key)
static <T> void fill(List<T> list, T obj)
static <T> void copy(List<T> dest, List<T> src)
static <T> List<T> synchronizedList(List<T> list)
static <T> List<T> unmodifiableList(List<T> list)
static <T> List<T> emptyList()
static <T> List<T> singletonList(T o)
```

---

## üí° Best Practices

1. ‚úÖ **Use Collection interface for method parameters** (more flexible)
   ```java
   public void process(Collection<String> items) { }  // Good
   public void process(ArrayList<String> items) { }   // Less flexible
   ```

2. ‚úÖ **Use Collections class for algorithms**
   ```java
   Collections.sort(list);      // Use utility method
   list.sort(null);            // Or use List's sort method (Java 8+)
   ```

3. ‚úÖ **Return empty collections instead of null**
   ```java
   return Collections.emptyList();  // Good
   return null;                      // Avoid - causes NullPointerException
   ```

4. ‚úÖ **Use Collections for thread-safety**
   ```java
   List<String> syncList = Collections.synchronizedList(new ArrayList<>());
   ```

5. ‚úÖ **Use Collections for immutability**
   ```java
   List<String> immutable = Collections.unmodifiableList(list);
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class CommonPitfalls {
    public static void main(String[] args) {
        // 1. Confusing Collection with Collections
        // Collection<String> c = new Collections<>();  // Error! Collections is a class
        // Collections<String> c = new ArrayList<>();   // Error! Collections is not generic
        
        Collection<String> c = new ArrayList<>();  // Correct
        Collections.sort((List<String>)c);         // Correct
        
        // 2. Trying to modify unmodifiable collections
        List<String> unmod = Collections.unmodifiableList(Arrays.asList("A", "B"));
        try {
            unmod.add("C");  // UnsupportedOperationException!
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot modify unmodifiable collection!");
        }
        
        // 3. Not synchronizing when iterating synchronized collections
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        syncList.add("A");
        
        // Wrong - not thread-safe!
        // for (String item : syncList) { }
        
        // Correct - manually synchronize
        synchronized (syncList) {
            for (String item : syncList) {
                System.out.println(item);
            }
        }
        
        // 4. Using binarySearch on unsorted list
        List<Integer> unsorted = Arrays.asList(5, 2, 8, 1);
        int index = Collections.binarySearch(unsorted, 2);
        System.out.println("Wrong result: " + index);  // Undefined behavior!
        
        Collections.sort(unsorted);
        index = Collections.binarySearch(unsorted, 2);
        System.out.println("Correct result: " + index);
    }
}
```

---

## üéØ Interview Questions

1. **What is the difference between Collection and Collections?**
2. **Is Collections a class or interface?**
3. **Can we instantiate Collection or Collections?**
4. **What are the main methods in the Collection interface?**
5. **What are the main methods in the Collections class?**
6. **How to make a collection thread-safe?**
7. **How to make a collection unmodifiable?**
8. **What is the difference between emptyList() and new ArrayList()?**
9. **What is a singleton collection?**
10. **Why use Collections.synchronizedList() instead of Vector?**
11. **Can we sort a Set using Collections.sort()?**
12. **What happens if we call add() on an unmodifiable collection?**
13. **How does Collections.binarySearch() work?**
14. **Difference between Collections.emptyList() and Arrays.asList()?**
15. **What is the purpose of Collections.reverseOrder()?**

---

## üìö Next Topics

- [Iterable & Iterator](04.%20Iterable%20%26%20Iterator.md)
- [Comparable vs Comparator](05.%20Comparable%20vs%20Comparator.md)
- [Collections Class](../07.%20Special%20Purpose%20Collections/01.%20Collections%20Class.md)
- [Synchronized Collections](../07.%20Special%20Purpose%20Collections/03.%20Synchronized%20Collections.md)
- [Unmodifiable Collections](../07.%20Special%20Purpose%20Collections/04.%20Unmodifiable%20Collections.md)
