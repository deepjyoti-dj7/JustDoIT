# ğŸ“Š Collection Hierarchy

## ğŸ“– Overview

The Java Collections Framework has a well-defined hierarchy of interfaces and classes. Understanding this hierarchy is crucial for choosing the right collection for your needs and understanding the relationships between different collection types.

---

## ğŸ¯ Complete Collection Hierarchy

```
                    java.lang.Iterable<E>
                            â†“
                    java.util.Collection<E>
                            â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â†“                  â†“                  â†“
    java.util.List     java.util.Set    java.util.Queue
         â†“                  â†“                  â†“
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â†“         â†“        â†“         â†“       â†“         â†“
ArrayList  LinkedList HashSet TreeSet PriorityQueue ArrayDeque
Vector              LinkedHashSet    LinkedList
Stack               SortedSet
                    NavigableSet
                    
    
    Separate Hierarchy (Map is NOT part of Collection):
    
         java.util.Map<K,V>
                â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”
         â†“      â†“      â†“
    HashMap TreeMap LinkedHashMap
    Hashtable    SortedMap
    WeakHashMap  NavigableMap
    IdentityHashMap
    EnumMap
```

---

## ğŸ’» Example 1: Iterable Interface (Root)

```java
import java.util.*;

public class IterableDemo {
    public static void main(String[] args) {
        // All collections implement Iterable
        // This allows them to be used in for-each loops
        
        List<String> list = Arrays.asList("A", "B", "C");
        Set<String> set = new HashSet<>(Arrays.asList("X", "Y", "Z"));
        Queue<String> queue = new LinkedList<>(Arrays.asList("1", "2", "3"));
        
        System.out.println("=== List (Iterable) ===");
        for (String item : list) {  // Possible because List extends Iterable
            System.out.print(item + " ");
        }
        
        System.out.println("\n\n=== Set (Iterable) ===");
        for (String item : set) {
            System.out.print(item + " ");
        }
        
        System.out.println("\n\n=== Queue (Iterable) ===");
        for (String item : queue) {
            System.out.print(item + " ");
        }
        
        // Using Iterator explicitly
        System.out.println("\n\n=== Using Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
    }
}
```

**Output:**
```
=== List (Iterable) ===
A B C 

=== Set (Iterable) ===
X Y Z 

=== Queue (Iterable) ===
1 2 3 

=== Using Iterator ===
A B C 
```

---

## ğŸ’» Example 2: Collection Interface (Common Methods)

```java
import java.util.*;

public class CollectionInterfaceDemo {
    public static void main(String[] args) {
        // All List, Set, Queue extend Collection
        // So they all have these common methods
        
        demonstrateCollection(new ArrayList<>(), "ArrayList");
        demonstrateCollection(new HashSet<>(), "HashSet");
        demonstrateCollection(new LinkedList<>(), "LinkedList");
    }
    
    static void demonstrateCollection(Collection<String> collection, String name) {
        System.out.println("=== " + name + " ===");
        
        // Common Collection methods
        collection.add("Java");
        collection.add("Python");
        collection.add("JavaScript");
        
        System.out.println("Size: " + collection.size());
        System.out.println("Contains Java: " + collection.contains("Java"));
        System.out.println("Is empty: " + collection.isEmpty());
        System.out.println("Elements: " + collection);
        
        collection.remove("Python");
        System.out.println("After removal: " + collection);
        System.out.println();
    }
}
```

---

## ğŸ’» Example 3: List Hierarchy

```java
import java.util.*;

public class ListHierarchyDemo {
    public static void main(String[] args) {
        // List interface implementations
        
        // 1. ArrayList - Dynamic array
        List<String> arrayList = new ArrayList<>();
        arrayList.add("A");
        arrayList.add("B");
        arrayList.add("C");
        System.out.println("ArrayList: " + arrayList);
        System.out.println("Get index 1: " + arrayList.get(1));
        
        // 2. LinkedList - Doubly-linked list
        List<String> linkedList = new LinkedList<>();
        linkedList.add("X");
        linkedList.add("Y");
        linkedList.add("Z");
        System.out.println("\nLinkedList: " + linkedList);
        
        // 3. Vector - Legacy synchronized list
        List<String> vector = new Vector<>();
        vector.add("1");
        vector.add("2");
        vector.add("3");
        System.out.println("\nVector: " + vector);
        
        // 4. Stack - LIFO (extends Vector)
        Stack<String> stack = new Stack<>();
        stack.push("First");
        stack.push("Second");
        stack.push("Third");
        System.out.println("\nStack: " + stack);
        System.out.println("Pop: " + stack.pop());
        System.out.println("After pop: " + stack);
        
        // All are Lists - have common methods
        System.out.println("\n=== Common List Methods ===");
        System.out.println("ArrayList size: " + arrayList.size());
        System.out.println("LinkedList size: " + linkedList.size());
        System.out.println("Vector size: " + vector.size());
    }
}
```

---

## ğŸ’» Example 4: Set Hierarchy

```java
import java.util.*;

public class SetHierarchyDemo {
    public static void main(String[] args) {
        // Set interface implementations - no duplicates
        
        // 1. HashSet - No order, fastest
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Banana");
        hashSet.add("Apple");
        hashSet.add("Cherry");
        hashSet.add("Apple");  // Duplicate ignored
        System.out.println("HashSet (no order): " + hashSet);
        
        // 2. LinkedHashSet - Insertion order maintained
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Banana");
        linkedHashSet.add("Apple");
        linkedHashSet.add("Cherry");
        linkedHashSet.add("Apple");  // Duplicate ignored
        System.out.println("\nLinkedHashSet (insertion order): " + linkedHashSet);
        
        // 3. TreeSet - Sorted order (NavigableSet â†’ SortedSet â†’ Set)
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("Banana");
        treeSet.add("Apple");
        treeSet.add("Cherry");
        treeSet.add("Apple");  // Duplicate ignored
        System.out.println("\nTreeSet (sorted): " + treeSet);
        
        // TreeSet specific methods (NavigableSet)
        NavigableSet<String> navigableSet = new TreeSet<>(treeSet);
        System.out.println("First: " + navigableSet.first());
        System.out.println("Last: " + navigableSet.last());
        System.out.println("Lower than Cherry: " + navigableSet.lower("Cherry"));
        System.out.println("Higher than Apple: " + navigableSet.higher("Apple"));
        
        // All are Sets - no duplicates
        System.out.println("\n=== All sets have unique elements ===");
        System.out.println("HashSet size: " + hashSet.size());
        System.out.println("LinkedHashSet size: " + linkedHashSet.size());
        System.out.println("TreeSet size: " + treeSet.size());
    }
}
```

---

## ğŸ’» Example 5: Queue Hierarchy

```java
import java.util.*;

public class QueueHierarchyDemo {
    public static void main(String[] args) {
        // Queue interface implementations - FIFO
        
        // 1. LinkedList (implements both List and Queue)
        Queue<String> linkedListQueue = new LinkedList<>();
        linkedListQueue.offer("First");
        linkedListQueue.offer("Second");
        linkedListQueue.offer("Third");
        System.out.println("LinkedList as Queue: " + linkedListQueue);
        System.out.println("Poll: " + linkedListQueue.poll());
        System.out.println("After poll: " + linkedListQueue);
        
        // 2. PriorityQueue - Natural ordering or comparator
        Queue<Integer> priorityQueue = new PriorityQueue<>();
        priorityQueue.offer(30);
        priorityQueue.offer(10);
        priorityQueue.offer(20);
        System.out.println("\nPriorityQueue: " + priorityQueue);
        System.out.println("Poll (smallest): " + priorityQueue.poll());
        System.out.println("After poll: " + priorityQueue);
        
        // 3. ArrayDeque - Double-ended queue (Deque extends Queue)
        Deque<String> arrayDeque = new ArrayDeque<>();
        arrayDeque.offerFirst("First");
        arrayDeque.offerLast("Last");
        arrayDeque.offerFirst("NewFirst");
        System.out.println("\nArrayDeque: " + arrayDeque);
        System.out.println("Poll first: " + arrayDeque.pollFirst());
        System.out.println("Poll last: " + arrayDeque.pollLast());
        System.out.println("After polls: " + arrayDeque);
        
        // Queue operations
        System.out.println("\n=== Queue Operations ===");
        Queue<String> queue = new LinkedList<>();
        queue.offer("A");
        queue.offer("B");
        System.out.println("Peek (don't remove): " + queue.peek());
        System.out.println("Queue still: " + queue);
        System.out.println("Poll (remove): " + queue.poll());
        System.out.println("Queue now: " + queue);
    }
}
```

---

## ğŸ’» Example 6: Map Hierarchy (Separate)

```java
import java.util.*;

public class MapHierarchyDemo {
    public static void main(String[] args) {
        // Map does NOT extend Collection interface
        // It's a separate hierarchy
        
        // 1. HashMap - No order, fastest
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("Java", 1);
        hashMap.put("Python", 2);
        hashMap.put("JavaScript", 3);
        System.out.println("HashMap (no order): " + hashMap);
        
        // 2. LinkedHashMap - Insertion order maintained
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("Java", 1);
        linkedHashMap.put("Python", 2);
        linkedHashMap.put("JavaScript", 3);
        System.out.println("\nLinkedHashMap (insertion order): " + linkedHashMap);
        
        // 3. TreeMap - Sorted by keys (NavigableMap â†’ SortedMap â†’ Map)
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("Java", 1);
        treeMap.put("Python", 2);
        treeMap.put("JavaScript", 3);
        System.out.println("\nTreeMap (sorted by key): " + treeMap);
        
        // 4. Hashtable - Legacy synchronized map
        Map<String, Integer> hashtable = new Hashtable<>();
        hashtable.put("A", 1);
        hashtable.put("B", 2);
        System.out.println("\nHashtable: " + hashtable);
        
        // TreeMap specific methods (NavigableMap)
        NavigableMap<String, Integer> navigableMap = new TreeMap<>(treeMap);
        System.out.println("\n=== NavigableMap Methods ===");
        System.out.println("First key: " + navigableMap.firstKey());
        System.out.println("Last key: " + navigableMap.lastKey());
        System.out.println("Lower key than 'Python': " + navigableMap.lowerKey("Python"));
        
        // Common Map methods
        System.out.println("\n=== Common Map Methods ===");
        System.out.println("HashMap size: " + hashMap.size());
        System.out.println("Get 'Java': " + hashMap.get("Java"));
        System.out.println("Contains key 'Python': " + hashMap.containsKey("Python"));
        System.out.println("Contains value 3: " + hashMap.containsValue(3));
    }
}
```

---

## ğŸ’» Example 7: Hierarchy Relationships

```java
import java.util.*;

public class HierarchyRelationshipsDemo {
    public static void main(String[] args) {
        // Understanding "is-a" relationships
        
        // ArrayList is-a List, is-a Collection, is-a Iterable
        ArrayList<String> arrayList = new ArrayList<>();
        List<String> list = arrayList;           // Upcasting
        Collection<String> collection = arrayList; // Upcasting
        Iterable<String> iterable = arrayList;    // Upcasting
        
        System.out.println("ArrayList is a List: " + (arrayList instanceof List));
        System.out.println("ArrayList is a Collection: " + (arrayList instanceof Collection));
        System.out.println("ArrayList is Iterable: " + (arrayList instanceof Iterable));
        
        // LinkedList is-a List AND Queue
        LinkedList<String> linkedList = new LinkedList<>();
        List<String> asList = linkedList;
        Queue<String> asQueue = linkedList;
        
        System.out.println("\nLinkedList is a List: " + (linkedList instanceof List));
        System.out.println("LinkedList is a Queue: " + (linkedList instanceof Queue));
        
        // TreeSet is-a Set, NavigableSet, SortedSet
        TreeSet<Integer> treeSet = new TreeSet<>();
        Set<Integer> asSet = treeSet;
        NavigableSet<Integer> asNavigableSet = treeSet;
        SortedSet<Integer> asSortedSet = treeSet;
        
        System.out.println("\nTreeSet is a Set: " + (treeSet instanceof Set));
        System.out.println("TreeSet is a NavigableSet: " + (treeSet instanceof NavigableSet));
        System.out.println("TreeSet is a SortedSet: " + (treeSet instanceof SortedSet));
        
        // Map is NOT a Collection!
        HashMap<String, Integer> hashMap = new HashMap<>();
        System.out.println("\nHashMap is a Map: " + (hashMap instanceof Map));
        System.out.println("HashMap is a Collection: " + (hashMap instanceof Collection));  // false!
    }
}
```

---

## ğŸ’» Example 8: Interface Capabilities

```java
import java.util.*;

public class InterfaceCapabilitiesDemo {
    public static void main(String[] args) {
        // List: Ordered, allows duplicates, index-based
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "A", "C"));
        System.out.println("List (ordered, duplicates): " + list);
        System.out.println("Element at index 1: " + list.get(1));
        
        // Set: No duplicates, no guaranteed order
        Set<String> set = new HashSet<>(Arrays.asList("A", "B", "A", "C"));
        System.out.println("\nSet (no duplicates): " + set);
        // set.get(0);  // No such method! Sets don't have index access
        
        // Queue: FIFO operations
        Queue<String> queue = new LinkedList<>(Arrays.asList("First", "Second", "Third"));
        System.out.println("\nQueue (FIFO): " + queue);
        System.out.println("Peek: " + queue.peek());
        System.out.println("Poll: " + queue.poll());
        System.out.println("After poll: " + queue);
        
        // Map: Key-value pairs
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);
        map.put("One", 10);  // Updates value for key "One"
        System.out.println("\nMap (key-value): " + map);
        System.out.println("Value for 'One': " + map.get("One"));
        
        // NavigableSet: Sorted set with navigation methods
        NavigableSet<Integer> navSet = new TreeSet<>(Arrays.asList(5, 2, 8, 1, 9));
        System.out.println("\nNavigableSet (sorted): " + navSet);
        System.out.println("Lower than 5: " + navSet.lower(5));
        System.out.println("Higher than 5: " + navSet.higher(5));
        System.out.println("Subset [2, 8): " + navSet.subSet(2, false, 8, false));
        
        // Deque: Double-ended queue
        Deque<String> deque = new ArrayDeque<>();
        deque.offerFirst("A");
        deque.offerLast("B");
        deque.offerFirst("C");
        System.out.println("\nDeque: " + deque);
        System.out.println("Poll first: " + deque.pollFirst());
        System.out.println("Poll last: " + deque.pollLast());
    }
}
```

---

## ğŸ“Š Complete Interface Hierarchy Table

| Interface | Extends | Ordered | Duplicates | Indexed | Null | Key Implementations |
|-----------|---------|---------|------------|---------|------|---------------------|
| **Iterable** | - | - | - | - | - | All collections |
| **Collection** | Iterable | Depends | Depends | No | Depends | All collections |
| **List** | Collection | Yes | Yes | Yes | Yes | ArrayList, LinkedList, Vector |
| **Set** | Collection | No* | No | No | Yes* | HashSet, LinkedHashSet, TreeSet |
| **SortedSet** | Set | Yes (sorted) | No | No | No | TreeSet |
| **NavigableSet** | SortedSet | Yes (sorted) | No | No | No | TreeSet |
| **Queue** | Collection | Yes | Yes | No | No* | LinkedList, PriorityQueue |
| **Deque** | Queue | Yes | Yes | No | No | ArrayDeque, LinkedList |
| **Map** | - | No* | Keys: No, Values: Yes | No | Yes* | HashMap, TreeMap, LinkedHashMap |
| **SortedMap** | Map | Yes (by keys) | Keys: No, Values: Yes | No | No | TreeMap |
| **NavigableMap** | SortedMap | Yes (by keys) | Keys: No, Values: Yes | No | No | TreeMap |

*Varies by implementation

---

## ğŸ“Š Implementation Hierarchy

```
List Implementations:
    ArrayList (dynamic array)
    LinkedList (doubly-linked list) *also implements Deque
    Vector (synchronized ArrayList)
        â””â”€â”€ Stack (LIFO)
    CopyOnWriteArrayList (thread-safe)

Set Implementations:
    HashSet (backed by HashMap)
        â””â”€â”€ LinkedHashSet (maintains insertion order)
    TreeSet (NavigableSet, SortedSet - Red-Black tree)
    EnumSet (specialized for enum types)
    CopyOnWriteArraySet (thread-safe)

Queue/Deque Implementations:
    PriorityQueue (heap)
    ArrayDeque (resizable array)
    LinkedList (also List implementation)
    PriorityBlockingQueue (thread-safe)
    LinkedBlockingQueue (thread-safe)
    LinkedBlockingDeque (thread-safe)

Map Implementations:
    HashMap (hash table)
        â””â”€â”€ LinkedHashMap (maintains insertion/access order)
    TreeMap (NavigableMap, SortedMap - Red-Black tree)
    Hashtable (legacy, synchronized)
    WeakHashMap (weak keys for garbage collection)
    IdentityHashMap (uses == instead of equals())
    EnumMap (specialized for enum keys)
    ConcurrentHashMap (thread-safe)
```

---

## ğŸ’¡ Best Practices

1. âœ… **Program to interfaces, not implementations**
   ```java
   List<String> list = new ArrayList<>();  // Good
   ArrayList<String> list = new ArrayList<>();  // Less flexible
   ```

2. âœ… **Choose interface based on needs**
   - Need index access? â†’ List
   - Need unique elements? â†’ Set
   - Need FIFO/LIFO? â†’ Queue/Deque
   - Need key-value pairs? â†’ Map

3. âœ… **Use most specific interface when needed**
   ```java
   NavigableSet<Integer> set = new TreeSet<>();  // Access to navigation methods
   ```

4. âœ… **Understand inheritance relationships**
   - TreeSet is-a NavigableSet is-a SortedSet is-a Set
   - LinkedList is-a List AND Queue

---

## âš ï¸ Common Pitfalls

```java
import java.util.*;

public class HierarchyPitfalls {
    public static void main(String[] args) {
        // 1. Map is NOT a Collection!
        Map<String, Integer> map = new HashMap<>();
        // Collection<String> col = map;  // Compile error!
        
        // But you can get Collection views
        Collection<Integer> values = map.values();
        Set<String> keys = map.keySet();
        
        // 2. Not all Lists support all operations
        List<String> fixedList = Arrays.asList("A", "B", "C");
        // fixedList.add("D");  // UnsupportedOperationException!
        
        // 3. TreeSet/TreeMap require comparable elements
        // TreeSet<MyClass> set = new TreeSet<>();  // May throw ClassCastException
        
        // 4. Some implementations don't allow null
        // TreeSet<String> treeSet = new TreeSet<>();
        // treeSet.add(null);  // NullPointerException!
        
        // But HashSet allows null
        Set<String> hashSet = new HashSet<>();
        hashSet.add(null);
        System.out.println("HashSet with null: " + hashSet);
        
        // 5. Stack is legacy, use Deque instead
        Deque<String> stack = new ArrayDeque<>();  // Better than Stack class
        stack.push("A");
        stack.push("B");
        System.out.println("Modern stack: " + stack);
    }
}
```

---

## ğŸ¯ Interview Questions

1. **Draw the Java Collections Framework hierarchy.**
2. **Why doesn't Map extend Collection?**
3. **What is the difference between Collection and Collections?**
4. **What interfaces does LinkedList implement?**
5. **What is the difference between Set and SortedSet?**
6. **What is NavigableSet? Give an example.**
7. **Which collection allows both List and Queue operations?**
8. **What is the root interface of the Collections Framework?**
9. **Difference between List and Set interfaces?**
10. **What is Deque? How is it different from Queue?**
11. **Which implementations are legacy?**
12. **Can TreeSet contain null elements?**
13. **What is the relationship between HashSet and HashMap?**
14. **Why use interface references instead of concrete classes?**
15. **What are the sub-interfaces of Map?**

---

## ğŸ“š Next Topics

- [Collection vs Collections](03.%20Collection%20vs%20Collections.md)
- [Iterable & Iterator](04.%20Iterable%20%26%20Iterator.md)
- [List Interface Basics](../02.%20List%20Interface/01.%20List%20Interface%20Basics.md)
- [Set Interface Basics](../03.%20Set%20Interface/01.%20Set%20Interface%20Basics.md)
- [Map Interface Basics](../05.%20Map%20Interface/01.%20Map%20Interface%20Basics.md)
