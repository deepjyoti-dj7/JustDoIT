# üì¶ Introduction to Collections

## üìñ Overview

The Java Collections Framework is a unified architecture for representing and manipulating collections of objects. It provides interfaces, implementations, and algorithms to store, retrieve, and manipulate groups of objects efficiently.

---

## üéØ What is a Collection?

A **Collection** is a group of objects represented as a single unit. It provides a way to store, retrieve, and manipulate data efficiently.

**Example**: A group of students, a list of books, a set of unique IDs, etc.

---

## üíª Example 1: Before Collections (Using Arrays)

```java
public class BeforeCollectionsDemo {
    public static void main(String[] args) {
        // Problems with arrays:
        // 1. Fixed size
        String[] fruits = new String[3];
        fruits[0] = "Apple";
        fruits[1] = "Banana";
        fruits[2] = "Cherry";

        // Cannot add more elements
        // fruits[3] = "Date";  // ArrayIndexOutOfBoundsException!

        // 2. No built-in methods
        // Manual search
        String searchFor = "Banana";
        boolean found = false;
        for (String fruit : fruits) {
            if (fruit.equals(searchFor)) {
                found = true;
                break;
            }
        }
        System.out.println("Found: " + found);

        // 3. Can contain duplicates
        String[] numbers = {"1", "2", "2", "3"};  // Duplicates allowed

        // 4. No type safety (before Java 5)
        Object[] mixed = new Object[3];
        mixed[0] = "String";
        mixed[1] = 123;
        mixed[2] = true;
        // Need casting and runtime errors possible
    }
}
```

---

## üíª Example 2: After Collections (Modern Approach)

```java
import java.util.*;

public class AfterCollectionsDemo {
    public static void main(String[] args) {
        // 1. Dynamic size
        List<String> fruits = new ArrayList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Date");      // Can add more!
        fruits.add("Elderberry");

        System.out.println("Fruits: " + fruits);
        System.out.println("Size: " + fruits.size());

        // 2. Built-in methods
        boolean found = fruits.contains("Banana");
        System.out.println("Contains Banana: " + found);

        fruits.remove("Cherry");
        System.out.println("After removal: " + fruits);

        // 3. No duplicates with Set
        Set<String> uniqueNumbers = new HashSet<>();
        uniqueNumbers.add("1");
        uniqueNumbers.add("2");
        uniqueNumbers.add("2");  // Duplicate ignored
        uniqueNumbers.add("3");
        System.out.println("Unique numbers: " + uniqueNumbers);  // [1, 2, 3]

        // 4. Type safety with generics
        List<Integer> numbers = new ArrayList<>();
        numbers.add(10);
        numbers.add(20);
        // numbers.add("30");  // Compile error! Type safe

        // 5. Powerful operations
        Collections.sort(fruits);
        System.out.println("Sorted: " + fruits);

        Collections.reverse(fruits);
        System.out.println("Reversed: " + fruits);
    }
}
```

---

## üíª Example 3: Collection Framework Architecture

```java
import java.util.*;

public class CollectionArchitectureDemo {
    public static void main(String[] args) {
        System.out.println("=== Collection Framework Hierarchy ===\n");

        // 1. List - Ordered, allows duplicates
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Apple");  // Duplicate allowed
        System.out.println("List (ArrayList): " + list);

        // 2. Set - Unordered, no duplicates
        Set<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Apple");  // Duplicate ignored
        System.out.println("Set (HashSet): " + set);

        // 3. Queue - FIFO order
        Queue<String> queue = new LinkedList<>();
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        System.out.println("Queue: " + queue);
        System.out.println("Poll: " + queue.poll());  // Removes First
        System.out.println("After poll: " + queue);

        // 4. Map - Key-Value pairs (not part of Collection interface)
        Map<String, Integer> map = new HashMap<>();
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Cherry", 30);
        System.out.println("\nMap (HashMap): " + map);
        System.out.println("Value for 'Banana': " + map.get("Banana"));
    }
}
```

---

## üìä Collection Framework Hierarchy

```
                    Iterable
                       ‚Üì
                   Collection
                       ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚Üì             ‚Üì             ‚Üì
       List           Set          Queue
         ‚Üì             ‚Üì             ‚Üì
    ArrayList     HashSet      LinkedList
    LinkedList    TreeSet      PriorityQueue
    Vector        LinkedHashSet ArrayDeque
    Stack


    Separate Hierarchy:

         Map
          ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì     ‚Üì     ‚Üì
 HashMap TreeMap LinkedHashMap
 Hashtable
 WeakHashMap
```

---

## üíª Example 4: Key Interfaces

```java
import java.util.*;

public class KeyInterfacesDemo {
    public static void main(String[] args) {
        // Collection interface methods
        Collection<String> collection = new ArrayList<>();

        // Add elements
        collection.add("Java");
        collection.add("Python");
        collection.add("JavaScript");
        System.out.println("Collection: " + collection);

        // Size
        System.out.println("Size: " + collection.size());

        // Contains
        System.out.println("Contains 'Java': " + collection.contains("Java"));

        // Remove
        collection.remove("Python");
        System.out.println("After removal: " + collection);

        // isEmpty
        System.out.println("Is empty: " + collection.isEmpty());

        // Clear
        collection.clear();
        System.out.println("After clear: " + collection);
        System.out.println("Is empty now: " + collection.isEmpty());

        // Bulk operations
        Collection<Integer> c1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Collection<Integer> c2 = new ArrayList<>(Arrays.asList(4, 5, 6, 7, 8));

        // addAll
        Collection<Integer> union = new ArrayList<>(c1);
        union.addAll(c2);
        System.out.println("\nUnion (with duplicates): " + union);

        // retainAll (intersection)
        Collection<Integer> intersection = new ArrayList<>(c1);
        intersection.retainAll(c2);
        System.out.println("Intersection: " + intersection);  // [4, 5]

        // removeAll (difference)
        Collection<Integer> difference = new ArrayList<>(c1);
        difference.removeAll(c2);
        System.out.println("Difference (c1 - c2): " + difference);  // [1, 2, 3]
    }
}
```

---

## üíª Example 5: Benefits of Collections Framework

```java
import java.util.*;

public class BenefitsDemo {
    public static void main(String[] args) {
        // 1. Reduces programming effort
        List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);
        Collections.sort(numbers);  // One line to sort!
        System.out.println("Sorted: " + numbers);

        // 2. Increases performance
        // Collections are highly optimized
        long start = System.nanoTime();
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < 10000; i++) {
            set.add(i);
        }
        long end = System.nanoTime();
        System.out.println("\nHashSet add time: " + (end - start) + " ns");

        // 3. Provides interoperability
        List<String> arrayList = new ArrayList<>();
        arrayList.add("A");
        arrayList.add("B");

        // Can easily convert to other types
        Set<String> set2 = new HashSet<>(arrayList);
        LinkedList<String> linkedList = new LinkedList<>(arrayList);

        System.out.println("ArrayList: " + arrayList);
        System.out.println("HashSet: " + set2);
        System.out.println("LinkedList: " + linkedList);

        // 4. Reusable data structures
        // Don't need to implement your own list, set, map

        // 5. Algorithm reuse
        List<String> words = Arrays.asList("zebra", "apple", "mango", "banana");
        Collections.sort(words);
        System.out.println("\nSorted words: " + words);

        int index = Collections.binarySearch(words, "mango");
        System.out.println("Index of 'mango': " + index);

        Collections.shuffle(words);
        System.out.println("Shuffled: " + words);

        String max = Collections.max(words);
        String min = Collections.min(words);
        System.out.println("Max: " + max + ", Min: " + min);
    }
}
```

---

## üíª Example 6: Common Collection Operations

```java
import java.util.*;

public class CommonOperationsDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        // 1. Adding elements
        list.add("Java");
        list.add("Python");
        list.add("JavaScript");
        list.add(1, "C++");  // Insert at index
        System.out.println("After add: " + list);

        // 2. Accessing elements
        String first = list.get(0);
        String last = list.get(list.size() - 1);
        System.out.println("First: " + first + ", Last: " + last);

        // 3. Modifying elements
        list.set(1, "Ruby");
        System.out.println("After set: " + list);

        // 4. Removing elements
        list.remove("Python");
        list.remove(0);  // Remove by index
        System.out.println("After remove: " + list);

        // 5. Searching
        boolean contains = list.contains("JavaScript");
        int index = list.indexOf("JavaScript");
        System.out.println("Contains JavaScript: " + contains + " at index: " + index);

        // 6. Size
        System.out.println("Size: " + list.size());

        // 7. Iteration
        System.out.println("\nIteration methods:");

        // For-each loop
        System.out.print("For-each: ");
        for (String item : list) {
            System.out.print(item + " ");
        }

        // Iterator
        System.out.print("\nIterator: ");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }

        // Stream (Java 8+)
        System.out.print("\nStream: ");
        list.stream().forEach(item -> System.out.print(item + " "));

        // 8. Bulk operations
        List<String> newLanguages = Arrays.asList("Go", "Rust", "Swift");
        list.addAll(newLanguages);
        System.out.println("\n\nAfter addAll: " + list);

        // 9. Clear
        list.clear();
        System.out.println("After clear: " + list + " (empty: " + list.isEmpty() + ")");
    }
}
```

---

## üíª Example 7: Collection vs Array

```java
import java.util.*;

public class CollectionVsArrayDemo {
    public static void main(String[] args) {
        System.out.println("=== Array ===");
        // Array: Fixed size
        String[] arrayFruits = new String[3];
        arrayFruits[0] = "Apple";
        arrayFruits[1] = "Banana";
        arrayFruits[2] = "Cherry";

        System.out.println("Array length: " + arrayFruits.length);
        System.out.println("Array: " + Arrays.toString(arrayFruits));

        // Cannot add more elements
        // arrayFruits[3] = "Date";  // Error!

        System.out.println("\n=== Collection ===");
        // Collection: Dynamic size
        List<String> listFruits = new ArrayList<>();
        listFruits.add("Apple");
        listFruits.add("Banana");
        listFruits.add("Cherry");
        listFruits.add("Date");      // Can keep adding
        listFruits.add("Elderberry");

        System.out.println("List size: " + listFruits.size());
        System.out.println("List: " + listFruits);

        // Built-in methods
        listFruits.remove("Banana");
        System.out.println("After removal: " + listFruits);

        Collections.sort(listFruits);
        System.out.println("Sorted: " + listFruits);

        // Conversion
        System.out.println("\n=== Conversion ===");

        // Array to List
        String[] array = {"A", "B", "C"};
        List<String> listFromArray = Arrays.asList(array);
        System.out.println("Array to List: " + listFromArray);

        // List to Array
        List<String> list = new ArrayList<>(Arrays.asList("X", "Y", "Z"));
        String[] arrayFromList = list.toArray(new String[0]);
        System.out.println("List to Array: " + Arrays.toString(arrayFromList));
    }
}
```

---

## üìä Collection Framework Features

| Feature             | Description                                    |
| ------------------- | ---------------------------------------------- |
| **Interfaces**      | Abstract data types (List, Set, Queue, Map)    |
| **Implementations** | Concrete classes (ArrayList, HashSet, HashMap) |
| **Algorithms**      | Methods for searching, sorting, shuffling      |
| **Generic**         | Type-safe collections                          |
| **Dynamic sizing**  | Automatically grows/shrinks                    |
| **Utility classes** | Collections, Arrays classes                    |

---

## üìä Collection Types Quick Reference

| Type      | Ordered | Duplicates            | Null  | Thread-Safe | Key Implementations                   |
| --------- | ------- | --------------------- | ----- | ----------- | ------------------------------------- |
| **List**  | Yes     | Yes                   | Yes   | No\*        | ArrayList, LinkedList, Vector         |
| **Set**   | No      | No                    | Yes\* | No\*        | HashSet, LinkedHashSet, TreeSet       |
| **Queue** | Yes     | Yes                   | No\*  | No\*        | PriorityQueue, LinkedList, ArrayDeque |
| **Map**   | No      | Keys: No, Values: Yes | Yes\* | No\*        | HashMap, TreeMap, LinkedHashMap       |

\*Some implementations may vary

---

## üéØ Key Advantages of Collections Framework

### 1. **Consistent API**

All collection classes implement common interfaces, making them easy to learn and use.

### 2. **Reduced Development Effort**

Pre-built data structures eliminate the need for custom implementations.

### 3. **Increased Performance**

Highly optimized implementations for common operations.

### 4. **Interoperability**

Easy conversion between different collection types.

### 5. **Generic Programming**

Type-safe collections prevent runtime errors.

### 6. **Rich Functionality**

Built-in methods for sorting, searching, reversing, etc.

---

## üí° Best Practices

1. ‚úÖ **Program to interfaces, not implementations**

   ```java
   List<String> list = new ArrayList<>();  // Good
   ArrayList<String> list = new ArrayList<>();  // Less flexible
   ```

2. ‚úÖ **Use generics for type safety**

   ```java
   List<String> list = new ArrayList<>();  // Type-safe
   List list = new ArrayList();  // Raw type, avoid!
   ```

3. ‚úÖ **Choose the right collection for your use case**

   - ArrayList: Random access
   - LinkedList: Frequent insertions/deletions
   - HashSet: Unique elements
   - HashMap: Key-value pairs

4. ‚úÖ **Initialize with capacity if size is known**

   ```java
   List<String> list = new ArrayList<>(100);
   ```

5. ‚úÖ **Use immutable collections when possible**
   ```java
   List<String> immutable = List.of("A", "B", "C");  // Java 9+
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class CollectionPitfalls {
    public static void main(String[] args) {
        // 1. Modifying collection while iterating
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // Wrong way (ConcurrentModificationException)
        // for (Integer num : numbers) {
        //     if (num % 2 == 0) {
        //         numbers.remove(num);  // Exception!
        //     }
        // }

        // Correct way: Use Iterator
        Iterator<Integer> iterator = numbers.iterator();
        while (iterator.hasNext()) {
            if (iterator.next() % 2 == 0) {
                iterator.remove();  // Safe
            }
        }
        System.out.println("After removal: " + numbers);

        // 2. Using raw types (no generics)
        // List list = new ArrayList();  // Avoid!
        List<String> list = new ArrayList<>();  // Good

        // 3. Not checking for null
        List<String> nullList = null;
        // int size = nullList.size();  // NullPointerException!
        if (nullList != null) {
            System.out.println(nullList.size());
        }

        // 4. Assuming order in HashSet
        Set<Integer> set = new HashSet<>();
        set.add(3);
        set.add(1);
        set.add(2);
        // Order is not guaranteed!
        System.out.println("HashSet (unordered): " + set);
    }
}
```

---

## üéØ Interview Questions

1. **What is the Java Collections Framework?**
2. **What are the main interfaces in the Collection hierarchy?**
3. **Difference between Collection and Collections?**
4. **Why use Collections instead of arrays?**
5. **What is the difference between List, Set, and Queue?**
6. **What are the benefits of the Collections Framework?**
7. **What is a generic collection?**
8. **Can we add null to collections?**
9. **What is the difference between ArrayList and Array?**
10. **How to make a collection thread-safe?**

---

## üìö Next Topics

- [Collection Hierarchy](02.%20Collection%20Hierarchy.md)
- [Collection vs Collections](03.%20Collection%20vs%20Collections.md)
- [Iterable & Iterator](04.%20Iterable%20%26%20Iterator.md)
