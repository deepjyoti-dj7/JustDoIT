# üîÑ Iterable & Iterator

## üìñ Overview

**Iterable** and **Iterator** are fundamental interfaces in Java that enable traversal of collection elements:
- **Iterable<T>**: Interface that represents a collection that can be iterated. Provides an iterator() method.
- **Iterator<E>**: Interface for iterating over collection elements. Provides hasNext(), next(), and remove() methods.

All collection classes implement Iterable, which allows them to be used in enhanced for-loops.

---

## üéØ Interface Hierarchy

```
    java.lang.Iterable<T>
           ‚Üì
    iterator() method
           ‚Üì
    java.util.Iterator<E>
           ‚Üì
    hasNext(), next(), remove()
```

---

## üíª Example 1: Iterable Interface Basic Usage

```java
import java.util.*;

public class IterableBasicDemo {
    public static void main(String[] args) {
        // All collections implement Iterable
        List<String> list = Arrays.asList("Java", "Python", "JavaScript");
        
        // Enhanced for-loop (possible because of Iterable)
        System.out.println("Using enhanced for-loop (Iterable):");
        for (String language : list) {
            System.out.println(language);
        }
        
        // Behind the scenes, it uses Iterator
        System.out.println("\nUsing Iterator explicitly:");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String language = iterator.next();
            System.out.println(language);
        }
        
        // Works with any Iterable
        Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("\nIterating over Set:");
        for (Integer num : set) {
            System.out.print(num + " ");
        }
    }
}
```

**Output:**
```
Using enhanced for-loop (Iterable):
Java
Python
JavaScript

Using Iterator explicitly:
Java
Python
JavaScript

Iterating over Set:
1 2 3 4 5 
```

---

## üíª Example 2: Iterator Methods

```java
import java.util.*;

public class IteratorMethodsDemo {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>(
            Arrays.asList("Apple", "Banana", "Cherry", "Date", "Elderberry")
        );
        
        System.out.println("Original list: " + fruits);
        
        Iterator<String> iterator = fruits.iterator();
        
        // 1. hasNext() - Check if more elements exist
        System.out.println("\n=== Using hasNext() and next() ===");
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println("Current: " + fruit);
        }
        
        // 2. remove() - Remove current element
        System.out.println("\n=== Using remove() ===");
        iterator = fruits.iterator();  // Get new iterator
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if (fruit.startsWith("B") || fruit.startsWith("D")) {
                iterator.remove();  // Safe removal during iteration
                System.out.println("Removed: " + fruit);
            }
        }
        System.out.println("After removal: " + fruits);
        
        // 3. forEachRemaining() - Java 8+
        System.out.println("\n=== Using forEachRemaining() ===");
        iterator = fruits.iterator();
        iterator.forEachRemaining(fruit -> System.out.println("Fruit: " + fruit));
    }
}
```

**Output:**
```
Original list: [Apple, Banana, Cherry, Date, Elderberry]

=== Using hasNext() and next() ===
Current: Apple
Current: Banana
Current: Cherry
Current: Date
Current: Elderberry

=== Using remove() ===
Removed: Banana
Removed: Date
After removal: [Apple, Cherry, Elderberry]

=== Using forEachRemaining() ===
Fruit: Apple
Fruit: Cherry
Fruit: Elderberry
```

---

## üíª Example 3: Iterator vs Enhanced For-Loop

```java
import java.util.*;

public class IteratorVsForLoopDemo {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));
        
        // Enhanced for-loop - CANNOT remove elements
        System.out.println("=== Enhanced For-Loop (Read-only) ===");
        for (Integer num : numbers) {
            System.out.print(num + " ");
            // Cannot remove here safely
            // if (num % 2 == 0) numbers.remove(num);  // ConcurrentModificationException!
        }
        
        // Iterator - CAN remove elements safely
        System.out.println("\n\n=== Iterator (Can Modify) ===");
        System.out.println("Original: " + numbers);
        
        Iterator<Integer> iterator = numbers.iterator();
        while (iterator.hasNext()) {
            Integer num = iterator.next();
            if (num % 2 == 0) {
                iterator.remove();  // Safe removal
                System.out.println("Removed: " + num);
            }
        }
        System.out.println("After removal: " + numbers);
        
        // For-loop with index - Another option for modification
        System.out.println("\n=== Traditional For-Loop (Can Modify) ===");
        List<Integer> list = new ArrayList<>(Arrays.asList(10, 20, 30, 40, 50));
        for (int i = list.size() - 1; i >= 0; i--) {  // Iterate backwards
            if (list.get(i) > 25) {
                list.remove(i);
            }
        }
        System.out.println("After removal: " + list);
    }
}
```

---

## üíª Example 4: ListIterator (Bidirectional)

```java
import java.util.*;

public class ListIteratorDemo {
    public static void main(String[] args) {
        List<String> languages = new ArrayList<>(
            Arrays.asList("Java", "Python", "JavaScript", "C++", "Ruby")
        );
        
        // ListIterator - bidirectional iteration (only for List)
        ListIterator<String> listIterator = languages.listIterator();
        
        // 1. Forward iteration
        System.out.println("=== Forward Iteration ===");
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String language = listIterator.next();
            System.out.println("Index " + index + ": " + language);
        }
        
        // 2. Backward iteration
        System.out.println("\n=== Backward Iteration ===");
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String language = listIterator.previous();
            System.out.println("Index " + index + ": " + language);
        }
        
        // 3. Modify during iteration
        System.out.println("\n=== Modification During Iteration ===");
        listIterator = languages.listIterator();
        while (listIterator.hasNext()) {
            String language = listIterator.next();
            if (language.equals("Python")) {
                listIterator.set("Python 3");  // Replace current element
            }
            if (language.equals("JavaScript")) {
                listIterator.add("TypeScript");  // Add after current
            }
        }
        System.out.println("After modifications: " + languages);
        
        // 4. Start from specific position
        System.out.println("\n=== Start from Index 2 ===");
        listIterator = languages.listIterator(2);
        while (listIterator.hasNext()) {
            System.out.println(listIterator.next());
        }
    }
}
```

**Output:**
```
=== Forward Iteration ===
Index 0: Java
Index 1: Python
Index 2: JavaScript
Index 3: C++
Index 4: Ruby

=== Backward Iteration ===
Index 4: Ruby
Index 3: C++
Index 2: JavaScript
Index 1: Python
Index 0: Java

=== Modification During Iteration ===
After modifications: [Java, Python 3, JavaScript, TypeScript, C++, Ruby]

=== Start from Index 2 ===
JavaScript
TypeScript
C++
Ruby
```

---

## üíª Example 5: Custom Iterable Class

```java
import java.util.*;

// Custom class implementing Iterable
class NumberRange implements Iterable<Integer> {
    private int start;
    private int end;
    
    public NumberRange(int start, int end) {
        this.start = start;
        this.end = end;
    }
    
    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            private int current = start;
            
            @Override
            public boolean hasNext() {
                return current <= end;
            }
            
            @Override
            public Integer next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }
                return current++;
            }
            
            @Override
            public void remove() {
                throw new UnsupportedOperationException("Remove not supported");
            }
        };
    }
}

public class CustomIterableDemo {
    public static void main(String[] args) {
        NumberRange range = new NumberRange(1, 10);
        
        // Can use enhanced for-loop because it implements Iterable
        System.out.println("=== Using Enhanced For-Loop ===");
        for (Integer num : range) {
            System.out.print(num + " ");
        }
        
        // Can use Iterator explicitly
        System.out.println("\n\n=== Using Iterator ===");
        Iterator<Integer> iterator = range.iterator();
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
        }
        
        // Multiple iterations
        System.out.println("\n\n=== Multiple Iterations ===");
        for (Integer num : range) {
            if (num % 2 == 0) {
                System.out.print(num + " ");
            }
        }
    }
}
```

**Output:**
```
=== Using Enhanced For-Loop ===
1 2 3 4 5 6 7 8 9 10 

=== Using Iterator ===
1 2 3 4 5 6 7 8 9 10 

=== Multiple Iterations ===
2 4 6 8 10 
```

---

## üíª Example 6: Fail-Fast Iterator

```java
import java.util.*;

public class FailFastIteratorDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        
        System.out.println("=== Fail-Fast Behavior ===");
        System.out.println("Original list: " + list);
        
        // Attempting to modify collection during iteration
        Iterator<String> iterator = list.iterator();
        
        try {
            while (iterator.hasNext()) {
                String item = iterator.next();
                System.out.println("Current: " + item);
                
                if (item.equals("B")) {
                    // Modifying collection directly (not through iterator)
                    list.remove("C");  // ConcurrentModificationException!
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("\nConcurrentModificationException caught!");
            System.out.println("Cannot modify collection during iteration");
        }
        
        // Correct way - use Iterator's remove method
        System.out.println("\n=== Correct Way ===");
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));
        iterator = list.iterator();
        
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (item.equals("B") || item.equals("D")) {
                iterator.remove();  // Safe!
                System.out.println("Removed: " + item);
            }
        }
        System.out.println("Final list: " + list);
    }
}
```

---

## üíª Example 7: Iterator Performance Comparison

```java
import java.util.*;

public class IteratorPerformanceDemo {
    public static void main(String[] args) {
        int size = 100000;
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            list.add(i);
        }
        
        // 1. Iterator
        long start = System.nanoTime();
        Iterator<Integer> iterator = list.iterator();
        int sum = 0;
        while (iterator.hasNext()) {
            sum += iterator.next();
        }
        long end = System.nanoTime();
        System.out.println("Iterator time: " + (end - start) + " ns");
        
        // 2. Enhanced for-loop
        start = System.nanoTime();
        sum = 0;
        for (Integer num : list) {
            sum += num;
        }
        end = System.nanoTime();
        System.out.println("Enhanced for-loop time: " + (end - start) + " ns");
        
        // 3. Traditional for-loop with get()
        start = System.nanoTime();
        sum = 0;
        for (int i = 0; i < list.size(); i++) {
            sum += list.get(i);
        }
        end = System.nanoTime();
        System.out.println("Traditional for-loop time: " + (end - start) + " ns");
        
        // 4. Stream
        start = System.nanoTime();
        sum = list.stream().mapToInt(Integer::intValue).sum();
        end = System.nanoTime();
        System.out.println("Stream time: " + (end - start) + " ns");
        
        System.out.println("\nNote: For ArrayList, all are similar.");
        System.out.println("For LinkedList, iterator is much faster than get().");
    }
}
```

---

## üíª Example 8: Iterator with Different Collections

```java
import java.util.*;

public class IteratorCollectionsDemo {
    public static void main(String[] args) {
        // List - maintains order
        System.out.println("=== List Iterator ===");
        List<String> list = Arrays.asList("A", "B", "C");
        Iterator<String> listIter = list.iterator();
        while (listIter.hasNext()) {
            System.out.print(listIter.next() + " ");
        }
        
        // Set - no guaranteed order (HashSet)
        System.out.println("\n\n=== Set Iterator (HashSet) ===");
        Set<String> hashSet = new HashSet<>(Arrays.asList("A", "B", "C"));
        Iterator<String> setIter = hashSet.iterator();
        while (setIter.hasNext()) {
            System.out.print(setIter.next() + " ");
        }
        
        // LinkedHashSet - maintains insertion order
        System.out.println("\n\n=== Set Iterator (LinkedHashSet) ===");
        Set<String> linkedSet = new LinkedHashSet<>(Arrays.asList("A", "B", "C"));
        Iterator<String> linkedIter = linkedSet.iterator();
        while (linkedIter.hasNext()) {
            System.out.print(linkedIter.next() + " ");
        }
        
        // TreeSet - sorted order
        System.out.println("\n\n=== Set Iterator (TreeSet) ===");
        Set<String> treeSet = new TreeSet<>(Arrays.asList("C", "A", "B"));
        Iterator<String> treeIter = treeSet.iterator();
        while (treeIter.hasNext()) {
            System.out.print(treeIter.next() + " ");
        }
        
        // Queue
        System.out.println("\n\n=== Queue Iterator ===");
        Queue<String> queue = new LinkedList<>(Arrays.asList("First", "Second", "Third"));
        Iterator<String> queueIter = queue.iterator();
        while (queueIter.hasNext()) {
            System.out.print(queueIter.next() + " ");
        }
        
        // Map - iterate over keys, values, or entries
        System.out.println("\n\n=== Map Iterator ===");
        Map<String, Integer> map = new HashMap<>();
        map.put("A", 1);
        map.put("B", 2);
        map.put("C", 3);
        
        System.out.println("Keys:");
        Iterator<String> keyIter = map.keySet().iterator();
        while (keyIter.hasNext()) {
            System.out.print(keyIter.next() + " ");
        }
        
        System.out.println("\nValues:");
        Iterator<Integer> valueIter = map.values().iterator();
        while (valueIter.hasNext()) {
            System.out.print(valueIter.next() + " ");
        }
        
        System.out.println("\nEntries:");
        Iterator<Map.Entry<String, Integer>> entryIter = map.entrySet().iterator();
        while (entryIter.hasNext()) {
            Map.Entry<String, Integer> entry = entryIter.next();
            System.out.print(entry.getKey() + "=" + entry.getValue() + " ");
        }
    }
}
```

---

## üìä Iterable vs Iterator Comparison

| Aspect | Iterable | Iterator |
|--------|----------|----------|
| **Type** | Interface | Interface |
| **Package** | java.lang | java.util |
| **Purpose** | Represents collection that can be iterated | Provides iteration mechanism |
| **Methods** | iterator() | hasNext(), next(), remove(), forEachRemaining() |
| **Who implements** | All collection classes | Returned by iterator() method |
| **Use in for-each** | Yes, directly | No |
| **Reusability** | Can create multiple iterators | Single-use (must create new for re-iteration) |
| **State** | Stateless | Stateful (tracks position) |

---

## üìä Iterator vs ListIterator

| Feature | Iterator | ListIterator |
|---------|----------|--------------|
| **Direction** | Forward only | Forward and backward |
| **Works with** | All collections | Only List |
| **Methods** | hasNext(), next(), remove() | All Iterator methods + hasPrevious(), previous(), add(), set(), nextIndex(), previousIndex() |
| **Modification** | Can remove | Can remove, add, and set |
| **Index access** | No | Yes (nextIndex(), previousIndex()) |

---

## üìä Iterator Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| **hasNext()** | boolean | Returns true if more elements exist |
| **next()** | E | Returns next element and advances iterator |
| **remove()** | void | Removes last element returned by next() |
| **forEachRemaining()** | void | Performs action for remaining elements (Java 8+) |

---

## üìä ListIterator Additional Methods

| Method | Return Type | Description |
|--------|-------------|-------------|
| **hasPrevious()** | boolean | Returns true if previous elements exist |
| **previous()** | E | Returns previous element and moves backward |
| **nextIndex()** | int | Returns index of next element |
| **previousIndex()** | int | Returns index of previous element |
| **add(E e)** | void | Inserts element at current position |
| **set(E e)** | void | Replaces last element returned by next/previous |

---

## üí° Best Practices

1. ‚úÖ **Use enhanced for-loop for read-only iteration**
   ```java
   for (String item : list) {
       System.out.println(item);
   }
   ```

2. ‚úÖ **Use Iterator when you need to remove elements**
   ```java
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       if (condition) it.remove();
   }
   ```

3. ‚úÖ **Use ListIterator for bidirectional traversal**
   ```java
   ListIterator<String> lit = list.listIterator();
   while (lit.hasNext()) { /* forward */ }
   while (lit.hasPrevious()) { /* backward */ }
   ```

4. ‚úÖ **Always check hasNext() before calling next()**
   ```java
   while (iterator.hasNext()) {
       String item = iterator.next();  // Safe
   }
   ```

5. ‚úÖ **Don't modify collection during iteration (except via Iterator)**
   ```java
   // Wrong
   for (String item : list) {
       list.remove(item);  // ConcurrentModificationException!
   }
   
   // Correct
   Iterator<String> it = list.iterator();
   while (it.hasNext()) {
       it.next();
       it.remove();  // Safe
   }
   ```

---

## ‚ö†Ô∏è Common Pitfalls

```java
import java.util.*;

public class IteratorPitfalls {
    public static void main(String[] args) {
        // 1. Calling next() without hasNext()
        List<String> list = Arrays.asList("A", "B");
        Iterator<String> it = list.iterator();
        it.next();
        it.next();
        // it.next();  // NoSuchElementException!
        
        // 2. Calling remove() before next()
        it = list.iterator();
        // it.remove();  // IllegalStateException!
        
        // 3. Calling remove() twice
        list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        it = list.iterator();
        it.next();
        it.remove();  // OK
        // it.remove();  // IllegalStateException!
        
        // 4. Modifying collection during iteration
        list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        it = list.iterator();
        while (it.hasNext()) {
            String item = it.next();
            // list.remove(item);  // ConcurrentModificationException!
            it.remove();  // Correct way
        }
        
        // 5. Reusing exhausted iterator
        it = list.iterator();
        while (it.hasNext()) {
            it.next();
        }
        // it is now exhausted
        // it.next();  // NoSuchElementException!
        // Must create new iterator
        it = list.iterator();
        
        System.out.println("All pitfalls avoided!");
    }
}
```

---

## üéØ Interview Questions

1. **What is the difference between Iterable and Iterator?**
2. **Can you iterate over a collection without using Iterator?**
3. **What is the difference between Iterator and ListIterator?**
4. **Why does ConcurrentModificationException occur?**
5. **How to safely remove elements during iteration?**
6. **What methods does Iterator provide?**
7. **Can you iterate backwards using Iterator?**
8. **What is fail-fast iterator?**
9. **What happens if you call next() after the last element?**
10. **Can you call remove() multiple times without calling next()?**
11. **How to implement custom Iterable?**
12. **What is the purpose of forEachRemaining()?**
13. **Difference between for-loop and Iterator?**
14. **Can Map be iterated directly?**
15. **What is the use of hasNext() method?**

---

## üìö Next Topics

- [Comparable vs Comparator](05.%20Comparable%20vs%20Comparator.md)
- [Fail-Fast vs Fail-Safe](06.%20Fail-Fast%20vs%20Fail-Safe.md)
- [ArrayList](../02.%20List%20Interface/02.%20ArrayList.md)
- [HashMap](../05.%20Map%20Interface/02.%20HashMap.md)
- [Stream Operations](../10.%20Stream%20Operations/01.%20Collection%20to%20Stream.md)
