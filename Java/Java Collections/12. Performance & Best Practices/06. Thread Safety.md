# üîí Thread Safety

## üìñ Overview

**Thread-safe collections** prevent data corruption in concurrent environments. Key concepts:
- **Synchronization** - Coordinated access
- **Concurrent collections** - Built for multi-threading
- **Immutability** - Inherently thread-safe
- **Lock mechanisms** - Prevent race conditions

---

## ‚ö†Ô∏è Problem: Non-Thread-Safe Collections

### ‚ùå Race Condition
```java
List<Integer> list = new ArrayList<>();

// Thread 1
new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        list.add(i);
    }
}).start();

// Thread 2
new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        list.add(i);
    }
}).start();

// Results:
// - Data corruption
// - ArrayIndexOutOfBoundsException
// - Lost updates
// - Final size might be < 2000
```

---

## üîí Solution 1: Synchronized Collections

### Collections.synchronizedXxx()
```java
// Synchronized wrappers
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());

// Usage
syncList.add("thread-safe");
syncSet.add("safe");
syncMap.put("key", 1);
```

### ‚ö†Ô∏è Caveat: Iteration Requires Manual Synchronization
```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// ‚ùå Not thread-safe!
for (String item : syncList) {
    System.out.println(item);  // ConcurrentModificationException possible
}

// ‚úÖ Thread-safe iteration
synchronized (syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}
```

### Performance
```java
// Synchronization overhead
// All operations lock entire collection
// Only one thread can access at a time
// Performance: ‚≠ê‚≠ê (adequate but slow)
```

---

## üöÄ Solution 2: Concurrent Collections (Recommended)

### ConcurrentHashMap
```java
// ‚úÖ Best for concurrent map operations
Map<String, Integer> map = new ConcurrentHashMap<>();

// Thread-safe operations
map.put("key", 1);
map.get("key");
map.remove("key");

// Atomic operations
map.putIfAbsent("key", 1);
map.computeIfAbsent("key", k -> 1);
map.merge("key", 1, Integer::sum);

// Thread-safe iteration (no need to lock)
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry);  // Safe!
}
```

**Features:**
- **Lock striping**: Multiple segments, better concurrency
- **No blocking reads**: Read while writing
- **Atomic operations**: putIfAbsent, computeIfAbsent, etc.
- **Performance**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (excellent)

---

### CopyOnWriteArrayList
```java
// ‚úÖ Best for read-heavy, write-rare scenarios
List<String> list = new CopyOnWriteArrayList<>();

// Thread-safe operations
list.add("item");
list.remove("item");

// No synchronization needed for iteration
for (String item : list) {
    System.out.println(item);  // Always safe!
}
```

**How it works:**
- Creates new copy on every modification
- Iterators work on snapshot
- No ConcurrentModificationException

**Use when:**
- ‚úÖ Many reads, few writes
- ‚úÖ Iteration is frequent
- ‚ùå Frequent modifications (expensive)

**Performance:**
- Read: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (O(1), no locking)
- Write: ‚≠ê‚≠ê (O(n), copies entire array)

---

### CopyOnWriteArraySet
```java
// ‚úÖ Thread-safe set, backed by CopyOnWriteArrayList
Set<String> set = new CopyOnWriteArraySet<>();

set.add("item");
set.remove("item");

// Safe iteration
for (String item : set) {
    System.out.println(item);
}
```

**Same characteristics as CopyOnWriteArrayList**

---

### ConcurrentLinkedQueue
```java
// ‚úÖ Thread-safe FIFO queue
Queue<String> queue = new ConcurrentLinkedQueue<>();

// Thread-safe operations
queue.offer("item");
queue.poll();
queue.peek();

// No locking needed
for (String item : queue) {
    System.out.println(item);
}
```

**Features:**
- Non-blocking (lock-free)
- Efficient for producer-consumer
- Unbounded
- Performance: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

---

### ConcurrentLinkedDeque
```java
// ‚úÖ Thread-safe double-ended queue
Deque<String> deque = new ConcurrentLinkedDeque<>();

// Both ends thread-safe
deque.offerFirst("first");
deque.offerLast("last");
deque.pollFirst();
deque.pollLast();
```

---

### BlockingQueue (Producer-Consumer)
```java
// ‚úÖ Best for producer-consumer pattern
BlockingQueue<String> queue = new LinkedBlockingQueue<>(100);

// Producer thread
new Thread(() -> {
    try {
        queue.put("item");  // Blocks if full
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();

// Consumer thread
new Thread(() -> {
    try {
        String item = queue.take();  // Blocks if empty
        System.out.println(item);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}).start();
```

**Implementations:**
- **ArrayBlockingQueue**: Bounded, array-based
- **LinkedBlockingQueue**: Optionally bounded, linked nodes
- **PriorityBlockingQueue**: Unbounded, priority heap
- **SynchronousQueue**: No capacity, direct handoff

---

### ConcurrentSkipListMap
```java
// ‚úÖ Thread-safe sorted map
ConcurrentNavigableMap<Integer, String> map = new ConcurrentSkipListMap<>();

map.put(3, "three");
map.put(1, "one");
map.put(2, "two");

System.out.println(map);  // {1=one, 2=two, 3=three} - sorted!

// Navigation operations
map.firstEntry();
map.lastEntry();
map.ceilingKey(2);
```

**Features:**
- Sorted keys
- O(log n) operations
- Better concurrency than TreeMap
- Performance: ‚≠ê‚≠ê‚≠ê‚≠ê

---

### ConcurrentSkipListSet
```java
// ‚úÖ Thread-safe sorted set
NavigableSet<Integer> set = new ConcurrentSkipListSet<>();

set.add(3);
set.add(1);
set.add(2);

System.out.println(set);  // [1, 2, 3] - sorted!
```

---

## üìä Thread-Safe Collections Comparison

| Collection | Thread-Safety | Performance | Best For |
|------------|---------------|-------------|----------|
| **ArrayList** | ‚ùå No | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Single thread |
| **synchronizedList** | ‚úÖ Yes | ‚≠ê‚≠ê | Simple sync |
| **CopyOnWriteArrayList** | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê read, ‚≠ê‚≠ê write | Read-heavy |
| **Vector** | ‚úÖ Yes (legacy) | ‚≠ê‚≠ê | Legacy code |
| **HashMap** | ‚ùå No | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Single thread |
| **synchronizedMap** | ‚úÖ Yes | ‚≠ê‚≠ê | Simple sync |
| **Hashtable** | ‚úÖ Yes (legacy) | ‚≠ê‚≠ê | Legacy code |
| **ConcurrentHashMap** | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Concurrent access |
| **ConcurrentSkipListMap** | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê‚≠ê | Sorted + concurrent |
| **ConcurrentLinkedQueue** | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Queue operations |
| **BlockingQueue** | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê‚≠ê | Producer-consumer |

---

## üéØ Choosing Thread-Safe Collection

### For Map
```java
// Need sorted keys?
ConcurrentNavigableMap<K, V> map = new ConcurrentSkipListMap<>();

// Just need fast concurrent access?
Map<K, V> map = new ConcurrentHashMap<>();

// Legacy or simple sync?
Map<K, V> map = Collections.synchronizedMap(new HashMap<>());
```

---

### For List
```java
// Read-heavy, write-rare?
List<E> list = new CopyOnWriteArrayList<>();

// Balanced read/write?
List<E> list = Collections.synchronizedList(new ArrayList<>());

// Legacy?
List<E> list = new Vector<>();  // Not recommended
```

---

### For Set
```java
// Need sorted order?
NavigableSet<E> set = new ConcurrentSkipListSet<>();

// Read-heavy?
Set<E> set = new CopyOnWriteArraySet<>();

// Just need thread-safe?
Set<E> set = Collections.synchronizedSet(new HashSet<>());
// Or use ConcurrentHashMap.newKeySet()
Set<E> set = ConcurrentHashMap.newKeySet();
```

---

### For Queue
```java
// Producer-consumer pattern?
BlockingQueue<E> queue = new LinkedBlockingQueue<>();

// High-performance queue?
Queue<E> queue = new ConcurrentLinkedQueue<>();

// Stack operations?
Deque<E> stack = new ConcurrentLinkedDeque<>();
```

---

## ‚ö†Ô∏è Common Thread-Safety Pitfalls

### 1. Compound Operations Not Atomic
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// ‚ùå Not atomic! Race condition possible
if (!map.containsKey("count")) {
    map.put("count", 1);
} else {
    map.put("count", map.get("count") + 1);
}

// ‚úÖ Atomic operation
map.merge("count", 1, Integer::sum);

// ‚úÖ Or use compute
map.compute("count", (k, v) -> v == null ? 1 : v + 1);
```

---

### 2. Iterating Synchronized Collection
```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// ‚ùå Not thread-safe!
for (String item : syncList) {
    System.out.println(item);
}

// ‚úÖ Manual synchronization
synchronized (syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}
```

---

### 3. Using Size for Logic
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// ‚ùå Race condition! Size may change between check and use
if (map.size() == 0) {
    map.put("first", 1);
}

// ‚úÖ Use atomic putIfAbsent
map.putIfAbsent("first", 1);
```

---

### 4. Forgetting Volatile for Shared Variables
```java
class Counter {
    // ‚ùå Not visible to other threads
    private int count = 0;
    
    public void increment() {
        count++;
    }
}

// ‚úÖ Use volatile or AtomicInteger
class Counter {
    private volatile int count = 0;
    // Or better:
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
}
```

---

## üîß Atomic Operations

### AtomicInteger, AtomicLong, AtomicBoolean
```java
// Thread-safe counter
AtomicInteger counter = new AtomicInteger(0);

// Multiple threads
ExecutorService executor = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    executor.submit(() -> counter.incrementAndGet());
}

executor.shutdown();
executor.awaitTermination(1, TimeUnit.MINUTES);
System.out.println(counter.get());  // Always 1000!
```

---

### AtomicReference
```java
// Thread-safe reference
AtomicReference<String> ref = new AtomicReference<>("initial");

// Compare and set
ref.compareAndSet("initial", "updated");

// Get and set
String old = ref.getAndSet("new value");
```

---

## üí° Best Practices

1. **Prefer concurrent collections** over synchronized wrappers
2. **Use ConcurrentHashMap** instead of Hashtable or synchronizedMap
3. **Use CopyOnWriteArrayList** for read-heavy scenarios
4. **Use BlockingQueue** for producer-consumer
5. **Avoid manual synchronization** when possible
6. **Use atomic classes** for counters and flags
7. **Prefer immutability** for thread-safety
8. **Test under load** to find concurrency issues

---

## üéØ Common Patterns

### Pattern 1: Frequency Counter
```java
ConcurrentHashMap<String, AtomicInteger> frequency = new ConcurrentHashMap<>();

// Thread-safe increment
frequency.computeIfAbsent(word, k -> new AtomicInteger(0)).incrementAndGet();

// Or
frequency.merge(word, 1, Integer::sum);
```

---

### Pattern 2: Producer-Consumer
```java
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(100);

// Producer
executor.submit(() -> {
    while (running) {
        Task task = generateTask();
        queue.put(task);  // Blocks if full
    }
});

// Consumer
executor.submit(() -> {
    while (running) {
        Task task = queue.take();  // Blocks if empty
        processTask(task);
    }
});
```

---

### Pattern 3: Cache
```java
// Thread-safe cache with auto-computation
ConcurrentHashMap<String, Data> cache = new ConcurrentHashMap<>();

Data getData(String key) {
    return cache.computeIfAbsent(key, k -> fetchFromDatabase(k));
}
```

---

## üìö Interview Questions

**Q1: ConcurrentHashMap vs Hashtable?**
A: ConcurrentHashMap uses lock striping (better concurrency), Hashtable locks entire table.

**Q2: When to use CopyOnWriteArrayList?**
A: Read-heavy scenarios with infrequent writes. Creates copy on every modification.

**Q3: Are synchronized collections thread-safe for iteration?**
A: No! Must manually synchronize on collection object during iteration.

**Q4: Best collection for producer-consumer?**
A: BlockingQueue (LinkedBlockingQueue, ArrayBlockingQueue). Blocks when empty/full.

**Q5: Why not use Vector/Hashtable?**
A: Legacy, slower. Use ArrayList/HashMap with manual sync or concurrent collections.

**Q6: putIfAbsent vs put?**
A: putIfAbsent is atomic, put is not. Important for concurrent environments.

**Q7: What's lock striping?**
A: ConcurrentHashMap divides into segments, each with own lock. Multiple threads can access different segments.

**Q8: Fail-fast vs fail-safe iterators?**
A: Fail-fast throws ConcurrentModificationException. Fail-safe (concurrent collections) works on snapshot.

---

## üìö Summary

- **Concurrent collections**: ConcurrentHashMap, CopyOnWriteArrayList, ConcurrentLinkedQueue
- **ConcurrentHashMap**: Best for concurrent map operations, lock striping
- **CopyOnWriteArrayList**: Best for read-heavy, write-rare scenarios
- **BlockingQueue**: Best for producer-consumer pattern
- **Atomic classes**: AtomicInteger for thread-safe counters
- **Avoid**: Vector, Hashtable (use modern alternatives)
- **Iteration**: Synchronized collections need manual synchronization
- **Atomic operations**: putIfAbsent, computeIfAbsent, merge
- **Best practice**: Prefer concurrent collections over synchronized wrappers
