# üíæ Space Complexity

## üìñ Overview

**Space complexity** measures memory usage of collections. Consider:
- **Storage overhead** - Extra memory per element
- **Capacity vs size** - Allocated vs used memory
- **Internal structures** - Links, buckets, trees

**Key Factors:**
- Data structure type
- Number of elements
- Load factor (maps/sets)
- Initial capacity

---

## üìä ArrayList Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
ArrayList with 10 elements:
- Object[] array: 10 slots (some unused)
- size field: 1 int (4 bytes)
- modCount: 1 int (4 bytes)

Per element overhead: 0 bytes (just array slot)
```

**Capacity Waste:**
```java
List<String> list = new ArrayList<>(100);
list.add("one");  // Using 1, wasting 99 slots

// ‚úÖ Trim excess capacity
list.trimToSize();  // Reduce to actual size
```

**Growth Strategy:**
- Default capacity: 10
- Growth: 1.5x current capacity
- Waste: Up to 50% after growth

**Memory Tips:**
```java
// ‚ùå Wastes memory
List<String> list = new ArrayList<>();  // Capacity 10
list.add("one");  // Using 1, wasting 9

// ‚úÖ Set right capacity
List<String> list = new ArrayList<>(1000);

// ‚úÖ Trim after bulk operations
list.trimToSize();
```

---

## üìä LinkedList Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
LinkedList with 10 elements:
- 10 Node objects
- Each Node:
  - data reference: 8 bytes
  - prev reference: 8 bytes
  - next reference: 8 bytes
  - Object overhead: 16 bytes
  Total per node: ~40 bytes

Per element overhead: ~40 bytes (higher than ArrayList!)
```

**Comparison with ArrayList:**
```
100 String references:
ArrayList: ~400 bytes (100 √ó 4 bytes) + small overhead
LinkedList: ~4000 bytes (100 √ó 40 bytes)

LinkedList uses ~10x more memory!
```

**Memory Efficiency:**
- **ArrayList**: More memory efficient
- **LinkedList**: Higher overhead (3 references per element)

---

## üìä HashSet Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
HashSet with 100 elements (default load factor 0.75):
- HashMap backing (capacity 128)
- 128 Entry[] buckets array
- ~100 Entry objects (for 100 elements)
- Each Entry:
  - key reference: 8 bytes
  - hash: 4 bytes
  - next reference: 8 bytes
  - Object overhead: 16 bytes
  Total per entry: ~36 bytes

Total: ~3600 bytes + buckets array overhead
```

**Load Factor Impact:**
```java
// Load factor 0.75 (default)
Set<String> set = new HashSet<>();
// With 75 elements, capacity = 100 (25% waste)

// Load factor 1.0 (less waste, more collisions)
Set<String> set = new HashSet<>(100, 1.0f);
// With 100 elements, capacity = 100 (no waste)

// Load factor 0.5 (more waste, fewer collisions)
Set<String> set = new HashSet<>(100, 0.5f);
// With 50 elements, capacity = 100 (50% waste)
```

**Memory Optimization:**
```java
// ‚úÖ Set initial capacity
int expectedSize = 1000;
Set<String> set = new HashSet<>(expectedSize / 0.75);  // Avoid resize
```

---

## üìä TreeSet Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
TreeSet with 100 elements (Red-Black Tree):
- 100 TreeNode objects
- Each TreeNode:
  - element reference: 8 bytes
  - parent reference: 8 bytes
  - left reference: 8 bytes
  - right reference: 8 bytes
  - color (boolean): 1 byte
  - Object overhead: 16 bytes
  Total per node: ~49 bytes

Total: ~4900 bytes (higher than HashSet!)
```

**Comparison:**
```
100 elements:
ArrayList: ~400 bytes
HashSet: ~3600 bytes
TreeSet: ~4900 bytes

TreeSet uses most memory!
```

---

## üìä HashMap Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
HashMap with 100 key-value pairs:
- 128 Entry[] buckets array
- ~100 Entry objects
- Each Entry:
  - key reference: 8 bytes
  - value reference: 8 bytes
  - hash: 4 bytes
  - next reference: 8 bytes
  - Object overhead: 16 bytes
  Total per entry: ~44 bytes

Total: ~4400 bytes + buckets overhead
```

**Load Factor Strategy:**
```java
// Default: 0.75
Map<String, Integer> map = new HashMap<>();
// Good balance: performance vs memory

// High load factor: Save memory, slower
Map<String, Integer> map = new HashMap<>(100, 0.9f);

// Low load factor: Use memory, faster
Map<String, Integer> map = new HashMap<>(100, 0.6f);
```

---

## üìä TreeMap Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
TreeMap with 100 entries:
- 100 TreeNode objects
- Each TreeNode:
  - key reference: 8 bytes
  - value reference: 8 bytes
  - parent reference: 8 bytes
  - left reference: 8 bytes
  - right reference: 8 bytes
  - color (boolean): 1 byte
  - Object overhead: 16 bytes
  Total per node: ~57 bytes

Total: ~5700 bytes (most memory-intensive map!)
```

---

## üìä PriorityQueue Space Complexity

**Space Complexity:** O(n)

**Memory Breakdown:**
```
PriorityQueue with 100 elements:
- Object[] array (heap): 100+ slots
- size field: 4 bytes
- comparator: 8 bytes

Per element overhead: Minimal (just array slot)
Similar to ArrayList
```

**Memory Efficiency:**
- Similar to ArrayList
- Grows by 50% when full
- More efficient than tree-based structures

---

## üìä Memory Comparison Table

| Collection | Space per Element | Overhead | Memory Efficiency |
|------------|------------------|----------|-------------------|
| **ArrayList** | ~4 bytes | Low | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Best |
| **LinkedList** | ~40 bytes | High | ‚≠ê Worst |
| **HashSet** | ~36 bytes | Medium | ‚≠ê‚≠ê‚≠ê Good |
| **TreeSet** | ~49 bytes | High | ‚≠ê‚≠ê Fair |
| **HashMap** | ~44 bytes | Medium | ‚≠ê‚≠ê‚≠ê Good |
| **TreeMap** | ~57 bytes | High | ‚≠ê‚≠ê Fair |
| **PriorityQueue** | ~4 bytes | Low | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Best |
| **ArrayDeque** | ~4 bytes | Low | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Best |

---

## üí° Memory Optimization Tips

### 1. Choose Memory-Efficient Collections
```java
// ‚ùå LinkedList: 40 bytes per element
List<String> list = new LinkedList<>();

// ‚úÖ ArrayList: 4 bytes per element
List<String> list = new ArrayList<>();
```

### 2. Set Initial Capacity
```java
// ‚ùå Multiple resizes waste memory temporarily
List<String> list = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    list.add("item");  // Resize: 10‚Üí15‚Üí22‚Üí33...‚Üí16384
}

// ‚úÖ Single allocation
List<String> list = new ArrayList<>(10000);
for (int i = 0; i < 10000; i++) {
    list.add("item");  // No resize
}
```

### 3. Trim Excess Capacity
```java
List<String> list = new ArrayList<>(10000);
// ... add 100 items
list.trimToSize();  // Reduce from 10000 to 100
```

### 4. Use Primitive Collections (Third-party)
```java
// ‚ùå Boxed integers: 16 bytes each
List<Integer> list = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    list.add(i);  // 1000 √ó 16 = 16KB
}

// ‚úÖ Primitive array: 4 bytes each (use library like Trove, FastUtil)
// IntArrayList list = new IntArrayList();  // 1000 √ó 4 = 4KB
```

### 5. Choose Right Load Factor
```java
// Memory-critical: Higher load factor
Map<String, Integer> map = new HashMap<>(1000, 0.9f);  // Less waste

// Performance-critical: Lower load factor
Map<String, Integer> map = new HashMap<>(1000, 0.6f);  // Fewer collisions
```

### 6. Clear References
```java
// ‚ùå Memory leak
list.clear();  // ArrayList.clear() nulls elements ‚úì

// Custom collection
public void clear() {
    for (int i = 0; i < size; i++) {
        elements[i] = null;  // Clear references for GC
    }
    size = 0;
}
```

### 7. Use EnumSet/EnumMap for Enums
```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// ‚ùå HashSet: ~36 bytes per element
Set<Day> days = new HashSet<>();

// ‚úÖ EnumSet: Bit vector, ~1 bit per element!
Set<Day> days = EnumSet.noneOf(Day.class);
```

---

## ‚ö†Ô∏è Common Memory Issues

### 1. LinkedList Overuse
```java
// ‚ùå 10x memory overhead
List<Integer> list = new LinkedList<>();
for (int i = 0; i < 100000; i++) {
    list.add(i);  // ~4MB
}

// ‚úÖ ArrayList
List<Integer> list = new ArrayList<>(100000);
for (int i = 0; i < 100000; i++) {
    list.add(i);  // ~400KB
}
```

### 2. Not Trimming After Bulk Operations
```java
List<String> list = new ArrayList<>(100000);
// ... add 100 items
// list.trimToSize();  // Save 99,900 slots!
```

### 3. Wrong Initial Capacity
```java
// ‚ùå Too small: Multiple resizes
List<String> list = new ArrayList<>(10);
for (int i = 0; i < 10000; i++) {
    list.add("item");
}

// ‚ùå Too large: Wasted memory
List<String> list = new ArrayList<>(1000000);
list.add("one");  // Wasting 999,999 slots
```

### 4. Boxed Primitives
```java
// ‚ùå Integer: 16 bytes each
List<Integer> list = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    list.add(i);  // 16MB
}

// ‚úÖ int[]: 4 bytes each
int[] array = new int[1000000];  // 4MB
```

---

## üìä Real-World Scenarios

### Scenario 1: 1 Million Integers
```
ArrayList<Integer>: ~16 MB (boxed) + ~4 MB (array) = 20 MB
LinkedList<Integer>: ~40 MB (nodes) + ~16 MB (boxed) = 56 MB
int[]: 4 MB (primitive array)

Recommendation: Use int[] or primitive collection library
```

### Scenario 2: LRU Cache (1000 entries)
```
LinkedHashMap: ~44 bytes √ó 1000 = ~44 KB
TreeMap: ~57 bytes √ó 1000 = ~57 KB

Recommendation: LinkedHashMap (better for LRU)
```

### Scenario 3: Set of Enums
```
HashSet<Enum>: ~36 bytes √ó 7 = ~252 bytes
EnumSet<Enum>: ~1 bit √ó 7 = ~1 byte (256x smaller!)

Recommendation: Always use EnumSet for enums
```

---

## üìö Interview Questions

**Q1: Which collection uses least memory?**
A: ArrayList and PriorityQueue (~4 bytes per element). LinkedList uses most (~40 bytes).

**Q2: Why does LinkedList use more memory?**
A: Each node stores 3 references (prev, next, data) + object overhead = ~40 bytes vs ~4 for ArrayList slot.

**Q3: What is load factor?**
A: Ratio of size to capacity in hash-based collections. Default 0.75 balances performance and memory.

**Q4: How to reduce HashMap memory?**
A: Set initial capacity, increase load factor (0.9), or trim if possible.

**Q5: Why use EnumSet?**
A: Extremely memory efficient - uses bit vector, ~1 bit per enum constant.

**Q6: ArrayList vs int[] for integers?**
A: int[] uses 4 bytes per int. ArrayList<Integer> uses ~20 bytes (16 for Integer object + 4 for array slot).

**Q7: When to use trimToSize()?**
A: After bulk operations when you know collection won't grow further. Saves wasted capacity.

**Q8: TreeSet vs HashSet memory?**
A: TreeSet uses more (~49 vs ~36 bytes per element) due to tree node overhead.

---

## üìö Summary

- **ArrayList**: Most memory efficient (~4 bytes per element)
- **LinkedList**: Least efficient (~40 bytes per element)
- **Hash collections**: Medium efficiency (~36-44 bytes)
- **Tree collections**: High overhead (~49-57 bytes)
- **Optimization**: Set initial capacity, trim excess, use primitives
- **Load factor**: Higher = less memory, more collisions
- **EnumSet/EnumMap**: Extremely efficient for enums
- **Best practice**: Choose collection based on memory constraints
