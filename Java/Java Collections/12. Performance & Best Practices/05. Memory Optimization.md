# üöÄ Memory Optimization

## üìñ Overview

**Memory optimization** reduces RAM usage and improves garbage collection. Key strategies:
- Choose memory-efficient collections
- Set proper initial capacity
- Avoid memory leaks
- Use primitives when possible
- Trim excess capacity

---

## üìä Collection Memory Comparison

```
Storage per Element (approximate):

ArrayList:        ~4 bytes (array slot)
LinkedList:       ~40 bytes (Node: data, prev, next, overhead)
HashSet:          ~36 bytes (Entry: key, hash, next, overhead)
TreeSet:          ~49 bytes (Node: data, parent, left, right, color)
HashMap:          ~44 bytes (Entry: key, value, hash, next)
TreeMap:          ~57 bytes (Node: key, value, parent, left, right, color)
PriorityQueue:    ~4 bytes (array slot)
ArrayDeque:       ~4 bytes (array slot)
EnumSet:          ~1 bit (bit vector!)
```

---

## üí° Optimization Strategies

### 1. Choose Memory-Efficient Collections

#### ‚ùå High Memory Usage
```java
// LinkedList: ~40 bytes per element
List<String> list = new LinkedList<>();
for (int i = 0; i < 100000; i++) {
    list.add("item" + i);
}
// Memory: ~4 MB
```

#### ‚úÖ Low Memory Usage
```java
// ArrayList: ~4 bytes per element
List<String> list = new ArrayList<>(100000);
for (int i = 0; i < 100000; i++) {
    list.add("item" + i);
}
// Memory: ~400 KB
```

---

### 2. Set Initial Capacity

#### ‚ùå Multiple Resizes
```java
// Grows: 10 ‚Üí 15 ‚Üí 22 ‚Üí 33 ‚Üí ... ‚Üí 163840
// Wastes memory during growth
List<String> list = new ArrayList<>();
for (int i = 0; i < 100000; i++) {
    list.add("item");
}
```

#### ‚úÖ Single Allocation
```java
// Allocate exactly what's needed
List<String> list = new ArrayList<>(100000);
for (int i = 0; i < 100000; i++) {
    list.add("item");
}
// No wasted capacity!
```

---

### 3. Trim Excess Capacity

#### ‚ùå Wasted Space
```java
List<String> list = new ArrayList<>(10000);
// Add 100 items
for (int i = 0; i < 100; i++) {
    list.add("item");
}
// Wasting 9,900 slots!
```

#### ‚úÖ Trim to Size
```java
List<String> list = new ArrayList<>(10000);
for (int i = 0; i < 100; i++) {
    list.add("item");
}
list.trimToSize();  // Reduce capacity to 100
```

---

### 4. Use Primitive Collections (Third-party)

#### ‚ùå Boxed Primitives
```java
// Integer: 16 bytes each
List<Integer> list = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    list.add(i);
}
// Memory: ~16 MB (boxed) + ~4 MB (array) = 20 MB
```

#### ‚úÖ Primitive Array
```java
// int: 4 bytes each
int[] array = new int[1000000];
for (int i = 0; i < 1000000; i++) {
    array[i] = i;
}
// Memory: ~4 MB
```

#### ‚úÖ Primitive Collections (Libraries)
```java
// Use libraries like Trove, FastUtil, Eclipse Collections
// TIntArrayList (Trove)
// IntArrayList (FastUtil)
// IntList (Eclipse Collections)

// Example (conceptual):
// IntArrayList list = new IntArrayList();
// for (int i = 0; i < 1000000; i++) {
//     list.add(i);
// }
// Memory: ~4 MB (no boxing!)
```

---

### 5. Use EnumSet/EnumMap for Enums

#### ‚ùå HashSet for Enums
```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// HashSet: ~36 bytes per element
Set<Day> days = new HashSet<>();
days.add(Day.MON);
days.add(Day.TUE);
days.add(Day.WED);
// Memory: ~108 bytes
```

#### ‚úÖ EnumSet for Enums
```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// EnumSet: ~1 bit per element!
Set<Day> days = EnumSet.of(Day.MON, Day.TUE, Day.WED);
// Memory: ~8 bytes (entire set as bit vector!)
// 13x more efficient!
```

---

### 6. Choose Right Load Factor

#### ‚ùå Low Load Factor (More Memory)
```java
// Load factor 0.5: High memory usage
Map<String, Integer> map = new HashMap<>(1000, 0.5f);
// With 500 elements, capacity = 1000
// Wasting 500 slots
```

#### ‚úÖ Higher Load Factor (Less Memory)
```java
// Load factor 0.9: Lower memory usage
Map<String, Integer> map = new HashMap<>(1000, 0.9f);
// With 900 elements, capacity = 1000
// Only wasting 100 slots
```

#### ‚öñÔ∏è Balanced (Default)
```java
// Load factor 0.75: Good balance
Map<String, Integer> map = new HashMap<>(1000);  // 0.75 default
```

---

### 7. Clear References Properly

#### ‚ùå Memory Leak
```java
public class Stack<E> {
    private E[] elements;
    private int size;
    
    public E pop() {
        if (size == 0) return null;
        return elements[--size];  // ‚ùå Old reference still in array!
    }
}
```

#### ‚úÖ Clear References
```java
public class Stack<E> {
    private E[] elements;
    private int size;
    
    public E pop() {
        if (size == 0) return null;
        E element = elements[--size];
        elements[size] = null;  // ‚úÖ Clear for GC
        return element;
    }
}
```

---

### 8. Avoid Sublist Memory Leaks

#### ‚ùå Retains Parent List
```java
List<String> hugeList = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    hugeList.add("item" + i);
}

// subList holds reference to entire hugeList!
List<String> subList = hugeList.subList(0, 10);
hugeList = null;  // ‚ùå Still in memory!
```

#### ‚úÖ Create Independent Copy
```java
List<String> hugeList = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    hugeList.add("item" + i);
}

// Create copy
List<String> subList = new ArrayList<>(hugeList.subList(0, 10));
hugeList = null;  // ‚úÖ Can be garbage collected
```

---

### 9. Use Weak/Soft References

#### ‚ùå Strong References (Prevents GC)
```java
Map<Key, LargeObject> cache = new HashMap<>();
cache.put(key, largeObject);
// LargeObject won't be GC'd even if memory is low
```

#### ‚úÖ Weak/Soft References
```java
// WeakHashMap: Keys can be GC'd when not used
Map<Key, LargeObject> cache = new WeakHashMap<>();

// Or use SoftReference for values
Map<Key, SoftReference<LargeObject>> cache = new HashMap<>();
cache.put(key, new SoftReference<>(largeObject));
// LargeObject can be GC'd if memory is low
```

---

### 10. Minimize Object Creation

#### ‚ùå Creating Objects in Loop
```java
// Creates 1,000,000 StringBuilder objects!
for (int i = 0; i < 1000000; i++) {
    String result = new StringBuilder()
        .append("prefix")
        .append(i)
        .append("suffix")
        .toString();
}
```

#### ‚úÖ Reuse Objects
```java
// Reuse single StringBuilder
StringBuilder sb = new StringBuilder(20);
for (int i = 0; i < 1000000; i++) {
    sb.setLength(0);  // Clear
    sb.append("prefix").append(i).append("suffix");
    String result = sb.toString();
}
```

---

## üìä Memory Optimization Scenarios

### Scenario 1: Large Integer List
```java
// ‚ùå ArrayList<Integer>: ~20 MB
List<Integer> list = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    list.add(i);
}

// ‚úÖ int[]: ~4 MB (5x better!)
int[] array = new int[1000000];
for (int i = 0; i < 1000000; i++) {
    array[i] = i;
}

// ‚úÖ Or use primitive collection library
// Memory: ~4 MB (same as array, with List interface)
```

---

### Scenario 2: Cache with Size Limit
```java
// ‚úÖ LRU Cache with automatic eviction
Map<Integer, String> cache = new LinkedHashMap<Integer, String>(16, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 1000;  // Max 1000 entries
    }
};

// Memory controlled, old entries auto-removed
```

---

### Scenario 3: Set of Enum Values
```java
enum Status { PENDING, PROCESSING, COMPLETED, FAILED }

// ‚ùå HashSet: ~144 bytes
Set<Status> statuses = new HashSet<>();
statuses.add(Status.PENDING);
statuses.add(Status.PROCESSING);
statuses.add(Status.COMPLETED);
statuses.add(Status.FAILED);

// ‚úÖ EnumSet: ~8 bytes (18x better!)
Set<Status> statuses = EnumSet.allOf(Status.class);
```

---

### Scenario 4: Temporary Collections
```java
// ‚ùå Creates ArrayList, then converts to array
List<String> temp = new ArrayList<>();
temp.add("a");
temp.add("b");
temp.add("c");
String[] array = temp.toArray(new String[0]);

// ‚úÖ Use array directly
String[] array = new String[3];
array[0] = "a";
array[1] = "b";
array[2] = "c";

// Or
String[] array = {"a", "b", "c"};
```

---

## ‚ö†Ô∏è Common Memory Waste Patterns

### 1. Over-allocated Collections
```java
// Allocate 1,000,000 but use 10
List<String> list = new ArrayList<>(1000000);
list.add("one");
list.add("two");
// Wasting 999,998 slots!

// ‚úÖ Use reasonable estimate
List<String> list = new ArrayList<>(100);
```

---

### 2. String Concatenation
```java
// ‚ùå Creates many temporary strings
String result = "";
for (int i = 0; i < 10000; i++) {
    result += i + ",";  // 10,000 String objects!
}

// ‚úÖ Use StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i).append(",");
}
String result = sb.toString();
```

---

### 3. Boxed Primitives in Collections
```java
// ‚ùå Each Double: 24 bytes
List<Double> values = new ArrayList<>();
for (int i = 0; i < 100000; i++) {
    values.add(Math.random());
}
// Memory: ~2.4 MB (boxed) + overhead

// ‚úÖ Primitive array: 8 bytes each
double[] values = new double[100000];
for (int i = 0; i < 100000; i++) {
    values[i] = Math.random();
}
// Memory: ~800 KB
```

---

### 4. Not Removing from Collections
```java
// ‚ùå Memory leak: never removes
Map<User, Session> sessions = new HashMap<>();
public void login(User user) {
    sessions.put(user, new Session());
    // Sessions accumulate forever!
}

// ‚úÖ Remove when done
public void logout(User user) {
    sessions.remove(user);
}

// Or use expiring cache
```

---

## üí° Best Practices

1. **Prefer ArrayList over LinkedList** (10x less memory)
2. **Set initial capacity** when size is known
3. **Trim collections** after bulk operations
4. **Use primitives** instead of boxed types
5. **EnumSet/EnumMap** for enums (256x more efficient)
6. **Clear references** to enable GC
7. **Copy sublists** to avoid retaining parent
8. **Higher load factor** for memory-constrained scenarios
9. **WeakHashMap** for caches
10. **Monitor memory** with profilers

---

## üîß Tools for Memory Analysis

### 1. JVisualVM
```bash
# Monitor heap usage, GC activity
jvisualvm
```

### 2. Java Mission Control
```bash
# Detailed memory profiling
jmc
```

### 3. Eclipse Memory Analyzer (MAT)
```bash
# Analyze heap dumps
# File ‚Üí Open Heap Dump
```

### 4. JVM Flags
```bash
# Print GC details
java -XX:+PrintGCDetails -XX:+PrintGCTimeStamps YourApp

# Generate heap dump on OutOfMemoryError
java -XX:+HeapDumpOnOutOfMemoryError YourApp
```

---

## üìö Interview Questions

**Q1: Which collection uses least memory?**
A: ArrayList and PriorityQueue (~4 bytes per element). LinkedList uses most (~40 bytes).

**Q2: How to reduce HashMap memory?**
A: Set initial capacity, increase load factor, or use primitive key/value libraries.

**Q3: Why use EnumSet?**
A: Extremely efficient - uses bit vector (~1 bit per enum vs ~36 bytes for HashSet).

**Q4: What's trimToSize()?**
A: Reduces ArrayList capacity to match size, freeing wasted space.

**Q5: Memory leak with subList?**
A: subList() returns view of parent list, keeping entire parent in memory. Create copy instead.

**Q6: ArrayList<Integer> vs int[]?**
A: int[] is 5x more efficient (~4 bytes vs ~20 bytes per element with boxing overhead).

**Q7: When to use WeakHashMap?**
A: For caches where entries can be GC'd when keys are no longer used elsewhere.

**Q8: Best practices for memory optimization?**
A: Choose right collection, set capacity, use primitives, clear references, monitor with profilers.

---

## üìö Summary

- **ArrayList > LinkedList**: 10x less memory
- **Set initial capacity**: Avoid resizes
- **trimToSize()**: Free excess capacity
- **Primitives > Boxed**: 5x less memory
- **EnumSet > HashSet**: 256x less memory for enums
- **Clear references**: Enable garbage collection
- **Copy sublists**: Avoid parent retention
- **Higher load factor**: Use memory efficiently
- **WeakHashMap**: For caches
- **Profile regularly**: Use JVisualVM, MAT
