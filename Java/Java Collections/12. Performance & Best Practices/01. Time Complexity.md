# ‚è±Ô∏è Time Complexity

## üìñ Overview

Understanding **time complexity** helps choose the right collection for your use case. Operations have different performance characteristics.

**Big O Notation:**
- **O(1)** - Constant time (instant)
- **O(log n)** - Logarithmic (very fast)
- **O(n)** - Linear (proportional to size)
- **O(n log n)** - Log-linear (efficient sorting)
- **O(n¬≤)** - Quadratic (slow for large data)

---

## üìä ArrayList Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(1) amortized | O(n) when resize needed |
| **add(int, E)** | O(n) | Shift elements right |
| **get(int)** | O(1) | Direct array access |
| **set(int, E)** | O(1) | Direct array access |
| **remove(int)** | O(n) | Shift elements left |
| **remove(Object)** | O(n) | Search + shift |
| **contains(Object)** | O(n) | Linear search |
| **indexOf(Object)** | O(n) | Linear search |
| **clear()** | O(n) | Clear all references |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Random access (get/set by index)
- Add to end
- Iterate through elements

**Avoid When:**
- Frequent insertions/deletions at start/middle
- Need fast search

---

## üìä LinkedList Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(1) | Add to tail |
| **addFirst(E)** | O(1) | Add to head |
| **addLast(E)** | O(1) | Add to tail |
| **add(int, E)** | O(n) | Traverse to index |
| **get(int)** | O(n) | Traverse to index |
| **set(int, E)** | O(n) | Traverse to index |
| **remove()** | O(1) | Remove from head |
| **removeFirst()** | O(1) | Remove from head |
| **removeLast()** | O(1) | Remove from tail |
| **remove(int)** | O(n) | Traverse to index |
| **contains(Object)** | O(n) | Linear search |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Frequent insertions/deletions at ends
- Queue/Deque operations
- Iterator-based modifications

**Avoid When:**
- Random access needed
- Frequent indexed operations

---

## üìä HashSet Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(1) average | O(n) worst (collisions) |
| **remove(Object)** | O(1) average | O(n) worst case |
| **contains(Object)** | O(1) average | O(n) worst case |
| **clear()** | O(n) | Clear all buckets |
| **size()** | O(1) | Return size field |
| **isEmpty()** | O(1) | Check size |
| **iterator()** | O(h + n) | h = capacity, n = size |

**Best Use Cases:**
- Fast membership testing
- Remove duplicates
- No ordering needed

**Avoid When:**
- Need sorted order
- Need ordering by insertion

---

## üìä TreeSet Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(log n) | Balanced tree insertion |
| **remove(Object)** | O(log n) | Balanced tree deletion |
| **contains(Object)** | O(log n) | Binary search |
| **first()** | O(log n) | Find minimum |
| **last()** | O(log n) | Find maximum |
| **ceiling(E)** | O(log n) | Smallest >= element |
| **floor(E)** | O(log n) | Largest <= element |
| **size()** | O(1) | Return size field |
| **clear()** | O(n) | Remove all nodes |

**Best Use Cases:**
- Need sorted order
- Range queries
- Ceiling/floor operations

**Avoid When:**
- Just need uniqueness (use HashSet)
- Performance critical (HashSet faster)

---

## üìä LinkedHashSet Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **add(E)** | O(1) average | HashMap + linked list |
| **remove(Object)** | O(1) average | HashMap + linked list |
| **contains(Object)** | O(1) average | HashMap lookup |
| **iterator()** | O(n) | Follow insertion order |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Need uniqueness + insertion order
- Predictable iteration order

---

## üìä HashMap Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **put(K, V)** | O(1) average | O(n) worst (collisions) |
| **get(K)** | O(1) average | O(n) worst case |
| **remove(K)** | O(1) average | O(n) worst case |
| **containsKey(K)** | O(1) average | O(n) worst case |
| **containsValue(V)** | O(n) | Must scan all entries |
| **keySet()** | O(1) | Return view |
| **values()** | O(1) | Return view |
| **entrySet()** | O(1) | Return view |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Fast key-based lookups
- Caching
- Frequency counting

**Avoid When:**
- Need sorted keys (use TreeMap)
- Need insertion order (use LinkedHashMap)

---

## üìä TreeMap Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **put(K, V)** | O(log n) | Balanced tree insertion |
| **get(K)** | O(log n) | Binary search |
| **remove(K)** | O(log n) | Balanced tree deletion |
| **containsKey(K)** | O(log n) | Binary search |
| **firstKey()** | O(log n) | Find minimum |
| **lastKey()** | O(log n) | Find maximum |
| **ceilingKey(K)** | O(log n) | Smallest >= key |
| **floorKey(K)** | O(log n) | Largest <= key |
| **subMap(K, K)** | O(log n) | Range view |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Need sorted keys
- Range queries on keys
- Navigation operations

---

## üìä LinkedHashMap Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **put(K, V)** | O(1) average | HashMap + linked list |
| **get(K)** | O(1) average | HashMap lookup |
| **remove(K)** | O(1) average | HashMap + unlink |
| **containsKey(K)** | O(1) average | HashMap lookup |
| **keySet()** | O(1) | Return ordered view |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- LRU cache implementation
- Need insertion order + fast lookups

---

## üìä PriorityQueue Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **offer(E)** | O(log n) | Heap insertion |
| **poll()** | O(log n) | Remove min/max |
| **peek()** | O(1) | View min/max |
| **remove(Object)** | O(n) | Linear search + heapify |
| **contains(Object)** | O(n) | Linear search |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Priority-based processing
- Top K elements
- Dijkstra's algorithm

---

## üìä ArrayDeque Time Complexity

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| **addFirst(E)** | O(1) amortized | Add to front |
| **addLast(E)** | O(1) amortized | Add to end |
| **removeFirst()** | O(1) | Remove from front |
| **removeLast()** | O(1) | Remove from end |
| **getFirst()** | O(1) | Peek front |
| **getLast()** | O(1) | Peek end |
| **size()** | O(1) | Return size field |

**Best Use Cases:**
- Stack operations
- Queue operations
- Better than LinkedList for both

---

## ‚ö° Performance Tips

### 1. Choose Right Initial Capacity
```java
// ‚ùå Resize many times
List<String> list = new ArrayList<>();  // Default 10
for (int i = 0; i < 10000; i++) {
    list.add("item" + i);  // Multiple resizes
}

// ‚úÖ Set initial capacity
List<String> list = new ArrayList<>(10000);
for (int i = 0; i < 10000; i++) {
    list.add("item" + i);  // No resizes
}
```

### 2. Use Appropriate Collection
```java
// ‚ùå LinkedList for random access
List<String> list = new LinkedList<>();
for (int i = 0; i < 1000; i++) {
    list.get(i);  // O(n) each time!
}

// ‚úÖ ArrayList for random access
List<String> list = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    list.get(i);  // O(1) each time
}
```

### 3. Avoid containsValue() in Maps
```java
// ‚ùå O(n) operation
if (map.containsValue(value)) {
    // ...
}

// ‚úÖ Maintain reverse map if needed
Map<Value, Key> reverseMap = new HashMap<>();
if (reverseMap.containsKey(value)) {  // O(1)
    // ...
}
```

### 4. Use HashSet for Fast Lookup
```java
// ‚ùå O(n) contains in list
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
if (list.contains("b")) {  // O(n)
    // ...
}

// ‚úÖ O(1) contains in set
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
if (set.contains("b")) {  // O(1)
    // ...
}
```

### 5. Remove During Iteration Carefully
```java
// ‚ùå ConcurrentModificationException
for (String item : list) {
    if (item.equals("remove")) {
        list.remove(item);  // ‚ùå
    }
}

// ‚úÖ Use iterator
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if (it.next().equals("remove")) {
        it.remove();  // ‚úÖ
    }
}
```

---

## üìä Quick Reference Chart

| Need | Use | Why |
|------|-----|-----|
| **Fast random access** | ArrayList | O(1) get/set |
| **Fast insert/delete at ends** | LinkedList/ArrayDeque | O(1) operations |
| **Fast lookup** | HashSet/HashMap | O(1) contains/get |
| **Sorted order** | TreeSet/TreeMap | O(log n) sorted |
| **Insertion order** | LinkedHashSet/LinkedHashMap | O(1) + order |
| **Priority processing** | PriorityQueue | O(log n) heap |
| **Stack** | ArrayDeque | O(1) push/pop |
| **Queue** | ArrayDeque/LinkedList | O(1) offer/poll |
| **LRU cache** | LinkedHashMap | O(1) + access order |

---

## üìö Interview Questions

**Q1: Why is ArrayList.add() O(1) amortized?**
A: Usually O(1), but occasionally O(n) when resizing. Amortized over many operations, it's O(1).

**Q2: When is HashMap O(n)?**
A: Worst case when all keys hash to same bucket (poor hash function or hash collision attack).

**Q3: Why is LinkedList.get(i) slow?**
A: Must traverse from head/tail to index i, taking O(n/2) average time.

**Q4: TreeMap vs HashMap performance?**
A: HashMap is faster: O(1) vs O(log n). Use TreeMap only when sorted keys needed.

**Q5: Why not always use HashMap?**
A: No ordering. Use TreeMap for sorted, LinkedHashMap for insertion order.

**Q6: What's amortized complexity?**
A: Average time per operation over a sequence. E.g., ArrayList add is O(1) amortized despite occasional O(n) resize.

**Q7: Best collection for frequent contains()?**
A: HashSet - O(1) average vs O(n) for List.

**Q8: Why is PriorityQueue.remove(Object) slow?**
A: Must find element (O(n) linear search) then re-heapify.

---

## üìö Summary

- **ArrayList**: O(1) random access, O(n) insert/remove
- **LinkedList**: O(1) at ends, O(n) random access
- **HashSet/HashMap**: O(1) average, fast lookups
- **TreeSet/TreeMap**: O(log n), sorted order
- **PriorityQueue**: O(log n) add/remove, O(1) peek
- **Choose based on operations**: Random access vs insertions vs lookups
- **Initial capacity**: Avoid unnecessary resizes
- **Use right tool**: HashSet for lookups, ArrayList for access, TreeSet for sorting
