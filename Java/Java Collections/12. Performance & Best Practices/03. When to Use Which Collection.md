# ğŸ¯ When to Use Which Collection

## ğŸ“– Overview

Choosing the right collection impacts **performance**, **memory usage**, and **code clarity**. This guide helps you select the optimal collection for your use case.

---

## ğŸ” Decision Tree

```
Need key-value pairs?
â”œâ”€ Yes â†’ Use Map
â”‚  â”œâ”€ Need sorted keys? â†’ TreeMap
â”‚  â”œâ”€ Need insertion order? â†’ LinkedHashMap
â”‚  â””â”€ Just fast lookup? â†’ HashMap
â”‚
â””â”€ No â†’ Need unique elements?
   â”œâ”€ Yes â†’ Use Set
   â”‚  â”œâ”€ Need sorted order? â†’ TreeSet
   â”‚  â”œâ”€ Need insertion order? â†’ LinkedHashSet
   â”‚  â””â”€ Just uniqueness? â†’ HashSet
   â”‚
   â””â”€ No â†’ Use List or Queue
      â”œâ”€ Need indexed access? â†’ ArrayList
      â”œâ”€ Need stack/queue? â†’ ArrayDeque
      â”œâ”€ Need priority? â†’ PriorityQueue
      â””â”€ Frequent insert/delete at ends? â†’ LinkedList
```

---

## ğŸ“‹ List: When to Use

### ArrayList
**Use When:**
- âœ… Random access needed (get/set by index)
- âœ… Mostly adding to end
- âœ… Iterating frequently
- âœ… Memory efficiency important

**Avoid When:**
- âŒ Frequent insertions/deletions at start/middle
- âŒ Need fast insertions at arbitrary positions

```java
// âœ… Perfect use case
List<String> names = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    names.add("Name" + i);  // Add to end: O(1)
}
System.out.println(names.get(500));  // Random access: O(1)
```

---

### LinkedList
**Use When:**
- âœ… Frequent insertions/deletions at ends
- âœ… Implementing queue/deque
- âœ… Iterator-based modifications
- âœ… Don't need random access

**Avoid When:**
- âŒ Need frequent random access
- âŒ Memory efficiency important
- âŒ Iterating by index

```java
// âœ… Perfect use case: Queue
Queue<String> queue = new LinkedList<>();
queue.offer("first");   // O(1)
queue.offer("second");  // O(1)
queue.poll();          // O(1)

// âŒ Bad use case: Random access
LinkedList<String> list = new LinkedList<>();
list.get(500);  // O(n) - Must traverse!
```

---

### Vector
**Use When:**
- âœ… Need thread-safe ArrayList
- âœ… Legacy code compatibility

**Avoid When:**
- âŒ Modern code (use `Collections.synchronizedList()` or `CopyOnWriteArrayList`)
- âŒ Don't need synchronization

```java
// âš ï¸ Legacy
List<String> vector = new Vector<>();

// âœ… Modern alternative
List<String> list = Collections.synchronizedList(new ArrayList<>());
```

---

## ğŸ² Set: When to Use

### HashSet
**Use When:**
- âœ… Need uniqueness
- âœ… Fast membership testing (contains)
- âœ… Order doesn't matter
- âœ… Performance critical

**Avoid When:**
- âŒ Need sorted order
- âŒ Need insertion order
- âŒ Need to iterate in predictable order

```java
// âœ… Perfect use case: Remove duplicates
Set<String> uniqueWords = new HashSet<>();
uniqueWords.add("apple");
uniqueWords.add("banana");
uniqueWords.add("apple");  // Duplicate, not added
System.out.println(uniqueWords.size());  // 2

// Fast contains: O(1)
if (uniqueWords.contains("apple")) {
    // ...
}
```

---

### TreeSet
**Use When:**
- âœ… Need sorted order
- âœ… Need range queries (subSet, headSet, tailSet)
- âœ… Need ceiling/floor operations
- âœ… Elements comparable

**Avoid When:**
- âŒ Just need uniqueness (use HashSet)
- âŒ Performance critical
- âŒ Elements not comparable

```java
// âœ… Perfect use case: Sorted unique numbers
Set<Integer> scores = new TreeSet<>();
scores.add(85);
scores.add(92);
scores.add(78);
System.out.println(scores);  // [78, 85, 92] - sorted!

// Range queries
NavigableSet<Integer> topScores = ((TreeSet<Integer>)scores).tailSet(80);
System.out.println(topScores);  // [85, 92]
```

---

### LinkedHashSet
**Use When:**
- âœ… Need uniqueness + insertion order
- âœ… Need predictable iteration order
- âœ… Building ordered unique collection

**Avoid When:**
- âŒ Order doesn't matter (use HashSet)
- âŒ Need sorted order (use TreeSet)

```java
// âœ… Perfect use case: Maintain order while removing duplicates
Set<String> orderedUnique = new LinkedHashSet<>();
orderedUnique.add("first");
orderedUnique.add("second");
orderedUnique.add("first");  // Duplicate
System.out.println(orderedUnique);  // [first, second] - insertion order!
```

---

## ğŸ—ºï¸ Map: When to Use

### HashMap
**Use When:**
- âœ… Need fast key-value lookups
- âœ… Order doesn't matter
- âœ… Performance critical
- âœ… Caching, frequency counting

**Avoid When:**
- âŒ Need sorted keys
- âŒ Need insertion order

```java
// âœ… Perfect use case: Frequency counter
Map<String, Integer> wordCount = new HashMap<>();
String[] words = {"apple", "banana", "apple", "cherry", "banana"};
for (String word : words) {
    wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
}
System.out.println(wordCount);  // {apple=2, banana=2, cherry=1}
```

---

### TreeMap
**Use When:**
- âœ… Need sorted keys
- âœ… Need range queries on keys
- âœ… Need navigation methods (firstKey, lastKey, etc.)

**Avoid When:**
- âŒ Just need fast lookups (use HashMap)
- âŒ Keys not comparable

```java
// âœ… Perfect use case: Sorted leaderboard
Map<Integer, String> leaderboard = new TreeMap<>(Collections.reverseOrder());
leaderboard.put(95, "Alice");
leaderboard.put(87, "Bob");
leaderboard.put(92, "Charlie");
System.out.println(leaderboard);  // {95=Alice, 92=Charlie, 87=Bob} - sorted by key!

// Range queries
NavigableMap<Integer, String> topPlayers = ((TreeMap<Integer, String>)leaderboard).headMap(93);
```

---

### LinkedHashMap
**Use When:**
- âœ… Need fast lookups + insertion order
- âœ… Implementing LRU cache
- âœ… Need predictable iteration order

**Avoid When:**
- âŒ Order doesn't matter (use HashMap)
- âŒ Need sorted order (use TreeMap)

```java
// âœ… Perfect use case: LRU Cache
Map<Integer, String> lruCache = new LinkedHashMap<>(16, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 100;  // Max 100 entries
    }
};

lruCache.put(1, "one");
lruCache.put(2, "two");
lruCache.get(1);  // Access order updated
```

---

### Hashtable
**Use When:**
- âœ… Legacy code compatibility

**Avoid When:**
- âŒ Modern code (use HashMap or ConcurrentHashMap)

```java
// âš ï¸ Legacy
Map<String, Integer> table = new Hashtable<>();

// âœ… Modern alternatives
Map<String, Integer> map = new HashMap<>();
Map<String, Integer> concurrent = new ConcurrentHashMap<>();
```

---

## ğŸ¯ Queue: When to Use

### ArrayDeque
**Use When:**
- âœ… Need stack operations (LIFO)
- âœ… Need queue operations (FIFO)
- âœ… Don't need indexed access
- âœ… Performance critical

**Avoid When:**
- âŒ Need random access
- âŒ Need thread-safety

```java
// âœ… Perfect use case: Stack
Deque<String> stack = new ArrayDeque<>();
stack.push("first");
stack.push("second");
stack.pop();  // "second"

// Perfect use case: Queue
Deque<String> queue = new ArrayDeque<>();
queue.offer("first");
queue.offer("second");
queue.poll();  // "first"
```

---

### PriorityQueue
**Use When:**
- âœ… Need priority-based processing
- âœ… Finding top K elements
- âœ… Implementing algorithms (Dijkstra, Huffman)
- âœ… Task scheduling

**Avoid When:**
- âŒ Need FIFO order
- âŒ Need random access

```java
// âœ… Perfect use case: Task scheduling by priority
PriorityQueue<Task> taskQueue = new PriorityQueue<>(
    (a, b) -> b.priority - a.priority  // High priority first
);

taskQueue.offer(new Task("Low priority", 1));
taskQueue.offer(new Task("High priority", 10));
taskQueue.offer(new Task("Medium priority", 5));

while (!taskQueue.isEmpty()) {
    Task task = taskQueue.poll();  // Gets highest priority
    System.out.println(task);
}
```

---

### LinkedList (as Queue)
**Use When:**
- âœ… Need both queue and list operations
- âœ… Need to iterate while removing

**Avoid When:**
- âŒ Just need queue (use ArrayDeque - faster)

```java
// âš ï¸ Works but not optimal
Queue<String> queue = new LinkedList<>();

// âœ… Better
Queue<String> queue = new ArrayDeque<>();
```

---

## ğŸ¨ Specialized Collections

### EnumSet
**Use When:**
- âœ… Working with enum values
- âœ… Need set operations on enums

```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// âœ… Perfect for enums - extremely efficient
Set<Day> workDays = EnumSet.of(Day.MON, Day.TUE, Day.WED, Day.THU, Day.FRI);
Set<Day> weekend = EnumSet.of(Day.SAT, Day.SUN);
```

---

### EnumMap
**Use When:**
- âœ… Keys are enum values
- âœ… Need fast, memory-efficient map

```java
enum Size { SMALL, MEDIUM, LARGE }

// âœ… Perfect for enum keys
Map<Size, Integer> inventory = new EnumMap<>(Size.class);
inventory.put(Size.SMALL, 50);
inventory.put(Size.MEDIUM, 30);
inventory.put(Size.LARGE, 20);
```

---

## ğŸ“Š Quick Selection Guide

| Requirement | Collection | Reason |
|-------------|-----------|--------|
| **Random access** | ArrayList | O(1) get/set |
| **Insert/delete at ends** | ArrayDeque | O(1) both ends |
| **Unique elements** | HashSet | O(1) add/contains |
| **Sorted elements** | TreeSet | Auto-sorted |
| **Key-value pairs** | HashMap | O(1) get/put |
| **Sorted keys** | TreeMap | Auto-sorted keys |
| **LRU cache** | LinkedHashMap | Access order |
| **Priority processing** | PriorityQueue | Min/max heap |
| **Stack** | ArrayDeque | O(1) push/pop |
| **Queue** | ArrayDeque | O(1) offer/poll |
| **Enum set** | EnumSet | Bit vector |
| **Enum map** | EnumMap | Array-based |

---

## ğŸ¯ Common Use Cases

### 1. Remove Duplicates
```java
// Input with duplicates
List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Charlie");

// âœ… Use HashSet
Set<String> unique = new HashSet<>(names);
// Result: [Alice, Bob, Charlie]
```

---

### 2. Frequency Counter
```java
// âœ… Use HashMap
Map<String, Integer> frequency = new HashMap<>();
for (String word : words) {
    frequency.put(word, frequency.getOrDefault(word, 0) + 1);
}
```

---

### 3. Sorted Unique Elements
```java
// âœ… Use TreeSet
Set<Integer> sortedUnique = new TreeSet<>(Arrays.asList(5, 2, 8, 2, 1));
// Result: [1, 2, 5, 8]
```

---

### 4. LRU Cache
```java
// âœ… Use LinkedHashMap with access order
Map<Integer, String> cache = new LinkedHashMap<>(16, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > MAX_SIZE;
    }
};
```

---

### 5. Top K Elements
```java
// âœ… Use PriorityQueue (min heap)
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
for (int num : nums) {
    minHeap.offer(num);
    if (minHeap.size() > k) {
        minHeap.poll();  // Remove smallest
    }
}
// minHeap contains top K largest elements
```

---

### 6. Task Queue
```java
// âœ… Use ArrayDeque for FIFO
Queue<Task> taskQueue = new ArrayDeque<>();
taskQueue.offer(task1);
taskQueue.offer(task2);
Task next = taskQueue.poll();
```

---

### 7. Undo Stack
```java
// âœ… Use ArrayDeque as stack
Deque<Action> undoStack = new ArrayDeque<>();
undoStack.push(action1);
undoStack.push(action2);
Action undo = undoStack.pop();
```

---

## âš ï¸ Common Mistakes

### 1. Using LinkedList for Random Access
```java
// âŒ Slow: O(n) for get()
List<String> list = new LinkedList<>();
for (int i = 0; i < 1000; i++) {
    list.get(i);  // O(n) each!
}

// âœ… Fast: O(1) for get()
List<String> list = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    list.get(i);  // O(1)
}
```

---

### 2. Using List for Membership Testing
```java
// âŒ Slow: O(n) contains
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
if (list.contains("b")) {  // O(n)
    // ...
}

// âœ… Fast: O(1) contains
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c"));
if (set.contains("b")) {  // O(1)
    // ...
}
```

---

### 3. Using TreeMap When HashMap Suffices
```java
// âŒ Slower: O(log n)
Map<String, Integer> map = new TreeMap<>();
map.put("key", 1);  // O(log n)
map.get("key");     // O(log n)

// âœ… Faster: O(1)
Map<String, Integer> map = new HashMap<>();
map.put("key", 1);  // O(1)
map.get("key");     // O(1)
```

---

## ğŸ“š Interview Questions

**Q1: ArrayList vs LinkedList?**
A: ArrayList for random access (O(1)), LinkedList for frequent insertions at ends (O(1)).

**Q2: When to use TreeSet over HashSet?**
A: When you need sorted order. TreeSet is O(log n), HashSet is O(1).

**Q3: Best collection for LRU cache?**
A: LinkedHashMap with accessOrder=true. Maintains insertion/access order + O(1) lookups.

**Q4: HashMap vs TreeMap?**
A: HashMap for fast lookups (O(1)), TreeMap for sorted keys (O(log n)).

**Q5: When to use PriorityQueue?**
A: When processing elements by priority, finding top K, or implementing heap-based algorithms.

**Q6: Best collection for stack?**
A: ArrayDeque. Faster than Stack (synchronized) and LinkedList (overhead).

**Q7: When to use EnumSet?**
A: Always for enum values. Extremely memory-efficient (bit vector).

**Q8: LinkedHashMap vs HashMap?**
A: LinkedHashMap maintains insertion order, HashMap doesn't. Use LinkedHashMap when order matters.

---

## ğŸ“š Summary

- **Random access**: ArrayList (O(1))
- **Insert at ends**: ArrayDeque (O(1))
- **Unique + fast**: HashSet (O(1))
- **Unique + sorted**: TreeSet (O(log n))
- **Key-value + fast**: HashMap (O(1))
- **Key-value + sorted**: TreeMap (O(log n))
- **Priority**: PriorityQueue (O(log n))
- **LRU cache**: LinkedHashMap (access order)
- **Enums**: EnumSet/EnumMap (extremely efficient)
- **Choose based on**: Access pattern, ordering needs, performance requirements
