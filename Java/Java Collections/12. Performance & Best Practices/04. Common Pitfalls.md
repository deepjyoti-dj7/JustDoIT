# ‚ö†Ô∏è Common Pitfalls

## üìñ Overview

Avoid these **common mistakes** when working with Java Collections. Understanding these pitfalls prevents bugs and performance issues.

---

## 1Ô∏è‚É£ Modifying Collection During Iteration

### ‚ùå Problem
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c", "d"));

// ConcurrentModificationException!
for (String item : list) {
    if (item.equals("b")) {
        list.remove(item);  // ‚ùå Modifies during iteration
    }
}
```

### ‚úÖ Solutions
```java
// Solution 1: Use Iterator.remove()
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (item.equals("b")) {
        it.remove();  // ‚úÖ Safe
    }
}

// Solution 2: removeIf() (Java 8+)
list.removeIf(item -> item.equals("b"));  // ‚úÖ Best

// Solution 3: Copy and iterate
List<String> toRemove = new ArrayList<>();
for (String item : list) {
    if (item.equals("b")) {
        toRemove.add(item);
    }
}
list.removeAll(toRemove);  // ‚úÖ Works
```

---

## 2Ô∏è‚É£ Using Wrong Collection Type

### ‚ùå Problem: LinkedList for Random Access
```java
List<String> list = new LinkedList<>();
for (int i = 0; i < 1000; i++) {
    list.add("item" + i);
}

// O(n) for each get() - SLOW!
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));  // ‚ùå O(n¬≤) total
}
```

### ‚úÖ Solution: Use ArrayList
```java
List<String> list = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    list.add("item" + i);
}

// O(1) for each get() - FAST!
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));  // ‚úÖ O(n) total
}
```

---

## 3Ô∏è‚É£ Not Setting Initial Capacity

### ‚ùå Problem: Multiple Resizes
```java
// Resizes: 10 ‚Üí 15 ‚Üí 22 ‚Üí 33 ‚Üí 49 ‚Üí 73 ‚Üí 109 ‚Üí 163 ‚Üí ...
List<String> list = new ArrayList<>();  // Default capacity 10
for (int i = 0; i < 10000; i++) {
    list.add("item" + i);  // Multiple expensive resizes
}
```

### ‚úÖ Solution: Set Initial Capacity
```java
// Single allocation
List<String> list = new ArrayList<>(10000);
for (int i = 0; i < 10000; i++) {
    list.add("item" + i);  // No resizes!
}
```

---

## 4Ô∏è‚É£ Using List.contains() for Frequent Lookups

### ‚ùå Problem: O(n) Contains
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c", ...));

// O(n) linear search each time!
if (list.contains("x")) {  // ‚ùå Slow
    // ...
}
if (list.contains("y")) {  // ‚ùå Slow again
    // ...
}
```

### ‚úÖ Solution: Use HashSet
```java
Set<String> set = new HashSet<>(Arrays.asList("a", "b", "c", ...));

// O(1) hash lookup each time!
if (set.contains("x")) {  // ‚úÖ Fast
    // ...
}
if (set.contains("y")) {  // ‚úÖ Fast
    // ...
}
```

---

## 5Ô∏è‚É£ Not Overriding equals() and hashCode()

### ‚ùå Problem: Objects Not Found
```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // Missing equals() and hashCode()
}

Set<Person> people = new HashSet<>();
people.add(new Person("Alice", 25));

// false! Different object references
System.out.println(people.contains(new Person("Alice", 25)));  // ‚ùå false
```

### ‚úÖ Solution: Override equals() and hashCode()
```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Person)) return false;
        Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

Set<Person> people = new HashSet<>();
people.add(new Person("Alice", 25));

// true! Proper equals() implementation
System.out.println(people.contains(new Person("Alice", 25)));  // ‚úÖ true
```

---

## 6Ô∏è‚É£ Using == Instead of equals()

### ‚ùå Problem: Reference Comparison
```java
String s1 = new String("hello");
String s2 = new String("hello");

// false - different objects
if (s1 == s2) {  // ‚ùå Wrong
    System.out.println("Equal");
}

List<String> list = Arrays.asList("hello");
// false - comparing references
if (list.get(0) == s1) {  // ‚ùå Wrong
    System.out.println("Found");
}
```

### ‚úÖ Solution: Use equals()
```java
String s1 = new String("hello");
String s2 = new String("hello");

// true - content comparison
if (s1.equals(s2)) {  // ‚úÖ Correct
    System.out.println("Equal");
}

List<String> list = Arrays.asList("hello");
// true - content comparison
if (list.contains(s1)) {  // ‚úÖ Correct
    System.out.println("Found");
}
```

---

## 7Ô∏è‚É£ Assuming HashMap Maintains Order

### ‚ùå Problem: Order Not Guaranteed
```java
Map<String, Integer> map = new HashMap<>();
map.put("one", 1);
map.put("two", 2);
map.put("three", 3);

// Unpredictable order!
for (String key : map.keySet()) {
    System.out.println(key);  // May print: two, one, three
}
```

### ‚úÖ Solution: Use LinkedHashMap or TreeMap
```java
// Maintains insertion order
Map<String, Integer> map = new LinkedHashMap<>();
map.put("one", 1);
map.put("two", 2);
map.put("three", 3);

for (String key : map.keySet()) {
    System.out.println(key);  // Prints: one, two, three
}

// Or TreeMap for sorted order
Map<String, Integer> sorted = new TreeMap<>();
sorted.put("one", 1);
sorted.put("two", 2);
sorted.put("three", 3);

for (String key : sorted.keySet()) {
    System.out.println(key);  // Prints: one, three, two (alphabetical)
}
```

---

## 8Ô∏è‚É£ Not Handling Null Properly

### ‚ùå Problem: NullPointerException
```java
List<String> list = Arrays.asList("a", null, "c");

// NPE!
for (String item : list) {
    if (item.equals("b")) {  // ‚ùå NPE when item is null
        System.out.println("Found");
    }
}

Map<String, Integer> map = new HashMap<>();
map.put("key", null);

// NPE!
int value = map.get("key");  // ‚ùå Unboxing null to int
```

### ‚úÖ Solution: Check for Null
```java
List<String> list = Arrays.asList("a", null, "c");

for (String item : list) {
    if (item != null && item.equals("b")) {  // ‚úÖ Safe
        System.out.println("Found");
    }
    // Or use Objects.equals()
    if (Objects.equals(item, "b")) {  // ‚úÖ Null-safe
        System.out.println("Found");
    }
}

Map<String, Integer> map = new HashMap<>();
map.put("key", null);

// Safe retrieval
Integer value = map.get("key");
if (value != null) {
    int v = value;  // ‚úÖ Safe unboxing
}
```

---

## 9Ô∏è‚É£ Using Array.asList() Incorrectly

### ‚ùå Problem: Fixed Size List
```java
List<String> list = Arrays.asList("a", "b", "c");

// UnsupportedOperationException!
list.add("d");  // ‚ùå Cannot add
list.remove("a");  // ‚ùå Cannot remove
```

### ‚úÖ Solution: Create Mutable Copy
```java
// Create mutable ArrayList
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));

list.add("d");  // ‚úÖ Works
list.remove("a");  // ‚úÖ Works

// Or use List.of() and copy (Java 9+)
List<String> immutable = List.of("a", "b", "c");
List<String> mutable = new ArrayList<>(immutable);
```

---

## üîü Using removeAll() Inefficiently

### ‚ùå Problem: O(n¬≤) Performance
```java
List<String> list1 = new ArrayList<>();  // 10,000 elements
List<String> list2 = new ArrayList<>();  // 5,000 elements

// O(n¬≤) - contains() is O(n) for each element
list1.removeAll(list2);  // ‚ùå Very slow!
```

### ‚úÖ Solution: Convert to HashSet
```java
List<String> list1 = new ArrayList<>();  // 10,000 elements
List<String> list2 = new ArrayList<>();  // 5,000 elements

// O(n) - contains() is O(1) for HashSet
list1.removeAll(new HashSet<>(list2));  // ‚úÖ Fast!
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ Comparing Collections with ==

### ‚ùå Problem: Reference Comparison
```java
List<String> list1 = Arrays.asList("a", "b", "c");
List<String> list2 = Arrays.asList("a", "b", "c");

// false - different object references
if (list1 == list2) {  // ‚ùå Wrong
    System.out.println("Equal");
}
```

### ‚úÖ Solution: Use equals()
```java
List<String> list1 = Arrays.asList("a", "b", "c");
List<String> list2 = Arrays.asList("a", "b", "c");

// true - content comparison
if (list1.equals(list2)) {  // ‚úÖ Correct
    System.out.println("Equal");
}
```

---

## 1Ô∏è‚É£2Ô∏è‚É£ Not Using EnumSet/EnumMap for Enums

### ‚ùå Problem: Memory Waste
```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// ~36 bytes per element
Set<Day> days = new HashSet<>();
days.add(Day.MON);
days.add(Day.TUE);
```

### ‚úÖ Solution: Use EnumSet
```java
enum Day { MON, TUE, WED, THU, FRI, SAT, SUN }

// ~1 bit per element - 256x more efficient!
Set<Day> days = EnumSet.of(Day.MON, Day.TUE);
```

---

## 1Ô∏è‚É£3Ô∏è‚É£ Inefficient String Concatenation in Loops

### ‚ùå Problem: O(n¬≤) String Building
```java
String result = "";
for (String item : list) {
    result += item + ", ";  // ‚ùå Creates new String each time
}
```

### ‚úÖ Solution: Use StringBuilder
```java
StringBuilder sb = new StringBuilder();
for (String item : list) {
    sb.append(item).append(", ");  // ‚úÖ Efficient
}
String result = sb.toString();

// Or use String.join()
String result = String.join(", ", list);  // ‚úÖ Best
```

---

## 1Ô∏è‚É£4Ô∏è‚É£ Forgetting to Override Comparable

### ‚ùå Problem: ClassCastException
```java
class Person {
    String name;
    int age;
    // Not implementing Comparable
}

Set<Person> people = new TreeSet<>();
people.add(new Person("Alice", 25));
people.add(new Person("Bob", 30));  // ‚ùå ClassCastException!
```

### ‚úÖ Solution: Implement Comparable or Provide Comparator
```java
class Person implements Comparable<Person> {
    String name;
    int age;
    
    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age);
    }
}

Set<Person> people = new TreeSet<>();
people.add(new Person("Alice", 25));
people.add(new Person("Bob", 30));  // ‚úÖ Works

// Or provide Comparator
Set<Person> people = new TreeSet<>(Comparator.comparing(p -> p.age));
```

---

## 1Ô∏è‚É£5Ô∏è‚É£ Using Vector/Hashtable in Modern Code

### ‚ùå Problem: Unnecessary Synchronization
```java
// Legacy, synchronized (slower)
List<String> list = new Vector<>();
Map<String, Integer> map = new Hashtable<>();
```

### ‚úÖ Solution: Use Modern Alternatives
```java
// Unsynchronized (faster)
List<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();

// Or if thread-safety needed
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>();
```

---

## 1Ô∏è‚É£6Ô∏è‚É£ Memory Leaks with Sublist

### ‚ùå Problem: Retains Original List
```java
List<String> bigList = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    bigList.add("item" + i);
}

// subList holds reference to entire bigList!
List<String> subList = bigList.subList(0, 10);
bigList = null;  // ‚ùå bigList still in memory via subList!
```

### ‚úÖ Solution: Create Copy
```java
List<String> bigList = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    bigList.add("item" + i);
}

// Create independent copy
List<String> subList = new ArrayList<>(bigList.subList(0, 10));
bigList = null;  // ‚úÖ Can be garbage collected
```

---

## üìö Quick Reference: Common Pitfalls

| Pitfall | Problem | Solution |
|---------|---------|----------|
| Modify during iteration | ConcurrentModificationException | Use Iterator.remove() or removeIf() |
| LinkedList for random access | O(n) per get() | Use ArrayList |
| No initial capacity | Multiple resizes | Set initial capacity |
| List.contains() in loop | O(n¬≤) | Use HashSet |
| No equals/hashCode | Objects not found | Override both methods |
| Using == for objects | Reference comparison | Use equals() |
| HashMap iteration order | Unpredictable | Use LinkedHashMap/TreeMap |
| Not checking null | NullPointerException | Check null or use Objects.equals() |
| Arrays.asList() | Fixed size | new ArrayList<>(Arrays.asList()) |
| List.removeAll(List) | O(n¬≤) | Convert to HashSet first |
| HashSet for enums | Memory waste | Use EnumSet |
| String + in loop | O(n¬≤) | Use StringBuilder |
| TreeSet without Comparable | ClassCastException | Implement Comparable |
| Vector/Hashtable | Slow (synchronized) | Use ArrayList/HashMap |
| subList memory leak | Retains parent | Create copy |

---

## üìö Summary

- **Never modify** collection during iteration (use Iterator.remove())
- **Choose right collection**: ArrayList vs LinkedList, List vs Set
- **Set initial capacity** to avoid resizes
- **Use HashSet** for frequent contains() checks
- **Override equals() and hashCode()** for custom objects
- **Use equals()** not == for object comparison
- **LinkedHashMap/TreeMap** for ordered maps
- **Check null** to avoid NPE
- **new ArrayList<>(Arrays.asList())** for mutable list
- **EnumSet/EnumMap** for enums
- **StringBuilder** for string concatenation in loops
- **Modern collections** over Vector/Hashtable
