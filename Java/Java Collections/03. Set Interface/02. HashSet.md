# ğŸ¯ HashSet

## ğŸ“– Overview

`HashSet` is a collection that stores elements in a **hash table**. It provides **constant-time performance** for basic operations and **does not allow duplicates**.

```java
public class HashSet<E> extends AbstractSet<E>
    implements Set<E>, Cloneable, Serializable
```

---

## ğŸ”‘ Key Characteristics

1. **No Duplicates** - Uses `hashCode()` and `equals()` to detect duplicates
2. **Unordered** - Does not maintain any order
3. **Allows Null** - Can contain one null element
4. **Not Synchronized** - Not thread-safe
5. **Fast Performance** - O(1) for add, remove, contains
6. **Backed by HashMap** - Internally uses HashMap

---

## ğŸ’» Creating HashSet

```java
import java.util.*;

// 1. Default constructor - initial capacity 16, load factor 0.75
Set<String> set1 = new HashSet<>();

// 2. With initial capacity
Set<String> set2 = new HashSet<>(20);

// 3. With capacity and load factor
Set<String> set3 = new HashSet<>(20, 0.8f);

// 4. From another collection
List<String> list = Arrays.asList("A", "B", "C", "A");
Set<String> set4 = new HashSet<>(list);  // [A, B, C]

// 5. Using Set.of() - Immutable (Java 9+)
Set<String> set5 = Set.of("X", "Y", "Z");
```

---

## ğŸ¨ Basic Operations

```java
public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> fruits = new HashSet<>();
        
        // Add elements
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Apple");  // Duplicate - returns false
        
        System.out.println(fruits);  // [Apple, Cherry, Banana] (order may vary)
        
        // Check size
        System.out.println("Size: " + fruits.size());  // 3
        
        // Check existence
        System.out.println(fruits.contains("Banana"));  // true
        
        // Remove element
        fruits.remove("Banana");
        System.out.println(fruits);  // [Apple, Cherry]
        
        // Add null
        fruits.add(null);
        System.out.println(fruits);  // [null, Apple, Cherry]
        
        // Check empty
        System.out.println(fruits.isEmpty());  // false
        
        // Clear all
        fruits.clear();
        System.out.println(fruits.isEmpty());  // true
    }
}
```

---

## ğŸ”„ Iteration

```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C", "D"));

// 1. For-each loop
for (String item : set) {
    System.out.println(item);
}

// 2. Iterator
Iterator<String> iterator = set.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    System.out.println(item);
    // Can remove during iteration
    if (item.equals("B")) {
        iterator.remove();
    }
}

// 3. Java 8 forEach
set.forEach(item -> System.out.println(item));

// 4. Java 8 Stream
set.stream()
   .filter(s -> s.startsWith("A"))
   .forEach(System.out::println);
```

---

## ğŸ—ï¸ Internal Structure

```java
// HashSet internally uses HashMap
public class HashSet<E> {
    private transient HashMap<E, Object> map;
    private static final Object PRESENT = new Object();
    
    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }
    
    public boolean remove(Object o) {
        return map.remove(o) == PRESENT;
    }
    
    public boolean contains(Object o) {
        return map.containsKey(o);
    }
}
```

**Key Points:**
- Elements stored as keys in HashMap
- Dummy value `PRESENT` for all keys
- Uses HashMap's hashing mechanism
- Default capacity: 16
- Default load factor: 0.75

---

## ğŸ“Š Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `add(E e)` | O(1) | Average case |
| `remove(Object o)` | O(1) | Average case |
| `contains(Object o)` | O(1) | Average case |
| `size()` | O(1) | |
| Iteration | O(n) | n = capacity + size |

**Load Factor Impact:**
- Low load factor (0.5): Less collision, more memory
- High load factor (0.9): More collision, less memory
- Default (0.75): Good balance

---

## ğŸ“ Custom Objects

```java
class Student {
    private int id;
    private String name;
    
    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    // MUST override equals and hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return id == student.id && Objects.equals(name, student.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
    
    @Override
    public String toString() {
        return name + "(" + id + ")";
    }
}

public class CustomObjectDemo {
    public static void main(String[] args) {
        Set<Student> students = new HashSet<>();
        
        students.add(new Student(1, "Alice"));
        students.add(new Student(2, "Bob"));
        students.add(new Student(1, "Alice"));  // Duplicate - not added
        
        System.out.println(students.size());  // 2
        System.out.println(students);  // [Alice(1), Bob(2)]
    }
}
```

---

## ğŸ”§ Bulk Operations

```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));

// addAll - Union
Set<Integer> union = new HashSet<>(set1);
union.addAll(set2);
System.out.println("Union: " + union);  // [1, 2, 3, 4, 5, 6, 7, 8]

// retainAll - Intersection
Set<Integer> intersection = new HashSet<>(set1);
intersection.retainAll(set2);
System.out.println("Intersection: " + intersection);  // [4, 5]

// removeAll - Difference
Set<Integer> difference = new HashSet<>(set1);
difference.removeAll(set2);
System.out.println("Difference: " + difference);  // [1, 2, 3]

// containsAll - Subset check
Set<Integer> subset = new HashSet<>(Arrays.asList(1, 2));
System.out.println("Is subset? " + set1.containsAll(subset));  // true
```

---

## ğŸ¯ Java 8+ Features

```java
Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));

// forEach
numbers.forEach(n -> System.out.println(n * 2));

// removeIf
numbers.removeIf(n -> n % 2 == 0);  // Remove even numbers
System.out.println(numbers);  // [1, 3, 5]

// Stream operations
numbers.stream()
       .filter(n -> n > 2)
       .map(n -> n * 10)
       .forEach(System.out::println);  // 30, 50

// Parallel stream
long count = numbers.parallelStream()
                    .filter(n -> n > 2)
                    .count();
```

---

## âš ï¸ Common Pitfalls

```java
// 1. Not overriding equals and hashCode
class Person {
    String name;
    // No equals/hashCode
}
Set<Person> set = new HashSet<>();
set.add(new Person("John"));
set.add(new Person("John"));  // Treated as different!
System.out.println(set.size());  // 2 âŒ

// 2. Modifying objects in HashSet
class MutablePerson {
    String name;
    public void setName(String name) { this.name = name; }
    // equals/hashCode based on name
}
Set<MutablePerson> set = new HashSet<>();
MutablePerson p = new MutablePerson("Alice");
set.add(p);
p.setName("Bob");  // âš ï¸ Breaks hashCode contract!
System.out.println(set.contains(p));  // false (cannot find)

// 3. ConcurrentModificationException
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
for (String s : set) {
    if (s.equals("B")) {
        set.remove(s);  // âŒ Exception
    }
}

// âœ… Use Iterator or removeIf
set.removeIf(s -> s.equals("B"));
```

---

## ğŸ†š When to Use HashSet

**Use HashSet when:**
- âœ… Need fast add/remove/contains operations
- âœ… Order doesn't matter
- âœ… No duplicates required
- âœ… Working with unique elements
- âœ… Membership testing (contains)

**Don't use HashSet when:**
- âŒ Need to maintain insertion order â†’ Use `LinkedHashSet`
- âŒ Need sorted elements â†’ Use `TreeSet`
- âŒ Need thread-safety â†’ Use `CopyOnWriteArraySet` or synchronize
- âŒ Need indexed access â†’ Use `List`
- âŒ Working with enums â†’ Use `EnumSet`

---

## ğŸ” HashSet vs HashMap

```java
// HashSet uses HashMap internally
HashSet<String> set = new HashSet<>();
set.add("Apple");
// Internally: map.put("Apple", PRESENT);

HashMap<String, Object> map = new HashMap<>();
map.put("Apple", PRESENT);

// HashSet is a wrapper around HashMap keys
```

| Feature | HashSet | HashMap |
|---------|---------|---------|
| Storage | Keys only | Key-Value pairs |
| Duplicates | No duplicate keys | No duplicate keys, duplicate values OK |
| Null | One null key | One null key, multiple null values |
| Usage | Unique elements | Mapping relationships |

---

## ğŸ’¡ Best Practices

1. **Override equals() and hashCode()** for custom objects
2. **Use immutable objects** as elements
3. **Initialize with capacity** if size is known: `new HashSet<>(expectedSize)`
4. **Use Set.of()** for small immutable sets
5. **Don't modify objects** after adding to HashSet
6. **Use removeIf()** instead of removing during iteration
7. **Consider load factor** for memory vs performance trade-off

---

## ğŸ¯ Real-World Examples

```java
// 1. Remove duplicates from list
List<String> listWithDuplicates = Arrays.asList("A", "B", "A", "C", "B");
Set<String> uniqueElements = new HashSet<>(listWithDuplicates);
System.out.println(uniqueElements);  // [A, B, C]

// 2. Check for common elements
Set<String> team1 = new HashSet<>(Arrays.asList("Alice", "Bob", "Charlie"));
Set<String> team2 = new HashSet<>(Arrays.asList("Bob", "David", "Eve"));
team1.retainAll(team2);
System.out.println("Common members: " + team1);  // [Bob]

// 3. Unique word counter
String text = "hello world hello java world";
String[] words = text.split(" ");
Set<String> uniqueWords = new HashSet<>(Arrays.asList(words));
System.out.println("Unique words: " + uniqueWords.size());  // 3

// 4. Check duplicates exist
List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4);
boolean hasDuplicates = numbers.size() != new HashSet<>(numbers).size();
System.out.println("Has duplicates? " + hasDuplicates);  // true

// 5. Find missing elements
Set<Integer> expected = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
Set<Integer> actual = new HashSet<>(Arrays.asList(1, 3, 5));
expected.removeAll(actual);
System.out.println("Missing: " + expected);  // [2, 4]
```

---

## ğŸ“š Summary

- **HashSet**: Fast, unordered, no duplicates, allows null
- Backed by **HashMap** internally
- **O(1)** performance for basic operations
- **Must override** `equals()` and `hashCode()` for custom objects
- **Not thread-safe** - use synchronization or `CopyOnWriteArraySet`
- **Default choice** for unique element storage when order doesn't matter
- **Load factor** 0.75 balances time and space complexity
