# ğŸ¯ Set Comparisons

## ğŸ“Š Complete Comparison Matrix

| Feature | HashSet | LinkedHashSet | TreeSet | EnumSet | CopyOnWriteArraySet |
|---------|---------|---------------|---------|---------|---------------------|
| **Order** | No order | Insertion order | Sorted (natural/comparator) | Enum order | Insertion order |
| **Performance (add/remove/contains)** | O(1) | O(1) | O(log n) | O(1) | O(n) |
| **Iteration** | O(capacity) | O(size) | O(n) | O(n) | O(n) |
| **Null allowed** | Yes (one) | Yes (one) | No | No | Yes (one) |
| **Thread-safe** | No | No | No | No | Yes |
| **Memory** | Moderate | More (linked list) | More (tree) | Least (bit vector) | Most (copy array) |
| **Backed by** | HashMap | LinkedHashMap | TreeMap | Bit vector | Array |
| **Use case** | General purpose | Order matters | Sorted/range queries | Enum only | Concurrent reads |
| **Duplicates** | No | No | No | No | No |
| **Requirements** | equals/hashCode | equals/hashCode | Comparable/Comparator | Enum type | equals |

---

## ğŸ” Detailed Comparisons

### 1ï¸âƒ£ HashSet vs LinkedHashSet

```java
// HashSet - no order guarantee
Set<String> hashSet = new HashSet<>();
hashSet.add("C");
hashSet.add("A");
hashSet.add("B");
System.out.println(hashSet);  // [A, B, C] or any order

// LinkedHashSet - insertion order maintained
Set<String> linkedSet = new LinkedHashSet<>();
linkedSet.add("C");
linkedSet.add("A");
linkedSet.add("B");
System.out.println(linkedSet);  // [C, A, B]
```

**When to choose:**

| Choose HashSet when | Choose LinkedHashSet when |
|---------------------|---------------------------|
| Order doesn't matter | Order matters |
| Maximum performance needed | Predictable iteration needed |
| Memory is limited | Removing duplicates from list |
| Default choice for sets | Caching with order |

---

### 2ï¸âƒ£ HashSet vs TreeSet

```java
// HashSet - fast, unordered
Set<Integer> hashSet = new HashSet<>();
hashSet.addAll(Arrays.asList(5, 2, 8, 1, 9));
System.out.println(hashSet);  // [1, 2, 5, 8, 9] or any order
System.out.println(hashSet.contains(5));  // O(1)

// TreeSet - slower, sorted
Set<Integer> treeSet = new TreeSet<>();
treeSet.addAll(Arrays.asList(5, 2, 8, 1, 9));
System.out.println(treeSet);  // [1, 2, 5, 8, 9] always sorted
System.out.println(treeSet.contains(5));  // O(log n)

// TreeSet special features
TreeSet<Integer> tree = (TreeSet<Integer>) treeSet;
System.out.println(tree.first());     // 1
System.out.println(tree.last());      // 9
System.out.println(tree.floor(6));    // 5
System.out.println(tree.ceiling(6));  // 8
```

**Performance Comparison:**

| Operation | HashSet | TreeSet |
|-----------|---------|---------|
| add(e) | O(1) | O(log n) |
| remove(e) | O(1) | O(log n) |
| contains(e) | O(1) | O(log n) |
| Memory | Less | More |

**When to choose:**

| Choose HashSet when | Choose TreeSet when |
|---------------------|---------------------|
| Fast operations critical | Need sorted elements |
| Order doesn't matter | Range queries needed (subSet, headSet) |
| Can use null | Need first/last operations |
| Default choice | Need floor/ceiling operations |

---

### 3ï¸âƒ£ LinkedHashSet vs TreeSet

```java
// LinkedHashSet - insertion order
Set<String> linkedSet = new LinkedHashSet<>();
linkedSet.add("Zebra");
linkedSet.add("Apple");
linkedSet.add("Mango");
System.out.println(linkedSet);  // [Zebra, Apple, Mango]

// TreeSet - natural order
Set<String> treeSet = new TreeSet<>();
treeSet.add("Zebra");
treeSet.add("Apple");
treeSet.add("Mango");
System.out.println(treeSet);  // [Apple, Mango, Zebra]
```

**When to choose:**

| Choose LinkedHashSet when | Choose TreeSet when |
|---------------------------|---------------------|
| Need insertion order | Need sorted order |
| Fast operations (O(1)) | Willing to trade speed for sorting |
| Can use null | No null needed |
| LRU-like behavior | Range operations needed |

---

### 4ï¸âƒ£ HashSet vs EnumSet

```java
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }

// HashSet with enum
Set<Day> hashSet = new HashSet<>();
hashSet.add(Day.MONDAY);
hashSet.add(Day.FRIDAY);

// EnumSet - specialized for enums
EnumSet<Day> enumSet = EnumSet.of(Day.MONDAY, Day.FRIDAY);

// Performance test
long start = System.nanoTime();
for (int i = 0; i < 1_000_000; i++) {
    hashSet.contains(Day.WEDNESDAY);
}
long hashSetTime = System.nanoTime() - start;

start = System.nanoTime();
for (int i = 0; i < 1_000_000; i++) {
    enumSet.contains(Day.WEDNESDAY);
}
long enumSetTime = System.nanoTime() - start;

System.out.println("HashSet: " + hashSetTime + " ns");
System.out.println("EnumSet: " + enumSetTime + " ns");
// EnumSet is significantly faster (typically 2-3x)
```

**When to choose:**

| Choose HashSet when | Choose EnumSet when |
|---------------------|---------------------|
| Not working with enums | Working exclusively with enums |
| Need null support | Best performance needed |
| Mixed types possible | Memory efficiency critical |

**Always use EnumSet for enum collections!**

---

### 5ï¸âƒ£ Regular Sets vs CopyOnWriteArraySet

```java
// Regular HashSet - not thread-safe
Set<String> hashSet = new HashSet<>();

// CopyOnWriteArraySet - thread-safe
Set<String> cowSet = new CopyOnWriteArraySet<>();
```

**Performance:**

| Operation | HashSet | CopyOnWriteArraySet |
|-----------|---------|---------------------|
| add(e) | O(1) | O(n) - copies array |
| remove(e) | O(1) | O(n) - copies array |
| contains(e) | O(1) | O(n) - linear search |
| Iteration | Fast | Very fast (no locking) |
| Thread-safe | No | Yes |

**When to choose:**

| Choose Regular Set when | Choose CopyOnWriteArraySet when |
|-------------------------|----------------------------------|
| Single-threaded | Multi-threaded |
| Frequent writes | Mostly reads, rare writes |
| Performance critical | Thread-safety critical |
| Large collections | Small collections |

---

## ğŸ¯ Decision Tree

```
Need Set collection?
â”‚
â”œâ”€ Working with enums only?
â”‚  â””â”€ YES â†’ EnumSet (fastest, most efficient)
â”‚
â”œâ”€ Need thread-safety?
â”‚  â””â”€ YES â†’ CopyOnWriteArraySet (or synchronized wrapper)
â”‚
â”œâ”€ Need sorted elements?
â”‚  â”œâ”€ YES â†’ TreeSet
â”‚  â”‚  â””â”€ Also need: first(), last(), floor(), ceiling()
â”‚  â”‚
â”‚  â””â”€ NO â†’ Need insertion order?
â”‚     â”œâ”€ YES â†’ LinkedHashSet
â”‚     â””â”€ NO â†’ HashSet (default choice)
```

---

## ğŸ“ˆ Performance Benchmarks

```java
public class SetPerformanceTest {
    private static final int SIZE = 100_000;
    
    public static void main(String[] args) {
        // Test add operation
        testAdd();
        
        // Test contains operation
        testContains();
        
        // Test iteration
        testIteration();
    }
    
    private static void testAdd() {
        System.out.println("=== Add Performance ===");
        
        long start = System.nanoTime();
        Set<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < SIZE; i++) hashSet.add(i);
        System.out.println("HashSet: " + (System.nanoTime() - start) / 1_000_000 + " ms");
        
        start = System.nanoTime();
        Set<Integer> linkedSet = new LinkedHashSet<>();
        for (int i = 0; i < SIZE; i++) linkedSet.add(i);
        System.out.println("LinkedHashSet: " + (System.nanoTime() - start) / 1_000_000 + " ms");
        
        start = System.nanoTime();
        Set<Integer> treeSet = new TreeSet<>();
        for (int i = 0; i < SIZE; i++) treeSet.add(i);
        System.out.println("TreeSet: " + (System.nanoTime() - start) / 1_000_000 + " ms");
        
        // Typical results (relative):
        // HashSet: 10 ms (baseline)
        // LinkedHashSet: 12 ms (20% slower)
        // TreeSet: 40 ms (4x slower)
    }
}
```

**Typical Performance Results:**

| Operation | HashSet | LinkedHashSet | TreeSet | EnumSet | CopyOnWriteArraySet |
|-----------|---------|---------------|---------|---------|---------------------|
| Add 100K | 10 ms | 12 ms | 40 ms | 5 ms | 500 ms |
| Contains (100K lookups) | 5 ms | 5 ms | 20 ms | 2 ms | 200 ms |
| Iterate 100K | 3 ms | 2 ms | 5 ms | 2 ms | 2 ms |

---

## ğŸ’¾ Memory Comparison

```java
enum Color { RED, GREEN, BLUE, YELLOW, ORANGE }

// Memory usage (approximate for 1000 elements):
// HashSet: ~32KB (16 bytes per entry + overhead)
// LinkedHashSet: ~40KB (additional linked list pointers)
// TreeSet: ~48KB (tree structure with parent/child pointers)
// EnumSet: 8 bytes (single long for â‰¤64 enums)
// CopyOnWriteArraySet: ~24KB (array + synchronization)
```

**Memory Characteristics:**

| Implementation | Memory per Element | Additional Overhead |
|----------------|-------------------|---------------------|
| HashSet | 16-24 bytes | Hash table buckets |
| LinkedHashSet | 24-32 bytes | + linked list pointers |
| TreeSet | 32-40 bytes | + tree node structure |
| EnumSet | 1 bit | Minimal (bit vector) |
| CopyOnWriteArraySet | 8-16 bytes | + synchronization |

---

## ğŸ“ Use Case Examples

### Scenario 1: Unique User IDs
```java
// Best choice: HashSet (fast, order doesn't matter)
Set<String> userIds = new HashSet<>();
```

### Scenario 2: Recent Search History
```java
// Best choice: LinkedHashSet (maintains order)
Set<String> searchHistory = new LinkedHashSet<>();
```

### Scenario 3: Leaderboard (Sorted Scores)
```java
// Best choice: TreeSet (sorted order, range queries)
TreeSet<Integer> scores = new TreeSet<>(Comparator.reverseOrder());
```

### Scenario 4: Days Open
```java
enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }
// Best choice: EnumSet (fastest for enums)
EnumSet<Day> openDays = EnumSet.range(Day.MONDAY, Day.FRIDAY);
```

### Scenario 5: Concurrent Cache
```java
// Best choice: CopyOnWriteArraySet (thread-safe, read-heavy)
Set<String> cache = new CopyOnWriteArraySet<>();
```

### Scenario 6: Unique Words in Text
```java
// Best choice: HashSet (fast, order doesn't matter)
String text = "hello world hello java world";
Set<String> uniqueWords = new HashSet<>(Arrays.asList(text.split(" ")));
```

### Scenario 7: Sorted Product Categories
```java
// Best choice: TreeSet (sorted, range queries)
TreeSet<String> categories = new TreeSet<>();
System.out.println("Categories A-M: " + categories.subSet("A", "N"));
```

---

## âš¡ Quick Reference Guide

### Choose **HashSet** (Default)
- âœ… Fast operations (O(1))
- âœ… Order doesn't matter
- âœ… General-purpose
- âœ… Memory efficient

### Choose **LinkedHashSet**
- âœ… Need insertion order
- âœ… Fast operations (O(1))
- âœ… Remove duplicates from list
- âœ… Cache with order

### Choose **TreeSet**
- âœ… Need sorted elements
- âœ… Range queries (subSet, headSet, tailSet)
- âœ… First/last operations
- âœ… Floor/ceiling operations

### Choose **EnumSet**
- âœ… Working with enums
- âœ… Maximum performance
- âœ… Minimum memory
- âœ… Type-safe

### Choose **CopyOnWriteArraySet**
- âœ… Thread-safety required
- âœ… Read-heavy workload
- âœ… Small collections
- âœ… Iteration without locking

---

## ğŸ“š Summary

**Performance Ranking (fastest to slowest):**
1. **EnumSet** - O(1) bit operations
2. **HashSet** - O(1) hash operations
3. **LinkedHashSet** - O(1) hash + linked list
4. **TreeSet** - O(log n) tree operations
5. **CopyOnWriteArraySet** - O(n) array operations

**Memory Ranking (least to most):**
1. **EnumSet** - 1 bit per element
2. **HashSet** - Moderate
3. **CopyOnWriteArraySet** - Moderate
4. **LinkedHashSet** - More (linked list)
5. **TreeSet** - Most (tree structure)

**Default Choice:** HashSet (unless you need specific features)

**Special Cases:**
- Enums â†’ Always use EnumSet
- Order needed â†’ LinkedHashSet
- Sorted needed â†’ TreeSet
- Thread-safety â†’ CopyOnWriteArraySet
