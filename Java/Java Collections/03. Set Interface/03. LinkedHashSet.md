# ğŸ¯ LinkedHashSet

## ğŸ“– Overview

`LinkedHashSet` is a **hash table and linked list** implementation of the Set interface. It maintains **insertion order** while providing **HashSet's performance**.

```java
public class LinkedHashSet<E> extends HashSet<E>
    implements Set<E>, Cloneable, Serializable
```

---

## ğŸ”‘ Key Characteristics

1. **No Duplicates** - Like HashSet
2. **Maintains Insertion Order** - Elements ordered by insertion
3. **Allows Null** - Can contain one null element
4. **Not Synchronized** - Not thread-safe
5. **Fast Performance** - O(1) for basic operations
6. **Backed by LinkedHashMap** - Uses LinkedHashMap internally
7. **Predictable Iteration** - Iterates in insertion order

---

## ğŸ’» Creating LinkedHashSet

```java
import java.util.*;

// 1. Default constructor - capacity 16, load factor 0.75
Set<String> set1 = new LinkedHashSet<>();

// 2. With initial capacity
Set<String> set2 = new LinkedHashSet<>(20);

// 3. With capacity and load factor
Set<String> set3 = new LinkedHashSet<>(20, 0.8f);

// 4. From another collection
List<String> list = Arrays.asList("C", "A", "B", "A");
Set<String> set4 = new LinkedHashSet<>(list);  // [C, A, B] - order preserved
```

---

## ğŸ¨ Basic Operations

```java
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        Set<String> fruits = new LinkedHashSet<>();
        
        // Add elements - order preserved
        fruits.add("Banana");
        fruits.add("Apple");
        fruits.add("Cherry");
        fruits.add("Apple");  // Duplicate - not added
        
        System.out.println(fruits);  // [Banana, Apple, Cherry] - insertion order
        
        // Add more elements
        fruits.add("Date");
        fruits.add("Elderberry");
        System.out.println(fruits);  // [Banana, Apple, Cherry, Date, Elderberry]
        
        // Remove element
        fruits.remove("Cherry");
        System.out.println(fruits);  // [Banana, Apple, Date, Elderberry]
        
        // Add removed element again
        fruits.add("Cherry");
        System.out.println(fruits);  // [Banana, Apple, Date, Elderberry, Cherry]
        
        // Check existence
        System.out.println(fruits.contains("Apple"));  // true
        
        // Size
        System.out.println("Size: " + fruits.size());  // 5
    }
}
```

---

## ğŸ”„ Iteration Order

```java
// LinkedHashSet maintains insertion order
Set<Integer> linkedSet = new LinkedHashSet<>();
linkedSet.add(3);
linkedSet.add(1);
linkedSet.add(4);
linkedSet.add(2);

System.out.println(linkedSet);  // [3, 1, 4, 2] - insertion order

// Compare with HashSet
Set<Integer> hashSet = new HashSet<>();
hashSet.add(3);
hashSet.add(1);
hashSet.add(4);
hashSet.add(2);

System.out.println(hashSet);  // [1, 2, 3, 4] or any order - no guarantee
```

---

## ğŸ—ï¸ Internal Structure

```java
// LinkedHashSet extends HashSet
public class LinkedHashSet<E> extends HashSet<E> {
    
    public LinkedHashSet() {
        super(16, 0.75f, true);  // true = use LinkedHashMap
    }
    
    // Internally uses LinkedHashMap
}

// HashSet constructor with LinkedHashMap
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

**Structure:**
```
Element â†’ HashMap Entry â†’ Doubly Linked List
         (for fast lookup) (for order)
```

**Components:**
- **Hash Table**: Fast O(1) operations
- **Doubly Linked List**: Maintains insertion order
- Each entry has: `before` and `after` pointers

---

## ğŸ“Š Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `add(E e)` | O(1) | Amortized |
| `remove(Object o)` | O(1) | Amortized |
| `contains(Object o)` | O(1) | Average case |
| `size()` | O(1) | |
| Iteration | O(n) | Based on size, not capacity |

**Performance vs HashSet:**
- Slightly slower than HashSet (linked list overhead)
- Faster iteration than HashSet (no empty buckets)
- More memory (stores links)

---

## ğŸ”§ Common Operations

```java
Set<String> set = new LinkedHashSet<>();

// Add elements
set.add("First");
set.add("Second");
set.add("Third");

// Iteration - predictable order
for (String s : set) {
    System.out.println(s);  // First, Second, Third
}

// Remove and re-add
set.remove("Second");
set.add("Second");
System.out.println(set);  // [First, Third, Second] - moved to end

// Bulk operations
Set<String> another = new LinkedHashSet<>(Arrays.asList("Fourth", "Fifth"));
set.addAll(another);
System.out.println(set);  // [First, Third, Second, Fourth, Fifth]

// Clear
set.clear();
System.out.println(set.isEmpty());  // true
```

---

## ğŸ“ Custom Objects

```java
class Employee {
    private int id;
    private String name;
    
    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    @Override
    public String toString() {
        return name + "(" + id + ")";
    }
}

public class CustomObjectDemo {
    public static void main(String[] args) {
        Set<Employee> employees = new LinkedHashSet<>();
        
        employees.add(new Employee(3, "Charlie"));
        employees.add(new Employee(1, "Alice"));
        employees.add(new Employee(2, "Bob"));
        employees.add(new Employee(1, "Alice2"));  // Duplicate id - not added
        
        // Maintains insertion order
        System.out.println(employees);  // [Charlie(3), Alice(1), Bob(2)]
    }
}
```

---

## ğŸ¯ Use Cases

```java
// 1. Remove duplicates while preserving order
List<String> list = Arrays.asList("C", "A", "B", "A", "D", "B");
Set<String> uniqueOrdered = new LinkedHashSet<>(list);
System.out.println(uniqueOrdered);  // [C, A, B, D]

// 2. LRU Cache (Least Recently Used) - using access order
// Not directly with LinkedHashSet, but concept applies
// Use LinkedHashMap with accessOrder=true for LRU

// 3. Track visited URLs in order
Set<String> visitedUrls = new LinkedHashSet<>();
visitedUrls.add("google.com");
visitedUrls.add("stackoverflow.com");
visitedUrls.add("github.com");
// Maintains visit order

// 4. Playlist - unique songs in order
Set<String> playlist = new LinkedHashSet<>();
playlist.add("Song1");
playlist.add("Song2");
playlist.add("Song3");
playlist.add("Song1");  // Already exists - not added
// [Song1, Song2, Song3] - order preserved

// 5. Process tasks in order without duplicates
Set<String> tasks = new LinkedHashSet<>();
tasks.add("Task3");
tasks.add("Task1");
tasks.add("Task2");
tasks.add("Task1");  // Duplicate - ignored
// Process in order: Task3, Task1, Task2
```

---

## ğŸ†š LinkedHashSet vs HashSet

| Feature | LinkedHashSet | HashSet |
|---------|--------------|---------|
| **Order** | Insertion order | No order |
| **Performance** | Slightly slower | Faster |
| **Memory** | More (linked list) | Less |
| **Iteration** | O(n) - size | O(n) - capacity |
| **Use Case** | Order matters | Order doesn't matter |

```java
// HashSet
Set<String> hashSet = new HashSet<>();
hashSet.add("C");
hashSet.add("A");
hashSet.add("B");
System.out.println(hashSet);  // [A, B, C] or any order

// LinkedHashSet
Set<String> linkedSet = new LinkedHashSet<>();
linkedSet.add("C");
linkedSet.add("A");
linkedSet.add("B");
System.out.println(linkedSet);  // [C, A, B] - insertion order
```

---

## ğŸ†š LinkedHashSet vs TreeSet

| Feature | LinkedHashSet | TreeSet |
|---------|--------------|---------|
| **Order** | Insertion order | Sorted (natural/comparator) |
| **Performance** | O(1) | O(log n) |
| **Null** | Allows one null | No null |
| **Requirement** | equals/hashCode | Comparable/Comparator |

```java
// LinkedHashSet - insertion order
Set<Integer> linkedSet = new LinkedHashSet<>();
linkedSet.add(5);
linkedSet.add(1);
linkedSet.add(3);
System.out.println(linkedSet);  // [5, 1, 3]

// TreeSet - sorted order
Set<Integer> treeSet = new TreeSet<>();
treeSet.add(5);
treeSet.add(1);
treeSet.add(3);
System.out.println(treeSet);  // [1, 3, 5]
```

---

## âš ï¸ Common Pitfalls

```java
// 1. Expecting sorted order
Set<Integer> set = new LinkedHashSet<>();
set.add(3);
set.add(1);
set.add(2);
System.out.println(set);  // [3, 1, 2] NOT [1, 2, 3]

// 2. Re-adding changes position
Set<String> set = new LinkedHashSet<>();
set.add("A");
set.add("B");
set.remove("A");
set.add("A");  // Moved to end
System.out.println(set);  // [B, A]

// 3. Memory overhead
// LinkedHashSet uses more memory than HashSet
// Consider if order is really needed

// 4. Not thread-safe
Set<String> set = new LinkedHashSet<>();
// Concurrent modifications will cause issues
// Use Collections.synchronizedSet() or CopyOnWriteArraySet
```

---

## ğŸ”„ Thread Safety

```java
// LinkedHashSet is not thread-safe
// Option 1: Synchronized wrapper
Set<String> syncSet = Collections.synchronizedSet(new LinkedHashSet<>());

synchronized(syncSet) {
    Iterator<String> it = syncSet.iterator();
    while (it.hasNext()) {
        System.out.println(it.next());
    }
}

// Option 2: CopyOnWriteArraySet (maintains insertion order, thread-safe)
Set<String> cowSet = new CopyOnWriteArraySet<>();

// Option 3: ConcurrentHashMap.newKeySet() - no order guarantee
Set<String> concurrentSet = ConcurrentHashMap.newKeySet();
```

---

## ğŸ’¡ Best Practices

1. **Use when order matters** and duplicates are not allowed
2. **Choose HashSet** if order doesn't matter (better performance)
3. **Choose TreeSet** if sorted order is needed
4. **Override equals() and hashCode()** for custom objects
5. **Consider memory overhead** - LinkedHashSet uses more memory
6. **Synchronize** for concurrent access
7. **Initialize capacity** if size is known: `new LinkedHashSet<>(expectedSize)`

---

## ğŸ¯ When to Use LinkedHashSet

**Use LinkedHashSet when:**
- âœ… Need to maintain insertion order
- âœ… No duplicates allowed
- âœ… Fast operations required (O(1))
- âœ… Remove duplicates while preserving order
- âœ… Predictable iteration order needed

**Don't use LinkedHashSet when:**
- âŒ Order doesn't matter â†’ Use `HashSet` (faster, less memory)
- âŒ Need sorted order â†’ Use `TreeSet`
- âŒ Memory is critical â†’ Use `HashSet`
- âŒ Need thread-safety â†’ Use `CopyOnWriteArraySet` or synchronize
- âŒ Need indexed access â†’ Use `List`

---

## ğŸ“š Summary

- **LinkedHashSet**: HashSet + Insertion Order
- Maintains **predictable iteration order**
- **O(1)** performance for basic operations
- Uses **more memory** than HashSet (doubly linked list)
- **Faster iteration** than HashSet (no empty buckets)
- **Not thread-safe** - use synchronization if needed
- Perfect for **removing duplicates while preserving order**
- Must override **equals() and hashCode()** for custom objects
