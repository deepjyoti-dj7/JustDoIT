# üéØ Set Interface Basics

## üìñ Overview

`Set` is a collection that **does not allow duplicate elements**. It models the mathematical set abstraction.

```java
public interface Set<E> extends Collection<E>
```

---

## üîë Key Characteristics

1. **No Duplicates** - Cannot contain duplicate elements
2. **Unordered** - Most implementations don't maintain insertion order
3. **Null Elements** - Some allow one null, some don't
4. **Mathematical Set Operations** - Union, intersection, difference

---

## üìä Set Hierarchy

```
Set (Interface)
‚îú‚îÄ‚îÄ HashSet (Class)
‚îÇ   ‚îî‚îÄ‚îÄ LinkedHashSet (Class)
‚îú‚îÄ‚îÄ TreeSet (Class) - implements NavigableSet
‚îú‚îÄ‚îÄ EnumSet (Abstract Class)
‚îî‚îÄ‚îÄ CopyOnWriteArraySet (Class)
```

---

## üé® Set Implementations

| Implementation | Ordering | Null | Performance | Thread-Safe |
|---------------|----------|------|-------------|-------------|
| **HashSet** | No order | Yes | O(1) | No |
| **LinkedHashSet** | Insertion order | Yes | O(1) | No |
| **TreeSet** | Sorted | No | O(log n) | No |
| **EnumSet** | Enum order | No | O(1) | No |
| **CopyOnWriteArraySet** | Insertion order | Yes | O(n) | Yes |

---

## üíª Basic Operations

```java
import java.util.*;

public class SetBasics {
    public static void main(String[] args) {
        // Create a Set
        Set<String> set = new HashSet<>();
        
        // Add elements
        set.add("Apple");
        set.add("Banana");
        set.add("Cherry");
        set.add("Apple");  // Duplicate - won't be added
        
        System.out.println(set);  // [Apple, Cherry, Banana] (order may vary)
        System.out.println("Size: " + set.size());  // 3
        
        // Check existence
        System.out.println(set.contains("Apple"));  // true
        
        // Remove element
        set.remove("Banana");
        
        // Iterate
        for (String fruit : set) {
            System.out.println(fruit);
        }
        
        // Clear
        set.clear();
        System.out.println(set.isEmpty());  // true
    }
}
```

---

## üîß Common Methods

```java
Set<String> set = new HashSet<>();

// Basic operations
boolean add(E e)           // Adds element, returns false if duplicate
boolean remove(Object o)   // Removes element
boolean contains(Object o) // Checks existence
int size()                 // Returns number of elements
boolean isEmpty()          // Checks if empty
void clear()               // Removes all elements

// Bulk operations
boolean addAll(Collection<? extends E> c)      // Union
boolean removeAll(Collection<?> c)             // Difference
boolean retainAll(Collection<?> c)             // Intersection
boolean containsAll(Collection<?> c)           // Subset check

// Conversion
Object[] toArray()                             // To array
<T> T[] toArray(T[] a)                        // To typed array

// Java 8+ methods
default void forEach(Consumer<? super E> action)
default boolean removeIf(Predicate<? super E> filter)
default Spliterator<E> spliterator()

// Java 9+ - Factory methods
Set<E> Set.of(E... elements)                   // Immutable set
Set<E> Set.copyOf(Collection<? extends E> coll)
```

---

## üéØ Set Operations (Mathematical)

```java
public class SetOperations {
    public static void main(String[] args) {
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
        
        // Union - All elements from both sets
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union);  // [1, 2, 3, 4, 5, 6, 7, 8]
        
        // Intersection - Common elements
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection);  // [4, 5]
        
        // Difference - Elements in set1 but not in set2
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference: " + difference);  // [1, 2, 3]
        
        // Symmetric Difference - Elements in either but not both
        Set<Integer> symDiff = new HashSet<>(set1);
        symDiff.addAll(set2);
        Set<Integer> temp = new HashSet<>(set1);
        temp.retainAll(set2);
        symDiff.removeAll(temp);
        System.out.println("Symmetric Difference: " + symDiff);  // [1, 2, 3, 6, 7, 8]
        
        // Subset check
        Set<Integer> subset = new HashSet<>(Arrays.asList(1, 2, 3));
        System.out.println("Is subset? " + set1.containsAll(subset));  // true
    }
}
```

---

## üÜö Set vs List

| Feature | Set | List |
|---------|-----|------|
| Duplicates | ‚ùå Not allowed | ‚úÖ Allowed |
| Order | Usually no order | Maintains insertion order |
| Index access | ‚ùå No | ‚úÖ Yes |
| Performance | O(1) for HashSet | O(1) for ArrayList |
| Use case | Unique elements | Ordered collection |

---

## üîç Choosing the Right Set

```java
// HashSet - Fast, no order
Set<String> hashSet = new HashSet<>();
// Use when: Order doesn't matter, need fast operations

// LinkedHashSet - Fast, maintains insertion order
Set<String> linkedHashSet = new LinkedHashSet<>();
// Use when: Need insertion order, fast operations

// TreeSet - Sorted, slower
Set<String> treeSet = new TreeSet<>();
// Use when: Need sorted elements, range queries

// EnumSet - Extremely fast for enums
Set<Day> enumSet = EnumSet.of(Day.MONDAY, Day.FRIDAY);
// Use when: Working with enum types

// CopyOnWriteArraySet - Thread-safe, slow writes
Set<String> cowSet = new CopyOnWriteArraySet<>();
// Use when: Thread-safety needed, reads >> writes
```

---

## üìù Immutable Sets (Java 9+)

```java
// Immutable set - cannot be modified
Set<String> immutableSet = Set.of("A", "B", "C");
// immutableSet.add("D");  // UnsupportedOperationException

// Copy existing collection to immutable set
Set<String> original = new HashSet<>(Arrays.asList("X", "Y", "Z"));
Set<String> immutableCopy = Set.copyOf(original);

// Empty immutable set
Set<String> empty = Set.of();
```

**Characteristics:**
- Cannot add, remove, or modify elements
- Does not allow null elements
- Compact memory representation
- Thread-safe by nature

---

## üéì Custom Objects in Set

```java
class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // MUST override equals and hashCode for HashSet
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

// Usage
Set<Person> people = new HashSet<>();
people.add(new Person("Alice", 30));
people.add(new Person("Bob", 25));
people.add(new Person("Alice", 30));  // Duplicate, won't be added

System.out.println(people.size());  // 2
```

**Note:** For `TreeSet`, implement `Comparable` or provide `Comparator`.

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Modifying objects in Set
Set<Person> set = new HashSet<>();
Person p = new Person("John", 25);
set.add(p);
p.setAge(30);  // ‚ö†Ô∏è Breaks hashCode contract!
// Now p cannot be found in set

// 2. Using mutable objects without proper equals/hashCode
class BadPerson {
    String name;
    // No equals/hashCode override
}
Set<BadPerson> bad = new HashSet<>();
bad.add(new BadPerson("John"));
bad.add(new BadPerson("John"));  // Treated as different!

// 3. Null handling
Set<String> hashSet = new HashSet<>();
hashSet.add(null);  // ‚úÖ Allowed (only one)

Set<String> treeSet = new TreeSet<>();
// treeSet.add(null);  // ‚ùå NullPointerException
```

---

## üí° Best Practices

1. **Always override `equals()` and `hashCode()`** for custom objects in HashSet
2. **Implement `Comparable`** or provide `Comparator` for TreeSet
3. **Don't modify objects** after adding to Set
4. **Use Set.of()** for immutable sets (Java 9+)
5. **Choose right implementation** based on requirements:
   - HashSet: Default choice (fast, no order)
   - LinkedHashSet: When order matters
   - TreeSet: When sorting needed
   - EnumSet: For enum types
   - CopyOnWriteArraySet: For concurrent reads

---

## üéØ Interview Questions

**Q: What is the main difference between Set and List?**
A: Set doesn't allow duplicates, List allows duplicates. Set has no index-based access.

**Q: Can Set contain null elements?**
A: Depends on implementation. HashSet/LinkedHashSet allow one null, TreeSet doesn't allow null.

**Q: Why must we override equals() and hashCode() for HashSet?**
A: HashSet uses hashCode() to find bucket and equals() to check duplicates. Without proper implementation, duplicates won't be detected.

**Q: Which Set implementation to use for maintaining insertion order?**
A: LinkedHashSet maintains insertion order.

**Q: Time complexity of HashSet operations?**
A: O(1) for add, remove, contains (average case).

---

## üìö Summary

- **Set**: No duplicates, unordered (usually)
- **HashSet**: Fast, no order, allows null
- **LinkedHashSet**: Fast, insertion order, allows null
- **TreeSet**: Sorted, O(log n), no null
- **EnumSet**: Best for enums
- **CopyOnWriteArraySet**: Thread-safe, slow writes
- Always override `equals()` and `hashCode()` for custom objects
