# üéØ TreeSet

## üìñ Overview

`TreeSet` is a **sorted set** implementation based on a **Red-Black Tree**. It stores elements in **sorted (ascending) order** and provides **O(log n)** performance.

```java
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, Serializable
```

---

## üîë Key Characteristics

1. **Sorted Order** - Elements stored in natural or custom order
2. **No Duplicates** - Set semantics apply
3. **No Null** - Does not allow null elements (NullPointerException)
4. **Not Synchronized** - Not thread-safe
5. **O(log n) Performance** - For add, remove, contains
6. **Backed by TreeMap** - Uses TreeMap internally
7. **Implements NavigableSet** - Rich navigation methods

---

## üíª Creating TreeSet

```java
import java.util.*;

// 1. Natural ordering (elements must implement Comparable)
Set<Integer> set1 = new TreeSet<>();
set1.addAll(Arrays.asList(5, 2, 8, 1, 9));
System.out.println(set1);  // [1, 2, 5, 8, 9]

// 2. Custom comparator - descending order
Set<Integer> set2 = new TreeSet<>(Comparator.reverseOrder());
set2.addAll(Arrays.asList(5, 2, 8, 1, 9));
System.out.println(set2);  // [9, 8, 5, 2, 1]

// 3. From another collection
List<String> list = Arrays.asList("Dog", "Cat", "Ant", "Bear");
Set<String> set3 = new TreeSet<>(list);
System.out.println(set3);  // [Ant, Bear, Cat, Dog]

// 4. Custom comparator - string length
Set<String> set4 = new TreeSet<>(Comparator.comparing(String::length));
set4.addAll(Arrays.asList("aaa", "bb", "c", "dddd"));
System.out.println(set4);  // [c, bb, aaa, dddd]
```

---

## üé® Basic Operations

```java
public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        
        // Add elements - automatically sorted
        numbers.add(5);
        numbers.add(2);
        numbers.add(8);
        numbers.add(1);
        numbers.add(9);
        
        System.out.println(numbers);  // [1, 2, 5, 8, 9]
        
        // Add duplicate - ignored
        numbers.add(5);
        System.out.println(numbers);  // [1, 2, 5, 8, 9]
        
        // Contains
        System.out.println(numbers.contains(8));  // true
        
        // Remove
        numbers.remove(2);
        System.out.println(numbers);  // [1, 5, 8, 9]
        
        // Size
        System.out.println("Size: " + numbers.size());  // 4
        
        // Cannot add null
        // numbers.add(null);  // NullPointerException
    }
}
```

---

## üß≠ NavigableSet Methods

```java
TreeSet<Integer> set = new TreeSet<>(Arrays.asList(1, 3, 5, 7, 9, 11, 13));

// Retrieval methods
System.out.println(set.first());     // 1 (lowest)
System.out.println(set.last());      // 13 (highest)

// Closest matches
System.out.println(set.lower(7));    // 5 (strictly less than 7)
System.out.println(set.floor(7));    // 7 (less than or equal to 7)
System.out.println(set.ceiling(8));  // 9 (greater than or equal to 8)
System.out.println(set.higher(7));   // 9 (strictly greater than 7)

// Poll (retrieve and remove)
System.out.println(set.pollFirst()); // 1 (removes and returns)
System.out.println(set.pollLast());  // 13 (removes and returns)
System.out.println(set);             // [3, 5, 7, 9, 11]

// Subset views
System.out.println(set.headSet(7));           // [3, 5] (< 7)
System.out.println(set.tailSet(7));           // [7, 9, 11] (>= 7)
System.out.println(set.subSet(5, 11));        // [5, 7, 9] (>= 5, < 11)

// Inclusive/exclusive bounds
System.out.println(set.headSet(7, true));     // [3, 5, 7] (<= 7)
System.out.println(set.subSet(5, true, 11, true));  // [5, 7, 9, 11]
```

---

## üîÑ Iteration

```java
TreeSet<String> fruits = new TreeSet<>(Arrays.asList("Banana", "Apple", "Cherry", "Date"));

// Forward iteration - sorted order
for (String fruit : fruits) {
    System.out.println(fruit);  // Apple, Banana, Cherry, Date
}

// Reverse iteration
Iterator<String> descIterator = fruits.descendingIterator();
while (descIterator.hasNext()) {
    System.out.println(descIterator.next());  // Date, Cherry, Banana, Apple
}

// Descending set view
NavigableSet<String> reverseSet = fruits.descendingSet();
System.out.println(reverseSet);  // [Date, Cherry, Banana, Apple]

// Stream
fruits.stream()
      .filter(f -> f.startsWith("C"))
      .forEach(System.out::println);  // Cherry
```

---

## üèóÔ∏è Internal Structure

```java
// TreeSet uses TreeMap internally
public class TreeSet<E> {
    private transient NavigableMap<E, Object> m;
    private static final Object PRESENT = new Object();
    
    public boolean add(E e) {
        return m.put(e, PRESENT) == null;
    }
    
    public boolean remove(Object o) {
        return m.remove(o) == PRESENT;
    }
    
    public boolean contains(Object o) {
        return m.containsKey(o);
    }
}
```

**Red-Black Tree Properties:**
- Self-balancing binary search tree
- Each node has a color (red or black)
- Root is always black
- No two adjacent red nodes
- Every path has same number of black nodes
- Height: O(log n)

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `add(E e)` | O(log n) | Tree rebalancing |
| `remove(Object o)` | O(log n) | Tree rebalancing |
| `contains(Object o)` | O(log n) | Binary search |
| `first()` / `last()` | O(log n) | |
| `ceiling()` / `floor()` | O(log n) | |
| `pollFirst()` / `pollLast()` | O(log n) | |
| Iteration | O(n) | In-order traversal |

---

## üéì Custom Objects with Comparable

```java
class Student implements Comparable<Student> {
    private int id;
    private String name;
    private double gpa;
    
    public Student(int id, String name, double gpa) {
        this.id = id;
        this.name = name;
        this.gpa = gpa;
    }
    
    // Natural ordering by GPA (descending)
    @Override
    public int compareTo(Student other) {
        return Double.compare(other.gpa, this.gpa);  // Descending
    }
    
    @Override
    public String toString() {
        return name + "(" + gpa + ")";
    }
}

public class ComparableDemo {
    public static void main(String[] args) {
        TreeSet<Student> students = new TreeSet<>();
        
        students.add(new Student(1, "Alice", 3.8));
        students.add(new Student(2, "Bob", 3.5));
        students.add(new Student(3, "Charlie", 3.9));
        
        System.out.println(students);  // [Charlie(3.9), Alice(3.8), Bob(3.5)]
    }
}
```

---

## üéì Custom Objects with Comparator

```java
class Employee {
    private int id;
    private String name;
    private int age;
    
    public Employee(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
    
    // Getters
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}

public class ComparatorDemo {
    public static void main(String[] args) {
        // Sort by name
        TreeSet<Employee> byName = new TreeSet<>(Comparator.comparing(Employee::getName));
        byName.add(new Employee(1, "Charlie", 30));
        byName.add(new Employee(2, "Alice", 25));
        byName.add(new Employee(3, "Bob", 28));
        System.out.println("By name: " + byName);  // [Alice(25), Bob(28), Charlie(30)]
        
        // Sort by age
        TreeSet<Employee> byAge = new TreeSet<>(Comparator.comparing(Employee::getAge));
        byAge.addAll(byName);
        System.out.println("By age: " + byAge);  // [Alice(25), Bob(28), Charlie(30)]
        
        // Sort by age descending
        TreeSet<Employee> byAgeDesc = new TreeSet<>(
            Comparator.comparing(Employee::getAge).reversed()
        );
        byAgeDesc.addAll(byName);
        System.out.println("By age desc: " + byAgeDesc);  // [Charlie(30), Bob(28), Alice(25)]
        
        // Multiple criteria - age then name
        TreeSet<Employee> multiSort = new TreeSet<>(
            Comparator.comparing(Employee::getAge)
                      .thenComparing(Employee::getName)
        );
    }
}
```

---

## üîß Range Operations

```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(1, 3, 5, 7, 9, 11, 13, 15, 17, 19));

// Get elements less than 10
NavigableSet<Integer> lessThan10 = numbers.headSet(10, false);
System.out.println(lessThan10);  // [1, 3, 5, 7, 9]

// Get elements from 7 to 15 (inclusive)
NavigableSet<Integer> range = numbers.subSet(7, true, 15, true);
System.out.println(range);  // [7, 9, 11, 13, 15]

// Get elements greater than or equal to 10
NavigableSet<Integer> greaterEqual10 = numbers.tailSet(10, true);
System.out.println(greaterEqual10);  // [11, 13, 15, 17, 19]

// Modifying subset affects original
range.remove(11);
System.out.println(numbers);  // [1, 3, 5, 7, 9, 13, 15, 17, 19] - 11 removed
```

---

## üéØ Use Cases

```java
// 1. Leaderboard (sorted scores)
TreeSet<Integer> scores = new TreeSet<>(Comparator.reverseOrder());
scores.add(95);
scores.add(87);
scores.add(92);
System.out.println("Top score: " + scores.first());  // 95

// 2. Priority levels
TreeSet<String> priorities = new TreeSet<>();
priorities.add("HIGH");
priorities.add("LOW");
priorities.add("MEDIUM");
System.out.println("Highest priority: " + priorities.first());  // HIGH

// 3. Time-based scheduling
TreeSet<LocalTime> schedule = new TreeSet<>();
schedule.add(LocalTime.of(9, 0));
schedule.add(LocalTime.of(14, 30));
schedule.add(LocalTime.of(11, 15));
System.out.println("Next meeting: " + schedule.first());  // 09:00

// 4. Range queries
TreeSet<Integer> prices = new TreeSet<>(Arrays.asList(10, 25, 40, 55, 70, 85));
System.out.println("Products $30-$60: " + prices.subSet(30, 60));  // [40, 55]

// 5. Find closest value
TreeSet<Integer> values = new TreeSet<>(Arrays.asList(1, 5, 10, 15, 20));
int target = 12;
Integer lower = values.floor(target);   // 10
Integer higher = values.ceiling(target); // 15
System.out.println("Closest to " + target + ": " + 
    (Math.abs(target - lower) < Math.abs(target - higher) ? lower : higher));  // 10
```

---

## ‚ö†Ô∏è Common Pitfalls

```java
// 1. Null elements not allowed
TreeSet<String> set = new TreeSet<>();
// set.add(null);  // NullPointerException

// 2. ClassCastException - elements must be comparable
TreeSet<Object> objects = new TreeSet<>();
objects.add("String");
// objects.add(123);  // ClassCastException

// 3. Inconsistent compareTo and equals
class BadPerson implements Comparable<BadPerson> {
    String name;
    int age;
    
    @Override
    public int compareTo(BadPerson other) {
        return this.name.compareTo(other.name);  // Only compares name
    }
    
    @Override
    public boolean equals(Object o) {
        // Compares both name and age
        // Violates consistency with compareTo
    }
}

// 4. Mutable objects in TreeSet
class MutableScore implements Comparable<MutableScore> {
    int score;
    public void setScore(int score) { this.score = score; }
    public int compareTo(MutableScore o) { return Integer.compare(score, o.score); }
}
TreeSet<MutableScore> scores = new TreeSet<>();
MutableScore s = new MutableScore();
s.score = 50;
scores.add(s);
s.setScore(100);  // ‚ö†Ô∏è Breaks tree structure!
```

---

## üÜö TreeSet vs HashSet

| Feature | TreeSet | HashSet |
|---------|---------|---------|
| **Order** | Sorted | No order |
| **Performance** | O(log n) | O(1) |
| **Null** | Not allowed | One null |
| **Requirement** | Comparable/Comparator | equals/hashCode |
| **Memory** | More (tree structure) | Less |
| **Use Case** | Sorted data, range queries | Fast operations |

```java
// HashSet - fast, no order
Set<Integer> hashSet = new HashSet<>(Arrays.asList(5, 2, 8, 1));
System.out.println(hashSet);  // [1, 2, 5, 8] or any order

// TreeSet - slower, sorted
Set<Integer> treeSet = new TreeSet<>(Arrays.asList(5, 2, 8, 1));
System.out.println(treeSet);  // [1, 2, 5, 8] guaranteed
```

---

## üí° Best Practices

1. **Implement Comparable** or provide **Comparator**
2. **Ensure consistency** between `compareTo()` and `equals()`
3. **Use immutable objects** as elements
4. **Don't modify** objects after adding to TreeSet
5. **Choose TreeSet** only when sorted order or range queries needed
6. **Use HashSet** if order doesn't matter (better performance)
7. **Handle ClassCastException** for heterogeneous elements
8. **Avoid null** elements

---

## üéØ When to Use TreeSet

**Use TreeSet when:**
- ‚úÖ Need sorted elements
- ‚úÖ Need range queries (subSet, headSet, tailSet)
- ‚úÖ Need closest element operations (floor, ceiling)
- ‚úÖ No duplicates required
- ‚úÖ Elements are comparable

**Don't use TreeSet when:**
- ‚ùå Order doesn't matter ‚Üí Use `HashSet` (faster)
- ‚ùå Need insertion order ‚Üí Use `LinkedHashSet`
- ‚ùå Need null elements ‚Üí Use `HashSet` or `LinkedHashSet`
- ‚ùå Elements not comparable ‚Üí Provide Comparator or use HashSet
- ‚ùå Performance critical ‚Üí Use `HashSet`

---

## üìö Summary

- **TreeSet**: Sorted, no duplicates, O(log n) operations
- Uses **Red-Black Tree** internally
- Implements **NavigableSet** - rich navigation methods
- **No null** elements allowed
- Elements must be **Comparable** or use **Comparator**
- Best for **sorted data** and **range queries**
- Slower than **HashSet** but provides ordering
- **Not thread-safe** - use synchronization if needed
