# üéØ CopyOnWriteArraySet

## üìñ Overview

`CopyOnWriteArraySet` is a **thread-safe** Set implementation that uses a **copy-on-write array**. It creates a **new copy** of the underlying array for every **write operation**.

```java
public class CopyOnWriteArraySet<E> extends AbstractSet<E>
    implements Serializable
```

---

## üîë Key Characteristics

1. **Thread-Safe** - Safe for concurrent access without external synchronization
2. **Copy-on-Write** - Creates new array copy for modifications
3. **Snapshot Iteration** - Iterator uses snapshot, never throws ConcurrentModificationException
4. **No Duplicates** - Set semantics apply
5. **Allows Null** - Can contain one null element
6. **Maintains Insertion Order** - Preserves order of addition
7. **Best for Read-Heavy** - Optimized for frequent reads, rare writes
8. **Backed by CopyOnWriteArrayList** - Uses CopyOnWriteArrayList internally

---

## üíª Creating CopyOnWriteArraySet

```java
import java.util.concurrent.*;
import java.util.*;

// 1. Empty set
Set<String> set1 = new CopyOnWriteArraySet<>();

// 2. From collection
List<String> list = Arrays.asList("A", "B", "C", "A");
Set<String> set2 = new CopyOnWriteArraySet<>(list);  // [A, B, C]

// 3. From array
String[] array = {"X", "Y", "Z"};
Set<String> set3 = new CopyOnWriteArraySet<>(Arrays.asList(array));
```

---

## üé® Basic Operations

```java
public class CopyOnWriteArraySetDemo {
    public static void main(String[] args) {
        Set<String> set = new CopyOnWriteArraySet<>();
        
        // Add elements
        set.add("Apple");
        set.add("Banana");
        set.add("Cherry");
        set.add("Apple");  // Duplicate - not added
        
        System.out.println(set);  // [Apple, Banana, Cherry]
        
        // Contains
        System.out.println(set.contains("Banana"));  // true
        
        // Remove
        set.remove("Banana");
        System.out.println(set);  // [Apple, Cherry]
        
        // Size
        System.out.println("Size: " + set.size());  // 2
        
        // Add null
        set.add(null);
        System.out.println(set);  // [Apple, Cherry, null]
        
        // Clear
        set.clear();
        System.out.println(set.isEmpty());  // true
    }
}
```

---

## üîí Thread-Safety Demo

```java
public class ThreadSafetyDemo {
    public static void main(String[] args) throws InterruptedException {
        Set<Integer> set = new CopyOnWriteArraySet<>();
        
        // Multiple threads adding elements
        Thread writer1 = new Thread(() -> {
            for (int i = 0; i < 100; i++) {
                set.add(i);
            }
        });
        
        Thread writer2 = new Thread(() -> {
            for (int i = 100; i < 200; i++) {
                set.add(i);
            }
        });
        
        Thread reader = new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("Size: " + set.size());
                try { Thread.sleep(10); } catch (InterruptedException e) {}
            }
        });
        
        writer1.start();
        writer2.start();
        reader.start();
        
        writer1.join();
        writer2.join();
        reader.join();
        
        System.out.println("Final size: " + set.size());  // 200
        // No ConcurrentModificationException!
    }
}
```

---

## üîÑ Snapshot Iteration

```java
public class SnapshotIterationDemo {
    public static void main(String[] args) {
        Set<String> set = new CopyOnWriteArraySet<>();
        set.add("A");
        set.add("B");
        set.add("C");
        
        // Iterator works on snapshot
        Iterator<String> iterator = set.iterator();
        
        // Modify set during iteration
        set.add("D");
        set.remove("B");
        
        // Iterator still sees original snapshot
        System.out.println("Iterator sees:");
        while (iterator.hasNext()) {
            System.out.println(iterator.next());  // A, B, C
        }
        
        System.out.println("\nActual set: " + set);  // [A, C, D]
        
        // No ConcurrentModificationException!
    }
}
```

**Key Point:** Iterator operates on a snapshot taken when iterator was created.

---

## üèóÔ∏è Internal Structure

```java
public class CopyOnWriteArraySet<E> {
    private final CopyOnWriteArrayList<E> al;
    
    public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList<E>();
    }
    
    public boolean add(E e) {
        return al.addIfAbsent(e);  // Thread-safe add if not present
    }
    
    public boolean remove(Object o) {
        return al.remove(o);  // Thread-safe remove
    }
    
    public boolean contains(Object o) {
        return al.contains(o);  // Thread-safe read
    }
}
```

**Copy-on-Write Mechanism:**
```java
// When adding element
synchronized {
    Object[] oldArray = array;
    int len = oldArray.length;
    Object[] newArray = Arrays.copyOf(oldArray, len + 1);  // Copy entire array
    newArray[len] = element;
    array = newArray;  // Atomic reference update
}
```

---

## üìä Performance

| Operation | Time Complexity | Note |
|-----------|----------------|------|
| `add(E e)` | O(n) | Copies entire array |
| `remove(Object o)` | O(n) | Linear search + copy |
| `contains(Object o)` | O(n) | Linear search |
| `size()` | O(1) | |
| Iteration | O(n) | No locking needed |

**Performance Characteristics:**
- **Writes**: Expensive O(n) - creates new array
- **Reads**: Fast - no locking, direct array access
- **Iteration**: Very fast - uses snapshot, no locking

---

## üÜö CopyOnWriteArraySet vs Other Sets

### vs HashSet

| Feature | CopyOnWriteArraySet | HashSet |
|---------|---------------------|---------|
| **Thread-safe** | Yes | No |
| **Performance (add/remove)** | O(n) | O(1) |
| **Performance (contains)** | O(n) | O(1) |
| **Memory** | More (copies array) | Less |
| **Iteration during modification** | Safe (snapshot) | ConcurrentModificationException |
| **Best for** | Concurrent, read-heavy | Single-threaded, fast ops |

```java
// HashSet - not thread-safe
Set<String> hashSet = new HashSet<>();

// CopyOnWriteArraySet - thread-safe
Set<String> cowSet = new CopyOnWriteArraySet<>();
```

---

### vs Collections.synchronizedSet()

```java
// Synchronized wrapper - locks on every operation
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());

// CopyOnWriteArraySet - no locks on reads
Set<String> cowSet = new CopyOnWriteArraySet<>();
```

| Feature | CopyOnWriteArraySet | synchronizedSet |
|---------|---------------------|-----------------|
| **Read locking** | No | Yes |
| **Write locking** | Yes | Yes |
| **Iteration locking** | No (snapshot) | Yes (manual) |
| **Read performance** | Faster | Slower |
| **Write performance** | Much slower | Slower |
| **Memory** | More | Less |

**Iteration with synchronizedSet:**
```java
Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());

// Must manually synchronize for iteration
synchronized(syncSet) {
    for (String s : syncSet) {
        System.out.println(s);
    }
}

// CopyOnWriteArraySet - no manual synchronization needed
Set<String> cowSet = new CopyOnWriteArraySet<>();
for (String s : cowSet) {  // Safe without synchronization
    System.out.println(s);
}
```

---

### vs ConcurrentHashMap.newKeySet()

```java
// ConcurrentHashMap key set - better for large sets
Set<String> concurrentSet = ConcurrentHashMap.newKeySet();

// CopyOnWriteArraySet - better for small, read-heavy sets
Set<String> cowSet = new CopyOnWriteArraySet<>();
```

| Feature | CopyOnWriteArraySet | ConcurrentHashMap.newKeySet() |
|---------|---------------------|-------------------------------|
| **Order** | Insertion order | No order |
| **Read performance** | O(n) | O(1) |
| **Write performance** | O(n) | O(1) |
| **Best size** | Small (< 100) | Any size |
| **Best for** | Read-heavy, small | General concurrent use |

---

## üéØ Use Cases

### Use Case 1: Event Listeners

```java
class EventManager {
    private final Set<EventListener> listeners = new CopyOnWriteArraySet<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    public void removeListener(EventListener listener) {
        listeners.remove(listener);
    }
    
    public void fireEvent(Event event) {
        // Safe iteration even if listeners are added/removed during notification
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
}

interface EventListener {
    void onEvent(Event event);
}
```

---

### Use Case 2: Observable Pattern

```java
class Subject {
    private final Set<Observer> observers = new CopyOnWriteArraySet<>();
    private int state;
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void setState(int state) {
        this.state = state;
        notifyObservers();
    }
    
    private void notifyObservers() {
        // Safe even if observers add/remove themselves during notification
        for (Observer observer : observers) {
            observer.update(state);
        }
    }
}

interface Observer {
    void update(int state);
}
```

---

### Use Case 3: Cache Invalidation Listeners

```java
class Cache {
    private final Set<CacheListener> listeners = new CopyOnWriteArraySet<>();
    private final Map<String, Object> data = new ConcurrentHashMap<>();
    
    public void addListener(CacheListener listener) {
        listeners.add(listener);
    }
    
    public void put(String key, Object value) {
        data.put(key, value);
        notifyListeners(key);
    }
    
    public void remove(String key) {
        data.remove(key);
        notifyListeners(key);
    }
    
    private void notifyListeners(String key) {
        for (CacheListener listener : listeners) {
            listener.onCacheUpdate(key);
        }
    }
}

interface CacheListener {
    void onCacheUpdate(String key);
}
```

---

### Use Case 4: Active User Sessions

```java
class SessionManager {
    private final Set<String> activeSessions = new CopyOnWriteArraySet<>();
    
    public void login(String sessionId) {
        activeSessions.add(sessionId);
    }
    
    public void logout(String sessionId) {
        activeSessions.remove(sessionId);
    }
    
    public boolean isActive(String sessionId) {
        return activeSessions.contains(sessionId);
    }
    
    public List<String> getActiveSessions() {
        // Returns snapshot - safe for concurrent access
        return new ArrayList<>(activeSessions);
    }
    
    public int getActiveCount() {
        return activeSessions.size();
    }
}
```

---

## ‚ö†Ô∏è When NOT to Use

```java
// ‚ùå Don't use for large collections
Set<Integer> large = new CopyOnWriteArraySet<>();
for (int i = 0; i < 10_000; i++) {
    large.add(i);  // Very slow - copies array 10,000 times!
}

// ‚ùå Don't use for write-heavy workloads
Set<String> writeHeavy = new CopyOnWriteArraySet<>();
// Many concurrent writes = poor performance

// ‚ùå Don't use when memory is limited
// Each write creates a new array copy

// ‚úÖ Use ConcurrentHashMap.newKeySet() instead
Set<Integer> better = ConcurrentHashMap.newKeySet();
```

---

## üí° Best Practices

1. **Use for small collections** (typically < 100 elements)
2. **Use for read-heavy workloads** (reads >> writes)
3. **Ideal for observer/listener patterns**
4. **Good for event notifications**
5. **Don't use for write-heavy scenarios**
6. **Don't use for large collections**
7. **Consider ConcurrentHashMap.newKeySet()** for general concurrent use
8. **No manual synchronization needed** for iteration

---

## üéØ When to Use CopyOnWriteArraySet

**Use CopyOnWriteArraySet when:**
- ‚úÖ Thread-safety required
- ‚úÖ Read operations >> Write operations
- ‚úÖ Small collection size (< 100 elements)
- ‚úÖ Iteration without locking needed
- ‚úÖ Observer/listener patterns
- ‚úÖ Event notification systems
- ‚úÖ Snapshot consistency needed

**Don't use CopyOnWriteArraySet when:**
- ‚ùå Large collections (> 1000 elements)
- ‚ùå Frequent writes
- ‚ùå Write operations common
- ‚ùå Memory is constrained
- ‚ùå Need fast contains/remove ‚Üí Use `ConcurrentHashMap.newKeySet()`
- ‚ùå Single-threaded ‚Üí Use `HashSet` or `LinkedHashSet`

---

## üìä Performance Comparison

```java
public class PerformanceTest {
    private static final int SIZE = 1000;
    private static final int READS = 10_000;
    
    public static void main(String[] args) {
        testWrites();
        testReads();
    }
    
    private static void testWrites() {
        System.out.println("=== Write Performance ===");
        
        long start = System.nanoTime();
        Set<Integer> cowSet = new CopyOnWriteArraySet<>();
        for (int i = 0; i < SIZE; i++) cowSet.add(i);
        long cowTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Set<Integer> syncSet = Collections.synchronizedSet(new HashSet<>());
        for (int i = 0; i < SIZE; i++) syncSet.add(i);
        long syncTime = System.nanoTime() - start;
        
        start = System.nanoTime();
        Set<Integer> concSet = ConcurrentHashMap.newKeySet();
        for (int i = 0; i < SIZE; i++) concSet.add(i);
        long concTime = System.nanoTime() - start;
        
        System.out.println("CopyOnWriteArraySet: " + cowTime / 1_000_000 + " ms");
        System.out.println("SynchronizedSet: " + syncTime / 1_000_000 + " ms");
        System.out.println("ConcurrentHashMap: " + concTime / 1_000_000 + " ms");
        // CopyOnWriteArraySet is slowest for writes
    }
}

// Typical results for 1000 elements:
// CopyOnWriteArraySet: 50 ms (slowest)
// SynchronizedSet: 5 ms
// ConcurrentHashMap: 3 ms (fastest)
```

---

## üìö Summary

- **CopyOnWriteArraySet**: Thread-safe Set with copy-on-write semantics
- **Best for**: Read-heavy workloads with rare writes
- **Write operations**: O(n) - creates new array copy
- **Read operations**: Fast - no locking required
- **Iteration**: Safe without locking (uses snapshot)
- **Memory**: High - maintains array copies
- **No ConcurrentModificationException** during iteration
- **Maintains insertion order**
- **Allows null** elements
- **Ideal for**: Observers, listeners, event handlers
- Use **ConcurrentHashMap.newKeySet()** for large or write-heavy collections
