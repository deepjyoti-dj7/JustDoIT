# üîÑ Thread Lifecycle

## üìñ Overview

A thread in Java goes through various states during its lifetime. Understanding the thread lifecycle is crucial for effective multithreading programming.

---

## üéØ Thread States

Java defines **6 thread states** in the `Thread.State` enum:

1. **NEW**
2. **RUNNABLE**
3. **BLOCKED**
4. **WAITING**
5. **TIMED_WAITING**
6. **TERMINATED**

---

## üìä Thread State Diagram

```
         NEW
          |
          | start()
          ‚Üì
      RUNNABLE ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       |  ‚Üë  ‚Üë                 |
       |  |  |                 |
       |  |  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
       |  |                    |
       |  |  synchronized      |  notify/notifyAll
       |  |  block acquired    |  lock acquired
       |  |                    |  timeout/interrupt
       |  ‚Üì                    |
       | BLOCKED               |
       |                       |
       | wait()                |
       | join()                |
       | park()                |
       ‚Üì                       |
      WAITING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       |
       | sleep(time)
       | wait(time)
       | join(time)
       ‚Üì
   TIMED_WAITING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       |
       | task completion
       ‚Üì
    TERMINATED
```

---

## üîç Detailed State Explanation

### 1. NEW

Thread is created but not yet started.

```java
Thread thread = new Thread(() -> {
    System.out.println("Task running");
});

System.out.println(thread.getState()); // NEW
```

---

### 2. RUNNABLE

Thread is executing or ready to execute (waiting for CPU allocation).

```java
Thread thread = new Thread(() -> {
    System.out.println("State: " + Thread.currentThread().getState()); // RUNNABLE
    for (int i = 0; i < 1000000; i++) {
        // Some work
    }
});

thread.start();
Thread.sleep(100);
System.out.println(thread.getState()); // RUNNABLE (if still executing)
```

**Note**: In RUNNABLE state, thread may be:
- **Running**: Actually executing on CPU
- **Ready**: Waiting for CPU time slice

---

### 3. BLOCKED

Thread is waiting to acquire a lock held by another thread.

```java
class BlockedStateExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 1: Acquired lock");
                try {
                    Thread.sleep(5000); // Hold lock for 5 seconds
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2: Acquired lock");
            }
        });
        
        thread1.start();
        Thread.sleep(100); // Let thread1 acquire lock first
        
        thread2.start();
        Thread.sleep(100);
        
        System.out.println("Thread 1 state: " + thread1.getState()); // TIMED_WAITING
        System.out.println("Thread 2 state: " + thread2.getState()); // BLOCKED
    }
}
```

---

### 4. WAITING

Thread is waiting indefinitely for another thread to perform a specific action.

**Methods that cause WAITING state:**
- `Object.wait()` (without timeout)
- `Thread.join()` (without timeout)
- `LockSupport.park()`

```java
class WaitingStateExample {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();
        
        Thread waitingThread = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Thread going to wait...");
                    lock.wait(); // Thread will wait indefinitely
                    System.out.println("Thread resumed");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        waitingThread.start();
        Thread.sleep(100);
        
        System.out.println("Waiting thread state: " + waitingThread.getState()); // WAITING
        
        // Notify the waiting thread
        synchronized (lock) {
            lock.notify();
        }
    }
}
```

---

### 5. TIMED_WAITING

Thread is waiting for a specified period of time.

**Methods that cause TIMED_WAITING state:**
- `Thread.sleep(time)`
- `Object.wait(time)`
- `Thread.join(time)`
- `LockSupport.parkNanos()`
- `LockSupport.parkUntil()`

```java
class TimedWaitingStateExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                System.out.println("Thread sleeping for 5 seconds...");
                Thread.sleep(5000);
                System.out.println("Thread woke up");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        thread.start();
        Thread.sleep(100);
        
        System.out.println("Thread state: " + thread.getState()); // TIMED_WAITING
    }
}
```

---

### 6. TERMINATED

Thread has completed execution or terminated abnormally.

```java
Thread thread = new Thread(() -> {
    System.out.println("Task completed");
});

thread.start();
thread.join(); // Wait for completion

System.out.println("Thread state: " + thread.getState()); // TERMINATED
```

---

## üíª Complete Lifecycle Example

```java
public class ThreadLifecycleDemo {
    public static void main(String[] args) throws InterruptedException {
        final Object lock = new Object();
        
        Thread thread = new Thread(() -> {
            System.out.println("Inside run method");
            
            synchronized (lock) {
                try {
                    // State: TIMED_WAITING
                    Thread.sleep(1000);
                    
                    // State: WAITING
                    lock.wait(2000);
                    
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            
            System.out.println("Thread finishing execution");
        });
        
        // State: NEW
        System.out.println("1. State after creation: " + thread.getState());
        
        thread.start();
        
        // State: RUNNABLE
        Thread.sleep(100);
        System.out.println("2. State after start(): " + thread.getState());
        
        // State: TIMED_WAITING (during sleep)
        Thread.sleep(500);
        System.out.println("3. State during sleep(): " + thread.getState());
        
        // State: WAITING (during wait)
        Thread.sleep(1000);
        System.out.println("4. State during wait(): " + thread.getState());
        
        // Wait for thread to complete
        thread.join();
        
        // State: TERMINATED
        System.out.println("5. State after completion: " + thread.getState());
    }
}
```

**Output:**
```
1. State after creation: NEW
2. State after start(): RUNNABLE
Inside run method
3. State during sleep(): TIMED_WAITING
4. State during wait(): TIMED_WAITING
Thread finishing execution
5. State after completion: TERMINATED
```

---

## üìä State Transition Methods

| Method | From State | To State |
|--------|-----------|----------|
| `start()` | NEW | RUNNABLE |
| `sleep(time)` | RUNNABLE | TIMED_WAITING |
| `wait()` | RUNNABLE | WAITING |
| `wait(time)` | RUNNABLE | TIMED_WAITING |
| `join()` | RUNNABLE | WAITING |
| `join(time)` | RUNNABLE | TIMED_WAITING |
| `notify()/notifyAll()` | WAITING | RUNNABLE |
| Lock acquisition | RUNNABLE | BLOCKED |
| Lock release | BLOCKED | RUNNABLE |
| Task completion | Any | TERMINATED |

---

## ‚ö†Ô∏è Important Notes

1. **Thread can't go back to NEW or come back from TERMINATED**
2. **A thread in BLOCKED state is waiting for a monitor lock**
3. **A thread in WAITING state is waiting for another thread's action**
4. **TIMED_WAITING automatically transitions back after timeout**
5. **RUNNABLE includes both ready and running states**
6. **Thread scheduler decides when RUNNABLE thread gets CPU time**

---

## üí° Best Practices

1. ‚úÖ Always check thread state before performing operations
2. ‚úÖ Don't assume thread will be in expected state (race conditions)
3. ‚úÖ Use proper synchronization when checking states
4. ‚úÖ Handle `InterruptedException` properly to respond to state changes
5. ‚úÖ Avoid spinning on thread state checks (wastes CPU)

---

## üéØ Interview Questions

1. **What are the different states of a thread in Java?**
2. **What is the difference between BLOCKED and WAITING state?**
3. **Can a terminated thread be restarted?**
4. **What causes a thread to enter BLOCKED state?**
5. **What is the difference between WAITING and TIMED_WAITING?**
6. **How does sleep() differ from wait() in terms of state?**
7. **What happens when notify() is called on a WAITING thread?**
8. **Can you have a thread in RUNNABLE state that's not actually running?**

---

## üìö Next Topics

- [Thread Creation Methods](03.%20Thread%20Creation%20Methods.md)
- [Synchronization](../02.%20Synchronization/01.%20Race%20Conditions.md)
- [Thread Communication](../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
