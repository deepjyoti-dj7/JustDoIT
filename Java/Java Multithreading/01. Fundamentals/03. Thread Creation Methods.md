# üõ†Ô∏è Thread Creation Methods

## üìñ Overview

In Java, there are **4 primary ways** to create and execute threads:

1. **Extending Thread class**
2. **Implementing Runnable interface**
3. **Implementing Callable interface**
4. **Using Lambda Expressions**

---

## üéØ Method 1: Extending Thread Class

### Theory
Create a subclass of `Thread` and override the `run()` method.

### Example

```java
class MyThread extends Thread {
    private String threadName;
    
    public MyThread(String name) {
        this.threadName = name;
    }
    
    @Override
    public void run() {
        System.out.println(threadName + " started");
        for (int i = 1; i <= 5; i++) {
            System.out.println(threadName + ": " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println(threadName + " interrupted");
            }
        }
        System.out.println(threadName + " completed");
    }
}

public class ThreadClassExample {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread("Thread-1");
        MyThread thread2 = new MyThread("Thread-2");
        
        thread1.start();
        thread2.start();
    }
}
```

### ‚úÖ Advantages
- Simple and straightforward
- Can override other Thread methods if needed

### ‚ùå Disadvantages
- Can't extend another class (Java doesn't support multiple inheritance)
- Tight coupling with Thread class
- Not recommended in modern Java

---

## üéØ Method 2: Implementing Runnable Interface

### Theory
Create a class that implements `Runnable` interface and pass it to a `Thread` object.

### Example

```java
class MyRunnable implements Runnable {
    private String taskName;
    
    public MyRunnable(String name) {
        this.taskName = name;
    }
    
    @Override
    public void run() {
        System.out.println(taskName + " started by " + Thread.currentThread().getName());
        for (int i = 1; i <= 5; i++) {
            System.out.println(taskName + ": " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println(taskName + " interrupted");
            }
        }
        System.out.println(taskName + " completed");
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        MyRunnable task1 = new MyRunnable("Task-1");
        MyRunnable task2 = new MyRunnable("Task-2");
        
        Thread thread1 = new Thread(task1);
        Thread thread2 = new Thread(task2);
        
        thread1.start();
        thread2.start();
    }
}
```

### ‚úÖ Advantages
- Better design (separates task from thread mechanism)
- Can extend another class
- More flexible and reusable
- **Recommended approach**

### ‚ùå Disadvantages
- Slightly more verbose than extending Thread
- No return value from run() method

---

## üéØ Method 3: Implementing Callable Interface

### Theory
`Callable` is similar to `Runnable` but can return a result and throw checked exceptions. Used with `ExecutorService`.

### Example

```java
import java.util.concurrent.*;

class MyCallable implements Callable<Integer> {
    private String taskName;
    private int number;
    
    public MyCallable(String name, int number) {
        this.taskName = name;
        this.number = number;
    }
    
    @Override
    public Integer call() throws Exception {
        System.out.println(taskName + " started");
        Thread.sleep(2000);
        
        int sum = 0;
        for (int i = 1; i <= number; i++) {
            sum += i;
        }
        
        System.out.println(taskName + " completed");
        return sum;
    }
}

public class CallableExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        Callable<Integer> task1 = new MyCallable("Task-1", 10);
        Callable<Integer> task2 = new MyCallable("Task-2", 20);
        
        Future<Integer> future1 = executor.submit(task1);
        Future<Integer> future2 = executor.submit(task2);
        
        try {
            Integer result1 = future1.get(); // Blocking call
            Integer result2 = future2.get();
            
            System.out.println("Result 1: " + result1);
            System.out.println("Result 2: " + result2);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

**Output:**
```
Task-1 started
Task-2 started
Task-1 completed
Task-2 completed
Result 1: 55
Result 2: 210
```

### ‚úÖ Advantages
- Can return a result
- Can throw checked exceptions
- Better for computational tasks
- Works with ExecutorService

### ‚ùå Disadvantages
- Requires ExecutorService
- More complex than Runnable

---

## üéØ Method 4: Using Lambda Expressions (Java 8+)

### Theory
Since `Runnable` is a functional interface, we can use lambda expressions for cleaner code.

### Example 1: Simple Lambda

```java
public class LambdaExample {
    public static void main(String[] args) {
        // Lambda expression with Runnable
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1 executing");
            for (int i = 1; i <= 5; i++) {
                System.out.println("Count: " + i);
            }
        });
        
        Thread thread2 = new Thread(() -> {
            System.out.println("Thread 2 executing");
            System.out.println("Current thread: " + Thread.currentThread().getName());
        });
        
        thread1.start();
        thread2.start();
    }
}
```

### Example 2: Lambda with Method Reference

```java
public class MethodReferenceExample {
    
    public static void printMessage() {
        System.out.println("Method reference example");
        System.out.println("Thread: " + Thread.currentThread().getName());
    }
    
    public void instanceMethod() {
        System.out.println("Instance method executing");
    }
    
    public static void main(String[] args) {
        // Static method reference
        Thread thread1 = new Thread(MethodReferenceExample::printMessage);
        thread1.start();
        
        // Instance method reference
        MethodReferenceExample obj = new MethodReferenceExample();
        Thread thread2 = new Thread(obj::instanceMethod);
        thread2.start();
    }
}
```

### ‚úÖ Advantages
- Clean and concise syntax
- Less boilerplate code
- Modern Java approach
- Easy to read and maintain

### ‚ùå Disadvantages
- Less explicit than other methods
- May be harder to debug

---

## üìä Comparison Table

| Method | Syntax Complexity | Flexibility | Return Value | Exception Handling | Use Case |
|--------|------------------|-------------|--------------|-------------------|----------|
| **Extend Thread** | Simple | Limited | No | Unchecked only | Simple scenarios |
| **Implement Runnable** | Moderate | High | No | Unchecked only | **Most common** |
| **Implement Callable** | Complex | High | Yes | Checked & Unchecked | Computational tasks |
| **Lambda** | Very Simple | High | No | Unchecked only | Quick tasks |

---

## üíª Complete Comparison Example

```java
import java.util.concurrent.*;

public class AllMethodsComparison {
    
    // Method 1: Extend Thread
    static class MyThread extends Thread {
        @Override
        public void run() {
            System.out.println("Method 1 - Thread class");
        }
    }
    
    // Method 2: Implement Runnable
    static class MyRunnable implements Runnable {
        @Override
        public void run() {
            System.out.println("Method 2 - Runnable interface");
        }
    }
    
    // Method 3: Implement Callable
    static class MyCallable implements Callable<String> {
        @Override
        public String call() throws Exception {
            return "Method 3 - Callable interface";
        }
    }
    
    public static void main(String[] args) throws Exception {
        // Method 1
        MyThread thread1 = new MyThread();
        thread1.start();
        
        // Method 2
        Thread thread2 = new Thread(new MyRunnable());
        thread2.start();
        
        // Method 3
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(new MyCallable());
        System.out.println(future.get());
        executor.shutdown();
        
        // Method 4
        Thread thread4 = new Thread(() -> {
            System.out.println("Method 4 - Lambda expression");
        });
        thread4.start();
    }
}
```

---

## üéØ Using Thread Pool (Best Practice)

```java
import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // Create a thread pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit 5 tasks
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            
            executor.submit(() -> {
                System.out.println("Task " + taskId + " started by " + 
                                   Thread.currentThread().getName());
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task " + taskId + " completed");
            });
        }
        
        // Shutdown executor
        executor.shutdown();
        
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}
```

---

## üí° Best Practices

1. ‚úÖ **Prefer Runnable over Thread**: Better design and flexibility
2. ‚úÖ **Use Callable for return values**: When you need results
3. ‚úÖ **Use Lambda for simple tasks**: Clean and concise
4. ‚úÖ **Use ExecutorService**: Instead of creating threads manually
5. ‚úÖ **Give threads meaningful names**: For debugging
6. ‚úÖ **Handle InterruptedException**: Properly restore interrupt status

---

## üéØ Interview Questions

1. **What are the different ways to create a thread in Java?**
2. **What is the difference between Runnable and Callable?**
3. **Why is implementing Runnable better than extending Thread?**
4. **Can we use lambda expressions with Callable?**
5. **What is the advantage of using ExecutorService?**
6. **How do you handle the return value from a Callable?**
7. **What happens if you call run() instead of start()?**
8. **Can you restart a terminated thread?**

---

## üìö Next Topics

- [Thread vs Runnable](04.%20Thread%20vs%20Runnable.md)
- [ExecutorService](../04.%20Executor%20Framework/01.%20ExecutorService.md)
- [Callable & Future](../04.%20Executor%20Framework/03.%20Callable%20%26%20Future.md)
