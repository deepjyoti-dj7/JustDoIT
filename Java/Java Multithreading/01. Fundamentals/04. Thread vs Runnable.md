# âš”ï¸ Thread vs Runnable

## ğŸ“– Overview

Understanding when to use `Thread` class vs `Runnable` interface is crucial for designing effective multithreaded applications.

---

## ğŸ” Key Differences

| Aspect | Thread Class | Runnable Interface |
|--------|-------------|-------------------|
| **Inheritance** | Extends Thread | Implements Runnable |
| **Multiple Inheritance** | âŒ Can't extend other class | âœ… Can extend another class |
| **Reusability** | âŒ Less reusable | âœ… Highly reusable |
| **Coupling** | Tight coupling | Loose coupling |
| **Design** | Represents a thread | Represents a task |
| **Object Creation** | One object (thread+task) | Two objects (thread+task) |
| **Overhead** | More overhead | Less overhead |
| **Best Practice** | âŒ Not recommended | âœ… **Recommended** |

---

## ğŸ’» Example Comparison

### Using Thread Class

```java
class PrintTask extends Thread {
    private String message;
    
    public PrintTask(String message) {
        this.message = message;
    }
    
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(message + " - " + i);
        }
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        PrintTask task1 = new PrintTask("Task-1");
        PrintTask task2 = new PrintTask("Task-2");
        
        task1.start();
        task2.start();
    }
}
```

### Using Runnable Interface

```java
class PrintTask implements Runnable {
    private String message;
    
    public PrintTask(String message) {
        this.message = message;
    }
    
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(message + " - " + i);
        }
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        PrintTask task1 = new PrintTask("Task-1");
        PrintTask task2 = new PrintTask("Task-2");
        
        Thread thread1 = new Thread(task1);
        Thread thread2 = new Thread(task2);
        
        thread1.start();
        thread2.start();
    }
}
```

---

## ğŸ¯ Why Runnable is Better?

### 1. Separation of Concerns

```java
// Task logic is separate from thread mechanism
class DataProcessor implements Runnable {
    private String data;
    
    public DataProcessor(String data) {
        this.data = data;
    }
    
    @Override
    public void run() {
        // Process data
        System.out.println("Processing: " + data);
    }
    
    // Can have other methods
    public void preProcess() {
        System.out.println("Pre-processing: " + data);
    }
}

public class SeparationExample {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor("MyData");
        
        // Can use the task without threading
        processor.preProcess();
        
        // Can use with threading when needed
        Thread thread = new Thread(processor);
        thread.start();
    }
}
```

### 2. Reusability

```java
class Task implements Runnable {
    private int taskId;
    
    public Task(int id) {
        this.taskId = id;
    }
    
    @Override
    public void run() {
        System.out.println("Task " + taskId + " executing on " + 
                          Thread.currentThread().getName());
    }
}

public class ReusabilityExample {
    public static void main(String[] args) {
        // Same task can be executed by multiple threads
        Task sharedTask = new Task(1);
        
        Thread thread1 = new Thread(sharedTask, "Thread-1");
        Thread thread2 = new Thread(sharedTask, "Thread-2");
        Thread thread3 = new Thread(sharedTask, "Thread-3");
        
        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

### 3. Extending Another Class

```java
// Can extend another class while implementing Runnable
class Vehicle {
    protected String name;
    
    public Vehicle(String name) {
        this.name = name;
    }
    
    public void start() {
        System.out.println(name + " starting...");
    }
}

class Car extends Vehicle implements Runnable {
    public Car(String name) {
        super(name);
    }
    
    @Override
    public void run() {
        start();
        System.out.println(name + " is running on " + 
                          Thread.currentThread().getName());
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        Car car1 = new Car("Tesla");
        Car car2 = new Car("BMW");
        
        Thread thread1 = new Thread(car1);
        Thread thread2 = new Thread(car2);
        
        thread1.start();
        thread2.start();
    }
}
```

### 4. Better for Thread Pools

```java
import java.util.concurrent.*;

class WorkerTask implements Runnable {
    private int taskId;
    
    public WorkerTask(int id) {
        this.taskId = id;
    }
    
    @Override
    public void run() {
        System.out.println("Task " + taskId + " started by " + 
                          Thread.currentThread().getName());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Task " + taskId + " completed");
    }
}

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit multiple tasks (all are Runnable)
        for (int i = 1; i <= 10; i++) {
            executor.submit(new WorkerTask(i));
        }
        
        executor.shutdown();
    }
}
```

---

## ğŸ“Š Memory and Resource Comparison

### Thread Class Approach

```java
class HeavyThread extends Thread {
    private byte[] data = new byte[1024 * 1024]; // 1MB
    
    @Override
    public void run() {
        System.out.println("Heavy thread running");
    }
}

public class ThreadMemoryExample {
    public static void main(String[] args) {
        // Each object carries thread overhead + task data
        HeavyThread t1 = new HeavyThread(); // Thread object + 1MB
        HeavyThread t2 = new HeavyThread(); // Thread object + 1MB
        
        t1.start();
        t2.start();
    }
}
```

### Runnable Approach

```java
class LightTask implements Runnable {
    private byte[] data = new byte[1024 * 1024]; // 1MB
    
    @Override
    public void run() {
        System.out.println("Light task running");
    }
}

public class RunnableMemoryExample {
    public static void main(String[] args) {
        LightTask task1 = new LightTask(); // Just task data (1MB)
        LightTask task2 = new LightTask(); // Just task data (1MB)
        
        // Thread objects are separate and lightweight
        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);
        
        t1.start();
        t2.start();
    }
}
```

---

## ğŸ¯ When to Use Thread Class?

### Rare Use Case: Need to Override Thread Methods

```java
class CustomThread extends Thread {
    @Override
    public void run() {
        System.out.println("Task executing");
    }
    
    @Override
    public void interrupt() {
        System.out.println("Custom interrupt logic");
        super.interrupt();
    }
    
    @Override
    public String toString() {
        return "CustomThread: " + getName();
    }
}

public class ThreadClassUseCase {
    public static void main(String[] args) {
        CustomThread thread = new CustomThread();
        thread.start();
        
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        thread.interrupt();
        System.out.println(thread);
    }
}
```

**Note**: Even in this case, composition is often better than inheritance.

---

## ğŸ’¡ Modern Approach: Lambda with Runnable

```java
public class ModernApproach {
    public static void main(String[] args) {
        // Clean and concise with lambda
        Thread thread1 = new Thread(() -> {
            System.out.println("Task 1 executing");
            // Task logic here
        });
        
        Thread thread2 = new Thread(() -> {
            System.out.println("Task 2 executing");
            // Task logic here
        });
        
        thread1.start();
        thread2.start();
    }
}
```

---

## ğŸ“‹ Design Pattern Perspective

### âŒ Bad Design (Thread)

```java
// Violates Single Responsibility Principle
class DatabaseTask extends Thread {
    private String query;
    
    public DatabaseTask(String query) {
        this.query = query;
    }
    
    @Override
    public void run() {
        // Task is tightly coupled with threading mechanism
        System.out.println("Executing: " + query);
    }
}
```

### âœ… Good Design (Runnable)

```java
// Follows Single Responsibility Principle
class DatabaseTask implements Runnable {
    private String query;
    
    public DatabaseTask(String query) {
        this.query = query;
    }
    
    @Override
    public void run() {
        executeQuery();
    }
    
    private void executeQuery() {
        // Task logic is independent of threading
        System.out.println("Executing: " + query);
    }
    
    // Can test this method without threading
    public void testExecuteQuery() {
        executeQuery();
    }
}
```

---

## ğŸ§ª Testing Comparison

### Testing Thread Class (Harder)

```java
class TaskThread extends Thread {
    private int result;
    
    @Override
    public void run() {
        result = compute();
    }
    
    private int compute() {
        return 42;
    }
    
    public int getResult() {
        return result;
    }
}

// Testing requires thread management
public class ThreadTestExample {
    public static void main(String[] args) throws InterruptedException {
        TaskThread thread = new TaskThread();
        thread.start();
        thread.join(); // Must wait for thread
        
        System.out.println("Result: " + thread.getResult());
    }
}
```

### Testing Runnable (Easier)

```java
class TaskRunnable implements Runnable {
    private int result;
    
    @Override
    public void run() {
        result = compute();
    }
    
    private int compute() {
        return 42;
    }
    
    public int getResult() {
        return result;
    }
}

// Can test without threading
public class RunnableTestExample {
    public static void main(String[] args) {
        TaskRunnable task = new TaskRunnable();
        
        // Direct method testing
        task.run(); // No thread needed for testing
        
        System.out.println("Result: " + task.getResult());
    }
}
```

---

## ğŸ’¡ Best Practices

1. âœ… **Always prefer Runnable over Thread**
2. âœ… **Use lambda expressions for simple tasks**
3. âœ… **Use ExecutorService with Runnable**
4. âœ… **Keep task logic separate from threading logic**
5. âœ… **Make tasks testable without threading**
6. âœ… **Follow composition over inheritance**

---

## ğŸ¯ Interview Questions

1. **Why is Runnable interface better than Thread class?**
2. **Can you implement Runnable and extend another class simultaneously?**
3. **What is the relationship between Thread and Runnable?**
4. **Can you pass the same Runnable instance to multiple threads?**
5. **Does implementing Runnable mean the class is thread-safe?**
6. **How does ExecutorService work with Runnable?**
7. **What are the memory implications of Thread vs Runnable?**
8. **Can you override Thread methods when implementing Runnable?**

---

## ğŸ“š Next Topics

- [Synchronization](../02.%20Synchronization/01.%20Race%20Conditions.md)
- [ExecutorService](../04.%20Executor%20Framework/01.%20ExecutorService.md)
- [Thread Pools](../04.%20Executor%20Framework/02.%20Thread%20Pools.md)
