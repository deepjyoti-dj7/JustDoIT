# ğŸ§µ Thread Basics

## ğŸ“– What is a Thread?

A **thread** is the smallest unit of execution within a process. It is a lightweight subprocess that shares the same memory space with other threads in the same process but executes independently.

### Key Points:
- Threads exist within a process
- Multiple threads share the same memory (heap) but have their own stack
- Enables concurrent execution and better CPU utilization
- Lighter weight than processes (faster creation and context switching)

---

## ğŸ¯ Why Use Threads?

1. **Concurrency**: Execute multiple tasks simultaneously
2. **Responsiveness**: Keep UI responsive while performing background tasks
3. **Resource Sharing**: Threads share memory, making communication easier
4. **Performance**: Better CPU utilization on multi-core systems
5. **Asynchronous Processing**: Handle I/O operations without blocking

---

## ğŸ” Thread vs Process

| Feature | Thread | Process |
|---------|--------|---------|
| **Memory** | Shared within process | Separate memory space |
| **Communication** | Easy (shared memory) | Complex (IPC needed) |
| **Creation Time** | Fast | Slow |
| **Context Switching** | Lightweight | Heavyweight |
| **Resource Usage** | Less | More |
| **Isolation** | Low | High |

---

## ğŸ’» Basic Thread Example

### Example 1: Simple Thread Creation

```java
public class ThreadBasicsExample {
    public static void main(String[] args) {
        // Main thread
        System.out.println("Main thread: " + Thread.currentThread().getName());
        System.out.println("Main thread ID: " + Thread.currentThread().getId());
        System.out.println("Main thread priority: " + Thread.currentThread().getPriority());
        
        // Create and start a new thread
        Thread thread = new Thread(() -> {
            System.out.println("\nChild thread: " + Thread.currentThread().getName());
            System.out.println("Child thread ID: " + Thread.currentThread().getId());
            System.out.println("Child thread priority: " + Thread.currentThread().getPriority());
        });
        
        thread.start();
    }
}
```

**Output:**
```
Main thread: main
Main thread ID: 1
Main thread priority: 5
Child thread: Thread-0
Child thread ID: 12
Child thread priority: 5
```

---

### Example 2: Thread with Loop

```java
public class ThreadLoopExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread 1: " + i);
                try {
                    Thread.sleep(500); // Sleep for 500ms
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread 2: " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        thread1.start();
        thread2.start();
    }
}
```

**Output:** (Output may vary due to thread scheduling)
```
Thread 1: 1
Thread 2: 1
Thread 1: 2
Thread 2: 2
Thread 1: 3
Thread 2: 3
...
```

---

## ğŸ“Š Thread Properties

### 1. Thread Name

```java
Thread thread = new Thread(() -> {
    System.out.println("Current thread: " + Thread.currentThread().getName());
});

thread.setName("MyWorkerThread");
thread.start();
```

### 2. Thread Priority

```java
Thread thread = new Thread(() -> {
    System.out.println("Priority: " + Thread.currentThread().getPriority());
});

// Priority range: 1 (MIN_PRIORITY) to 10 (MAX_PRIORITY), default is 5 (NORM_PRIORITY)
thread.setPriority(Thread.MAX_PRIORITY); // 10
thread.start();
```

### 3. Thread ID

```java
Thread thread = new Thread(() -> {
    System.out.println("Thread ID: " + Thread.currentThread().getId());
});
thread.start();
```

### 4. Daemon vs User Threads

```java
Thread daemonThread = new Thread(() -> {
    while (true) {
        System.out.println("Daemon thread running...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            break;
        }
    }
});

daemonThread.setDaemon(true); // Set as daemon before starting
daemonThread.start();

// Main thread sleeps for 3 seconds then exits
Thread.sleep(3000);
System.out.println("Main thread exiting...");
// Daemon thread will automatically terminate when main exits
```

---

## ğŸ“ Important Thread Methods

### Static Methods

```java
// Get current thread
Thread currentThread = Thread.currentThread();

// Sleep current thread
Thread.sleep(1000); // Sleep for 1 second

// Yield current thread (hint to scheduler)
Thread.yield();

// Check if interrupted
boolean interrupted = Thread.interrupted();
```

### Instance Methods

```java
Thread thread = new Thread(() -> {
    // Task implementation
});

// Start the thread
thread.start();

// Wait for thread to complete
thread.join();

// Check if thread is alive
boolean isAlive = thread.isAlive();

// Interrupt the thread
thread.interrupt();

// Check if interrupted
boolean isInterrupted = thread.isInterrupted();

// Get/Set thread state
thread.getState();
thread.setName("WorkerThread");
thread.setPriority(Thread.MAX_PRIORITY);
```

---

## âš ï¸ Common Mistakes

### âŒ Mistake 1: Calling run() instead of start()

```java
// WRONG - This runs in the same thread
thread.run();

// CORRECT - This creates a new thread
thread.start();
```

### âŒ Mistake 2: Starting a thread twice

```java
Thread thread = new Thread(() -> System.out.println("Hello"));
thread.start();
thread.start(); // IllegalThreadStateException
```

### âŒ Mistake 3: Not handling InterruptedException

```java
// BAD
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    // Swallowing exception
}

// GOOD
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // Restore interrupt status
    // Handle or propagate
}
```

---

## ğŸ’¡ Best Practices

1. âœ… Always give meaningful names to threads
2. âœ… Handle `InterruptedException` properly
3. âœ… Prefer `Runnable` over extending `Thread` class
4. âœ… Use thread pools instead of creating threads manually
5. âœ… Set appropriate thread priority only when necessary
6. âœ… Make daemon threads for background tasks

---

## ğŸ¯ Interview Questions

1. **What is the difference between a process and a thread?**
2. **What happens when you call run() instead of start()?**
3. **Can we start a thread twice?**
4. **What is the default priority of a thread?**
5. **What is a daemon thread?**
6. **How many ways can we create a thread in Java?**
7. **What is the difference between Thread.sleep() and Object.wait()?**

---

## ğŸ“š Next Topics

- [Thread Lifecycle](02.%20Thread%20Lifecycle.md)
- [Thread Creation Methods](03.%20Thread%20Creation%20Methods.md)
- [Thread vs Runnable](04.%20Thread%20vs%20Runnable.md)
