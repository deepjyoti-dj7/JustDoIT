# üî± ForkJoinPool

## üìñ What is ForkJoinPool?

A specialized `ExecutorService` designed for divide-and-conquer algorithms. It uses work-stealing algorithm where idle threads steal work from busy threads.

**Key Features:**
- Work-stealing algorithm
- Recursive task decomposition
- Optimal for CPU-intensive tasks
- Better performance for parallel algorithms

---

## üíª Example 1: RecursiveTask - Sum of Array

```java
import java.util.concurrent.*;

class SumTask extends RecursiveTask<Long> {
    private static final int THRESHOLD = 10;
    private int[] array;
    private int start;
    private int end;
    
    public SumTask(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected Long compute() {
        int length = end - start;
        
        // Base case: compute directly if small enough
        if (length <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            System.out.println(Thread.currentThread().getName() + 
                              " computing sum from " + start + " to " + end + ": " + sum);
            return sum;
        }
        
        // Recursive case: split the task
        int mid = start + length / 2;
        SumTask leftTask = new SumTask(array, start, mid);
        SumTask rightTask = new SumTask(array, mid, end);
        
        // Fork left task (run asynchronously)
        leftTask.fork();
        
        // Compute right task in current thread
        long rightResult = rightTask.compute();
        
        // Join left task result
        long leftResult = leftTask.join();
        
        return leftResult + rightResult;
    }
    
    public static void main(String[] args) {
        int[] array = new int[100];
        for (int i = 0; i < array.length; i++) {
            array[i] = i + 1;
        }
        
        ForkJoinPool pool = new ForkJoinPool();
        SumTask task = new SumTask(array, 0, array.length);
        
        long result = pool.invoke(task);
        System.out.println("\nTotal sum: " + result);
        
        pool.shutdown();
    }
}
```

---

## üíª Example 2: RecursiveAction - Parallel Array Processing

```java
import java.util.concurrent.*;

class ArrayProcessorAction extends RecursiveAction {
    private static final int THRESHOLD = 5;
    private int[] array;
    private int start;
    private int end;
    
    public ArrayProcessorAction(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected void compute() {
        int length = end - start;
        
        if (length <= THRESHOLD) {
            // Process directly
            for (int i = start; i < end; i++) {
                array[i] = array[i] * 2; // Double each element
            }
            System.out.println(Thread.currentThread().getName() + 
                              " processed indices " + start + " to " + (end - 1));
        } else {
            // Split the task
            int mid = start + length / 2;
            ArrayProcessorAction left = new ArrayProcessorAction(array, start, mid);
            ArrayProcessorAction right = new ArrayProcessorAction(array, mid, end);
            
            // Execute both subtasks
            invokeAll(left, right);
        }
    }
    
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
        
        System.out.println("Original array:");
        printArray(array);
        
        ForkJoinPool pool = new ForkJoinPool();
        ArrayProcessorAction task = new ArrayProcessorAction(array, 0, array.length);
        pool.invoke(task);
        
        System.out.println("\nProcessed array:");
        printArray(array);
        
        pool.shutdown();
    }
    
    private static void printArray(int[] array) {
        for (int num : array) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
}
```

---

## üíª Example 3: Fibonacci with ForkJoin

```java
import java.util.concurrent.*;

class FibonacciTask extends RecursiveTask<Integer> {
    private final int n;
    
    public FibonacciTask(int n) {
        this.n = n;
    }
    
    @Override
    protected Integer compute() {
        if (n <= 1) {
            return n;
        }
        
        FibonacciTask f1 = new FibonacciTask(n - 1);
        FibonacciTask f2 = new FibonacciTask(n - 2);
        
        f1.fork(); // Fork first task
        int result2 = f2.compute(); // Compute second in current thread
        int result1 = f1.join(); // Wait for first task
        
        return result1 + result2;
    }
    
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        
        int n = 10;
        FibonacciTask task = new FibonacciTask(n);
        
        long start = System.currentTimeMillis();
        int result = pool.invoke(task);
        long duration = System.currentTimeMillis() - start;
        
        System.out.println("Fibonacci(" + n + ") = " + result);
        System.out.println("Time taken: " + duration + "ms");
        
        pool.shutdown();
    }
}
```

---

## üíª Example 4: Parallel Merge Sort

```java
import java.util.concurrent.*;
import java.util.Arrays;

class ParallelMergeSort extends RecursiveAction {
    private static final int THRESHOLD = 10;
    private int[] array;
    private int start;
    private int end;
    
    public ParallelMergeSort(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected void compute() {
        if (end - start <= THRESHOLD) {
            // Use Arrays.sort for small arrays
            Arrays.sort(array, start, end);
        } else {
            int mid = start + (end - start) / 2;
            
            ParallelMergeSort left = new ParallelMergeSort(array, start, mid);
            ParallelMergeSort right = new ParallelMergeSort(array, mid, end);
            
            invokeAll(left, right);
            merge(start, mid, end);
        }
    }
    
    private void merge(int start, int mid, int end) {
        int[] temp = new int[end - start];
        int i = start, j = mid, k = 0;
        
        while (i < mid && j < end) {
            temp[k++] = (array[i] <= array[j]) ? array[i++] : array[j++];
        }
        
        while (i < mid) temp[k++] = array[i++];
        while (j < end) temp[k++] = array[j++];
        
        System.arraycopy(temp, 0, array, start, temp.length);
    }
    
    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11, 90, 88, 45, 50, 23, 36, 18, 77, 29};
        
        System.out.println("Original: " + Arrays.toString(array));
        
        ForkJoinPool pool = new ForkJoinPool();
        ParallelMergeSort task = new ParallelMergeSort(array, 0, array.length);
        pool.invoke(task);
        
        System.out.println("Sorted:   " + Arrays.toString(array));
        
        pool.shutdown();
    }
}
```

---

## üíª Example 5: Maximum Element Search

```java
import java.util.concurrent.*;

class MaximumFinder extends RecursiveTask<Integer> {
    private static final int THRESHOLD = 5;
    private int[] array;
    private int start;
    private int end;
    
    public MaximumFinder(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected Integer compute() {
        if (end - start <= THRESHOLD) {
            int max = array[start];
            for (int i = start + 1; i < end; i++) {
                if (array[i] > max) {
                    max = array[i];
                }
            }
            System.out.println(Thread.currentThread().getName() + 
                              " found max " + max + " in range [" + start + ", " + end + ")");
            return max;
        }
        
        int mid = start + (end - start) / 2;
        MaximumFinder left = new MaximumFinder(array, start, mid);
        MaximumFinder right = new MaximumFinder(array, mid, end);
        
        left.fork();
        int rightMax = right.compute();
        int leftMax = left.join();
        
        return Math.max(leftMax, rightMax);
    }
    
    public static void main(String[] args) {
        int[] array = {3, 5, 2, 9, 1, 8, 4, 7, 6, 10, 12, 11, 15, 13, 14};
        
        ForkJoinPool pool = new ForkJoinPool();
        MaximumFinder task = new MaximumFinder(array, 0, array.length);
        
        int max = pool.invoke(task);
        System.out.println("\nMaximum element: " + max);
        
        pool.shutdown();
    }
}
```

---

## üíª Example 6: Custom ForkJoinPool Configuration

```java
import java.util.concurrent.*;

class CustomForkJoinPoolExample {
    public static void main(String[] args) {
        // Default pool (parallelism = number of processors)
        ForkJoinPool defaultPool = ForkJoinPool.commonPool();
        System.out.println("Default parallelism: " + defaultPool.getParallelism());
        
        // Custom pool with specific parallelism
        ForkJoinPool customPool = new ForkJoinPool(4);
        System.out.println("Custom parallelism: " + customPool.getParallelism());
        
        // Task
        RecursiveTask<Long> task = new RecursiveTask<Long>() {
            @Override
            protected Long compute() {
                long sum = 0;
                for (int i = 1; i <= 1000; i++) {
                    sum += i;
                }
                return sum;
            }
        };
        
        // Execute with custom pool
        long result = customPool.invoke(task);
        System.out.println("Result: " + result);
        
        // Pool statistics
        System.out.println("\nPool Statistics:");
        System.out.println("Active threads: " + customPool.getActiveThreadCount());
        System.out.println("Running threads: " + customPool.getRunningThreadCount());
        System.out.println("Queued submissions: " + customPool.getQueuedSubmissionCount());
        System.out.println("Steal count: " + customPool.getStealCount());
        
        customPool.shutdown();
    }
}
```

---

## üìä RecursiveTask vs RecursiveAction

| Feature | RecursiveTask<V> | RecursiveAction |
|---------|------------------|-----------------|
| **Returns** | Value | void |
| **Method** | `compute()` returns V | `compute()` returns void |
| **Use Case** | Compute results | Perform actions |
| **Example** | Sum, Max, Search | Sort, Transform |

---

## üìä ForkJoinPool vs ThreadPoolExecutor

| Feature | ForkJoinPool | ThreadPoolExecutor |
|---------|--------------|-------------------|
| **Algorithm** | Work-stealing | Fixed assignment |
| **Best For** | Recursive tasks | Independent tasks |
| **Task Type** | ForkJoinTask | Runnable/Callable |
| **Efficiency** | Better for divide-conquer | Better for unrelated tasks |

---

## üí° Best Practices

1. ‚úÖ Use for recursive, divide-and-conquer algorithms
2. ‚úÖ Set appropriate THRESHOLD to avoid too many small tasks
3. ‚úÖ Use `fork()` and `join()` correctly
4. ‚úÖ Consider using `invokeAll()` for multiple subtasks
5. ‚úÖ Avoid blocking operations in tasks
6. ‚úÖ Use `RecursiveTask` for results, `RecursiveAction` for side effects

---

## üéØ Work-Stealing Algorithm

```
Thread 1 Queue: [Task1, Task2, Task3]
Thread 2 Queue: []  ‚Üê Idle, steals from Thread 1

After stealing:
Thread 1 Queue: [Task1, Task2]
Thread 2 Queue: [Task3]  ‚Üê Stolen from end
```

---

## üéØ Interview Questions

1. **What is ForkJoinPool?**
2. **What is work-stealing?**
3. **When should you use ForkJoinPool over ExecutorService?**
4. **What is the difference between RecursiveTask and RecursiveAction?**
5. **What is the purpose of the threshold in fork-join tasks?**
6. **What is the common pool?**

---

## üìö Next Topics

- [ConcurrentHashMap](../05.%20Concurrent%20Collections/01.%20ConcurrentHashMap.md)
- [CompletableFuture](04.%20CompletableFuture.md)
