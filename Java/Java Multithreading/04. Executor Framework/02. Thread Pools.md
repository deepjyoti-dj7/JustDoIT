# üèä Thread Pools

## üìñ What are Thread Pools?

A collection of pre-initialized threads ready to execute tasks. Thread pools avoid the overhead of creating and destroying threads for each task.

**Benefits:**
- Reduces thread creation overhead
- Controls resource usage
- Improves performance
- Better task management

---

## üíª Example 1: FixedThreadPool

```java
import java.util.concurrent.*;

class FixedThreadPoolExample {
    public static void main(String[] args) {
        // Create pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit 10 tasks
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " started by " + 
                                  Thread.currentThread().getName());
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task-" + taskId + " completed");
            });
        }
        
        executor.shutdown();
    }
}
```

**Output:**
```
Task-1 started by pool-1-thread-1
Task-2 started by pool-1-thread-2
Task-3 started by pool-1-thread-3
Task-1 completed
Task-4 started by pool-1-thread-1
...
```

---

## üíª Example 2: CachedThreadPool

```java
import java.util.concurrent.*;

class CachedThreadPoolExample {
    public static void main(String[] args) {
        // Creates threads as needed, reuses idle threads
        ExecutorService executor = Executors.newCachedThreadPool();
        
        for (int i = 1; i <= 20; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " on " + 
                                  Thread.currentThread().getName());
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        executor.shutdown();
        
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
}
```

---

## üíª Example 3: SingleThreadExecutor

```java
import java.util.concurrent.*;

class SingleThreadExecutorExample {
    public static void main(String[] args) {
        // Ensures tasks execute sequentially
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " started at " + 
                                  System.currentTimeMillis());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task-" + taskId + " completed");
            });
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 4: ThreadPoolExecutor with Custom Settings

```java
import java.util.concurrent.*;

class CustomThreadPoolExample {
    public static void main(String[] args) {
        // Custom thread pool configuration
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2,                      // corePoolSize
            4,                      // maximumPoolSize
            60L,                    // keepAliveTime
            TimeUnit.SECONDS,       // time unit
            new LinkedBlockingQueue<>(5), // work queue capacity
            new ThreadPoolExecutor.CallerRunsPolicy() // rejection policy
        );
        
        // Submit 15 tasks
        for (int i = 1; i <= 15; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task-" + taskId + " executing on " + 
                                      Thread.currentThread().getName());
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("Task-" + taskId + " completed");
                });
                
                System.out.println("Active threads: " + executor.getActiveCount() + 
                                  ", Queue size: " + executor.getQueue().size());
            } catch (RejectedExecutionException e) {
                System.out.println("Task-" + taskId + " rejected");
            }
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 5: Work Stealing Pool

```java
import java.util.concurrent.*;

class WorkStealingPoolExample {
    public static void main(String[] args) throws InterruptedException {
        // Creates pool with parallelism = CPU cores
        ExecutorService executor = Executors.newWorkStealingPool();
        
        System.out.println("Available processors: " + 
                          Runtime.getRuntime().availableProcessors());
        
        CountDownLatch latch = new CountDownLatch(20);
        
        for (int i = 1; i <= 20; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("Task-" + taskId + " on " + 
                                      Thread.currentThread().getName());
                    Thread.sleep((long)(Math.random() * 1000));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        executor.shutdown();
        System.out.println("All tasks completed");
    }
}
```

---

## üíª Example 6: Rejection Policies

```java
import java.util.concurrent.*;

class RejectionPolicyExample {
    public static void main(String[] args) {
        // Test different rejection policies
        
        // 1. AbortPolicy (default) - throws RejectedExecutionException
        testPolicy("AbortPolicy", new ThreadPoolExecutor.AbortPolicy());
        
        // 2. CallerRunsPolicy - caller thread runs the task
        testPolicy("CallerRunsPolicy", new ThreadPoolExecutor.CallerRunsPolicy());
        
        // 3. DiscardPolicy - silently discards task
        testPolicy("DiscardPolicy", new ThreadPoolExecutor.DiscardPolicy());
        
        // 4. DiscardOldestPolicy - discards oldest task in queue
        testPolicy("DiscardOldestPolicy", new ThreadPoolExecutor.DiscardOldestPolicy());
    }
    
    private static void testPolicy(String name, RejectedExecutionHandler policy) {
        System.out.println("\n=== Testing " + name + " ===");
        
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            1, 1, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(2),
            policy
        );
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            try {
                executor.submit(() -> {
                    System.out.println("Task-" + taskId + " executing");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                System.out.println("Task-" + taskId + " submitted");
            } catch (RejectedExecutionException e) {
                System.out.println("Task-" + taskId + " rejected!");
            }
        }
        
        executor.shutdown();
        try {
            executor.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üíª Example 7: Monitoring Thread Pool

```java
import java.util.concurrent.*;

class ThreadPoolMonitor {
    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(10)
        );
        
        // Submit tasks
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        // Monitor pool
        for (int i = 0; i < 5; i++) {
            System.out.println("\n=== Pool Status ===");
            System.out.println("Active threads: " + executor.getActiveCount());
            System.out.println("Pool size: " + executor.getPoolSize());
            System.out.println("Queue size: " + executor.getQueue().size());
            System.out.println("Completed tasks: " + executor.getCompletedTaskCount());
            System.out.println("Total tasks: " + executor.getTaskCount());
            
            Thread.sleep(1000);
        }
        
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        
        System.out.println("\n=== Final Status ===");
        System.out.println("Completed tasks: " + executor.getCompletedTaskCount());
    }
}
```

---

## üìä Thread Pool Types Comparison

| Type | Threads | Queue | Use Case |
|------|---------|-------|----------|
| **FixedThreadPool** | Fixed | Unbounded | Fixed workload |
| **CachedThreadPool** | 0 to ‚àû | No queue | Short tasks |
| **SingleThreadExecutor** | 1 | Unbounded | Sequential execution |
| **ScheduledThreadPool** | Fixed | Delayed queue | Scheduled tasks |
| **WorkStealingPool** | CPU cores | Fork-join | Parallel processing |

---

## üí° Best Practices

1. ‚úÖ Always shutdown executor
2. ‚úÖ Use `awaitTermination()` before exit
3. ‚úÖ Choose appropriate pool type
4. ‚úÖ Set reasonable pool size
5. ‚úÖ Handle `RejectedExecutionException`
6. ‚úÖ Monitor pool metrics
7. ‚úÖ Use bounded queues when possible

---

## üéØ Pool Sizing Guidelines

```java
// CPU-intensive tasks
int poolSize = Runtime.getRuntime().availableProcessors();

// I/O-intensive tasks
int poolSize = Runtime.getRuntime().availableProcessors() * 2;

// Custom formula
int poolSize = cores * (1 + waitTime / computeTime);
```

---

## üéØ Interview Questions

1. **What is a thread pool?**
2. **What are the different types of thread pools?**
3. **What is the difference between FixedThreadPool and CachedThreadPool?**
4. **What are rejection policies?**
5. **How do you determine the optimal thread pool size?**
6. **What is a work-stealing pool?**

---

## üìö Next Topics

- [Callable & Future](03.%20Callable%20&%20Future.md)
- [ScheduledExecutorService](04.%20ScheduledExecutorService.md)
