# ‚è∞ ScheduledExecutorService

## üìñ What is ScheduledExecutorService?

An `ExecutorService` that can schedule tasks to run after a delay or periodically at fixed intervals.

**Use Cases:**
- Scheduled tasks
- Periodic tasks
- Delayed execution
- Task scheduling with delays

---

## üíª Example 1: schedule() - One-time Delayed Task

```java
import java.util.concurrent.*;

class ScheduleExample {
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        System.out.println("Scheduling task at: " + System.currentTimeMillis());
        
        // Schedule task to run after 3 seconds
        ScheduledFuture<?> future = scheduler.schedule(() -> {
            System.out.println("Task executed at: " + System.currentTimeMillis());
            System.out.println("Hello after 3 seconds!");
        }, 3, TimeUnit.SECONDS);
        
        System.out.println("Task scheduled, continuing...");
        
        // Wait for task completion
        future.get();
        System.out.println("Task completed");
        
        scheduler.shutdown();
    }
}
```

---

## üíª Example 2: scheduleAtFixedRate() - Fixed Rate Execution

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class FixedRateExample {
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        AtomicInteger counter = new AtomicInteger(0);
        
        System.out.println("Starting fixed rate task");
        
        // Execute every 2 seconds, starting after 1 second
        scheduler.scheduleAtFixedRate(() -> {
            int count = counter.incrementAndGet();
            System.out.println("Execution #" + count + " at " + 
                              System.currentTimeMillis());
            
            // Simulate work
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, 1, 2, TimeUnit.SECONDS);
        
        // Run for 10 seconds
        Thread.sleep(10000);
        
        scheduler.shutdown();
        System.out.println("Scheduler shut down");
    }
}
```

**Note:** If execution takes longer than the period, next execution waits for current to complete.

---

## üíª Example 3: scheduleWithFixedDelay() - Fixed Delay Between Executions

```java
import java.util.concurrent.*;

class FixedDelayExample {
    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        System.out.println("Starting fixed delay task");
        
        // Wait 2 seconds between end of one execution and start of next
        scheduler.scheduleWithFixedDelay(() -> {
            System.out.println("Task started at: " + System.currentTimeMillis());
            
            // Random execution time
            long executionTime = (long)(Math.random() * 2000) + 1000;
            try {
                Thread.sleep(executionTime);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            System.out.println("Task completed (took " + executionTime + "ms)\n");
        }, 0, 2, TimeUnit.SECONDS);
        
        Thread.sleep(15000);
        scheduler.shutdown();
    }
}
```

---

## üíª Example 4: Returning Values with Callable

```java
import java.util.concurrent.*;

class ScheduledCallableExample {
    public static void main(String[] args) throws Exception {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        
        Callable<Integer> task = () -> {
            System.out.println("Computing result...");
            Thread.sleep(1000);
            return 42;
        };
        
        System.out.println("Scheduling Callable task");
        ScheduledFuture<Integer> future = scheduler.schedule(task, 2, TimeUnit.SECONDS);
        
        System.out.println("Waiting for result...");
        Integer result = future.get(); // Blocks until ready
        System.out.println("Result: " + result);
        
        scheduler.shutdown();
    }
}
```

---

## üíª Example 5: Heartbeat Monitor

```java
import java.util.concurrent.*;
import java.time.LocalTime;

class HeartbeatMonitor {
    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private volatile boolean isAlive = true;
    
    public void startMonitoring() {
        scheduler.scheduleAtFixedRate(() -> {
            if (isAlive) {
                System.out.println("üíö Heartbeat at " + LocalTime.now());
                checkHealth();
            } else {
                System.out.println("‚ùå Service down at " + LocalTime.now());
            }
        }, 0, 2, TimeUnit.SECONDS);
    }
    
    private void checkHealth() {
        // Simulate random failures
        if (Math.random() < 0.1) {
            isAlive = false;
            System.out.println("‚ö†Ô∏è  Health check failed!");
        }
    }
    
    public void stopMonitoring() {
        scheduler.shutdown();
    }
    
    public static void main(String[] args) throws InterruptedException {
        HeartbeatMonitor monitor = new HeartbeatMonitor();
        monitor.startMonitoring();
        
        Thread.sleep(15000);
        monitor.stopMonitoring();
    }
}
```

---

## üíª Example 6: Cache Cleanup Task

```java
import java.util.concurrent.*;
import java.util.*;

class CacheWithScheduledCleanup {
    private Map<String, CacheEntry> cache = new ConcurrentHashMap<>();
    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    static class CacheEntry {
        String value;
        long timestamp;
        
        CacheEntry(String value) {
            this.value = value;
            this.timestamp = System.currentTimeMillis();
        }
        
        boolean isExpired(long maxAge) {
            return System.currentTimeMillis() - timestamp > maxAge;
        }
    }
    
    public void startCleanup(long interval, long maxAge) {
        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("\nüßπ Running cache cleanup...");
            int removed = 0;
            
            Iterator<Map.Entry<String, CacheEntry>> iterator = 
                cache.entrySet().iterator();
            
            while (iterator.hasNext()) {
                Map.Entry<String, CacheEntry> entry = iterator.next();
                if (entry.getValue().isExpired(maxAge)) {
                    iterator.remove();
                    removed++;
                    System.out.println("Removed expired entry: " + entry.getKey());
                }
            }
            
            System.out.println("Cleanup complete. Removed: " + removed + 
                              ", Remaining: " + cache.size());
        }, interval, interval, TimeUnit.SECONDS);
    }
    
    public void put(String key, String value) {
        cache.put(key, new CacheEntry(value));
        System.out.println("Added: " + key);
    }
    
    public void shutdown() {
        scheduler.shutdown();
    }
    
    public static void main(String[] args) throws InterruptedException {
        CacheWithScheduledCleanup cache = new CacheWithScheduledCleanup();
        
        // Cleanup every 3 seconds, entries expire after 5 seconds
        cache.startCleanup(3, 5000);
        
        // Add entries
        cache.put("key1", "value1");
        Thread.sleep(2000);
        cache.put("key2", "value2");
        Thread.sleep(2000);
        cache.put("key3", "value3");
        
        // Wait for cleanup cycles
        Thread.sleep(10000);
        
        cache.shutdown();
    }
}
```

---

## üíª Example 7: Rate Limiter with Token Bucket

```java
import java.util.concurrent.*;

class TokenBucketRateLimiter {
    private final int capacity;
    private final int tokensPerInterval;
    private int availableTokens;
    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    
    public TokenBucketRateLimiter(int capacity, int tokensPerInterval, int intervalSeconds) {
        this.capacity = capacity;
        this.tokensPerInterval = tokensPerInterval;
        this.availableTokens = capacity;
        
        // Refill tokens periodically
        scheduler.scheduleAtFixedRate(() -> {
            synchronized (this) {
                availableTokens = Math.min(capacity, availableTokens + tokensPerInterval);
                System.out.println("Refilled tokens. Available: " + availableTokens);
            }
        }, intervalSeconds, intervalSeconds, TimeUnit.SECONDS);
    }
    
    public synchronized boolean tryConsume(int tokens) {
        if (availableTokens >= tokens) {
            availableTokens -= tokens;
            return true;
        }
        return false;
    }
    
    public void shutdown() {
        scheduler.shutdown();
    }
    
    public static void main(String[] args) throws InterruptedException {
        // 10 tokens capacity, refill 3 tokens every 2 seconds
        TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(10, 3, 2);
        
        // Simulate requests
        for (int i = 1; i <= 20; i++) {
            if (limiter.tryConsume(1)) {
                System.out.println("‚úÖ Request " + i + " allowed");
            } else {
                System.out.println("‚ùå Request " + i + " denied");
            }
            Thread.sleep(500);
        }
        
        limiter.shutdown();
    }
}
```

---

## üìä scheduleAtFixedRate vs scheduleWithFixedDelay

| Feature | scheduleAtFixedRate | scheduleWithFixedDelay |
|---------|---------------------|------------------------|
| **Timing** | Fixed rate from start | Delay between executions |
| **If task slow** | May run back-to-back | Always waits for delay |
| **Use Case** | Regular intervals | Task completion + delay |

```
scheduleAtFixedRate:
Task1[==]  Task2[==]  Task3[==]
|--2s--|--2s--|--2s--|

scheduleWithFixedDelay:
Task1[==]   Task2[==]   Task3[==]
|--2s--|--delay--|--2s--|--delay--|
```

---

## üí° Best Practices

1. ‚úÖ Use `scheduleAtFixedRate` for fixed intervals
2. ‚úÖ Use `scheduleWithFixedDelay` for delay after completion
3. ‚úÖ Handle exceptions in tasks (they're suppressed otherwise)
4. ‚úÖ Always shutdown scheduler when done
5. ‚úÖ Use appropriate pool size
6. ‚úÖ Monitor for task failures

---

## üéØ Interview Questions

1. **What is ScheduledExecutorService?**
2. **What is the difference between scheduleAtFixedRate and scheduleWithFixedDelay?**
3. **What happens if a scheduled task throws an exception?**
4. **Can you cancel a scheduled task?**
5. **How do you handle long-running scheduled tasks?**

---

## üìö Next Topics

- [ForkJoinPool](06.%20ForkJoinPool.md)
- [CompletableFuture](04.%20CompletableFuture.md)
