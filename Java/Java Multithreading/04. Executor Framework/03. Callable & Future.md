# üìû Callable & Future

## üìñ What are Callable and Future?

- **Callable**: Like `Runnable` but returns a result and can throw checked exceptions
- **Future**: Represents the result of an asynchronous computation

**Key Differences from Runnable:**
- Callable returns a value
- Callable can throw checked exceptions
- Future provides methods to check status and retrieve results

---

## üíª Example 1: Basic Callable and Future

```java
import java.util.concurrent.*;

class BasicCallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Create a Callable task
        Callable<Integer> task = () -> {
            System.out.println("Task started");
            Thread.sleep(2000);
            System.out.println("Task completed");
            return 42;
        };
        
        // Submit and get Future
        Future<Integer> future = executor.submit(task);
        
        System.out.println("Task submitted");
        System.out.println("Is done? " + future.isDone());
        
        // Block and get result
        Integer result = future.get(); // Blocks until complete
        
        System.out.println("Result: " + result);
        System.out.println("Is done? " + future.isDone());
        
        executor.shutdown();
    }
}
```

**Output:**
```
Task submitted
Is done? false
Task started
Task completed
Result: 42
Is done? true
```

---

## üíª Example 2: Multiple Callable Tasks

```java
import java.util.*;
import java.util.concurrent.*;

class MultipleCallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        List<Callable<Integer>> tasks = new ArrayList<>();
        
        // Create multiple tasks
        for (int i = 1; i <= 5; i++) {
            final int num = i;
            tasks.add(() -> {
                System.out.println("Computing factorial of " + num);
                Thread.sleep(1000);
                return factorial(num);
            });
        }
        
        // Submit all tasks
        List<Future<Integer>> futures = executor.invokeAll(tasks);
        
        // Get all results
        for (int i = 0; i < futures.size(); i++) {
            Integer result = futures.get(i).get();
            System.out.println("Factorial of " + (i + 1) + " = " + result);
        }
        
        executor.shutdown();
    }
    
    private static int factorial(int n) {
        int result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
}
```

---

## üíª Example 3: Future with Timeout

```java
import java.util.concurrent.*;

class FutureTimeoutExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<String> future = executor.submit(() -> {
            System.out.println("Long running task started");
            Thread.sleep(5000);
            return "Task completed";
        });
        
        try {
            System.out.println("Waiting for result (2 second timeout)...");
            String result = future.get(2, TimeUnit.SECONDS);
            System.out.println("Result: " + result);
        } catch (TimeoutException e) {
            System.out.println("Timeout! Task took too long");
            future.cancel(true); // Interrupt the task
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        System.out.println("Is cancelled? " + future.isCancelled());
        executor.shutdownNow();
    }
}
```

---

## üíª Example 4: Cancelling Future

```java
import java.util.concurrent.*;

class CancelFutureExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        Future<Integer> future = executor.submit(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    if (Thread.currentThread().isInterrupted()) {
                        System.out.println("Task interrupted");
                        return -1;
                    }
                    System.out.println("Processing step " + i);
                    Thread.sleep(1000);
                }
                return 100;
            } catch (InterruptedException e) {
                System.out.println("Task interrupted via exception");
                return -1;
            }
        });
        
        // Let it run for 3 seconds
        Thread.sleep(3000);
        
        // Cancel the task
        System.out.println("Cancelling task...");
        boolean cancelled = future.cancel(true); // mayInterruptIfRunning = true
        
        System.out.println("Cancelled: " + cancelled);
        System.out.println("Is cancelled? " + future.isCancelled());
        
        try {
            future.get(); // Will throw CancellationException
        } catch (CancellationException e) {
            System.out.println("Task was cancelled");
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 5: invokeAny() - First to Complete

```java
import java.util.*;
import java.util.concurrent.*;

class InvokeAnyExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        List<Callable<String>> tasks = Arrays.asList(
            () -> {
                Thread.sleep(3000);
                return "Task 1 result";
            },
            () -> {
                Thread.sleep(1000);
                return "Task 2 result (fastest)";
            },
            () -> {
                Thread.sleep(2000);
                return "Task 3 result";
            }
        );
        
        System.out.println("Starting tasks...");
        long start = System.currentTimeMillis();
        
        // Returns result of first completed task
        String result = executor.invokeAny(tasks);
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("Result: " + result);
        System.out.println("Time taken: " + duration + "ms");
        
        executor.shutdown();
    }
}
```

---

## üíª Example 6: Parallel Sum Calculation

```java
import java.util.*;
import java.util.concurrent.*;

class ParallelSumCalculator {
    public static void main(String[] args) throws Exception {
        int[] numbers = new int[1000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }
        
        long sum = parallelSum(numbers, 4);
        System.out.println("Total sum: " + sum);
    }
    
    public static long parallelSum(int[] numbers, int numThreads) 
            throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        List<Future<Long>> futures = new ArrayList<>();
        
        int chunkSize = numbers.length / numThreads;
        
        for (int i = 0; i < numThreads; i++) {
            final int start = i * chunkSize;
            final int end = (i == numThreads - 1) ? numbers.length : (i + 1) * chunkSize;
            
            Callable<Long> task = () -> {
                long sum = 0;
                for (int j = start; j < end; j++) {
                    sum += numbers[j];
                }
                System.out.println(Thread.currentThread().getName() + 
                                  " computed sum from " + start + " to " + end + ": " + sum);
                return sum;
            };
            
            futures.add(executor.submit(task));
        }
        
        // Combine results
        long totalSum = 0;
        for (Future<Long> future : futures) {
            totalSum += future.get();
        }
        
        executor.shutdown();
        return totalSum;
    }
}
```

---

## üíª Example 7: Exception Handling with Future

```java
import java.util.concurrent.*;

class FutureExceptionExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // Task that succeeds
        Future<Integer> successFuture = executor.submit(() -> {
            System.out.println("Success task running");
            return 42;
        });
        
        // Task that fails
        Future<Integer> failureFuture = executor.submit(() -> {
            System.out.println("Failure task running");
            Thread.sleep(1000);
            throw new RuntimeException("Task failed!");
        });
        
        // Get results
        try {
            Integer result1 = successFuture.get();
            System.out.println("Success result: " + result1);
        } catch (Exception e) {
            System.out.println("Success task failed: " + e.getMessage());
        }
        
        try {
            Integer result2 = failureFuture.get();
            System.out.println("Failure result: " + result2);
        } catch (ExecutionException e) {
            System.out.println("Failure task failed: " + e.getCause().getMessage());
        } catch (Exception e) {
            System.out.println("Other exception: " + e.getMessage());
        }
        
        executor.shutdown();
    }
}
```

---

## üìä Callable vs Runnable

| Feature | Callable<V> | Runnable |
|---------|-------------|----------|
| **Return Value** | Yes | No |
| **Exception** | Checked ‚úÖ | Only Runtime |
| **Method** | `call()` | `run()` |
| **Use with** | ExecutorService | Thread or ExecutorService |
| **Result** | Via Future | N/A |

---

## üìä Future Methods

| Method | Description | Blocks? |
|--------|-------------|---------|
| `get()` | Get result | ‚úÖ Yes |
| `get(timeout)` | Get with timeout | ‚úÖ Yes |
| `isDone()` | Check if complete | ‚ùå No |
| `isCancelled()` | Check if cancelled | ‚ùå No |
| `cancel()` | Cancel task | ‚ùå No |

---

## üí° Best Practices

1. ‚úÖ Use `Callable` when you need a return value
2. ‚úÖ Always handle `ExecutionException`
3. ‚úÖ Use timeout with `get()` to avoid indefinite blocking
4. ‚úÖ Check `isDone()` before calling `get()` if non-blocking check needed
5. ‚úÖ Cancel long-running tasks when no longer needed
6. ‚úÖ Use `invokeAll()` for multiple tasks
7. ‚úÖ Use `invokeAny()` when only first result matters

---

## üéØ Interview Questions

1. **What is the difference between Callable and Runnable?**
2. **How do you get the result from a Callable?**
3. **What happens when you call get() on a Future?**
4. **What is ExecutionException?**
5. **How do you cancel a task?**
6. **What is the difference between invokeAll() and invokeAny()?**
7. **Can you reuse a Future?**

---

## üìö Next Topics

- [CompletableFuture](03.%20CompletableFuture.md)
- [ForkJoinPool](06.%20ForkJoinPool.md)
