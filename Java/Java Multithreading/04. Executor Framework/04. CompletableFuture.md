# ðŸš€ CompletableFuture

## ðŸ“– What is CompletableFuture?

An enhanced `Future` that supports asynchronous, non-blocking, and functional-style programming. It can be completed manually and supports callbacks.

**Key Features:**
- Non-blocking operations
- Chaining and composition
- Exception handling
- Combine multiple futures
- Callbacks (thenApply, thenAccept, thenRun)

---

## ðŸ’» Example 1: Basic CompletableFuture

```java
import java.util.concurrent.CompletableFuture;

class BasicCompletableFutureExample {
    public static void main(String[] args) throws Exception {
        // Create and complete manually
        CompletableFuture<String> future = new CompletableFuture<>();
        
        // Complete in another thread
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                future.complete("Hello from Future!");
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            }
        }).start();
        
        System.out.println("Waiting for result...");
        String result = future.get(); // Blocks
        System.out.println("Result: " + result);
    }
}
```

---

## ðŸ’» Example 2: supplyAsync and runAsync

```java
import java.util.concurrent.CompletableFuture;

class AsyncMethodsExample {
    public static void main(String[] args) throws Exception {
        // supplyAsync - returns a value
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println("Computing on: " + Thread.currentThread().getName());
            return 42;
        });
        
        System.out.println("Result: " + future1.get());
        
        // runAsync - no return value
        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            System.out.println("Running on: " + Thread.currentThread().getName());
            System.out.println("Task completed");
        });
        
        future2.get(); // Wait for completion
    }
}
```

---

## ðŸ’» Example 3: Chaining with thenApply, thenAccept, thenRun

```java
import java.util.concurrent.CompletableFuture;

class ChainingExample {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> {
            System.out.println("Step 1: Fetch data");
            return "Raw Data";
        })
        .thenApply(data -> {
            System.out.println("Step 2: Process data");
            return data.toUpperCase();
        })
        .thenApply(processed -> {
            System.out.println("Step 3: Transform data");
            return processed + " - PROCESSED";
        })
        .thenAccept(result -> {
            System.out.println("Step 4: Save result: " + result);
        })
        .thenRun(() -> {
            System.out.println("Step 5: Cleanup");
        })
        .get(); // Wait for all steps
    }
}
```

**Output:**
```
Step 1: Fetch data
Step 2: Process data
Step 3: Transform data
Step 4: Save result: RAW DATA - PROCESSED
Step 5: Cleanup
```

---

## ðŸ’» Example 4: Combining Multiple Futures

```java
import java.util.concurrent.CompletableFuture;

class CombiningFuturesExample {
    public static void main(String[] args) throws Exception {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return 10;
        });
        
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return 20;
        });
        
        // thenCombine - combines two independent futures
        CompletableFuture<Integer> combined = future1.thenCombine(future2, (a, b) -> {
            System.out.println("Combining: " + a + " + " + b);
            return a + b;
        });
        
        System.out.println("Result: " + combined.get());
        
        // thenCompose - for dependent futures
        CompletableFuture<Integer> composed = CompletableFuture.supplyAsync(() -> 5)
            .thenCompose(num -> CompletableFuture.supplyAsync(() -> num * 2));
        
        System.out.println("Composed result: " + composed.get());
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ðŸ’» Example 5: Exception Handling

```java
import java.util.concurrent.CompletableFuture;

class ExceptionHandlingExample {
    public static void main(String[] args) {
        // Using exceptionally
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            if (Math.random() > 0.5) {
                throw new RuntimeException("Random failure!");
            }
            return 42;
        }).exceptionally(ex -> {
            System.out.println("Exception caught: " + ex.getMessage());
            return -1; // Default value
        });
        
        future1.thenAccept(result -> System.out.println("Result: " + result));
        
        // Using handle (receives both result and exception)
        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            return 10 / 0; // Will throw ArithmeticException
        }).handle((result, ex) -> {
            if (ex != null) {
                System.out.println("Handled exception: " + ex.getCause());
                return 0;
            }
            return result;
        });
        
        future2.thenAccept(result -> System.out.println("Final result: " + result));
        
        sleep(2000);
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ðŸ’» Example 6: allOf and anyOf

```java
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;

class AllOfAnyOfExample {
    public static void main(String[] args) throws Exception {
        // Create multiple futures
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            sleep(1000);
            return "Result-1";
        });
        
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            sleep(2000);
            return "Result-2";
        });
        
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> {
            sleep(1500);
            return "Result-3";
        });
        
        // allOf - wait for all to complete
        System.out.println("Waiting for all futures...");
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);
        
        allFutures.thenRun(() -> {
            System.out.println("All completed!");
            Stream.of(future1, future2, future3)
                  .map(CompletableFuture::join)
                  .forEach(System.out::println);
        }).get();
        
        // anyOf - returns first completed
        System.out.println("\nWaiting for any future...");
        CompletableFuture<Object> anyFuture = CompletableFuture.anyOf(
            CompletableFuture.supplyAsync(() -> { sleep(1000); return "Fast"; }),
            CompletableFuture.supplyAsync(() -> { sleep(3000); return "Slow"; })
        );
        
        System.out.println("First result: " + anyFuture.get());
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ðŸ’» Example 7: Async Web Service Calls

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class AsyncWebServiceExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        long start = System.currentTimeMillis();
        
        // Simulate parallel web service calls
        CompletableFuture<String> userService = CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching user data...");
            sleep(2000);
            return "User: John Doe";
        }, executor);
        
        CompletableFuture<String> orderService = CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching order data...");
            sleep(1500);
            return "Orders: 5";
        }, executor);
        
        CompletableFuture<String> productService = CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching product data...");
            sleep(1000);
            return "Products: 10";
        }, executor);
        
        // Combine all results
        CompletableFuture<String> allData = userService
            .thenCombine(orderService, (user, orders) -> user + ", " + orders)
            .thenCombine(productService, (partial, products) -> partial + ", " + products);
        
        System.out.println("\nFinal Result: " + allData.get());
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("Total time: " + duration + "ms");
        
        executor.shutdown();
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ðŸ’» Example 8: Timeout and Cancellation

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

class TimeoutExample {
    public static void main(String[] args) {
        // With timeout (Java 9+)
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            sleep(5000);
            return "Completed";
        }).orTimeout(2, TimeUnit.SECONDS)
          .exceptionally(ex -> "Timeout occurred!");
        
        future.thenAccept(result -> System.out.println("Result: " + result));
        
        sleep(3000);
        
        // Cancellation
        CompletableFuture<String> cancellableFuture = CompletableFuture.supplyAsync(() -> {
            for (int i = 0; i < 10; i++) {
                System.out.println("Working... " + i);
                sleep(500);
            }
            return "Done";
        });
        
        sleep(2000);
        cancellableFuture.cancel(true);
        System.out.println("Cancelled: " + cancellableFuture.isCancelled());
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ðŸ“Š CompletableFuture Methods

| Method | Description | Returns |
|--------|-------------|---------|
| `supplyAsync()` | Async task with result | CompletableFuture<T> |
| `runAsync()` | Async task no result | CompletableFuture<Void> |
| `thenApply()` | Transform result | CompletableFuture<U> |
| `thenAccept()` | Consume result | CompletableFuture<Void> |
| `thenRun()` | Run after completion | CompletableFuture<Void> |
| `thenCombine()` | Combine two futures | CompletableFuture<V> |
| `thenCompose()` | Chain dependent futures | CompletableFuture<U> |
| `exceptionally()` | Handle exception | CompletableFuture<T> |
| `handle()` | Handle result or exception | CompletableFuture<U> |
| `allOf()` | Wait for all | CompletableFuture<Void> |
| `anyOf()` | Wait for any | CompletableFuture<Object> |

---

## ðŸ’¡ Best Practices

1. âœ… Use `supplyAsync()` for tasks with return values
2. âœ… Use `thenApply()` for transformations
3. âœ… Use `thenCompose()` for dependent async operations
4. âœ… Handle exceptions with `exceptionally()` or `handle()`
5. âœ… Use custom executor for better control
6. âœ… Use `allOf()` to wait for multiple futures
7. âœ… Avoid blocking calls like `get()` in production

---

## ðŸŽ¯ Interview Questions

1. **What is CompletableFuture?**
2. **What is the difference between thenApply and thenCompose?**
3. **How do you handle exceptions in CompletableFuture?**
4. **What is the difference between thenApply and thenApplyAsync?**
5. **How do you combine multiple CompletableFutures?**
6. **What is the difference between allOf and anyOf?**

---

## ðŸ“š Next Topics

- [ScheduledExecutorService](04.%20ScheduledExecutorService.md)
- [ForkJoinPool](06.%20ForkJoinPool.md)
