# üèä ExecutorService & Thread Pools

## üìñ What is ExecutorService?

`ExecutorService` is a high-level API for managing thread pools and executing asynchronous tasks. It provides:
- **Thread pool management**
- **Task submission and execution**
- **Lifecycle management**
- **Result tracking with Future**

**Benefits:**
- Reuses threads (better performance)
- Controls number of concurrent threads
- Easier than manual thread management
- Provides shutdown mechanisms

---

## üéØ Creating ExecutorService

```java
import java.util.concurrent.*;

// 1. Fixed thread pool
ExecutorService executor = Executors.newFixedThreadPool(5);

// 2. Cached thread pool (creates threads as needed)
ExecutorService executor = Executors.newCachedThreadPool();

// 3. Single thread executor
ExecutorService executor = Executors.newSingleThreadExecutor();

// 4. Scheduled thread pool
ScheduledExecutorService executor = Executors.newScheduledThreadPool(3);

// 5. Custom thread pool
ExecutorService executor = new ThreadPoolExecutor(
    corePoolSize, maximumPoolSize, keepAliveTime, 
    TimeUnit.SECONDS, workQueue
);
```

---

## üíª Example 1: Basic ExecutorService

```java
import java.util.concurrent.*;

class BasicExecutorExample {
    public static void main(String[] args) {
        // Create thread pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit 5 tasks
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            
            executor.submit(() -> {
                System.out.println("Task " + taskId + " started by " + 
                                   Thread.currentThread().getName());
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task " + taskId + " completed");
            });
        }
        
        // Shutdown executor
        executor.shutdown();
        
        try {
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
        
        System.out.println("All tasks completed");
    }
}
```

---

## üíª Example 2: submit() vs execute()

```java
import java.util.concurrent.*;

class SubmitVsExecute {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // execute() - for Runnable, no return value
        executor.execute(() -> {
            System.out.println("execute(): " + Thread.currentThread().getName());
        });
        
        // submit() - returns Future
        Future<?> future = executor.submit(() -> {
            System.out.println("submit(): " + Thread.currentThread().getName());
        });
        
        // submit() with Callable - returns result
        Future<Integer> result = executor.submit(() -> {
            System.out.println("Callable: Computing...");
            Thread.sleep(1000);
            return 42;
        });
        
        System.out.println("Result: " + result.get()); // Blocking call
        
        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);
    }
}
```

---

## üíª Example 3: Fixed Thread Pool

```java
import java.util.concurrent.*;

class FixedThreadPoolExample {
    public static void main(String[] args) throws InterruptedException {
        // Pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit 10 tasks
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " executing on " + 
                                   Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(15, TimeUnit.SECONDS);
        System.out.println("All tasks completed");
    }
}
```

**Key Point**: Only 3 threads execute tasks concurrently, others wait in queue.

---

## üíª Example 4: Cached Thread Pool

```java
import java.util.concurrent.*;

class CachedThreadPoolExample {
    public static void main(String[] args) {
        // Creates threads as needed, reuses idle threads
        ExecutorService executor = Executors.newCachedThreadPool();
        
        for (int i = 1; i <= 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " on " + 
                                   Thread.currentThread().getName());
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
    }
}
```

**Use Case**: Short-lived tasks, unpredictable load

---

## üíª Example 5: Single Thread Executor

```java
import java.util.concurrent.*;

class SingleThreadExecutorExample {
    public static void main(String[] args) {
        // Guarantees sequential execution
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task-" + taskId + " executing");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        executor.shutdown();
    }
}
```

**Output:** Tasks execute one after another sequentially.

---

## üíª Example 6: invokeAll() - Execute Multiple Tasks

```java
import java.util.*;
import java.util.concurrent.*;

class InvokeAllExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Create list of tasks
        List<Callable<String>> tasks = new ArrayList<>();
        
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            tasks.add(() -> {
                Thread.sleep(1000);
                return "Task-" + taskId + " result";
            });
        }
        
        // Execute all tasks and wait for completion
        List<Future<String>> futures = executor.invokeAll(tasks);
        
        // Get results
        for (Future<String> future : futures) {
            try {
                System.out.println(future.get());
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 7: invokeAny() - First Completed Task

```java
import java.util.*;
import java.util.concurrent.*;

class InvokeAnyExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        List<Callable<String>> tasks = new ArrayList<>();
        
        tasks.add(() -> {
            Thread.sleep(3000);
            return "Task 1 (3 seconds)";
        });
        
        tasks.add(() -> {
            Thread.sleep(1000);
            return "Task 2 (1 second)"; // This will complete first
        });
        
        tasks.add(() -> {
            Thread.sleep(2000);
            return "Task 3 (2 seconds)";
        });
        
        try {
            // Returns result of first completed task
            String result = executor.invokeAny(tasks);
            System.out.println("First completed: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 8: Proper Shutdown

```java
import java.util.concurrent.*;

class ProperShutdownExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit tasks
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("Task-" + taskId + " running");
                    Thread.sleep(2000);
                    System.out.println("Task-" + taskId + " completed");
                } catch (InterruptedException e) {
                    System.out.println("Task-" + taskId + " interrupted");
                    Thread.currentThread().interrupt();
                }
            });
        }
        
        // Proper shutdown sequence
        shutdownExecutor(executor);
    }
    
    public static void shutdownExecutor(ExecutorService executor) {
        System.out.println("\nInitiating shutdown...");
        
        // 1. Graceful shutdown - no new tasks accepted
        executor.shutdown();
        
        try {
            // 2. Wait for existing tasks to complete
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                System.out.println("Forcing shutdown...");
                
                // 3. Cancel running tasks
                executor.shutdownNow();
                
                // 4. Wait again for tasks to respond to cancellation
                if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                    System.err.println("Executor did not terminate");
                }
            }
        } catch (InterruptedException e) {
            // Current thread was interrupted
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Executor shutdown complete");
    }
}
```

---

## üíª Example 9: Exception Handling

```java
import java.util.concurrent.*;

class ExceptionHandlingExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // Task that throws exception
        Future<Integer> future = executor.submit(() -> {
            System.out.println("Task starting...");
            Thread.sleep(1000);
            if (true) {
                throw new RuntimeException("Task failed!");
            }
            return 42;
        });
        
        try {
            // Exception is thrown here, not in submit()
            Integer result = future.get();
            System.out.println("Result: " + result);
        } catch (ExecutionException e) {
            System.out.println("Task threw exception: " + e.getCause().getMessage());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executor.shutdown();
    }
}
```

---

## üìä Thread Pool Types Comparison

| Type | Use Case | Thread Creation | Queue |
|------|----------|-----------------|-------|
| **FixedThreadPool** | Known load, controlled resources | Fixed number | Unbounded |
| **CachedThreadPool** | Many short tasks | Creates as needed | No queue |
| **SingleThreadExecutor** | Sequential execution | One thread | Unbounded |
| **ScheduledThreadPool** | Delayed/periodic tasks | Fixed number | DelayQueue |

---

## üíª Example 10: Real-World - Batch Processing

```java
import java.util.*;
import java.util.concurrent.*;

class BatchProcessor {
    private ExecutorService executor = Executors.newFixedThreadPool(5);
    
    public void processBatch(List<String> items) {
        List<Future<String>> futures = new ArrayList<>();
        
        for (String item : items) {
            Future<String> future = executor.submit(() -> processItem(item));
            futures.add(future);
        }
        
        // Collect results
        for (int i = 0; i < futures.size(); i++) {
            try {
                String result = futures.get(i).get(5, TimeUnit.SECONDS);
                System.out.println("Processed: " + result);
            } catch (TimeoutException e) {
                System.out.println("Item " + i + " timed out");
                futures.get(i).cancel(true);
            } catch (ExecutionException | InterruptedException e) {
                System.out.println("Item " + i + " failed: " + e.getMessage());
            }
        }
    }
    
    private String processItem(String item) throws InterruptedException {
        Thread.sleep(1000);
        return "Processed: " + item;
    }
    
    public void shutdown() {
        executor.shutdown();
        try {
            executor.awaitTermination(10, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }
    
    public static void main(String[] args) {
        BatchProcessor processor = new BatchProcessor();
        
        List<String> items = Arrays.asList("Item1", "Item2", "Item3", "Item4", "Item5");
        processor.processBatch(items);
        processor.shutdown();
    }
}
```

---

## üí° Best Practices

1. ‚úÖ Always **shutdown** executor when done
2. ‚úÖ Use **try-finally** or try-with-resources
3. ‚úÖ Handle **InterruptedException** properly
4. ‚úÖ Use **awaitTermination** to wait for completion
5. ‚úÖ Choose appropriate **thread pool type**
6. ‚úÖ Set **meaningful thread names** for debugging
7. ‚úÖ Handle **exceptions** in submitted tasks
8. ‚ùå Don't create too many threads (resource exhaustion)

---

## üéØ Interview Questions

1. **What is ExecutorService?**
2. **What are different types of thread pools?**
3. **What is the difference between execute() and submit()?**
4. **What is the difference between shutdown() and shutdownNow()?**
5. **What is invokeAll() vs invokeAny()?**
6. **How do you handle exceptions in ExecutorService?**
7. **When would you use FixedThreadPool vs CachedThreadPool?**
8. **What happens if you don't shutdown ExecutorService?**

---

## üìö Next Topics

- [Thread Pools](02.%20Thread%20Pools.md)
- [Callable & Future](03.%20Callable%20%26%20Future.md)
- [CompletableFuture](04.%20CompletableFuture.md)
