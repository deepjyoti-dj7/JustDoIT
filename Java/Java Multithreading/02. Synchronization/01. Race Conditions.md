# üèÅ Race Conditions

## üìñ What is a Race Condition?

A **race condition** occurs when two or more threads access shared data concurrently, and at least one thread modifies the data, leading to unpredictable results. The final outcome depends on the timing/order of thread execution.

---

## üéØ Why Race Conditions Happen?

1. **Non-atomic operations**: Operations that involve multiple steps
2. **Shared mutable state**: Multiple threads accessing same data
3. **No synchronization**: Lack of proper thread coordination
4. **Interleaved execution**: Thread scheduler switches between threads

---

## üíª Example 1: Counter Race Condition

### Without Synchronization (‚ùå Bug)

```java
class Counter {
    private int count = 0;
    
    public void increment() {
        count++; // NOT atomic! (read, increment, write)
    }
    
    public int getCount() {
        return count;
    }
}

public class RaceConditionExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        
        // Create 2 threads, each incrementing 1000 times
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Expected: 2000");
        System.out.println("Actual: " + counter.getCount()); // Often less than 2000!
    }
}
```

**Output (Varies):**
```
Expected: 2000
Actual: 1847
```

### Why This Happens?

The `count++` operation is actually three separate operations:
1. **Read** the current value of count
2. **Increment** the value
3. **Write** the new value back

```
Thread 1: Read count (0)
Thread 2: Read count (0)
Thread 1: Increment (0 + 1 = 1)
Thread 2: Increment (0 + 1 = 1)
Thread 1: Write count (1)
Thread 2: Write count (1)
Result: count = 1 (should be 2!)
```

---

## üíª Example 2: Bank Account Race Condition

### Without Synchronization (‚ùå Bug)

```java
class BankAccount {
    private double balance = 1000.0;
    
    public void withdraw(double amount) {
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() + 
                              " is withdrawing " + amount);
            
            // Simulate some processing time
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            balance -= amount;
            System.out.println(Thread.currentThread().getName() + 
                              " completed. Balance: " + balance);
        } else {
            System.out.println(Thread.currentThread().getName() + 
                              " insufficient funds");
        }
    }
    
    public double getBalance() {
        return balance;
    }
}

public class BankAccountRaceCondition {
    public static void main(String[] args) throws InterruptedException {
        BankAccount account = new BankAccount();
        
        // Two people trying to withdraw simultaneously
        Thread person1 = new Thread(() -> account.withdraw(800), "Person-1");
        Thread person2 = new Thread(() -> account.withdraw(800), "Person-2");
        
        person1.start();
        person2.start();
        
        person1.join();
        person2.join();
        
        System.out.println("Final balance: " + account.getBalance());
    }
}
```

**Output:**
```
Person-1 is withdrawing 800.0
Person-2 is withdrawing 800.0
Person-1 completed. Balance: 200.0
Person-2 completed. Balance: -600.0  ‚Üê NEGATIVE BALANCE! (BUG)
Final balance: -600.0
```

---

## üíª Example 3: ArrayList Race Condition

### Without Synchronization (‚ùå Bug)

```java
import java.util.ArrayList;
import java.util.List;

public class ListRaceCondition {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> list = new ArrayList<>();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                list.add(i);
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Expected size: 2000");
        System.out.println("Actual size: " + list.size()); // May crash or give wrong size
    }
}
```

**Possible Outcomes:**
1. `ArrayIndexOutOfBoundsException`
2. `NullPointerException`
3. Incorrect size (< 2000)
4. Data corruption

---

## üîß Solutions to Race Conditions

### Solution 1: Synchronized Method

```java
class SynchronizedCounter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
}

public class SynchronizedSolution {
    public static void main(String[] args) throws InterruptedException {
        SynchronizedCounter counter = new SynchronizedCounter();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Count: " + counter.getCount()); // Always 2000
    }
}
```

### Solution 2: Synchronized Block

```java
class BankAccountSafe {
    private double balance = 1000.0;
    private final Object lock = new Object();
    
    public void withdraw(double amount) {
        synchronized (lock) {
            if (balance >= amount) {
                System.out.println(Thread.currentThread().getName() + 
                                  " is withdrawing " + amount);
                
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                
                balance -= amount;
                System.out.println(Thread.currentThread().getName() + 
                                  " completed. Balance: " + balance);
            } else {
                System.out.println(Thread.currentThread().getName() + 
                                  " insufficient funds");
            }
        }
    }
    
    public double getBalance() {
        synchronized (lock) {
            return balance;
        }
    }
}
```

### Solution 3: Atomic Variables

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet(); // Atomic operation
    }
    
    public int getCount() {
        return count.get();
    }
}

public class AtomicSolution {
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Count: " + counter.getCount()); // Always 2000
    }
}
```

### Solution 4: Concurrent Collections

```java
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class ConcurrentListSolution {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> list = new CopyOnWriteArrayList<>();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 1000; i < 2000; i++) {
                list.add(i);
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Size: " + list.size()); // Always 2000
    }
}
```

---

## üéØ Detecting Race Conditions

### Example: Using Print Statements

```java
class DebugCounter {
    private int count = 0;
    
    public void increment() {
        int temp = count;
        System.out.println(Thread.currentThread().getName() + 
                          " read: " + temp);
        
        temp = temp + 1;
        System.out.println(Thread.currentThread().getName() + 
                          " incremented to: " + temp);
        
        count = temp;
        System.out.println(Thread.currentThread().getName() + 
                          " wrote: " + count);
    }
    
    public int getCount() {
        return count;
    }
}

public class RaceDetection {
    public static void main(String[] args) throws InterruptedException {
        DebugCounter counter = new DebugCounter();
        
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                counter.increment();
            }
        }, "Thread-1");
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                counter.increment();
            }
        }, "Thread-2");
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("\nFinal count: " + counter.getCount());
    }
}
```

---

## üí° Best Practices

1. ‚úÖ **Identify shared mutable state** in your code
2. ‚úÖ **Minimize shared state** when possible
3. ‚úÖ **Use immutable objects** for thread safety
4. ‚úÖ **Synchronize access** to shared mutable state
5. ‚úÖ **Prefer higher-level concurrency utilities** (Atomic classes, Concurrent collections)
6. ‚úÖ **Keep synchronized blocks small** to minimize contention
7. ‚úÖ **Test with multiple threads** under load

---

## ‚ö†Ô∏è Common Pitfalls

1. ‚ùå Assuming operations are atomic when they're not
2. ‚ùå Not synchronizing all access to shared state
3. ‚ùå Using different locks for same shared state
4. ‚ùå Ignoring race conditions in complex objects
5. ‚ùå Not considering visibility issues (use `volatile` or synchronization)

---

## üéØ Interview Questions

1. **What is a race condition?**
2. **Why is count++ not thread-safe?**
3. **How can you detect race conditions?**
4. **What are the solutions to race conditions?**
5. **Is reading a variable thread-safe?**
6. **What is the difference between race condition and data race?**
7. **Can race conditions occur with only read operations?**
8. **How do Atomic classes prevent race conditions?**

---

## üìö Next Topics

- [Synchronized Keyword](02.%20Synchronized%20Keyword.md)
- [Volatile Keyword](03.%20Volatile%20Keyword.md)
- [Atomic Variables](04.%20Atomic%20Variables.md)
