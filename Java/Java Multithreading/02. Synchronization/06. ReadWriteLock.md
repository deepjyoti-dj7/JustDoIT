# üìö ReadWriteLock

## üìñ What is ReadWriteLock?

`ReadWriteLock` maintains a pair of locks:
- **Read Lock**: Multiple threads can hold simultaneously (shared lock)
- **Write Lock**: Only one thread can hold (exclusive lock)

**Use Case**: When you have many read operations and few write operations.

---

## üéØ Basic Concept

```
Multiple Readers: ‚úÖ Allowed
Multiple Writers: ‚ùå Not allowed  
Reader + Writer: ‚ùå Not allowed
```

---

## üíª Example 1: Basic ReadWriteLock

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class SharedResource {
    private int value = 0;
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    
    // Read operation - multiple threads can execute
    public int read() {
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " reading: " + value);
            Thread.sleep(1000); // Simulate read time
            return value;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return -1;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    // Write operation - only one thread can execute
    public void write(int newValue) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + newValue);
            value = newValue;
            Thread.sleep(1000); // Simulate write time
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // Start 5 reader threads
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> resource.read(), "Reader-" + i).start();
        }
        
        // Start 2 writer threads
        for (int i = 1; i <= 2; i++) {
            final int value = i * 10;
            new Thread(() -> resource.write(value), "Writer-" + i).start();
        }
    }
}
```

---

## üíª Example 2: Cache with ReadWriteLock

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class ThreadSafeCache<K, V> {
    private Map<K, V> cache = new HashMap<>();
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public V get(K key) {
        lock.readLock().lock();
        try {
            return cache.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(K key, V value) {
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void remove(K key) {
        lock.writeLock().lock();
        try {
            cache.remove(key);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int size() {
        lock.readLock().lock();
        try {
            return cache.size();
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        ThreadSafeCache<String, Integer> cache = new ThreadSafeCache<>();
        
        // Writers
        Thread writer1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                cache.put("key" + i, i);
                System.out.println("Writer-1 added key" + i);
            }
        });
        
        // Readers
        Thread reader1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                Integer value = cache.get("key" + i);
                System.out.println("Reader-1 read: " + value);
            }
        });
        
        Thread reader2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                Integer value = cache.get("key" + i);
                System.out.println("Reader-2 read: " + value);
            }
        });
        
        writer1.start();
        Thread.sleep(100);
        reader1.start();
        reader2.start();
        
        writer1.join();
        reader1.join();
        reader2.join();
    }
}
```

---

## üíª Example 3: Lock Downgrading

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class LockDowngrading {
    private int value = 0;
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public void updateValue(int newValue) {
        lock.writeLock().lock();
        try {
            value = newValue;
            System.out.println("Updated value to: " + value);
            
            // Downgrade to read lock
            lock.readLock().lock(); // Acquire read lock before releasing write lock
        } finally {
            lock.writeLock().unlock(); // Release write lock
        }
        
        try {
            // Now holding only read lock
            System.out.println("Reading updated value: " + value);
            // Can perform read operations
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        LockDowngrading example = new LockDowngrading();
        example.updateValue(42);
    }
}
```

---

## üìä Performance Comparison

```java
import java.util.concurrent.locks.*;

class PerformanceTest {
    private int value = 0;
    private ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private Object syncLock = new Object();
    
    // Using synchronized
    public synchronized int readSync() {
        return value;
    }
    
    public synchronized void writeSync(int val) {
        value = val;
    }
    
    // Using ReadWriteLock
    public int readRW() {
        rwLock.readLock().lock();
        try {
            return value;
        } finally {
            rwLock.readLock().unlock();
        }
    }
    
    public void writeRW(int val) {
        rwLock.writeLock().lock();
        try {
            value = val;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        PerformanceTest test = new PerformanceTest();
        int numReaders = 10;
        int numWrites = 2;
        
        System.out.println("=== Testing synchronized ===");
        long start = System.currentTimeMillis();
        Thread[] threads = new Thread[numReaders + numWrites];
        
        for (int i = 0; i < numReaders; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    test.readSync();
                }
            });
        }
        
        for (int i = numReaders; i < numReaders + numWrites; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    test.writeSync(j);
                }
            });
        }
        
        for (Thread t : threads) t.start();
        for (Thread t : threads) t.join();
        System.out.println("Time: " + (System.currentTimeMillis() - start) + "ms");
        
        System.out.println("\n=== Testing ReadWriteLock ===");
        start = System.currentTimeMillis();
        
        for (int i = 0; i < numReaders; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    test.readRW();
                }
            });
        }
        
        for (int i = numReaders; i < numReaders + numWrites; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    test.writeRW(j);
                }
            });
        }
        
        for (Thread t : threads) t.start();
        for (Thread t : threads) t.join();
        System.out.println("Time: " + (System.currentTimeMillis() - start) + "ms");
    }
}
```

---

## üí° When to Use

### ‚úÖ Use ReadWriteLock when:
1. Many read operations, few write operations
2. Read operations are time-consuming
3. Multiple threads need concurrent reads
4. Data doesn't change frequently

### ‚ùå Don't use when:
1. Equal read/write operations
2. Write operations are very frequent
3. Simple data structures (use synchronized)
4. Single-threaded access

---

## üéØ Interview Questions

1. **What is ReadWriteLock?**
2. **When would you use ReadWriteLock over synchronized?**
3. **Can multiple readers hold the lock simultaneously?**
4. **What is lock downgrading?**
5. **Is lock upgrading supported?**
6. **What is StampedLock?**

---

## üìö Next Topics

- [Thread Communication](../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
- [ConcurrentHashMap](../05.%20Concurrent%20Collections/01.%20ConcurrentHashMap.md)
