# âš›ï¸ Atomic Variables

## ðŸ“– What are Atomic Variables?

Atomic variables provide **lock-free, thread-safe** operations on single variables using low-level CPU instructions (Compare-And-Swap). They are part of `java.util.concurrent.atomic` package.

**Key Benefits:**
- Thread-safe without synchronization
- Non-blocking (no lock contention)
- Better performance than synchronized
- Atomic compound operations

---

## ðŸŽ¯ Common Atomic Classes

1. **AtomicInteger** - int values
2. **AtomicLong** - long values
3. **AtomicBoolean** - boolean values
4. **AtomicReference** - object references
5. **AtomicIntegerArray** - int arrays
6. **AtomicLongArray** - long arrays
7. **AtomicReferenceArray** - object arrays

---

## ðŸ’» Example 1: AtomicInteger

### Problem: Non-Atomic Counter

```java
class NonAtomicCounter {
    private int count = 0;
    
    public void increment() {
        count++; // NOT thread-safe!
    }
    
    public int getCount() {
        return count;
    }
}
```

### Solution: Using AtomicInteger

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet(); // Thread-safe atomic operation
    }
    
    public void decrement() {
        count.decrementAndGet();
    }
    
    public int getCount() {
        return count.get();
    }
    
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();
        
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("Count: " + counter.getCount()); // Always 2000!
    }
}
```

---

## ðŸ’» Example 2: AtomicInteger Methods

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerMethods {
    public static void main(String[] args) {
        AtomicInteger atomic = new AtomicInteger(10);
        
        // Get current value
        System.out.println("Initial value: " + atomic.get()); // 10
        
        // Set new value
        atomic.set(20);
        System.out.println("After set: " + atomic.get()); // 20
        
        // Get and set
        int oldValue = atomic.getAndSet(30);
        System.out.println("Old: " + oldValue + ", New: " + atomic.get()); // Old: 20, New: 30
        
        // Increment and get
        int newValue = atomic.incrementAndGet();
        System.out.println("After increment: " + newValue); // 31
        
        // Get and increment
        int current = atomic.getAndIncrement();
        System.out.println("Current: " + current + ", After: " + atomic.get()); // Current: 31, After: 32
        
        // Decrement and get
        newValue = atomic.decrementAndGet();
        System.out.println("After decrement: " + newValue); // 31
        
        // Get and decrement
        current = atomic.getAndDecrement();
        System.out.println("Current: " + current + ", After: " + atomic.get()); // Current: 31, After: 30
        
        // Add and get
        newValue = atomic.addAndGet(5);
        System.out.println("After add 5: " + newValue); // 35
        
        // Get and add
        current = atomic.getAndAdd(10);
        System.out.println("Current: " + current + ", After: " + atomic.get()); // Current: 35, After: 45
        
        // Compare and set
        boolean updated = atomic.compareAndSet(45, 100);
        System.out.println("CAS success: " + updated + ", Value: " + atomic.get()); // true, 100
        
        updated = atomic.compareAndSet(50, 200);
        System.out.println("CAS success: " + updated + ", Value: " + atomic.get()); // false, 100
    }
}
```

---

## ðŸ’» Example 3: Compare-And-Swap (CAS)

```java
import java.util.concurrent.atomic.AtomicInteger;

class CASExample {
    private AtomicInteger value = new AtomicInteger(0);
    
    public void safeIncrement() {
        int current;
        int next;
        
        do {
            current = value.get();
            next = current + 1;
        } while (!value.compareAndSet(current, next));
        
        // CAS loop: retry until successful
    }
    
    public static void main(String[] args) throws InterruptedException {
        CASExample example = new CASExample();
        
        Thread[] threads = new Thread[10];
        
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    example.safeIncrement();
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Final value: " + example.value.get()); // 1000
    }
}
```

---

## ðŸ’» Example 4: AtomicBoolean

```java
import java.util.concurrent.atomic.AtomicBoolean;

class TaskController {
    private AtomicBoolean running = new AtomicBoolean(false);
    
    public boolean start() {
        // Atomically set to true only if currently false
        if (running.compareAndSet(false, true)) {
            System.out.println("Task started");
            return true;
        } else {
            System.out.println("Task already running");
            return false;
        }
    }
    
    public void stop() {
        running.set(false);
        System.out.println("Task stopped");
    }
    
    public static void main(String[] args) throws InterruptedException {
        TaskController controller = new TaskController();
        
        // Multiple threads trying to start
        Thread t1 = new Thread(() -> controller.start());
        Thread t2 = new Thread(() -> controller.start());
        Thread t3 = new Thread(() -> controller.start());
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        controller.stop();
    }
}
```

**Output:**
```
Task started
Task already running
Task already running
Task stopped
```

---

## ðŸ’» Example 5: AtomicReference

```java
import java.util.concurrent.atomic.AtomicReference;

class User {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}

class AtomicReferenceExample {
    private AtomicReference<User> userRef = new AtomicReference<>();
    
    public void updateUser(User newUser) {
        User oldUser = userRef.getAndSet(newUser);
        System.out.println("Updated from: " + oldUser + " to: " + newUser);
    }
    
    public boolean compareAndUpdate(User expected, User newUser) {
        boolean updated = userRef.compareAndSet(expected, newUser);
        if (updated) {
            System.out.println("Successfully updated to: " + newUser);
        } else {
            System.out.println("Update failed, current: " + userRef.get());
        }
        return updated;
    }
    
    public static void main(String[] args) {
        AtomicReferenceExample example = new AtomicReferenceExample();
        
        User user1 = new User("Alice", 25);
        User user2 = new User("Bob", 30);
        User user3 = new User("Charlie", 35);
        
        example.userRef.set(user1);
        System.out.println("Initial: " + example.userRef.get());
        
        example.updateUser(user2);
        
        example.compareAndUpdate(user2, user3); // Success
        example.compareAndUpdate(user1, user2); // Fail
    }
}
```

---

## ðŸ’» Example 6: AtomicLong for Statistics

```java
import java.util.concurrent.atomic.AtomicLong;

class RequestStatistics {
    private AtomicLong totalRequests = new AtomicLong(0);
    private AtomicLong successfulRequests = new AtomicLong(0);
    private AtomicLong failedRequests = new AtomicLong(0);
    private AtomicLong totalResponseTime = new AtomicLong(0);
    
    public void recordSuccess(long responseTime) {
        totalRequests.incrementAndGet();
        successfulRequests.incrementAndGet();
        totalResponseTime.addAndGet(responseTime);
    }
    
    public void recordFailure() {
        totalRequests.incrementAndGet();
        failedRequests.incrementAndGet();
    }
    
    public void printStatistics() {
        long total = totalRequests.get();
        long success = successfulRequests.get();
        long failed = failedRequests.get();
        long avgTime = total > 0 ? totalResponseTime.get() / success : 0;
        
        System.out.println("\n=== Request Statistics ===");
        System.out.println("Total Requests: " + total);
        System.out.println("Successful: " + success);
        System.out.println("Failed: " + failed);
        System.out.println("Success Rate: " + (total > 0 ? (success * 100.0 / total) : 0) + "%");
        System.out.println("Avg Response Time: " + avgTime + "ms");
    }
    
    public static void main(String[] args) throws InterruptedException {
        RequestStatistics stats = new RequestStatistics();
        
        // Simulate multiple threads recording statistics
        Thread[] threads = new Thread[5];
        
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    if (Math.random() > 0.1) {
                        stats.recordSuccess((long)(Math.random() * 100));
                    } else {
                        stats.recordFailure();
                    }
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        stats.printStatistics();
    }
}
```

---

## ðŸ’» Example 7: AtomicIntegerArray

```java
import java.util.concurrent.atomic.AtomicIntegerArray;

class AtomicArrayExample {
    private AtomicIntegerArray scores = new AtomicIntegerArray(5);
    
    public void incrementScore(int index) {
        scores.incrementAndGet(index);
    }
    
    public void addScore(int index, int delta) {
        scores.addAndGet(index, delta);
    }
    
    public int getScore(int index) {
        return scores.get(index);
    }
    
    public void printScores() {
        System.out.print("Scores: [");
        for (int i = 0; i < scores.length(); i++) {
            System.out.print(scores.get(i));
            if (i < scores.length() - 1) System.out.print(", ");
        }
        System.out.println("]");
    }
    
    public static void main(String[] args) throws InterruptedException {
        AtomicArrayExample example = new AtomicArrayExample();
        
        // Multiple threads updating different indices
        Thread[] threads = new Thread[5];
        
        for (int i = 0; i < threads.length; i++) {
            final int index = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    example.incrementScore(index);
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        example.printScores(); // Scores: [100, 100, 100, 100, 100]
    }
}
```

---

## ðŸ“Š Performance Comparison

```java
import java.util.concurrent.atomic.AtomicInteger;

class PerformanceComparison {
    private int syncCounter = 0;
    private AtomicInteger atomicCounter = new AtomicInteger(0);
    
    public synchronized void syncIncrement() {
        syncCounter++;
    }
    
    public void atomicIncrement() {
        atomicCounter.incrementAndGet();
    }
    
    public static void main(String[] args) throws InterruptedException {
        PerformanceComparison test = new PerformanceComparison();
        
        // Test synchronized
        long start = System.currentTimeMillis();
        Thread[] syncThreads = new Thread[10];
        for (int i = 0; i < syncThreads.length; i++) {
            syncThreads[i] = new Thread(() -> {
                for (int j = 0; j < 100000; j++) {
                    test.syncIncrement();
                }
            });
            syncThreads[i].start();
        }
        for (Thread t : syncThreads) t.join();
        long syncTime = System.currentTimeMillis() - start;
        
        // Test atomic
        start = System.currentTimeMillis();
        Thread[] atomicThreads = new Thread[10];
        for (int i = 0; i < atomicThreads.length; i++) {
            atomicThreads[i] = new Thread(() -> {
                for (int j = 0; j < 100000; j++) {
                    test.atomicIncrement();
                }
            });
            atomicThreads[i].start();
        }
        for (Thread t : atomicThreads) t.join();
        long atomicTime = System.currentTimeMillis() - start;
        
        System.out.println("Synchronized: " + syncTime + "ms");
        System.out.println("Atomic: " + atomicTime + "ms");
        System.out.println("Atomic is " + (syncTime * 100.0 / atomicTime) + "% faster");
    }
}
```

---

## ðŸ’¡ Best Practices

1. âœ… Use atomic classes for **simple counters** and **flags**
2. âœ… Prefer atomic over synchronized for **single variables**
3. âœ… Use CAS operations for **lock-free algorithms**
4. âœ… Atomic classes are **non-blocking** (better scalability)
5. âŒ Don't use for **multiple related variables** (use synchronized)
6. âŒ Don't use for **complex operations** (use locks)

---

## ðŸŽ¯ Interview Questions

1. **What are atomic variables in Java?**
2. **How does AtomicInteger work internally?**
3. **What is Compare-And-Swap (CAS)?**
4. **When would you use AtomicInteger vs synchronized int?**
5. **What is the ABA problem in CAS?**
6. **Are atomic operations always better than synchronized?**
7. **What is the difference between volatile and atomic?**
8. **Can you explain lock-free programming?**

---

## ðŸ“š Next Topics

- [Locks & ReentrantLock](05.%20Locks%20%26%20ReentrantLock.md)
- [Volatile Keyword](03.%20Volatile%20Keyword.md)
- [ConcurrentHashMap](../05.%20Concurrent%20Collections/01.%20ConcurrentHashMap.md)
