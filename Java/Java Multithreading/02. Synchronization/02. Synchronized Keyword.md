# ðŸ”’ Synchronized Keyword

## ðŸ“– What is Synchronized?

The `synchronized` keyword in Java provides **mutual exclusion** - ensuring that only one thread can execute a synchronized block or method at a time on a given object.

---

## ðŸŽ¯ Types of Synchronization

1. **Synchronized Method** (Instance level)
2. **Synchronized Method** (Class level - static)
3. **Synchronized Block** (Instance level)
4. **Synchronized Block** (Class level)

---

## ðŸ’» 1. Synchronized Instance Method

### Example

```java
class Counter {
    private int count = 0;
    
    // Synchronized on 'this' object
    public synchronized void increment() {
        count++;
    }
    
    public synchronized void decrement() {
        count--;
    }
    
    public synchronized int getCount() {
        return count;
    }
}

public class SynchronizedMethodExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        
        Thread incrementThread = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread decrementThread = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.decrement();
            }
        });
        
        incrementThread.start();
        decrementThread.start();
        
        incrementThread.join();
        decrementThread.join();
        
        System.out.println("Final count: " + counter.getCount()); // Always 0
    }
}
```

**Key Points:**
- Lock is acquired on the **instance** (this object)
- Only one thread can execute ANY synchronized instance method of that object
- Different instances have different locks

---

## ðŸ’» 2. Synchronized Static Method

### Example

```java
class StaticCounter {
    private static int count = 0;
    
    // Synchronized on Class object (StaticCounter.class)
    public static synchronized void increment() {
        count++;
    }
    
    public static synchronized int getCount() {
        return count;
    }
}

public class SynchronizedStaticExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                StaticCounter.increment();
            }
        });
        
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                StaticCounter.increment();
            }
        });
        
        thread1.start();
        thread2.start();
        
        thread1.join();
        thread2.join();
        
        System.out.println("Count: " + StaticCounter.getCount()); // Always 2000
    }
}
```

**Key Points:**
- Lock is acquired on the **Class object** (ClassName.class)
- Shared across all instances of the class
- Used for static shared data

---

## ðŸ’» 3. Synchronized Block (Instance Lock)

### Example

```java
class BankAccount {
    private double balance = 1000.0;
    private final Object lock = new Object();
    
    public void withdraw(double amount) {
        System.out.println(Thread.currentThread().getName() + " attempting withdrawal");
        
        // Only critical section is synchronized
        synchronized (lock) {
            if (balance >= amount) {
                System.out.println(Thread.currentThread().getName() + 
                                  " withdrawing " + amount);
                try {
                    Thread.sleep(100); // Simulate processing
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                balance -= amount;
                System.out.println(Thread.currentThread().getName() + 
                                  " completed. Balance: " + balance);
            } else {
                System.out.println(Thread.currentThread().getName() + 
                                  " insufficient funds");
            }
        }
    }
    
    public double getBalance() {
        synchronized (lock) {
            return balance;
        }
    }
}

public class SynchronizedBlockExample {
    public static void main(String[] args) throws InterruptedException {
        BankAccount account = new BankAccount();
        
        Thread t1 = new Thread(() -> account.withdraw(600), "User-1");
        Thread t2 = new Thread(() -> account.withdraw(600), "User-2");
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("Final balance: " + account.getBalance());
    }
}
```

**Key Points:**
- More **fine-grained control** over synchronization
- Can use **any object** as a lock
- Only critical section is synchronized (better performance)
- Common practice: use private final Object as lock

---

## ðŸ’» 4. Synchronized Block (Class Lock)

### Example

```java
class Singleton {
    private static Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            // Synchronized on Class object
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

public class ClassLockExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            Singleton s1 = Singleton.getInstance();
            System.out.println("Thread 1: " + s1);
        });
        
        Thread thread2 = new Thread(() -> {
            Singleton s2 = Singleton.getInstance();
            System.out.println("Thread 2: " + s2);
        });
        
        thread1.start();
        thread2.start();
    }
}
```

---

## ðŸ“Š Synchronized Method vs Block

### Synchronized Method

```java
class Example1 {
    private int value;
    
    public synchronized void method() {
        // Entire method is synchronized
        value++;
        System.out.println(value);
        // More code...
    }
}
```

**Equivalent to:**

```java
class Example2 {
    private int value;
    
    public void method() {
        synchronized (this) {
            // Entire method body
            value++;
            System.out.println(value);
            // More code...
        }
    }
}
```

### Synchronized Block (Better)

```java
class Example3 {
    private int value;
    private final Object lock = new Object();
    
    public void method() {
        // Non-critical code (no lock needed)
        System.out.println("Preparing...");
        
        // Only critical section is synchronized
        synchronized (lock) {
            value++;
        }
        
        // Non-critical code (no lock needed)
        System.out.println("Value: " + value);
    }
}
```

---

## ðŸŽ¯ Multiple Locks Example

```java
class MultiLockExample {
    private int counter1 = 0;
    private int counter2 = 0;
    
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void incrementCounter1() {
        synchronized (lock1) {
            counter1++;
            System.out.println("Counter1: " + counter1);
        }
    }
    
    public void incrementCounter2() {
        synchronized (lock2) {
            counter2++;
            System.out.println("Counter2: " + counter2);
        }
    }
    
    public static void main(String[] args) {
        MultiLockExample example = new MultiLockExample();
        
        // These can run in parallel (different locks)
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                example.incrementCounter1();
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                example.incrementCounter2();
            }
        });
        
        t1.start();
        t2.start();
    }
}
```

---

## âš ï¸ Common Mistakes

### âŒ Mistake 1: Synchronizing on Different Objects

```java
class WrongSync {
    private int count = 0;
    
    public void increment() {
        // WRONG: Creates new Object each time!
        synchronized (new Object()) {
            count++;
        }
    }
}
```

### âŒ Mistake 2: Not Synchronizing All Access

```java
class IncompleteSync {
    private int count = 0;
    
    public synchronized void increment() {
        count++; // Synchronized
    }
    
    public int getCount() {
        return count; // NOT synchronized (BUG!)
    }
}
```

### âŒ Mistake 3: Holding Lock Too Long

```java
class SlowSync {
    private int count = 0;
    
    public synchronized void doWork() {
        count++;
        
        // BAD: Holding lock during slow I/O
        try {
            Thread.sleep(5000); // Slow operation
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println(count);
    }
}
```

**Better:**

```java
class BetterSync {
    private int count = 0;
    private final Object lock = new Object();
    
    public void doWork() {
        synchronized (lock) {
            count++; // Only critical section is synchronized
        }
        
        // I/O outside synchronized block
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println(count);
    }
}
```

---

## ðŸ’¡ Reentrancy

Synchronized locks in Java are **reentrant** - a thread can acquire the same lock multiple times.

```java
class ReentrantExample {
    private int count = 0;
    
    public synchronized void method1() {
        count++;
        method2(); // Can call another synchronized method
    }
    
    public synchronized void method2() {
        count++;
        // Thread already holds the lock, can acquire it again
    }
    
    public static void main(String[] args) {
        ReentrantExample example = new ReentrantExample();
        example.method1(); // Works fine!
        System.out.println("Count: " + example.count); // 2
    }
}
```

---

## ðŸŽ¯ Best Practices

1. âœ… **Minimize synchronization scope** - only critical sections
2. âœ… **Use private final lock objects** for better encapsulation
3. âœ… **Synchronize all access** to shared mutable state
4. âœ… **Avoid nested locks** to prevent deadlock
5. âœ… **Don't synchronize on publicly accessible objects**
6. âœ… **Keep synchronized blocks short** for better performance
7. âœ… **Document locking strategy** in comments

---

## ðŸŽ¯ Interview Questions

1. **What is the synchronized keyword?**
2. **What is the difference between synchronized method and block?**
3. **What object does a synchronized method lock on?**
4. **Can two threads execute two different synchronized methods on the same object?**
5. **What is reentrant synchronization?**
6. **Can synchronized methods call other synchronized methods?**
7. **What is the difference between instance lock and class lock?**
8. **How does synchronized guarantee visibility?**

---

## ðŸ“š Next Topics

- [Volatile Keyword](03.%20Volatile%20Keyword.md)
- [Locks & ReentrantLock](05.%20Locks%20%26%20ReentrantLock.md)
- [Deadlock](../06.%20Advanced%20Concepts/02.%20Deadlock.md)
