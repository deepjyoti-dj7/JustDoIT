# âš¡ Volatile Keyword

## ğŸ“– What is Volatile?

The `volatile` keyword in Java is used to mark a variable as being stored in **main memory**, ensuring that:
1. **Visibility**: Changes made by one thread are immediately visible to all other threads
2. **No Caching**: Variable is not cached in thread-local memory (CPU cache)
3. **Prevents Reordering**: Establishes happens-before relationship

---

## ğŸ¯ Problem: Visibility Issue

### Without Volatile (âŒ Bug)

```java
class VisibilityProblem {
    private boolean flag = false; // Not volatile
    
    public void writer() {
        System.out.println("Writer: Setting flag to true");
        flag = true;
    }
    
    public void reader() {
        System.out.println("Reader: Waiting for flag...");
        while (!flag) {
            // Busy waiting - may never see flag = true!
        }
        System.out.println("Reader: Flag is now true!");
    }
    
    public static void main(String[] args) {
        VisibilityProblem problem = new VisibilityProblem();
        
        Thread readerThread = new Thread(() -> problem.reader());
        Thread writerThread = new Thread(() -> problem.writer());
        
        readerThread.start();
        
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        writerThread.start();
        
        // Reader thread may never exit the loop!
    }
}
```

**Problem**: Reader thread caches `flag` in CPU cache and never sees the update!

---

## âœ… Solution: Using Volatile

```java
class VolatileSolution {
    private volatile boolean flag = false; // Volatile ensures visibility
    
    public void writer() {
        System.out.println("Writer: Setting flag to true");
        flag = true;
    }
    
    public void reader() {
        System.out.println("Reader: Waiting for flag...");
        while (!flag) {
            // Will see the change immediately
        }
        System.out.println("Reader: Flag is now true!");
    }
    
    public static void main(String[] args) throws InterruptedException {
        VolatileSolution solution = new VolatileSolution();
        
        Thread readerThread = new Thread(() -> solution.reader());
        Thread writerThread = new Thread(() -> solution.writer());
        
        readerThread.start();
        Thread.sleep(1000);
        writerThread.start();
        
        readerThread.join();
        writerThread.join();
        
        System.out.println("Completed successfully!");
    }
}
```

---

## ğŸ’» Example 1: Stop Flag Pattern

```java
class StoppableTask {
    private volatile boolean running = true;
    
    public void start() {
        Thread thread = new Thread(() -> {
            System.out.println("Task started");
            int count = 0;
            
            while (running) {
                System.out.println("Working... " + count++);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
            
            System.out.println("Task stopped gracefully");
        });
        
        thread.start();
    }
    
    public void stop() {
        System.out.println("Stopping task...");
        running = false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        StoppableTask task = new StoppableTask();
        task.start();
        
        Thread.sleep(3000);
        task.stop();
        
        Thread.sleep(1000);
    }
}
```

**Output:**
```
Task started
Working... 0
Working... 1
Working... 2
Working... 3
Working... 4
Stopping task...
Task stopped gracefully
```

---

## ğŸ’» Example 2: Singleton with Double-Checked Locking

```java
class Singleton {
    // volatile is CRITICAL here!
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) { // First check (no locking)
            synchronized (Singleton.class) {
                if (instance == null) { // Second check (with locking)
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**Why volatile is needed:**
Without volatile, another thread might see a partially constructed object due to instruction reordering.

---

## ğŸ’» Example 3: Status Flag

```java
class TaskExecutor {
    private volatile boolean ready = false;
    private volatile boolean completed = false;
    private String result;
    
    public void prepare() {
        System.out.println("Preparing task...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        result = "Task Result";
        ready = true;
        System.out.println("Task ready");
    }
    
    public void execute() {
        System.out.println("Waiting for task to be ready...");
        while (!ready) {
            // Wait for preparation
        }
        
        System.out.println("Executing task with: " + result);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        completed = true;
        System.out.println("Task completed");
    }
    
    public void monitor() {
        System.out.println("Monitoring task...");
        while (!completed) {
            // Wait for completion
        }
        System.out.println("Monitor: Task is completed!");
    }
    
    public static void main(String[] args) throws InterruptedException {
        TaskExecutor executor = new TaskExecutor();
        
        Thread t1 = new Thread(() -> executor.prepare());
        Thread t2 = new Thread(() -> executor.execute());
        Thread t3 = new Thread(() -> executor.monitor());
        
        t2.start();
        t3.start();
        Thread.sleep(500);
        t1.start();
        
        t1.join();
        t2.join();
        t3.join();
    }
}
```

---

## âš ï¸ What Volatile Does NOT Guarantee

### âŒ Does NOT provide atomicity

```java
class VolatileCounter {
    private volatile int count = 0;
    
    public void increment() {
        count++; // NOT ATOMIC! Still has race condition
        // Actual operations: read, increment, write
    }
    
    public static void main(String[] args) throws InterruptedException {
        VolatileCounter counter = new VolatileCounter();
        
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("Count: " + counter.count); // Less than 2000!
    }
}
```

**Solution: Use AtomicInteger or synchronized**

```java
import java.util.concurrent.atomic.AtomicInteger;

class CorrectCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet(); // Atomic operation
    }
    
    public int getCount() {
        return count.get();
    }
}
```

---

## ğŸ“Š Volatile vs Synchronized vs Atomic

| Feature | volatile | synchronized | Atomic Classes |
|---------|----------|--------------|----------------|
| **Visibility** | âœ… Yes | âœ… Yes | âœ… Yes |
| **Atomicity** | âŒ No | âœ… Yes | âœ… Yes |
| **Blocking** | âŒ Non-blocking | âœ… Can block | âŒ Non-blocking |
| **Performance** | Fast | Slower | Fast |
| **Use Case** | Flags, status | Critical sections | Counters, numbers |

---

## ğŸ’¡ When to Use Volatile

### âœ… Good Use Cases

1. **Status flags**
```java
private volatile boolean shutdown = false;
```

2. **State indicators**
```java
private volatile boolean initialized = false;
```

3. **Simple read/write variables**
```java
private volatile long timestamp;
```

4. **Reference updates**
```java
private volatile Object reference;
```

### âŒ Bad Use Cases

1. **Compound operations**
```java
// DON'T USE volatile here
private volatile int counter;
counter++; // Not thread-safe!
```

2. **Multiple dependent variables**
```java
// DON'T USE volatile here
private volatile int x;
private volatile int y;
// If x and y must be updated together, use synchronized
```

---

## ğŸ” Memory Visibility Example

```java
class MemoryVisibilityDemo {
    private volatile int volatileVar = 0;
    private int normalVar = 0;
    
    public void writer() {
        normalVar = 100;
        volatileVar = 200; // This write happens-before any read of volatileVar
    }
    
    public void reader() {
        int v = volatileVar; // Reading volatile variable
        int n = normalVar;   // This read will see the write to normalVar
        
        System.out.println("Volatile: " + v + ", Normal: " + n);
        // Will print: Volatile: 200, Normal: 100
    }
    
    public static void main(String[] args) throws InterruptedException {
        MemoryVisibilityDemo demo = new MemoryVisibilityDemo();
        
        Thread writerThread = new Thread(() -> demo.writer());
        writerThread.start();
        writerThread.join();
        
        Thread readerThread = new Thread(() -> demo.reader());
        readerThread.start();
        readerThread.join();
    }
}
```

---

## ğŸ¯ Volatile Happens-Before Rule

**Rule**: A write to a volatile variable happens-before every subsequent read of that variable.

This means:
1. All writes before volatile write are visible after volatile read
2. All reads after volatile read see all writes before volatile write

```java
class HappensBeforeExample {
    private int x = 0;
    private int y = 0;
    private volatile boolean flag = false;
    
    public void thread1() {
        x = 10; // Operation 1
        y = 20; // Operation 2
        flag = true; // Operation 3 (volatile write)
    }
    
    public void thread2() {
        if (flag) { // Operation 4 (volatile read)
            // Operations 1 and 2 are guaranteed to be visible here
            System.out.println("x = " + x + ", y = " + y);
            // Always prints: x = 10, y = 20
        }
    }
}
```

---

## ğŸ’¡ Best Practices

1. âœ… Use volatile for **simple flags** and **status variables**
2. âœ… Use AtomicXXX for **counters** and **numeric operations**
3. âœ… Use synchronized for **complex operations** and **multiple variables**
4. âœ… Volatile is **cheaper** than synchronized for simple reads/writes
5. âœ… Always document why volatile is used
6. âŒ Don't use volatile for **compound operations**
7. âŒ Don't assume volatile provides **atomicity**

---

## ğŸ¯ Interview Questions

1. **What is the volatile keyword in Java?**
2. **What is the difference between volatile and synchronized?**
3. **Does volatile guarantee atomicity?**
4. **Can you explain the happens-before relationship with volatile?**
5. **When would you use volatile instead of synchronized?**
6. **What is the memory visibility problem?**
7. **Why is volatile needed in double-checked locking?**
8. **Can you use volatile with compound operations like count++?**

---

## ğŸ“š Next Topics

- [Atomic Variables](04.%20Atomic%20Variables.md)
- [Synchronized Keyword](02.%20Synchronized%20Keyword.md)
- [Memory Model](../06.%20Advanced%20Concepts/06.%20Memory%20Model.md)
- [Happens-Before](../06.%20Advanced%20Concepts/05.%20Happens-Before.md)
