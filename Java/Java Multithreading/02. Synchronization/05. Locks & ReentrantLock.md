# üîê Locks & ReentrantLock

## üìñ What is ReentrantLock?

`ReentrantLock` is a more flexible alternative to `synchronized` keyword, providing:
- **Explicit locking/unlocking**
- **Try-lock with timeout**
- **Interruptible lock acquisition**
- **Fair/unfair locking**
- **Multiple condition variables**
- **Lock status queries**

---

## üéØ Basic Usage

### synchronized vs ReentrantLock

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class LockComparison {
    private int count = 0;
    private Lock lock = new ReentrantLock();
    
    // Using synchronized
    public synchronized void incrementSync() {
        count++;
    }
    
    // Using ReentrantLock
    public void incrementLock() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // ALWAYS unlock in finally!
        }
    }
    
    public int getCount() {
        return count;
    }
}
```

---

## üíª Example 1: Basic Lock/Unlock

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Counter {
    private int count = 0;
    private Lock lock = new ReentrantLock();
    
    public void increment() {
        lock.lock();
        try {
            count++;
            System.out.println(Thread.currentThread().getName() + ": " + count);
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                counter.increment();
            }
        }, "Thread-1");
        
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                counter.increment();
            }
        }, "Thread-2");
        
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        
        System.out.println("Final count: " + counter.count);
    }
}
```

---

## üíª Example 2: tryLock() - Non-blocking

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class TryLockExample {
    private Lock lock = new ReentrantLock();
    
    public void doWork() {
        boolean acquired = lock.tryLock();
        
        if (acquired) {
            try {
                System.out.println(Thread.currentThread().getName() + 
                                  " acquired lock, working...");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println(Thread.currentThread().getName() + 
                                  " releasing lock");
                lock.unlock();
            }
        } else {
            System.out.println(Thread.currentThread().getName() + 
                              " could not acquire lock, doing alternative work");
        }
    }
    
    public static void main(String[] args) {
        TryLockExample example = new TryLockExample();
        
        Thread t1 = new Thread(() -> example.doWork(), "Thread-1");
        Thread t2 = new Thread(() -> example.doWork(), "Thread-2");
        Thread t3 = new Thread(() -> example.doWork(), "Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
    }
}
```

---

## üíª Example 3: tryLock() with Timeout

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class TryLockTimeoutExample {
    private Lock lock = new ReentrantLock();
    
    public void doWork() {
        try {
            boolean acquired = lock.tryLock(1, TimeUnit.SECONDS);
            
            if (acquired) {
                try {
                    System.out.println(Thread.currentThread().getName() + 
                                      " acquired lock");
                    Thread.sleep(2000); // Simulate work
                } finally {
                    lock.unlock();
                    System.out.println(Thread.currentThread().getName() + 
                                      " released lock");
                }
            } else {
                System.out.println(Thread.currentThread().getName() + 
                                  " timeout waiting for lock");
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + " interrupted");
        }
    }
    
    public static void main(String[] args) {
        TryLockTimeoutExample example = new TryLockTimeoutExample();
        
        for (int i = 1; i <= 3; i++) {
            new Thread(() -> example.doWork(), "Thread-" + i).start();
        }
    }
}
```

---

## üíª Example 4: lockInterruptibly()

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class InterruptibleLockExample {
    private Lock lock = new ReentrantLock();
    
    public void doWork() {
        try {
            System.out.println(Thread.currentThread().getName() + 
                              " trying to acquire lock");
            lock.lockInterruptibly(); // Can be interrupted while waiting
            
            try {
                System.out.println(Thread.currentThread().getName() + 
                                  " acquired lock, working...");
                Thread.sleep(5000);
            } finally {
                lock.unlock();
                System.out.println(Thread.currentThread().getName() + 
                                  " released lock");
            }
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName() + 
                              " was interrupted while waiting/working");
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        InterruptibleLockExample example = new InterruptibleLockExample();
        
        Thread t1 = new Thread(() -> example.doWork(), "Thread-1");
        Thread t2 = new Thread(() -> example.doWork(), "Thread-2");
        
        t1.start();
        Thread.sleep(100); // Let t1 acquire lock first
        t2.start();
        
        Thread.sleep(1000);
        System.out.println("Interrupting Thread-2");
        t2.interrupt(); // Interrupt t2 while waiting for lock
        
        t1.join();
        t2.join();
    }
}
```

---

## üíª Example 5: Fair vs Unfair Lock

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class FairLockExample {
    private Lock unfairLock = new ReentrantLock(); // Unfair by default
    private Lock fairLock = new ReentrantLock(true); // Fair lock
    
    public void testLock(Lock lock, String lockType) {
        lock.lock();
        try {
            System.out.println(lockType + " - " + Thread.currentThread().getName() + 
                              " acquired lock");
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        FairLockExample example = new FairLockExample();
        
        System.out.println("=== Testing Unfair Lock ===");
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 2; j++) {
                    example.testLock(example.unfairLock, "UNFAIR");
                }
            }, "Thread-" + i).start();
        }
        
        Thread.sleep(2000);
        
        System.out.println("\n=== Testing Fair Lock ===");
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 2; j++) {
                    example.testLock(example.fairLock, "FAIR");
                }
            }, "Thread-" + i).start();
        }
    }
}
```

---

## üíª Example 6: Condition Variables

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.LinkedList;
import java.util.Queue;

class BoundedBuffer {
    private Queue<Integer> queue = new LinkedList<>();
    private final int capacity = 5;
    private Lock lock = new ReentrantLock();
    private Condition notFull = lock.newCondition();
    private Condition notEmpty = lock.newCondition();
    
    public void produce(int value) throws InterruptedException {
        lock.lock();
        try {
            while (queue.size() == capacity) {
                System.out.println("Queue full, producer waiting...");
                notFull.await(); // Wait until not full
            }
            
            queue.add(value);
            System.out.println("Produced: " + value + " | Size: " + queue.size());
            notEmpty.signal(); // Signal that queue is not empty
        } finally {
            lock.unlock();
        }
    }
    
    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                System.out.println("Queue empty, consumer waiting...");
                notEmpty.await(); // Wait until not empty
            }
            
            int value = queue.poll();
            System.out.println("Consumed: " + value + " | Size: " + queue.size());
            notFull.signal(); // Signal that queue is not full
            return value;
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        BoundedBuffer buffer = new BoundedBuffer();
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    buffer.produce(i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    buffer.consume();
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        producer.start();
        consumer.start();
    }
}
```

---

## üíª Example 7: Multiple Conditions

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class MultiConditionExample {
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int turn = 1; // 1, 2, or 3
    
    public void printNumber(int threadNum, int maxNum) {
        for (int i = threadNum; i <= maxNum; i += 3) {
            lock.lock();
            try {
                while (turn != threadNum) {
                    if (threadNum == 1) condition1.await();
                    else if (threadNum == 2) condition2.await();
                    else condition3.await();
                }
                
                System.out.print(i + " ");
                turn = turn % 3 + 1;
                
                if (turn == 1) condition1.signal();
                else if (turn == 2) condition2.signal();
                else condition3.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        MultiConditionExample example = new MultiConditionExample();
        
        Thread t1 = new Thread(() -> example.printNumber(1, 15));
        Thread t2 = new Thread(() -> example.printNumber(2, 15));
        Thread t3 = new Thread(() -> example.printNumber(3, 15));
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        System.out.println("\nCompleted!");
    }
}
```

---

## üíª Example 8: Lock Status Queries

```java
import java.util.concurrent.locks.ReentrantLock;

class LockStatusExample {
    private ReentrantLock lock = new ReentrantLock();
    
    public void demonstrateStatus() {
        System.out.println("Is locked: " + lock.isLocked());
        System.out.println("Hold count: " + lock.getHoldCount());
        System.out.println("Has queued threads: " + lock.hasQueuedThreads());
        
        lock.lock();
        try {
            System.out.println("\nAfter acquiring lock:");
            System.out.println("Is locked: " + lock.isLocked());
            System.out.println("Hold count: " + lock.getHoldCount());
            System.out.println("Is held by current thread: " + lock.isHeldByCurrentThread());
            
            // Reentrant lock - same thread can acquire multiple times
            lock.lock();
            try {
                System.out.println("\nAfter acquiring lock again (reentrant):");
                System.out.println("Hold count: " + lock.getHoldCount());
            } finally {
                lock.unlock();
            }
            
            System.out.println("\nAfter one unlock:");
            System.out.println("Hold count: " + lock.getHoldCount());
        } finally {
            lock.unlock();
        }
        
        System.out.println("\nAfter all unlocks:");
        System.out.println("Is locked: " + lock.isLocked());
        System.out.println("Hold count: " + lock.getHoldCount());
    }
    
    public static void main(String[] args) {
        LockStatusExample example = new LockStatusExample();
        example.demonstrateStatus();
    }
}
```

---

## üìä ReentrantLock vs synchronized

| Feature | ReentrantLock | synchronized |
|---------|--------------|--------------|
| **Lock acquisition** | Explicit (lock()/unlock()) | Implicit (block exit) |
| **Try lock** | ‚úÖ tryLock() | ‚ùå No |
| **Timeout** | ‚úÖ tryLock(time) | ‚ùå No |
| **Interruptible** | ‚úÖ lockInterruptibly() | ‚ùå No |
| **Fairness** | ‚úÖ Optional | ‚ùå No guarantee |
| **Multiple conditions** | ‚úÖ Multiple Condition objects | ‚ùå Single wait set |
| **Lock status** | ‚úÖ Query methods | ‚ùå No |
| **Convenience** | More code | ‚úÖ Less code |
| **Performance** | Similar | Similar |
| **Risk** | Forget unlock() | ‚úÖ Auto-release |

---

## üí° Best Practices

1. ‚úÖ **Always use try-finally** to ensure unlock
2. ‚úÖ Use **tryLock()** to avoid deadlock
3. ‚úÖ Use **lockInterruptibly()** for cancellable operations
4. ‚úÖ Use **fair locks** when fairness is critical
5. ‚úÖ Use **multiple conditions** for complex coordination
6. ‚úÖ Prefer **synchronized** for simple cases
7. ‚ùå Don't forget to **unlock** (common bug!)

---

## üéØ Interview Questions

1. **What is ReentrantLock?**
2. **What are the advantages of ReentrantLock over synchronized?**
3. **What is a fair lock?**
4. **What is the difference between lock() and tryLock()?**
5. **What is lockInterruptibly()?**
6. **Can you forget to unlock a ReentrantLock?**
7. **What are Condition objects?**
8. **When would you use ReentrantLock instead of synchronized?**

---

## üìö Next Topics

- [ReadWriteLock](06.%20ReadWriteLock.md)
- [Deadlock](../06.%20Advanced%20Concepts/02.%20Deadlock.md)
- [Thread Communication](../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
