# üçΩÔ∏è Dining Philosophers Problem

## üìñ What is the Dining Philosophers Problem?

A classic synchronization problem where N philosophers sit around a table, alternating between thinking and eating. Each philosopher needs two forks (shared resources) to eat.

**Challenges:**
- Deadlock prevention
- Starvation prevention
- Resource contention
- Fairness

---

## üíª Example 1: Naive Solution (Deadlock Possible)

```java
class NaiveDiningPhilosophers {
    static class Fork {
        private final int id;
        
        Fork(int id) {
            this.id = id;
        }
        
        @Override
        public String toString() {
            return "Fork-" + id;
        }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork leftFork;
        private final Fork rightFork;
        
        Philosopher(int id, Fork leftFork, Fork rightFork) {
            super("Philosopher-" + id);
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            System.out.println(getName() + " is eating");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 3; i++) {
                    think();
                    
                    // Pick up left fork
                    synchronized (leftFork) {
                        System.out.println(getName() + " picked up " + leftFork);
                        
                        // Pick up right fork
                        synchronized (rightFork) {
                            System.out.println(getName() + " picked up " + rightFork);
                            eat();
                        }
                        
                        System.out.println(getName() + " put down forks");
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N]);
            philosophers[i].start();
        }
    }
}
```

**Problem:** All philosophers pick up left fork simultaneously ‚Üí DEADLOCK!

---

## üíª Example 2: Resource Ordering Solution

```java
class OrderedDiningPhilosophers {
    static class Fork {
        private final int id;
        Fork(int id) { this.id = id; }
        public String toString() { return "Fork-" + id; }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork firstFork;  // Lower ID fork
        private final Fork secondFork; // Higher ID fork
        
        Philosopher(int id, Fork fork1, Fork fork2) {
            super("Philosopher-" + id);
            this.id = id;
            
            // Always pick up lower ID fork first
            if (fork1.id < fork2.id) {
                this.firstFork = fork1;
                this.secondFork = fork2;
            } else {
                this.firstFork = fork2;
                this.secondFork = fork1;
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            System.out.println(getName() + " is eating with " + 
                              firstFork + " and " + secondFork);
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 3; i++) {
                    think();
                    
                    synchronized (firstFork) {
                        System.out.println(getName() + " picked up " + firstFork);
                        
                        synchronized (secondFork) {
                            System.out.println(getName() + " picked up " + secondFork);
                            eat();
                        }
                    }
                    
                    System.out.println(getName() + " put down forks");
                }
                System.out.println(getName() + " finished dining");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N]);
            philosophers[i].start();
        }
    }
}
```

**Solution:** Impose total ordering on resources ‚Üí No circular wait!

---

## üíª Example 3: Arbitrator Solution (Waiter)

```java
import java.util.concurrent.Semaphore;

class WaiterDiningPhilosophers {
    static class Fork {
        private final int id;
        Fork(int id) { this.id = id; }
        public String toString() { return "Fork-" + id; }
    }
    
    static class Waiter {
        private final Semaphore semaphore;
        
        Waiter(int permits) {
            this.semaphore = new Semaphore(permits);
        }
        
        void requestForks() throws InterruptedException {
            semaphore.acquire();
        }
        
        void returnForks() {
            semaphore.release();
        }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork leftFork;
        private final Fork rightFork;
        private final Waiter waiter;
        
        Philosopher(int id, Fork leftFork, Fork rightFork, Waiter waiter) {
            super("Philosopher-" + id);
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
            this.waiter = waiter;
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            System.out.println(getName() + " is eating");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 3; i++) {
                    think();
                    
                    // Ask waiter for permission
                    waiter.requestForks();
                    
                    synchronized (leftFork) {
                        System.out.println(getName() + " picked up " + leftFork);
                        
                        synchronized (rightFork) {
                            System.out.println(getName() + " picked up " + rightFork);
                            eat();
                        }
                    }
                    
                    waiter.returnForks();
                    System.out.println(getName() + " returned forks");
                }
                System.out.println(getName() + " finished");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        Waiter waiter = new Waiter(N - 1); // Allow only N-1 to eat simultaneously
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N], waiter);
            philosophers[i].start();
        }
    }
}
```

**Solution:** Limit concurrent eaters to N-1 ‚Üí At least one can always eat!

---

## üíª Example 4: Chandy-Misra Solution (Request-Based)

```java
import java.util.concurrent.*;

class ChandyMisraDiningPhilosophers {
    static class Fork {
        private final int id;
        private volatile boolean dirty = true;
        private volatile int holder; // Philosopher ID holding this fork
        private final BlockingQueue<Integer> requests = new LinkedBlockingQueue<>();
        
        Fork(int id, int initialHolder) {
            this.id = id;
            this.holder = initialHolder;
        }
        
        synchronized void request(int requesterId) throws InterruptedException {
            if (holder != requesterId) {
                requests.put(requesterId);
                if (dirty) {
                    // Transfer fork
                    dirty = false;
                    holder = requesterId;
                    System.out.println("Fork-" + id + " transferred to " + requesterId);
                }
            }
        }
        
        synchronized void clean() {
            dirty = false;
        }
        
        synchronized void makeDirty() {
            dirty = true;
        }
        
        public String toString() {
            return "Fork-" + id;
        }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork leftFork;
        private final Fork rightFork;
        
        Philosopher(int id, Fork leftFork, Fork rightFork) {
            super("Philosopher-" + id);
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 3; i++) {
                    think();
                    
                    // Request forks
                    leftFork.request(id);
                    rightFork.request(id);
                    
                    eat();
                    
                    // Make forks dirty after eating
                    leftFork.makeDirty();
                    rightFork.makeDirty();
                }
                System.out.println(getName() + " finished");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            System.out.println(getName() + " is eating");
            Thread.sleep((long) (Math.random() * 1000));
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i, i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N]);
            philosophers[i].start();
        }
    }
}
```

---

## üíª Example 5: Using ReentrantLock with tryLock

```java
import java.util.concurrent.locks.*;

class TryLockDiningPhilosophers {
    static class Fork {
        private final int id;
        private final ReentrantLock lock = new ReentrantLock();
        
        Fork(int id) {
            this.id = id;
        }
        
        boolean pickUp() {
            return lock.tryLock();
        }
        
        void putDown() {
            lock.unlock();
        }
        
        public String toString() {
            return "Fork-" + id;
        }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork leftFork;
        private final Fork rightFork;
        private int mealsEaten = 0;
        
        Philosopher(int id, Fork leftFork, Fork rightFork) {
            super("Philosopher-" + id);
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
        }
        
        @Override
        public void run() {
            try {
                while (mealsEaten < 3) {
                    think();
                    
                    if (leftFork.pickUp()) {
                        System.out.println(getName() + " picked up " + leftFork);
                        
                        if (rightFork.pickUp()) {
                            System.out.println(getName() + " picked up " + rightFork);
                            
                            eat();
                            
                            rightFork.putDown();
                            leftFork.putDown();
                            System.out.println(getName() + " put down both forks");
                        } else {
                            // Couldn't get right fork, release left
                            leftFork.putDown();
                            System.out.println(getName() + " couldn't get right fork, released left");
                        }
                    }
                    
                    Thread.sleep(100); // Small delay before retry
                }
                System.out.println(getName() + " finished (" + mealsEaten + " meals)");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            System.out.println(getName() + " is eating (meal " + (mealsEaten + 1) + ")");
            Thread.sleep((long) (Math.random() * 1000));
            mealsEaten++;
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N]);
            philosophers[i].start();
        }
    }
}
```

**Solution:** Use tryLock() and release if can't get both ‚Üí No deadlock!

---

## üíª Example 6: Fair Solution with Timestamps

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

class TimestampDiningPhilosophers {
    static class Fork {
        private final int id;
        private final Semaphore semaphore = new Semaphore(1, true); // Fair
        
        Fork(int id) {
            this.id = id;
        }
        
        void pickUp() throws InterruptedException {
            semaphore.acquire();
        }
        
        void putDown() {
            semaphore.release();
        }
        
        public String toString() {
            return "Fork-" + id;
        }
    }
    
    static class Philosopher extends Thread {
        private final int id;
        private final Fork leftFork;
        private final Fork rightFork;
        private final AtomicLong timestamp = new AtomicLong(0);
        private int mealsEaten = 0;
        
        Philosopher(int id, Fork leftFork, Fork rightFork) {
            super("Philosopher-" + id);
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
        }
        
        @Override
        public void run() {
            try {
                for (int i = 0; i < 3; i++) {
                    think();
                    
                    timestamp.set(System.nanoTime());
                    
                    leftFork.pickUp();
                    System.out.println(getName() + " picked up " + leftFork);
                    
                    rightFork.pickUp();
                    System.out.println(getName() + " picked up " + rightFork);
                    
                    eat();
                    
                    rightFork.putDown();
                    leftFork.putDown();
                    System.out.println(getName() + " put down forks");
                }
                System.out.println(getName() + " finished (" + mealsEaten + " meals)");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        private void think() throws InterruptedException {
            System.out.println(getName() + " is thinking");
            Thread.sleep((long) (Math.random() * 1000));
        }
        
        private void eat() throws InterruptedException {
            mealsEaten++;
            long waitTime = System.nanoTime() - timestamp.get();
            System.out.println(getName() + " is eating (meal " + mealsEaten + 
                              ", waited " + TimeUnit.NANOSECONDS.toMillis(waitTime) + "ms)");
            Thread.sleep((long) (Math.random() * 1000));
        }
    }
    
    public static void main(String[] args) {
        int N = 5;
        Fork[] forks = new Fork[N];
        Philosopher[] philosophers = new Philosopher[N];
        
        for (int i = 0; i < N; i++) {
            forks[i] = new Fork(i);
        }
        
        for (int i = 0; i < N; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % N]);
            philosophers[i].start();
        }
    }
}
```

---

## üìä Solutions Comparison

| Solution | Deadlock-Free | Starvation-Free | Fairness | Complexity |
|----------|---------------|-----------------|----------|------------|
| **Naive** | ‚ùå No | ‚ùå No | ‚ùå No | Low |
| **Resource Ordering** | ‚úÖ Yes | ‚ö†Ô∏è Possible | ‚ùå No | Low |
| **Waiter (Semaphore)** | ‚úÖ Yes | ‚úÖ Yes | ‚ö†Ô∏è Depends | Medium |
| **tryLock** | ‚úÖ Yes | ‚ö†Ô∏è Possible | ‚ùå No | Medium |
| **Chandy-Misra** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | High |
| **Fair Semaphore** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes | Medium |

---

## üí° Key Insights

### Deadlock Conditions (All must be present):
1. **Mutual Exclusion**: Resources can't be shared
2. **Hold and Wait**: Holding resources while waiting
3. **No Preemption**: Can't forcibly take resources
4. **Circular Wait**: Circular dependency chain

### Prevention Strategies:
- **Break circular wait**: Resource ordering
- **Limit concurrency**: Waiter pattern
- **Release and retry**: tryLock approach
- **Fairness**: Fair semaphores, timestamps

---

## üí° Best Practices

1. ‚úÖ Always acquire resources in same order
2. ‚úÖ Use timeout mechanisms (tryLock with timeout)
3. ‚úÖ Limit concurrent resource holders
4. ‚úÖ Implement fair scheduling
5. ‚úÖ Monitor for starvation
6. ‚úÖ Test with different thread counts

---

## üéØ Interview Questions

1. **What is the Dining Philosophers problem?**
2. **What causes deadlock in this problem?**
3. **Explain resource ordering solution**
4. **How does the waiter solution prevent deadlock?**
5. **What is the Chandy-Misra algorithm?**
6. **How to prevent starvation?**
7. **Implement using ReentrantLock**

---

## üìö Related Topics

- [Deadlock](../../01.%20Fundamentals/04.%20Deadlock.md)
- [ReentrantLock](../../02.%20Synchronization/03.%20ReentrantLock.md)
- [Semaphore](../../03.%20Thread%20Communication/04.%20Semaphore.md)
- [Livelock & Starvation](../../06.%20Advanced%20Concepts/02.%20Livelock%20%26%20Starvation.md)
