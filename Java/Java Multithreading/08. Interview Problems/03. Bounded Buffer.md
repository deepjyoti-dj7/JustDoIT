# ðŸ“¦ Bounded Buffer Problem (Producer-Consumer)

## ðŸ“– What is the Bounded Buffer Problem?

A classic synchronization problem where producers add items to a fixed-size buffer and consumers remove items.

**Challenges:**
- Prevent buffer overflow
- Prevent buffer underflow
- Coordinate multiple producers/consumers
- Maintain thread safety

---

## ðŸ’» Example 1: Using wait() and notify()

```java
import java.util.*;

class BoundedBuffer<T> {
    private final Queue<T> buffer = new LinkedList<>();
    private final int capacity;
    
    public BoundedBuffer(int capacity) {
        this.capacity = capacity;
    }
    
    public synchronized void produce(T item) throws InterruptedException {
        while (buffer.size() == capacity) {
            System.out.println(Thread.currentThread().getName() + " waiting (buffer full)");
            wait(); // Wait until space available
        }
        
        buffer.offer(item);
        System.out.println(Thread.currentThread().getName() + " produced: " + item + 
                          " (size: " + buffer.size() + ")");
        notifyAll(); // Notify waiting consumers
    }
    
    public synchronized T consume() throws InterruptedException {
        while (buffer.isEmpty()) {
            System.out.println(Thread.currentThread().getName() + " waiting (buffer empty)");
            wait(); // Wait until item available
        }
        
        T item = buffer.poll();
        System.out.println(Thread.currentThread().getName() + " consumed: " + item + 
                          " (size: " + buffer.size() + ")");
        notifyAll(); // Notify waiting producers
        return item;
    }
    
    public static void main(String[] args) {
        BoundedBuffer<Integer> buffer = new BoundedBuffer<>(5);
        
        // Producers
        for (int i = 1; i <= 3; i++) {
            final int producerId = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 10; j++) {
                        buffer.produce(producerId * 100 + j);
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Producer-" + i).start();
        }
        
        // Consumers
        for (int i = 1; i <= 2; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < 15; j++) {
                        buffer.consume();
                        Thread.sleep(200);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Consumer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 2: Using BlockingQueue

```java
import java.util.concurrent.*;

class BlockingQueueBuffer {
    public static void main(String[] args) {
        BlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(5);
        
        // Producers
        for (int i = 1; i <= 3; i++) {
            final int producerId = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 10; j++) {
                        int item = producerId * 100 + j;
                        buffer.put(item); // Blocks if full
                        System.out.println(Thread.currentThread().getName() + 
                            " produced: " + item + " (size: " + buffer.size() + ")");
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Producer-" + i).start();
        }
        
        // Consumers
        for (int i = 1; i <= 2; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < 15; j++) {
                        int item = buffer.take(); // Blocks if empty
                        System.out.println(Thread.currentThread().getName() + 
                            " consumed: " + item + " (size: " + buffer.size() + ")");
                        Thread.sleep(200);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Consumer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 3: Using Semaphores

```java
import java.util.*;
import java.util.concurrent.Semaphore;

class SemaphoreBuffer<T> {
    private final Queue<T> buffer = new LinkedList<>();
    private final Semaphore empty; // Counts empty slots
    private final Semaphore full;  // Counts full slots
    private final Semaphore mutex = new Semaphore(1); // Mutual exclusion
    
    public SemaphoreBuffer(int capacity) {
        this.empty = new Semaphore(capacity);
        this.full = new Semaphore(0);
    }
    
    public void produce(T item) throws InterruptedException {
        empty.acquire(); // Wait for empty slot
        mutex.acquire(); // Enter critical section
        
        buffer.offer(item);
        System.out.println(Thread.currentThread().getName() + 
                          " produced: " + item + " (size: " + buffer.size() + ")");
        
        mutex.release(); // Exit critical section
        full.release(); // Signal item available
    }
    
    public T consume() throws InterruptedException {
        full.acquire(); // Wait for available item
        mutex.acquire(); // Enter critical section
        
        T item = buffer.poll();
        System.out.println(Thread.currentThread().getName() + 
                          " consumed: " + item + " (size: " + buffer.size() + ")");
        
        mutex.release(); // Exit critical section
        empty.release(); // Signal slot available
        return item;
    }
    
    public static void main(String[] args) {
        SemaphoreBuffer<String> buffer = new SemaphoreBuffer<>(3);
        
        // Producers
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 5; j++) {
                        buffer.produce("Item-" + id + "-" + j);
                        Thread.sleep(150);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Producer-" + i).start();
        }
        
        // Consumers
        for (int i = 1; i <= 2; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < 5; j++) {
                        buffer.consume();
                        Thread.sleep(300);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Consumer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 4: Using ReentrantLock and Conditions

```java
import java.util.*;
import java.util.concurrent.locks.*;

class LockConditionBuffer<T> {
    private final Queue<T> buffer = new LinkedList<>();
    private final int capacity;
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    
    public LockConditionBuffer(int capacity) {
        this.capacity = capacity;
    }
    
    public void produce(T item) throws InterruptedException {
        lock.lock();
        try {
            while (buffer.size() == capacity) {
                System.out.println(Thread.currentThread().getName() + " waiting (full)");
                notFull.await();
            }
            
            buffer.offer(item);
            System.out.println(Thread.currentThread().getName() + 
                              " produced: " + item + " (size: " + buffer.size() + ")");
            notEmpty.signal(); // Signal one waiting consumer
        } finally {
            lock.unlock();
        }
    }
    
    public T consume() throws InterruptedException {
        lock.lock();
        try {
            while (buffer.isEmpty()) {
                System.out.println(Thread.currentThread().getName() + " waiting (empty)");
                notEmpty.await();
            }
            
            T item = buffer.poll();
            System.out.println(Thread.currentThread().getName() + 
                              " consumed: " + item + " (size: " + buffer.size() + ")");
            notFull.signal(); // Signal one waiting producer
            return item;
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        LockConditionBuffer<String> buffer = new LockConditionBuffer<>(4);
        
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 8; j++) {
                        buffer.produce("P" + id + "-" + j);
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Producer-" + i).start();
        }
        
        for (int i = 1; i <= 2; i++) {
            new Thread(() -> {
                try {
                    for (int j = 0; j < 8; j++) {
                        buffer.consume();
                        Thread.sleep(150);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Consumer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 5: Priority Producer-Consumer

```java
import java.util.concurrent.*;

class PriorityBuffer<T extends Comparable<T>> {
    private final PriorityBlockingQueue<T> buffer;
    private final int capacity;
    private final Semaphore slots;
    
    public PriorityBuffer(int capacity) {
        this.capacity = capacity;
        this.buffer = new PriorityBlockingQueue<>(capacity);
        this.slots = new Semaphore(capacity);
    }
    
    public void produce(T item) throws InterruptedException {
        slots.acquire();
        buffer.put(item);
        System.out.println(Thread.currentThread().getName() + 
                          " produced: " + item + " (size: " + buffer.size() + ")");
    }
    
    public T consume() throws InterruptedException {
        T item = buffer.take();
        slots.release();
        System.out.println(Thread.currentThread().getName() + 
                          " consumed: " + item + " (size: " + buffer.size() + ")");
        return item;
    }
    
    static class Task implements Comparable<Task> {
        final int priority;
        final String name;
        
        Task(int priority, String name) {
            this.priority = priority;
            this.name = name;
        }
        
        @Override
        public int compareTo(Task other) {
            return Integer.compare(other.priority, this.priority); // Higher priority first
        }
        
        @Override
        public String toString() {
            return name + "(P" + priority + ")";
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        PriorityBuffer<Task> buffer = new PriorityBuffer<>(5);
        
        // Producer
        new Thread(() -> {
            try {
                buffer.produce(new Task(1, "Low"));
                buffer.produce(new Task(10, "High"));
                buffer.produce(new Task(5, "Medium"));
                buffer.produce(new Task(10, "High2"));
                buffer.produce(new Task(1, "Low2"));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Producer").start();
        
        Thread.sleep(1000); // Let items be produced
        
        // Consumer
        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    buffer.consume();
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Consumer").start();
    }
}
```

---

## ðŸ’» Example 6: Multiple Buffers (Pipeline)

```java
import java.util.concurrent.*;

class Pipeline {
    static class Stage {
        private final BlockingQueue<Integer> input;
        private final BlockingQueue<Integer> output;
        private final String name;
        
        Stage(String name, BlockingQueue<Integer> input, BlockingQueue<Integer> output) {
            this.name = name;
            this.input = input;
            this.output = output;
        }
        
        void start() {
            new Thread(() -> {
                try {
                    while (true) {
                        Integer item = input.take();
                        if (item == -1) break; // Poison pill
                        
                        // Process
                        int result = item * 2;
                        System.out.println(name + " processing: " + item + " -> " + result);
                        Thread.sleep(500);
                        
                        output.put(result);
                    }
                    output.put(-1); // Pass poison pill
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, name).start();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue1 = new ArrayBlockingQueue<>(3);
        BlockingQueue<Integer> queue2 = new ArrayBlockingQueue<>(3);
        BlockingQueue<Integer> queue3 = new ArrayBlockingQueue<>(3);
        
        // Create pipeline stages
        Stage stage1 = new Stage("Stage1", queue1, queue2);
        Stage stage2 = new Stage("Stage2", queue2, queue3);
        
        stage1.start();
        stage2.start();
        
        // Producer
        new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    queue1.put(i);
                    System.out.println("Producer: " + i);
                    Thread.sleep(200);
                }
                queue1.put(-1); // Poison pill
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Producer").start();
        
        // Final consumer
        new Thread(() -> {
            try {
                while (true) {
                    Integer item = queue3.take();
                    if (item == -1) break;
                    System.out.println("Final output: " + item);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Consumer").start();
    }
}
```

---

## ðŸ“Š Implementation Comparison

| Approach | Complexity | Performance | Fairness | Use Case |
|----------|------------|-------------|----------|----------|
| **wait/notify** | High | Medium | No | Learning |
| **BlockingQueue** | Low | High | Yes | Production |
| **Semaphore** | Medium | High | Configurable | Fine control |
| **Lock/Condition** | Medium | High | Yes | Complex logic |

---

## ðŸ’¡ Best Practices

1. âœ… Use BlockingQueue for simplicity
2. âœ… Handle InterruptedException properly
3. âœ… Use poison pill for shutdown
4. âœ… Size buffer appropriately
5. âœ… Monitor queue size metrics
6. âœ… Test with different producer/consumer ratios

---

## ðŸŽ¯ Interview Questions

1. **What is the producer-consumer problem?**
2. **How to implement bounded buffer?**
3. **When to use BlockingQueue vs custom implementation?**
4. **What is a poison pill?**
5. **How to handle shutdown gracefully?**

---

## ðŸ“š Related Topics

- [BlockingQueue](../../05.%20Concurrent%20Collections/03.%20BlockingQueue.md)
- [wait/notify](../../03.%20Thread%20Communication/01.%20wait%2C%20notify%2C%20notifyAll.md)
- [Semaphore](../../03.%20Thread%20Communication/04.%20Semaphore.md)
