# ðŸ”¢ Print Odd-Even Numbers

## ðŸ“– Problem Statement

Create two threads:
- **Thread 1** prints odd numbers: 1, 3, 5, 7, 9...
- **Thread 2** prints even numbers: 2, 4, 6, 8, 10...

**Expected Output:** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15...

---

## ðŸŽ¯ Solution 1: Using wait() and notify()

```java
class OddEvenPrinter {
    private int number = 1;
    private int maxNumber;
    private final Object lock = new Object();
    
    public OddEvenPrinter(int maxNumber) {
        this.maxNumber = maxNumber;
    }
    
    public void printOdd() {
        synchronized (lock) {
            while (number <= maxNumber) {
                // Wait if current number is even
                while (number % 2 == 0 && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public void printEven() {
        synchronized (lock) {
            while (number <= maxNumber) {
                // Wait if current number is odd
                while (number % 2 != 0 && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        OddEvenPrinter printer = new OddEvenPrinter(20);
        
        Thread oddThread = new Thread(() -> printer.printOdd(), "Odd-Thread");
        Thread evenThread = new Thread(() -> printer.printEven(), "Even-Thread");
        
        oddThread.start();
        evenThread.start();
        
        oddThread.join();
        evenThread.join();
        
        System.out.println("\nCompleted!");
    }
}
```

**Output:**
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
Completed!
```

---

## ðŸŽ¯ Solution 2: Using Semaphore

```java
import java.util.concurrent.Semaphore;

class OddEvenSemaphore {
    private int number = 1;
    private int maxNumber;
    private Semaphore oddSemaphore = new Semaphore(1);
    private Semaphore evenSemaphore = new Semaphore(0);
    
    public OddEvenSemaphore(int maxNumber) {
        this.maxNumber = maxNumber;
    }
    
    public void printOdd() {
        while (number <= maxNumber) {
            try {
                oddSemaphore.acquire();
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                }
                evenSemaphore.release();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    public void printEven() {
        while (number <= maxNumber) {
            try {
                evenSemaphore.acquire();
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                }
                oddSemaphore.release();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        OddEvenSemaphore printer = new OddEvenSemaphore(20);
        
        Thread oddThread = new Thread(() -> printer.printOdd());
        Thread evenThread = new Thread(() -> printer.printEven());
        
        oddThread.start();
        evenThread.start();
        
        oddThread.join();
        evenThread.join();
        
        System.out.println("\nCompleted!");
    }
}
```

---

## ðŸŽ¯ Solution 3: Using ReentrantLock and Condition

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class OddEvenLock {
    private int number = 1;
    private int maxNumber;
    private Lock lock = new ReentrantLock();
    private Condition oddCondition = lock.newCondition();
    private Condition evenCondition = lock.newCondition();
    
    public OddEvenLock(int maxNumber) {
        this.maxNumber = maxNumber;
    }
    
    public void printOdd() {
        lock.lock();
        try {
            while (number <= maxNumber) {
                while (number % 2 == 0 && number <= maxNumber) {
                    oddCondition.await();
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    evenCondition.signal();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
    
    public void printEven() {
        lock.lock();
        try {
            while (number <= maxNumber) {
                while (number % 2 != 0 && number <= maxNumber) {
                    evenCondition.await();
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    oddCondition.signal();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        OddEvenLock printer = new OddEvenLock(20);
        
        Thread oddThread = new Thread(() -> printer.printOdd());
        Thread evenThread = new Thread(() -> printer.printEven());
        
        oddThread.start();
        evenThread.start();
        
        oddThread.join();
        evenThread.join();
        
        System.out.println("\nCompleted!");
    }
}
```

---

## ðŸŽ¯ Solution 4: Using CompletableFuture (Modern Approach)

```java
import java.util.concurrent.CompletableFuture;

class OddEvenCompletable {
    private int number = 1;
    private int maxNumber;
    
    public OddEvenCompletable(int maxNumber) {
        this.maxNumber = maxNumber;
    }
    
    public void print() {
        CompletableFuture<Void> oddFuture = CompletableFuture.runAsync(() -> {
            while (number <= maxNumber) {
                synchronized (this) {
                    if (number % 2 != 0 && number <= maxNumber) {
                        System.out.print(number + " ");
                        number++;
                        notify();
                    } else {
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            }
        });
        
        CompletableFuture<Void> evenFuture = CompletableFuture.runAsync(() -> {
            while (number <= maxNumber) {
                synchronized (this) {
                    if (number % 2 == 0 && number <= maxNumber) {
                        System.out.print(number + " ");
                        number++;
                        notify();
                    } else {
                        try {
                            wait();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            }
        });
        
        CompletableFuture.allOf(oddFuture, evenFuture).join();
    }
    
    public static void main(String[] args) {
        OddEvenCompletable printer = new OddEvenCompletable(20);
        printer.print();
        System.out.println("\nCompleted!");
    }
}
```

---

## ðŸŽ¯ Variation 1: Print in Separate Lines

```java
class OddEvenSeparateLines {
    private int number = 1;
    private int maxNumber;
    private final Object lock = new Object();
    
    public OddEvenSeparateLines(int maxNumber) {
        this.maxNumber = maxNumber;
    }
    
    public void printOdd() {
        synchronized (lock) {
            while (number <= maxNumber) {
                while (number % 2 == 0 && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.println("Odd: " + number);
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public void printEven() {
        synchronized (lock) {
            while (number <= maxNumber) {
                while (number % 2 != 0 && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.println("Even: " + number);
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        OddEvenSeparateLines printer = new OddEvenSeparateLines(10);
        
        Thread oddThread = new Thread(() -> printer.printOdd());
        Thread evenThread = new Thread(() -> printer.printEven());
        
        oddThread.start();
        evenThread.start();
        
        oddThread.join();
        evenThread.join();
    }
}
```

**Output:**
```
Odd: 1
Even: 2
Odd: 3
Even: 4
Odd: 5
Even: 6
Odd: 7
Even: 8
Odd: 9
Even: 10
```

---

## ðŸŽ¯ Variation 2: Using Modulo for N Threads

```java
class ModuloPrinter {
    private int number = 0;
    private int maxNumber;
    private int numberOfThreads;
    private final Object lock = new Object();
    
    public ModuloPrinter(int maxNumber, int numberOfThreads) {
        this.maxNumber = maxNumber;
        this.numberOfThreads = numberOfThreads;
    }
    
    public void printNumbers(int remainder) {
        synchronized (lock) {
            while (number < maxNumber) {
                while (number % numberOfThreads != remainder && number < maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number < maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    lock.notifyAll();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        int maxNumber = 20;
        int numberOfThreads = 2;
        
        ModuloPrinter printer = new ModuloPrinter(maxNumber, numberOfThreads);
        
        Thread evenThread = new Thread(() -> printer.printNumbers(0), "Even");
        Thread oddThread = new Thread(() -> printer.printNumbers(1), "Odd");
        
        evenThread.start();
        oddThread.start();
        
        evenThread.join();
        oddThread.join();
        
        System.out.println("\nCompleted!");
    }
}
```

---

## ðŸ“Š Comparison

| Approach | Complexity | Performance | Best For |
|----------|-----------|-------------|----------|
| **wait/notify** | Medium | Good | Understanding fundamentals |
| **Semaphore** | Low | Excellent | Simple coordination |
| **ReentrantLock** | High | Excellent | Complex scenarios |
| **CompletableFuture** | Medium | Good | Async operations |

---

## ðŸ’¡ Key Concepts

1. **Thread Synchronization**: Ensuring threads execute in order
2. **Condition Checking**: Using while loops for spurious wakeups
3. **Signaling**: Notifying waiting threads
4. **Mutual Exclusion**: Only one thread executes critical section

---

## ðŸŽ¯ Interview Tips

**Common Follow-ups:**
1. Extend to 3 threads (print multiples of 3)
2. Print in reverse order
3. Handle variable ranges
4. Add delay between prints
5. Make it configurable

**What Interviewers Look For:**
- Proper synchronization
- No race conditions
- Handling edge cases
- Clean code structure
- Understanding of concepts

---

## ðŸ“š Related Problems

- [Print Numbers Sequentially](01.%20Print%20Numbers%20Sequentially.md)
- [Wait Notify NotifyAll](../../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
- [Semaphore](../../03.%20Thread%20Communication/05.%20Semaphore.md)
