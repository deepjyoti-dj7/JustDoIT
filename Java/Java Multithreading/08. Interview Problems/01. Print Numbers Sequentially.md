# ðŸ”¢ Print Numbers Sequentially by Multiple Threads

## ðŸ“– Problem Statement

Create multiple threads that print numbers sequentially. For example, with 3 threads:
- Thread 1 prints: 1, 4, 7, 10, 13...
- Thread 2 prints: 2, 5, 8, 11, 14...
- Thread 3 prints: 3, 6, 9, 12, 15...

**Expected Output:** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15...

---

## ðŸŽ¯ Solution 1: Using wait() and notify()

```java
class SequentialPrinter {
    private int number = 1;
    private int maxNumber;
    private int numberOfThreads;
    private int currentThread = 0;
    private final Object lock = new Object();
    
    public SequentialPrinter(int maxNumber, int numberOfThreads) {
        this.maxNumber = maxNumber;
        this.numberOfThreads = numberOfThreads;
    }
    
    public void printNumber(int threadId) {
        synchronized (lock) {
            while (number <= maxNumber) {
                // Wait until it's this thread's turn
                while (currentThread != threadId && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                // Print the number if within range
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    
                    // Update to next thread
                    currentThread = (currentThread + 1) % numberOfThreads;
                    
                    // Notify all waiting threads
                    lock.notifyAll();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        int maxNumber = 20;
        int numberOfThreads = 3;
        
        SequentialPrinter printer = new SequentialPrinter(maxNumber, numberOfThreads);
        
        Thread[] threads = new Thread[numberOfThreads];
        
        for (int i = 0; i < numberOfThreads; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                printer.printNumber(threadId);
            }, "Thread-" + (i + 1));
        }
        
        // Start all threads
        for (Thread thread : threads) {
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("\nAll threads completed!");
    }
}
```

**Output:**
```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
All threads completed!
```

---

## ðŸŽ¯ Solution 2: Using Semaphore

```java
import java.util.concurrent.Semaphore;

class SequentialPrinterSemaphore {
    private int number = 1;
    private int maxNumber;
    private int numberOfThreads;
    private Semaphore[] semaphores;
    
    public SequentialPrinterSemaphore(int maxNumber, int numberOfThreads) {
        this.maxNumber = maxNumber;
        this.numberOfThreads = numberOfThreads;
        this.semaphores = new Semaphore[numberOfThreads];
        
        // Initialize semaphores
        for (int i = 0; i < numberOfThreads; i++) {
            semaphores[i] = new Semaphore(i == 0 ? 1 : 0);
        }
    }
    
    public void printNumber(int threadId) {
        while (true) {
            try {
                // Acquire permission for this thread
                semaphores[threadId].acquire();
                
                if (number > maxNumber) {
                    // Release next thread's semaphore to let it exit
                    semaphores[(threadId + 1) % numberOfThreads].release();
                    break;
                }
                
                // Print number
                System.out.print(number + " ");
                number++;
                
                // Release next thread's semaphore
                semaphores[(threadId + 1) % numberOfThreads].release();
                
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        int maxNumber = 20;
        int numberOfThreads = 3;
        
        SequentialPrinterSemaphore printer = new SequentialPrinterSemaphore(maxNumber, numberOfThreads);
        
        Thread[] threads = new Thread[numberOfThreads];
        
        for (int i = 0; i < numberOfThreads; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                printer.printNumber(threadId);
            }, "Thread-" + (i + 1));
        }
        
        for (Thread thread : threads) {
            thread.start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("\nAll threads completed!");
    }
}
```

---

## ðŸŽ¯ Solution 3: Using ReentrantLock and Condition

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SequentialPrinterLock {
    private int number = 1;
    private int maxNumber;
    private int numberOfThreads;
    private int currentThread = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    
    public SequentialPrinterLock(int maxNumber, int numberOfThreads) {
        this.maxNumber = maxNumber;
        this.numberOfThreads = numberOfThreads;
    }
    
    public void printNumber(int threadId) {
        lock.lock();
        try {
            while (number <= maxNumber) {
                // Wait until it's this thread's turn
                while (currentThread != threadId && number <= maxNumber) {
                    try {
                        condition.await();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " ");
                    number++;
                    currentThread = (currentThread + 1) % numberOfThreads;
                    condition.signalAll();
                }
            }
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        int maxNumber = 20;
        int numberOfThreads = 3;
        
        SequentialPrinterLock printer = new SequentialPrinterLock(maxNumber, numberOfThreads);
        
        Thread[] threads = new Thread[numberOfThreads];
        
        for (int i = 0; i < numberOfThreads; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                printer.printNumber(threadId);
            }, "Thread-" + (i + 1));
        }
        
        for (Thread thread : threads) {
            thread.start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("\nAll threads completed!");
    }
}
```

---

## ðŸŽ¯ Variation: Print in Ranges

Each thread prints a range of numbers:
- Thread 1: 1-10
- Thread 2: 11-20
- Thread 3: 21-30

```java
class RangePrinter {
    private final Object lock = new Object();
    private int currentThreadId = 0;
    
    public void printRange(int threadId, int start, int end) {
        synchronized (lock) {
            while (currentThreadId != threadId) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            
            // Print range
            System.out.print("Thread-" + (threadId + 1) + ": ");
            for (int i = start; i <= end; i++) {
                System.out.print(i + " ");
            }
            System.out.println();
            
            currentThreadId++;
            lock.notifyAll();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        RangePrinter printer = new RangePrinter();
        
        Thread t1 = new Thread(() -> printer.printRange(0, 1, 10), "Thread-1");
        Thread t2 = new Thread(() -> printer.printRange(1, 11, 20), "Thread-2");
        Thread t3 = new Thread(() -> printer.printRange(2, 21, 30), "Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
    }
}
```

**Output:**
```
Thread-1: 1 2 3 4 5 6 7 8 9 10 
Thread-2: 11 12 13 14 15 16 17 18 19 20 
Thread-3: 21 22 23 24 25 26 27 28 29 30 
```

---

## ðŸŽ¯ Variation: N Threads with Custom Order

```java
class CustomOrderPrinter {
    private int number = 1;
    private int maxNumber;
    private int currentThreadIndex = 0;
    private int[] threadOrder; // Custom order of thread execution
    private final Object lock = new Object();
    
    public CustomOrderPrinter(int maxNumber, int[] threadOrder) {
        this.maxNumber = maxNumber;
        this.threadOrder = threadOrder;
    }
    
    public void printNumber(int threadId) {
        synchronized (lock) {
            while (number <= maxNumber) {
                // Check if it's this thread's turn based on custom order
                while (threadOrder[currentThreadIndex] != threadId && number <= maxNumber) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                
                if (number <= maxNumber) {
                    System.out.print(number + " (T" + threadId + ") ");
                    number++;
                    currentThreadIndex = (currentThreadIndex + 1) % threadOrder.length;
                    lock.notifyAll();
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Custom order: Thread 2, Thread 1, Thread 3, Thread 1...
        int[] order = {2, 1, 3, 1};
        int maxNumber = 16;
        
        CustomOrderPrinter printer = new CustomOrderPrinter(maxNumber, order);
        
        Thread t1 = new Thread(() -> printer.printNumber(1), "Thread-1");
        Thread t2 = new Thread(() -> printer.printNumber(2), "Thread-2");
        Thread t3 = new Thread(() -> printer.printNumber(3), "Thread-3");
        
        t1.start();
        t2.start();
        t3.start();
        
        t1.join();
        t2.join();
        t3.join();
        
        System.out.println("\nCompleted!");
    }
}
```

---

## ðŸ“Š Comparison

| Approach | Complexity | Performance | Best For |
|----------|-----------|-------------|----------|
| **wait/notify** | Medium | Good | General purpose |
| **Semaphore** | Low | Excellent | Simple coordination |
| **ReentrantLock** | High | Excellent | Complex conditions |

---

## ðŸ’¡ Key Concepts

1. **Thread Coordination**: Ensuring threads execute in specific order
2. **Synchronization**: Preventing race conditions
3. **Signaling**: Notifying waiting threads
4. **State Management**: Tracking which thread should execute

---

## ðŸŽ¯ Interview Tips

**Questions to Expect:**
1. Implement with N threads
2. Handle variable number of threads
3. Print in reverse order
4. Handle thread failure
5. Add timeout mechanism

**Follow-up Questions:**
- How would you scale this to 100 threads?
- What if one thread fails?
- How to add priority to threads?
- Can you implement without synchronization?

---

## ðŸ“š Related Problems

- [Print Odd Even](02.%20Print%20Odd%20Even.md)
- [Wait Notify NotifyAll](../../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
- [Semaphore](../../03.%20Thread%20Communication/05.%20Semaphore.md)
