# ‚è±Ô∏è Rate Limiter

## üìñ What is a Rate Limiter?

A mechanism to control the rate of requests/operations. Essential for APIs, preventing abuse, and resource protection.

**Common Algorithms:**
- Token Bucket
- Leaky Bucket
- Fixed Window
- Sliding Window Log
- Sliding Window Counter

---

## üíª Example 1: Token Bucket Rate Limiter

```java
import java.util.concurrent.atomic.AtomicInteger;

class TokenBucketRateLimiter {
    private final int capacity;
    private final int refillRate; // tokens per second
    private final AtomicInteger tokens;
    private long lastRefillTime;
    
    public TokenBucketRateLimiter(int capacity, int refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = new AtomicInteger(capacity);
        this.lastRefillTime = System.currentTimeMillis();
    }
    
    public synchronized boolean allowRequest() {
        refill();
        
        if (tokens.get() > 0) {
            tokens.decrementAndGet();
            System.out.println(Thread.currentThread().getName() + 
                              " - Request ALLOWED (tokens: " + tokens.get() + ")");
            return true;
        }
        
        System.out.println(Thread.currentThread().getName() + 
                          " - Request DENIED (no tokens)");
        return false;
    }
    
    private void refill() {
        long now = System.currentTimeMillis();
        long timePassed = now - lastRefillTime;
        int tokensToAdd = (int) (timePassed * refillRate / 1000);
        
        if (tokensToAdd > 0) {
            tokens.set(Math.min(capacity, tokens.get() + tokensToAdd));
            lastRefillTime = now;
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(5, 2);
        
        // Burst of requests
        for (int i = 1; i <= 10; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest(), "Request-" + requestId).start();
            Thread.sleep(100);
        }
        
        Thread.sleep(3000);
        System.out.println("\n--- After 3 seconds (tokens refilled) ---");
        
        // More requests
        for (int i = 11; i <= 15; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest(), "Request-" + requestId).start();
            Thread.sleep(100);
        }
    }
}
```

---

## üíª Example 2: Sliding Window Log Rate Limiter

```java
import java.util.*;
import java.util.concurrent.ConcurrentLinkedDeque;

class SlidingWindowLogRateLimiter {
    private final int maxRequests;
    private final long windowSizeMs;
    private final Deque<Long> requestTimestamps = new ConcurrentLinkedDeque<>();
    
    public SlidingWindowLogRateLimiter(int maxRequests, long windowSizeMs) {
        this.maxRequests = maxRequests;
        this.windowSizeMs = windowSizeMs;
    }
    
    public synchronized boolean allowRequest() {
        long now = System.currentTimeMillis();
        long windowStart = now - windowSizeMs;
        
        // Remove old timestamps
        while (!requestTimestamps.isEmpty() && 
               requestTimestamps.peekFirst() <= windowStart) {
            requestTimestamps.pollFirst();
        }
        
        if (requestTimestamps.size() < maxRequests) {
            requestTimestamps.offerLast(now);
            System.out.println(Thread.currentThread().getName() + 
                              " - ALLOWED (" + requestTimestamps.size() + "/" + maxRequests + ")");
            return true;
        }
        
        System.out.println(Thread.currentThread().getName() + 
                          " - DENIED (limit reached)");
        return false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Allow 3 requests per 2 seconds
        SlidingWindowLogRateLimiter limiter = new SlidingWindowLogRateLimiter(3, 2000);
        
        for (int i = 1; i <= 10; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest(), "Request-" + requestId).start();
            Thread.sleep(400);
        }
    }
}
```

---

## üíª Example 3: Fixed Window Counter

```java
import java.util.concurrent.atomic.AtomicInteger;

class FixedWindowRateLimiter {
    private final int maxRequests;
    private final long windowSizeMs;
    private final AtomicInteger counter = new AtomicInteger(0);
    private long windowStart;
    
    public FixedWindowRateLimiter(int maxRequests, long windowSizeMs) {
        this.maxRequests = maxRequests;
        this.windowSizeMs = windowSizeMs;
        this.windowStart = System.currentTimeMillis();
    }
    
    public synchronized boolean allowRequest() {
        long now = System.currentTimeMillis();
        
        // Reset window if expired
        if (now - windowStart >= windowSizeMs) {
            counter.set(0);
            windowStart = now;
            System.out.println("--- Window reset ---");
        }
        
        if (counter.get() < maxRequests) {
            counter.incrementAndGet();
            System.out.println(Thread.currentThread().getName() + 
                              " - ALLOWED (" + counter.get() + "/" + maxRequests + ")");
            return true;
        }
        
        System.out.println(Thread.currentThread().getName() + " - DENIED");
        return false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        FixedWindowRateLimiter limiter = new FixedWindowRateLimiter(5, 2000);
        
        for (int i = 1; i <= 15; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest(), "Request-" + requestId).start();
            Thread.sleep(300);
        }
    }
}
```

---

## üíª Example 4: Leaky Bucket Rate Limiter

```java
import java.util.concurrent.*;

class LeakyBucketRateLimiter {
    private final BlockingQueue<Long> bucket;
    private final int capacity;
    private final long leakIntervalMs;
    
    public LeakyBucketRateLimiter(int capacity, long leakIntervalMs) {
        this.capacity = capacity;
        this.leakIntervalMs = leakIntervalMs;
        this.bucket = new LinkedBlockingQueue<>(capacity);
        startLeaking();
    }
    
    public boolean allowRequest() {
        boolean accepted = bucket.offer(System.currentTimeMillis());
        if (accepted) {
            System.out.println(Thread.currentThread().getName() + 
                              " - ALLOWED (queue: " + bucket.size() + "/" + capacity + ")");
        } else {
            System.out.println(Thread.currentThread().getName() + 
                              " - DENIED (bucket full)");
        }
        return accepted;
    }
    
    private void startLeaking() {
        new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(leakIntervalMs);
                    Long request = bucket.poll();
                    if (request != null) {
                        System.out.println("[LEAK] Processing request from " + 
                                          (System.currentTimeMillis() - request) + "ms ago");
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "Leaker").start();
    }
    
    public static void main(String[] args) throws InterruptedException {
        LeakyBucketRateLimiter limiter = new LeakyBucketRateLimiter(3, 1000);
        
        // Burst of requests
        for (int i = 1; i <= 10; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest(), "Request-" + requestId).start();
            Thread.sleep(200);
        }
        
        Thread.sleep(10000); // Let bucket drain
    }
}
```

---

## üíª Example 5: Per-User Rate Limiter

```java
import java.util.concurrent.*;

class PerUserRateLimiter {
    private final ConcurrentHashMap<String, UserRateLimit> userLimits = 
        new ConcurrentHashMap<>();
    private final int maxRequests;
    private final long windowMs;
    
    static class UserRateLimit {
        final int maxRequests;
        final long windowMs;
        int count = 0;
        long windowStart;
        
        UserRateLimit(int maxRequests, long windowMs) {
            this.maxRequests = maxRequests;
            this.windowMs = windowMs;
            this.windowStart = System.currentTimeMillis();
        }
        
        synchronized boolean allowRequest() {
            long now = System.currentTimeMillis();
            
            if (now - windowStart >= windowMs) {
                count = 0;
                windowStart = now;
            }
            
            if (count < maxRequests) {
                count++;
                return true;
            }
            return false;
        }
    }
    
    public PerUserRateLimiter(int maxRequests, long windowMs) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
    }
    
    public boolean allowRequest(String userId) {
        UserRateLimit limit = userLimits.computeIfAbsent(userId, 
            k -> new UserRateLimit(maxRequests, windowMs));
        
        boolean allowed = limit.allowRequest();
        System.out.println(Thread.currentThread().getName() + " [" + userId + "] - " + 
                          (allowed ? "ALLOWED" : "DENIED"));
        return allowed;
    }
    
    public static void main(String[] args) throws InterruptedException {
        PerUserRateLimiter limiter = new PerUserRateLimiter(3, 2000);
        
        // User1 makes many requests
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> limiter.allowRequest("user1"), "Req-U1-" + i).start();
            Thread.sleep(100);
        }
        
        Thread.sleep(500);
        
        // User2 makes requests (should have own quota)
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> limiter.allowRequest("user2"), "Req-U2-" + i).start();
            Thread.sleep(100);
        }
    }
}
```

---

## üíª Example 6: Distributed Rate Limiter (Redis-like)

```java
import java.util.concurrent.*;

class DistributedRateLimiter {
    // Simulates Redis using local concurrent map
    private final ConcurrentHashMap<String, AtomicInteger> redis = 
        new ConcurrentHashMap<>();
    private final int maxRequests;
    private final long windowMs;
    
    public DistributedRateLimiter(int maxRequests, long windowMs) {
        this.maxRequests = maxRequests;
        this.windowMs = windowMs;
    }
    
    public boolean allowRequest(String key) {
        long now = System.currentTimeMillis();
        long window = now / windowMs;
        String redisKey = key + ":" + window;
        
        AtomicInteger counter = redis.computeIfAbsent(redisKey, 
            k -> new AtomicInteger(0));
        
        int count = counter.incrementAndGet();
        
        // Cleanup old keys
        redis.keySet().removeIf(k -> {
            String[] parts = k.split(":");
            return Long.parseLong(parts[1]) < window - 1;
        });
        
        boolean allowed = count <= maxRequests;
        System.out.println(Thread.currentThread().getName() + " [" + key + "] - " + 
                          (allowed ? "ALLOWED" : "DENIED") + " (" + count + "/" + maxRequests + ")");
        return allowed;
    }
    
    public static void main(String[] args) throws InterruptedException {
        DistributedRateLimiter limiter = new DistributedRateLimiter(5, 1000);
        
        for (int i = 1; i <= 15; i++) {
            final int requestId = i;
            new Thread(() -> limiter.allowRequest("api_endpoint"), 
                      "Request-" + requestId).start();
            Thread.sleep(150);
        }
    }
}
```

---

## üíª Example 7: Rate Limiter with Retry

```java
import java.util.concurrent.TimeUnit;

class RateLimiterWithRetry {
    private final TokenBucketRateLimiter limiter;
    private final int maxRetries;
    private final long retryDelayMs;
    
    public RateLimiterWithRetry(int capacity, int refillRate, 
                                int maxRetries, long retryDelayMs) {
        this.limiter = new TokenBucketRateLimiter(capacity, refillRate);
        this.maxRetries = maxRetries;
        this.retryDelayMs = retryDelayMs;
    }
    
    public boolean executeWithRetry(Runnable task) {
        int attempts = 0;
        
        while (attempts <= maxRetries) {
            if (limiter.allowRequest()) {
                task.run();
                return true;
            }
            
            attempts++;
            if (attempts <= maxRetries) {
                System.out.println(Thread.currentThread().getName() + 
                                  " - Retry " + attempts + "/" + maxRetries);
                try {
                    Thread.sleep(retryDelayMs);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return false;
                }
            }
        }
        
        System.out.println(Thread.currentThread().getName() + 
                          " - FAILED after " + attempts + " attempts");
        return false;
    }
    
    public static void main(String[] args) {
        RateLimiterWithRetry limiter = new RateLimiterWithRetry(2, 1, 3, 1000);
        
        for (int i = 1; i <= 5; i++) {
            final int requestId = i;
            new Thread(() -> {
                limiter.executeWithRetry(() -> {
                    System.out.println(Thread.currentThread().getName() + 
                                      " - Executing task");
                });
            }, "Request-" + requestId).start();
        }
    }
}
```

---

## üìä Algorithm Comparison

| Algorithm | Memory | Accuracy | Burst Handling | Use Case |
|-----------|--------|----------|----------------|----------|
| **Token Bucket** | O(1) | High | ‚úÖ Yes | General purpose |
| **Leaky Bucket** | O(N) | High | ‚ö†Ô∏è Queue | Smooth traffic |
| **Fixed Window** | O(1) | Low | ‚ùå Edge cases | Simple limits |
| **Sliding Window Log** | O(N) | Very High | ‚úÖ Yes | Precise control |
| **Sliding Window Counter** | O(1) | High | ‚úÖ Yes | Production |

---

## üí° Best Practices

1. ‚úÖ Choose algorithm based on requirements
2. ‚úÖ Use distributed rate limiter for microservices
3. ‚úÖ Implement per-user and per-endpoint limits
4. ‚úÖ Return proper HTTP status (429 Too Many Requests)
5. ‚úÖ Include Retry-After header
6. ‚úÖ Monitor rate limit metrics

---

## üéØ Interview Questions

1. **What is rate limiting?**
2. **Explain token bucket algorithm**
3. **How to implement distributed rate limiter?**
4. **Fixed window vs sliding window?**
5. **How to handle burst traffic?**

---

## üìö Related Topics

- [Semaphore](../../03.%20Thread%20Communication/04.%20Semaphore.md)
- [Thread-Safe Cache](04.%20Thread-Safe%20Cache.md)
