# üîí Collections Synchronization

## üìñ What is Collections Synchronization?

Methods provided by `Collections` class to create synchronized wrappers around non-thread-safe collections.

**Key Features:**
- Wrapper-based synchronization
- Legacy approach
- Coarse-grained locking
- Simple but less efficient

---

## üíª Example 1: synchronizedList()

```java
import java.util.*;

class SynchronizedListExample {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> list = Collections.synchronizedList(new ArrayList<>());
        
        // Multiple threads adding elements
        Thread[] threads = new Thread[5];
        for (int i = 0; i < threads.length; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    list.add(threadId * 1000 + j);
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("List size: " + list.size());
        System.out.println("Expected: 5000");
    }
}
```

---

## üíª Example 2: Manual Synchronization for Iteration

```java
import java.util.*;

class ManualSynchronizationExample {
    public static void main(String[] args) {
        List<String> list = Collections.synchronizedList(new ArrayList<>());
        
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        
        // WRONG - Can throw ConcurrentModificationException
        // for (String item : list) {
        //     System.out.println(item);
        // }
        
        // CORRECT - Synchronize on the list
        synchronized (list) {
            for (String item : list) {
                System.out.println(item);
            }
        }
        
        // CORRECT - Using iterator
        synchronized (list) {
            Iterator<String> iterator = list.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        }
    }
}
```

---

## üíª Example 3: synchronizedMap()

```java
import java.util.*;

class SynchronizedMapExample {
    public static void main(String[] args) throws InterruptedException {
        Map<String, Integer> map = Collections.synchronizedMap(new HashMap<>());
        
        // Multiple threads updating map
        Thread[] threads = new Thread[3];
        for (int i = 0; i < threads.length; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    String key = "key-" + (threadId * 100 + j);
                    map.put(key, j);
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Map size: " + map.size());
        
        // Iterate safely
        synchronized (map) {
            for (Map.Entry<String, Integer> entry : map.entrySet()) {
                if (entry.getValue() < 5) {
                    System.out.println(entry.getKey() + " = " + entry.getValue());
                }
            }
        }
    }
}
```

---

## üíª Example 4: synchronizedSet()

```java
import java.util.*;

class SynchronizedSetExample {
    public static void main(String[] args) throws InterruptedException {
        Set<Integer> set = Collections.synchronizedSet(new HashSet<>());
        
        // Concurrent additions
        Thread adder1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                set.add(i);
            }
        });
        
        Thread adder2 = new Thread(() -> {
            for (int i = 500; i < 1500; i++) {
                set.add(i);
            }
        });
        
        adder1.start();
        adder2.start();
        
        adder1.join();
        adder2.join();
        
        System.out.println("Set size: " + set.size());
        
        // Check specific elements
        System.out.println("Contains 500? " + set.contains(500));
        System.out.println("Contains 1000? " + set.contains(1000));
    }
}
```

---

## üíª Example 5: Comparison with Concurrent Collections

```java
import java.util.*;
import java.util.concurrent.*;

class ComparisonExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Synchronized Map ===");
        testMap(Collections.synchronizedMap(new HashMap<>()), "SynchronizedMap");
        
        System.out.println("\n=== ConcurrentHashMap ===");
        testMap(new ConcurrentHashMap<>(), "ConcurrentHashMap");
    }
    
    private static void testMap(Map<Integer, Integer> map, String type) 
            throws InterruptedException {
        long start = System.currentTimeMillis();
        
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    map.put(threadId * 10000 + j, j);
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        long duration = System.currentTimeMillis() - start;
        System.out.println(type + " - Size: " + map.size() + 
                          ", Time: " + duration + "ms");
    }
}
```

---

## üíª Example 6: Thread-Safe Queue

```java
import java.util.*;

class SynchronizedQueueExample {
    public static void main(String[] args) throws InterruptedException {
        Queue<String> queue = new LinkedList<>();
        Queue<String> syncQueue = Collections.synchronizedCollection(queue, 
                                                                     new LinkedList<>().getClass());
        
        // Producer
        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                syncQueue.offer("Item-" + i);
                System.out.println("Produced: Item-" + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        // Consumer
        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                String item = syncQueue.poll();
                while (item == null) {
                    item = syncQueue.poll();
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
                System.out.println("Consumed: " + item);
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
    }
}
```

---

## üíª Example 7: Read-Write Scenario

```java
import java.util.*;

class ReadWriteScenario {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> list = Collections.synchronizedList(new ArrayList<>());
        
        // Initialize with data
        for (int i = 0; i < 100; i++) {
            list.add(i);
        }
        
        // Multiple readers
        Thread[] readers = new Thread[5];
        for (int i = 0; i < readers.length; i++) {
            final int readerId = i;
            readers[i] = new Thread(() -> {
                for (int j = 0; j < 10; j++) {
                    synchronized (list) {
                        int sum = list.stream().mapToInt(Integer::intValue).sum();
                        System.out.println("Reader-" + readerId + " sum: " + sum);
                    }
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        
        // Single writer
        Thread writer = new Thread(() -> {
            for (int i = 0; i < 20; i++) {
                list.add(100 + i);
                System.out.println("Writer added: " + (100 + i));
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        for (Thread reader : readers) {
            reader.start();
        }
        writer.start();
        
        for (Thread reader : readers) {
            reader.join();
        }
        writer.join();
        
        System.out.println("\nFinal list size: " + list.size());
    }
}
```

---

## üìä Synchronized Collections vs Concurrent Collections

| Feature | Synchronized Collections | Concurrent Collections |
|---------|-------------------------|----------------------|
| **Locking** | Entire collection | Fine-grained |
| **Performance** | Lower | Higher |
| **Scalability** | Poor | Good |
| **Iteration** | Manual sync needed | Weakly consistent |
| **Null Support** | ‚úÖ Yes | ‚ùå No (most) |
| **Example** | `synchronizedList()` | `ConcurrentHashMap` |

---

## üìä Available Synchronized Wrappers

| Method | Returns | Thread-Safe? |
|--------|---------|-------------|
| `synchronizedList()` | List | ‚úÖ Yes |
| `synchronizedSet()` | Set | ‚úÖ Yes |
| `synchronizedMap()` | Map | ‚úÖ Yes |
| `synchronizedCollection()` | Collection | ‚úÖ Yes |
| `synchronizedSortedSet()` | SortedSet | ‚úÖ Yes |
| `synchronizedSortedMap()` | SortedMap | ‚úÖ Yes |

---

## üí° Best Practices

1. ‚úÖ Manually synchronize on collection for iteration
2. ‚úÖ Prefer concurrent collections for better performance
3. ‚úÖ Use for legacy code compatibility
4. ‚úÖ Be aware of coarse-grained locking overhead
5. ‚úÖ Synchronize compound operations

---

## ‚ö†Ô∏è Common Pitfalls

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());

// ‚ùå WRONG - Not thread-safe
for (String item : list) {
    System.out.println(item);
}

// ‚úÖ CORRECT
synchronized (list) {
    for (String item : list) {
        System.out.println(item);
    }
}

// ‚ùå WRONG - Compound operation not atomic
if (!list.contains("item")) {
    list.add("item");
}

// ‚úÖ CORRECT
synchronized (list) {
    if (!list.contains("item")) {
        list.add("item");
    }
}
```

---

## üéØ Interview Questions

1. **What are synchronized collections?**
2. **How do you create a synchronized list?**
3. **Why must you synchronize manually during iteration?**
4. **What is the difference between synchronized collections and concurrent collections?**
5. **What are the performance implications of synchronized collections?**
6. **When would you use synchronized collections?**

---

## üìö Next Topics

- [ConcurrentHashMap](01.%20ConcurrentHashMap.md)
- [ThreadLocal](../06.%20Advanced%20Concepts/01.%20ThreadLocal.md)
