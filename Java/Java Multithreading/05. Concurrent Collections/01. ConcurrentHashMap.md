# ğŸ—ºï¸ ConcurrentHashMap

## ğŸ“– What is ConcurrentHashMap?

A thread-safe implementation of `HashMap` that allows concurrent reads and writes without locking the entire map.

**Key Features:**
- Thread-safe without synchronizing entire map
- Better concurrency than Hashtable
- Null keys/values not allowed
- Segment-based locking (Java 7) / CAS operations (Java 8+)

---

## ğŸ’» Example 1: Basic Operations

```java
import java.util.concurrent.ConcurrentHashMap;

class BasicConcurrentHashMapExample {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        
        // Put operations
        map.put("Apple", 100);
        map.put("Banana", 200);
        map.put("Orange", 150);
        
        System.out.println("Initial map: " + map);
        
        // Get operation
        System.out.println("Apple count: " + map.get("Apple"));
        
        // putIfAbsent - only adds if key doesn't exist
        map.putIfAbsent("Apple", 300); // Won't update
        map.putIfAbsent("Mango", 250);  // Will add
        
        System.out.println("After putIfAbsent: " + map);
        
        // remove with value check
        map.remove("Banana", 200); // Removes only if value matches
        
        System.out.println("After remove: " + map);
        
        // replace
        map.replace("Orange", 150, 175);
        
        System.out.println("After replace: " + map);
    }
}
```

---

## ğŸ’» Example 2: Concurrent Updates

```java
import java.util.concurrent.*;

class ConcurrentUpdatesExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentHashMap<String, Integer> counter = new ConcurrentHashMap<>();
        counter.put("count", 0);
        
        // Create 10 threads incrementing the counter
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    // Atomic increment
                    counter.compute("count", (key, value) -> value + 1);
                }
            });
            threads[i].start();
        }
        
        // Wait for all threads
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Final count: " + counter.get("count"));
        System.out.println("Expected: 10000");
    }
}
```

---

## ğŸ’» Example 3: compute(), computeIfAbsent(), computeIfPresent()

```java
import java.util.concurrent.ConcurrentHashMap;

class ComputeMethodsExample {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        map.put("A", 10);
        map.put("B", 20);
        
        System.out.println("Initial: " + map);
        
        // compute - always computes new value
        map.compute("A", (key, value) -> value * 2);
        System.out.println("After compute A: " + map);
        
        // computeIfAbsent - computes only if absent
        map.computeIfAbsent("C", key -> 30);
        map.computeIfAbsent("A", key -> 100); // Won't update
        System.out.println("After computeIfAbsent: " + map);
        
        // computeIfPresent - computes only if present
        map.computeIfPresent("B", (key, value) -> value + 5);
        map.computeIfPresent("D", (key, value) -> 40); // Won't add
        System.out.println("After computeIfPresent: " + map);
        
        // merge - combines existing value with new value
        map.merge("A", 5, (oldValue, newValue) -> oldValue + newValue);
        map.merge("E", 50, (oldValue, newValue) -> oldValue + newValue); // Adds 50
        System.out.println("After merge: " + map);
    }
}
```

---

## ğŸ’» Example 4: Word Frequency Counter

```java
import java.util.concurrent.*;

class WordFrequencyCounter {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentHashMap<String, Integer> wordCount = new ConcurrentHashMap<>();
        
        String[] documents = {
            "hello world hello",
            "world of java",
            "hello java world",
            "java is great"
        };
        
        // Process documents concurrently
        ExecutorService executor = Executors.newFixedThreadPool(4);
        CountDownLatch latch = new CountDownLatch(documents.length);
        
        for (String document : documents) {
            executor.submit(() -> {
                try {
                    String[] words = document.split(" ");
                    for (String word : words) {
                        wordCount.merge(word, 1, Integer::sum);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }
        
        latch.await();
        executor.shutdown();
        
        System.out.println("Word frequencies:");
        wordCount.forEach((word, count) -> 
            System.out.println(word + ": " + count));
    }
}
```

---

## ğŸ’» Example 5: Cache Implementation

```java
import java.util.concurrent.*;

class SimpleCache<K, V> {
    private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();
    private final int maxSize;
    
    public SimpleCache(int maxSize) {
        this.maxSize = maxSize;
    }
    
    public V get(K key) {
        return cache.get(key);
    }
    
    public void put(K key, V value) {
        if (cache.size() >= maxSize && !cache.containsKey(key)) {
            // Remove oldest entry (simplified eviction)
            K firstKey = cache.keys().nextElement();
            cache.remove(firstKey);
        }
        cache.put(key, value);
    }
    
    public V computeIfAbsent(K key, java.util.function.Function<K, V> mappingFunction) {
        return cache.computeIfAbsent(key, mappingFunction);
    }
    
    public int size() {
        return cache.size();
    }
    
    public static void main(String[] args) {
        SimpleCache<String, String> cache = new SimpleCache<>(3);
        
        cache.put("key1", "value1");
        cache.put("key2", "value2");
        cache.put("key3", "value3");
        
        System.out.println("Cache size: " + cache.size());
        
        cache.put("key4", "value4"); // Will evict one entry
        
        System.out.println("After adding key4, size: " + cache.size());
    }
}
```

---

## ğŸ’» Example 6: Parallel Stream with ConcurrentHashMap

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.IntStream;

class ParallelStreamExample {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, Integer> map = new ConcurrentHashMap<>();
        
        // Parallel stream populating map
        IntStream.range(1, 1001)
            .parallel()
            .forEach(i -> map.put(i, i * i));
        
        System.out.println("Map size: " + map.size());
        
        // Parallel reduction
        long sum = map.values()
            .parallelStream()
            .mapToLong(Integer::longValue)
            .sum();
        
        System.out.println("Sum of all values: " + sum);
        
        // Parallel filtering
        long evenCount = map.keySet()
            .parallelStream()
            .filter(key -> key % 2 == 0)
            .count();
        
        System.out.println("Even keys count: " + evenCount);
    }
}
```

---

## ğŸ’» Example 7: forEach and search operations

```java
import java.util.concurrent.ConcurrentHashMap;

class ForEachSearchExample {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        map.put("A", 10);
        map.put("B", 20);
        map.put("C", 30);
        map.put("D", 40);
        
        // forEach
        System.out.println("=== forEach ===");
        map.forEach((key, value) -> 
            System.out.println(key + " = " + value));
        
        // forEachKey
        System.out.println("\n=== forEachKey ===");
        map.forEachKey(1, key -> System.out.println("Key: " + key));
        
        // forEachValue
        System.out.println("\n=== forEachValue ===");
        map.forEachValue(1, value -> System.out.println("Value: " + value));
        
        // search - returns first non-null result
        System.out.println("\n=== search ===");
        String result = map.search(1, (key, value) -> 
            value > 25 ? key : null);
        System.out.println("First key with value > 25: " + result);
        
        // reduce
        System.out.println("\n=== reduce ===");
        Integer sum = map.reduce(1, 
            (key, value) -> value,
            (v1, v2) -> v1 + v2);
        System.out.println("Sum of all values: " + sum);
    }
}
```

---

## ğŸ“Š ConcurrentHashMap vs Hashtable vs HashMap

| Feature | ConcurrentHashMap | Hashtable | HashMap |
|---------|-------------------|-----------|---------|
| **Thread-Safe** | âœ… Yes | âœ… Yes | âŒ No |
| **Null Key** | âŒ No | âŒ No | âœ… Yes |
| **Null Value** | âŒ No | âŒ No | âœ… Yes |
| **Performance** | High | Low | Highest |
| **Locking** | Segment/CAS | Entire map | None |

---

## ğŸ’¡ Best Practices

1. âœ… Use for concurrent access scenarios
2. âœ… Prefer atomic methods over `get` + `put` combinations
3. âœ… Use `compute` methods for atomic updates
4. âœ… Avoid `null` keys and values
5. âœ… Use appropriate initial capacity
6. âœ… Consider `merge()` for combining values

---

## ğŸ¯ Interview Questions

1. **What is ConcurrentHashMap?**
2. **How does ConcurrentHashMap achieve thread-safety?**
3. **What is the difference between ConcurrentHashMap and Hashtable?**
4. **Can ConcurrentHashMap contain null keys or values?**
5. **What is segment-based locking?**
6. **What are the atomic operations in ConcurrentHashMap?**

---

## ğŸ“š Next Topics

- [CopyOnWriteArrayList](02.%20CopyOnWriteArrayList.md)
- [BlockingQueue](03.%20BlockingQueue.md)
