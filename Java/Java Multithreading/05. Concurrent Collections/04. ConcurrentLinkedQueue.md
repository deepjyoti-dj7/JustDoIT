# ðŸ”— ConcurrentLinkedQueue

## ðŸ“– What is ConcurrentLinkedQueue?

A thread-safe, non-blocking, unbounded FIFO queue based on linked nodes. Uses CAS (Compare-And-Swap) operations for lock-free thread safety.

**Key Features:**
- Non-blocking (lock-free)
- Unbounded capacity
- FIFO ordering
- Fast for concurrent access
- No null elements allowed

---

## ðŸ’» Example 1: Basic Operations

```java
import java.util.concurrent.ConcurrentLinkedQueue;

class BasicConcurrentLinkedQueueExample {
    public static void main(String[] args) {
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        
        // Add elements
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        
        System.out.println("Queue: " + queue);
        System.out.println("Size: " + queue.size());
        
        // Peek (doesn't remove)
        System.out.println("Peek: " + queue.peek());
        System.out.println("Size after peek: " + queue.size());
        
        // Poll (removes and returns)
        System.out.println("Poll: " + queue.poll());
        System.out.println("Queue after poll: " + queue);
        
        // Check if empty
        System.out.println("Is empty? " + queue.isEmpty());
    }
}
```

---

## ðŸ’» Example 2: Multiple Producer-Consumer

```java
import java.util.concurrent.*;

class MultiProducerConsumerExample {
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>();
        CountDownLatch latch = new CountDownLatch(5);
        
        // 3 Producers
        for (int i = 1; i <= 3; i++) {
            final int producerId = i;
            new Thread(() -> {
                for (int j = 1; j <= 10; j++) {
                    int item = producerId * 100 + j;
                    queue.offer(item);
                    System.out.println("Producer-" + producerId + " added: " + item);
                }
                latch.countDown();
            }).start();
        }
        
        // 2 Consumers
        for (int i = 1; i <= 2; i++) {
            final int consumerId = i;
            new Thread(() -> {
                try {
                    Thread.sleep(500); // Let producers add items
                    for (int j = 0; j < 15; j++) {
                        Integer item = queue.poll();
                        if (item != null) {
                            System.out.println("Consumer-" + consumerId + " consumed: " + item);
                        }
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
        System.out.println("\nRemaining in queue: " + queue.size());
    }
}
```

---

## ðŸ’» Example 3: Task Queue for Thread Pool

```java
import java.util.concurrent.*;

class TaskQueueExample {
    static class Task {
        private String name;
        private int duration;
        
        public Task(String name, int duration) {
            this.name = name;
            this.duration = duration;
        }
        
        public void execute() {
            System.out.println(Thread.currentThread().getName() + 
                             " executing " + name);
            try {
                Thread.sleep(duration);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            System.out.println(Thread.currentThread().getName() + 
                             " completed " + name);
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        ConcurrentLinkedQueue<Task> taskQueue = new ConcurrentLinkedQueue<>();
        
        // Add tasks
        taskQueue.offer(new Task("Task-1", 1000));
        taskQueue.offer(new Task("Task-2", 500));
        taskQueue.offer(new Task("Task-3", 1500));
        taskQueue.offer(new Task("Task-4", 800));
        taskQueue.offer(new Task("Task-5", 1200));
        
        // Worker threads
        Thread[] workers = new Thread[2];
        for (int i = 0; i < workers.length; i++) {
            workers[i] = new Thread(() -> {
                while (true) {
                    Task task = taskQueue.poll();
                    if (task == null) break;
                    task.execute();
                }
            }, "Worker-" + (i + 1));
            workers[i].start();
        }
        
        for (Thread worker : workers) {
            worker.join();
        }
        
        System.out.println("All tasks completed");
    }
}
```

---

## ðŸ’» Example 4: Log Buffer

```java
import java.util.concurrent.*;
import java.time.LocalTime;

class LogBuffer {
    private ConcurrentLinkedQueue<String> logQueue = new ConcurrentLinkedQueue<>();
    private volatile boolean running = true;
    
    public void log(String message) {
        String logEntry = LocalTime.now() + " - " + message;
        logQueue.offer(logEntry);
    }
    
    public void startLogWriter() {
        new Thread(() -> {
            while (running || !logQueue.isEmpty()) {
                String log = logQueue.poll();
                if (log != null) {
                    System.out.println("[LOG] " + log);
                } else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
            System.out.println("[LOG] Writer stopped");
        }, "LogWriter").start();
    }
    
    public void stop() {
        running = false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        LogBuffer buffer = new LogBuffer();
        buffer.startLogWriter();
        
        // Multiple threads logging
        for (int i = 1; i <= 5; i++) {
            final int threadId = i;
            new Thread(() -> {
                for (int j = 1; j <= 3; j++) {
                    buffer.log("Thread-" + threadId + " message-" + j);
                    try {
                        Thread.sleep((long)(Math.random() * 500));
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }).start();
        }
        
        Thread.sleep(3000);
        buffer.stop();
    }
}
```

---

## ðŸ’» Example 5: removeIf() - Conditional Removal

```java
import java.util.concurrent.ConcurrentLinkedQueue;

class ConditionalRemovalExample {
    public static void main(String[] args) {
        ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>();
        
        // Add numbers 1 to 10
        for (int i = 1; i <= 10; i++) {
            queue.offer(i);
        }
        
        System.out.println("Original queue: " + queue);
        
        // Remove all even numbers
        queue.removeIf(n -> n % 2 == 0);
        
        System.out.println("After removing evens: " + queue);
        
        // Remove numbers greater than 5
        queue.removeIf(n -> n > 5);
        
        System.out.println("After removing > 5: " + queue);
    }
}
```

---

## ðŸ’» Example 6: Iteration While Modifying

```java
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.Iterator;

class IterationExample {
    public static void main(String[] args) {
        ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
        queue.offer("A");
        queue.offer("B");
        queue.offer("C");
        queue.offer("D");
        
        System.out.println("Original: " + queue);
        
        // Iterate and modify simultaneously
        Iterator<String> iterator = queue.iterator();
        
        new Thread(() -> {
            try {
                Thread.sleep(100);
                queue.offer("E");
                queue.offer("F");
                System.out.println("Added E and F");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        while (iterator.hasNext()) {
            String item = iterator.next();
            System.out.println("Iterator: " + item);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        System.out.println("\nFinal queue: " + queue);
    }
}
```

---

## ðŸ’» Example 7: Performance Comparison

```java
import java.util.concurrent.*;
import java.util.Queue;
import java.util.LinkedList;

class PerformanceComparison {
    public static void main(String[] args) throws InterruptedException {
        int operations = 100000;
        
        // Test ConcurrentLinkedQueue
        System.out.println("=== ConcurrentLinkedQueue ===");
        testQueue(new ConcurrentLinkedQueue<>(), operations);
        
        // Test synchronized LinkedList
        System.out.println("\n=== Synchronized LinkedList ===");
        Queue<Integer> syncQueue = new LinkedList<>();
        testQueue(syncQueue, operations);
    }
    
    private static void testQueue(Queue<Integer> queue, int operations) 
            throws InterruptedException {
        long start = System.currentTimeMillis();
        
        Thread producer = new Thread(() -> {
            for (int i = 0; i < operations; i++) {
                if (queue instanceof ConcurrentLinkedQueue) {
                    queue.offer(i);
                } else {
                    synchronized (queue) {
                        queue.offer(i);
                    }
                }
            }
        });
        
        Thread consumer = new Thread(() -> {
            int count = 0;
            while (count < operations) {
                Integer item;
                if (queue instanceof ConcurrentLinkedQueue) {
                    item = queue.poll();
                } else {
                    synchronized (queue) {
                        item = queue.poll();
                    }
                }
                if (item != null) count++;
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("Time taken: " + duration + "ms");
    }
}
```

---

## ðŸ“Š ConcurrentLinkedQueue vs BlockingQueue

| Feature | ConcurrentLinkedQueue | BlockingQueue |
|---------|----------------------|---------------|
| **Blocking** | âŒ No | âœ… Yes |
| **Capacity** | Unbounded | Bounded/Unbounded |
| **Performance** | Very fast | Moderate |
| **Use Case** | Non-blocking needs | Producer-Consumer |
| **Waiting** | Busy-wait | Thread blocking |

---

## ðŸ“Š Key Methods

| Method | Description | Blocking? |
|--------|-------------|-----------|
| `offer(e)` | Add element | âŒ No |
| `poll()` | Remove and return head | âŒ No |
| `peek()` | View head without removal | âŒ No |
| `isEmpty()` | Check if empty | âŒ No |
| `size()` | Get size (O(n)) | âŒ No |

---

## ðŸ’¡ Best Practices

1. âœ… Use for non-blocking concurrent access
2. âœ… Ideal for high-throughput scenarios
3. âœ… Avoid `size()` in hot paths (O(n) operation)
4. âœ… Handle null returns from `poll()`
5. âœ… Use when blocking is not needed
6. âœ… Good for work-stealing algorithms

---

## ðŸŽ¯ Interview Questions

1. **What is ConcurrentLinkedQueue?**
2. **How does it achieve thread-safety without locks?**
3. **What is CAS (Compare-And-Swap)?**
4. **When would you use ConcurrentLinkedQueue over BlockingQueue?**
5. **Why is size() operation expensive?**
6. **Can it contain null elements?**

---

## ðŸ“š Next Topics

- [Collections Synchronization](05.%20Collections%20Synchronization.md)
- [BlockingQueue](03.%20BlockingQueue.md)
