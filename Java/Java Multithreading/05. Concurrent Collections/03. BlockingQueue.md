# ðŸš¦ BlockingQueue

## ðŸ“– What is BlockingQueue?

A queue that supports operations that wait for the queue to become non-empty when retrieving and wait for space to become available when storing.

**Key Features:**
- Thread-safe queue operations
- Blocking put and take operations
- Producer-Consumer pattern support
- Various implementations available

---

## ðŸ’» Example 1: ArrayBlockingQueue - Fixed Capacity

```java
import java.util.concurrent.*;

class ArrayBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(3);
        
        // Producer
        new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("Producing: " + i);
                    queue.put(i); // Blocks if queue is full
                    System.out.println("Produced: " + i + ", Queue size: " + queue.size());
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer").start();
        
        // Consumer
        Thread.sleep(2000); // Start consumer after delay
        
        new Thread(() -> {
            try {
                for (int i = 1; i <= 5; i++) {
                    Integer item = queue.take(); // Blocks if queue is empty
                    System.out.println("Consumed: " + item);
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer").start();
    }
}
```

---

## ðŸ’» Example 2: LinkedBlockingQueue - Unbounded/Bounded

```java
import java.util.concurrent.*;

class LinkedBlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // Can be bounded or unbounded
        BlockingQueue<String> queue = new LinkedBlockingQueue<>(5);
        
        // Multiple producers
        for (int i = 1; i <= 3; i++) {
            final int producerId = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 3; j++) {
                        String item = "P" + producerId + "-Item" + j;
                        queue.put(item);
                        System.out.println("Producer-" + producerId + " produced: " + item);
                        Thread.sleep((long)(Math.random() * 1000));
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
        // Single consumer
        new Thread(() -> {
            try {
                for (int i = 1; i <= 9; i++) {
                    String item = queue.take();
                    System.out.println("Consumer consumed: " + item);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

---

## ðŸ’» Example 3: PriorityBlockingQueue - Priority-Based

```java
import java.util.concurrent.*;

class PriorityBlockingQueueExample {
    static class Task implements Comparable<Task> {
        String name;
        int priority;
        
        public Task(String name, int priority) {
            this.name = name;
            this.priority = priority;
        }
        
        @Override
        public int compareTo(Task other) {
            return Integer.compare(other.priority, this.priority); // Higher priority first
        }
        
        @Override
        public String toString() {
            return name + "(P" + priority + ")";
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<Task> queue = new PriorityBlockingQueue<>();
        
        // Add tasks with different priorities
        queue.put(new Task("Task-Low", 1));
        queue.put(new Task("Task-High", 10));
        queue.put(new Task("Task-Medium", 5));
        queue.put(new Task("Task-Critical", 20));
        queue.put(new Task("Task-Normal", 3));
        
        System.out.println("Processing tasks by priority:");
        while (!queue.isEmpty()) {
            Task task = queue.take();
            System.out.println("Processing: " + task);
            Thread.sleep(500);
        }
    }
}
```

---

## ðŸ’» Example 4: SynchronousQueue - Zero Capacity

```java
import java.util.concurrent.*;

class SynchronousQueueExample {
    public static void main(String[] args) {
        // Zero capacity - direct handoff
        BlockingQueue<String> queue = new SynchronousQueue<>();
        
        // Producer
        new Thread(() -> {
            String[] items = {"Item-1", "Item-2", "Item-3"};
            try {
                for (String item : items) {
                    System.out.println("Producer offering: " + item);
                    queue.put(item); // Blocks until consumer takes
                    System.out.println("Producer: " + item + " handed off");
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer").start();
        
        // Consumer
        new Thread(() -> {
            try {
                for (int i = 0; i < 3; i++) {
                    Thread.sleep(2000); // Slow consumer
                    String item = queue.take();
                    System.out.println("Consumer received: " + item);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer").start();
    }
}
```

---

## ðŸ’» Example 5: offer() and poll() with Timeout

```java
import java.util.concurrent.*;

class TimeoutOperationsExample {
    public static void main(String[] args) {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(2);
        
        try {
            // offer with timeout
            System.out.println("offer Item-1: " + queue.offer("Item-1", 1, TimeUnit.SECONDS));
            System.out.println("offer Item-2: " + queue.offer("Item-2", 1, TimeUnit.SECONDS));
            System.out.println("offer Item-3: " + queue.offer("Item-3", 1, TimeUnit.SECONDS)); // Will timeout
            
            System.out.println("\nQueue: " + queue);
            
            // poll with timeout
            System.out.println("\npoll: " + queue.poll(1, TimeUnit.SECONDS));
            System.out.println("poll: " + queue.poll(1, TimeUnit.SECONDS));
            System.out.println("poll: " + queue.poll(1, TimeUnit.SECONDS)); // Will timeout
            
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

## ðŸ’» Example 6: DelayQueue - Delayed Elements

```java
import java.util.concurrent.*;

class DelayedTask implements Delayed {
    private String name;
    private long delayTime;
    
    public DelayedTask(String name, long delayInMillis) {
        this.name = name;
        this.delayTime = System.currentTimeMillis() + delayInMillis;
    }
    
    @Override
    public long getDelay(TimeUnit unit) {
        long diff = delayTime - System.currentTimeMillis();
        return unit.convert(diff, TimeUnit.MILLISECONDS);
    }
    
    @Override
    public int compareTo(Delayed other) {
        return Long.compare(this.delayTime, ((DelayedTask) other).delayTime);
    }
    
    @Override
    public String toString() {
        return name;
    }
    
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<DelayedTask> queue = new DelayQueue<>();
        
        // Add tasks with different delays
        queue.put(new DelayedTask("Task-3sec", 3000));
        queue.put(new DelayedTask("Task-1sec", 1000));
        queue.put(new DelayedTask("Task-5sec", 5000));
        queue.put(new DelayedTask("Task-2sec", 2000));
        
        System.out.println("Tasks will execute after their delay:");
        
        while (!queue.isEmpty()) {
            DelayedTask task = queue.take(); // Blocks until delay expires
            System.out.println(System.currentTimeMillis() + ": Executing " + task);
        }
    }
}
```

---

## ðŸ’» Example 7: Producer-Consumer with Multiple Threads

```java
import java.util.concurrent.*;

class MultiThreadedProducerConsumer {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(10);
        
        // 3 Producers
        for (int i = 1; i <= 3; i++) {
            final int producerId = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 5; j++) {
                        int item = producerId * 100 + j;
                        queue.put(item);
                        System.out.println("Producer-" + producerId + " produced: " + item + 
                                         " | Queue size: " + queue.size());
                        Thread.sleep((long)(Math.random() * 1000));
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Producer-" + i).start();
        }
        
        // 2 Consumers
        for (int i = 1; i <= 2; i++) {
            final int consumerId = i;
            new Thread(() -> {
                try {
                    for (int j = 1; j <= 7; j++) {
                        Integer item = queue.take();
                        System.out.println("Consumer-" + consumerId + " consumed: " + item);
                        Thread.sleep((long)(Math.random() * 1500));
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }, "Consumer-" + i).start();
        }
    }
}
```

---

## ðŸ“Š BlockingQueue Implementations

| Type | Capacity | Ordering | Use Case |
|------|----------|----------|----------|
| **ArrayBlockingQueue** | Bounded | FIFO | Fixed buffer |
| **LinkedBlockingQueue** | Bounded/Unbounded | FIFO | General purpose |
| **PriorityBlockingQueue** | Unbounded | Priority | Priority tasks |
| **SynchronousQueue** | 0 | Direct handoff | Thread coordination |
| **DelayQueue** | Unbounded | Delay expiry | Scheduled tasks |

---

## ðŸ“Š BlockingQueue Methods

| Method | Throws Exception | Returns Special | Blocks | Times Out |
|--------|-----------------|-----------------|--------|-----------|
| **Insert** | `add(e)` | `offer(e)` | `put(e)` | `offer(e, time, unit)` |
| **Remove** | `remove()` | `poll()` | `take()` | `poll(time, unit)` |
| **Examine** | `element()` | `peek()` | - | - |

---

## ðŸ’¡ Best Practices

1. âœ… Use `put()` and `take()` for blocking behavior
2. âœ… Use `offer()` and `poll()` with timeout for non-blocking
3. âœ… Choose appropriate implementation based on needs
4. âœ… Handle `InterruptedException` properly
5. âœ… Consider capacity for bounded queues
6. âœ… Use for Producer-Consumer patterns

---

## ðŸŽ¯ Interview Questions

1. **What is BlockingQueue?**
2. **What is the difference between put() and offer()?**
3. **What are the different implementations of BlockingQueue?**
4. **When would you use SynchronousQueue?**
5. **What is the difference between ArrayBlockingQueue and LinkedBlockingQueue?**
6. **How does PriorityBlockingQueue work?**

---

## ðŸ“š Next Topics

- [ConcurrentLinkedQueue](04.%20ConcurrentLinkedQueue.md)
- [Producer Consumer Pattern](../07.%20Design%20Patterns/01.%20Producer%20Consumer.md)
