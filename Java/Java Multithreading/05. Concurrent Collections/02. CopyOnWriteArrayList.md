# üìù CopyOnWriteArrayList

## üìñ What is CopyOnWriteArrayList?

A thread-safe variant of `ArrayList` where all mutative operations (add, set, remove) are implemented by making a fresh copy of the underlying array.

**Key Features:**
- Thread-safe without explicit synchronization
- Best for read-heavy, write-rare scenarios
- Iterator never throws ConcurrentModificationException
- No locking during iteration

---

## üíª Example 1: Basic Operations

```java
import java.util.concurrent.CopyOnWriteArrayList;

class BasicCopyOnWriteExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        
        // Add elements
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        
        System.out.println("Initial list: " + list);
        
        // Modify
        list.set(1, "Mango");
        System.out.println("After set: " + list);
        
        // Remove
        list.remove("Orange");
        System.out.println("After remove: " + list);
        
        // Add at index
        list.add(1, "Grape");
        System.out.println("After add at index: " + list);
    }
}
```

---

## üíª Example 2: Safe Iteration During Modification

```java
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.Iterator;

class SafeIterationExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
        
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        
        System.out.println("Original list: " + list);
        
        // Iterate and modify simultaneously
        Iterator<Integer> iterator = list.iterator();
        
        new Thread(() -> {
            try {
                Thread.sleep(100);
                list.add(6);
                list.add(7);
                System.out.println("Added elements: " + list);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        // Iterator sees snapshot at time of creation
        System.out.print("Iterator sees: ");
        while (iterator.hasNext()) {
            System.out.print(iterator.next() + " ");
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        System.out.println("\nFinal list: " + list);
    }
}
```

**Output:**
```
Original list: [1, 2, 3, 4, 5]
Iterator sees: 1 2 3 Added elements: [1, 2, 3, 4, 5, 6, 7]
4 5 
Final list: [1, 2, 3, 4, 5, 6, 7]
```

---

## üíª Example 3: Event Listener Pattern

```java
import java.util.concurrent.CopyOnWriteArrayList;

interface EventListener {
    void onEvent(String event);
}

class EventManager {
    private CopyOnWriteArrayList<EventListener> listeners = new CopyOnWriteArrayList<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
        System.out.println("Listener added. Total: " + listeners.size());
    }
    
    public void removeListener(EventListener listener) {
        listeners.remove(listener);
        System.out.println("Listener removed. Total: " + listeners.size());
    }
    
    public void fireEvent(String event) {
        System.out.println("\nüîî Firing event: " + event);
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        EventManager manager = new EventManager();
        
        // Add listeners
        EventListener listener1 = (event) -> 
            System.out.println("Listener-1 received: " + event);
        EventListener listener2 = (event) -> 
            System.out.println("Listener-2 received: " + event);
        EventListener listener3 = (event) -> 
            System.out.println("Listener-3 received: " + event);
        
        manager.addListener(listener1);
        manager.addListener(listener2);
        manager.addListener(listener3);
        
        // Fire events
        manager.fireEvent("EVENT_1");
        
        // Remove listener while firing events
        new Thread(() -> {
            manager.removeListener(listener2);
        }).start();
        
        Thread.sleep(100);
        manager.fireEvent("EVENT_2");
    }
}
```

---

## üíª Example 4: Concurrent Readers and Writers

```java
import java.util.concurrent.*;

class ConcurrentReadWriteExample {
    public static void main(String[] args) throws InterruptedException {
        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
        
        // Writer thread
        Thread writer = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add(i);
                System.out.println("Writer added: " + i);
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        // Reader threads
        Thread reader1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Reader-1: " + list);
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        Thread reader2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                int sum = list.stream().mapToInt(Integer::intValue).sum();
                System.out.println("Reader-2 sum: " + sum);
                try {
                    Thread.sleep(400);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        writer.start();
        Thread.sleep(50);
        reader1.start();
        reader2.start();
        
        writer.join();
        reader1.join();
        reader2.join();
        
        System.out.println("\nFinal list: " + list);
    }
}
```

---

## üíª Example 5: No ConcurrentModificationException

```java
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;

class NoConcurrentModificationExample {
    public static void main(String[] args) {
        System.out.println("=== ArrayList (will throw exception) ===");
        testArrayList();
        
        System.out.println("\n=== CopyOnWriteArrayList (safe) ===");
        testCopyOnWriteArrayList();
    }
    
    private static void testArrayList() {
        ArrayList<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        
        try {
            for (String item : list) {
                System.out.println(item);
                if (item.equals("B")) {
                    list.add("D"); // ConcurrentModificationException
                }
            }
        } catch (Exception e) {
            System.out.println("Exception: " + e.getClass().getSimpleName());
        }
    }
    
    private static void testCopyOnWriteArrayList() {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");
        
        for (String item : list) {
            System.out.println(item);
            if (item.equals("B")) {
                list.add("D"); // No exception!
            }
        }
        
        System.out.println("Final list: " + list);
    }
}
```

---

## üíª Example 6: Observer Pattern Implementation

```java
import java.util.concurrent.CopyOnWriteArrayList;

class Subject {
    private CopyOnWriteArrayList<Observer> observers = new CopyOnWriteArrayList<>();
    private int state;
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void setState(int state) {
        this.state = state;
        notifyAllObservers();
    }
    
    public int getState() {
        return state;
    }
    
    private void notifyAllObservers() {
        for (Observer observer : observers) {
            observer.update(this);
        }
    }
}

interface Observer {
    void update(Subject subject);
}

class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    @Override
    public void update(Subject subject) {
        System.out.println(name + " notified. New state: " + subject.getState());
    }
}

class ObserverPatternExample {
    public static void main(String[] args) {
        Subject subject = new Subject();
        
        Observer observer1 = new ConcreteObserver("Observer-1");
        Observer observer2 = new ConcreteObserver("Observer-2");
        Observer observer3 = new ConcreteObserver("Observer-3");
        
        subject.attach(observer1);
        subject.attach(observer2);
        subject.attach(observer3);
        
        System.out.println("Setting state to 10:");
        subject.setState(10);
        
        System.out.println("\nRemoving Observer-2");
        subject.detach(observer2);
        
        System.out.println("\nSetting state to 20:");
        subject.setState(20);
    }
}
```

---

## üìä CopyOnWriteArrayList vs ArrayList

| Feature | CopyOnWriteArrayList | ArrayList |
|---------|---------------------|-----------|
| **Thread-Safe** | ‚úÖ Yes | ‚ùå No |
| **Read Performance** | Fast | Fast |
| **Write Performance** | Slow (copies array) | Fast |
| **Iterator** | Snapshot, never fails | Can throw CME |
| **Memory** | Higher | Lower |
| **Use Case** | Read-heavy | Single-threaded |

---

## üí° When to Use

### ‚úÖ Good For:
- Event listeners
- Observer pattern
- Read-heavy operations
- Small lists with infrequent writes
- Iteration without explicit synchronization

### ‚ùå Avoid When:
- Frequent writes
- Large lists
- Write-heavy scenarios
- Memory-constrained environments

---

## üéØ Performance Considerations

```java
Write Operation Cost:
1. Create new array (size + 1)
2. Copy all existing elements
3. Add new element
4. Replace reference

O(n) time for each write!
```

---

## üí° Best Practices

1. ‚úÖ Use for read-heavy scenarios
2. ‚úÖ Perfect for listener lists
3. ‚úÖ Avoid for large lists
4. ‚úÖ No need for external synchronization
5. ‚úÖ Iterator reflects snapshot

---

## üéØ Interview Questions

1. **What is CopyOnWriteArrayList?**
2. **When should you use CopyOnWriteArrayList?**
3. **Why doesn't the iterator throw ConcurrentModificationException?**
4. **What is the time complexity of add operation?**
5. **What are the disadvantages of CopyOnWriteArrayList?**
6. **How is it different from Collections.synchronizedList()?**

---

## üìö Next Topics

- [BlockingQueue](03.%20BlockingQueue.md)
- [ConcurrentLinkedQueue](04.%20ConcurrentLinkedQueue.md)
