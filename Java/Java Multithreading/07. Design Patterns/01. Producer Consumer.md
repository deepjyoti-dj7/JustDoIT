# âš¡ Producer-Consumer Pattern

## ðŸ“– Overview

The **Producer-Consumer** pattern is one of the most common concurrency patterns where:
- **Producers** create data and add it to a shared buffer
- **Consumers** retrieve and process data from the buffer
- A **bounded buffer** (queue) coordinates between them

---

## ðŸŽ¯ Use Cases

1. **Task Processing Systems** - Job queues
2. **Message Queues** - Kafka, RabbitMQ
3. **Logging Systems** - Async log processing
4. **Data Pipelines** - ETL processes
5. **Web Servers** - Request handling

---

## ðŸ’» Method 1: Using wait() and notify()

### Classic Implementation

```java
import java.util.LinkedList;
import java.util.Queue;

class ProducerConsumerClassic {
    private Queue<Integer> queue = new LinkedList<>();
    private final int CAPACITY = 5;
    private final Object lock = new Object();
    
    // Producer method
    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (lock) {
                // Wait if queue is full
                while (queue.size() == CAPACITY) {
                    System.out.println("Queue is full, Producer waiting...");
                    lock.wait();
                }
                
                // Produce item
                System.out.println("Producing: " + value);
                queue.add(value++);
                
                // Notify consumer
                lock.notifyAll();
                
                Thread.sleep(1000);
            }
        }
    }
    
    // Consumer method
    public void consume() throws InterruptedException {
        while (true) {
            synchronized (lock) {
                // Wait if queue is empty
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty, Consumer waiting...");
                    lock.wait();
                }
                
                // Consume item
                int value = queue.poll();
                System.out.println("Consuming: " + value);
                
                // Notify producer
                lock.notifyAll();
                
                Thread.sleep(1000);
            }
        }
    }
    
    public static void main(String[] args) {
        ProducerConsumerClassic pc = new ProducerConsumerClassic();
        
        Thread producerThread = new Thread(() -> {
            try {
                pc.produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Producer");
        
        Thread consumerThread = new Thread(() -> {
            try {
                pc.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Consumer");
        
        producerThread.start();
        consumerThread.start();
    }
}
```

**Output:**
```
Producing: 0
Producing: 1
Consuming: 0
Producing: 2
Consuming: 1
Producing: 3
...
```

---

## ðŸ’» Method 2: Using BlockingQueue (Recommended)

### Using ArrayBlockingQueue

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

class ProducerConsumerBlocking {
    private BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);
    
    // Producer
    class Producer implements Runnable {
        @Override
        public void run() {
            int value = 0;
            try {
                while (true) {
                    System.out.println("Producing: " + value);
                    queue.put(value++); // Blocks if queue is full
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // Consumer
    class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    Integer value = queue.take(); // Blocks if queue is empty
                    System.out.println("Consuming: " + value);
                    Thread.sleep(1500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public static void main(String[] args) {
        ProducerConsumerBlocking pc = new ProducerConsumerBlocking();
        
        Thread producerThread = new Thread(pc.new Producer(), "Producer");
        Thread consumerThread = new Thread(pc.new Consumer(), "Consumer");
        
        producerThread.start();
        consumerThread.start();
    }
}
```

---

## ðŸ’» Method 3: Multiple Producers and Consumers

### Example with Thread Pool

```java
import java.util.concurrent.*;

class MultiProducerConsumer {
    private BlockingQueue<String> queue = new LinkedBlockingQueue<>(10);
    private volatile boolean isRunning = true;
    
    class Producer implements Runnable {
        private String name;
        
        public Producer(String name) {
            this.name = name;
        }
        
        @Override
        public void run() {
            int count = 0;
            try {
                while (isRunning) {
                    String item = name + "-Item-" + count++;
                    queue.put(item);
                    System.out.println(name + " produced: " + item + 
                                      " | Queue size: " + queue.size());
                    Thread.sleep(ThreadLocalRandom.current().nextInt(500, 1500));
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    class Consumer implements Runnable {
        private String name;
        
        public Consumer(String name) {
            this.name = name;
        }
        
        @Override
        public void run() {
            try {
                while (isRunning || !queue.isEmpty()) {
                    String item = queue.poll(100, TimeUnit.MILLISECONDS);
                    if (item != null) {
                        System.out.println(name + " consumed: " + item + 
                                          " | Queue size: " + queue.size());
                        Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 2000));
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public void start() throws InterruptedException {
        ExecutorService producerPool = Executors.newFixedThreadPool(3);
        ExecutorService consumerPool = Executors.newFixedThreadPool(2);
        
        // Start producers
        producerPool.submit(new Producer("Producer-1"));
        producerPool.submit(new Producer("Producer-2"));
        producerPool.submit(new Producer("Producer-3"));
        
        // Start consumers
        consumerPool.submit(new Consumer("Consumer-1"));
        consumerPool.submit(new Consumer("Consumer-2"));
        
        // Run for 10 seconds
        Thread.sleep(10000);
        
        // Shutdown
        isRunning = false;
        producerPool.shutdown();
        consumerPool.shutdown();
        
        producerPool.awaitTermination(5, TimeUnit.SECONDS);
        consumerPool.awaitTermination(5, TimeUnit.SECONDS);
        
        System.out.println("All tasks completed");
    }
    
    public static void main(String[] args) throws InterruptedException {
        new MultiProducerConsumer().start();
    }
}
```

---

## ðŸ’» Method 4: Priority Queue

### Example with Priority Processing

```java
import java.util.concurrent.PriorityBlockingQueue;

class Task implements Comparable<Task> {
    private String name;
    private int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(other.priority, this.priority); // Higher priority first
    }
    
    @Override
    public String toString() {
        return name + " (Priority: " + priority + ")";
    }
}

class PriorityProducerConsumer {
    private PriorityBlockingQueue<Task> queue = new PriorityBlockingQueue<>();
    
    public static void main(String[] args) throws InterruptedException {
        PriorityProducerConsumer pc = new PriorityProducerConsumer();
        
        // Producer
        Thread producer = new Thread(() -> {
            try {
                pc.queue.put(new Task("Task-1", 3));
                pc.queue.put(new Task("Task-2", 10));
                pc.queue.put(new Task("Task-3", 1));
                pc.queue.put(new Task("Task-4", 7));
                pc.queue.put(new Task("Task-5", 5));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        // Consumer
        Thread consumer = new Thread(() -> {
            try {
                Thread.sleep(2000); // Wait for all tasks to be produced
                while (!pc.queue.isEmpty()) {
                    Task task = pc.queue.take();
                    System.out.println("Processing: " + task);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
    }
}
```

**Output:**
```
Processing: Task-2 (Priority: 10)
Processing: Task-4 (Priority: 7)
Processing: Task-5 (Priority: 5)
Processing: Task-1 (Priority: 3)
Processing: Task-3 (Priority: 1)
```

---

## ðŸ’» Real-World Example: Log Processing System

```java
import java.util.concurrent.*;
import java.time.LocalDateTime;

class LogEntry {
    private String level;
    private String message;
    private LocalDateTime timestamp;
    
    public LogEntry(String level, String message) {
        this.level = level;
        this.message = message;
        this.timestamp = LocalDateTime.now();
    }
    
    @Override
    public String toString() {
        return String.format("[%s] %s - %s", timestamp, level, message);
    }
}

class LogProcessingSystem {
    private BlockingQueue<LogEntry> logQueue = new LinkedBlockingQueue<>(100);
    private volatile boolean isRunning = true;
    
    // Producer: Application generating logs
    class LogProducer implements Runnable {
        private String componentName;
        
        public LogProducer(String componentName) {
            this.componentName = componentName;
        }
        
        @Override
        public void run() {
            try {
                int count = 0;
                while (isRunning) {
                    LogEntry entry = new LogEntry(
                        getRandomLevel(),
                        componentName + " - Message " + count++
                    );
                    
                    if (logQueue.offer(entry, 100, TimeUnit.MILLISECONDS)) {
                        System.out.println("âœ“ Logged: " + entry);
                    } else {
                        System.out.println("âœ— Log queue full, dropping log");
                    }
                    
                    Thread.sleep(ThreadLocalRandom.current().nextInt(100, 500));
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private String getRandomLevel() {
            String[] levels = {"INFO", "DEBUG", "WARN", "ERROR"};
            return levels[ThreadLocalRandom.current().nextInt(levels.length)];
        }
    }
    
    // Consumer: Log processor
    class LogConsumer implements Runnable {
        @Override
        public void run() {
            try {
                while (isRunning || !logQueue.isEmpty()) {
                    LogEntry entry = logQueue.poll(100, TimeUnit.MILLISECONDS);
                    if (entry != null) {
                        processLog(entry);
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private void processLog(LogEntry entry) throws InterruptedException {
            // Simulate log processing (writing to file/database)
            Thread.sleep(200);
            System.out.println("â†’ Processed: " + entry);
        }
    }
    
    public void start() throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        
        // Start multiple log producers
        executor.submit(new LogProducer("UserService"));
        executor.submit(new LogProducer("OrderService"));
        executor.submit(new LogProducer("PaymentService"));
        
        // Start log consumer
        executor.submit(new LogConsumer());
        
        // Run for 5 seconds
        Thread.sleep(5000);
        
        isRunning = false;
        executor.shutdown();
        executor.awaitTermination(5, TimeUnit.SECONDS);
        
        System.out.println("\nLog processing system stopped");
        System.out.println("Remaining logs in queue: " + logQueue.size());
    }
    
    public static void main(String[] args) throws InterruptedException {
        new LogProcessingSystem().start();
    }
}
```

---

## ðŸ“Š Comparison of Approaches

| Approach | Complexity | Performance | Use Case |
|----------|-----------|-------------|----------|
| **wait/notify** | High | Good | Learning, custom logic |
| **BlockingQueue** | Low | Excellent | **Most common, Recommended** |
| **Semaphore** | Medium | Good | Resource limiting |
| **Condition** | High | Excellent | Complex coordination |

---

## ðŸ’¡ Best Practices

1. âœ… **Use BlockingQueue** for simplicity and correctness
2. âœ… **Handle InterruptedException** properly
3. âœ… **Set appropriate queue capacity** to prevent memory issues
4. âœ… **Use timeout methods** (poll/offer with timeout)
5. âœ… **Graceful shutdown** mechanism with shutdown flags
6. âœ… **Monitor queue size** for performance tuning
7. âœ… **Use appropriate queue type** based on requirements

---

## ðŸŽ¯ Interview Questions

1. **What is the Producer-Consumer problem?**
2. **How does BlockingQueue solve the Producer-Consumer problem?**
3. **What is the difference between put() and offer()?**
4. **What is the difference between take() and poll()?**
5. **How do you handle multiple producers and consumers?**
6. **What happens if the queue is full/empty?**
7. **How do you implement graceful shutdown?**
8. **When would you use PriorityBlockingQueue?**

---

## ðŸ“š Related Topics

- [BlockingQueue](../../05.%20Concurrent%20Collections/03.%20BlockingQueue.md)
- [Wait Notify NotifyAll](../../03.%20Thread%20Communication/01.%20Wait%20Notify%20NotifyAll.md)
- [Thread Pools](../../04.%20Executor%20Framework/02.%20Thread%20Pools.md)
