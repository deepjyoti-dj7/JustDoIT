# üîí Double-Checked Locking

## üìñ What is Double-Checked Locking?

A design pattern that reduces the overhead of acquiring a lock by first testing the locking criterion without actually acquiring the lock.

**Use Cases:**
- Lazy initialization
- Singleton pattern
- Resource caching

**Warning:** Can be broken without `volatile`!

---

## üíª Example 1: Broken Double-Checked Locking

```java
class BrokenSingleton {
    private static BrokenSingleton instance; // ‚ùå Not volatile
    
    private BrokenSingleton() {
        System.out.println("Instance created");
    }
    
    public static BrokenSingleton getInstance() {
        if (instance == null) { // First check (no lock)
            synchronized (BrokenSingleton.class) {
                if (instance == null) { // Second check (with lock)
                    instance = new BrokenSingleton();
                    // ‚ö†Ô∏è PROBLEM: Another thread might see partially constructed object!
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                BrokenSingleton s = BrokenSingleton.getInstance();
                System.out.println(s.hashCode());
            }).start();
        }
    }
}
```

**Problem:** Without `volatile`, the instance assignment can be reordered, causing another thread to see a partially constructed object.

---

## üíª Example 2: Correct Double-Checked Locking

```java
class CorrectSingleton {
    private static volatile CorrectSingleton instance; // ‚úÖ volatile!
    private String data;
    
    private CorrectSingleton() {
        System.out.println("Initializing singleton...");
        try {
            Thread.sleep(1000); // Simulate expensive initialization
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.data = "Initialized";
        System.out.println("Singleton created");
    }
    
    public static CorrectSingleton getInstance() {
        if (instance == null) { // First check (no lock) - fast path
            synchronized (CorrectSingleton.class) {
                if (instance == null) { // Second check (with lock)
                    instance = new CorrectSingleton();
                }
            }
        }
        return instance;
    }
    
    public String getData() {
        return data;
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Multiple threads trying to get instance
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                CorrectSingleton s = CorrectSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + s.hashCode() + " - " + s.getData());
            }, "Thread-" + i).start();
        }
        
        Thread.sleep(2000);
    }
}
```

---

## üíª Example 3: Lazy Initialization Holder (Best Alternative)

```java
class HolderSingleton {
    private HolderSingleton() {
        System.out.println("Singleton created");
    }
    
    // Inner static class - loaded only when referenced
    private static class Holder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }
    
    public static HolderSingleton getInstance() {
        return Holder.INSTANCE; // Thread-safe, no synchronization needed!
    }
    
    public static void main(String[] args) {
        System.out.println("Before getInstance");
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                HolderSingleton s = HolderSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + s.hashCode());
            }, "Thread-" + i).start();
        }
    }
}
```

**Advantages:**
- No synchronization overhead
- Lazy initialization
- Thread-safe by JVM guarantees

---

## üíª Example 4: Lazy Resource Initialization

```java
class DatabaseConnection {
    private static volatile DatabaseConnection connection;
    private String connectionString;
    
    private DatabaseConnection(String connString) {
        System.out.println("Establishing connection to " + connString);
        try {
            Thread.sleep(2000); // Simulate connection setup
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.connectionString = connString;
        System.out.println("Connection established");
    }
    
    public static DatabaseConnection getInstance(String connString) {
        if (connection == null) {
            synchronized (DatabaseConnection.class) {
                if (connection == null) {
                    connection = new DatabaseConnection(connString);
                }
            }
        }
        return connection;
    }
    
    public void query(String sql) {
        System.out.println("Executing: " + sql + " on " + connectionString);
    }
    
    public static void main(String[] args) {
        // Multiple threads trying to get connection
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                DatabaseConnection conn = DatabaseConnection.getInstance("jdbc:mysql://localhost");
                conn.query("SELECT * FROM users");
            }, "Thread-" + i).start();
        }
    }
}
```

---

## üíª Example 5: Configuration Loader

```java
import java.util.*;

class ConfigLoader {
    private static volatile ConfigLoader instance;
    private final Map<String, String> config;
    private final long loadTime;
    
    private ConfigLoader() {
        System.out.println("Loading configuration...");
        config = new HashMap<>();
        
        try {
            Thread.sleep(1500); // Simulate file I/O
            config.put("db.host", "localhost");
            config.put("db.port", "3306");
            config.put("app.name", "MyApp");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        loadTime = System.currentTimeMillis();
        System.out.println("Configuration loaded");
    }
    
    public static ConfigLoader getInstance() {
        if (instance == null) {
            synchronized (ConfigLoader.class) {
                if (instance == null) {
                    instance = new ConfigLoader();
                }
            }
        }
        return instance;
    }
    
    public String get(String key) {
        return config.get(key);
    }
    
    public long getLoadTime() {
        return loadTime;
    }
    
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                ConfigLoader cfg = ConfigLoader.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                    " - DB Host: " + cfg.get("db.host") + 
                    ", Load time: " + cfg.getLoadTime());
            }, "Thread-" + i).start();
        }
    }
}
```

---

## üíª Example 6: Cache with Lazy Initialization

```java
import java.util.concurrent.ConcurrentHashMap;

class LazyCache<K, V> {
    private final ConcurrentHashMap<K, V> cache = new ConcurrentHashMap<>();
    
    public V get(K key, ValueLoader<K, V> loader) {
        V value = cache.get(key);
        
        if (value == null) {
            synchronized (this) {
                value = cache.get(key); // Double-check
                if (value == null) {
                    System.out.println("Computing value for " + key);
                    value = loader.load(key);
                    cache.put(key, value);
                }
            }
        } else {
            System.out.println("Cache hit for " + key);
        }
        
        return value;
    }
    
    interface ValueLoader<K, V> {
        V load(K key);
    }
    
    public static void main(String[] args) throws InterruptedException {
        LazyCache<Integer, String> cache = new LazyCache<>();
        
        // Multiple threads requesting same keys
        for (int i = 1; i <= 10; i++) {
            final int threadId = i;
            new Thread(() -> {
                int key = threadId % 3; // Only 3 unique keys
                String value = cache.get(key, k -> {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    return "Value-" + k;
                });
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + key + " = " + value);
            }, "Thread-" + i).start();
        }
        
        Thread.sleep(5000);
    }
}
```

---

## üíª Example 7: Performance Comparison

```java
class PerformanceComparison {
    private static volatile PerformanceComparison instanceDCL;
    private static PerformanceComparison instanceSync;
    
    private PerformanceComparison() {}
    
    // Double-checked locking
    public static PerformanceComparison getInstanceDCL() {
        if (instanceDCL == null) {
            synchronized (PerformanceComparison.class) {
                if (instanceDCL == null) {
                    instanceDCL = new PerformanceComparison();
                }
            }
        }
        return instanceDCL;
    }
    
    // Simple synchronized
    public static synchronized PerformanceComparison getInstanceSync() {
        if (instanceSync == null) {
            instanceSync = new PerformanceComparison();
        }
        return instanceSync;
    }
    
    public static void main(String[] args) throws InterruptedException {
        int threads = 100;
        int iterations = 10000;
        
        // Test DCL
        long start1 = System.nanoTime();
        Thread[] threads1 = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            threads1[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    getInstanceDCL();
                }
            });
            threads1[i].start();
        }
        for (Thread t : threads1) {
            t.join();
        }
        long time1 = System.nanoTime() - start1;
        
        // Test synchronized
        long start2 = System.nanoTime();
        Thread[] threads2 = new Thread[threads];
        for (int i = 0; i < threads; i++) {
            threads2[i] = new Thread(() -> {
                for (int j = 0; j < iterations; j++) {
                    getInstanceSync();
                }
            });
            threads2[i].start();
        }
        for (Thread t : threads2) {
            t.join();
        }
        long time2 = System.nanoTime() - start2;
        
        System.out.println("DCL time: " + time1 / 1_000_000 + " ms");
        System.out.println("Synchronized time: " + time2 / 1_000_000 + " ms");
        System.out.println("DCL is " + (time2 / time1) + "x faster");
    }
}
```

---

## üìä Comparison of Singleton Approaches

| Approach | Thread-Safe | Lazy | Performance | Complexity |
|----------|-------------|------|-------------|------------|
| **Eager** | ‚úÖ Yes | ‚ùå No | ‚≠ê‚≠ê‚≠ê High | Low |
| **Synchronized** | ‚úÖ Yes | ‚úÖ Yes | ‚≠ê Low | Low |
| **DCL** | ‚úÖ Yes | ‚úÖ Yes | ‚≠ê‚≠ê Medium | Medium |
| **Holder** | ‚úÖ Yes | ‚úÖ Yes | ‚≠ê‚≠ê‚≠ê High | Low |
| **Enum** | ‚úÖ Yes | ‚ùå No | ‚≠ê‚≠ê‚≠ê High | Low |

---

## ‚ö†Ô∏è Common Pitfalls

```java
class Pitfalls {
    // ‚ùå WRONG: Missing volatile
    private static Pitfalls instance1;
    
    public static Pitfalls getInstance1() {
        if (instance1 == null) {
            synchronized (Pitfalls.class) {
                if (instance1 == null) {
                    instance1 = new Pitfalls(); // Can be partially visible!
                }
            }
        }
        return instance1;
    }
    
    // ‚ùå WRONG: Synchronizing on wrong object
    private static volatile Pitfalls instance2;
    private static final Object lock = new Object();
    
    public static Pitfalls getInstance2() {
        if (instance2 == null) {
            synchronized (lock) { // Should sync on class
                if (instance2 == null) {
                    instance2 = new Pitfalls();
                }
            }
        }
        return instance2;
    }
    
    // ‚úÖ CORRECT
    private static volatile Pitfalls instance3;
    
    public static Pitfalls getInstance3() {
        if (instance3 == null) {
            synchronized (Pitfalls.class) {
                if (instance3 == null) {
                    instance3 = new Pitfalls();
                }
            }
        }
        return instance3;
    }
}
```

---

## üí° Best Practices

1. ‚úÖ Always use `volatile` with DCL
2. ‚úÖ Consider Holder pattern instead (simpler, faster)
3. ‚úÖ Use enum for simple singletons
4. ‚úÖ DCL is useful for expensive initialization
5. ‚úÖ Document why DCL is needed
6. ‚úÖ Test with stress testing tools

---

## üéØ Interview Questions

1. **What is double-checked locking?**
2. **Why is volatile necessary in DCL?**
3. **What are alternatives to DCL?**
4. **What is the initialization-on-demand holder pattern?**
5. **When would you use DCL over synchronized?**

---

## üìö Related Topics

- [Thread-Safe Singleton](05.%20Thread-Safe%20Singleton.md)
- [Memory Model](../../06.%20Advanced%20Concepts/06.%20Memory%20Model.md)
- [Happens-Before](../../06.%20Advanced%20Concepts/05.%20Happens-Before.md)
