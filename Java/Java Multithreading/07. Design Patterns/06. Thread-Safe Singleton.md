# üîê Thread-Safe Singleton

## üìñ What is a Thread-Safe Singleton?

A design pattern that ensures a class has only one instance and provides thread-safe access to it.

**Requirements:**
- Only one instance
- Thread-safe creation
- Lazy or eager initialization
- Prevention of reflection/serialization attacks

---

## üíª Example 1: Eager Initialization

```java
class EagerSingleton {
    // Instance created at class loading time
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    private EagerSingleton() {
        System.out.println("EagerSingleton created");
        if (INSTANCE != null) {
            throw new IllegalStateException("Instance already exists!");
        }
    }
    
    public static EagerSingleton getInstance() {
        return INSTANCE; // No synchronization needed
    }
    
    public void doSomething() {
        System.out.println("Doing something...");
    }
    
    public static void main(String[] args) {
        System.out.println("Starting main...");
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                EagerSingleton instance = EagerSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + instance.hashCode());
            }, "Thread-" + i).start();
        }
    }
}
```

**Pros:** Simple, thread-safe  
**Cons:** Not lazy, created even if never used

---

## üíª Example 2: Lazy Synchronized

```java
class LazySynchronized {
    private static LazySynchronized instance;
    
    private LazySynchronized() {
        System.out.println("LazySynchronized created");
    }
    
    public static synchronized LazySynchronized getInstance() {
        if (instance == null) {
            try {
                Thread.sleep(1000); // Simulate expensive initialization
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            instance = new LazySynchronized();
        }
        return instance;
    }
    
    public static void main(String[] args) {
        System.out.println("Starting main...");
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                long start = System.currentTimeMillis();
                LazySynchronized s = LazySynchronized.getInstance();
                long end = System.currentTimeMillis();
                System.out.println(Thread.currentThread().getName() + 
                    ": " + s.hashCode() + " (took " + (end - start) + "ms)");
            }, "Thread-" + i).start();
        }
    }
}
```

**Pros:** Lazy, thread-safe  
**Cons:** Synchronized every time (performance hit)

---

## üíª Example 3: Double-Checked Locking

```java
class DCLSingleton {
    private static volatile DCLSingleton instance;
    
    private DCLSingleton() {
        System.out.println("DCLSingleton created");
    }
    
    public static DCLSingleton getInstance() {
        if (instance == null) { // First check (no lock)
            synchronized (DCLSingleton.class) {
                if (instance == null) { // Second check (with lock)
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    instance = new DCLSingleton();
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                long start = System.currentTimeMillis();
                DCLSingleton s = DCLSingleton.getInstance();
                long end = System.currentTimeMillis();
                System.out.println(Thread.currentThread().getName() + 
                    ": " + s.hashCode() + " (took " + (end - start) + "ms)");
            }, "Thread-" + i).start();
        }
    }
}
```

**Pros:** Lazy, minimal synchronization  
**Cons:** Complex, requires volatile

---

## üíª Example 4: Bill Pugh Solution (Initialization-on-demand Holder)

```java
class HolderSingleton {
    private HolderSingleton() {
        System.out.println("HolderSingleton created");
    }
    
    // Inner static class - loaded only when referenced
    private static class SingletonHolder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }
    
    public static HolderSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    public static void main(String[] args) {
        System.out.println("Starting main...");
        System.out.println("Singleton not yet created...");
        
        Thread.sleep(2000);
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                HolderSingleton s = HolderSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + s.hashCode());
            }, "Thread-" + i).start();
        }
    }
}
```

**Pros:** Lazy, thread-safe, no synchronization, best performance  
**Cons:** None (recommended approach)

---

## üíª Example 5: Enum Singleton (Best Practice)

```java
enum EnumSingleton {
    INSTANCE;
    
    private String data;
    
    EnumSingleton() {
        System.out.println("EnumSingleton created");
        data = "Initialized";
    }
    
    public void doSomething() {
        System.out.println("Doing something with " + data);
    }
    
    public String getData() {
        return data;
    }
    
    public void setData(String data) {
        this.data = data;
    }
}

class EnumSingletonDemo {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                EnumSingleton singleton = EnumSingleton.INSTANCE;
                System.out.println(Thread.currentThread().getName() + 
                    ": " + singleton.hashCode());
                singleton.doSomething();
            }, "Thread-" + i).start();
        }
    }
}
```

**Pros:** Thread-safe, serialization-safe, reflection-safe, simplest  
**Cons:** Not lazy (but usually not needed)

---

## üíª Example 6: Preventing Reflection Attacks

```java
class ReflectionProofSingleton {
    private static volatile ReflectionProofSingleton instance;
    private static boolean instanceCreated = false;
    
    private ReflectionProofSingleton() {
        synchronized (ReflectionProofSingleton.class) {
            if (instanceCreated) {
                throw new IllegalStateException(
                    "Instance already created. Use getInstance()");
            }
            instanceCreated = true;
        }
        System.out.println("Singleton created");
    }
    
    public static ReflectionProofSingleton getInstance() {
        if (instance == null) {
            synchronized (ReflectionProofSingleton.class) {
                if (instance == null) {
                    instance = new ReflectionProofSingleton();
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) throws Exception {
        // Normal creation
        ReflectionProofSingleton s1 = ReflectionProofSingleton.getInstance();
        System.out.println("s1: " + s1.hashCode());
        
        // Try reflection attack
        try {
            java.lang.reflect.Constructor<ReflectionProofSingleton> constructor = 
                ReflectionProofSingleton.class.getDeclaredConstructor();
            constructor.setAccessible(true);
            ReflectionProofSingleton s2 = constructor.newInstance();
            System.out.println("s2: " + s2.hashCode());
        } catch (Exception e) {
            System.out.println("Reflection attack prevented: " + e.getMessage());
        }
    }
}
```

---

## üíª Example 7: Serialization-Safe Singleton

```java
import java.io.*;

class SerializableSingleton implements Serializable {
    private static final long serialVersionUID = 1L;
    private static volatile SerializableSingleton instance;
    
    private SerializableSingleton() {
        System.out.println("Singleton created");
    }
    
    public static SerializableSingleton getInstance() {
        if (instance == null) {
            synchronized (SerializableSingleton.class) {
                if (instance == null) {
                    instance = new SerializableSingleton();
                }
            }
        }
        return instance;
    }
    
    // Prevent creating new instance during deserialization
    protected Object readResolve() {
        System.out.println("readResolve called");
        return getInstance();
    }
    
    public static void main(String[] args) throws Exception {
        SerializableSingleton original = SerializableSingleton.getInstance();
        System.out.println("Original: " + original.hashCode());
        
        // Serialize
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(original);
        
        // Deserialize
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        SerializableSingleton deserialized = (SerializableSingleton) ois.readObject();
        System.out.println("Deserialized: " + deserialized.hashCode());
        
        System.out.println("Same instance? " + (original == deserialized));
    }
}
```

---

## üíª Example 8: Registry Singleton Pattern

```java
import java.util.concurrent.ConcurrentHashMap;

class SingletonRegistry {
    private static final ConcurrentHashMap<String, Object> registry = 
        new ConcurrentHashMap<>();
    
    @SuppressWarnings("unchecked")
    public static <T> T getInstance(String key, Class<T> clazz) {
        return (T) registry.computeIfAbsent(key, k -> {
            try {
                System.out.println("Creating instance of " + clazz.getSimpleName());
                return clazz.getDeclaredConstructor().newInstance();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }
}

class DatabaseConnection {
    public DatabaseConnection() {
        System.out.println("Database connection created");
    }
}

class CacheManager {
    public CacheManager() {
        System.out.println("Cache manager created");
    }
}

class RegistryDemo {
    public static void main(String[] args) {
        // Multiple threads requesting same services
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                DatabaseConnection db = SingletonRegistry.getInstance(
                    "database", DatabaseConnection.class);
                CacheManager cache = SingletonRegistry.getInstance(
                    "cache", CacheManager.class);
                
                System.out.println(Thread.currentThread().getName() + 
                    " - DB: " + db.hashCode() + ", Cache: " + cache.hashCode());
            }, "Thread-" + i).start();
        }
    }
}
```

---

## üìä Singleton Approaches Comparison

| Approach | Lazy | Thread-Safe | Complexity | Performance | Recommended |
|----------|------|-------------|------------|-------------|-------------|
| **Eager** | ‚ùå No | ‚úÖ Yes | Low | ‚≠ê‚≠ê‚≠ê High | ‚úÖ If not lazy |
| **Synchronized** | ‚úÖ Yes | ‚úÖ Yes | Low | ‚≠ê Low | ‚ùå No |
| **DCL** | ‚úÖ Yes | ‚úÖ Yes | High | ‚≠ê‚≠ê Medium | ‚ö†Ô∏è Complex |
| **Holder** | ‚úÖ Yes | ‚úÖ Yes | Low | ‚≠ê‚≠ê‚≠ê High | ‚úÖ Best for lazy |
| **Enum** | ‚ùå No | ‚úÖ Yes | Low | ‚≠ê‚≠ê‚≠ê High | ‚úÖ Simplest |

---

## ‚ö†Ô∏è Common Pitfalls

```java
class CommonMistakes {
    // ‚ùå WRONG: Not thread-safe
    private static CommonMistakes instance1;
    public static CommonMistakes getInstance1() {
        if (instance1 == null) {
            instance1 = new CommonMistakes();
        }
        return instance1;
    }
    
    // ‚ùå WRONG: DCL without volatile
    private static CommonMistakes instance2;
    public static CommonMistakes getInstance2() {
        if (instance2 == null) {
            synchronized (CommonMistakes.class) {
                if (instance2 == null) {
                    instance2 = new CommonMistakes();
                }
            }
        }
        return instance2;
    }
    
    // ‚ùå WRONG: Public constructor
    public CommonMistakes() {} // Should be private!
    
    // ‚úÖ CORRECT: Use Holder pattern
    private CommonMistakes() {}
    private static class Holder {
        static final CommonMistakes INSTANCE = new CommonMistakes();
    }
    public static CommonMistakes getInstance() {
        return Holder.INSTANCE;
    }
}
```

---

## üí° Best Practices

1. ‚úÖ Use Enum for simplest thread-safe singleton
2. ‚úÖ Use Holder pattern for lazy initialization
3. ‚úÖ Always make constructor private
4. ‚úÖ Implement readResolve() if serializable
5. ‚úÖ Prevent reflection with constructor check
6. ‚úÖ Document the singleton choice

---

## üéØ Interview Questions

1. **What is the Singleton pattern?**
2. **How to make Singleton thread-safe?**
3. **What is double-checked locking?**
4. **Why use enum for Singleton?**
5. **How to prevent reflection attacks?**
6. **What is the Holder pattern?**
7. **Serialization issues with Singleton?**

---

## üìö Related Topics

- [Double-Checked Locking](05.%20Double-Checked%20Locking.md)
- [Memory Model](../../06.%20Advanced%20Concepts/06.%20Memory%20Model.md)
- [Thread Safety](../../06.%20Advanced%20Concepts/03.%20Thread%20Safety.md)
