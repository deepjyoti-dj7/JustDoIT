# üîÆ Future Pattern

## üìñ What is the Future Pattern?

A concurrency pattern that represents a placeholder for a result that will be available in the future. It allows asynchronous computation.

**Key Concepts:**
- Non-blocking calls
- Deferred result retrieval
- Composition of async operations
- Exception handling

---

## üíª Example 1: Basic Future Implementation

```java
import java.util.concurrent.*;

class SimpleFuture<T> {
    private T result;
    private Exception exception;
    private boolean isDone = false;
    private final CountDownLatch latch = new CountDownLatch(1);
    
    public void complete(T result) {
        this.result = result;
        this.isDone = true;
        latch.countDown();
    }
    
    public void completeExceptionally(Exception exception) {
        this.exception = exception;
        this.isDone = true;
        latch.countDown();
    }
    
    public T get() throws InterruptedException, ExecutionException {
        latch.await();
        if (exception != null) {
            throw new ExecutionException(exception);
        }
        return result;
    }
    
    public T get(long timeout, TimeUnit unit) 
            throws InterruptedException, ExecutionException, TimeoutException {
        if (!latch.await(timeout, unit)) {
            throw new TimeoutException();
        }
        if (exception != null) {
            throw new ExecutionException(exception);
        }
        return result;
    }
    
    public boolean isDone() {
        return isDone;
    }
    
    public static void main(String[] args) throws Exception {
        SimpleFuture<String> future = new SimpleFuture<>();
        
        // Start async computation
        new Thread(() -> {
            try {
                System.out.println("Computing...");
                Thread.sleep(2000);
                future.complete("Result: 42");
            } catch (InterruptedException e) {
                future.completeExceptionally(e);
            }
        }).start();
        
        System.out.println("Doing other work...");
        Thread.sleep(500);
        
        System.out.println("Getting result: " + future.get());
    }
}
```

---

## üíª Example 2: Callable with Future

```java
import java.util.concurrent.*;

class CallableFutureExample {
    static class DataFetcher implements Callable<String> {
        private final String url;
        
        DataFetcher(String url) {
            this.url = url;
        }
        
        @Override
        public String call() throws Exception {
            System.out.println(Thread.currentThread().getName() + 
                              " fetching from " + url);
            Thread.sleep(2000); // Simulate network delay
            return "Data from " + url;
        }
    }
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit multiple async tasks
        Future<String> future1 = executor.submit(new DataFetcher("api1.com"));
        Future<String> future2 = executor.submit(new DataFetcher("api2.com"));
        Future<String> future3 = executor.submit(new DataFetcher("api3.com"));
        
        System.out.println("All tasks submitted, doing other work...");
        
        try {
            // Get results (blocks if not ready)
            System.out.println(future1.get());
            System.out.println(future2.get());
            System.out.println(future3.get());
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        
        executor.shutdown();
    }
}
```

---

## üíª Example 3: CompletableFuture Chaining

```java
import java.util.concurrent.*;

class CompletableFutureChaining {
    static CompletableFuture<Integer> fetchUserId(String username) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching user ID for " + username);
            sleep(1000);
            return 123;
        });
    }
    
    static CompletableFuture<String> fetchUserDetails(int userId) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("Fetching details for user " + userId);
            sleep(1000);
            return "User[id=" + userId + ", name=John]";
        });
    }
    
    static CompletableFuture<String> formatUser(String details) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("Formatting: " + details);
            sleep(500);
            return details.toUpperCase();
        });
    }
    
    static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static void main(String[] args) throws Exception {
        // Chain async operations
        CompletableFuture<String> result = fetchUserId("alice")
            .thenCompose(userId -> fetchUserDetails(userId))
            .thenCompose(details -> formatUser(details))
            .thenApply(formatted -> "Final: " + formatted);
        
        System.out.println("Pipeline started...");
        
        // Get final result
        System.out.println(result.get());
    }
}
```

---

## üíª Example 4: Combining Multiple Futures

```java
import java.util.concurrent.*;

class CombiningFutures {
    static int fetchPrice(String product) {
        System.out.println("Fetching price for " + product);
        sleep(1000);
        return (int) (Math.random() * 100);
    }
    
    static int fetchStock(String product) {
        System.out.println("Fetching stock for " + product);
        sleep(1000);
        return (int) (Math.random() * 50);
    }
    
    static String fetchDescription(String product) {
        System.out.println("Fetching description for " + product);
        sleep(1000);
        return "Description of " + product;
    }
    
    static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static void main(String[] args) throws Exception {
        String product = "Laptop";
        
        // Start all operations in parallel
        CompletableFuture<Integer> priceFuture = 
            CompletableFuture.supplyAsync(() -> fetchPrice(product));
        
        CompletableFuture<Integer> stockFuture = 
            CompletableFuture.supplyAsync(() -> fetchStock(product));
        
        CompletableFuture<String> descFuture = 
            CompletableFuture.supplyAsync(() -> fetchDescription(product));
        
        // Combine all results
        CompletableFuture<String> combined = priceFuture
            .thenCombine(stockFuture, (price, stock) -> 
                "Price: $" + price + ", Stock: " + stock)
            .thenCombine(descFuture, (priceStock, desc) -> 
                priceStock + ", " + desc);
        
        System.out.println("All fetches started in parallel...");
        System.out.println(combined.get());
    }
}
```

---

## üíª Example 5: Error Handling in Futures

```java
import java.util.concurrent.*;

class FutureErrorHandling {
    static CompletableFuture<Integer> riskyOperation(int input) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("Processing " + input);
            sleep(1000);
            
            if (input < 0) {
                throw new IllegalArgumentException("Negative input: " + input);
            }
            return input * 2;
        });
    }
    
    static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static void main(String[] args) {
        // Handle exceptions with exceptionally
        CompletableFuture<Integer> result1 = riskyOperation(-5)
            .exceptionally(ex -> {
                System.out.println("Error: " + ex.getMessage());
                return 0; // Default value
            });
        
        System.out.println("Result1: " + result1.join());
        
        // Handle both success and failure with handle
        CompletableFuture<String> result2 = riskyOperation(10)
            .handle((value, ex) -> {
                if (ex != null) {
                    return "Failed: " + ex.getMessage();
                }
                return "Success: " + value;
            });
        
        System.out.println("Result2: " + result2.join());
        
        // Try-catch style with whenComplete
        riskyOperation(5)
            .whenComplete((value, ex) -> {
                if (ex != null) {
                    System.out.println("Exception occurred: " + ex.getMessage());
                } else {
                    System.out.println("Completed with value: " + value);
                }
            })
            .join();
    }
}
```

---

## üíª Example 6: Timeout with Future

```java
import java.util.concurrent.*;

class FutureTimeout {
    static String slowOperation() {
        try {
            System.out.println("Starting slow operation...");
            Thread.sleep(5000);
            return "Completed";
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Approach 1: Future.get with timeout
        Future<String> future1 = executor.submit(() -> slowOperation());
        try {
            String result = future1.get(2, TimeUnit.SECONDS);
            System.out.println("Result: " + result);
        } catch (TimeoutException e) {
            System.out.println("Operation timed out!");
            future1.cancel(true);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        
        // Approach 2: CompletableFuture with timeout (Java 9+)
        CompletableFuture<String> future2 = CompletableFuture
            .supplyAsync(() -> slowOperation())
            .orTimeout(2, TimeUnit.SECONDS)
            .exceptionally(ex -> {
                System.out.println("Timed out: " + ex.getMessage());
                return "Default value";
            });
        
        System.out.println("Result2: " + future2.join());
        
        executor.shutdown();
    }
}
```

---

## üíª Example 7: Future Pool Pattern

```java
import java.util.*;
import java.util.concurrent.*;

class FuturePool {
    private final ExecutorService executor;
    private final List<Future<?>> futures = new ArrayList<>();
    
    public FuturePool(int poolSize) {
        this.executor = Executors.newFixedThreadPool(poolSize);
    }
    
    public <T> Future<T> submit(Callable<T> task) {
        Future<T> future = executor.submit(task);
        futures.add(future);
        return future;
    }
    
    public void waitAll() throws InterruptedException, ExecutionException {
        System.out.println("Waiting for " + futures.size() + " tasks...");
        for (Future<?> future : futures) {
            future.get(); // Block until complete
        }
        System.out.println("All tasks completed!");
    }
    
    public void waitAny() throws InterruptedException, ExecutionException {
        System.out.println("Waiting for any task to complete...");
        while (true) {
            for (Future<?> future : futures) {
                if (future.isDone()) {
                    System.out.println("A task completed!");
                    return;
                }
            }
            Thread.sleep(100);
        }
    }
    
    public void cancelAll() {
        System.out.println("Cancelling all tasks...");
        futures.forEach(f -> f.cancel(true));
    }
    
    public void shutdown() {
        executor.shutdown();
    }
    
    public static void main(String[] args) throws Exception {
        FuturePool pool = new FuturePool(3);
        
        // Submit multiple tasks
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            pool.submit(() -> {
                System.out.println("Task-" + taskId + " starting");
                Thread.sleep(taskId * 1000);
                System.out.println("Task-" + taskId + " completed");
                return taskId;
            });
        }
        
        // Wait for first completion
        pool.waitAny();
        
        // Wait for all
        pool.waitAll();
        
        pool.shutdown();
    }
}
```

---

## üíª Example 8: Async Result Cache

```java
import java.util.concurrent.*;

class AsyncCache<K, V> {
    private final ConcurrentHashMap<K, CompletableFuture<V>> cache = 
        new ConcurrentHashMap<>();
    
    public CompletableFuture<V> get(K key, Callable<V> loader) {
        return cache.computeIfAbsent(key, k -> 
            CompletableFuture.supplyAsync(() -> {
                try {
                    System.out.println("Computing value for " + key);
                    return loader.call();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            })
        );
    }
    
    public void invalidate(K key) {
        cache.remove(key);
    }
    
    public static void main(String[] args) throws Exception {
        AsyncCache<String, String> cache = new AsyncCache<>();
        
        // Multiple threads request same key
        CompletableFuture<String> f1 = cache.get("user:123", () -> {
            Thread.sleep(2000);
            return "User Data";
        });
        
        CompletableFuture<String> f2 = cache.get("user:123", () -> {
            throw new RuntimeException("Should not be called!");
        });
        
        CompletableFuture<String> f3 = cache.get("user:456", () -> {
            Thread.sleep(1000);
            return "Another User";
        });
        
        System.out.println("Result1: " + f1.get());
        System.out.println("Result2: " + f2.get()); // Uses cached future
        System.out.println("Result3: " + f3.get());
    }
}
```

---

## üìä Future vs CompletableFuture

| Feature | Future | CompletableFuture |
|---------|--------|-------------------|
| **Chaining** | ‚ùå No | ‚úÖ Yes |
| **Combining** | ‚ùå Manual | ‚úÖ Built-in |
| **Error Handling** | ‚ùå Limited | ‚úÖ Rich |
| **Completion** | ‚ùå Cannot set | ‚úÖ Can complete manually |
| **Non-blocking** | ‚ùå No | ‚úÖ Yes |

---

## üí° Best Practices

1. ‚úÖ Use CompletableFuture for complex async workflows
2. ‚úÖ Always handle exceptions in async code
3. ‚úÖ Set timeouts to prevent hanging
4. ‚úÖ Use thenCompose for dependent operations
5. ‚úÖ Use thenCombine for parallel operations
6. ‚úÖ Don't block on futures in callbacks

---

## üéØ Interview Questions

1. **What is the Future pattern?**
2. **Difference between Future and CompletableFuture?**
3. **How to combine multiple futures?**
4. **How to handle timeouts in futures?**
5. **What is thenCompose vs thenCombine?**

---

## üìö Related Topics

- [Callable & Future](../../04.%20Executor%20Framework/03.%20Callable%20%26%20Future.md)
- [CompletableFuture](../../04.%20Executor%20Framework/04.%20CompletableFuture.md)
