# üèä Thread Pool Pattern

## üìñ What is Thread Pool Pattern?

A design pattern that maintains a pool of reusable worker threads to execute tasks, avoiding the overhead of thread creation/destruction.

**Benefits:**
- Reduces thread creation overhead
- Controls resource usage
- Improves response time
- Better task management

---

## üíª Example 1: Basic Custom Thread Pool

```java
import java.util.concurrent.*;

class SimpleThreadPool {
    private final BlockingQueue<Runnable> taskQueue;
    private final Thread[] workers;
    private volatile boolean shutdown = false;
    
    public SimpleThreadPool(int poolSize, int queueCapacity) {
        taskQueue = new LinkedBlockingQueue<>(queueCapacity);
        workers = new Thread[poolSize];
        
        for (int i = 0; i < poolSize; i++) {
            workers[i] = new Thread(new Worker(), "Worker-" + i);
            workers[i].start();
        }
    }
    
    public void submit(Runnable task) throws InterruptedException {
        if (shutdown) {
            throw new IllegalStateException("Pool is shutdown");
        }
        taskQueue.put(task);
    }
    
    public void shutdown() {
        shutdown = true;
        for (Thread worker : workers) {
            worker.interrupt();
        }
    }
    
    private class Worker implements Runnable {
        @Override
        public void run() {
            while (!shutdown) {
                try {
                    Runnable task = taskQueue.take();
                    System.out.println(Thread.currentThread().getName() + 
                                      " executing task");
                    task.run();
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() + 
                                      " interrupted");
                    break;
                }
            }
            System.out.println(Thread.currentThread().getName() + " stopped");
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        SimpleThreadPool pool = new SimpleThreadPool(3, 10);
        
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            pool.submit(() -> {
                System.out.println("Task-" + taskId + " running");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task-" + taskId + " completed");
            });
        }
        
        Thread.sleep(5000);
        pool.shutdown();
    }
}
```

---

## üíª Example 2: Dynamic Thread Pool

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class DynamicThreadPool {
    private final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<>();
    private final CopyOnWriteArrayList<WorkerThread> workers = new CopyOnWriteArrayList<>();
    private final int minThreads;
    private final int maxThreads;
    private final AtomicInteger activeThreads = new AtomicInteger(0);
    private volatile boolean shutdown = false;
    
    public DynamicThreadPool(int minThreads, int maxThreads) {
        this.minThreads = minThreads;
        this.maxThreads = maxThreads;
        
        // Start minimum threads
        for (int i = 0; i < minThreads; i++) {
            addWorker();
        }
    }
    
    private void addWorker() {
        if (workers.size() < maxThreads) {
            WorkerThread worker = new WorkerThread();
            workers.add(worker);
            worker.start();
            System.out.println("Added worker. Total: " + workers.size());
        }
    }
    
    public void execute(Runnable task) {
        if (shutdown) {
            throw new RejectedExecutionException("Pool is shutdown");
        }
        
        taskQueue.offer(task);
        
        // Add worker if queue is growing and under max
        if (taskQueue.size() > workers.size() && workers.size() < maxThreads) {
            addWorker();
        }
    }
    
    public void shutdown() {
        shutdown = true;
        workers.forEach(Thread::interrupt);
    }
    
    class WorkerThread extends Thread {
        @Override
        public void run() {
            System.out.println(getName() + " started");
            
            while (!shutdown) {
                try {
                    Runnable task = taskQueue.poll(1, TimeUnit.SECONDS);
                    if (task != null) {
                        activeThreads.incrementAndGet();
                        task.run();
                        activeThreads.decrementAndGet();
                    } else if (workers.size() > minThreads) {
                        // No tasks, can exit if above minimum
                        workers.remove(this);
                        System.out.println(getName() + " exiting. Total: " + workers.size());
                        break;
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
            
            System.out.println(getName() + " stopped");
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        DynamicThreadPool pool = new DynamicThreadPool(2, 5);
        
        // Submit burst of tasks
        for (int i = 1; i <= 15; i++) {
            final int taskId = i;
            pool.execute(() -> {
                System.out.println("Task-" + taskId + " executing");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            Thread.sleep(100);
        }
        
        Thread.sleep(20000);
        pool.shutdown();
    }
}
```

---

## üíª Example 3: Priority Thread Pool

```java
import java.util.concurrent.*;

class PriorityThreadPool {
    private final BlockingQueue<PriorityTask> taskQueue = 
        new PriorityBlockingQueue<>();
    private final Thread[] workers;
    private volatile boolean shutdown = false;
    
    static class PriorityTask implements Comparable<PriorityTask> {
        private final Runnable task;
        private final int priority;
        private final long timestamp;
        
        public PriorityTask(Runnable task, int priority) {
            this.task = task;
            this.priority = priority;
            this.timestamp = System.nanoTime();
        }
        
        @Override
        public int compareTo(PriorityTask other) {
            int priorityCompare = Integer.compare(other.priority, this.priority);
            if (priorityCompare != 0) {
                return priorityCompare;
            }
            return Long.compare(this.timestamp, other.timestamp);
        }
    }
    
    public PriorityThreadPool(int poolSize) {
        workers = new Thread[poolSize];
        for (int i = 0; i < poolSize; i++) {
            workers[i] = new Thread(new Worker(), "Worker-" + i);
            workers[i].start();
        }
    }
    
    public void submit(Runnable task, int priority) {
        if (shutdown) {
            throw new RejectedExecutionException("Pool is shutdown");
        }
        taskQueue.offer(new PriorityTask(task, priority));
    }
    
    public void shutdown() {
        shutdown = true;
        for (Thread worker : workers) {
            worker.interrupt();
        }
    }
    
    private class Worker implements Runnable {
        @Override
        public void run() {
            while (!shutdown) {
                try {
                    PriorityTask priorityTask = taskQueue.take();
                    System.out.println(Thread.currentThread().getName() + 
                                      " executing priority-" + priorityTask.priority + " task");
                    priorityTask.task.run();
                } catch (InterruptedException e) {
                    break;
                }
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        PriorityThreadPool pool = new PriorityThreadPool(2);
        
        // Submit tasks with different priorities
        pool.submit(() -> System.out.println("LOW priority task"), 1);
        pool.submit(() -> System.out.println("HIGH priority task"), 10);
        pool.submit(() -> System.out.println("MEDIUM priority task"), 5);
        pool.submit(() -> System.out.println("HIGH priority task 2"), 10);
        pool.submit(() -> System.out.println("LOW priority task 2"), 1);
        
        Thread.sleep(2000);
        pool.shutdown();
    }
}
```

---

## üíª Example 4: Scheduled Thread Pool

```java
import java.util.concurrent.*;

class SimpleScheduledPool {
    private final PriorityBlockingQueue<ScheduledTask> taskQueue = 
        new PriorityBlockingQueue<>();
    private final Thread scheduler;
    private final ExecutorService executor;
    private volatile boolean shutdown = false;
    
    static class ScheduledTask implements Comparable<ScheduledTask> {
        final Runnable task;
        final long executeAt;
        final long period;
        
        ScheduledTask(Runnable task, long delay, long period, TimeUnit unit) {
            this.task = task;
            this.executeAt = System.nanoTime() + unit.toNanos(delay);
            this.period = unit.toNanos(period);
        }
        
        @Override
        public int compareTo(ScheduledTask other) {
            return Long.compare(this.executeAt, other.executeAt);
        }
    }
    
    public SimpleScheduledPool(int poolSize) {
        executor = Executors.newFixedThreadPool(poolSize);
        scheduler = new Thread(this::runScheduler, "Scheduler");
        scheduler.start();
    }
    
    public void schedule(Runnable task, long delay, TimeUnit unit) {
        taskQueue.offer(new ScheduledTask(task, delay, 0, unit));
    }
    
    public void scheduleAtFixedRate(Runnable task, long initialDelay, 
                                    long period, TimeUnit unit) {
        taskQueue.offer(new ScheduledTask(task, initialDelay, period, unit));
    }
    
    private void runScheduler() {
        while (!shutdown) {
            try {
                ScheduledTask task = taskQueue.take();
                long delay = task.executeAt - System.nanoTime();
                
                if (delay > 0) {
                    taskQueue.offer(task); // Put back
                    Thread.sleep(delay / 1_000_000);
                } else {
                    executor.submit(task.task);
                    
                    // Reschedule if periodic
                    if (task.period > 0) {
                        taskQueue.offer(new ScheduledTask(
                            task.task, 
                            task.period, 
                            task.period, 
                            TimeUnit.NANOSECONDS
                        ));
                    }
                }
            } catch (InterruptedException e) {
                break;
            }
        }
    }
    
    public void shutdown() {
        shutdown = true;
        scheduler.interrupt();
        executor.shutdown();
    }
    
    public static void main(String[] args) throws InterruptedException {
        SimpleScheduledPool pool = new SimpleScheduledPool(2);
        
        // One-time task
        pool.schedule(() -> System.out.println("One-time task executed"), 
                     2, TimeUnit.SECONDS);
        
        // Periodic task
        pool.scheduleAtFixedRate(() -> 
            System.out.println("Periodic task at " + System.currentTimeMillis()), 
            1, 2, TimeUnit.SECONDS);
        
        Thread.sleep(10000);
        pool.shutdown();
    }
}
```

---

## üíª Example 5: Work-Stealing Pool

```java
import java.util.concurrent.*;
import java.util.*;

class WorkStealingPool {
    private final List<WorkerThread> workers;
    private final int poolSize;
    private volatile boolean shutdown = false;
    
    static class WorkerThread extends Thread {
        final Deque<Runnable> taskQueue = new ConcurrentLinkedDeque<>();
        final WorkStealingPool pool;
        
        WorkerThread(WorkStealingPool pool, int id) {
            super("Worker-" + id);
            this.pool = pool;
        }
        
        @Override
        public void run() {
            while (!pool.shutdown) {
                Runnable task = taskQueue.pollFirst();
                
                if (task == null) {
                    task = stealTask();
                }
                
                if (task != null) {
                    System.out.println(getName() + " executing task");
                    task.run();
                } else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        break;
                    }
                }
            }
        }
        
        private Runnable stealTask() {
            for (WorkerThread worker : pool.workers) {
                if (worker != this) {
                    Runnable task = worker.taskQueue.pollLast();
                    if (task != null) {
                        System.out.println(getName() + " stole task from " + 
                                          worker.getName());
                        return task;
                    }
                }
            }
            return null;
        }
    }
    
    public WorkStealingPool(int poolSize) {
        this.poolSize = poolSize;
        workers = new ArrayList<>();
        
        for (int i = 0; i < poolSize; i++) {
            WorkerThread worker = new WorkerThread(this, i);
            workers.add(worker);
            worker.start();
        }
    }
    
    public void submit(Runnable task) {
        // Submit to least loaded worker
        WorkerThread minWorker = workers.get(0);
        for (WorkerThread worker : workers) {
            if (worker.taskQueue.size() < minWorker.taskQueue.size()) {
                minWorker = worker;
            }
        }
        minWorker.taskQueue.offerFirst(task);
    }
    
    public void shutdown() {
        shutdown = true;
        workers.forEach(Thread::interrupt);
    }
    
    public static void main(String[] args) throws InterruptedException {
        WorkStealingPool pool = new WorkStealingPool(3);
        
        // Submit many tasks to first worker (unbalanced)
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            pool.workers.get(0).taskQueue.offer(() -> {
                System.out.println("Task-" + taskId + " running");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        Thread.sleep(6000);
        pool.shutdown();
    }
}
```

---

## üíª Example 6: Cached Thread Pool Implementation

```java
import java.util.concurrent.*;
import java.util.*;

class CachedThreadPool {
    private final Set<WorkerThread> workers = ConcurrentHashMap.newKeySet();
    private final BlockingQueue<Runnable> taskQueue = new SynchronousQueue<>();
    private final long keepAliveTime;
    private volatile boolean shutdown = false;
    
    public CachedThreadPool(long keepAliveTime, TimeUnit unit) {
        this.keepAliveTime = unit.toMillis(keepAliveTime);
    }
    
    public void execute(Runnable task) {
        if (shutdown) {
            throw new RejectedExecutionException("Pool is shutdown");
        }
        
        // Try to hand off to existing worker
        if (!taskQueue.offer(task)) {
            // No idle worker, create new one
            WorkerThread worker = new WorkerThread(task);
            workers.add(worker);
            worker.start();
            System.out.println("Created new worker. Total: " + workers.size());
        }
    }
    
    public void shutdown() {
        shutdown = true;
        workers.forEach(Thread::interrupt);
    }
    
    class WorkerThread extends Thread {
        WorkerThread(Runnable firstTask) {
            super();
            // Execute first task immediately
            new Thread(() -> {
                firstTask.run();
                run();
            }).start();
        }
        
        @Override
        public void run() {
            try {
                while (!shutdown) {
                    Runnable task = taskQueue.poll(keepAliveTime, TimeUnit.MILLISECONDS);
                    if (task != null) {
                        task.run();
                    } else {
                        // Timeout, exit
                        workers.remove(this);
                        System.out.println(getName() + " timed out. Total: " + 
                                          workers.size());
                        break;
                    }
                }
            } catch (InterruptedException e) {
                workers.remove(this);
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        CachedThreadPool pool = new CachedThreadPool(2, TimeUnit.SECONDS);
        
        // Burst of tasks
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            pool.execute(() -> {
                System.out.println("Task-" + taskId + " running");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        
        Thread.sleep(1000);
        
        // More tasks after delay
        for (int i = 6; i <= 8; i++) {
            final int taskId = i;
            pool.execute(() -> {
                System.out.println("Task-" + taskId + " running");
            });
        }
        
        Thread.sleep(5000);
        pool.shutdown();
    }
}
```

---

## üìä Thread Pool Types Comparison

| Pool Type | Use Case | Min Threads | Max Threads | Queue |
|-----------|----------|-------------|-------------|-------|
| **Fixed** | Stable load | N | N | Unbounded |
| **Cached** | Bursty load | 0 | Unlimited | Synchronous |
| **Single** | Sequential | 1 | 1 | Unbounded |
| **Scheduled** | Delayed/periodic | Core | Max | Delayed |
| **Work-Stealing** | Recursive tasks | N | N | Per-thread deque |

---

## üí° Best Practices

1. ‚úÖ Size pool based on workload (CPU-bound vs I/O-bound)
2. ‚úÖ Use bounded queues to prevent memory issues
3. ‚úÖ Implement proper rejection policy
4. ‚úÖ Always shutdown pools gracefully
5. ‚úÖ Monitor pool metrics (queue size, active threads)
6. ‚úÖ Use appropriate pool type for workload

---

## üéØ Interview Questions

1. **What is a thread pool? Why use it?**
2. **How to size a thread pool?**
3. **What is work-stealing?**
4. **Difference between fixed and cached thread pool?**
5. **Implement a simple thread pool**

---

## üìö Related Topics

- [Thread Pools](../../04.%20Executor%20Framework/02.%20Thread%20Pools.md)
- [ForkJoinPool](../../04.%20Executor%20Framework/06.%20ForkJoinPool.md)
