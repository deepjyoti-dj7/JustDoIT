# ðŸ“š Reader-Writer Problem

## ðŸ“– What is the Reader-Writer Problem?

A classic synchronization problem where:
- **Multiple readers** can read simultaneously
- **Only one writer** can write at a time
- **Writers have exclusive access** (no readers or writers)

**Key Challenges:**
- Reader starvation
- Writer starvation
- Performance vs fairness

---

## ðŸ’» Example 1: Basic ReadWriteLock

```java
import java.util.concurrent.locks.*;

class SharedResource {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private String data = "Initial Data";
    
    public String read() {
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " reading: " + data);
            Thread.sleep(1000); // Simulate read time
            return data;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void write(String newData) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + newData);
            Thread.sleep(2000); // Simulate write time
            data = newData;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        // Multiple readers
        for (int i = 1; i <= 3; i++) {
            new Thread(() -> resource.read(), "Reader-" + i).start();
        }
        
        // One writer
        new Thread(() -> resource.write("Updated Data"), "Writer-1").start();
        
        // More readers
        for (int i = 4; i <= 6; i++) {
            new Thread(() -> resource.read(), "Reader-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 2: Fair ReadWriteLock

```java
import java.util.concurrent.locks.*;

class FairReadWrite {
    private final ReadWriteLock lock = new ReentrantReadWriteLock(true); // Fair mode
    private int value = 0;
    
    public int read() {
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " read: " + value);
            return value;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void write(int newValue) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + newValue);
            Thread.sleep(100);
            value = newValue;
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        FairReadWrite rw = new FairReadWrite();
        
        // Start readers and writers alternately
        for (int i = 0; i < 10; i++) {
            final int num = i;
            if (i % 3 == 0) {
                new Thread(() -> rw.write(num), "Writer-" + i).start();
            } else {
                new Thread(() -> rw.read(), "Reader-" + i).start();
            }
            Thread.sleep(50);
        }
    }
}
```

---

## ðŸ’» Example 3: Custom Reader-Writer with Semaphores

```java
import java.util.concurrent.Semaphore;

class CustomReaderWriter {
    private int readers = 0;
    private final Semaphore mutex = new Semaphore(1); // Protects readers count
    private final Semaphore writeLock = new Semaphore(1); // Exclusive write access
    private String data = "Initial";
    
    public String read() throws InterruptedException {
        // Entry section
        mutex.acquire();
        readers++;
        if (readers == 1) {
            writeLock.acquire(); // First reader blocks writers
        }
        mutex.release();
        
        // Critical section
        System.out.println(Thread.currentThread().getName() + " reading: " + data);
        Thread.sleep(500);
        String result = data;
        
        // Exit section
        mutex.acquire();
        readers--;
        if (readers == 0) {
            writeLock.release(); // Last reader unblocks writers
        }
        mutex.release();
        
        return result;
    }
    
    public void write(String newData) throws InterruptedException {
        writeLock.acquire();
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + newData);
            Thread.sleep(1000);
            data = newData;
        } finally {
            writeLock.release();
        }
    }
    
    public static void main(String[] args) {
        CustomReaderWriter rw = new CustomReaderWriter();
        
        for (int i = 1; i <= 5; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    rw.read();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Reader-" + i).start();
        }
        
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    rw.write("Data-" + id);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Writer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 4: Cache with Read-Write Locking

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.*;

class ThreadSafeCache<K, V> {
    private final Map<K, V> cache = new HashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public V get(K key) {
        lock.readLock().lock();
        try {
            V value = cache.get(key);
            System.out.println(Thread.currentThread().getName() + 
                              " GET " + key + " = " + value);
            return value;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public void put(K key, V value) {
        lock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + 
                              " PUT " + key + " = " + value);
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public V computeIfAbsent(K key, Function<K, V> mappingFunction) {
        // First try optimistic read
        lock.readLock().lock();
        try {
            V value = cache.get(key);
            if (value != null) {
                return value;
            }
        } finally {
            lock.readLock().unlock();
        }
        
        // Need to write
        lock.writeLock().lock();
        try {
            // Double-check
            V value = cache.get(key);
            if (value == null) {
                value = mappingFunction.apply(key);
                cache.put(key, value);
            }
            return value;
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        ThreadSafeCache<String, Integer> cache = new ThreadSafeCache<>();
        
        // Writers
        new Thread(() -> cache.put("A", 1), "Writer-1").start();
        new Thread(() -> cache.put("B", 2), "Writer-2").start();
        
        // Readers
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                cache.get("A");
                cache.get("B");
            }, "Reader-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 5: Writer-Preference Solution

```java
import java.util.concurrent.locks.*;

class WriterPreference {
    private final Lock lock = new ReentrantLock();
    private final Condition readers = lock.newCondition();
    private final Condition writers = lock.newCondition();
    
    private int activeReaders = 0;
    private int waitingWriters = 0;
    private boolean activeWriter = false;
    private String data = "Initial";
    
    public String read() throws InterruptedException {
        lock.lock();
        try {
            // Wait if writer is active or waiting
            while (activeWriter || waitingWriters > 0) {
                readers.await();
            }
            
            activeReaders++;
            System.out.println(Thread.currentThread().getName() + 
                              " started reading. Active readers: " + activeReaders);
        } finally {
            lock.unlock();
        }
        
        // Read (outside lock)
        String result = data;
        Thread.sleep(500);
        System.out.println(Thread.currentThread().getName() + " read: " + result);
        
        lock.lock();
        try {
            activeReaders--;
            if (activeReaders == 0) {
                writers.signal(); // Wake up waiting writers
            }
        } finally {
            lock.unlock();
        }
        
        return result;
    }
    
    public void write(String newData) throws InterruptedException {
        lock.lock();
        try {
            waitingWriters++;
            while (activeReaders > 0 || activeWriter) {
                writers.await();
            }
            waitingWriters--;
            activeWriter = true;
            System.out.println(Thread.currentThread().getName() + " started writing");
        } finally {
            lock.unlock();
        }
        
        // Write (outside lock)
        Thread.sleep(1000);
        data = newData;
        System.out.println(Thread.currentThread().getName() + " wrote: " + newData);
        
        lock.lock();
        try {
            activeWriter = false;
            if (waitingWriters > 0) {
                writers.signal(); // Wake up next writer
            } else {
                readers.signalAll(); // Wake up all readers
            }
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        WriterPreference wp = new WriterPreference();
        
        // Start many readers
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                try {
                    wp.read();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Reader-" + i).start();
        }
        
        Thread.sleep(100);
        
        // Start writers (should get preference)
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    wp.write("Update-" + id);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Writer-" + i).start();
        }
        
        // More readers
        for (int i = 6; i <= 10; i++) {
            new Thread(() -> {
                try {
                    wp.read();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Reader-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 6: StampedLock Optimistic Read

```java
import java.util.concurrent.locks.StampedLock;

class OptimisticReadExample {
    private final StampedLock lock = new StampedLock();
    private double x, y;
    
    public void move(double deltaX, double deltaY) {
        long stamp = lock.writeLock();
        try {
            x += deltaX;
            y += deltaY;
            System.out.println(Thread.currentThread().getName() + 
                              " moved to (" + x + ", " + y + ")");
        } finally {
            lock.unlockWrite(stamp);
        }
    }
    
    public double distanceFromOrigin() {
        long stamp = lock.tryOptimisticRead();
        double currentX = x;
        double currentY = y;
        
        if (!lock.validate(stamp)) {
            // Data changed, upgrade to read lock
            stamp = lock.readLock();
            try {
                currentX = x;
                currentY = y;
                System.out.println(Thread.currentThread().getName() + 
                                  " upgraded to read lock");
            } finally {
                lock.unlockRead(stamp);
            }
        } else {
            System.out.println(Thread.currentThread().getName() + 
                              " optimistic read succeeded");
        }
        
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
    
    public static void main(String[] args) {
        OptimisticReadExample point = new OptimisticReadExample();
        
        // Readers using optimistic locking
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    double dist = point.distanceFromOrigin();
                    System.out.println(Thread.currentThread().getName() + 
                                      " distance: " + dist);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "Reader-" + i).start();
        }
        
        // Writers
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                for (int j = 0; j < 3; j++) {
                    point.move(id, id);
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "Writer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 7: Database Connection Pool

```java
import java.util.*;
import java.util.concurrent.locks.*;

class ConnectionPool {
    private final List<Connection> connections = new ArrayList<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    
    static class Connection {
        private final int id;
        private boolean inUse = false;
        
        Connection(int id) {
            this.id = id;
        }
        
        @Override
        public String toString() {
            return "Connection-" + id;
        }
    }
    
    public ConnectionPool(int size) {
        for (int i = 1; i <= size; i++) {
            connections.add(new Connection(i));
        }
    }
    
    public Connection acquire() throws InterruptedException {
        // Try optimistic read first
        lock.readLock().lock();
        try {
            for (Connection conn : connections) {
                if (!conn.inUse) {
                    // Found available, upgrade to write lock
                    lock.readLock().unlock();
                    lock.writeLock().lock();
                    try {
                        // Double-check
                        if (!conn.inUse) {
                            conn.inUse = true;
                            System.out.println(Thread.currentThread().getName() + 
                                              " acquired " + conn);
                            return conn;
                        }
                    } finally {
                        lock.writeLock().unlock();
                        lock.readLock().lock();
                    }
                }
            }
        } finally {
            lock.readLock().unlock();
        }
        
        System.out.println(Thread.currentThread().getName() + " waiting for connection...");
        Thread.sleep(1000);
        return acquire(); // Retry
    }
    
    public void release(Connection conn) {
        lock.writeLock().lock();
        try {
            conn.inUse = false;
            System.out.println(Thread.currentThread().getName() + 
                              " released " + conn);
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public void printStatus() {
        lock.readLock().lock();
        try {
            long inUse = connections.stream().filter(c -> c.inUse).count();
            System.out.println("Pool status: " + inUse + "/" + 
                              connections.size() + " in use");
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        ConnectionPool pool = new ConnectionPool(3);
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                try {
                    Connection conn = pool.acquire();
                    Thread.sleep(2000); // Use connection
                    pool.release(conn);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }, "Client-" + i).start();
        }
        
        // Monitor thread
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                pool.printStatus();
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "Monitor").start();
    }
}
```

---

## ðŸ“Š Solution Comparison

| Approach | Readers Concurrent | Writer Starvation | Reader Starvation | Complexity |
|----------|-------------------|-------------------|-------------------|------------|
| **ReadWriteLock** | âœ… Yes | Possible | No | Low |
| **Fair ReadWriteLock** | âœ… Yes | No | No | Low |
| **Writer Preference** | âœ… Yes | No | Possible | Medium |
| **StampedLock** | âœ… Yes | Possible | No | High |
| **Custom Semaphore** | âœ… Yes | Possible | No | Medium |

---

## âš ï¸ Common Pitfalls

1. **Reader starvation**: Continuous writers block readers
2. **Writer starvation**: Continuous readers block writers
3. **Deadlock**: Incorrect lock upgrade/downgrade
4. **Performance**: Not choosing optimal lock type

---

## ðŸ’¡ Best Practices

1. âœ… Use ReadWriteLock for read-heavy workloads
2. âœ… Use StampedLock for optimistic reads
3. âœ… Consider fairness requirements
4. âœ… Use tryLock with timeout for better responsiveness
5. âœ… Monitor lock contention and adjust strategy

---

## ðŸŽ¯ Interview Questions

1. **What is the reader-writer problem?**
2. **How does ReadWriteLock work?**
3. **What is writer starvation? How to prevent it?**
4. **When to use StampedLock over ReadWriteLock?**
5. **Implement reader-writer using semaphores**

---

## ðŸ“š Related Topics

- [ReadWriteLock](../../02.%20Synchronization/06.%20ReadWriteLock.md)
- [Semaphore](../../03.%20Thread%20Communication/04.%20Semaphore.md)
