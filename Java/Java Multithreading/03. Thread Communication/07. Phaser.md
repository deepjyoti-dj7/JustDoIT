# ğŸ­ Phaser

## ğŸ“– What is Phaser?

A reusable synchronization barrier similar to CyclicBarrier and CountDownLatch, but more flexible. It supports dynamic registration/deregistration of parties and multiple phases.

**Key Features:**
- Dynamic party registration
- Multiple phases
- Reusable
- Termination capability
- Tiered phasing

---

## ğŸ’» Example 1: Basic Phaser

```java
import java.util.concurrent.Phaser;

class BasicPhaserExample {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(1); // Register main thread
        
        System.out.println("Starting phase: " + phaser.getPhase());
        
        // Create 3 worker threads
        for (int i = 1; i <= 3; i++) {
            final int id = i;
            phaser.register(); // Register each thread
            
            new Thread(() -> {
                System.out.println("Thread-" + id + " starting phase " + phaser.getPhase());
                phaser.arriveAndAwaitAdvance(); // Wait for all
                
                System.out.println("Thread-" + id + " in phase " + phaser.getPhase());
                phaser.arriveAndAwaitAdvance();
                
                System.out.println("Thread-" + id + " completed");
                phaser.arriveAndDeregister(); // Deregister
            }).start();
        }
        
        phaser.arriveAndAwaitAdvance(); // Main waits for phase 0
        System.out.println("Phase 0 complete");
        
        phaser.arriveAndAwaitAdvance(); // Main waits for phase 1
        System.out.println("Phase 1 complete");
        
        phaser.arriveAndDeregister(); // Main deregisters
    }
}
```

---

## ğŸ’» Example 2: Multi-Phase Task Processing

```java
import java.util.concurrent.Phaser;

class MultiPhaseProcessor {
    public static void main(String[] args) {
        int workers = 3;
        Phaser phaser = new Phaser(workers);
        
        for (int i = 1; i <= workers; i++) {
            final int workerId = i;
            new Thread(() -> {
                // Phase 1: Initialize
                System.out.println("Worker-" + workerId + ": Initializing");
                sleep(1000);
                System.out.println("Worker-" + workerId + ": Init complete");
                phaser.arriveAndAwaitAdvance();
                
                // Phase 2: Process
                System.out.println("Worker-" + workerId + ": Processing");
                sleep(1500);
                System.out.println("Worker-" + workerId + ": Processing complete");
                phaser.arriveAndAwaitAdvance();
                
                // Phase 3: Finalize
                System.out.println("Worker-" + workerId + ": Finalizing");
                sleep(800);
                System.out.println("Worker-" + workerId + ": Finalize complete");
                phaser.arriveAndAwaitAdvance();
                
                System.out.println("Worker-" + workerId + ": All phases done!");
            }, "Worker-" + workerId).start();
        }
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ğŸ’» Example 3: Dynamic Registration

```java
import java.util.concurrent.Phaser;

class DynamicRegistrationExample {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(1); // Start with main thread
        
        System.out.println("Initial parties: " + phaser.getRegisteredParties());
        
        // Dynamically add threads
        for (int i = 1; i <= 5; i++) {
            final int id = i;
            
            if (i % 2 == 0) {
                // Even threads register dynamically
                new Thread(() -> {
                    phaser.register();
                    System.out.println("Thread-" + id + " dynamically registered. " +
                                      "Parties: " + phaser.getRegisteredParties());
                    
                    sleep(1000);
                    phaser.arriveAndAwaitAdvance();
                    System.out.println("Thread-" + id + " completed phase");
                    
                    phaser.arriveAndDeregister();
                    System.out.println("Thread-" + id + " deregistered. " +
                                      "Parties: " + phaser.getRegisteredParties());
                }).start();
            } else {
                // Odd threads pre-registered
                phaser.register();
                new Thread(() -> {
                    System.out.println("Thread-" + id + " starting. " +
                                      "Parties: " + phaser.getRegisteredParties());
                    sleep(1000);
                    phaser.arriveAndAwaitAdvance();
                    System.out.println("Thread-" + id + " completed phase");
                    phaser.arriveAndDeregister();
                }).start();
            }
            
            sleep(200);
        }
        
        phaser.arriveAndDeregister(); // Main deregisters
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ğŸ’» Example 4: Phaser with onAdvance()

```java
import java.util.concurrent.Phaser;

class CustomPhaser extends Phaser {
    private int maxPhases;
    
    public CustomPhaser(int parties, int maxPhases) {
        super(parties);
        this.maxPhases = maxPhases;
    }
    
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        System.out.println("\n=== Phase " + phase + " completed ===");
        System.out.println("Registered parties: " + registeredParties + "\n");
        
        // Terminate after maxPhases
        return phase >= maxPhases - 1 || registeredParties == 0;
    }
}

class OnAdvanceExample {
    public static void main(String[] args) {
        CustomPhaser phaser = new CustomPhaser(3, 3);
        
        for (int i = 1; i <= 3; i++) {
            final int workerId = i;
            new Thread(() -> {
                for (int phase = 0; phase < 3; phase++) {
                    System.out.println("Worker-" + workerId + 
                                      " working on phase " + phase);
                    sleep(1000);
                    phaser.arriveAndAwaitAdvance();
                }
                System.out.println("Worker-" + workerId + " finished all phases");
            }).start();
        }
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ğŸ’» Example 5: Tiered Phaser

```java
import java.util.concurrent.Phaser;

class TieredPhaserExample {
    public static void main(String[] args) {
        // Main phaser
        Phaser mainPhaser = new Phaser(1);
        
        // Sub-phasers for groups
        Phaser groupA = new Phaser(mainPhaser, 3); // Group A with 3 workers
        Phaser groupB = new Phaser(mainPhaser, 2); // Group B with 2 workers
        
        // Group A workers
        for (int i = 1; i <= 3; i++) {
            final int id = i;
            new Thread(() -> {
                System.out.println("GroupA-Worker-" + id + " working");
                sleep(1000 * id);
                System.out.println("GroupA-Worker-" + id + " done");
                groupA.arriveAndDeregister();
            }).start();
        }
        
        // Group B workers
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                System.out.println("GroupB-Worker-" + id + " working");
                sleep(1000 * id);
                System.out.println("GroupB-Worker-" + id + " done");
                groupB.arriveAndDeregister();
            }).start();
        }
        
        // Wait for all groups to complete
        mainPhaser.arriveAndAwaitAdvance();
        System.out.println("\nAll groups completed!");
        mainPhaser.arriveAndDeregister();
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ğŸ’» Example 6: Arrive Methods Comparison

```java
import java.util.concurrent.Phaser;

class ArriveMethodsExample {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(4);
        
        // arrive() - don't wait
        new Thread(() -> {
            System.out.println("Thread-1: Arriving without waiting");
            int phase = phaser.arrive();
            System.out.println("Thread-1: Returned immediately, phase: " + phase);
        }).start();
        
        // arriveAndAwaitAdvance() - wait
        new Thread(() -> {
            System.out.println("Thread-2: Arriving and waiting");
            int phase = phaser.arriveAndAwaitAdvance();
            System.out.println("Thread-2: Phase advanced to: " + phase);
        }).start();
        
        // arriveAndDeregister() - arrive and leave
        new Thread(() -> {
            System.out.println("Thread-3: Arriving and deregistering");
            int phase = phaser.arriveAndDeregister();
            System.out.println("Thread-3: Deregistered at phase: " + phase);
        }).start();
        
        sleep(1000);
        
        // Main thread
        System.out.println("Main: Arriving and waiting");
        phaser.arriveAndAwaitAdvance();
        System.out.println("Main: Phase complete");
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## ğŸ“Š Comparison with Other Synchronizers

| Feature | Phaser | CyclicBarrier | CountDownLatch |
|---------|--------|---------------|----------------|
| **Reusable** | âœ… Yes | âœ… Yes | âŒ No |
| **Dynamic Parties** | âœ… Yes | âŒ No | âŒ No |
| **Multiple Phases** | âœ… Yes | âŒ No | âŒ No |
| **Termination** | âœ… Yes | âŒ No | âŒ No |
| **Complexity** | High | Medium | Low |

---

## ğŸ’¡ Best Practices

1. âœ… Use for complex multi-phase coordination
2. âœ… Override `onAdvance()` for phase-specific logic
3. âœ… Always deregister when done
4. âœ… Use tiered phasers for hierarchical coordination
5. âœ… Monitor registered parties count

---

## ğŸ¯ Interview Questions

1. **What is Phaser?**
2. **How is Phaser different from CyclicBarrier?**
3. **What is dynamic registration?**
4. **What is the onAdvance() method?**
5. **When would you use Phaser over CyclicBarrier?**
6. **What is a tiered Phaser?**

---

## ğŸ“š Next Topics

- [ExecutorService](../04.%20Executor%20Framework/01.%20ExecutorService.md)
- [Thread Pools](../04.%20Executor%20Framework/02.%20Thread%20Pools.md)
