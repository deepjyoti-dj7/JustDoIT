# ðŸ”— Join Method

## ðŸ“– What is join()?

The `join()` method allows one thread to wait for the completion of another thread.

**Use Cases:**
- Wait for worker threads to complete before continuing
- Ensure dependent tasks finish in order
- Collect results from multiple threads

---

## ðŸ’» Example 1: Basic join()

```java
class JoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread worker = new Thread(() -> {
            System.out.println("Worker started");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Worker finished");
        });
        
        System.out.println("Main: Starting worker");
        worker.start();
        
        System.out.println("Main: Waiting for worker to finish");
        worker.join(); // Wait for worker to complete
        
        System.out.println("Main: Worker completed, continuing");
    }
}
```

**Output:**
```
Main: Starting worker
Worker started
Main: Waiting for worker to finish
Worker finished
Main: Worker completed, continuing
```

---

## ðŸ’» Example 2: Multiple Threads with join()

```java
class MultipleJoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[5];
        
        // Create and start threads
        for (int i = 0; i < 5; i++) {
            final int id = i + 1;
            threads[i] = new Thread(() -> {
                System.out.println("Thread-" + id + " started");
                try {
                    Thread.sleep(1000 * id);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread-" + id + " finished");
            });
            threads[i].start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("All threads completed!");
    }
}
```

---

## ðŸ’» Example 3: join() with Timeout

```java
class JoinTimeoutExample {
    public static void main(String[] args) throws InterruptedException {
        Thread longTask = new Thread(() -> {
            try {
                System.out.println("Long task started");
                Thread.sleep(5000);
                System.out.println("Long task finished");
            } catch (InterruptedException e) {
                System.out.println("Long task interrupted");
            }
        });
        
        longTask.start();
        
        // Wait maximum 2 seconds
        System.out.println("Main: Waiting up to 2 seconds");
        longTask.join(2000);
        
        if (longTask.isAlive()) {
            System.out.println("Main: Task still running after timeout");
            longTask.interrupt();
        } else {
            System.out.println("Main: Task completed within timeout");
        }
    }
}
```

---

## ðŸ’» Example 4: Data Processing Pipeline

```java
import java.util.ArrayList;
import java.util.List;

class DataProcessor {
    private List<Integer> results = new ArrayList<>();
    
    class ProcessorThread extends Thread {
        private int start;
        private int end;
        
        public ProcessorThread(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        @Override
        public void run() {
            System.out.println(getName() + " processing " + start + " to " + end);
            int sum = 0;
            for (int i = start; i <= end; i++) {
                sum += i;
            }
            synchronized (results) {
                results.add(sum);
            }
            System.out.println(getName() + " finished with sum: " + sum);
        }
    }
    
    public void processData() throws InterruptedException {
        ProcessorThread t1 = new ProcessorThread(1, 25);
        ProcessorThread t2 = new ProcessorThread(26, 50);
        ProcessorThread t3 = new ProcessorThread(51, 75);
        ProcessorThread t4 = new ProcessorThread(76, 100);
        
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        
        // Wait for all to complete
        t1.join();
        t2.join();
        t3.join();
        t4.join();
        
        // Calculate final result
        int total = results.stream().mapToInt(Integer::intValue).sum();
        System.out.println("\nTotal sum: " + total);
    }
    
    public static void main(String[] args) throws InterruptedException {
        new DataProcessor().processData();
    }
}
```

---

## ðŸ’» Example 5: Batch Processing

```java
class BatchProcessor {
    public void processBatches() throws InterruptedException {
        Thread downloader = new Thread(() -> {
            System.out.println("Phase 1: Downloading data...");
            sleep(2000);
            System.out.println("Phase 1: Download complete");
        });
        
        Thread validator = new Thread(() -> {
            System.out.println("Phase 2: Validating data...");
            sleep(1500);
            System.out.println("Phase 2: Validation complete");
        });
        
        Thread processor = new Thread(() -> {
            System.out.println("Phase 3: Processing data...");
            sleep(2500);
            System.out.println("Phase 3: Processing complete");
        });
        
        // Sequential execution using join
        downloader.start();
        downloader.join(); // Wait for download
        
        validator.start();
        validator.join(); // Wait for validation
        
        processor.start();
        processor.join(); // Wait for processing
        
        System.out.println("\nAll phases completed successfully!");
    }
    
    private void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        new BatchProcessor().processBatches();
    }
}
```

---

## ðŸ“Š join() vs wait()

| Feature | join() | wait() |
|---------|--------|--------|
| **Purpose** | Wait for thread completion | Wait for notification |
| **Class** | Thread class | Object class |
| **Lock** | No lock needed | Must be in synchronized |
| **Notification** | Auto on thread end | Requires notify() |
| **Timeout** | Yes | Yes |

---

## ðŸ’¡ Best Practices

1. âœ… Use `join()` to ensure dependent tasks complete
2. âœ… Use timeout to avoid indefinite waiting
3. âœ… Check `isAlive()` after timeout
4. âœ… Handle `InterruptedException` properly
5. âœ… Consider `CountDownLatch` for complex coordination

---

## ðŸŽ¯ Interview Questions

1. **What does join() do?**
2. **What happens if you call join() on a thread that hasn't started?**
3. **Can you call join() multiple times?**
4. **What is the difference between join() and wait()?**
5. **What happens if join() times out?**

---

## ðŸ“š Next Topics

- [CountDownLatch](03.%20CountDownLatch.md)
- [CyclicBarrier](04.%20CyclicBarrier.md)
