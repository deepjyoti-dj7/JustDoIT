# ‚è≥ wait(), notify(), notifyAll()

## üìñ Overview

`wait()`, `notify()`, and `notifyAll()` are methods for **inter-thread communication**, allowing threads to coordinate by:
- **wait()**: Release lock and wait for notification
- **notify()**: Wake up one waiting thread
- **notifyAll()**: Wake up all waiting threads

**Key Points:**
- Must be called inside `synchronized` block
- Must be called on the **same object** used for synchronization
- Part of `Object` class (not Thread class)

---

## üéØ Basic Syntax

```java
synchronized (object) {
    while (condition) {
        object.wait(); // Release lock and wait
    }
    // Do work
    object.notify(); // or notifyAll()
}
```

---

## üíª Example 1: Basic wait() and notify()

```java
class SharedResource {
    private boolean ready = false;
    
    public synchronized void waitForReady() {
        System.out.println(Thread.currentThread().getName() + " waiting...");
        
        try {
            while (!ready) {
                wait(); // Release lock and wait
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        System.out.println(Thread.currentThread().getName() + " proceeding");
    }
    
    public synchronized void setReady() {
        System.out.println("Setting ready to true");
        ready = true;
        notify(); // Wake up one waiting thread
    }
    
    public static void main(String[] args) throws InterruptedException {
        SharedResource resource = new SharedResource();
        
        Thread waiter = new Thread(() -> resource.waitForReady(), "Waiter");
        Thread notifier = new Thread(() -> resource.setReady(), "Notifier");
        
        waiter.start();
        Thread.sleep(1000);
        notifier.start();
        
        waiter.join();
        notifier.join();
    }
}
```

**Output:**
```
Waiter waiting...
Setting ready to true
Waiter proceeding
```

---

## üíª Example 2: Producer-Consumer using wait/notify

```java
import java.util.LinkedList;
import java.util.Queue;

class ProducerConsumer {
    private Queue<Integer> queue = new LinkedList<>();
    private final int CAPACITY = 5;
    private final Object lock = new Object();
    
    public void produce() throws InterruptedException {
        int value = 0;
        while (true) {
            synchronized (lock) {
                while (queue.size() == CAPACITY) {
                    System.out.println("Queue full, producer waiting...");
                    lock.wait();
                }
                
                System.out.println("Producing: " + value);
                queue.add(value++);
                lock.notifyAll();
                
                Thread.sleep(500);
            }
        }
    }
    
    public void consume() throws InterruptedException {
        while (true) {
            synchronized (lock) {
                while (queue.isEmpty()) {
                    System.out.println("Queue empty, consumer waiting...");
                    lock.wait();
                }
                
                int value = queue.poll();
                System.out.println("Consuming: " + value);
                lock.notifyAll();
                
                Thread.sleep(1000);
            }
        }
    }
    
    public static void main(String[] args) {
        ProducerConsumer pc = new ProducerConsumer();
        
        Thread producer = new Thread(() -> {
            try {
                pc.produce();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        Thread consumer = new Thread(() -> {
            try {
                pc.consume();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        producer.start();
        consumer.start();
    }
}
```

---

## üíª Example 3: notify() vs notifyAll()

```java
class NotifyExample {
    private final Object lock = new Object();
    private int count = 0;
    
    public void waiter(int id) {
        synchronized (lock) {
            try {
                System.out.println("Waiter-" + id + " waiting...");
                lock.wait();
                System.out.println("Waiter-" + id + " woke up! Count: " + count);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public void notifyOne() {
        synchronized (lock) {
            count++;
            System.out.println("notify() called");
            lock.notify(); // Wakes up only ONE thread
        }
    }
    
    public void notifyAllThreads() {
        synchronized (lock) {
            count++;
            System.out.println("notifyAll() called");
            lock.notifyAll(); // Wakes up ALL threads
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        NotifyExample example = new NotifyExample();
        
        // Create 3 waiting threads
        for (int i = 1; i <= 3; i++) {
            final int id = i;
            new Thread(() -> example.waiter(id)).start();
        }
        
        Thread.sleep(1000);
        
        System.out.println("\n=== Testing notify() ===");
        example.notifyOne(); // Only one thread wakes up
        Thread.sleep(1000);
        
        System.out.println("\n=== Testing notifyAll() ===");
        example.notifyAllThreads(); // All remaining threads wake up
        
        Thread.sleep(1000);
    }
}
```

---

## üíª Example 4: Multiple Conditions

```java
class MultiConditionWait {
    private boolean dataReady = false;
    private boolean processingComplete = false;
    private final Object lock = new Object();
    
    public void prepareData() {
        synchronized (lock) {
            System.out.println("Preparing data...");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            dataReady = true;
            System.out.println("Data ready");
            lock.notifyAll();
        }
    }
    
    public void processData() {
        synchronized (lock) {
            try {
                while (!dataReady) {
                    System.out.println("Waiting for data...");
                    lock.wait();
                }
                
                System.out.println("Processing data...");
                Thread.sleep(2000);
                processingComplete = true;
                System.out.println("Processing complete");
                lock.notifyAll();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public void saveResults() {
        synchronized (lock) {
            try {
                while (!processingComplete) {
                    System.out.println("Waiting for processing...");
                    lock.wait();
                }
                
                System.out.println("Saving results...");
                Thread.sleep(1000);
                System.out.println("Results saved");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        MultiConditionWait example = new MultiConditionWait();
        
        Thread saver = new Thread(() -> example.saveResults());
        Thread processor = new Thread(() -> example.processData());
        Thread preparer = new Thread(() -> example.prepareData());
        
        saver.start();
        processor.start();
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        preparer.start();
    }
}
```

---

## üíª Example 5: Timeout with wait()

```java
class WaitTimeoutExample {
    private boolean ready = false;
    
    public synchronized boolean waitForReady(long timeoutMillis) {
        long startTime = System.currentTimeMillis();
        long remaining = timeoutMillis;
        
        try {
            while (!ready && remaining > 0) {
                wait(remaining);
                remaining = timeoutMillis - (System.currentTimeMillis() - startTime);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        return ready;
    }
    
    public synchronized void setReady() {
        ready = true;
        notifyAll();
    }
    
    public static void main(String[] args) throws InterruptedException {
        WaitTimeoutExample example = new WaitTimeoutExample();
        
        Thread waiter = new Thread(() -> {
            System.out.println("Waiting for ready (3 second timeout)...");
            boolean success = example.waitForReady(3000);
            System.out.println("Wait result: " + (success ? "Success" : "Timeout"));
        });
        
        waiter.start();
        
        // Uncomment to test success case
        // Thread.sleep(1000);
        // example.setReady();
        
        waiter.join();
    }
}
```

---

## ‚ö†Ô∏è Common Mistakes

### ‚ùå Mistake 1: Not using while loop

```java
// WRONG - using if
synchronized (lock) {
    if (!condition) {
        lock.wait(); // Spurious wakeup not handled!
    }
}

// CORRECT - using while
synchronized (lock) {
    while (!condition) {
        lock.wait(); // Handles spurious wakeups
    }
}
```

### ‚ùå Mistake 2: Calling wait() outside synchronized

```java
// WRONG - IllegalMonitorStateException!
object.wait();

// CORRECT
synchronized (object) {
    object.wait();
}
```

### ‚ùå Mistake 3: Using notify() when notifyAll() is needed

```java
// WRONG - May cause threads to wait forever
synchronized (lock) {
    condition = true;
    lock.notify(); // Only wakes one thread
}

// CORRECT - Wake all threads
synchronized (lock) {
    condition = true;
    lock.notifyAll(); // Wakes all waiting threads
}
```

---

## üíª Example 6: Print Odd-Even

```java
class OddEvenPrinter {
    private int number = 1;
    private final int MAX = 20;
    private final Object lock = new Object();
    
    public void printOdd() {
        synchronized (lock) {
            while (number <= MAX) {
                while (number % 2 == 0 && number <= MAX) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                
                if (number <= MAX) {
                    System.out.println("Odd: " + number);
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public void printEven() {
        synchronized (lock) {
            while (number <= MAX) {
                while (number % 2 != 0 && number <= MAX) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                
                if (number <= MAX) {
                    System.out.println("Even: " + number);
                    number++;
                    lock.notify();
                }
            }
        }
    }
    
    public static void main(String[] args) {
        OddEvenPrinter printer = new OddEvenPrinter();
        
        Thread oddThread = new Thread(() -> printer.printOdd());
        Thread evenThread = new Thread(() -> printer.printEven());
        
        oddThread.start();
        evenThread.start();
    }
}
```

---

## üìä wait() vs sleep() vs yield()

| Method | Releases Lock? | Native? | Purpose |
|--------|---------------|---------|---------|
| **wait()** | ‚úÖ Yes | Yes | Wait for notification |
| **sleep()** | ‚ùå No | Yes | Pause execution |
| **yield()** | ‚ùå No | Yes | Hint to scheduler |

---

## üí° Best Practices

1. ‚úÖ Always use **while loop**, not if
2. ‚úÖ Always call inside **synchronized block**
3. ‚úÖ Prefer **notifyAll()** over notify() (safer)
4. ‚úÖ Use same object for wait/notify
5. ‚úÖ Handle **InterruptedException** properly
6. ‚úÖ Consider using **higher-level utilities** (CountDownLatch, etc.)
7. ‚ùå Never ignore spurious wakeups

---

## üéØ Interview Questions

1. **What is the difference between wait() and sleep()?**
2. **Why must wait() be called inside synchronized block?**
3. **What is a spurious wakeup?**
4. **What is the difference between notify() and notifyAll()?**
5. **Can you call notify() without wait()?**
6. **What happens if you call wait() outside synchronized?**
7. **How do you handle timeout with wait()?**
8. **Why use while loop instead of if with wait()?**

---

## üìö Next Topics

- [Join Method](02.%20Join%20Method.md)
- [CountDownLatch](03.%20CountDownLatch.md)
- [Producer Consumer Pattern](../07.%20Design%20Patterns/01.%20Producer%20Consumer.md)
