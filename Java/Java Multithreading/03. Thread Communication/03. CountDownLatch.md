# üî¢ CountDownLatch

## üìñ What is CountDownLatch?

A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.

**Key Features:**
- One-time use (cannot be reset)
- Count decrements with `countDown()`
- Threads wait with `await()`
- When count reaches zero, all waiting threads proceed

---

## üíª Example 1: Basic Usage

```java
import java.util.concurrent.CountDownLatch;

class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int numberOfTasks = 3;
        CountDownLatch latch = new CountDownLatch(numberOfTasks);
        
        // Start worker threads
        for (int i = 1; i <= numberOfTasks; i++) {
            final int taskId = i;
            new Thread(() -> {
                System.out.println("Task-" + taskId + " started");
                try {
                    Thread.sleep(1000 * taskId);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Task-" + taskId + " completed");
                latch.countDown(); // Decrement count
            }).start();
        }
        
        System.out.println("Main thread waiting for all tasks to complete...");
        latch.await(); // Wait until count reaches 0
        System.out.println("All tasks completed! Main thread continuing.");
    }
}
```

**Output:**
```
Main thread waiting for all tasks to complete...
Task-1 started
Task-2 started
Task-3 started
Task-1 completed
Task-2 completed
Task-3 completed
All tasks completed! Main thread continuing.
```

---

## üíª Example 2: Service Initialization

```java
import java.util.concurrent.CountDownLatch;

class ServiceInitializer {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);
        
        // Database service
        new Thread(() -> {
            System.out.println("Initializing Database...");
            sleep(2000);
            System.out.println("Database ready");
            latch.countDown();
        }, "Database").start();
        
        // Cache service
        new Thread(() -> {
            System.out.println("Initializing Cache...");
            sleep(1500);
            System.out.println("Cache ready");
            latch.countDown();
        }, "Cache").start();
        
        // Message Queue service
        new Thread(() -> {
            System.out.println("Initializing Message Queue...");
            sleep(1000);
            System.out.println("Message Queue ready");
            latch.countDown();
        }, "MessageQueue").start();
        
        System.out.println("Waiting for all services to initialize...");
        latch.await();
        System.out.println("\n‚úÖ All services initialized! Application starting...");
    }
    
    private static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## üíª Example 3: Await with Timeout

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

class TimeoutExample {
    public static void main(String[] args) {
        CountDownLatch latch = new CountDownLatch(3);
        
        // Fast task
        new Thread(() -> {
            System.out.println("Fast task completed");
            latch.countDown();
        }).start();
        
        // Slow task (will timeout)
        new Thread(() -> {
            try {
                Thread.sleep(5000);
                System.out.println("Slow task completed");
                latch.countDown();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        
        try {
            System.out.println("Waiting for tasks (2 second timeout)...");
            boolean completed = latch.await(2, TimeUnit.SECONDS);
            
            if (completed) {
                System.out.println("All tasks completed within timeout");
            } else {
                System.out.println("Timeout! Some tasks still pending");
                System.out.println("Remaining count: " + latch.getCount());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

## üíª Example 4: Parallel Processing

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class ParallelProcessor {
    public void processFiles(String[] files) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(files.length);
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        long start = System.currentTimeMillis();
        
        for (String file : files) {
            executor.submit(() -> {
                try {
                    processFile(file);
                } finally {
                    latch.countDown();
                }
            });
        }
        
        System.out.println("Waiting for all files to be processed...");
        latch.await();
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("\nAll files processed in " + duration + "ms");
        
        executor.shutdown();
    }
    
    private void processFile(String file) {
        System.out.println("Processing " + file + " on " + 
                          Thread.currentThread().getName());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("Completed " + file);
    }
    
    public static void main(String[] args) throws InterruptedException {
        String[] files = {"file1.txt", "file2.txt", "file3.txt", 
                         "file4.txt", "file5.txt"};
        new ParallelProcessor().processFiles(files);
    }
}
```

---

## üíª Example 5: Race Starting Gate

```java
import java.util.concurrent.CountDownLatch;

class RaceSimulator {
    public static void main(String[] args) throws InterruptedException {
        int numberOfRunners = 5;
        CountDownLatch startSignal = new CountDownLatch(1); // Start gate
        CountDownLatch finishSignal = new CountDownLatch(numberOfRunners); // Finish line
        
        for (int i = 1; i <= numberOfRunners; i++) {
            final int runnerId = i;
            new Thread(() -> {
                try {
                    System.out.println("Runner-" + runnerId + " ready at start line");
                    startSignal.await(); // Wait for start signal
                    
                    System.out.println("Runner-" + runnerId + " started running");
                    Thread.sleep((long)(Math.random() * 3000));
                    System.out.println("Runner-" + runnerId + " finished!");
                    
                    finishSignal.countDown();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
        
        Thread.sleep(2000);
        System.out.println("\nüèÅ START! üèÅ\n");
        startSignal.countDown(); // Release all runners
        
        finishSignal.await(); // Wait for all to finish
        System.out.println("\nüèÜ All runners finished! üèÜ");
    }
}
```

---

## üìä CountDownLatch vs CyclicBarrier

| Feature | CountDownLatch | CyclicBarrier |
|---------|---------------|---------------|
| **Reusability** | One-time use | Reusable |
| **Decrement** | `countDown()` | Automatic on `await()` |
| **Waiting** | Multiple threads wait | All threads wait for each other |
| **Use Case** | Task completion | Synchronization point |

---

## üí° Best Practices

1. ‚úÖ Use for one-time synchronization events
2. ‚úÖ Always call `countDown()` in finally block
3. ‚úÖ Use timeout with `await()` to avoid indefinite waiting
4. ‚úÖ Initialize with correct count (one-time only)
5. ‚úÖ Consider `CyclicBarrier` if reusability needed

---

## üéØ Interview Questions

1. **What is CountDownLatch?**
2. **When would you use CountDownLatch?**
3. **Can you reuse a CountDownLatch?**
4. **What happens if countDown() is called more times than the initial count?**
5. **What is the difference between CountDownLatch and CyclicBarrier?**
6. **How do you handle timeout with CountDownLatch?**

---

## üìö Next Topics

- [CyclicBarrier](04.%20CyclicBarrier.md)
- [Semaphore](05.%20Semaphore.md)
