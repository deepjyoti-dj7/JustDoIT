# üîÑ CyclicBarrier

## üìñ What is CyclicBarrier?

A synchronization aid that allows a set of threads to wait for each other to reach a common barrier point. Unlike CountDownLatch, it's **reusable**.

**Key Features:**
- Reusable after all threads reach barrier
- All threads must call `await()`
- Optional barrier action executed when all threads arrive
- Can be reset

---

## üíª Example 1: Basic Usage

```java
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.BrokenBarrierException;

class CyclicBarrierExample {
    public static void main(String[] args) {
        int numberOfThreads = 3;
        
        // Barrier action executed when all threads reach barrier
        Runnable barrierAction = () -> {
            System.out.println("\n‚úÖ All threads reached barrier! Continuing...\n");
        };
        
        CyclicBarrier barrier = new CyclicBarrier(numberOfThreads, barrierAction);
        
        for (int i = 1; i <= numberOfThreads; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    System.out.println("Thread-" + id + " doing work phase 1");
                    Thread.sleep(1000 * id);
                    System.out.println("Thread-" + id + " reached barrier");
                    
                    barrier.await(); // Wait for all threads
                    
                    System.out.println("Thread-" + id + " doing work phase 2");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

---

## üíª Example 2: Multi-Phase Processing

```java
import java.util.concurrent.*;

class MultiPhaseProcessor {
    public static void main(String[] args) {
        int numberOfWorkers = 4;
        CyclicBarrier barrier = new CyclicBarrier(numberOfWorkers, () -> {
            System.out.println("--- Phase completed ---");
        });
        
        for (int i = 1; i <= numberOfWorkers; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    // Phase 1: Data collection
                    System.out.println("Worker-" + workerId + ": Collecting data");
                    Thread.sleep((long)(Math.random() * 2000));
                    System.out.println("Worker-" + workerId + ": Data collected");
                    barrier.await();
                    
                    // Phase 2: Data processing
                    System.out.println("Worker-" + workerId + ": Processing data");
                    Thread.sleep((long)(Math.random() * 2000));
                    System.out.println("Worker-" + workerId + ": Data processed");
                    barrier.await();
                    
                    // Phase 3: Result aggregation
                    System.out.println("Worker-" + workerId + ": Aggregating results");
                    Thread.sleep((long)(Math.random() * 2000));
                    System.out.println("Worker-" + workerId + ": Results aggregated");
                    barrier.await();
                    
                    System.out.println("Worker-" + workerId + ": All phases complete!");
                    
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }, "Worker-" + workerId).start();
        }
    }
}
```

---

## üíª Example 3: Matrix Multiplication

```java
import java.util.concurrent.*;

class ParallelMatrixMultiplier {
    private int[][] result;
    private CyclicBarrier barrier;
    
    class Worker implements Runnable {
        private int row;
        private int[][] matrixA;
        private int[][] matrixB;
        
        public Worker(int row, int[][] matrixA, int[][] matrixB) {
            this.row = row;
            this.matrixA = matrixA;
            this.matrixB = matrixB;
        }
        
        @Override
        public void run() {
            try {
                // Calculate one row
                for (int j = 0; j < matrixB[0].length; j++) {
                    int sum = 0;
                    for (int k = 0; k < matrixA[0].length; k++) {
                        sum += matrixA[row][k] * matrixB[k][j];
                    }
                    result[row][j] = sum;
                }
                
                System.out.println(Thread.currentThread().getName() + 
                                  " completed row " + row);
                barrier.await(); // Wait for all rows
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
        }
    }
    
    public int[][] multiply(int[][] matrixA, int[][] matrixB) {
        int rows = matrixA.length;
        result = new int[rows][matrixB[0].length];
        
        barrier = new CyclicBarrier(rows, () -> {
            System.out.println("All rows computed!");
        });
        
        ExecutorService executor = Executors.newFixedThreadPool(rows);
        
        for (int i = 0; i < rows; i++) {
            executor.submit(new Worker(i, matrixA, matrixB));
        }
        
        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] A = {{1, 2}, {3, 4}, {5, 6}};
        int[][] B = {{7, 8, 9}, {10, 11, 12}};
        
        ParallelMatrixMultiplier multiplier = new ParallelMatrixMultiplier();
        int[][] result = multiplier.multiply(A, B);
        
        System.out.println("\nResult:");
        for (int[] row : result) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }
}
```

---

## üíª Example 4: await() with Timeout

```java
import java.util.concurrent.*;

class TimeoutExample {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(3);
        
        // Fast threads
        for (int i = 1; i <= 2; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    System.out.println("Thread-" + id + " working");
                    Thread.sleep(1000);
                    System.out.println("Thread-" + id + " waiting at barrier");
                    barrier.await(3, TimeUnit.SECONDS);
                    System.out.println("Thread-" + id + " proceeding");
                } catch (TimeoutException e) {
                    System.out.println("Thread-" + id + " timed out!");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
        
        // Slow thread (causes timeout)
        new Thread(() -> {
            try {
                System.out.println("Thread-3 working slowly");
                Thread.sleep(5000);
                System.out.println("Thread-3 waiting at barrier");
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                System.out.println("Thread-3: Barrier broken!");
            }
        }).start();
    }
}
```

---

## üíª Example 5: Resetting Barrier

```java
import java.util.concurrent.*;

class ResetExample {
    public static void main(String[] args) throws InterruptedException {
        CyclicBarrier barrier = new CyclicBarrier(2, () -> {
            System.out.println("Barrier reached!\n");
        });
        
        // Round 1
        System.out.println("=== Round 1 ===");
        startThreads(barrier, 2);
        Thread.sleep(2000);
        
        // Round 2 (barrier is reusable)
        System.out.println("=== Round 2 ===");
        startThreads(barrier, 2);
        Thread.sleep(2000);
        
        // Reset and Round 3
        System.out.println("=== Resetting Barrier ===");
        barrier.reset();
        System.out.println("=== Round 3 ===");
        startThreads(barrier, 2);
    }
    
    private static void startThreads(CyclicBarrier barrier, int count) {
        for (int i = 1; i <= count; i++) {
            final int id = i;
            new Thread(() -> {
                try {
                    System.out.println("Thread-" + id + " working");
                    Thread.sleep(1000);
                    System.out.println("Thread-" + id + " at barrier");
                    barrier.await();
                    System.out.println("Thread-" + id + " continuing");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

---

## üìä Comparison

| Feature | CyclicBarrier | CountDownLatch |
|---------|--------------|----------------|
| **Reusability** | ‚úÖ Reusable | ‚ùå One-time |
| **Waiting** | All threads wait | One/more threads wait |
| **Action** | Optional barrier action | No action |
| **Reset** | ‚úÖ Can reset | ‚ùå Cannot reset |
| **Use Case** | Iterative sync | One-time event |

---

## üí° Best Practices

1. ‚úÖ Use for iterative/cyclic synchronization
2. ‚úÖ Handle `BrokenBarrierException`
3. ‚úÖ Use timeout with `await()` for safety
4. ‚úÖ Reset barrier if needed for reuse
5. ‚úÖ Keep barrier action short and non-blocking

---

## üéØ Interview Questions

1. **What is CyclicBarrier?**
2. **How is CyclicBarrier different from CountDownLatch?**
3. **Can CyclicBarrier be reused?**
4. **What is a barrier action?**
5. **What is BrokenBarrierException?**
6. **When would you use CyclicBarrier over CountDownLatch?**

---

## üìö Next Topics

- [Semaphore](05.%20Semaphore.md)
- [Phaser](07.%20Phaser.md)
