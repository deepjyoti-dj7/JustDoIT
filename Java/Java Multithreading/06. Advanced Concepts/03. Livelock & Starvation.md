# ðŸ”„ Livelock & Starvation

## ðŸ“– What is Livelock?

A situation where two or more threads continuously change their state in response to each other without making progress.

**vs Deadlock:**
- Deadlock: Threads are blocked
- Livelock: Threads are active but not progressing

---

## ðŸ’» Example 1: Basic Livelock

```java
class LivelockExample {
    static class Spoon {
        private Diner owner;
        
        public Spoon(Diner owner) {
            this.owner = owner;
        }
        
        public Diner getOwner() {
            return owner;
        }
        
        public synchronized void setOwner(Diner owner) {
            this.owner = owner;
        }
        
        public synchronized void use() {
            System.out.println(owner.name + " is eating");
        }
    }
    
    static class Diner {
        private String name;
        private boolean isHungry;
        
        public Diner(String name) {
            this.name = name;
            this.isHungry = true;
        }
        
        public void eatWith(Spoon spoon, Diner spouse) {
            while (isHungry) {
                // If spouse is hungry, offer the spoon
                if (spoon.getOwner() != this) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        continue;
                    }
                    continue;
                }
                
                if (spouse.isHungry) {
                    System.out.println(name + ": You eat first, " + spouse.name);
                    spoon.setOwner(spouse);
                    continue; // Livelock: keeps giving up
                }
                
                spoon.use();
                isHungry = false;
                System.out.println(name + ": I'm done eating");
                spoon.setOwner(spouse);
            }
        }
    }
    
    public static void main(String[] args) {
        Diner husband = new Diner("Husband");
        Diner wife = new Diner("Wife");
        
        Spoon spoon = new Spoon(husband);
        
        new Thread(() -> husband.eatWith(spoon, wife)).start();
        new Thread(() -> wife.eatWith(spoon, husband)).start();
    }
}
```

---

## ðŸ’» Example 2: Livelock Solution

```java
import java.util.Random;

class LivelockSolution {
    static class Spoon {
        private Diner owner;
        
        public Spoon(Diner owner) {
            this.owner = owner;
        }
        
        public Diner getOwner() {
            return owner;
        }
        
        public synchronized void setOwner(Diner owner) {
            this.owner = owner;
        }
        
        public synchronized void use() {
            System.out.println(owner.name + " is eating");
        }
    }
    
    static class Diner {
        private String name;
        private boolean isHungry;
        private Random random = new Random();
        
        public Diner(String name) {
            this.name = name;
            this.isHungry = true;
        }
        
        public void eatWith(Spoon spoon, Diner spouse) {
            while (isHungry) {
                if (spoon.getOwner() != this) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        continue;
                    }
                    continue;
                }
                
                // Random backoff to break livelock
                if (spouse.isHungry && random.nextBoolean()) {
                    System.out.println(name + ": You eat first, " + spouse.name);
                    spoon.setOwner(spouse);
                    try {
                        Thread.sleep(random.nextInt(10)); // Random delay
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    continue;
                }
                
                spoon.use();
                isHungry = false;
                System.out.println(name + ": I'm done eating");
                spoon.setOwner(spouse);
            }
        }
    }
    
    public static void main(String[] args) {
        Diner husband = new Diner("Husband");
        Diner wife = new Diner("Wife");
        
        Spoon spoon = new Spoon(husband);
        
        new Thread(() -> husband.eatWith(spoon, wife)).start();
        new Thread(() -> wife.eatWith(spoon, husband)).start();
    }
}
```

---

## ðŸ“– What is Starvation?

A situation where a thread is perpetually denied access to resources because other threads are constantly given priority.

---

## ðŸ’» Example 3: Starvation with Unfair Lock

```java
class StarvationExample {
    private int counter = 0;
    
    public synchronized void increment() {
        counter++;
        System.out.println(Thread.currentThread().getName() + 
                          ": " + counter);
    }
    
    public static void main(String[] args) {
        StarvationExample example = new StarvationExample();
        
        // High priority threads
        for (int i = 1; i <= 3; i++) {
            Thread t = new Thread(() -> {
                for (int j = 0; j < 100; j++) {
                    example.increment();
                }
            }, "HighPriority-" + i);
            t.setPriority(Thread.MAX_PRIORITY);
            t.start();
        }
        
        // Low priority thread (may starve)
        Thread lowPriority = new Thread(() -> {
            for (int j = 0; j < 100; j++) {
                example.increment();
            }
        }, "LowPriority");
        lowPriority.setPriority(Thread.MIN_PRIORITY);
        lowPriority.start();
    }
}
```

---

## ðŸ’» Example 4: Fair Lock Solution

```java
import java.util.concurrent.locks.*;

class FairLockSolution {
    private int counter = 0;
    private Lock lock = new ReentrantLock(true); // Fair lock
    
    public void increment() {
        lock.lock();
        try {
            counter++;
            System.out.println(Thread.currentThread().getName() + 
                              ": " + counter);
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        FairLockSolution example = new FairLockSolution();
        
        // All threads get fair chance
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 20; j++) {
                    example.increment();
                }
            }, "Thread-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 5: Reader-Writer Starvation

```java
import java.util.concurrent.locks.*;

class ReaderWriterStarvation {
    private int data = 0;
    private ReadWriteLock lock = new ReentrantReadWriteLock();
    
    public void write(int value) {
        lock.writeLock().lock();
        try {
            data = value;
            System.out.println(Thread.currentThread().getName() + 
                              " wrote: " + value);
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
    }
    
    public int read() {
        lock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + 
                              " read: " + data);
            Thread.sleep(10);
            return data;
        } catch (InterruptedException e) {
            return -1;
        } finally {
            lock.readLock().unlock();
        }
    }
    
    public static void main(String[] args) {
        ReaderWriterStarvation example = new ReaderWriterStarvation();
        
        // Many readers
        for (int i = 1; i <= 10; i++) {
            new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    example.read();
                }
            }, "Reader-" + i).start();
        }
        
        // Few writers (may starve)
        for (int i = 1; i <= 2; i++) {
            final int writerId = i;
            new Thread(() -> {
                for (int j = 0; j < 5; j++) {
                    example.write(writerId * 10 + j);
                }
            }, "Writer-" + i).start();
        }
    }
}
```

---

## ðŸ’» Example 6: Preventing Starvation with Timeouts

```java
import java.util.concurrent.locks.*;
import java.util.concurrent.TimeUnit;

class TimeoutSolution {
    private Lock lock = new ReentrantLock();
    private int counter = 0;
    
    public void increment() {
        try {
            if (lock.tryLock(100, TimeUnit.MILLISECONDS)) {
                try {
                    counter++;
                    System.out.println(Thread.currentThread().getName() + 
                                      ": " + counter);
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println(Thread.currentThread().getName() + 
                                  ": Couldn't acquire lock, skipping");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public static void main(String[] args) {
        TimeoutSolution example = new TimeoutSolution();
        
        for (int i = 1; i <= 5; i++) {
            new Thread(() -> {
                for (int j = 0; j < 10; j++) {
                    example.increment();
                    try {
                        Thread.sleep((long)(Math.random() * 50));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }, "Thread-" + i).start();
        }
    }
}
```

---

## ðŸ“Š Comparison

| Aspect | Deadlock | Livelock | Starvation |
|--------|----------|----------|------------|
| **State** | Blocked | Active | Waiting |
| **Progress** | No | No | Slow |
| **CPU Usage** | Low | High | Variable |
| **Detection** | Easy | Hard | Hard |
| **Common Cause** | Circular wait | Polite threads | Priority |

---

## ðŸ’¡ Prevention Strategies

### Livelock Prevention:
1. âœ… Random backoff
2. âœ… Ordered resource acquisition
3. âœ… Timeout mechanisms
4. âœ… Priority-based decisions

### Starvation Prevention:
1. âœ… Fair locks
2. âœ… Priority queuing
3. âœ… Age-based priority
4. âœ… Timeout and retry
5. âœ… Avoid extreme priority differences

---

## ðŸŽ¯ Interview Questions

1. **What is livelock?**
2. **How is livelock different from deadlock?**
3. **What is starvation?**
4. **How do you prevent livelock?**
5. **What is a fair lock?**
6. **How do you detect starvation?**

---

## ðŸ“š Next Topics

- [Thread Safety](03.%20Thread%20Safety.md)
- [Deadlock](02.%20Deadlock.md)
