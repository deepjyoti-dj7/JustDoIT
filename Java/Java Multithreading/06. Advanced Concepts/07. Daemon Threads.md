# ðŸ‘» Daemon Threads

## ðŸ“– What are Daemon Threads?

Background threads that don't prevent the JVM from exiting. When all user threads finish, JVM terminates, killing all daemon threads.

**Use Cases:**
- Garbage collection
- Background monitoring
- Housekeeping tasks
- Service threads

---

## ðŸ’» Example 1: Basic Daemon Thread

```java
class BasicDaemonExample {
    public static void main(String[] args) throws InterruptedException {
        Thread daemon = new Thread(() -> {
            while (true) {
                System.out.println("Daemon thread running...");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        daemon.setDaemon(true); // Must be set before start()
        daemon.start();
        
        System.out.println("Main thread working...");
        Thread.sleep(2000);
        System.out.println("Main thread exiting...");
        
        // JVM exits, daemon thread is killed
    }
}
```

**Output:**
```
Main thread working...
Daemon thread running...
Daemon thread running...
Daemon thread running...
Daemon thread running...
Main thread exiting...
```

---

## ðŸ’» Example 2: User vs Daemon Thread

```java
class UserVsDaemon {
    public static void main(String[] args) throws InterruptedException {
        // User thread
        Thread userThread = new Thread(() -> {
            try {
                System.out.println("User thread started");
                Thread.sleep(3000);
                System.out.println("User thread completed");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        // Daemon thread
        Thread daemonThread = new Thread(() -> {
            while (true) {
                System.out.println("Daemon running...");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        daemonThread.setDaemon(true);
        
        userThread.start();
        daemonThread.start();
        
        System.out.println("Main thread done");
        // JVM waits for user thread, not daemon
    }
}
```

---

## ðŸ’» Example 3: Monitoring Service

```java
class MonitoringService {
    private volatile boolean running = true;
    
    public void start() {
        Thread monitor = new Thread(() -> {
            while (running) {
                System.out.println("Monitor: Checking system health...");
                System.out.println("Monitor: Memory: " + 
                    (Runtime.getRuntime().totalMemory() - 
                     Runtime.getRuntime().freeMemory()) / 1024 / 1024 + " MB");
                
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    break;
                }
            }
        });
        
        monitor.setDaemon(true);
        monitor.start();
        System.out.println("Monitoring service started");
    }
    
    public void stop() {
        running = false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        MonitoringService service = new MonitoringService();
        service.start();
        
        // Simulate work
        Thread.sleep(5000);
        
        System.out.println("Application shutting down...");
        // Daemon thread killed automatically
    }
}
```

---

## ðŸ’» Example 4: Auto-Save Feature

```java
class AutoSaveService {
    private volatile boolean running = true;
    
    public void startAutoSave() {
        Thread autoSaver = new Thread(() -> {
            while (running) {
                System.out.println("Auto-save: Saving document...");
                saveDocument();
                
                try {
                    Thread.sleep(5000); // Save every 5 seconds
                } catch (InterruptedException e) {
                    System.out.println("Auto-save interrupted");
                    break;
                }
            }
        }, "AutoSaveThread");
        
        autoSaver.setDaemon(true);
        autoSaver.start();
        System.out.println("Auto-save enabled");
    }
    
    private void saveDocument() {
        // Simulate save operation
        System.out.println("Document saved at " + System.currentTimeMillis());
    }
    
    public static void main(String[] args) throws InterruptedException {
        AutoSaveService service = new AutoSaveService();
        service.startAutoSave();
        
        // User works for 12 seconds
        Thread.sleep(12000);
        
        System.out.println("User closed the application");
        // Daemon auto-save thread stops automatically
    }
}
```

---

## ðŸ’» Example 5: Thread Pool with Daemon Workers

```java
import java.util.concurrent.*;

class DaemonThreadPool {
    public static void main(String[] args) throws InterruptedException {
        // Create thread pool with daemon threads
        ThreadFactory daemonFactory = r -> {
            Thread thread = new Thread(r);
            thread.setDaemon(true);
            thread.setName("DaemonWorker-" + thread.getId());
            return thread;
        };
        
        ExecutorService executor = Executors.newFixedThreadPool(3, daemonFactory);
        
        // Submit tasks
        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println(Thread.currentThread().getName() + 
                                  " processing task-" + taskId);
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + 
                                  " completed task-" + taskId);
            });
        }
        
        System.out.println("Tasks submitted");
        Thread.sleep(5000);
        System.out.println("Main exiting");
        
        // JVM exits, daemon pool threads are killed
    }
}
```

---

## ðŸ’» Example 6: Log Flusher

```java
import java.util.concurrent.*;

class LogFlusher {
    private BlockingQueue<String> logQueue = new LinkedBlockingQueue<>();
    private volatile boolean running = true;
    
    public LogFlusher() {
        Thread flusher = new Thread(() -> {
            while (running || !logQueue.isEmpty()) {
                try {
                    String log = logQueue.poll(100, TimeUnit.MILLISECONDS);
                    if (log != null) {
                        flushToDisk(log);
                    }
                } catch (InterruptedException e) {
                    break;
                }
            }
            System.out.println("Log flusher stopped");
        }, "LogFlusher");
        
        flusher.setDaemon(true);
        flusher.start();
    }
    
    public void log(String message) {
        logQueue.offer(message);
    }
    
    private void flushToDisk(String log) {
        System.out.println("[DISK] " + log);
    }
    
    public void shutdown() {
        running = false;
    }
    
    public static void main(String[] args) throws InterruptedException {
        LogFlusher logger = new LogFlusher();
        
        for (int i = 1; i <= 5; i++) {
            logger.log("Log message " + i);
            Thread.sleep(500);
        }
        
        System.out.println("Application done");
        Thread.sleep(1000);
    }
}
```

---

## ðŸ’» Example 7: Checking Daemon Status

```java
class DaemonStatus {
    public static void main(String[] args) {
        Thread normalThread = new Thread(() -> {
            System.out.println("Normal thread: isDaemon = " + 
                              Thread.currentThread().isDaemon());
        });
        
        Thread daemonThread = new Thread(() -> {
            System.out.println("Daemon thread: isDaemon = " + 
                              Thread.currentThread().isDaemon());
        });
        daemonThread.setDaemon(true);
        
        System.out.println("Main thread: isDaemon = " + 
                          Thread.currentThread().isDaemon());
        
        normalThread.start();
        daemonThread.start();
        
        // Check before start
        Thread notStarted = new Thread(() -> {});
        notStarted.setDaemon(true);
        System.out.println("Not started thread: isDaemon = " + 
                          notStarted.isDaemon());
    }
}
```

---

## âš ï¸ Important Rules

```java
class DaemonRules {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println("Task running");
        });
        
        // âŒ WRONG: Cannot set daemon status after start
        thread.start();
        try {
            thread.setDaemon(true); // Throws IllegalThreadStateException
        } catch (IllegalThreadStateException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        // âœ… CORRECT: Set before start
        Thread daemon = new Thread(() -> {
            System.out.println("Daemon running");
        });
        daemon.setDaemon(true);
        daemon.start();
        
        // Daemon status is inherited
        Thread parent = new Thread(() -> {
            Thread child = new Thread(() -> {
                System.out.println("Child isDaemon: " + 
                                  Thread.currentThread().isDaemon());
            });
            child.start();
        });
        parent.setDaemon(true);
        parent.start();
    }
}
```

---

## ðŸ“Š User vs Daemon Threads

| Feature | User Thread | Daemon Thread |
|---------|-------------|---------------|
| **JVM Exit** | Prevents | Doesn't prevent |
| **Purpose** | Application work | Background service |
| **Priority** | Normal | Lower |
| **Examples** | Main, worker threads | GC, monitoring |
| **Default** | User | Inherits from parent |

---

## ðŸ’¡ Use Cases

### âœ… Good for Daemon:
- Monitoring and logging
- Garbage collection
- Auto-save features
- Background cleanup
- Health checks
- Cache invalidation

### âŒ Not Good for Daemon:
- Critical data processing
- Transaction handling
- File I/O that must complete
- Database operations
- Any work that must finish

---

## âš ï¸ Pitfalls

```java
class DaemonPitfalls {
    public static void main(String[] args) throws InterruptedException {
        // âŒ PITFALL 1: Daemon thread killed mid-operation
        Thread daemon = new Thread(() -> {
            System.out.println("Writing important data...");
            try {
                Thread.sleep(5000);
                System.out.println("Data written"); // May never execute
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        daemon.setDaemon(true);
        daemon.start();
        
        Thread.sleep(1000);
        System.out.println("Main exiting");
        // Daemon killed, data not written!
    }
}

class ProperShutdown {
    private static volatile boolean running = true;
    
    public static void main(String[] args) throws InterruptedException {
        // âœ… SOLUTION: Graceful shutdown
        Thread worker = new Thread(() -> {
            while (running) {
                System.out.println("Working...");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    break;
                }
            }
            System.out.println("Worker stopped gracefully");
        });
        
        worker.start();
        Thread.sleep(3000);
        
        running = false; // Signal stop
        worker.join(2000); // Wait for completion
        
        System.out.println("Main exiting");
    }
}
```

---

## ðŸ’¡ Best Practices

1. âœ… Use for non-critical background tasks
2. âœ… Never rely on finally blocks in daemon threads
3. âœ… Don't use for I/O operations that must complete
4. âœ… Set daemon status before start()
5. âœ… Consider graceful shutdown for important work
6. âœ… Document daemon thread behavior

---

## ðŸŽ¯ Interview Questions

1. **What is a daemon thread?**
2. **What happens to daemon threads when JVM exits?**
3. **When should you use daemon threads?**
4. **Can you set daemon status after thread starts?**
5. **What is the default daemon status of a new thread?**
6. **What are examples of daemon threads in JVM?**

---

## ðŸ“š Next Topics

- [Thread Lifecycle](../../01.%20Fundamentals/02.%20Thread%20Lifecycle.md)
- [Thread Pools](../../04.%20Executor%20Framework/02.%20Thread%20Pools.md)
