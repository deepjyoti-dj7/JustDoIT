# ‚ò†Ô∏è Deadlock

## üìñ What is Deadlock?

**Deadlock** occurs when two or more threads are blocked forever, waiting for each other to release locks. Each thread holds a resource and waits for another resource held by another thread.

**Conditions for Deadlock (Coffman Conditions):**
1. **Mutual Exclusion**: Resources cannot be shared
2. **Hold and Wait**: Thread holds resources while waiting for others
3. **No Preemption**: Resources cannot be forcibly taken
4. **Circular Wait**: Circular chain of threads waiting for resources

---

## üíª Example 1: Classic Deadlock

```java
class DeadlockExample {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
            System.out.println(Thread.currentThread().getName() + 
                              " acquired lock1, waiting for lock2...");
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            synchronized (lock2) {
                System.out.println(Thread.currentThread().getName() + 
                                  " acquired lock2");
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {
            System.out.println(Thread.currentThread().getName() + 
                              " acquired lock2, waiting for lock1...");
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            
            synchronized (lock1) {
                System.out.println(Thread.currentThread().getName() + 
                                  " acquired lock1");
            }
        }
    }
    
    public static void main(String[] args) {
        DeadlockExample example = new DeadlockExample();
        
        Thread t1 = new Thread(() -> example.method1(), "Thread-1");
        Thread t2 = new Thread(() -> example.method2(), "Thread-2");
        
        t1.start();
        t2.start();
        
        // Threads will deadlock!
        // Thread-1: holds lock1, waits for lock2
        // Thread-2: holds lock2, waits for lock1
    }
}
```

**Output:**
```
Thread-1 acquired lock1, waiting for lock2...
Thread-2 acquired lock2, waiting for lock1...
[DEADLOCK - program hangs]
```

---

## ‚úÖ Solution 1: Lock Ordering

Always acquire locks in the same order.

```java
class LockOrderingSolution {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
            System.out.println(Thread.currentThread().getName() + " acquired lock1");
            
            synchronized (lock2) {
                System.out.println(Thread.currentThread().getName() + " acquired lock2");
                // Do work
            }
        }
    }
    
    public void method2() {
        // Same order as method1
        synchronized (lock1) {
            System.out.println(Thread.currentThread().getName() + " acquired lock1");
            
            synchronized (lock2) {
                System.out.println(Thread.currentThread().getName() + " acquired lock2");
                // Do work
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        LockOrderingSolution solution = new LockOrderingSolution();
        
        Thread t1 = new Thread(() -> solution.method1(), "Thread-1");
        Thread t2 = new Thread(() -> solution.method2(), "Thread-2");
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("Completed successfully - No deadlock!");
    }
}
```

---

## ‚úÖ Solution 2: Using tryLock()

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class TryLockSolution {
    private Lock lock1 = new ReentrantLock();
    private Lock lock2 = new ReentrantLock();
    
    public void method1() {
        boolean lock1Acquired = false;
        boolean lock2Acquired = false;
        
        try {
            lock1Acquired = lock1.tryLock(1, TimeUnit.SECONDS);
            
            if (lock1Acquired) {
                System.out.println(Thread.currentThread().getName() + " acquired lock1");
                
                lock2Acquired = lock2.tryLock(1, TimeUnit.SECONDS);
                
                if (lock2Acquired) {
                    System.out.println(Thread.currentThread().getName() + " acquired lock2");
                    // Do work
                } else {
                    System.out.println(Thread.currentThread().getName() + 
                                      " couldn't acquire lock2, releasing lock1");
                }
            } else {
                System.out.println(Thread.currentThread().getName() + " couldn't acquire lock1");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock2Acquired) lock2.unlock();
            if (lock1Acquired) lock1.unlock();
        }
    }
    
    public void method2() {
        boolean lock2Acquired = false;
        boolean lock1Acquired = false;
        
        try {
            lock2Acquired = lock2.tryLock(1, TimeUnit.SECONDS);
            
            if (lock2Acquired) {
                System.out.println(Thread.currentThread().getName() + " acquired lock2");
                
                lock1Acquired = lock1.tryLock(1, TimeUnit.SECONDS);
                
                if (lock1Acquired) {
                    System.out.println(Thread.currentThread().getName() + " acquired lock1");
                    // Do work
                } else {
                    System.out.println(Thread.currentThread().getName() + 
                                      " couldn't acquire lock1, releasing lock2");
                }
            } else {
                System.out.println(Thread.currentThread().getName() + " couldn't acquire lock2");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock1Acquired) lock1.unlock();
            if (lock2Acquired) lock2.unlock();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        TryLockSolution solution = new TryLockSolution();
        
        Thread t1 = new Thread(() -> solution.method1(), "Thread-1");
        Thread t2 = new Thread(() -> solution.method2(), "Thread-2");
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("Completed - No deadlock!");
    }
}
```

---

## üíª Example 2: Bank Account Transfer Deadlock

```java
class BankAccount {
    private String accountNumber;
    private double balance;
    
    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    // DEADLOCK PRONE!
    public void transferBad(BankAccount target, double amount) {
        synchronized (this) {
            synchronized (target) {
                if (this.balance >= amount) {
                    this.balance -= amount;
                    target.balance += amount;
                    System.out.println("Transferred " + amount + 
                                      " from " + accountNumber + 
                                      " to " + target.accountNumber);
                }
            }
        }
    }
    
    // DEADLOCK-FREE!
    public void transferGood(BankAccount target, double amount) {
        BankAccount first, second;
        
        // Always lock accounts in same order
        if (this.accountNumber.compareTo(target.accountNumber) < 0) {
            first = this;
            second = target;
        } else {
            first = target;
            second = this;
        }
        
        synchronized (first) {
            synchronized (second) {
                if (this.balance >= amount) {
                    this.balance -= amount;
                    target.balance += amount;
                    System.out.println("Transferred " + amount + 
                                      " from " + accountNumber + 
                                      " to " + target.accountNumber);
                }
            }
        }
    }
    
    public double getBalance() {
        return balance;
    }
    
    public static void main(String[] args) throws InterruptedException {
        BankAccount acc1 = new BankAccount("ACC-001", 1000);
        BankAccount acc2 = new BankAccount("ACC-002", 1000);
        
        // Test deadlock-free version
        Thread t1 = new Thread(() -> acc1.transferGood(acc2, 100));
        Thread t2 = new Thread(() -> acc2.transferGood(acc1, 200));
        
        t1.start();
        t2.start();
        
        t1.join();
        t2.join();
        
        System.out.println("ACC-001 balance: " + acc1.getBalance());
        System.out.println("ACC-002 balance: " + acc2.getBalance());
    }
}
```

---

## üîç Detecting Deadlock

### Using JConsole/VisualVM

```bash
# Get Java process ID
jps

# Use jstack to detect deadlock
jstack <pid>
```

### Programmatic Detection

```java
import java.lang.management.*;

class DeadlockDetector {
    public static void detectDeadlock() {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
        
        if (deadlockedThreads != null) {
            System.out.println("Deadlock detected!");
            ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);
            
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("Thread: " + threadInfo.getThreadName());
                System.out.println("State: " + threadInfo.getThreadState());
                System.out.println("Locked on: " + threadInfo.getLockName());
                System.out.println("Locked by: " + threadInfo.getLockOwnerName());
                System.out.println();
            }
        } else {
            System.out.println("No deadlock detected");
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        // Create deadlock scenario
        final Object lock1 = new Object();
        final Object lock2 = new Object();
        
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("T1: Locked lock1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("T1: Locked lock2");
                }
            }
        });
        
        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("T2: Locked lock2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println("T2: Locked lock1");
                }
            }
        });
        
        t1.start();
        t2.start();
        
        Thread.sleep(1000);
        detectDeadlock();
    }
}
```

---

## üí° Prevention Strategies

### 1. Lock Ordering
Always acquire locks in the same global order.

### 2. Lock Timeout
Use `tryLock()` with timeout instead of blocking `lock()`.

### 3. Single Lock
Use a single lock for all operations.

```java
class SingleLockApproach {
    private final Object globalLock = new Object();
    
    public void operation1() {
        synchronized (globalLock) {
            // All operations use same lock
        }
    }
    
    public void operation2() {
        synchronized (globalLock) {
            // No chance of deadlock
        }
    }
}
```

### 4. Avoid Nested Locks
Don't hold multiple locks simultaneously.

---

## üìä Deadlock vs Livelock vs Starvation

| Condition | Deadlock | Livelock | Starvation |
|-----------|----------|----------|------------|
| **State** | Blocked | Active | Waiting |
| **Progress** | None | None | Eventually yes |
| **Resource** | Held | Not held | Not available |
| **Recovery** | Requires intervention | May recover | May recover |

---

## üí° Best Practices

1. ‚úÖ **Avoid nested locks** when possible
2. ‚úÖ **Use lock ordering** if multiple locks needed
3. ‚úÖ **Use tryLock()** with timeout
4. ‚úÖ **Keep synchronized blocks small**
5. ‚úÖ **Use higher-level concurrency utilities**
6. ‚úÖ **Test with multiple threads**
7. ‚úÖ **Monitor for deadlocks** in production

---

## üéØ Interview Questions

1. **What is deadlock?**
2. **What are the four conditions for deadlock?**
3. **How do you prevent deadlock?**
4. **How do you detect deadlock?**
5. **What is the difference between deadlock and livelock?**
6. **How does lock ordering prevent deadlock?**
7. **Can you have deadlock with a single thread?**
8. **How does tryLock() help avoid deadlock?**

---

## üìö Next Topics

- [Livelock & Starvation](03.%20Livelock%20%26%20Starvation.md)
- [Locks & ReentrantLock](../../02.%20Synchronization/05.%20Locks%20%26%20ReentrantLock.md)
- [Thread Safety](04.%20Thread%20Safety.md)
