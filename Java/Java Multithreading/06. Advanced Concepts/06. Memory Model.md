# ðŸ§  Java Memory Model

## ðŸ“– What is Java Memory Model (JMM)?

The Java Memory Model defines how threads interact through memory and what behaviors are allowed in concurrent execution.

**Key Concepts:**
- Main memory vs Thread-local memory
- Visibility guarantees
- Ordering guarantees
- Happens-before relationships

---

## ðŸ’» Example 1: Memory Visibility Problem

```java
class MemoryVisibilityProblem {
    private boolean stop = false;
    
    public void writer() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        stop = true; // May never be visible to reader!
        System.out.println("Writer: stop = true");
    }
    
    public void reader() {
        int count = 0;
        while (!stop) { // May loop forever!
            count++;
        }
        System.out.println("Reader: stopped after " + count + " iterations");
    }
    
    public static void main(String[] args) {
        MemoryVisibilityProblem example = new MemoryVisibilityProblem();
        
        new Thread(example::reader).start();
        new Thread(example::writer).start();
    }
}
```

---

## ðŸ’» Example 2: Fixed with volatile

```java
class VolatileVisibility {
    private volatile boolean stop = false;
    
    public void writer() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        stop = true; // Guaranteed visible to reader
        System.out.println("Writer: stop = true");
    }
    
    public void reader() {
        int count = 0;
        while (!stop) {
            count++;
        }
        System.out.println("Reader: stopped after " + count + " iterations");
    }
    
    public static void main(String[] args) {
        VolatileVisibility example = new VolatileVisibility();
        
        new Thread(example::reader).start();
        new Thread(example::writer).start();
    }
}
```

---

## ðŸ’» Example 3: Reordering Problem

```java
class ReorderingProblem {
    private int x = 0, y = 0;
    private int a = 0, b = 0;
    
    public void thread1() {
        a = 1; // (1)
        x = b; // (2)
    }
    
    public void thread2() {
        b = 1; // (3)
        y = a; // (4)
    }
    
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 100000; i++) {
            ReorderingProblem example = new ReorderingProblem();
            
            Thread t1 = new Thread(example::thread1);
            Thread t2 = new Thread(example::thread2);
            
            t1.start();
            t2.start();
            
            t1.join();
            t2.join();
            
            // Possible outcomes due to reordering:
            // x=0, y=0 (if reordering occurs)
            // x=1, y=0
            // x=0, y=1
            // x=1, y=1
            
            if (example.x == 0 && example.y == 0) {
                System.out.println("Reordering detected! x=" + example.x + ", y=" + example.y);
                break;
            }
        }
    }
}
```

---

## ðŸ’» Example 4: Double-Checked Locking (Broken without volatile)

```java
class BrokenDoubleLocking {
    private static Object instance; // Missing volatile!
    
    public static Object getInstance() {
        if (instance == null) {
            synchronized (BrokenDoubleLocking.class) {
                if (instance == null) {
                    instance = new Object(); // Can be partially constructed!
                }
            }
        }
        return instance; // May return partially constructed object
    }
}

class FixedDoubleLocking {
    private static volatile Object instance; // volatile fixes it
    
    public static Object getInstance() {
        if (instance == null) {
            synchronized (FixedDoubleLocking.class) {
                if (instance == null) {
                    instance = new Object();
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                Object obj = getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + obj.hashCode());
            }).start();
        }
    }
}
```

---

## ðŸ’» Example 5: Word Tearing

```java
class WordTearing {
    // Non-volatile long (not atomic on 32-bit JVM)
    private long value = 0;
    
    public void writer() {
        value = 0x0123456789ABCDEFL;
    }
    
    public void reader() {
        long read = value;
        if (read != 0 && read != 0x0123456789ABCDEFL) {
            System.out.println("Word tearing detected: " + 
                             Long.toHexString(read));
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 100000; i++) {
            WordTearing example = new WordTearing();
            
            Thread writer = new Thread(example::writer);
            Thread reader = new Thread(example::reader);
            
            writer.start();
            reader.start();
            
            writer.join();
            reader.join();
        }
    }
}

class FixedWordTearing {
    // volatile ensures atomic read/write
    private volatile long value = 0;
    
    public void writer() {
        value = 0x0123456789ABCDEFL;
    }
    
    public void reader() {
        long read = value;
        System.out.println("Read: " + Long.toHexString(read));
    }
}
```

---

## ðŸ’» Example 6: Safe Publication

```java
class UnsafePublication {
    private int value;
    
    public UnsafePublication(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

// âŒ WRONG: Unsafe publication
class PublisherBroken {
    public static UnsafePublication object;
    
    public static void main(String[] args) {
        new Thread(() -> {
            object = new UnsafePublication(42);
        }).start();
        
        new Thread(() -> {
            UnsafePublication local = object;
            if (local != null) {
                // May see default value 0!
                System.out.println(local.getValue());
            }
        }).start();
    }
}

// âœ… CORRECT: Safe publication with final
class SafePublication {
    private final int value;
    
    public SafePublication(int value) {
        this.value = value;
    }
    
    public int getValue() {
        return value;
    }
}

// âœ… CORRECT: Safe publication with volatile
class PublisherFixed {
    public static volatile SafePublication object;
    
    public static void main(String[] args) {
        new Thread(() -> {
            object = new SafePublication(42);
        }).start();
        
        new Thread(() -> {
            SafePublication local = object;
            if (local != null) {
                // Guaranteed to see 42
                System.out.println(local.getValue());
            }
        }).start();
    }
}
```

---

## ðŸ’» Example 7: Cache Coherency

```java
class CacheCoherency {
    private int value1 = 0;
    private int value2 = 0;
    
    public void thread1() {
        value1 = 1;
        int temp = value2; // May read stale value from cache
        System.out.println("Thread1: value2 = " + temp);
    }
    
    public void thread2() {
        value2 = 2;
        int temp = value1; // May read stale value from cache
        System.out.println("Thread2: value1 = " + temp);
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 1000; i++) {
            CacheCoherency example = new CacheCoherency();
            
            Thread t1 = new Thread(example::thread1);
            Thread t2 = new Thread(example::thread2);
            
            t1.start();
            t2.start();
            
            try {
                t1.join();
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

---

## ðŸ“Š Memory Model Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Main Memory       â”‚
â”‚  (Shared Memory)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Working Memory    â”‚
â”‚   (Thread Cache)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†•
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Thread           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“Š Memory Operations

| Operation | Description | Guarantee |
|-----------|-------------|-----------|
| **Read** | Load from main to working memory | - |
| **Load** | Copy to thread | - |
| **Use** | Use value | - |
| **Assign** | Assign new value | - |
| **Store** | Transfer to main memory | - |
| **Write** | Write to main memory | - |
| **Lock** | Acquire monitor | Synchronization |
| **Unlock** | Release monitor | Synchronization |

---

## ðŸ’¡ Guarantees

### What JMM Guarantees:
1. âœ… Happens-before relationships
2. âœ… Visibility of synchronized operations
3. âœ… Visibility of volatile variables
4. âœ… Atomicity of reference assignments
5. âœ… Final field safety

### What JMM Does NOT Guarantee:
1. âŒ Order of independent operations
2. âŒ Visibility without synchronization
3. âŒ Atomicity of compound operations
4. âŒ Fairness

---

## ðŸ’¡ Best Practices

1. âœ… Use `volatile` for flags and status variables
2. âœ… Use `synchronized` for compound operations
3. âœ… Make fields `final` when possible
4. âœ… Use atomic variables for counters
5. âœ… Properly synchronize shared mutable state
6. âœ… Understand happens-before relationships

---

## ðŸŽ¯ Interview Questions

1. **What is the Java Memory Model?**
2. **What is memory visibility?**
3. **What does volatile guarantee?**
4. **What is instruction reordering?**
5. **What is word tearing?**
6. **What is safe publication?**

---

## ðŸ“š Next Topics

- [Volatile Keyword](../../02.%20Synchronization/03.%20Volatile%20Keyword.md)
- [Happens-Before](05.%20Happens-Before.md)
