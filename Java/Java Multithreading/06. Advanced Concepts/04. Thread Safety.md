# üõ°Ô∏è Thread Safety

## üìñ What is Thread Safety?

A class or method is thread-safe if it behaves correctly when accessed from multiple threads, regardless of scheduling or interleaving.

**Thread-Safe means:**
- No race conditions
- Consistent state
- Correct behavior under concurrent access

---

## üíª Example 1: Non-Thread-Safe Counter

```java
class NonThreadSafeCounter {
    private int count = 0;
    
    public void increment() {
        count++; // Not atomic! Read-Modify-Write
    }
    
    public int getCount() {
        return count;
    }
    
    public static void main(String[] args) throws InterruptedException {
        NonThreadSafeCounter counter = new NonThreadSafeCounter();
        
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    counter.increment();
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Count: " + counter.getCount());
        System.out.println("Expected: 10000");
    }
}
```

---

## üíª Example 2: Thread-Safe with Synchronized

```java
class SynchronizedCounter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
    
    public synchronized int getCount() {
        return count;
    }
    
    public static void main(String[] args) throws InterruptedException {
        SynchronizedCounter counter = new SynchronizedCounter();
        
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    counter.increment();
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Count: " + counter.getCount());
        System.out.println("Expected: 10000");
    }
}
```

---

## üíª Example 3: Thread-Safe with AtomicInteger

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
    
    public int getCount() {
        return count.get();
    }
    
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();
        
        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    counter.increment();
                }
            });
            threads[i].start();
        }
        
        for (Thread thread : threads) {
            thread.join();
        }
        
        System.out.println("Count: " + counter.getCount());
    }
}
```

---

## üíª Example 4: Immutable Thread-Safe Class

```java
final class ImmutablePerson {
    private final String name;
    private final int age;
    
    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // Thread-safe because immutable
    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge);
    }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
    
    public static void main(String[] args) {
        ImmutablePerson person = new ImmutablePerson("John", 30);
        
        // Multiple threads can safely access
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + person.getName() + ", " + person.getAge());
            }).start();
        }
    }
}
```

---

## üíª Example 5: Thread-Local Storage

```java
class ThreadSafeFormatter {
    private static ThreadLocal<SimpleDateFormat> formatter = 
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
    
    public static String format(Date date) {
        return formatter.get().format(date);
    }
    
    public static void main(String[] args) {
        Date now = new Date();
        
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                String formatted = format(now);
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + formatted);
            }).start();
        }
    }
}
```

---

## üíª Example 6: Thread-Safe Singleton (Double-Checked Locking)

```java
class ThreadSafeSingleton {
    private static volatile ThreadSafeSingleton instance;
    
    private ThreadSafeSingleton() {
        // Private constructor
    }
    
    public static ThreadSafeSingleton getInstance() {
        if (instance == null) { // First check (no locking)
            synchronized (ThreadSafeSingleton.class) {
                if (instance == null) { // Second check (with locking)
                    instance = new ThreadSafeSingleton();
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                ThreadSafeSingleton singleton = ThreadSafeSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + 
                                  ": " + singleton.hashCode());
            }).start();
        }
    }
}
```

---

## üíª Example 7: Thread-Safe Collection Wrapper

```java
import java.util.*;

class ThreadSafeCollection {
    private List<String> list = Collections.synchronizedList(new ArrayList<>());
    
    public void add(String item) {
        list.add(item);
    }
    
    public void printAll() {
        synchronized (list) { // Must synchronize for iteration
            for (String item : list) {
                System.out.println(item);
            }
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        ThreadSafeCollection collection = new ThreadSafeCollection();
        
        // Writers
        for (int i = 0; i < 5; i++) {
            final int id = i;
            new Thread(() -> {
                for (int j = 0; j < 10; j++) {
                    collection.add("Thread-" + id + "-Item-" + j);
                }
            }).start();
        }
        
        Thread.sleep(1000);
        collection.printAll();
    }
}
```

---

## üìä Thread Safety Techniques

| Technique | Performance | Complexity | Use Case |
|-----------|------------|------------|----------|
| **Synchronized** | Low | Low | Simple critical sections |
| **Locks** | Medium | Medium | Complex synchronization |
| **Atomic** | High | Low | Simple operations |
| **Immutable** | Highest | Medium | Read-heavy |
| **ThreadLocal** | High | Medium | Per-thread state |
| **Concurrent Collections** | High | Low | Collections |

---

## üí° Levels of Thread Safety

### 1. Immutable
```java
final class Immutable {
    private final int value;
    public Immutable(int value) { this.value = value; }
    public int getValue() { return value; }
}
```

### 2. Thread-Safe
```java
class ThreadSafe {
    private int value;
    public synchronized void setValue(int value) { this.value = value; }
    public synchronized int getValue() { return value; }
}
```

### 3. Conditionally Thread-Safe
```java
// Thread-safe for individual operations
// Requires external synchronization for compound operations
List<String> list = Collections.synchronizedList(new ArrayList<>());
```

### 4. Not Thread-Safe
```java
class NotThreadSafe {
    private int value;
    public void setValue(int value) { this.value = value; }
    public int getValue() { return value; }
}
```

---

## üí° Best Practices

1. ‚úÖ Prefer immutability
2. ‚úÖ Use concurrent collections
3. ‚úÖ Minimize synchronization scope
4. ‚úÖ Avoid holding locks during callbacks
5. ‚úÖ Document thread-safety guarantees
6. ‚úÖ Use atomic variables for simple operations
7. ‚úÖ Prefer composition over inheritance

---

## ‚ö†Ô∏è Common Pitfalls

```java
// ‚ùå BAD: Check-then-act race condition
if (!list.contains(item)) {
    list.add(item);
}

// ‚úÖ GOOD: Atomic operation
list.putIfAbsent(key, value);

// ‚ùå BAD: Publishing partially constructed object
public class Unsafe {
    private int value;
    
    public Unsafe() {
        new Thread(() -> System.out.println(value)).start();
        value = 42; // May not be visible
    }
}

// ‚úÖ GOOD: Complete construction before publishing
public class Safe {
    private final int value;
    
    public Safe() {
        value = 42;
        new Thread(() -> System.out.println(value)).start();
    }
}
```

---

## üéØ Interview Questions

1. **What is thread safety?**
2. **What are different ways to achieve thread safety?**
3. **What is the difference between synchronized and Lock?**
4. **Why is immutability thread-safe?**
5. **What is a race condition?**
6. **How do you make a class thread-safe?**

---

## üìö Next Topics

- [Happens-Before](04.%20Happens-Before.md)
- [Memory Model](05.%20Memory%20Model.md)
