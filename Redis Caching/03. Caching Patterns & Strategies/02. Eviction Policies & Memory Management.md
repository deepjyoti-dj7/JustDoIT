# 02. Eviction Policies & Memory Management

## Redis Memory Management

**Redis is in-memory** - data stored in RAM.

**Key Concepts:**
- Set `maxmemory` limit
- Choose eviction policy when limit reached
- Monitor memory usage
- Optimize data structures

---

## Maxmemory Configuration

### Set Memory Limit

```bash
# redis.conf
maxmemory 2gb

# Runtime
redis-cli CONFIG SET maxmemory 2gb
redis-cli CONFIG REWRITE  # Persist
```

### Check Memory Usage

```bash
# Total memory used
redis-cli INFO memory | grep used_memory_human
# used_memory_human:1.50G

# Memory stats
redis-cli MEMORY STATS

# Specific key memory
redis-cli MEMORY USAGE user:1001
# (integer) 56
```

---

## Eviction Policies

When `maxmemory` reached, Redis uses eviction policy to free memory.

### Configure Eviction Policy

```bash
# redis.conf
maxmemory-policy allkeys-lru

# Runtime
redis-cli CONFIG SET maxmemory-policy allkeys-lru
```

---

## Available Eviction Policies

### 1. noeviction (Default)

**Behavior:** Return errors when memory limit reached.

```bash
maxmemory-policy noeviction
```

**When command needs memory:**
```bash
SET newkey "value"
# (error) OOM command not allowed when used memory > 'maxmemory'.
```

**Use when:**
- Redis as primary database (can't afford data loss)
- Better to fail than lose data

---

### 2. allkeys-lru

**Behavior:** Evict **least recently used** keys from all keys.

```bash
maxmemory-policy allkeys-lru
```

**How it works:**
```
Keys: A (used 1h ago), B (used 5m ago), C (used 10s ago)
Memory full → Evict A (oldest access)
```

**Use when:**
- General purpose caching
- Some keys accessed more frequently
- Most popular choice

---

### 3. volatile-lru

**Behavior:** Evict LRU keys **only among keys with TTL**.

```bash
maxmemory-policy volatile-lru
```

**Example:**
```bash
SET key1 "value"          # No TTL
SET key2 "value" EX 3600  # With TTL
SET key3 "value" EX 7200  # With TTL

# Memory full → Evicts key2 or key3 (LRU with TTL)
# key1 is safe (no TTL)
```

**Use when:**
- Mix of cache (with TTL) and persistent data (no TTL)
- Want to protect persistent data

---

### 4. allkeys-lfu (Redis 4.0+)

**Behavior:** Evict **least frequently used** keys from all keys.

```bash
maxmemory-policy allkeys-lfu
```

**How it works:**
```
Keys: A (accessed 100 times), B (accessed 10 times), C (accessed 1000 times)
Memory full → Evict B (least frequent)
```

**Use when:**
- Want to keep frequently accessed data
- Better than LRU for identifying "hot" data

---

### 5. volatile-lfu

**Behavior:** Evict LFU keys **only among keys with TTL**.

```bash
maxmemory-policy volatile-lfu
```

**Use when:**
- Mix of cache and persistent data
- Want frequency-based eviction for cache

---

### 6. allkeys-random

**Behavior:** Evict **random** keys from all keys.

```bash
maxmemory-policy allkeys-random
```

**Use when:**
- All keys equally important
- Simple, fast eviction needed
- Rare use case

---

### 7. volatile-random

**Behavior:** Evict random keys **only among keys with TTL**.

```bash
maxmemory-policy volatile-random
```

**Use when:**
- Want to protect keys without TTL
- Random eviction acceptable for cache

---

### 8. volatile-ttl

**Behavior:** Evict keys with **shortest TTL** (soonest to expire).

```bash
maxmemory-policy volatile-ttl
```

**How it works:**
```
Keys: A (TTL: 100s), B (TTL: 10s), C (TTL: 1000s)
Memory full → Evict B (shortest TTL)
```

**Use when:**
- Want to evict data that's expiring soon anyway
- Logical choice for time-sensitive cache

---

## Eviction Policy Comparison

| Policy | Scope | Algorithm | Use Case |
|--------|-------|-----------|----------|
| **noeviction** | N/A | Return errors | Primary database |
| **allkeys-lru** | All keys | Least Recently Used | General caching |
| **volatile-lru** | TTL keys only | Least Recently Used | Mixed data |
| **allkeys-lfu** | All keys | Least Frequently Used | Hot data caching |
| **volatile-lfu** | TTL keys only | Least Frequently Used | Mixed data |
| **allkeys-random** | All keys | Random | All equal priority |
| **volatile-random** | TTL keys only | Random | Simple cache |
| **volatile-ttl** | TTL keys only | Shortest TTL first | Time-sensitive cache |

---

## LRU vs LFU

### LRU (Least Recently Used)

**Evicts:** Keys not accessed for longest time

**Good for:** Time-based access patterns

**Example:**
```
Access pattern: A, B, C, A, B, C, A, B, C
All accessed recently → All kept

New access: D
Evict: Oldest accessed (assume A)
```

### LFU (Least Frequently Used)

**Evicts:** Keys with lowest access count

**Good for:** Frequency-based access patterns

**Example:**
```
Access counts: A(100), B(10), C(1000)
Memory full → Evict B (least frequent)

Even if B was accessed recently, it's evicted
```

### Which to Choose?

**LRU:**
- Sequential access patterns
- Recent data more valuable
- Traditional caching

**LFU:**
- Some data accessed much more frequently
- "Hot" data should stay
- Better cache hit rate for skewed access

---

## Memory Optimization

### 1. Use Hashes for Objects

```bash
# ❌ Bad: Multiple keys (more overhead)
SET user:1001:name "John"
SET user:1001:email "john@example.com"
SET user:1001:age "30"
# Memory: ~200 bytes (overhead per key)

# ✅ Good: Single hash
HSET user:1001 name "John" email "john@example.com" age "30"
# Memory: ~80 bytes (single key overhead)
```

### 2. Set Appropriate TTL

```bash
# ❌ Bad: No TTL (data lives forever)
SET cache:data "value"

# ✅ Good: With TTL
SET cache:data "value" EX 3600
```

### 3. Use Compression

```python
import gzip
import json

# Compress before storing
data = json.dumps(large_object)
compressed = gzip.compress(data.encode())
redis.set('key', compressed)

# Decompress when reading
compressed = redis.get('key')
data = gzip.decompress(compressed).decode()
obj = json.loads(data)
```

### 4. Use Appropriate Data Structures

```bash
# ❌ Bad: Set for sequential IDs
SADD users "1001" "1002" "1003" ... "1100"
# Memory: ~5KB

# ✅ Good: Bitmap for sequential IDs
SETBIT users 1001 1
SETBIT users 1002 1
SETBIT users 1100 1
# Memory: ~150 bytes
```

### 5. Limit Collection Sizes

```python
# Keep only last 100 items
redis.lpush('recent:posts', post)
redis.ltrim('recent:posts', 0, 99)

# Keep only top 1000 in sorted set
redis.zadd('leaderboard', {player: score})
redis.zremrangebyrank('leaderboard', 0, -1001)
```

---

## Monitoring Memory

### Memory Info Commands

```bash
# Overall memory usage
INFO memory

# Peak memory
redis-cli INFO memory | grep used_memory_peak_human

# Memory fragmentation
redis-cli INFO memory | grep mem_fragmentation_ratio
# mem_fragmentation_ratio:1.2
# < 1.0 = swapping (bad)
# 1.0-1.5 = healthy
# > 1.5 = fragmentation (consider restart)

# Check specific key
MEMORY USAGE user:1001
```

### Memory Alerts

```python
import redis

def check_memory_usage():
    r = redis.Redis()
    info = r.info('memory')
    
    used = info['used_memory']
    maxmem = info['maxmemory']
    
    if maxmem > 0:
        usage_percent = (used / maxmem) * 100
        
        if usage_percent > 90:
            alert(f"Redis memory usage critical: {usage_percent}%")
        elif usage_percent > 80:
            warn(f"Redis memory usage high: {usage_percent}%")
```

---

## Best Practices

### 1. Always Set maxmemory

```bash
# ✅ Set limit based on available RAM
maxmemory 2gb

# Leave ~25% for OS/other processes
# Server RAM: 8GB → maxmemory: 6gb
```

### 2. Choose Right Eviction Policy

```bash
# General caching
maxmemory-policy allkeys-lru

# Mix of cache and persistent data
maxmemory-policy volatile-lru

# Hot data caching
maxmemory-policy allkeys-lfu
```

### 3. Set TTL on Cache Data

```python
# ✅ Cache with TTL
redis.setex('cache:user:1001', 3600, data)

# ✅ Persistent data without TTL
redis.set('config:settings', data)
```

### 4. Monitor Memory Usage

```bash
# Set up monitoring
redis-cli --stat

# Check memory usage regularly
redis-cli INFO memory | grep used_memory_human
```

### 5. Use Memory-Efficient Data Types

```bash
# ✅ Hash for objects
HSET user:1001 ...

# ✅ Bitmap for boolean arrays
SETBIT active:users 1001 1

# ✅ HyperLogLog for cardinality
PFADD unique:visitors "user1"
```

---

## Production Configuration

```bash
# redis.conf

# Memory limit
maxmemory 4gb

# Eviction policy
maxmemory-policy allkeys-lru

# Sample size for LRU (higher = more accurate, slower)
maxmemory-samples 5

# Lazy freeing (delete in background)
lazyfree-lazy-eviction yes
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes
```

---

## Summary

**Eviction Policies:**
- `noeviction`: Return errors (default)
- `allkeys-lru`: General caching (popular)
- `volatile-lru`: Mixed data
- `allkeys-lfu`: Hot data caching
- `volatile-ttl`: Time-sensitive cache

**Memory Optimization:**
- Use hashes for objects
- Set TTL on cache data
- Use compression for large values
- Choose appropriate data structures
- Limit collection sizes

**Monitoring:**
- Set `maxmemory` limit
- Monitor memory usage
- Alert on high usage (>80%)
- Check fragmentation ratio

---

## Interview Questions & Answers

### Q1: What are Redis eviction policies?
**A:** Strategies to free memory when `maxmemory` limit is reached:
- `noeviction`: Return errors
- `allkeys-lru`: Evict least recently used (all keys)
- `volatile-lru`: Evict LRU (only TTL keys)
- `allkeys-lfu`: Evict least frequently used
- `volatile-ttl`: Evict shortest TTL first

### Q2: What's the difference between allkeys-lru and volatile-lru?
**A:**
- **allkeys-lru**: Evicts from ALL keys (cache + persistent)
- **volatile-lru**: Evicts only from keys WITH TTL

**Example:**
```bash
SET key1 "data"          # No TTL
SET key2 "data" EX 3600  # With TTL

# allkeys-lru: Can evict both
# volatile-lru: Only evicts key2
```

### Q3: What's the default eviction policy?
**A:** `noeviction` - Returns errors when memory limit reached:
```bash
(error) OOM command not allowed when used memory > 'maxmemory'.
```

### Q4: What's the difference between LRU and LFU?
**A:**
- **LRU (Least Recently Used)**: Evicts keys not accessed for longest time
- **LFU (Least Frequently Used)**: Evicts keys with lowest access count

**LRU:** Recent access matters
**LFU:** Access frequency matters

### Q5: When should you use allkeys-lru?
**A:** For **general purpose caching**:
- All data is cache (can be evicted)
- Recent data more valuable
- Most common choice

```bash
maxmemory-policy allkeys-lru
```

### Q6: When should you use volatile-ttl?
**A:** When evicting data that's **expiring soon anyway**:
```bash
Keys: A(TTL:10s), B(TTL:100s), C(TTL:1000s)
Evict A first (shortest TTL)
```
Good for time-sensitive cache.

### Q7: How do you check Redis memory usage?
**A:**
```bash
# Total memory
redis-cli INFO memory | grep used_memory_human

# Specific key
redis-cli MEMORY USAGE key

# Memory stats
redis-cli MEMORY STATS
```

### Q8: What is memory fragmentation ratio?
**A:** Ratio of allocated memory to used memory:
```bash
redis-cli INFO memory | grep mem_fragmentation_ratio
# 1.2
```

**Interpretation:**
- **< 1.0**: Swapping (bad!)
- **1.0-1.5**: Healthy
- **> 1.5**: Fragmentation (consider restart)

### Q9: How do you optimize memory for storing user objects?
**A:** Use **hashes** instead of multiple keys:
```bash
# ❌ Bad: 3 keys
SET user:1001:name "John"
SET user:1001:email "john@example.com"
SET user:1001:age "30"

# ✅ Good: 1 hash
HSET user:1001 name "John" email "john@example.com" age "30"
```
Saves ~60% memory!

### Q10: Should you always set maxmemory?
**A:** **Yes** in production!
```bash
maxmemory 4gb
```
Prevents Redis from consuming all server RAM. Leave ~25% for OS.

### Q11: What happens when Redis runs out of memory with noeviction?
**A:** Commands requiring memory return errors:
```bash
SET newkey "value"
# (error) OOM command not allowed when used memory > 'maxmemory'.
```
Read commands (GET) still work.

### Q12: How do you reduce memory usage for large datasets?
**A:**
1. **Set TTL**: Expire old data
2. **Use hashes**: Group related fields
3. **Compression**: gzip before storing
4. **Bitmaps**: For boolean arrays
5. **HyperLogLog**: For cardinality
6. **Limit sizes**: LTRIM lists, ZREMRANGEBYRANK sorted sets

### Q13: What is maxmemory-samples?
**A:** Number of keys sampled for LRU/LFU eviction:
```bash
maxmemory-samples 5  # Default
```
- **Higher**: More accurate, slower
- **Lower**: Less accurate, faster

Default (5) is good balance.

### Q14: Can eviction policies cause data loss?
**A:** Yes! Any policy except `noeviction` can evict data:
```bash
# allkeys-lru: Can evict ANY key
# volatile-lru: Can evict keys with TTL
```
Use `noeviction` if data loss unacceptable.

### Q15: How do you configure eviction policy at runtime?
**A:**
```bash
redis-cli CONFIG SET maxmemory-policy allkeys-lru
redis-cli CONFIG REWRITE  # Persist to redis.conf
```
No restart needed!

**Next:** Cache Invalidation Strategies!