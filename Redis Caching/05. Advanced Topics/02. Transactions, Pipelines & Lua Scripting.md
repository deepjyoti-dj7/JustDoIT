# 02. Transactions, Pipelines & Lua Scripting

## Overview

- Pipelines: Batch commands to reduce network round-trips (not atomic).
- Transactions (MULTI/EXEC): Execute atomically.
- WATCH: Optimistic locking.
- Lua: Atomic server-side scripts.

---

## Pipelines

```javascript
const pipeline = redis.pipeline();
pipeline.set('a','1');
pipeline.incr('a');
const res = await pipeline.exec(); // [[null,'OK'],[null,2]]
```

- Use for throughput; not atomic.
- Errors isolated per command.

---

## Transactions (MULTI/EXEC)

```javascript
const tx = redis.multi();
tx.set('balance:alice', 100);
tx.decrby('balance:alice', 10);
const result = await tx.exec(); // All-or-nothing
```

### Optimistic Locking (WATCH)

```javascript
await redis.watch('balance:alice');
const bal = Number(await redis.get('balance:alice'));
if (bal >= 10) {
  const tx = redis.multi();
  tx.decrby('balance:alice', 10);
  const ok = await tx.exec();
  if (!ok) throw new Error('Concurrent modification');
}
await redis.unwatch();
```

---

## Lua Scripting

### Why Lua?
- Atomic execution on server.
- Reduce round-trips.
- Complex logic (rate limiting, conditional updates).

### Examples

#### Conditional Update
```lua
-- KEYS[1]=key, ARGV[1]=expected, ARGV[2]=new
local cur = redis.call('GET', KEYS[1])
if cur == ARGV[1] then
  redis.call('SET', KEYS[1], ARGV[2])
  return 1
else
  return 0
end
```

```javascript
const script = "...";
const updated = await redis.eval(script, 1, 'user:1001:name', 'John', 'Jane');
```

#### Token Bucket Rate Limiter
```lua
-- KEYS[1]=bucket, ARGV[1]=capacity, ARGV[2]=refill, ARGV[3]=nowMillis
local tokens = tonumber(redis.call('GET', KEYS[1]) or ARGV[1])
if tokens > 0 then
  tokens = tokens - 1
  redis.call('SET', KEYS[1], tokens)
  return 1
else
  return 0
end
```

---

## Idempotency & Deduplication

```javascript
// Use SETNX to guard execution
const ok = await redis.set('dedupe:order:o-123', '1', 'NX', 'EX', 3600);
if (ok) processOrder(); // else skip duplicate
```

---

## Error Handling

- Pipeline: check per-command error tuple.
- MULTI/EXEC: returns `null` if WATCH failed; handle retries.
- Lua: validate args; avoid long-running scripts.

---

## Best Practices

- Keep Lua scripts short and deterministic.
- Use `EVALSHA` caching for performance.
- Prefer WATCH for optimistic updates; avoid heavy locks.
- Use pipelines for read-heavy batches.
- Set timeouts for transactions.

---

## Summary

Combine pipelines for throughput, MULTI/EXEC for atomicity, WATCH for concurrency control, and Lua for server-side logic.

---

## Interview Questions & Answers

1) Q: Difference between pipeline and transaction?
   A: Pipeline batches commands without atomicity; transaction (`MULTI/EXEC`) runs atomically.

2) Q: What does WATCH do?
   A: Marks keys for optimistic locking; if changed before `EXEC`, transaction aborts.

3) Q: When use Lua vs MULTI/EXEC?
   A: Lua for complex atomic logic inside server; MULTI/EXEC for grouped simple ops.

4) Q: How to detect transaction abort?
   A: `EXEC` returns `null` if watched keys changed.

5) Q: How to retry on WATCH conflict?
   A: Loop: WATCH → read → MULTI → EXEC; if `null`, UNWATCH and retry.

6) Q: Why prefer `EVALSHA`?
   A: Avoid sending script body each time; cache by SHA1.

7) Q: How to ensure idempotency?
   A: Use `SETNX` dedupe keys, store processed IDs, or idempotent writes.

8) Q: What’s a token bucket limiter?
   A: Allow N tokens per window; decrement per request; refill tokens periodically.

9) Q: Can pipelines reorder operations?
   A: Execution order is preserved; responses returned in order.

10) Q: Are transactions isolated?
    A: Redis provides atomicity, but not full isolation levels like SQL; commands queued then executed.

11) Q: How to conditionally update a value?
    A: Use Lua or `WATCH` + check + `MULTI`.

12) Q: Why avoid long Lua scripts?
    A: They block the single-threaded server; keep short to avoid latency.

13) Q: How to batch reads efficiently?
    A: Pipeline `MGET` or multiple `GET`s and parse results.

14) Q: What happens if a command fails in MULTI?
    A: Errors are returned for the specific command; overall transaction still executes.

15) Q: How to use optimistic concurrency with hashes?
    A: `WATCH` the hash key, read fields, `MULTI` update fields, `EXEC`, retry on change.
