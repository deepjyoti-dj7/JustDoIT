# 01. Pub-Sub & Messaging

## Overview

Redis supports two messaging models:
- Pub/Sub: Ephemeral broadcast, no persistence or replay.
- Streams: Durable event log with consumer groups and backpressure.

Use Pub/Sub for real-time notifications; Streams for reliable pipelines.

---

## Pub/Sub Basics

### Publisher
```javascript
// Node.js (ioredis)
const Redis = require('ioredis');
const pub = new Redis();
await pub.publish('events:user', JSON.stringify({ type: 'USER_CREATED', id: 1001 }));
```

### Subscriber
```javascript
const sub = new Redis();
await sub.subscribe('events:user');
sub.on('message', (channel, payload) => {
  const msg = JSON.parse(payload);
  console.log('Got', channel, msg);
});
```

### Spring Boot
```java
// Listener
@Bean
RedisMessageListenerContainer container(RedisConnectionFactory cf, MessageListener listener) {
  var c = new RedisMessageListenerContainer();
  c.setConnectionFactory(cf);
  c.addMessageListener(listener, new PatternTopic("events:user"));
  return c;
}

@Bean
MessageListener listener() {
  return (message, pattern) -> System.out.println(new String(message.getBody()));
}

// Publisher
stringRedisTemplate.convertAndSend("events:user", "{\"type\":\"USER_CREATED\"}");
```

### Characteristics
- Fire-and-forget; late subscribers miss messages.
- Fan-out to many subscribers.
- Use for chat, live updates, cache invalidation signals.

---

## Patterns with Pub/Sub

- Fan-out: One producer, many subscribers.
- Topic partitioning: Use channels per entity (e.g., `events:user:1001`).
- Filtering: Subscribers filter by message type.
- Reliability wrapper: Combine Pub/Sub with persistent side-effects to recover.

```javascript
// Reliability: also write to a durable store
await pub.publish('events:order', JSON.stringify(evt));
await redis.xadd('stream:order-audit', '*', 'evt', JSON.stringify(evt));
```

---

## Streams Overview

### Properties
- Durable log with IDs.
- Consumer groups (work distribution and replay).
- Pending list handling, backpressure (`BLOCK`).

### Producer
```javascript
await redis.xadd('stream:orders', '*', 'orderId', 'o-123', 'amount', '49.99');
```

### Consumer Group
```javascript
// Create group once
try { await redis.xgroup('CREATE', 'stream:orders', 'order-workers', '$', 'MKSTREAM'); } catch (e) {}

// Consume (claim new entries)
const resp = await redis.xreadgroup('GROUP','order-workers','worker-1','BLOCK',5000,'COUNT',10,'STREAMS','stream:orders','>');
for (const [stream, msgs] of resp || []) {
  for (const [id, fields] of msgs) {
    // process
    await redis.xack('stream:orders','order-workers',id);
  }
}
```

### Spring Streams
```java
// Add
var record = MapRecord.create("stream:orders", Map.of("orderId","o-123"));
redis.opsForStream().add(record);

// Create group
redis.opsForStream().createGroup("stream:orders", ReadOffset.latest(), "order-workers");

// Read loop
var records = redis.opsForStream().read(
  Consumer.from("order-workers","worker-1"),
  StreamReadOptions.empty().count(10).block(Duration.ofSeconds(5)),
  StreamOffset.create("stream:orders", ReadOffset.lastConsumed())
);
```

---

## Pub/Sub vs Streams

| Feature | Pub/Sub | Streams |
|--------|---------|---------|
| Persistence | No | Yes |
| Replay | No | Yes |
| Backpressure | No | Yes (`BLOCK`) |
| Groups | No | Yes |
| Use cases | Chat, notifications | Pipelines, ETL, event sourcing |

---

## Best Practices

- Use Pub/Sub for ephemeral signals (invalidate caches, UI updates).
- Use Streams for durable workflows and retries.
- Create consumer groups once; handle `BUSYGROUP` errors.
- Acknowledge (`XACK`) after successful processing.
- Use dead-letter streams for failed messages.

---

## Summary

Pub/Sub is lightweight broadcast; Streams add durability and work distribution. Choose based on reliability needs and replay requirements.

---

## Interview Questions & Answers

1) Q: Why prefer Streams over Pub/Sub for processing orders?
   A: Streams persist entries, support consumer groups, and allow retries and replay; Pub/Sub drops messages for offline consumers.

2) Q: How do you prevent message loss in Pub/Sub?
   A: You can’t; it’s ephemeral. Use Streams or write side-effects to durable storage.

3) Q: What does `XREADGROUP` with `>` do?
   A: It fetches new, unclaimed entries for the group; avoids reprocessing acknowledged ones.

4) Q: How to scale consumers?
   A: Add more consumers to the same group; Redis distributes messages among them.

5) Q: What’s the pending list?
   A: Unacknowledged messages tracked per group; recover by inspecting and claiming (`XPENDING`, `XCLAIM`).

6) Q: How to implement retries?
   A: Use `XPENDING` to find stuck entries, `XCLAIM` to move to another consumer; count attempts and move to DLQ on max retries.

7) Q: Can Pub/Sub guarantee ordering?
   A: No strict guarantees across subscribers; Streams preserve per-stream order.

8) Q: How to do fan-out efficiently?
   A: Use channel per topic, subscribers per interest; avoid broadcasting to giant wildcard topics; consider Streams for large scale.

9) Q: What’s `XGROUP CREATE` with `MKSTREAM`?
   A: Creates stream if it doesn’t exist alongside the group.

10) Q: How do you shard Streams?
    A: Use multiple streams by partition key; consumers subscribe to specific partitions.

11) Q: How to backpressure consumers?
    A: Use `BLOCK` with `XREADGROUP`, fixed batch size; scale workers.

12) Q: What is a dead-letter stream?
    A: A dedicated stream to store failed messages for later inspection or manual handling.

13) Q: How to ensure exactly-once processing?
    A: Hard in distributed systems; aim for at-least-once with idempotent handlers and deduplication keys.

14) Q: Difference between `XACK` and `DEL`?
    A: `XACK` acknowledges a pending entry; the entry stays in the stream for history. Deleting removes it.

15) Q: How to broadcast cache invalidations?
    A: Publish key patterns or IDs on Pub/Sub; subscribers delete/update caches accordingly.
