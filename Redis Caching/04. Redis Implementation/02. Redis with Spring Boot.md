# 02. Redis with Spring Boot

## Overview

Use Spring Boot + Spring Data Redis (Lettuce client by default) for caching, data operations, Pub/Sub, Streams, and high availability with Sentinel/Cluster.

---

## Dependencies

```xml
<!-- pom.xml -->
<dependencies>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
  <!-- Optional: Jackson for JSON serializers -->
  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
  </dependency>
</dependencies>
```

---

## Configuration

### Basic Connection

```yaml
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    password: ${REDIS_PASSWORD:}
    timeout: 2000
```

### RedisTemplate + Serializers

```java
@Configuration
public class RedisConfig {

  @Bean
  public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(connectionFactory);

    // Key serializer
    template.setKeySerializer(new StringRedisSerializer());

    // Value serializer (JSON)
    GenericJackson2JsonRedisSerializer serializer = new GenericJackson2JsonRedisSerializer();
    template.setValueSerializer(serializer);
    template.setHashKeySerializer(new StringRedisSerializer());
    template.setHashValueSerializer(serializer);

    template.afterPropertiesSet();
    return template;
  }
}
```

---

## Cache Abstraction (@Cacheable)

### Enable Caching + CacheManager

```java
@Configuration
@EnableCaching
public class CacheConfig {

  @Bean
  public RedisCacheManager cacheManager(RedisConnectionFactory cf) {
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
      .entryTtl(Duration.ofHours(1))
      .disableCachingNullValues()
      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

    return RedisCacheManager.builder(cf)
      .cacheDefaults(config)
      .withCacheConfiguration("users", config.entryTtl(Duration.ofMinutes(30)))
      .build();
  }
}
```

### Usage

```java
@Service
public class UserService {
  @Autowired private UserRepository repo;

  @Cacheable(value = "users", key = "#id")
  public User getUser(Long id) {
    return repo.findById(id).orElseThrow();
  }

  @CachePut(value = "users", key = "#user.id")
  public User updateUser(User user) {
    return repo.save(user);
  }

  @CacheEvict(value = "users", key = "#id")
  public void deleteUser(Long id) {
    repo.deleteById(id);
  }
}
```

---

## Data Operations (RedisTemplate)

```java
@Service
public class RedisOpsService {
  @Autowired private RedisTemplate<String, Object> redis;

  // Strings
  public void setName(Long userId, String name) {
    redis.opsForValue().set("user:" + userId + ":name", name, Duration.ofHours(1));
  }
  public String getName(Long userId) {
    return (String) redis.opsForValue().get("user:" + userId + ":name");
  }

  // Hashes
  public void putUser(Long id, Map<String, Object> fields) {
    redis.opsForHash().putAll("user:" + id, fields);
  }
  public Map<Object, Object> getUser(Long id) {
    return redis.opsForHash().entries("user:" + id);
  }

  // Lists (queue)
  public void enqueue(String queue, Object item) {
    redis.opsForList().leftPush(queue, item);
  }
  public Object dequeue(String queue) {
    return redis.opsForList().rightPop(queue);
  }

  // Sets
  public void addTags(String key, String... tags) {
    redis.opsForSet().add(key, (Object[]) tags);
  }
  public Set<Object> getTags(String key) {
    return redis.opsForSet().members(key);
  }

  // Sorted Sets
  public void addScore(String board, String member, double score) {
    redis.opsForZSet().add(board, member, score);
  }
  public Set<Object> topN(String board, long n) {
    return redis.opsForZSet().reverseRange(board, 0, n - 1);
  }
}
```

---

## Transactions & Pipelines

```java
@Service
public class TxService {
  @Autowired private RedisTemplate<String, Object> redis;

  public void transfer(String from, String to, int amount) {
    redis.execute(new SessionCallback<Void>() {
      @Override
      public Void execute(RedisOperations operations) throws DataAccessException {
        operations.multi();
        operations.opsForValue().increment("balance:" + from, -amount);
        operations.opsForValue().increment("balance:" + to, amount);
        operations.exec();
        return null;
      }
    });
  }
}
```

---

## Pub/Sub

```java
@Configuration
public class PubSubConfig {

  @Bean
  public RedisMessageListenerContainer container(RedisConnectionFactory cf, MessageListener listener) {
    RedisMessageListenerContainer container = new RedisMessageListenerContainer();
    container.setConnectionFactory(cf);
    container.addMessageListener(listener, new PatternTopic("events:user"));
    return container;
  }

  @Bean
  public MessageListener listener() {
    return (message, pattern) -> {
      String channel = new String(pattern);
      String payload = new String(message.getBody());
      System.out.println("Received: " + channel + " → " + payload);
    };
  }
}

// Publisher
@Service
public class EventPublisher {
  @Autowired private StringRedisTemplate stringRedisTemplate;
  public void publishUserEvent(String eventJson) {
    stringRedisTemplate.convertAndSend("events:user", eventJson);
  }
}
```

---

## Streams

```java
@Service
public class StreamService {
  @Autowired private RedisTemplate<String, Object> redis;

  public RecordId addOrder(Map<String, String> fields) {
    MapRecord<String, String, String> record = MapRecord.create("stream:orders", fields);
    return redis.opsForStream().add(record);
  }

  @PostConstruct
  public void initGroup() {
    try {
      redis.opsForStream().createGroup("stream:orders", ReadOffset.latest(), "order-workers");
    } catch (Exception e) {
      if (!e.getMessage().contains("BUSYGROUP")) throw e;
    }
  }

  public void consume(String consumer) {
    while (true) {
      List<MapRecord<String, Object, Object>> records = redis.opsForStream().read(
        Consumer.from("order-workers", consumer),
        StreamReadOptions.empty().count(10).block(Duration.ofSeconds(5)),
        StreamOffset.create("stream:orders", ReadOffset.lastConsumed())
      );
      if (records == null) continue;
      for (MapRecord<String, Object, Object> rec : records) {
        try {
          // process
          redis.opsForStream().acknowledge("stream:orders", "order-workers", rec.getId());
        } catch (Exception ex) {
          // log and continue
        }
      }
    }
  }
}
```

---

## Distributed Locks

```java
@Service
public class LockService {
  @Autowired private StringRedisTemplate redis;

  public <T> T withLock(String resource, Duration ttl, Supplier<T> action) {
    String token = UUID.randomUUID().toString();
    Boolean ok = redis.opsForValue().setIfAbsent(resource, token, ttl);
    if (Boolean.TRUE.equals(ok)) {
      try {
        return action.get();
      } finally {
        // Release only if token matches
        String current = redis.opsForValue().get(resource);
        if (token.equals(current)) redis.delete(resource);
      }
    }
    throw new IllegalStateException("Lock not acquired");
  }
}
```

---

## Sentinel & Cluster

### Sentinel

```yaml
spring:
  redis:
    sentinel:
      master: mymaster
      nodes:
        - localhost:26379
        - localhost:26380
```

### Cluster

```yaml
spring:
  redis:
    cluster:
      nodes:
        - localhost:7000
        - localhost:7001
        - localhost:7002
```

---

## Rate Limiting (Lua)

```java
@Service
public class RateLimiterService {
  @Autowired private StringRedisTemplate redis;

  private static final String SCRIPT = """
  local key = KEYS[1]
  local limit = tonumber(ARGV[1])
  local window = tonumber(ARGV[2])
  local current = redis.call('INCR', key)
  if current == 1 then
    redis.call('EXPIRE', key, window)
  end
  return current
  """;

  public boolean allow(String key, int limit, int windowSec) {
    Long count = redis.execute((RedisCallback<Long>) con -> con.eval(
      SCRIPT.getBytes(), ReturnType.INTEGER, 1,
      key.getBytes(), String.valueOf(limit).getBytes(), String.valueOf(windowSec).getBytes()
    ));
    return count <= limit;
  }
}
```

---

## Testing Tips

- Use `@DataRedisTest` for slice tests.
- Use Testcontainers `redis:latest` for integration tests.
- Clear keys in `@AfterEach` for deterministic tests.

---

## Summary

- Configure RedisTemplate with JSON serializers.
- Use Spring Cache for easy caching (`@Cacheable`, `@CachePut`, `@CacheEvict`).
- Implement Streams, Pub/Sub, transactions via RedisTemplate.
- Add rate limiting and distributed locks for robustness.
- Use Sentinel/Cluster for HA and scale.

---

## Interview Questions & Answers

1) Q: Why use Spring Cache abstraction?
   A: Declarative caching with minimal code: `@Cacheable` reads through, `@CachePut` write-through, `@CacheEvict` invalidation. Central TTL and serialization via `RedisCacheManager`.

2) Q: How to store complex objects in Redis?
   A: Configure `GenericJackson2JsonRedisSerializer` for values and hashes in `RedisTemplate` to automatically serialize/deserialize JSON.

3) Q: Difference between `RedisTemplate` and `StringRedisTemplate`?
   A: `StringRedisTemplate` is specialized for String keys/values; `RedisTemplate` is generic and supports custom serializers for complex objects.

4) Q: How to implement atomic updates?
   A: Use `RedisTemplate.execute(SessionCallback)` with `MULTI/EXEC` or Lua scripts to guarantee atomic sequences.

5) Q: How to build a queue in Spring?
   A: Use Lists (`LPUSH`/`BRPOP`) for simple FIFO, or Streams with consumer groups for durable, concurrent processing and replay.

6) Q: When to prefer Streams over Pub/Sub?
   A: Streams persist events and support consumer groups and backpressure; Pub/Sub is ephemeral and best for real-time broadcast without replay.

7) Q: How do you configure Redis Sentinel in Spring?
   A: Set `spring.redis.sentinel.master` and `spring.redis.sentinel.nodes` in `application.yml`; Spring Boot auto-configures Lettuce client for HA.

8) Q: How to avoid stale cache entries?
   A: Set TTLs in `RedisCacheConfiguration`, use `@CacheEvict` on updates/deletes, and consider versioned keys for bulk invalidations.

9) Q: How to implement a rate limiter?
   A: Evaluate a Lua script that `INCR`s a key and `EXPIRE`s the window; allow if count ≤ limit.

10) Q: How to implement distributed locks safely?
    A: Use `SET NX EX` (via `setIfAbsent`) with a token; release only if token matches to avoid unlocking others' locks.

11) Q: How to perform multi-key ops in Cluster?
    A: Use hash tags (e.g., `user:{1001}:name`, `user:{1001}:email`) to ensure keys hash to same slot; otherwise cross-slot errors occur.

12) Q: How to configure JSON cache values?
    A: In `RedisCacheConfiguration`, set `serializeValuesWith(GenericJackson2JsonRedisSerializer)` to store values as JSON.

13) Q: How to test Redis-dependent code?
    A: Use Testcontainers Redis, `@DataRedisTest`, and clear test keys; mock repositories for cache tests.

14) Q: How to handle connection failures?
    A: Lettuce handles reconnections; configure timeouts, enable health checks, and degrade gracefully with fallbacks to DB.

15) Q: What are common RedisTemplate ops?
    A: `opsForValue`, `opsForHash`, `opsForList`, `opsForSet`, `opsForZSet`, and `opsForStream` for Streams.
