# 01. Strings & Numbers

## Redis Strings

**Strings** are the most basic Redis data type, representing a sequence of bytes.

**Max Size:** 512 MB per value

**Use Cases:**
- Store user data (name, email)
- Cache HTML pages
- Counters and numbers
- Session tokens
- JSON/serialized objects

---

## Basic String Commands

### SET - Set a Key

```bash
# Basic set
SET key "value"
SET username "john_doe"
SET email "john@example.com"

# Set with expiration (seconds)
SET session:abc123 "user_data" EX 3600

# Set with expiration (milliseconds)
SET cache:page1 "<html>..." PX 60000

# Set only if key doesn't exist (NX)
SET user:1000 "John" NX

# Set only if key exists (XX)
SET user:1000 "Jane" XX

# Set and return old value
SET counter 100
GETSET counter 200  # Returns: "100", sets to 200
```

### GET - Get a Key

```bash
GET username
# "john_doe"

GET nonexistent
# (nil)
```

### MSET / MGET - Multiple Keys

```bash
# Set multiple keys at once
MSET user:1:name "John" user:1:age "30" user:1:city "NYC"

# Get multiple keys
MGET user:1:name user:1:age user:1:city
# 1) "John"
# 2) "30"
# 3) "NYC"

# Set multiple only if all keys don't exist
MSETNX key1 "value1" key2 "value2"
```

### APPEND - Append to String

```bash
SET message "Hello"
APPEND message " World"
GET message
# "Hello World"

# Returns length after append
APPEND message "!"
# (integer) 12
```

### STRLEN - String Length

```bash
SET name "John Doe"
STRLEN name
# (integer) 8
```

### GETRANGE / SETRANGE - Substring Operations

```bash
SET message "Hello World"

# Get substring (0-indexed, inclusive)
GETRANGE message 0 4
# "Hello"

GETRANGE message 6 10
# "World"

GETRANGE message -5 -1
# "World"

# Set substring
SETRANGE message 6 "Redis"
GET message
# "Hello Redis"
```

---

## Numbers & Counters

### INCR / DECR - Increment/Decrement

```bash
# Initialize counter
SET pageviews 0

# Increment by 1
INCR pageviews
# (integer) 1

INCR pageviews
# (integer) 2

# Decrement by 1
DECR pageviews
# (integer) 1
```

### INCRBY / DECRBY - Increment/Decrement by Amount

```bash
SET score 100

# Increment by 50
INCRBY score 50
# (integer) 150

# Decrement by 30
DECRBY score 30
# (integer) 120
```

### INCRBYFLOAT - Increment by Float

```bash
SET temperature 20.5

INCRBYFLOAT temperature 1.5
# "22"

INCRBYFLOAAT temperature -0.5
# "21.5"
```

---

## Advanced String Operations

### Atomic Operations

```bash
# Check and set atomically
SET lock:resource1 "process1" NX EX 10
# OK (if lock acquired)
# (nil) (if lock already held)

# Get and delete atomically
GETDEL lock:resource1
# "process1"
# Key is deleted
```

### GETEX - Get with Expiration Options

```bash
# Get and set/update expiration
GETEX cache:page1 EX 3600
GETEX cache:page2 PX 60000
GETEX cache:page3 EXAT 1735689600  # Unix timestamp

# Get and persist (remove TTL)
GETEX cache:page4 PERSIST
```

---

## String Use Cases

### 1. Caching

```bash
# Cache user profile
SET user:profile:1001 '{"name":"John","age":30}' EX 3600

# Cache API response
SET api:weather:NYC '{"temp":25,"condition":"sunny"}' EX 300
```

### 2. Session Management

```bash
# Store session token
SET session:abc123 '{"userId":1001,"role":"admin"}' EX 1800

# Get session
GET session:abc123

# Extend session
EXPIRE session:abc123 1800
```

### 3. Rate Limiting

```bash
# Track API requests
SET ratelimit:user:1001 0 EX 60
INCR ratelimit:user:1001

# Check if limit exceeded
GET ratelimit:user:1001
# If > 100, reject request
```

### 4. Counters

```bash
# Page views
INCR pageviews:homepage

# Like counter
INCR post:123:likes

# Download counter
INCRBY file:document.pdf:downloads 1
```

### 5. Distributed Lock

```bash
# Acquire lock
SET lock:resource1 "server1" NX EX 10

# Do work...

# Release lock
DEL lock:resource1
```

---

## Binary Data

### Store Binary Data

```bash
# Store image (base64 encoded)
SET image:logo "iVBORw0KGgoAAAANSUhEUgA..."

# Store serialized data
SET cache:object "\x80\x04\x95..."
```

---

## Performance Characteristics

### Time Complexity

| Command | Time Complexity |
|---------|----------------|
| SET | O(1) |
| GET | O(1) |
| MSET | O(N) - N is number of keys |
| MGET | O(N) - N is number of keys |
| INCR/DECR | O(1) |
| APPEND | O(1) - amortized |
| STRLEN | O(1) |
| GETRANGE | O(N) - N is length of string |

### Memory Usage

```bash
# Check memory usage
MEMORY USAGE key

# Example
SET small "hello"
MEMORY USAGE small
# (integer) 56 (overhead + data)

SET large "very long string..."
MEMORY USAGE large
# (integer) 1056
```

---

## Best Practices

### 1. Use Appropriate TTL

```bash
# Short-lived cache
SET cache:temp "data" EX 60

# Session data
SET session:token "xyz" EX 3600

# Long-term cache
SET config:settings "json" EX 86400
```

### 2. Use MGET/MSET for Batch Operations

```bash
# ❌ Bad: Multiple round trips
SET user:1:name "John"
SET user:1:age "30"
SET user:1:city "NYC"

# ✅ Good: Single round trip
MSET user:1:name "John" user:1:age "30" user:1:city "NYC"
```

### 3. Atomic Operations for Counters

```bash
# ❌ Bad: Race condition
count = GET counter
count += 1
SET counter count

# ✅ Good: Atomic
INCR counter
```

### 4. Use NX/XX for Conditional Sets

```bash
# Set only if doesn't exist (avoid overwrite)
SET user:1000 "John" NX

# Set only if exists (ensure update, not create)
SET user:1000 "Jane" XX
```

---

## Common Patterns

### Pattern 1: Cache-Aside

```python
# Python example
def get_user(user_id):
    key = f"user:{user_id}"
    
    # Try cache first
    cached = redis.get(key)
    if cached:
        return json.loads(cached)
    
    # Cache miss - fetch from DB
    user = db.query(f"SELECT * FROM users WHERE id={user_id}")
    
    # Store in cache
    redis.set(key, json.dumps(user), ex=3600)
    
    return user
```

### Pattern 2: Rate Limiting (Sliding Window)

```python
def is_rate_limited(user_id):
    key = f"ratelimit:{user_id}"
    current = int(time.time())
    
    # Increment counter with TTL
    count = redis.incr(key)
    if count == 1:
        redis.expire(key, 60)  # 60 second window
    
    return count > 100  # Max 100 requests per minute
```

### Pattern 3: Distributed Lock

```python
import uuid
import time

def acquire_lock(resource, ttl=10):
    lock_key = f"lock:{resource}"
    lock_value = str(uuid.uuid4())  # Unique identifier
    
    # Try to acquire lock
    acquired = redis.set(lock_key, lock_value, nx=True, ex=ttl)
    return lock_value if acquired else None

def release_lock(resource, lock_value):
    lock_key = f"lock:{resource}"
    
    # Only delete if we own the lock (Lua script for atomicity)
    script = """
    if redis.call('get', KEYS[1]) == ARGV[1] then
        return redis.call('del', KEYS[1])
    else
        return 0
    end
    """
    return redis.eval(script, 1, lock_key, lock_value)
```

---

## Summary

**String Commands:**
- `SET`, `GET`, `MSET`, `MGET`
- `INCR`, `DECR`, `INCRBY`, `DECRBY`
- `APPEND`, `STRLEN`, `GETRANGE`, `SETRANGE`
- `SETNX`, `SETEX`, `GETDEL`, `GETEX`

**Use Cases:**
- Caching (API responses, user data)
- Session management
- Counters (page views, likes)
- Rate limiting
- Distributed locks

**Best Practices:**
- Use TTL for cache
- Batch operations with MGET/MSET
- Atomic operations for counters
- Conditional sets with NX/XX

---

## Interview Questions & Answers

### Q1: What is the maximum size of a Redis string?
**A:** **512 MB**. However, for performance, it's recommended to keep values under 100 KB.

### Q2: How do you atomically increment a counter in Redis?
**A:** Use `INCR` or `INCRBY`:
```bash
INCR pageviews
INCRBY score 10
```
These are atomic operations, so no race conditions even with concurrent requests.

### Q3: What's the difference between SET with EX and SETEX?
**A:** They're functionally the same:
```bash
SET key "value" EX 60
SETEX key 60 "value"
```
Both set key with 60-second TTL. `SET ... EX` is the modern syntax.

### Q4: How do you implement a distributed lock with Redis?
**A:** Use `SET` with `NX` (not exist) and `EX` (expiration):
```bash
SET lock:resource1 "unique_id" NX EX 10
```
- `NX`: Only set if key doesn't exist (acquire lock)
- `EX 10`: Auto-release after 10 seconds (prevent deadlock)
- Check return value: OK (acquired), nil (failed)

### Q5: What's the difference between GET and GETDEL?
**A:**
- `GET`: Returns value, key remains
- `GETDEL`: Returns value and deletes key atomically

```bash
SET temp "data"
GET temp        # "data" (key still exists)
GETDEL temp     # "data" (key deleted)
GET temp        # (nil)
```

### Q6: How do you set multiple keys efficiently?
**A:** Use `MSET` instead of multiple `SET` commands:
```bash
# ❌ Bad: 3 network round trips
SET key1 "value1"
SET key2 "value2"
SET key3 "value3"

# ✅ Good: 1 network round trip
MSET key1 "value1" key2 "value2" key3 "value3"
```

### Q7: Can you increment a string that's not a number?
**A:** No, `INCR` only works on strings that represent integers:
```bash
SET name "John"
INCR name
# (error) ERR value is not an integer

SET count "10"
INCR count
# (integer) 11  ✅
```

### Q8: How do you implement rate limiting with Redis strings?
**A:**
```bash
# Track requests per user per minute
SET ratelimit:user:1001 0 EX 60
INCR ratelimit:user:1001

# Check limit
GET ratelimit:user:1001
# If > 100, reject request
```
Use INCR for atomic increments, TTL auto-resets the window.

### Q9: What's the time complexity of APPEND?
**A:** **O(1) amortized**. Redis allocates extra space to avoid frequent reallocations, making most appends O(1).

### Q10: How do you store JSON in Redis?
**A:** Serialize as string:
```bash
SET user:1001 '{"name":"John","age":30}' EX 3600
```
Or use RedisJSON module for native JSON operations:
```bash
JSON.SET user:1001 $ '{"name":"John","age":30}'
JSON.GET user:1001 $.name
```

### Q11: What does SETNX return?
**A:**
- **1**: Key was set (didn't exist before)
- **0**: Key was not set (already exists)

```bash
SETNX key "value"  # 1 (set successfully)
SETNX key "value2" # 0 (key exists, not set)
```

### Q12: How do you get a substring in Redis?
**A:** Use `GETRANGE`:
```bash
SET message "Hello World"
GETRANGE message 0 4   # "Hello"
GETRANGE message 6 10  # "World"
GETRANGE message -5 -1 # "World" (negative indices)
```

### Q13: Can you increment a key that doesn't exist?
**A:** Yes! `INCR` initializes non-existent keys to 0, then increments:
```bash
INCR newcounter
# (integer) 1  (initialized to 0, then incremented)
```

### Q14: What's the difference between INCR and INCRBY?
**A:**
- `INCR`: Increment by 1
- `INCRBY`: Increment by specified amount

```bash
INCR counter      # Increment by 1
INCRBY counter 5  # Increment by 5
```

### Q15: How do you extend a session's TTL without reading it?
**A:** Use `EXPIRE`:
```bash
EXPIRE session:abc123 1800  # Extend to 1800 seconds
```
Or `GETEX` to get and extend atomically:
```bash
GETEX session:abc123 EX 1800
```

**Next:** Lists & Sets!