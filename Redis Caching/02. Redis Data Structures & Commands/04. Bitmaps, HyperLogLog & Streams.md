# 04. Bitmaps, HyperLogLog & Streams

## Redis Bitmaps

**Bitmaps** are bit arrays, efficient for tracking boolean states.

**Not a separate data type** - uses String internally, with bit-level operations.

**Characteristics:**
- Extremely memory-efficient (1 bit per element)
- Fast bitwise operations
- Up to 2^32 bits (512 MB)

**Use Cases:**
- User activity tracking (daily active users)
- Feature flags
- Attendance tracking
- Real-time analytics
- Bloom filters

---

## Bitmap Commands

### SETBIT - Set Bit

```bash
# Set bit at position (0 or 1)
SETBIT user:1001:visited 0 1  # Day 0: visited
SETBIT user:1001:visited 1 1  # Day 1: visited
SETBIT user:1001:visited 2 0  # Day 2: not visited
SETBIT user:1001:visited 5 1  # Day 5: visited

# Returns previous value
SETBIT key 10 1
# (integer) 0 (previous value)
```

### GETBIT - Get Bit

```bash
GETBIT user:1001:visited 0
# (integer) 1 (visited)

GETBIT user:1001:visited 2
# (integer) 0 (not visited)

GETBIT user:1001:visited 100
# (integer) 0 (default for unset bits)
```

### BITCOUNT - Count Set Bits

```bash
# Count total set bits
BITCOUNT user:1001:visited
# (integer) 3 (visited 3 days)

# Count in range (byte range, not bit range)
BITCOUNT user:1001:visited 0 0  # First byte (bits 0-7)
```

### BITPOS - Find First Set/Unset Bit

```bash
# Find first 1 bit
BITPOS user:1001:visited 1
# (integer) 0 (first set bit at position 0)

# Find first 0 bit
BITPOS user:1001:visited 0
# (integer) 2 (first unset bit at position 2)

# Find in range
BITPOS user:1001:visited 1 0 1  # Search in first 2 bytes
```

### BITOP - Bitwise Operations

```bash
# AND operation
BITOP AND result key1 key2

# OR operation
BITOP OR result key1 key2

# XOR operation
BITOP XOR result key1 key2

# NOT operation
BITOP NOT result key1
```

---

## Bitmap Use Cases

### 1. Daily Active Users (DAU)

```bash
# User 1001 active on day 0
SETBIT active:2024-12-30 1001 1

# User 1002 active
SETBIT active:2024-12-30 1002 1

# Count DAU
BITCOUNT active:2024-12-30
# (integer) 2

# Check if user was active
GETBIT active:2024-12-30 1001
# (integer) 1
```

### 2. Weekly Active Users (WAU)

```bash
# OR operation to find users active in week
BITOP OR active:week-1 active:2024-12-24 active:2024-12-25 ... active:2024-12-30

# Count WAU
BITCOUNT active:week-1
```

### 3. User Retention

```bash
# Users active on Day 1
SETBIT active:day1 1001 1
SETBIT active:day1 1002 1
SETBIT active:day1 1003 1

# Users active on Day 7
SETBIT active:day7 1001 1
SETBIT active:day7 1002 1

# Users retained (active on both days)
BITOP AND retained:day1-day7 active:day1 active:day7
BITCOUNT retained:day1-day7
# (integer) 2 (retention: 2/3 = 66.67%)
```

### 4. Feature Flags

```bash
# User 1001: feature flags (bit 0 = premium, bit 1 = beta, bit 2 = admin)
SETBIT user:1001:flags 0 1  # Premium enabled
SETBIT user:1001:flags 2 1  # Admin enabled

# Check if user has premium
GETBIT user:1001:flags 0
# (integer) 1
```

### 5. Attendance Tracking

```bash
# Student 101 attendance (365 days)
SETBIT attendance:student:101 0 1   # Day 0: present
SETBIT attendance:student:101 1 1   # Day 1: present
SETBIT attendance:student:101 2 0   # Day 2: absent

# Count attendance
BITCOUNT attendance:student:101
# (integer) 200 (present 200 days)
```

---

## Redis HyperLogLog

**HyperLogLog (HLL)** is a probabilistic data structure for counting unique elements.

**Characteristics:**
- Very memory-efficient (12 KB for billions of elements)
- Approximate count (0.81% error rate)
- Can't retrieve elements (count-only)
- Ideal for unique visitor counting

**Use Cases:**
- Unique visitor counting
- Unique IP addresses
- Unique search queries
- Cardinality estimation

---

## HyperLogLog Commands

### PFADD - Add Elements

```bash
# Add single element
PFADD unique:visitors "user123"
# (integer) 1 (cardinality changed)

# Add multiple elements
PFADD unique:visitors "user456" "user789" "user123"
# (integer) 1 (2 new unique elements)
```

### PFCOUNT - Count Unique Elements

```bash
PFCOUNT unique:visitors
# (integer) 3 (approximate count)

# Count across multiple HLLs
PFCOUNT unique:visitors:day1 unique:visitors:day2
# Combined unique count
```

### PFMERGE - Merge HyperLogLogs

```bash
# Merge multiple HLLs
PFMERGE unique:visitors:week unique:visitors:day1 unique:visitors:day2 ... unique:visitors:day7

# Count weekly unique visitors
PFCOUNT unique:visitors:week
```

---

## HyperLogLog Use Cases

### 1. Unique Page Visitors

```bash
# Track unique visitors per page
PFADD page:123:visitors "user1001"
PFADD page:123:visitors "user1002"
PFADD page:123:visitors "user1001"  # Duplicate, ignored

# Count unique visitors
PFCOUNT page:123:visitors
# (integer) 2
```

### 2. Daily/Weekly/Monthly Unique Users

```bash
# Daily unique users
PFADD unique:2024-12-30 "user1001" "user1002"

# Weekly unique users
PFMERGE unique:week-52 unique:2024-12-24 ... unique:2024-12-30
PFCOUNT unique:week-52

# Monthly unique users
PFMERGE unique:2024-12 unique:2024-12-01 ... unique:2024-12-31
PFCOUNT unique:2024-12
```

### 3. Unique Search Queries

```bash
# Track unique searches
PFADD unique:searches "redis cache"
PFADD unique:searches "node.js tutorial"
PFADD unique:searches "redis cache"  # Duplicate

# Count unique searches
PFCOUNT unique:searches
# (integer) 2
```

---

## Bitmaps vs HyperLogLog

| Feature | Bitmaps | HyperLogLog |
|---------|---------|-------------|
| **Accuracy** | 100% exact | ~99% (0.81% error) |
| **Memory** | 1 bit per ID | 12 KB (fixed) |
| **Max Elements** | Limited by ID range | Billions |
| **Check Membership** | Yes (GETBIT) | No |
| **Retrieve Elements** | Yes | No |
| **Use Case** | Known ID range | Unknown/huge range |

**Example:**
- **Bitmap**: 1 million users = 125 KB
- **HyperLogLog**: 1 billion users = 12 KB

---

## Redis Streams

**Streams** are append-only log data structures, similar to Kafka.

**Characteristics:**
- Time-ordered entries
- Each entry has unique ID (timestamp-sequence)
- Consumer groups for message distribution
- Message acknowledgment

**Use Cases:**
- Event sourcing
- Activity feeds
- Message queues
- Audit logs
- Real-time analytics

---

## Stream Commands

### XADD - Add Entry

```bash
# Add entry with auto-generated ID
XADD mystream * field1 value1 field2 value2
# "1735689600000-0" (timestamp-sequence)

# Add with specific ID
XADD mystream 1735689600000-0 sensor "temperature" value "25.5"

# Add with max length (trimming)
XADD mystream MAXLEN 1000 * event "user_login" userId "1001"
```

### XRANGE - Get Entries by ID Range

```bash
# Get all entries
XRANGE mystream - +

# Get entries in range
XRANGE mystream 1735689600000-0 1735689700000-0

# Get first 10
XRANGE mystream - + COUNT 10
```

### XREVRANGE - Get Entries (Reverse)

```bash
# Get latest 10 entries
XREVRANGE mystream + - COUNT 10
```

### XREAD - Read Entries

```bash
# Read from beginning
XREAD STREAMS mystream 0

# Read new entries (blocking)
XREAD BLOCK 5000 STREAMS mystream $
# Blocks for 5 seconds waiting for new entries

# Read from multiple streams
XREAD STREAMS stream1 stream2 0-0 0-0
```

### XLEN - Get Stream Length

```bash
XLEN mystream
# (integer) 100
```

### XDEL - Delete Entry

```bash
XDEL mystream 1735689600000-0
```

### XTRIM - Trim Stream

```bash
# Keep only last 1000 entries
XTRIM mystream MAXLEN 1000

# Approximate trimming (more efficient)
XTRIM mystream MAXLEN ~ 1000
```

---

## Stream Consumer Groups

### XGROUP CREATE - Create Consumer Group

```bash
# Create group starting from beginning
XGROUP CREATE mystream mygroup 0

# Create group starting from latest
XGROUP CREATE mystream mygroup $

# Create with MKSTREAM (create stream if doesn't exist)
XGROUP CREATE mystream mygroup $ MKSTREAM
```

### XREADGROUP - Read as Consumer

```bash
# Read as consumer 'consumer1' in group 'mygroup'
XREADGROUP GROUP mygroup consumer1 STREAMS mystream >

# Read with blocking
XREADGROUP GROUP mygroup consumer1 BLOCK 5000 STREAMS mystream >

# Read multiple messages
XREADGROUP GROUP mygroup consumer1 COUNT 10 STREAMS mystream >
```

### XACK - Acknowledge Message

```bash
# Acknowledge message processing
XACK mystream mygroup 1735689600000-0
```

### XPENDING - Check Pending Messages

```bash
# Get pending messages
XPENDING mystream mygroup

# Get detailed pending info
XPENDING mystream mygroup - + 10
```

---

## Stream Use Cases

### 1. Event Sourcing

```bash
# Add events
XADD orders:stream * orderId "123" event "created" userId "1001"
XADD orders:stream * orderId "123" event "paid" amount "99.99"
XADD orders:stream * orderId "123" event "shipped" trackingId "ABC123"

# Replay events
XRANGE orders:stream - +
```

### 2. Activity Feed

```bash
# Add activity
XADD user:1001:feed * type "post" postId "456" action "created"
XADD user:1001:feed * type "comment" commentId "789" postId "456"

# Get latest 10 activities
XREVRANGE user:1001:feed + - COUNT 10
```

### 3. Message Queue with Consumer Group

```bash
# Create consumer group
XGROUP CREATE tasks:stream workers 0

# Producer: Add tasks
XADD tasks:stream * task "send_email" to "user@example.com"

# Consumer 1: Process tasks
XREADGROUP GROUP workers worker1 COUNT 1 STREAMS tasks:stream >
# Process task...
XACK tasks:stream workers 1735689600000-0

# Consumer 2: Process tasks
XREADGROUP GROUP workers worker2 COUNT 1 STREAMS tasks:stream >
```

---

## Summary

**Bitmaps:**
- Commands: `SETBIT`, `GETBIT`, `BITCOUNT`, `BITOP`
- Use cases: DAU/MAU tracking, feature flags, attendance
- Memory: 1 bit per element
- Exact counting

**HyperLogLog:**
- Commands: `PFADD`, `PFCOUNT`, `PFMERGE`
- Use cases: Unique visitors, cardinality estimation
- Memory: Fixed 12 KB
- Approximate counting (~0.81% error)

**Streams:**
- Commands: `XADD`, `XREAD`, `XREADGROUP`, `XACK`
- Use cases: Event sourcing, activity feeds, message queues
- Time-ordered log structure
- Consumer groups for distributed processing

---

## Interview Questions & Answers

### Q1: What's the difference between Bitmaps and HyperLogLog?
**A:**

| Feature | Bitmaps | HyperLogLog |
|---------|---------|-------------|
| **Accuracy** | Exact | ~99% (0.81% error) |
| **Memory** | 1 bit Ã— ID count | Fixed 12 KB |
| **Check membership** | Yes | No |
| **Best for** | Known ID range | Huge/unknown range |

**Example:** 1M users = 125 KB (bitmap) vs 12 KB (HLL)

### Q2: How do you track daily active users with Bitmaps?
**A:**
```bash
# User 1001 active on Dec 30
SETBIT active:2024-12-30 1001 1

# Count DAU
BITCOUNT active:2024-12-30

# Check if specific user was active
GETBIT active:2024-12-30 1001
```

### Q3: What's the memory overhead of HyperLogLog?
**A:** **Fixed 12 KB** regardless of element count. Can count billions of unique elements with same memory usage.

### Q4: Can you retrieve elements from HyperLogLog?
**A:** **No**. HyperLogLog only provides count, not the actual elements. If you need to retrieve elements, use Sets instead.

### Q5: How do you calculate user retention with Bitmaps?
**A:**
```bash
# Day 1 active users
SETBIT active:day1 1001 1
SETBIT active:day1 1002 1
SETBIT active:day1 1003 1

# Day 7 active users
SETBIT active:day7 1001 1
SETBIT active:day7 1002 1

# Retained users (active on both)
BITOP AND retained active:day1 active:day7
BITCOUNT retained
# Retention = retained / day1 users
```

### Q6: What are Redis Streams used for?
**A:** Streams are append-only logs for:
- Event sourcing
- Activity feeds
- Message queues (with consumer groups)
- Audit logs
- Time-series data

Similar to Kafka but simpler.

### Q7: What's the structure of a Stream entry ID?
**A:** `timestamp-sequence`, e.g., `1735689600000-0`:
- **1735689600000**: Unix timestamp (ms)
- **0**: Sequence number (for entries with same timestamp)

### Q8: How do consumer groups work in Streams?
**A:** Consumer groups allow multiple consumers to process messages in parallel:
```bash
# Create group
XGROUP CREATE mystream workers 0

# Consumer 1 reads
XREADGROUP GROUP workers worker1 STREAMS mystream >

# Consumer 2 reads (gets different messages)
XREADGROUP GROUP workers worker2 STREAMS mystream >

# Acknowledge after processing
XACK mystream workers <entry-id>
```

### Q9: What's the error rate of HyperLogLog?
**A:** **0.81% standard error**. For example, if actual unique count is 1,000,000, HLL might return between 991,900 and 1,008,100.

### Q10: How do you merge multiple HyperLogLogs?
**A:** Use `PFMERGE`:
```bash
PFMERGE weekly day1 day2 day3 day4 day5 day6 day7
PFCOUNT weekly  # Unique users across week
```

### Q11: Can you delete entries from a Stream?
**A:** Yes, with `XDEL`:
```bash
XDEL mystream 1735689600000-0
```
But Streams are designed to be append-only, so deletion is uncommon.

### Q12: What's BITOP used for?
**A:** Perform bitwise operations (AND, OR, XOR, NOT) on bitmaps:
```bash
# Users active on both Day 1 and Day 2
BITOP AND active:both active:day1 active:day2

# Users active on Day 1 or Day 2
BITOP OR active:either active:day1 active:day2
```

### Q13: How do you trim a Stream to keep only recent entries?
**A:** Use `XTRIM`:
```bash
XTRIM mystream MAXLEN 1000  # Keep last 1000 entries

# Or when adding
XADD mystream MAXLEN 1000 * field value
```

### Q14: What's the time complexity of PFADD?
**A:** **O(1)** - constant time regardless of set size.

### Q15: How do you check pending messages in a Stream consumer group?
**A:** Use `XPENDING`:
```bash
XPENDING mystream mygroup
# Returns: count, min ID, max ID, consumers

XPENDING mystream mygroup - + 10
# Returns: detailed info for 10 pending messages
```

**Next:** Keys, TTL & Expiration!