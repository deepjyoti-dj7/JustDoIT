# 05. Keys, TTL & Expiration

## Redis Keys

**Keys** are unique identifiers for values in Redis.

**Characteristics:**
- Binary-safe strings (can contain any byte sequence)
- Case-sensitive
- Max size: 512 MB (but keep them short)
- Use meaningful naming conventions

---

## Key Naming Conventions

### Best Practices

```bash
# ‚úÖ Good: Use colons for hierarchy
user:1001:profile
user:1001:sessions
product:123:details
order:456:items

# ‚úÖ Good: Descriptive names
cache:api:weather:NYC
session:abc123
ratelimit:user:1001

# ‚ùå Bad: Generic names
data1
temp
x

# ‚ùå Bad: Too long
this_is_a_very_long_key_name_that_wastes_memory_and_is_hard_to_read
```

### Common Patterns

```bash
# Object type:ID:attribute
user:1001:name
user:1001:email

# Object type:ID (hash)
user:1001  # Contains {name, email, age}

# Collection:attribute
users:active
products:trending

# Namespace:object:ID
app1:session:abc123
app1:cache:user:1001
```

---

## Key Commands

### EXISTS - Check Key Existence

```bash
EXISTS user:1001
# (integer) 1 (exists)

EXISTS nonexistent
# (integer) 0 (doesn't exist)

# Check multiple keys
EXISTS key1 key2 key3
# (integer) 2 (2 out of 3 exist)
```

### TYPE - Get Key Type

```bash
SET name "John"
TYPE name
# string

LPUSH mylist "a"
TYPE mylist
# list

SADD myset "a"
TYPE myset
# set

ZADD myzset 1 "a"
TYPE myzset
# zset

HSET myhash field value
TYPE myhash
# hash

TYPE nonexistent
# none
```

### KEYS - List Keys (Avoid in Production!)

```bash
# Get all keys (DANGEROUS in production!)
KEYS *

# Get keys matching pattern
KEYS user:*
KEYS user:100?
KEYS user:*:name

# Patterns:
# * - any characters
# ? - single character
# [abc] - any of a, b, c
# [^a] - not a
# [a-z] - range
```

**‚ö†Ô∏è Warning:** `KEYS` blocks server. Use `SCAN` in production!

### SCAN - Iterate Keys (Production-Safe)

```bash
# Scan with cursor
SCAN 0 MATCH user:* COUNT 100
# Returns: ["cursor", ["key1", "key2", ...]]

# Example iteration
SCAN 0 MATCH user:* COUNT 100
# 1) "17"
# 2) ["user:1001", "user:1002", ...]

SCAN 17 MATCH user:* COUNT 100
# 1) "0"  (cursor 0 = end)
# 2) ["user:1050", ...]
```

### DEL - Delete Keys

```bash
# Delete single key
DEL user:1001
# (integer) 1 (deleted)

# Delete multiple keys
DEL key1 key2 key3
# (integer) 3 (deleted count)

DEL nonexistent
# (integer) 0 (nothing deleted)
```

### UNLINK - Async Delete

```bash
# Delete asynchronously (non-blocking)
UNLINK large_key
# (integer) 1

# Better for large keys (lists, sets, hashes)
UNLINK huge_list huge_hash
```

**Difference:**
- `DEL`: Blocks until deleted (synchronous)
- `UNLINK`: Immediate return (deletes in background)

### RENAME - Rename Key

```bash
# Rename key
RENAME oldkey newkey
# OK

# Rename only if newkey doesn't exist
RENAMENX oldkey newkey
# (integer) 1 (renamed)
# (integer) 0 (newkey exists, not renamed)
```

### RANDOMKEY - Get Random Key

```bash
RANDOMKEY
# "user:1001" (random key)
```

### DUMP / RESTORE - Serialize/Deserialize

```bash
# Dump key to serialized string
DUMP user:1001
# "\x00\x04John\x09\x00\x..."

# Restore from dump
RESTORE user:1002 0 "\x00\x04John\x09\x00\x..."
# OK

# Restore with TTL (milliseconds)
RESTORE user:1003 60000 "\x00\x04John\x09\x00\x..."
```

---

## TTL (Time To Live)

### EXPIRE - Set Expiration in Seconds

```bash
SET cache:data "value"

# Expire in 60 seconds
EXPIRE cache:data 60
# (integer) 1 (success)

EXPIRE nonexistent 60
# (integer) 0 (key doesn't exist)
```

### EXPIREAT - Expire at Unix Timestamp

```bash
# Expire at specific Unix timestamp (seconds)
EXPIREAT cache:data 1735689600
# (integer) 1
```

### PEXPIRE - Expire in Milliseconds

```bash
# Expire in 60000 milliseconds (60 seconds)
PEXPIRE cache:data 60000
# (integer) 1
```

### PEXPIREAT - Expire at Unix Timestamp (ms)

```bash
PEXPIREAT cache:data 1735689600000
# (integer) 1
```

### TTL - Check Time To Live (seconds)

```bash
TTL cache:data
# (integer) 55 (55 seconds remaining)

TTL persistent_key
# (integer) -1 (no expiration)

TTL nonexistent
# (integer) -2 (key doesn't exist)
```

**Return Values:**
- **N**: Seconds remaining
- **-1**: No expiration set
- **-2**: Key doesn't exist

### PTTL - Check Time To Live (milliseconds)

```bash
PTTL cache:data
# (integer) 55432 (milliseconds remaining)
```

### PERSIST - Remove Expiration

```bash
# Remove TTL, make key persistent
PERSIST cache:data
# (integer) 1 (TTL removed)

PERSIST persistent_key
# (integer) 0 (no TTL to remove)
```

---

## Setting Keys with TTL

### SET with Expiration

```bash
# Set with expiration (seconds)
SET cache:data "value" EX 60

# Set with expiration (milliseconds)
SET cache:data "value" PX 60000

# Set with expiration at timestamp
SET cache:data "value" EXAT 1735689600

# Set with expiration at timestamp (ms)
SET cache:data "value" PXAT 1735689600000

# Combine with NX/XX
SET cache:data "value" EX 60 NX  # Set only if doesn't exist
SET cache:data "value" EX 60 XX  # Set only if exists
```

### SETEX - Set with Expiration

```bash
# Set with expiration (seconds)
SETEX cache:data 60 "value"
# OK

# Equivalent to:
SET cache:data "value" EX 60
```

### GETEX - Get and Set/Update Expiration

```bash
# Get and set expiration
GETEX cache:data EX 60
# "value"

# Get and remove expiration
GETEX cache:data PERSIST
# "value"

# Get and expire at timestamp
GETEX cache:data EXAT 1735689600
```

---

## Expiration Behavior

### How Expiration Works

1. **Passive Expiration**: When key is accessed, Redis checks TTL
2. **Active Expiration**: Background task checks random keys every 100ms

### Operations that Remove TTL

```bash
SET cache:data "value" EX 60

# These operations REMOVE TTL:
SET cache:data "new_value"  # TTL removed!
DEL cache:data
RENAME cache:data new_key   # TTL removed!

# These operations PRESERVE TTL:
APPEND cache:data "more"
INCR counter
LPUSH mylist "item"
HSET myhash field value
```

### Expiration and Replication

- Replicas don't expire keys independently
- Master sends DEL command when key expires
- Replicas wait for DEL from master

---

## Key Patterns and Use Cases

### 1. Session Management

```bash
# Create session with 30-minute expiration
SET session:abc123 '{"userId":1001,"role":"admin"}' EX 1800

# Check if session exists
EXISTS session:abc123

# Extend session on activity
EXPIRE session:abc123 1800

# Delete session (logout)
DEL session:abc123
```

### 2. Cache with TTL

```bash
# Cache API response for 5 minutes
SET cache:api:weather:NYC '{"temp":25,"condition":"sunny"}' EX 300

# Get cached data
GET cache:api:weather:NYC

# Check cache TTL
TTL cache:api:weather:NYC
```

### 3. Rate Limiting

```bash
# Track API requests (1-minute window)
SET ratelimit:user:1001 0 EX 60
INCR ratelimit:user:1001

# Check if rate limited
count = GET ratelimit:user:1001
if count > 100:
    reject_request()
```

### 4. Temporary Locks

```bash
# Acquire lock with auto-expiration
SET lock:resource1 "process1" NX EX 10
# (nil) if lock held by another process

# Do work...

# Release lock
DEL lock:resource1
```

### 5. One-Time Tokens

```bash
# Create password reset token (1-hour expiration)
SET token:reset:xyz123 "user:1001" EX 3600

# Verify token
user_id = GET token:reset:xyz123
if user_id:
    reset_password(user_id)
    DEL token:reset:xyz123  # Token used, delete it
```

---

## Key Space Management

### DBSIZE - Count Keys

```bash
DBSIZE
# (integer) 10000 (total keys)
```

### FLUSHDB - Delete All Keys in Database

```bash
# Delete all keys in current database
FLUSHDB
# OK

# Async version (non-blocking)
FLUSHDB ASYNC
```

### FLUSHALL - Delete All Keys in All Databases

```bash
# Delete all keys in all databases
FLUSHALL
# OK

# Async version
FLUSHALL ASYNC
```

---

## Performance Considerations

### Time Complexity

| Command | Time Complexity |
|---------|----------------|
| EXISTS | O(1) |
| TYPE | O(1) |
| KEYS | O(N) - AVOID! |
| SCAN | O(1) per call |
| DEL | O(N) - N = keys |
| UNLINK | O(1) (async) |
| TTL/PTTL | O(1) |
| EXPIRE | O(1) |

### Best Practices

1. **Use SCAN, not KEYS**:
```bash
# ‚ùå Bad
KEYS user:*  # Blocks server

# ‚úÖ Good
SCAN 0 MATCH user:* COUNT 100
```

2. **Use UNLINK for large keys**:
```bash
# ‚ùå Bad (blocks)
DEL huge_list

# ‚úÖ Good (non-blocking)
UNLINK huge_list
```

3. **Set TTL when creating keys**:
```bash
# ‚ùå Bad (two commands)
SET cache:data "value"
EXPIRE cache:data 60

# ‚úÖ Good (one command)
SET cache:data "value" EX 60
```

4. **Use short, meaningful key names**:
```bash
# ‚ùå Bad
this:is:a:very:long:key:name:that:wastes:memory

# ‚úÖ Good
user:1001:profile
```

---

## Summary

**Key Commands:**
- `EXISTS`, `TYPE`, `DEL`, `UNLINK`
- `KEYS` (dev only), `SCAN` (production)
- `RENAME`, `DUMP`, `RESTORE`

**TTL Commands:**
- `EXPIRE`, `EXPIREAT`, `PEXPIRE`, `PEXPIREAT`
- `TTL`, `PTTL`, `PERSIST`
- `SET ... EX`, `SETEX`, `GETEX`

**Best Practices:**
- Use colon-separated hierarchical naming
- Use `SCAN` instead of `KEYS` in production
- Set TTL when creating keys
- Use `UNLINK` for large keys

---

## Interview Questions & Answers

### Q1: What's the difference between DEL and UNLINK?
**A:**
- **DEL**: Synchronous, blocks until deleted
- **UNLINK**: Asynchronous, deletes in background (non-blocking)

```bash
DEL huge_list     # Blocks server
UNLINK huge_list  # Returns immediately
```
Use `UNLINK` for large keys in production.

### Q2: Why should you avoid KEYS in production?
**A:** `KEYS` blocks the server while scanning all keys. Use `SCAN` instead:
```bash
# ‚ùå KEYS - blocks server
KEYS user:*

# ‚úÖ SCAN - non-blocking, iterates
SCAN 0 MATCH user:* COUNT 100
```

### Q3: What does TTL -1 and -2 mean?
**A:**
- **-1**: Key exists but has no expiration
- **-2**: Key doesn't exist
- **N**: Key expires in N seconds

```bash
TTL persistent_key  # -1
TTL expired_key     # -2
TTL cache:data      # 55
```

### Q4: How do you set a key with expiration in one command?
**A:** Use `SET` with `EX` option:
```bash
SET cache:data "value" EX 60  # Expires in 60 seconds
SET cache:data "value" PX 60000  # Expires in 60000 ms
```

### Q5: What operations remove TTL from a key?
**A:** Operations that **replace** the key:
```bash
SET key "value" EX 60
SET key "new_value"  # TTL removed!
RENAME key newkey    # TTL removed!
```

Operations that **modify** preserve TTL:
```bash
APPEND key "more"  # TTL preserved
INCR counter       # TTL preserved
```

### Q6: How does SCAN work?
**A:** `SCAN` returns a cursor and partial results:
```bash
SCAN 0 MATCH user:* COUNT 100
# Returns: ["cursor", [keys]]

# If cursor is 0, iteration complete
# Otherwise, use returned cursor for next scan
```

### Q7: What's the recommended key naming convention?
**A:** Use colon-separated hierarchical structure:
```bash
object:id:attribute
user:1001:profile
user:1001:sessions
product:123:details

namespace:object:id
app1:cache:user:1001
```

### Q8: How do you check if a key exists?
**A:** Use `EXISTS`:
```bash
EXISTS user:1001
# (integer) 1 (exists)
# (integer) 0 (doesn't exist)
```

### Q9: What's the time complexity of KEYS?
**A:** **O(N)** where N is total keys in database. Blocks server, avoid in production!

### Q10: How do you remove expiration from a key?
**A:** Use `PERSIST`:
```bash
SET cache:data "value" EX 60
PERSIST cache:data
TTL cache:data
# (integer) -1 (no expiration)
```

### Q11: What's GETEX used for?
**A:** Get value and set/update expiration atomically:
```bash
GETEX cache:data EX 60      # Get and refresh TTL
GETEX cache:data PERSIST    # Get and remove TTL
```

### Q12: How do you implement a distributed lock with TTL?
**A:** Use `SET` with `NX` and `EX`:
```bash
SET lock:resource1 "unique_id" NX EX 10
# Returns OK if lock acquired
# Auto-expires in 10 seconds (prevents deadlock)
```

### Q13: What's the difference between EXPIRE and EXPIREAT?
**A:**
- **EXPIRE**: Relative time (seconds from now)
- **EXPIREAT**: Absolute time (Unix timestamp)

```bash
EXPIRE key 60              # Expires in 60 seconds
EXPIREAT key 1735689600    # Expires at specific time
```

### Q14: How do you count total keys in Redis?
**A:** Use `DBSIZE`:
```bash
DBSIZE
# (integer) 10000
```
O(1) operation, fast even with millions of keys.

### Q15: What's the maximum key size in Redis?
**A:** **512 MB**, but keep keys short (typically < 1 KB) for performance and memory efficiency.

**üéâ Redis Data Structures & Commands Complete! All 5 files done!**